var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn2) {
  return fn2();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn2) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn2);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn2) {
  return definition[1] && fn2 ? assign($$scope.ctx.slice(), definition[1](fn2(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn2) {
  if (definition[2] && fn2) {
    const lets = definition[2](fn2(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys2) {
  const rest = {};
  keys2 = new Set(keys2);
  for (const k in props)
    if (!keys2.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    return this._observer ?? (this._observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        this._listeners.get(entry.target)?.(entry);
      }
    }));
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn2) {
  return function(event) {
    event.preventDefault();
    return fn2.call(this, event);
  };
}
function stop_propagation(fn2) {
  return function(event) {
    event.stopPropagation();
    return fn2.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
var always_set_through_set_attribute = ["width", "height"];
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function set_custom_element_data_map(node, data_map) {
  Object.keys(data_map).forEach((key) => {
    set_custom_element_data(node, key, data_map[key]);
  });
}
function set_custom_element_data(node, prop, value) {
  const lower = prop.toLowerCase();
  if (lower in node) {
    node[lower] = typeof node[lower] === "boolean" && value === "" ? true : value;
  } else if (prop in node) {
    node[prop] = typeof node[prop] === "boolean" && value === "" ? true : value;
  } else {
    attr(node, prop, value);
  }
}
function set_dynamic_element_data(tag) {
  return /-/.test(tag) ? set_custom_element_data_map : set_attributes;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
var HtmlTag = class {
  constructor(is_svg = false) {
    /**
     * @private
     * @default false
     */
    __publicField(this, "is_svg", false);
    /** parent for creating node */
    __publicField(this, "e");
    /** html tag nodes */
    __publicField(this, "n");
    /** target */
    __publicField(this, "t");
    /** anchor */
    __publicField(this, "a");
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target.nodeName
        );
      else
        this.e = element(
          /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? "TEMPLATE" : target.nodeName
        );
      this.t = target.tagName !== "TEMPLATE" ? target : (
        /** @type {HTMLTemplateElement} */
        target.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
};
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn2) {
  get_current_component().$$.on_mount.push(fn2);
}
function onDestroy(fn2) {
  get_current_component().$$.on_destroy.push(fn2);
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn2) => fn2.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn2) {
  render_callbacks.push(fn2);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance13, create_fragment14, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance13 ? instance13(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment14 ? create_fragment14($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      this.$$c?.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  const type = props_definition[prop]?.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/orderedmap/dist/index.js
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self.find(key), content = self.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey)
        content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size)
      return this;
    return new OrderedMap(map2.content.concat(this.subtract(map2).content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size)
      return this;
    return new OrderedMap(this.subtract(map2).content.concat(map2.content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map2) {
    var result = this;
    map2 = OrderedMap.from(map2);
    for (var i = 0; i < map2.content.length; i += 2)
      result = result.remove(map2.content[i]);
    return result;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap)
    return value;
  var content = [];
  if (value)
    for (var prop in value)
      content.push(prop, value[prop]);
  return new OrderedMap(content);
};
var dist_default = OrderedMap;

// node_modules/prosemirror-model/dist/index.js
function findDiffStart(a, b, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment = class _Fragment {
  /**
  @internal
  */
  constructor(content, size) {
    this.content = content;
    this.size = size || 0;
    if (size == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from2, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end2 = pos + child.nodeSize;
      if (end2 > from2 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start2 = pos + 1;
        child.nodesBetween(Math.max(0, from2 - start2), Math.min(child.content.size, to - start2), f, nodeStart + start2);
      }
      pos = end2;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from2, to, blockSeparator, leafText) {
    let text2 = "", first2 = true;
    this.nodesBetween(from2, to, (node, pos) => {
      let nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first2)
          first2 = false;
        else
          text2 += blockSeparator;
      }
      text2 += nodeText;
    }, 0);
    return text2;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first2)) {
      content[content.length - 1] = last.withText(last.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new _Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from2, to = this.size) {
    if (from2 == 0 && to == this.size)
      return this;
    let result = [], size = 0;
    if (to > from2)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end2 = pos + child.nodeSize;
        if (end2 > from2) {
          if (pos < from2 || end2 > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size += child.nodeSize;
        }
        pos = end2;
      }
    return new _Fragment(result, size);
  }
  /**
  @internal
  */
  cutByIndex(from2, to) {
    if (from2 == to)
      return _Fragment.empty;
    if (from2 == 0 && to == this.content.length)
      return this;
    return new _Fragment(this.content.slice(from2, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index, node) {
    let current = this.content[index];
    if (current == node)
      return this;
    let copy2 = this.content.slice();
    let size = this.size + node.nodeSize - current.nodeSize;
    copy2[index] = node;
    return new _Fragment(copy2, size);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node) {
    return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node) {
    return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index) {
    let found2 = this.content[index];
    if (!found2)
      throw new RangeError("Index " + index + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index) {
    return this.content[index] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. (Not public.)
  */
  findIndex(pos, round2 = -1) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end2 = curPos + cur.nodeSize;
      if (end2 >= pos) {
        if (end2 == pos || round2 > 0)
          return retIndex(i + 1, end2);
        return retIndex(i, curPos);
      }
      curPos = end2;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema, value) {
    if (!value)
      return _Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new _Fragment(value.map(schema.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array) {
    if (!array.length)
      return _Fragment.empty;
    let joined, size = 0;
    for (let i = 0; i < array.length; i++) {
      let node = array[i];
      size += node.nodeSize;
      if (i && node.isText && array[i - 1].sameMarkup(node)) {
        if (!joined)
          joined = array.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new _Fragment(joined || array, size);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return _Fragment.empty;
    if (nodes instanceof _Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new _Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
Fragment.empty = new Fragment([], 0);
var found = { index: 0, offset: 0 };
function retIndex(index, offset2) {
  found.index = index;
  found.offset = offset2;
  return found;
}
function compareDeep(a, b) {
  if (a === b)
    return true;
  if (!(a && typeof a == "object") || !(b && typeof b == "object"))
    return false;
  let array = Array.isArray(a);
  if (Array.isArray(b) != array)
    return false;
  if (array) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compareDeep(a[i], b[i]))
        return false;
  } else {
    for (let p in a)
      if (!(p in b) || !compareDeep(a[p], b[p]))
        return false;
    for (let p in b)
      if (!(p in a))
        return false;
  }
  return true;
}
var Mark = class _Mark {
  /**
  @internal
  */
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set) {
    let copy2, placed = false;
    for (let i = 0; i < set.length; i++) {
      let other = set[i];
      if (this.eq(other))
        return set;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set.slice(0, i);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return set.slice(0, i).concat(set.slice(i + 1));
    return set;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    return type.create(json.attrs);
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a, b) {
    if (a == b)
      return true;
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].eq(b[i]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return _Mark.none;
    if (marks instanceof _Mark)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a, b) => a.type.rank - b.type.rank);
    return copy2;
  }
};
Mark.none = [];
var ReplaceError = class extends Error {
};
var Slice = class _Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new _Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from2, to) {
    return new _Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      return _Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new _Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new _Slice(fragment, openStart, openEnd);
  }
};
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from2, to) {
  let { index, offset: offset2 } = content.findIndex(from2), child = content.maybeChild(index);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset2 == from2 || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from2).append(content.cut(to));
  }
  if (index != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index, child.copy(removeRange(child.content, from2 - offset2 - 1, to - offset2 - 1)));
}
function insertInto(content, dist, insert2, parent) {
  let { index, offset: offset2 } = content.findIndex(dist), child = content.maybeChild(index);
  if (offset2 == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert2))
      return null;
    return content.cut(0, dist).append(insert2).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset2 - 1, insert2);
  return inner && content.replaceChild(index, child.copy(inner));
}
function replace($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index = $from.index(depth), node = $from.node(depth);
  if (index == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner = replaceOuter($from, $to, slice2, depth + 1);
    return node.copy(node.content.replaceChild(index, inner));
  } else if (!slice2.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
  } else {
    let { start: start2, end: end2 } = prepareSliceForReplace(slice2, $from);
    return close(node, replaceThreeWay($from, start2, end2, $to, depth));
  }
}
function checkJoin(main2, sub) {
  if (!sub.type.compatibleContent(main2.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
}
function joinable($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++)
    addNode(node.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node = parent.copy(slice2.content);
  for (let i = extra - 1; i >= 0; i--)
    node = $along.node(i).copy(Fragment.from(node));
  return {
    start: node.resolveNoCache(slice2.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
  };
}
var ResolvedPos = class _ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index = this.index(this.depth);
    if (index == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
    return dOff ? parent.child(index).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index).cut(0, dOff);
    return index == 0 ? null : this.parent.child(index - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index; i++)
      pos += node.child(i).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index = this.index();
    if (parent.content.size == 0)
      return Mark.none;
    if (this.textOffset)
      return parent.child(index).marks;
    let main2 = parent.maybeChild(index - 1), other = parent.maybeChild(index);
    if (!main2) {
      let tmp = main2;
      main2 = other;
      other = tmp;
    }
    let marks = main2.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc3, pos) {
    if (!(pos >= 0 && pos <= doc3.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start2 = 0, parentOffset = pos;
    for (let node = doc3; ; ) {
      let { index, offset: offset2 } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset2;
      path.push(node, index, start2 + offset2);
      if (!rem)
        break;
      node = node.child(index);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start2 += offset2 + 1;
    }
    return new _ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc3, pos) {
    for (let i = 0; i < resolveCache.length; i++) {
      let cached = resolveCache[i];
      if (cached.pos == pos && cached.doc == doc3)
        return cached;
    }
    let result = resolveCache[resolveCachePos] = _ResolvedPos.resolve(doc3, pos);
    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
    return result;
  }
};
var resolveCache = [];
var resolveCachePos = 0;
var resolveCacheSize = 12;
var NodeRange = class {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
};
var emptyAttrs = /* @__PURE__ */ Object.create(null);
var Node = class _Node {
  /**
  @internal
  */
  constructor(type, attrs, content, marks = Mark.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index) {
    return this.content.child(index);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index) {
    return this.content.maybeChild(index);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from2, to, f, startPos = 0) {
    this.content.nodesBetween(from2, to, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(from2, to, blockSeparator, leafText) {
    return this.content.textBetween(from2, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new _Node(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from2, to = this.content.size) {
    if (from2 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from2, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from2, to = this.content.size, includeParents = false) {
    if (from2 == to)
      return Slice.empty;
    let $from = this.resolve(from2), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start2 = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start2, $to.pos - start2);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from2, to, slice2) {
    return replace(this.resolve(from2), this.resolve(to), slice2);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node = this; ; ) {
      let { index, offset: offset2 } = node.content.findIndex(pos);
      node = node.maybeChild(index);
      if (!node)
        return null;
      if (offset2 == pos || node.isText)
        return node;
      pos -= offset2 + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index, offset: offset2 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index), index, offset: offset2 };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index, offset: offset2 } = this.content.findIndex(pos);
    if (offset2 < pos)
      return { node: this.content.child(index), index, offset: offset2 };
    let node = this.content.child(index - 1);
    return { node, index: index - 1, offset: offset2 - node.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from2, to, type) {
    let found2 = false;
    if (to > from2)
      this.nodesBetween(from2, to, (node) => {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from2, to, replacement = Fragment.empty, start2 = 0, end2 = replacement.childCount) {
    let one = this.contentMatchAt(from2).matchFragment(replacement, start2, end2);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start2; i < end2; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from2, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start2 = this.contentMatchAt(from2).matchType(type);
    let end2 = start2 && start2.matchFragment(this.content, to);
    return end2 ? end2.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise error when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    let copy2 = Mark.none;
    for (let i = 0; i < this.marks.length; i++)
      copy2 = this.marks[i].addToSet(copy2);
    if (!Mark.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n) => n.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = null;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment.fromJSON(schema, json.content);
    return schema.nodeType(json.type).create(json.attrs, content, marks);
  }
};
Node.prototype.text = void 0;
var TextNode = class _TextNode extends Node {
  /**
  @internal
  */
  constructor(type, attrs, content, marks) {
    super(type, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from2, to) {
    return this.text.slice(from2, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text2) {
    if (text2 == this.text)
      return this;
    return new _TextNode(this.type, this.attrs, text2, this.marks);
  }
  cut(from2 = 0, to = this.text.length) {
    if (from2 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from2, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
};
function wrapMarks(marks, str) {
  for (let i = marks.length - 1; i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str;
}
var ContentMatch = class _ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string, nodeTypes) {
    let stream = new TokenStream(string, nodeTypes);
    if (stream.next == null)
      return _ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type)
        return this.next[i].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start2 = 0, end2 = frag.childCount) {
    let cur = this;
    for (let i = start2; cur && i < end2; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type } = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j = 0; j < other.next.length; j++)
        if (this.next[i].type == other.next[j].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match, types) {
      let finished = match.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search(next, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n) {
    if (n >= this.next.length)
      throw new RangeError(`There's no ${n}th edge in this content match`);
    return this.next[n];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i = 0; i < m.next.length; i++)
        if (seen.indexOf(m.next[i].next) == -1)
          scan(m.next[i].next);
    }
    scan(this);
    return seen.map((m, i) => {
      let out = i + (m.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m.next.length; i2++)
        out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
      return out;
    }).join("\n");
  }
};
ContentMatch.empty = new ContentMatch(true);
var TokenStream = class {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
};
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max2 = parseNum(stream);
    else
      max2 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.groups.indexOf(name) > -1)
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    let edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next = compile(expr2.exprs[i], from2);
        if (i == expr2.exprs.length - 1)
          return next;
        connect(next, from2 = node());
      }
    } else if (expr2.type == "star") {
      let loop2 = node();
      edge(from2, loop2);
      connect(compile(expr2.expr, loop2), loop2);
      return [edge(loop2)];
    } else if (expr2.type == "plus") {
      let loop2 = node();
      connect(compile(expr2.expr, from2), loop2);
      connect(compile(expr2.expr, loop2), loop2);
      return [edge(loop2)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i = 0; i < expr2.min; i++) {
        let next = node();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next = node();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i = 0; i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set = out[i][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node2) == -1)
            set.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i = 0, work = [match]; i < work.length; i++) {
    let state = work[i], dead = !state.validEnd, nodes = [];
    for (let j = 0; j < state.next.length; j++) {
      let { type, next } = state.next[j];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults2 = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr2 = attrs[attrName];
    if (!attr2.hasDefault)
      return null;
    defaults2[attrName] = attr2.default;
  }
  return defaults2;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr2 = attrs[name];
      if (attr2.hasDefault)
        given = attr2.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function initAttrs(attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(attrs[name]);
  return result;
}
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs = null, content, marks) {
    content = Fragment.from(content);
    this.checkContent(content);
    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment.empty, true);
    if (!after)
      return null;
    return new Node(this, attrs, content.append(after), Mark.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type with the given attributes.
  */
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i);
      } else if (copy2) {
        copy2.push(marks[i]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new _NodeType(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _ in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
};
var Attribute = class {
  constructor(options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
  }
  get isRequired() {
    return !this.hasDefault;
  }
};
var MarkType = class _MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(spec.attrs);
    this.excluded = null;
    let defaults2 = defaultAttrs(this.attrs);
    this.instance = defaults2 ? new Mark(this, defaults2) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark(this, computeAttrs(this.attrs, attrs));
  }
  /**
  @internal
  */
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set) {
    for (var i = 0; i < set.length; i++)
      if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
    return set;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (set[i].type == this)
        return set[i];
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
};
var Schema = class {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type, attrs = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text2, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text2, Mark.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(json) {
    return Node.fromJSON(this, json);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(json) {
    return Mark.fromJSON(this, json);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
};
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
var DOMParser2 = class _DOMParser {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    rules.forEach((rule) => {
      if (rule.tag)
        this.tags.push(rule);
      else if (rule.style)
        this.styles.push(rule);
    });
    this.normalizeLists = !this.tags.some((r2) => {
      if (!/^(ul|ol)\b/.test(r2.tag) || !r2.node)
        return false;
      let node = schema.nodes[r2.node];
      return node.contentMatch.matchType(node);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, options.from, options.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, options.from, options.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style2 = rule.style;
      if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema) {
    let result = [];
    function insert2(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert2(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert2(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new _DOMParser(schema, _DOMParser.schemaRules(schema)));
  }
};
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1;
var OPT_PRESERVE_WS_FULL = 2;
var OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
var NodeContext = class {
  constructor(type, attrs, marks, pendingMarks, solid, match, options) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.pendingMarks = pendingMarks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark.none;
    this.stashMarks = [];
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start2 = this.type.contentMatch, wrap2;
        if (wrap2 = start2.findWrapping(node.type)) {
          this.match = start2;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last = this.content[this.content.length - 1], m;
      if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        let text2 = last;
        if (last.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text2.withText(text2.text.slice(0, text2.text.length - m[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  popFromStashMark(mark) {
    for (let i = this.stashMarks.length - 1; i >= 0; i--)
      if (mark.eq(this.stashMarks[i]))
        return this.stashMarks.splice(i, 1)[0];
  }
  applyPending(nextType) {
    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {
      let mark = pending[i];
      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
        this.activeMarks = mark.addToSet(this.activeMarks);
        this.pendingMarks = mark.removeFromSet(this.pendingMarks);
      }
    }
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
};
var ParseContext = class {
  constructor(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom) {
    if (dom.nodeType == 3)
      this.addTextNode(dom);
    else if (dom.nodeType == 1)
      this.addElement(dom);
  }
  withStyleRules(dom, f) {
    let style2 = dom.getAttribute("style");
    if (!style2)
      return f();
    let marks = this.readStyles(parseStyles(style2));
    if (!marks)
      return;
    let [addMarks, removeMarks] = marks, top2 = this.top;
    for (let i = 0; i < removeMarks.length; i++)
      this.removePendingMark(removeMarks[i], top2);
    for (let i = 0; i < addMarks.length; i++)
      this.addPendingMark(addMarks[i]);
    f();
    for (let i = 0; i < addMarks.length; i++)
      this.removePendingMark(addMarks[i], top2);
    for (let i = 0; i < removeMarks.length; i++)
      this.addPendingMark(removeMarks[i]);
  }
  addTextNode(dom) {
    let value = dom.nodeValue;
    let top2 = this.top;
    if (top2.options & OPT_PRESERVE_WS_FULL || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!(top2.options & OPT_PRESERVE_WS)) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top2.content[top2.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (!(top2.options & OPT_PRESERVE_WS_FULL)) {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, matchAfter) {
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync, top2 = this.top, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (top2.content.length && top2.content[0].isInline && this.open) {
          this.open--;
          top2 = this.top;
        }
        sync = true;
        if (!top2.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom);
        return;
      }
      if (rule && rule.skip)
        this.addAll(dom);
      else
        this.withStyleRules(dom, () => this.addAll(dom));
      if (sync)
        this.sync(top2);
      this.needsBlock = oldNeedsBlock;
    } else {
      this.withStyleRules(dom, () => {
        this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : void 0);
      });
    }
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  }
  // Called for ignored nodes
  ignoreFallback(dom) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"));
  }
  // Run any style parser associated with the node's styles. Either
  // return an array of marks, or null to indicate some of the styles
  // had a rule with `ignore` set.
  readStyles(styles) {
    let add = Mark.none, remove = Mark.none;
    for (let i = 0; i < styles.length; i += 2) {
      for (let after = void 0; ; ) {
        let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
        if (!rule)
          break;
        if (rule.ignore)
          return null;
        if (rule.clearMark) {
          this.top.pendingMarks.concat(this.top.activeMarks).forEach((m) => {
            if (rule.clearMark(m))
              remove = m.addToSet(remove);
          });
        } else {
          add = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add);
        }
        if (rule.consuming === false)
          after = rule;
        else
          break;
      }
    }
    return [add, remove];
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, continueAfter) {
    let sync, nodeType, mark;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
      } else if (!this.insertNode(nodeType.create(rule.attrs))) {
        this.leafFallback(dom);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      mark = markType.create(rule.attrs);
      this.addPendingMark(mark);
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM);
    }
    if (sync && this.sync(startIn))
      this.open--;
    if (mark)
      this.removePendingMark(mark, startIn);
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, startIndex, endIndex) {
    let index = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end2 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end2; dom = dom.nextSibling, ++index) {
      this.findAtPoint(parent, index);
      this.addDOM(dom);
    }
    this.findAtPoint(parent, index);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node) {
    let route, sync;
    for (let depth = this.open; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid)
        break;
    }
    if (!route)
      return false;
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      this.enterInner(route[i], null, false);
    return true;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        this.enterInner(block);
    }
    if (this.findPlace(node)) {
      this.closeExtra();
      let top2 = this.top;
      top2.applyPending(node.type);
      if (top2.match)
        top2.match = top2.match.matchType(node.type);
      let marks = top2.activeMarks;
      for (let i = 0; i < node.marks.length; i++)
        if (!top2.type || top2.type.allowsMarkType(node.marks[i].type))
          marks = node.marks[i].addToSet(marks);
      top2.content.push(node.mark(marks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type, attrs, preserveWS) {
    let ok = this.findPlace(type.create(attrs));
    if (ok)
      this.enterInner(type, attrs, true, preserveWS);
    return ok;
  }
  // Open a node of the given type
  enterInner(type, attrs = null, solid = false, preserveWS) {
    this.closeExtra();
    let top2 = this.top;
    top2.applyPending(type);
    top2.match = top2.match && top2.match.matchType(type);
    let options = wsOptionsFor(type, preserveWS, top2.options);
    if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0)
      options |= OPT_OPEN_LEFT;
    this.nodes.push(new NodeContext(type, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
    this.open++;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(to) {
    for (let i = this.open; i >= 0; i--)
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j = content.length - 1; j >= 0; j--)
        pos += content[j].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset2) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset2)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && next.groups.indexOf(part) == -1)
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth; d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
  addPendingMark(mark) {
    let found2 = findSameMarkInSet(mark, this.top.pendingMarks);
    if (found2)
      this.top.stashMarks.push(found2);
    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
  }
  removePendingMark(mark, upto) {
    for (let depth = this.open; depth >= 0; depth--) {
      let level = this.nodes[depth];
      let found2 = level.pendingMarks.lastIndexOf(mark);
      if (found2 > -1) {
        level.pendingMarks = mark.removeFromSet(level.pendingMarks);
      } else {
        level.activeMarks = mark.removeFromSet(level.activeMarks);
        let stashMark = level.popFromStashMark(mark);
        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
          level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
      if (level == upto)
        break;
    }
  }
};
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles(style2) {
  let re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
  while (m = re.exec(style2))
    result.push(m[1], m[2].trim());
  return result;
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i = 0; i < match.edgeCount; i++) {
        let { type, next } = match.edge(i);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
function findSameMarkInSet(mark, set) {
  for (let i = 0; i < set.length; i++) {
    if (mark.eq(set[i]))
      return set[i];
  }
}
var DOMSerializer = class _DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc(options).createDocumentFragment();
    let top2 = target, active = [];
    fragment.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top2 = active.pop()[1];
        while (rendered < node.marks.length) {
          let add = node.marks[rendered++];
          let markDOM = this.serializeMark(add, node.isInline, options);
          if (markDOM) {
            active.push([add, top2]);
            top2.appendChild(markDOM.dom);
            top2 = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top2.appendChild(this.serializeNodeInner(node, options));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node, options) {
    let { dom, contentDOM } = _DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node, options = {}) {
    let dom = this.serializeNodeInner(node, options);
    for (let i = node.marks.length - 1; i >= 0; i--) {
      let wrap2 = this.serializeMark(node.marks[i], node.isInline, options);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && _DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));
  }
  /**
  Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
  the spec has a hole (zero) in it, `contentDOM` will point at the
  node with the hole.
  */
  static renderSpec(doc3, structure, xmlNS = null) {
    if (typeof structure == "string")
      return { dom: doc3.createTextNode(structure) };
    if (structure.nodeType != null)
      return { dom: structure };
    if (structure.dom && structure.dom.nodeType != null)
      return structure;
    let tagName = structure[0], space2 = tagName.indexOf(" ");
    if (space2 > 0) {
      xmlNS = tagName.slice(0, space2);
      tagName = tagName.slice(space2 + 1);
    }
    let contentDOM;
    let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);
    let attrs = structure[1], start2 = 1;
    if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
      start2 = 2;
      for (let name in attrs)
        if (attrs[name] != null) {
          let space3 = name.indexOf(" ");
          if (space3 > 0)
            dom.setAttributeNS(name.slice(0, space3), name.slice(space3 + 1), attrs[name]);
          else
            dom.setAttribute(name, attrs[name]);
        }
    }
    for (let i = start2; i < structure.length; i++) {
      let child = structure[i];
      if (child === 0) {
        if (i < structure.length - 1 || i > start2)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom, contentDOM: dom };
      } else {
        let { dom: inner, contentDOM: innerContent } = _DOMSerializer.renderSpec(doc3, child, xmlNS);
        dom.appendChild(inner);
        if (innerContent) {
          if (contentDOM)
            throw new RangeError("Multiple content holes");
          contentDOM = innerContent;
        }
      }
    }
    return { dom, contentDOM };
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
};
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc(options) {
  return options.document || window.document;
}

// node_modules/prosemirror-transform/dist/index.js
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index, offset2) {
  return index + offset2 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var DEL_BEFORE = 1;
var DEL_AFTER = 2;
var DEL_ACROSS = 4;
var DEL_SIDE = 8;
var MapResult = class {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
};
var StepMap = class _StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && _StepMap.empty)
      return _StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end2 = start2 + oldSize;
      if (pos <= end2) {
        let side = !oldSize ? assoc : pos == start2 ? -1 : pos == end2 ? 1 : assoc;
        let result = start2 + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start2 : end2) ? null : makeRecover(i / 3, pos - start2);
        let del2 = pos == start2 ? DEL_AFTER : pos == end2 ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start2 : pos != end2)
          del2 |= DEL_SIDE;
        return new MapResult(result, del2, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end2 = start2 + oldSize;
      if (pos <= end2 && i == index * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i], oldStart = start2 - (this.inverted ? diff : 0), newStart = start2 + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new _StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n) {
    return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
};
StepMap.empty = new StepMap([]);
var Mapping = class _Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps = [], mirror, from2 = 0, to = maps.length) {
    this.maps = maps;
    this.mirror = mirror;
    this.from = from2;
    this.to = to;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from2 = 0, to = this.maps.length) {
    return new _Mapping(this.maps, this.mirror, from2, to);
  }
  /**
  @internal
  */
  copy() {
    return new _Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map2, mirrors) {
    this.to = this.maps.push(map2);
    if (mirrors != null)
      this.setMirror(this.maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new _Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this.maps[i].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map2 = this.maps[i], result = map2.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this.maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
};
var stepsByID = /* @__PURE__ */ Object.create(null);
var Step = class {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
};
var StepResult = class _StepResult {
  /**
  @internal
  */
  constructor(doc3, failed) {
    this.doc = doc3;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc3) {
    return new _StepResult(doc3, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message) {
    return new _StepResult(null, message);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc3, from2, to, slice2) {
    try {
      return _StepResult.ok(doc3.replace(from2, to, slice2));
    } catch (e) {
      if (e instanceof ReplaceError)
        return _StepResult.fail(e.message);
      throw e;
    }
  }
};
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
var AddMarkStep = class _AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _AddMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new _AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addMark", AddMarkStep);
var RemoveMarkStep = class _RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to);
    let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc3), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _RemoveMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new _RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeMark", RemoveMarkStep);
var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i = 0; i < node.marks.length; i++)
          if (!node.marks[i].isInSet(newSet))
            return new _AddNodeMarkStep(this.pos, node.marks[i]);
        return new _AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new _AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addNodeMark", AddNodeMarkStep);
var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new _RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
var ReplaceStep = class _ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from2, to, slice2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.slice = slice2;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && contentBetween(doc3, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc3, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc3) {
    return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deletedAcross && to.deletedAcross)
      return null;
    return new _ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice);
  }
  merge(other) {
    if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new _ReplaceStep(other.from, this.to, slice2, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
};
Step.jsonID("replace", ReplaceStep);
var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from2, to, gapFrom, gapTo, slice2, insert2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice2;
    this.insert = insert2;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc3.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc3, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc3) {
    let gap = this.gapTo - this.gapFrom;
    return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
      return null;
    return new _ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
};
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc3, from2, to) {
  let $from = doc3.resolve(from2), dist = to - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr2, from2, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr2.doc.nodesBetween(from2, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start2 = Math.max(pos, from2), end2 = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start2 && removing.mark.eq(marks[i]))
            removing.to = end2;
          else
            removed.push(removing = new RemoveMarkStep(start2, end2, marks[i]));
        }
      }
      if (adding && adding.to == start2)
        adding.to = end2;
      else
        added.push(adding = new AddMarkStep(start2, end2, mark));
    }
  });
  removed.forEach((s) => tr2.step(s));
  added.forEach((s) => tr2.step(s));
}
function removeMark(tr2, from2, to, mark) {
  let matched = [], step = 0;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set = node.marks, found2;
      while (found2 = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found2);
        set = found2.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end2 = Math.min(pos + node.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style2 = toRemove[i], found2;
        for (let j = 0; j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step - 1 && style2.eq(matched[j].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end2;
          found2.step = step;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from2), to: end2, step });
        }
      }
    }
  });
  matched.forEach((m) => tr2.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr2, pos, parentType, match = parentType.contentMatch) {
  let node = tr2.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i), end2 = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end2, Slice.empty));
    } else {
      match = allowed;
      for (let j = 0; j < child.marks.length; j++)
        if (!parentType.allowsMarkType(child.marks[j].type))
          tr2.step(new RemoveMarkStep(cur, end2, child.marks[j]));
      if (child.isText && !parentType.spec.code) {
        let m, newline = /\r?\n|\r/g, slice2;
        while (m = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
        }
      }
    }
    cur = end2;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment.empty, true);
    tr2.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = replSteps.length - 1; i >= 0; i--)
    tr2.step(replSteps[i]);
}
function canCut(node, start2, end2) {
  return (start2 == 0 || node.canReplace(start2, node.childCount)) && (end2 == node.childCount || node.canReplace(0, end2));
}
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth; ; --depth) {
    let node = range.$from.node(depth);
    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
      break;
  }
  return null;
}
function lift(tr2, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start2 = gapStart, end2 = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start2--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end2++;
    }
  tr2.step(new ReplaceAroundStep(start2, end2, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex; innerMatch && i < endIndex; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr2, range, wrappers) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      let match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let start2 = range.start, end2 = range.end;
  tr2.step(new ReplaceAroundStep(start2, end2, start2, end2, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType(tr2, from2, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr2.steps.length;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr2.doc, tr2.mapping.slice(mapFrom).map(pos), type)) {
      tr2.clearIncompatible(tr2.mapping.slice(mapFrom).map(pos, 1), type);
      let mapping = tr2.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr2.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
      return false;
    }
  });
}
function canChangeType(doc3, pos, type) {
  let $pos = doc3.resolve(pos), index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type);
}
function setNodeMarkup(tr2, pos, type, attrs, marks) {
  let node = tr2.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr2.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr2.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc3, pos, depth = 1, typesAfter) {
  let $pos = doc3.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
    let node = $pos.node(d), index2 = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index2, node.childCount);
    let overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i] || node;
    if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr2, pos, depth = 1, typesAfter) {
  let $pos = tr2.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = Fragment.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr2.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc3, pos) {
  let $pos = doc3.resolve(pos), index = $pos.index();
  return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
}
function joinable2(a, b) {
  return !!(a && b && !a.isLeaf && a.canAppend(b));
}
function joinPoint(doc3, pos, dir = -1) {
  let $pos = doc3.resolve(pos);
  for (let d = $pos.depth; ; d--) {
    let before, after, index = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index++;
      after = $pos.node(d).maybeChild(index);
    } else {
      before = $pos.node(d).maybeChild(index - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index, index + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join(tr2, pos, depth) {
  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
  tr2.step(step);
}
function insertPoint(doc3, pos, nodeType) {
  let $pos = doc3.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType))
        return $pos.before(d + 1);
      if (index > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType))
        return $pos.after(d + 1);
      if (index < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc3, pos, slice2) {
  let $pos = doc3.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content = slice2.content;
  for (let i = 0; i < slice2.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc3, from2, to = from2, slice2 = Slice.empty) {
  if (from2 == to && !slice2.size)
    return null;
  let $from = doc3.resolve(from2), $to = doc3.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
var Fitter = class {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice2 = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
    if (slice2.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice2);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
      let node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        this.openFrontierNode(wrap2[i]);
    let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
    let openStart = slice2.openStart - sliceDepth;
    let taken = 0, add = [];
    let { match, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i = 0; i < inject.childCount; i++)
        add.push(inject.child(i));
      match = match.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment; i < openEndCount; i++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top2 = this.frontier[this.depth], level;
    if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan:
      for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        let { match, type } = this.frontier[i];
        let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        let fit = contentAfterFits($to, i, type, match, dropInner);
        if (!fit)
          continue;
        for (let d = i - 1; d >= 0; d--) {
          let { match: match2, type: type2 } = this.frontier[d];
          let matches2 = contentAfterFits($to, d, type2, match2, true);
          if (!matches2 || matches2.childCount)
            continue scan;
        }
        return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
      }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d = close2.depth + 1; d <= $to.depth; d++) {
      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
      this.openFrontierNode(node.type, node.attrs, add);
    }
    return $to;
  }
  openFrontierNode(type, attrs = null, content) {
    let top2 = this.frontier[this.depth];
    top2.match = top2.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add = open.match.fillBefore(Fragment.empty, true);
    if (add.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add);
  }
};
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i = 0; i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null;
}
function invalidMarks(type, fragment, start2) {
  for (let i = start2; i < fragment.childCount; i++)
    if (!type.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr2, from2, to, slice2) {
  if (!slice2.size)
    return tr2.deleteRange(from2, to);
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr2.step(new ReplaceStep(from2, to, slice2));
  let targetDepths = coveredDepths($from, tr2.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content = slice2.content, i = 0; ; i++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i == slice2.openStart)
      break;
    content = node.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j = slice2.openStart; j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
    let insert2 = leftNodes[openDepth];
    if (!insert2)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert2.type, insert2.marks))
        return tr2.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr2.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr2.replace(from2, to, slice2);
    if (tr2.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start2 = match.fillBefore(fragment).append(fragment);
    fragment = start2.append(match.matchFragment(start2).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr2, from2, to, node) {
  if (!node.isInline && from2 == to && tr2.doc.resolve(from2).parent.content.size) {
    let point = insertPoint(tr2.doc, from2, node.type);
    if (point != null)
      from2 = to = point;
  }
  tr2.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange(tr2, from2, to) {
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr2.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr2.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
      return tr2.delete($from.before(d), to);
  }
  tr2.delete(from2, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start2 = $from.start(d);
    if (start2 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start2 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start2 - 1)
      result.push(d);
  }
  return result;
}
var AttrStep = class _AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr2, value) {
    super();
    this.pos = pos;
    this.attr = attr2;
    this.value = value;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node.attrs)
      attrs[name] = node.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node.type.create(attrs, null, node.marks);
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new _AttrStep(json.pos, json.attr, json.value);
  }
};
Step.jsonID("attr", AttrStep);
var DocAttrStep = class _DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr2, value) {
    super();
    this.attr = attr2;
    this.value = value;
  }
  apply(doc3) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in doc3.attrs)
      attrs[name] = doc3.attrs[name];
    attrs[this.attr] = this.value;
    let updated = doc3.type.create(attrs, doc3.content, doc3.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _DocAttrStep(this.attr, doc3.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new _DocAttrStep(json.attr, json.value);
  }
};
Step.jsonID("docAttr", DocAttrStep);
var TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
var Transform = class {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc3) {
    this.doc = doc3;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc3;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from2, to = from2, slice2 = Slice.empty) {
    let step = replaceStep(this.doc, from2, to, slice2);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from2, to, content) {
    return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from2, to) {
    return this.replace(from2, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from2, to, slice2) {
    replaceRange(this, from2, to, slice2);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from2, to, node) {
    replaceRangeWith(this, from2, to, node);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from2, to) {
    deleteRange(this, from2, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range, target) {
    lift(this, range, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range, wrappers) {
    wrap(this, range, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from2, to = from2, type, attrs = null) {
    setBlockType(this, from2, to, type, attrs);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type, attrs = null, marks) {
    setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr2, value) {
    this.step(new AttrStep(pos, attr2, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr2, value) {
    this.step(new DocAttrStep(attr2, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    if (!(mark instanceof Mark)) {
      let node = this.doc.nodeAt(pos);
      if (!node)
        throw new RangeError("No node at position " + pos);
      mark = mark.isInSet(node.marks);
      if (!mark)
        return this;
    }
    this.step(new RemoveNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from2, to, mark) {
    addMark(this, from2, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from2, to, mark) {
    removeMark(this, from2, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
};

// node_modules/prosemirror-state/dist/index.js
var classesById = /* @__PURE__ */ Object.create(null);
var Selection = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr2, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      tr2.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd(tr2, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr2, node) {
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr2.deleteRange(from2, to);
      } else {
        tr2.replaceRangeWith(from2, to, node);
        selectionToInsertionEnd(tr2, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc3) {
    return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc3) {
    return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc3, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc3, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
};
Selection.prototype.visible = true;
var SelectionRange = class {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
};
var warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
var TextSelection = class _TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc3, mapping) {
    let $head = doc3.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc3.resolve(mapping.map(this.anchor));
    return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr2, content = Slice.empty) {
    super.replace(tr2, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr2.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new _TextSelection(doc3.resolve(json.anchor), doc3.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc3, anchor, head = anchor) {
    let $anchor = doc3.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new _TextSelection($anchor, $head);
  }
};
Selection.jsonID("text", TextSelection);
var TextBookmark = class _TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc3) {
    return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));
  }
};
var NodeSelection = class _NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc3, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc3.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new _NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof _NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new _NodeSelection(doc3.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc3, from2) {
    return new _NodeSelection(doc3.resolve(from2));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
};
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
var NodeBookmark = class _NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
};
var AllSelection = class _AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc3) {
    super(doc3.resolve(0), doc3.resolve(doc3.content.size));
  }
  replace(tr2, content = Slice.empty) {
    if (content == Slice.empty) {
      tr2.delete(0, tr2.doc.content.size);
      let sel = Selection.atStart(tr2.doc);
      if (!sel.eq(tr2.selection))
        tr2.setSelection(sel);
    } else {
      super.replace(tr2, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc3) {
    return new _AllSelection(doc3);
  }
  map(doc3) {
    return new _AllSelection(doc3);
  }
  eq(other) {
    return other instanceof _AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
};
Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map() {
    return this;
  },
  resolve(doc3) {
    return new AllSelection(doc3);
  }
};
function findSelectionIn(doc3, node, pos, index, dir, text2 = false) {
  if (node.inlineContent)
    return TextSelection.create(doc3, pos);
  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text2);
      if (inner)
        return inner;
    } else if (!text2 && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr2, startLen, bias) {
  let last = tr2.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr2.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map2 = tr2.mapping.maps[last], end2;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 == null)
      end2 = newTo;
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end2), bias));
}
var UPDATED_SEL = 1;
var UPDATED_MARKS = 2;
var UPDATED_SCROLL = 4;
var Transaction = class extends Transform {
  /**
  @internal
  */
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    super.addStep(step, doc3);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time) {
    this.time = time;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice2) {
    this.selection.replace(this, slice2);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
    selection.replaceWith(this, node);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text2, from2, to) {
    let schema = this.doc.type.schema;
    if (from2 == null) {
      if (!text2)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text2), true);
    } else {
      if (to == null)
        to = from2;
      to = to == null ? from2 : to;
      if (!text2)
        return this.deleteRange(from2, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from2);
        marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from2, to, schema.text(text2, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _ in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
};
function bind(f, self) {
  return !self || !f ? f : f.bind(self);
}
var FieldDesc = class {
  constructor(name, desc, self) {
    this.name = name;
    this.init = bind(desc.init, self);
    this.apply = bind(desc.apply, self);
  }
};
var baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr2) {
      return tr2.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance13) {
      return config.selection || Selection.atStart(instance13.doc);
    },
    apply(tr2) {
      return tr2.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr2, _marks, _old, state) {
      return state.selection.$cursor ? tr2.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr2, prev) {
      return tr2.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
var Configuration = class {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
};
var EditorState = class _EditorState {
  /**
  @internal
  */
  constructor(config) {
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr2) {
    return this.applyTransaction(tr2).state;
  }
  /**
  @internal
  */
  filterTransaction(tr2, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr2, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr2 = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr2 && newState.filterTransaction(tr2, i)) {
            tr2.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0; j < this.config.plugins.length; j++)
                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr2);
            newState = newState.applyInner(tr2);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr2) {
    if (!tr2.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new _EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr2, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction(this);
  }
  /**
  Create a new state.
  */
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance13 = new _EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance13[$config.fields[i].name] = $config.fields[i].init(config, instance13);
    return instance13;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance13 = new _EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance13[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance13);
    }
    return instance13;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance13 = new _EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance13.doc = Node.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance13.selection = Selection.fromJSON(instance13.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance13.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance13[field.name] = state.fromJSON.call(plugin, config, json[prop], instance13);
              return;
            }
          }
        instance13[field.name] = field.init(config, instance13);
      }
    });
    return instance13;
  }
};
function bindProps(obj, self, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self, {});
    target[prop] = val;
  }
  return target;
}
var Plugin = class {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};
var keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
var PluginKey = class {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};

// node_modules/prosemirror-view/dist/index.js
var domIndex = function(node) {
  for (var index = 0; ; index++) {
    node = node.previousSibling;
    if (!node)
      return index;
  }
};
var parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function(node, from2, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from2 || 0);
  return range;
};
var isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false")
        return false;
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isOnEdge(node, offset2, parent) {
  for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc3) {
  let elt = doc3.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc3, x, y) {
  if (doc3.caretPositionFromPoint) {
    try {
      let pos = doc3.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: pos.offset };
    } catch (_) {
    }
  }
  if (doc3.caretRangeFromPoint) {
    let range = doc3.caretRangeFromPoint(x, y);
    if (range)
      return { node: range.startContainer, offset: range.startOffset };
  }
}
var nav = typeof navigator != "undefined" ? navigator : null;
var doc2 = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
var windows = nav ? /Win/.test(nav.platform) : false;
var android = /Android \d/.test(agent);
var webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc3) {
  return {
    left: 0,
    right: doc3.documentElement.clientWidth,
    top: 0,
    bottom: doc3.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc3 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent)
      break;
    if (parent.nodeType != 1)
      continue;
    let elt = parent;
    let atTop = elt == doc3.body;
    let bounding = atTop ? windowRect(doc3) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc3.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position))
      break;
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack = [], doc3 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc3)
      break;
  }
  return stack;
}
function resetScrollPos({ refDOM, refTop, stack }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (let i = 0; i < stack.length; i++) {
    let { dom, top: top2, left: left2 } = stack[i];
    if (dom.scrollTop != top2 + dTop)
      dom.scrollTop = top2 + dTop;
    if (dom.scrollLeft != left2)
      dom.scrollLeft = left2;
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset2 = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset: offset2 };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange();
  for (let i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset: offset2 } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset2, bias);
}
function posFromCaret(view, node, offset2, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true);
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent && !sawBlock || !desc.contentDOM)) {
      let rect = desc.dom.getBoundingClientRect();
      if (desc.node.isBlock && desc.parent && !sawBlock) {
        sawBlock = true;
        if (rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset2, -1);
}
function elementFromPoint(element2, coords, box) {
  let len = element2.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      let child = element2.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element2;
}
function posAtCoords(view, coords) {
  let doc3 = view.dom.ownerDocument, node, offset2 = 0;
  let caret = caretFromPoint(doc3, coords.left, coords.top);
  if (caret)
    ({ node, offset: offset2 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p = elt; node && p; p = parentNode(p))
      if (p.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset2 = Math.min(offset2, node.childNodes.length);
      if (offset2 < node.childNodes.length) {
        let next = node.childNodes[offset2], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset2++;
      }
    }
    let prev;
    if (webkit && offset2 && node.nodeType == 1 && (prev = node.childNodes[offset2 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset2--;
    if (node == view.dom && offset2 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset2 == 0 || node.nodeType != 1 || node.childNodes[offset2 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset2, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset: offset2, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset2 : offset2 == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset2, offset2), side);
      if (gecko && offset2 && /\s/.test(node.nodeValue[offset2 - 1]) && offset2 < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from2 = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
      let before = node.childNodes[offset2 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset2 < nodeSize(node)) {
      let after = node.childNodes[offset2];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
    let before = node.childNodes[offset2 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset2 < nodeSize(node)) {
    let after = node.childNodes[offset2];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left2) {
  if (rect.width == 0)
    return rect;
  let x = left2 ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top2) {
  if (rect.height == 0)
    return rect;
  let y = top2 ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
var cachedState = null;
var cachedDir = null;
var cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
var NOT_DIRTY = 0;
var CHILD_DIRTY = 1;
var CONTENT_DIRTY = 2;
var NODE_DIRTY = 3;
var ViewDesc = class {
  constructor(parent, children2, dom, contentDOM) {
    this.parent = parent;
    this.children = children2;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size = 0;
    for (let i = 0; i < this.children.length; i++)
      size += this.children[i].size;
    return size;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset2, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset2 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset2];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset2 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset2 == 0)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd == null && offset2 == dom.childNodes.length)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = true;
            break;
          }
          if (search.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset2, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset2, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (offset2 == pos && end2 != offset2) {
        while (!child.border && child.children.length)
          child = child.children[0];
        return child;
      }
      if (pos < end2)
        return child.descAt(pos - offset2 - child.border);
      offset2 = end2;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset2 = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = curPos + child.size;
      if (end2 > pos || child instanceof TrailingHackViewDesc) {
        offset2 = pos - curPos;
        break;
      }
      curPos = end2;
    }
    if (offset2)
      return this.children[i].domFromPos(offset2 - this.children[i].border, side);
    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev, enter2 = true;
      for (; ; i--, enter2 = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter2 && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter2 = true;
      for (; ; i++, enter2 = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter2 && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from2, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset2 = base2, i = 0; ; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (fromOffset == -1 && from2 <= end2) {
        let childBase = offset2 + child.border;
        if (from2 >= childBase && to <= end2 - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = offset2;
        for (let j = i; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end2 > to || i == this.children.length - 1)) {
        to = end2;
        for (let j = i + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset2 = end2;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset: offset2 } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset2 == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset2];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, root, force = false) {
    let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (from2 > offset2 && to < end2)
        return child.setSelection(anchor - offset2 - child.border, head - offset2 - child.border, root, force);
      offset2 = end2;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = root.getSelection();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node, offset: offset2 } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset2 && node.nodeValue[offset2 - 1] == "\n");
        if (brKludge && offset2 == node.nodeValue.length) {
          for (let scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset2 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
      let after = domSel.focusNode.childNodes[domSel.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from2, to) {
    for (let offset2 = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (offset2 == end2 ? from2 <= end2 && to >= offset2 : from2 < end2 && to > offset2) {
        let startInside = offset2 + child.border, endInside = end2 - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == offset2 || to == end2 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset2 = end2;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
};
var WidgetViewDesc = class extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self)
          return pos;
        if (self.parent)
          return self.parent.posBeforeChild(self);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get side() {
    return this.widget.type.side;
  }
};
var CompositionViewDesc = class extends ViewDesc {
  constructor(parent, dom, textDOM, text2) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text2;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset2) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset2 ? this.size : 0);
    return this.posAtStart + offset2;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
};
var MarkViewDesc = class _MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
  }
  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
    return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from2, to, view) {
    let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size = this.size;
    if (to < size)
      nodes = replaceNodes(nodes, to, size, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (let i = 0; i < nodes.length; i++)
      nodes[i].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
};
var NodeViewDesc = class _NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      ({ dom, contentDOM } = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)));
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i))
        ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))
        ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off))
        ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from2, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
      return null;
    let sel = view.domSelectionRange();
    let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text2 = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text2, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text: text2 };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text: text2 }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text2);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text2.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.removeAttribute("draggable");
  }
  get domAtom() {
    return this.node.isAtom;
  }
};
function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc3);
  let docView = new NodeViewDesc(void 0, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
var TextViewDesc = class _TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset2, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    return super.localPosFromDOM(dom, offset2, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from2, to, view) {
    let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
    return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
};
var TrailingHackViewDesc = class extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
};
var CustomNodeViewDesc = class extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, root, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : super.setSelection(anchor, head, root, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
};
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
var OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top2];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top2 = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top2 = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top2.class = (top2.class ? top2.class + " " : "") + val;
      else if (name == "style")
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      else if (name != "nodeName")
        top2[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom.classList.add(curList[i]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].type.eq(b[i].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ViewTreeUpdater = class {
  constructor(top2, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top2;
    this.preMatch = preMatch(top2.node.content, top2);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start2, end2) {
    if (start2 == end2)
      return;
    for (let i = start2; i < end2; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start2, end2 - start2);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        let next = this.top.children[i];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index) {
    let found2 = -1, targetDesc;
    if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index, view) {
    let child = this.top.children[index];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
};
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer:
    while (fI > 0) {
      let desc;
      for (; ; ) {
        if (descI) {
          let next = curDesc.children[descI - 1];
          if (next instanceof MarkViewDesc) {
            curDesc = next;
            descI = next.children.length;
          } else {
            desc = next;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      let node = desc.node;
      if (!node)
        continue;
      if (node != frag.child(fI - 1))
        break;
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset2 = 0;
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset2, child), i);
      offset2 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset2) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index;
    if (restNode) {
      index = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset2)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
      active.push(locals[decoIndex++]);
    let end2 = offset2 + child.nodeSize;
    if (child.isText) {
      let cutAt = end2;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end2) {
        restNode = child.cut(cutAt - offset2);
        child = child.cut(0, cutAt - offset2);
        end2 = cutAt;
        index = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end2)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset2, child), index);
    offset2 = end2;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function nearbyTextNode(node, offset2) {
  for (; ; ) {
    if (node.nodeType == 3)
      return node;
    if (node.nodeType == 1 && offset2 > 0) {
      if (node.childNodes.length > offset2 && node.childNodes[offset2].nodeType == 3)
        return node.childNodes[offset2];
      node = node.childNodes[offset2 - 1];
      offset2 = nodeSize(node);
    } else if (node.nodeType == 1 && offset2 < node.childNodes.length) {
      node = node.childNodes[offset2];
      offset2 = 0;
    } else {
      return null;
    }
  }
}
function findTextInFragment(frag, text2, from2, to) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      if (pos >= to && str.slice(to - text2.length - childStart, to - childStart) == text2)
        return to - text2.length;
      let found2 = childStart < to ? str.lastIndexOf(text2, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text2.length + childStart >= from2)
        return childStart + found2;
      if (from2 == to && str.length >= to + text2.length - childStart && str.slice(to - childStart, to - childStart + text2.length) == text2)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  let result = [];
  for (let i = 0, off = 0; i < nodes.length; i++) {
    let child = nodes[i], start2 = off, end2 = off += child.size;
    if (start2 >= to || end2 <= from2) {
      result.push(child);
    } else {
      if (start2 < from2)
        result.push(child.slice(0, from2 - start2, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end2 > to)
        result.push(child.slice(to - start2, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc3 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc3.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
    }
  } else {
    let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    if (anchor < 0)
      return null;
    $anchor = doc3.resolve(anchor);
  }
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset2 } = view.docView.domFromPos(pos, 0);
  let after = offset2 < node.childNodes.length ? node.childNodes[offset2] : null;
  let before = offset2 ? node.childNodes[offset2 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element2) {
  element2.contentEditable = "true";
  if (safari && element2.draggable) {
    element2.draggable = false;
    element2.wasDraggable = true;
  }
  return element2;
}
function resetEditable(element2) {
  element2.contentEditable = "false";
  if (element2.wasDraggable) {
    element2.draggable = true;
    element2.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc3 = view.dom.ownerDocument;
  doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset2) {
      doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range = document.createRange();
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    range.setEnd(node.parentNode, domIndex(node) + 1);
  else
    range.setEnd(node, 0);
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset2 < nodeLen(node) && isIgnorable(node.childNodes[offset2], -1))
    force = true;
  for (; ; ) {
    if (offset2 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset2 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset2;
        } else if (before.nodeType == 3) {
          node = before;
          offset2 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = 0;
      } else {
        node = prev;
        offset2 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset2);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset2];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset2;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = len = 0;
      } else {
        node = next;
        offset2 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset2) {
  while (node && offset2 == node.childNodes.length && !hasBlockDesc(node)) {
    offset2 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset2 < node.childNodes.length) {
    let next = node.childNodes[offset2];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = 0;
  }
}
function textNodeBefore(node, offset2) {
  while (node && !offset2 && !hasBlockDesc(node)) {
    offset2 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset2) {
    let next = node.childNodes[offset2 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset2) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset2)) {
      node = after;
      offset2 = 0;
    } else if (before = textNodeBefore(node, offset2)) {
      node = before;
      offset2 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset2);
    range.setStart(node, offset2);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset2);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed = getComputedStyle(view.dom).direction;
  return computed == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty3 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty3)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr2 = view.state.tr;
    if (dir < 0)
      tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr2);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code = event.keyCode, mods = getMods(event);
  if (code == 8 || mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac && code == 66 && mods == "c") {
    let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac && code == 70 && mods == "c") {
    let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 38 || mac && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc3 = detachedDoc(), wrap2 = doc3.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc3.createElement(needsWrap[i]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text2 = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap2, text: text2 };
}
function parseFromClipboard(view, text2, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html && !text2)
    return null;
  let asText = text2 && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text2 = f(text2, inCode || plainText, view);
    });
    if (inCode)
      return text2 ? new Slice(Fragment.from(view.state.schema.text(text2.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text2, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text2.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p = dom.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0; i--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view);
  });
  return slice2;
}
var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap2 = match.findWrapping(node.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap2);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap2, from2 = 0) {
  for (let i = wrap2.length - 1; i >= from2; i--)
    node = wrap2[i].create(null, Fragment.from(node));
  return node;
}
function addToSibling(wrap2, lastWrap, node, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = html;
  if (wrap2)
    for (let i = 0; i < wrap2.length; i++)
      elt = elt.querySelector(wrap2[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes.length; i++) {
    let node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema = slice2.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i = array.length - 2; i >= 0; i -= 2) {
    let type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
var handlers = {};
var editHandlers = {};
var passiveHandlers = { touchstart: true, touchmove: true };
var InputState = class {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "" };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastAndroidDelete = 0;
    this.composing = false;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
};
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now2 = Date.now();
    view.input.lastIOSEnter = now2;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now2) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text2 = String.fromCharCode(event.charCode);
    if (!/[\r\n]/.test(text2) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text2)))
      view.dispatch(view.state.tr.insertText(text2).scrollIntoView());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  let tr2 = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr2.setMeta("pointer", true);
  view.dispatch(tr2);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc3 = view.state.doc;
  if (inside == -1) {
    if (doc3.inlineContent) {
      updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc3.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now2 = Date.now(), type = "singleClick";
  if (now2 - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now2, x: event.clientX, y: event.clientY, type };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
var MouseDown = class {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
};
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$from;
    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node = sel.focusNode, offset2 = sel.focusOffset; node && node.nodeType == 1 && offset2 != 0; ) {
          let before = offset2 < 0 ? node.lastChild : node.childNodes[offset2 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            view.domSelection().collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset2 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, forceUpdate = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection))
      view.dispatch(view.state.tr.setSelection(sel));
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut2 = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom, text: text2 } = serializeForClipboard(view, slice2);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text2);
  } else {
    captureCopy(view, dom);
  }
  if (cut2)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text2, html, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text2, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr2 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr2.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  let text2 = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text2)
    return text2;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
var Dragging = class {
  constructor(slice2, move, node) {
    this.slice = slice2;
    this.move = move;
    this.node = node;
  }
};
var dragCopyModifier = mac ? "altKey" : "ctrlKey";
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let slice2 = (node || view.state.selection).content(), { dom, text: text2 } = serializeForClipboard(view, slice2);
  event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text2);
  view.dragging = new Dragging(slice2, !event[dragCopyModifier], node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
  } else {
    slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move = !!(dragging && !event[dragCopyModifier]);
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr2 = view.state.tr;
  if (move) {
    let { node } = dragging;
    if (node)
      node.replace(tr2);
    else
      tr2.deleteSelection();
  }
  let pos = tr2.mapping.map(insertPos);
  let isNode = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr2.doc;
  if (isNode)
    tr2.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr2.replaceRange(pos, pos, slice2);
  if (tr2.doc.eq(beforeInsert))
    return;
  let $pos = tr2.doc.resolve(pos);
  if (isNode && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr2.setSelection(new NodeSelection($pos));
  } else {
    let end2 = tr2.mapping.map(insertPos);
    tr2.mapping.maps[tr2.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end2 = newTo);
    tr2.setSelection(selectionBetween(view, $pos, tr2.doc.resolve(end2)));
  }
  view.focus();
  view.dispatch(tr2.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (let p in a)
    if (a[p] !== b[p])
      return false;
  for (let p in b)
    if (!(p in a))
      return false;
  return true;
}
var WidgetType = class _WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset2, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
};
var InlineType = class _InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
    return from2 >= to ? null : new Decoration(from2, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof _InlineType;
  }
  destroy() {
  }
};
var NodeType2 = class _NodeType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset2, to.pos - offset2, this);
  }
  valid(node, span) {
    let { index, offset: offset2 } = node.content.findIndex(span.from), child;
    return offset2 == span.from && !(child = node.child(index)).isText && offset2 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
};
var Decoration = class _Decoration {
  /**
  @internal
  */
  constructor(from2, to, type) {
    this.from = from2;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from2, to) {
    return new _Decoration(from2, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset2 = 0) {
    return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset2, oldOffset) {
    return this.type.map(mapping, this, offset2, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new InlineType(attrs, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new NodeType2(attrs, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
};
var none = [];
var noSpec = {};
var DecorationSet = class _DecorationSet {
  /**
  @internal
  */
  constructor(local, children2) {
    this.local = local.length ? local : none;
    this.children = children2.length ? children2 : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc3, decorations) {
    return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty2;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start2, end2, predicate) {
    let result = [];
    this.findInner(start2 == null ? 0 : start2, end2 == null ? 1e9 : end2, result, 0, predicate);
    return result;
  }
  findInner(start2, end2, result, offset2, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end2 && span.to >= start2 && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset2, span.to + offset2));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end2 && this.children[i + 1] > start2) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start2 - childOff, end2 - childOff, result, offset2 + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc3, options) {
    if (this == empty2 || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc3, 0, 0, options || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node, offset2, oldOffset, options) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset2, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset2, oldOffset, options);
    else
      return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty2;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc3, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty2)
      return _DecorationSet.create(doc3, decorations);
    return this.addInner(doc3, decorations, 0);
  }
  addInner(doc3, decorations, offset2) {
    let children2, childIndex = 0;
    doc3.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset2, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children2)
        children2 = this.children.slice();
      while (childIndex < children2.length && children2[childIndex] < childOffset)
        childIndex += 3;
      if (children2[childIndex] == childOffset)
        children2[childIndex + 2] = children2[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children2.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc3, local[i]))
        local.splice(i--, 1);
    return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children2 || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty2)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset2) {
    let children2 = this.children, local = this.local;
    for (let i = 0; i < children2.length; i += 3) {
      let found2;
      let from2 = children2[i] + offset2, to = children2[i + 1] + offset2;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from2 && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children2 == this.children)
        children2 = this.children.slice();
      let removed = children2[i + 2].removeInner(found2, from2 + 1);
      if (removed != empty2) {
        children2[i + 2] = removed;
      } else {
        children2.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset2)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children2 == this.children && local == this.local)
      return this;
    return local.length || children2.length ? new _DecorationSet(local, children2) : empty2;
  }
  /**
  @internal
  */
  forChild(offset2, node) {
    if (this == empty2)
      return this;
    if (node.isLeaf)
      return _DecorationSet.empty;
    let child, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset2) {
        if (this.children[i] == offset2)
          child = this.children[i + 2];
        break;
      }
    let start2 = offset2 + 1, end2 = start2 + node.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end2 && dec.to > start2 && dec.type instanceof InlineType) {
        let from2 = Math.max(start2, dec.from) - start2, to = Math.min(end2, dec.to) - start2;
        if (from2 < to)
          (local || (local = [])).push(dec.copy(from2, to));
      }
    }
    if (local) {
      let localSet = new _DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty2;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  /**
  @internal
  */
  localsInner(node) {
    if (this == empty2)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result;
  }
};
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
var empty2 = DecorationSet.empty;
var DecorationGroup = class _DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc3) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
    return _DecorationGroup.from(mappedDecos);
  }
  forChild(offset2, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i = 0; i < this.members.length; i++) {
      let result = this.members[i].forChild(offset2, child);
      if (result == empty2)
        continue;
      if (result instanceof _DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return _DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++)
          result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty2;
      case 1:
        return members[0];
      default:
        return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r2, m) => r2.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
};
function mapChildren(oldChildren, newLocal, mapping, node, offset2, oldOffset, options) {
  let children2 = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0; i2 < children2.length; i2 += 3) {
        let end2 = children2[i2 + 1];
        if (end2 < 0 || oldStart > end2 + baseOffset - moved)
          continue;
        let start2 = children2[i2] + baseOffset - moved;
        if (oldEnd >= start2) {
          children2[i2 + 1] = oldStart <= start2 ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children2[i2] += dSize;
          children2[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0; i < children2.length; i += 3)
    if (children2[i + 1] < 0) {
      if (children2[i + 1] == -2) {
        mustRebuild = true;
        children2[i + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset2;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset2;
      let { index, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children2[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options);
        if (mapped != empty2) {
          children2[i] = fromLocal;
          children2[i + 1] = toLocal;
          children2[i + 2] = mapped;
        } else {
          children2[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children2, oldChildren, newLocal, mapping, offset2, oldOffset, options);
    let built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (let i = 0; i < children2.length; i += 3)
      if (children2[i + 1] < 0) {
        children2.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from2 = built.children[i];
      while (j < children2.length && children2[j] < from2)
        j += 3;
      children2.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children2);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length)
    return spans;
  let result = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children2, oldChildren, decorations, mapping, offset2, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (let i = 0; i < set.local.length; i++) {
      let mapped = set.local[i].map(mapping, offset2, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set.local[i].spec);
    }
    for (let i = 0; i < set.children.length; i += 3)
      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children2.length; i += 3)
    if (children2[i + 1] == -1)
      gather(children2[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset2) {
  if (node.isLeaf)
    return null;
  let end2 = offset2 + node.nodeSize, found2 = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset2 && span.to < end2) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  let result = [];
  for (let i = 0; i < array.length; i++)
    if (array[i] != null)
      result.push(array[i]);
  return result;
}
function buildTree(spans, node, offset2, options) {
  let children2 = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset2 + localStart + 1, options);
      if (subtree != empty2)
        children2.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (let i = 0; i < locals.length; i++)
    if (!locals[i].type.valid(node, locals[i])) {
      if (options.onRemove)
        options.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children2.length ? new DecorationSet(locals, children2) : empty2;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0)
    i++;
  array.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty2)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = ie && ie_version <= 11;
var SelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
};
var DOMObserver = class {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from2 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result = this.registerMutation(mutations[i], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length > 1) {
      let brs = added.filter((n) => n.nodeName == "BR");
      if (brs.length == 2) {
        let a = brs[0], b = brs[1];
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      }
    }
    let readSel = null;
    if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from2 > -1 || newSel) {
      if (from2 > -1) {
        view.docView.markDirty(from2, to);
        checkCSS(view);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++)
        added.push(mut.addedNodes[i]);
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from2, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
};
var cssChecked = /* @__PURE__ */ new WeakMap();
var cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function safariShadowSelectionRange(view) {
  let found2;
  function read2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read2, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read2, true);
  let anchorNode = found2.startContainer, anchorOffset = found2.startOffset;
  let focusNode = found2.endContainer, focusOffset = found2.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find2;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc3 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc3, sel, from: from2, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr3 = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr3.setMeta("pointer", true);
      else if (origin == "key")
        tr3.scrollIntoView();
      if (compositionID)
        tr3.setMeta("composition", compositionID);
      view.dispatch(tr3);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared = $before.sharedDepth(to);
  from2 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse = parseBetween(view, from2, to);
  let doc3 = view.state.doc, compare = doc3.slice(parse.from, parse.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr3 = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr3.setMeta("composition", compositionID);
          view.dispatch(tr3);
        }
      }
      return;
    }
  }
  if (chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from && parse.sel.head == parse.sel.anchor) {
    let size = change.endB - change.start;
    parse.sel = { anchor: parse.sel.anchor + size, head: parse.sel.anchor + size };
  }
  view.input.domChangeCount++;
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse.doc.resolveNoCache(change.start - parse.from);
  let $to = parse.doc.resolveNoCache(change.endB - parse.from);
  let $fromA = doc3.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && !$from.sameParent($to) && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeJoin(doc3, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && android && change.endB == change.start)
    view.input.lastAndroidDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let tr2, storedMarks, markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      tr2 = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      tr2 = view.state.tr;
      if (markChange.type == "add")
        tr2.addMark(chFrom, chTo, markChange.mark);
      else
        tr2.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text2 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text2)))
        return;
      tr2 = view.state.tr.insertText(text2, chFrom, chTo);
    }
  }
  if (!tr2)
    tr2 = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
  if (parse.sel) {
    let sel2 = resolveSelection(view, tr2.doc, parse.sel);
    if (sel2 && !(chrome && android && view.composing && sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr2.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
      tr2.setSelection(sel2);
  }
  if (storedMarks)
    tr2.ensureMarks(storedMarks);
  if (compositionID)
    tr2.setMeta("composition", compositionID);
  view.dispatch(tr2.scrollIntoView());
}
function resolveSelection(view, doc3, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)
    return null;
  return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update2;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update2 = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update2 = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++)
    updated.push(update2(prev.child(i)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeJoin(old, start2, end2, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || // The content must have shrunk
  end2 - start2 <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
  skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
    return false;
  let $start = old.resolve(start2);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end2 || skipClosingAndOpening($next, true, false) < end2)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end2 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end2++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end2++;
    }
  }
  return end2;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  let start2 = a.findDiffStart(b, pos);
  if (start2 == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start2 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start2;
  }
  if (endA < start2 && a.size < b.size) {
    let move = preferredPos <= start2 && preferredPos >= endA ? start2 - preferredPos : 0;
    start2 -= move;
    if (start2 && start2 < b.size && isSurrogatePair(b.textBetween(start2 - 1, start2 + 1)))
      start2 += move ? 1 : -1;
    endB = start2 + (endB - endA);
    endA = start2;
  } else if (endB < start2) {
    let move = preferredPos <= start2 && preferredPos >= endB ? start2 - preferredPos : 0;
    start2 -= move;
    if (start2 && start2 < a.size && isSurrogatePair(a.textBetween(start2 - 1, start2 + 1)))
      start2 += move ? 1 : -1;
    endA = start2 + (endA - endB);
    endB = start2;
  }
  return { start: start2, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a = str.charCodeAt(0), b = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
}
var EditorView = class {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco([]);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (this.someProp("handleScrollToSelection", (f) => f(this)))
      ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin = this.directPlugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin = this.state.plugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0; i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection)
            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
          return this._root = search;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node, offset2, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset2, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text2, event) {
    return doPaste(this, text2, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(tr2) {
    let dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction)
      dispatchTransaction.call(this, tr2);
    else
      this.updateState(this.state.apply(tr2));
  }
  /**
  @internal
  */
  domSelectionRange() {
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom ? safariShadowSelectionRange(this) : this.domSelection();
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
};
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr2 in value) {
        if (attr2 == "class")
          attrs.class += " " + value[attr2];
        else if (attr2 == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr2];
        else if (!attrs[attr2] && attr2 != "contenteditable" && attr2 != "nodeName")
          attrs[attr2] = String(value[attr2]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}

// node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i = 0; i < 10; i++)
  base[48 + i] = base[96 + i] = String(i);
var i;
for (i = 1; i <= 24; i++)
  base[i + 111] = "F" + i;
var i;
for (i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
var i;
for (code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
var code;
function keyName(event) {
  var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}

// node_modules/prosemirror-keymap/dist/index.js
var mac3 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac3)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function normalize(map2) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map2)
    copy2[normalizeKeyName(prop)] = map2[prop];
  return copy2;
}
function modifiers(name, event, shift2 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map2 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map2[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map2[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}

// node_modules/prosemirror-commands/dist/index.js
var deleteSelection = (state, dispatch) => {
  if (state.selection.empty)
    return false;
  if (dispatch)
    dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
var joinBackward = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr2 = state.tr.step(delStep);
        tr2.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr2.doc, $cut.pos - before.nodeSize));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
var joinTextblockBackward = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
var joinTextblockForward = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
function joinTextblocksAround(state, $cut, dispatch) {
  let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
  for (; !beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating)
      return false;
    let child = beforeText.lastChild;
    if (!child)
      return false;
    beforeText = child;
  }
  let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
  for (; !afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating)
      return false;
    let child = afterText.firstChild;
    if (!child)
      return false;
    afterText = child;
  }
  let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
  if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
    return false;
  if (dispatch) {
    let tr2 = state.tr.step(step);
    tr2.setSelection(TextSelection.create(tr2.doc, beforePos));
    dispatch(tr2.scrollIntoView());
  }
  return true;
}
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
var selectNodeBackward = (state, dispatch, view) => {
  let { $head, empty: empty3 } = state.selection, $cut = $head;
  if (!empty3)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0)
        return $pos.doc.resolve($pos.before(i + 1));
      if ($pos.node(i).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
var joinForward = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr2 = state.tr.step(delStep);
        tr2.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos)), 1) : NodeSelection.create(tr2.doc, tr2.mapping.map($cut.pos)));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
var selectNodeForward = (state, dispatch, view) => {
  let { $head, empty: empty3 } = state.selection, $cut = $head;
  if (!empty3)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      let parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
var joinUp = (state, dispatch) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch) {
    let tr2 = state.tr.join(point);
    if (nodeSel)
      tr2.setSelection(NodeSelection.create(tr2.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var joinDown = (state, dispatch) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch)
    dispatch(state.tr.join(point).scrollIntoView());
  return true;
};
var lift2 = (state, dispatch) => {
  let { $from, $to } = state.selection;
  let range = $from.blockRange($to), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
var newlineInCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    let { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
var exitCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch) {
    let pos = $head.after(), tr2 = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr2.setSelection(Selection.near(tr2.doc.resolve(pos), 1));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var createParagraphNear = (state, dispatch) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr2 = state.tr.insert(side, type.createAndFill());
    tr2.setSelection(TextSelection.create(tr2.doc, side + 1));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var liftEmptyBlock = (state, dispatch) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch)
        dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state, dispatch) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch)
        dispatch(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.parent.isBlock)
      return false;
    if (dispatch) {
      let atEnd = $to.parentOffset == $to.parent.content.size;
      let tr2 = state.tr;
      if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
        tr2.deleteSelection();
      let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      let splitType = splitNode && splitNode($to.parent, atEnd);
      let types = splitType ? [splitType] : atEnd && deflt ? [{ type: deflt }] : void 0;
      let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
      if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
        if (deflt)
          types = [{ type: deflt }];
        can = true;
      }
      if (can) {
        tr2.split(tr2.mapping.map($from.pos), 1, types);
        if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
          let first2 = tr2.mapping.map($from.before()), $first = tr2.doc.resolve(first2);
          if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))
            tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
}
var splitBlock = splitBlockAs();
var selectParentNode = (state, dispatch) => {
  let { $from, to } = state.selection, pos;
  let same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
var selectAll = (state, dispatch) => {
  if (dispatch)
    dispatch(state.tr.setSelection(new AllSelection(state.doc)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  if (before.type.spec.isolating || after.type.spec.isolating)
    return false;
  if (joinMaybeClear(state, $cut, dispatch))
    return true;
  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end2 = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap2 = Fragment.from(conn[i].create(null, wrap2));
      wrap2 = Fragment.from(before.copy(wrap2));
      let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end2, $cut.pos, end2, new Slice(wrap2, 1, 0), conn.length, true));
      let joinAt = end2 + 2 * conn.length;
      if (canJoin(tr2.doc, joinAt))
        tr2.join(joinAt);
      dispatch(tr2.scrollIntoView());
    }
    return true;
  }
  let selAfter = Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        let end2 = Fragment.empty;
        for (let i = wrap2.length - 1; i >= 0; i--)
          end2 = Fragment.from(wrap2[i].copy(end2));
        let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end2, wrap2.length, 0), 0, true));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
var selectTextblockStart = selectTextblockSide(-1);
var selectTextblockEnd = selectTextblockSide(1);
function wrapIn(nodeType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch)
      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType2(nodeType, attrs = null) {
  return function(state, dispatch) {
    let applicable = false;
    for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
      let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index = $pos.index();
          applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr2 = state.tr;
      for (let i = 0; i < state.selection.ranges.length; i++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
        tr2.setBlockType(from2, to, nodeType, attrs);
      }
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands2) {
  return function(state, dispatch, view) {
    for (let i = 0; i < commands2.length; i++)
      if (commands2[i](state, dispatch, view))
        return true;
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (let key in pcBaseKeymap)
  macBaseKeymap[key] = pcBaseKeymap[key];
var mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;

// node_modules/prosemirror-schema-list/dist/index.js
function wrapInList(listType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), doJoin = false, outerRange = range;
    if (!range)
      return false;
    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      if ($from.index(range.depth - 1) == 0)
        return false;
      let $insert = state.doc.resolve(range.start - 2);
      outerRange = new NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount)
        range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
      doJoin = true;
    }
    let wrap2 = findWrapping(outerRange, listType, attrs, range);
    if (!wrap2)
      return false;
    if (dispatch)
      dispatch(doWrapInList(state.tr, range, wrap2, doJoin, listType).scrollIntoView());
    return true;
  };
}
function doWrapInList(tr2, range, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--)
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  tr2.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i = 0; i < wrappers.length; i++)
    if (wrappers[i].type == listType)
      found2 = i + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i = range.startIndex, e = range.endIndex, first2 = true; i < e; i++, first2 = false) {
    if (!first2 && canSplit(tr2.doc, splitPos, splitDepth)) {
      tr2.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i).nodeSize;
  }
  return tr2;
}
function liftListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range);
    else
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  let tr2 = state.tr, end2 = range.end, endOfList = range.$to.end(range.depth);
  if (end2 < endOfList) {
    tr2.step(new ReplaceAroundStep(end2 - 1, endOfList, end2, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr2.doc.resolve(range.$from.pos), tr2.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr2.lift(range, target);
  let after = tr2.mapping.map(end2, -1) - 1;
  if (canJoin(tr2.doc, after))
    tr2.join(after);
  dispatch(tr2.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  let tr2 = state.tr, list = range.parent;
  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr2.delete(pos - 1, pos + 1);
  }
  let $start = tr2.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr2.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start2 = $start.pos, end2 = start2 + item.nodeSize;
  tr2.step(new ReplaceAroundStep(start2 - (atStart ? 1 : 0), end2 + (atEnd ? 1 : 0), start2 + 1, end2 - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr2.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}

// node_modules/@tiptap/core/dist/index.js
function createChainableState(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc3 } = transaction;
  let { storedMarks } = transaction;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc3;
    },
    get tr() {
      selection = transaction.selection;
      doc3 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
var CommandManager = class {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr: tr2 } = state;
    const props = this.buildProps(tr2);
    return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      const method = (...args) => {
        const callback = command2(...args)(props);
        if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr2);
        }
        return callback;
      };
      return [name, method];
    }));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr2 = startTr || state.tr;
    const run4 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr2);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain = {
      ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const chainedCommand = (...args) => {
          const props = this.buildProps(tr2, shouldDispatch);
          const callback = command2(...args)(props);
          callbacks.push(callback);
          return chain;
        };
        return [name, chainedCommand];
      })),
      run: run4
    };
    return chain;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch = false;
    const tr2 = startTr || state.tr;
    const props = this.buildProps(tr2, dispatch);
    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
    }));
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr2, dispatch)
    };
  }
  buildProps(tr2, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr: tr2,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr2
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr2, shouldDispatch),
      can: () => this.createCan(tr2),
      get commands() {
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)(props)];
        }));
      }
    };
    return props;
  }
};
var EventEmitter = class {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn2) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn2);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn2) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn2) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn2);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function splitExtensions(extensions2) {
  const baseExtensions = extensions2.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions2.filter((extension) => extension.type === "node");
  const markExtensions = extensions2.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions2) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions2.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(extension, "addAttributes", context);
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? value.split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        mergedAttributes[key] = [mergedAttributes[key], value].join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function isFunction(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if (parseRule.style) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key, value]) => {
      if (key === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function getSchemaByResolvedExtensions(extensions2, editor) {
  var _a;
  const allAttributes = getAttributesFromExtensions(extensions2);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a === void 0 ? void 0 : _a.name;
  const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraNodeFields = extensions2.reduce((fields, e) => {
      const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
      return {
        ...fields,
        ...extendNodeSchema ? extendNodeSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraNodeFields,
      content: callOrReturn(getExtensionField(extension, "content", context)),
      marks: callOrReturn(getExtensionField(extension, "marks", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      inline: callOrReturn(getExtensionField(extension, "inline", context)),
      atom: callOrReturn(getExtensionField(extension, "atom", context)),
      selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
      draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      defining: callOrReturn(getExtensionField(extension, "defining", context)),
      isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (node) => renderHTML({
        node,
        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
      });
    }
    const renderText = getExtensionField(extension, "renderText", context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  }));
  const marks = Object.fromEntries(markExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraMarkFields = extensions2.reduce((fields, e) => {
      const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
      return {
        ...fields,
        ...extendMarkSchema ? extendMarkSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraMarkFields,
      inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
      excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (mark) => renderHTML({
        mark,
        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
      });
    }
    return [extension.name, schema];
  }));
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
var getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {
    var _a, _b;
    const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {
      node,
      pos,
      parent,
      index
    })) || node.textContent || "%leaf%";
    textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
var InputRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var inputRuleMatcherHandler = (text2, find2) => {
  if (isRegExp(find2)) {
    return find2.exec(text2);
  }
  const inputRuleMatch = find2(text2);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text2;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run$1(config) {
  var _a;
  const { editor, from: from2, to, text: text2, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from2);
  if (
    // check for code node
    $from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark) => mark.type.spec.code))
  ) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text2;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    const tr2 = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr2
    });
    const range = {
      from: from2 - (match[0].length - text2.length),
      to
    };
    const { commands: commands2, chain, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range,
      match,
      commands: commands2,
      chain,
      can
    });
    if (handler === null || !tr2.steps.length) {
      return;
    }
    tr2.setMeta(plugin, {
      transform: tr2,
      from: from2,
      to,
      text: text2
    });
    view.dispatch(tr2);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr2, prev) {
        const stored = tr2.getMeta(plugin);
        if (stored) {
          return stored;
        }
        return tr2.selectionSet || tr2.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from2, to, text2) {
        return run$1({
          editor,
          from: from2,
          to,
          text: text2,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run$1({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function isNumber(value) {
  return typeof value === "number";
}
var PasteRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var pasteRuleMatcherHandler = (text2, find2, event) => {
  if (isRegExp(find2)) {
    return [...text2.matchAll(find2)];
  }
  const matches2 = find2(text2, event);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text2;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run2(config) {
  const { editor, state, from: from2, to, rule, pasteEvent, dropEvent } = config;
  const { commands: commands2, chain, can } = new CommandManager({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isTextblock || node.type.spec.code) {
      return;
    }
    const resolvedFrom = Math.max(from2, pos);
    const resolvedTo = Math.min(to, pos + node.content.size);
    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches2.forEach((match) => {
      if (match.index === void 0) {
        return;
      }
      const start2 = resolvedFrom + match.index + 1;
      const end2 = start2 + match[0].length;
      const range = {
        from: state.tr.mapping.map(start2),
        to: state.tr.mapping.map(end2)
      };
      const handler = rule.handler({
        state,
        range,
        match,
        commands: commands2,
        chain,
        can,
        pasteEvent,
        dropEvent
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  let pasteEvent = new ClipboardEvent("paste");
  let dropEvent = new DragEvent("drop");
  const plugins = rules.map((rule) => {
    return new Plugin({
      // we register a global drag handler to track the current drag source element
      view(view) {
        const handleDragstart = (event) => {
          var _a;
          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
        };
        window.addEventListener("dragstart", handleDragstart);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view, event) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            return false;
          },
          paste: (_view, event) => {
            var _a;
            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
            pasteEvent = event;
            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction = transactions[0];
        const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        if (!isPaste && !isDrop) {
          return;
        }
        const from2 = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from2) || !to || from2 === to.b) {
          return;
        }
        const tr2 = state.tr;
        const chainableState = createChainableState({
          state,
          transaction: tr2
        });
        const handler = run2({
          editor,
          state: chainableState,
          from: Math.max(from2 - 1, 0),
          to: to.b - 1,
          rule,
          pasteEvent,
          dropEvent
        });
        if (!handler || !tr2.steps.length) {
          return;
        }
        dropEvent = new DragEvent("drop");
        pasteEvent = new ClipboardEvent("paste");
        return tr2;
      }
    });
  });
  return plugins;
}
function findDuplicates(items) {
  const filtered = items.filter((el, index) => items.indexOf(el) !== index);
  return [...new Set(filtered)];
}
var ExtensionManager = class _ExtensionManager {
  constructor(extensions2, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = _ExtensionManager.resolve(extensions2);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.extensions.forEach((extension) => {
      var _a;
      this.editor.extensionStorage[extension.name] = extension.storage;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      const onCreate2 = getExtensionField(extension, "onCreate", context);
      if (onCreate2) {
        this.editor.on("create", onCreate2);
      }
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      const onFocus = getExtensionField(extension, "onFocus", context);
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      const onBlur = getExtensionField(extension, "onBlur", context);
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      const onDestroy3 = getExtensionField(extension, "onDestroy", context);
      if (onDestroy3) {
        this.editor.on("destroy", onDestroy3);
      }
    });
  }
  static resolve(extensions2) {
    const resolvedExtensions = _ExtensionManager.sort(_ExtensionManager.flatten(extensions2));
    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
    if (duplicatedNames.length) {
      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
    }
    return resolvedExtensions;
  }
  static flatten(extensions2) {
    return extensions2.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addExtensions = getExtensionField(extension, "addExtensions", context);
      if (addExtensions) {
        return [extension, ...this.flatten(addExtensions())];
      }
      return extension;
    }).flat(10);
  }
  static sort(extensions2) {
    const defaultPriority = 100;
    return extensions2.sort((a, b) => {
      const priorityA = getExtensionField(a, "priority") || defaultPriority;
      const priorityB = getExtensionField(b, "priority") || defaultPriority;
      if (priorityA > priorityB) {
        return -1;
      }
      if (priorityA < priorityB) {
        return 1;
      }
      return 0;
    });
  }
  get commands() {
    return this.extensions.reduce((commands2, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands2;
      }
      return {
        ...commands2,
        ...addCommands()
      };
    }, {});
  }
  get plugins() {
    const { editor } = this;
    const extensions2 = _ExtensionManager.sort([...this.extensions].reverse());
    const inputRules = [];
    const pasteRules = [];
    const allPlugins = extensions2.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
      let defaultBindings = {};
      if (extension.type === "mark" && extension.config.exitable) {
        defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
          return [shortcut, () => method({ editor })];
        }));
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        pasteRules.push(...addPasteRules());
      }
      const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...pasteRulesPlugin({
        editor,
        rules: pasteRules
      }),
      ...allPlugins
    ];
  }
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
      const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionField(extension, "addNodeView", context);
      if (!addNodeView) {
        return [];
      }
      const nodeview = (node, view, getPos, decorations) => {
        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
        return addNodeView()({
          editor,
          node,
          getPos,
          decorations,
          HTMLAttributes,
          extension
        });
      };
      return [extension.name, nodeview];
    }));
  }
};
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key])) {
        if (!(key in target)) {
          Object.assign(output, { [key]: source[key] });
        } else {
          output[key] = mergeDeep(target[key], source[key]);
        }
      } else {
        Object.assign(output, { [key]: source[key] });
      }
    });
  }
  return output;
}
var Extension = class _Extension {
  constructor(config = {}) {
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Extension(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Extension({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function getTextBetween(startNode, range, options) {
  const { from: from2, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  let text2 = "";
  let separated = true;
  startNode.nodesBetween(from2, to, (node, pos, parent, index) => {
    var _a;
    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (node.isBlock && !separated) {
        text2 += blockSeparator;
        separated = true;
      }
      if (parent) {
        text2 += textSerializer({
          node,
          pos,
          parent,
          index,
          range
        });
      }
    } else if (node.isText) {
      text2 += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from2, pos) - pos, to - pos);
      separated = false;
    } else if (node.isBlock && !separated) {
      text2 += blockSeparator;
      separated = true;
    }
  });
  return text2;
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
}
var ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc3, selection } = state;
            const { ranges } = selection;
            const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema);
            const range = { from: from2, to };
            return getTextBetween(doc3, range, {
              textSerializers
            });
          }
        }
      })
    ];
  }
});
var blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
    }
  });
  return true;
};
var clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
  return commands2.setContent("", emitUpdate);
};
var clearNodes = () => ({ state, tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const { ranges } = selection;
  if (!dispatch) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc3, mapping } = tr2;
      const $mappedFrom = doc3.resolve(mapping.map(pos));
      const $mappedTo = doc3.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr2.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr2.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var command = (fn2) => (props) => {
  return fn2(props);
};
var createParagraphNear2 = () => ({ state, dispatch }) => {
  return createParagraphNear(state, dispatch);
};
var cut = (originRange, targetPos) => ({ editor, tr: tr2 }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr2.deleteRange(originRange.from, originRange.to);
  const newPos = tr2.mapping.map(targetPos);
  tr2.insert(newPos, contentSlice.content);
  tr2.setSelection(new TextSelection(tr2.doc.resolve(newPos - 1)));
  return true;
};
var deleteCurrentNode = () => ({ tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteNode = (typeOrName) => ({ tr: tr2, state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteRange2 = (range) => ({ tr: tr2, dispatch }) => {
  const { from: from2, to } = range;
  if (dispatch) {
    tr2.delete(from2, to);
  }
  return true;
};
var deleteSelection2 = () => ({ state, dispatch }) => {
  return deleteSelection(state, dispatch);
};
var enter = () => ({ commands: commands2 }) => {
  return commands2.keyboardShortcut("Enter");
};
var exitCode2 = () => ({ state, dispatch }) => {
  return exitCode(state, dispatch);
};
function objectIncludes(object1, object2, options = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(item.attrs, attributes);
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes = {}) {
  if (!$pos || !type) {
    return;
  }
  let start2 = $pos.parent.childAfter($pos.parentOffset);
  if ($pos.parentOffset === start2.offset && start2.offset !== 0) {
    start2 = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start2.node) {
    return;
  }
  const mark = findMarkInSet([...start2.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start2.index;
  let startPos = $pos.start() + start2.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start2.node.nodeSize;
  findMarkInSet([...start2.node.marks], type, attributes);
  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
var extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc3, selection } = tr2;
  const { $from, from: from2, to } = selection;
  if (dispatch) {
    const range = getMarkRange($from, type, attributes);
    if (range && range.from <= from2 && range.to >= to) {
      const newSelection = TextSelection.create(doc3, range.from, range.to);
      tr2.setSelection(newSelection);
    }
  }
  return true;
};
var first = (commands2) => (props) => {
  const items = typeof commands2 === "function" ? commands2(props) : commands2;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) {
      return true;
    }
  }
  return false;
};
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function resolveFocusPosition(doc3, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc3);
  const selectionAtEnd = Selection.atEnd(doc3);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc3, minMax(0, minPos, maxPos), minMax(doc3.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc3, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function isiOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var focus = (position = null, options = {}) => ({ editor, view, tr: tr2, dispatch }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position === null || position === false) {
    return true;
  }
  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr2.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch) {
    if (!isSameSelection) {
      tr2.setSelection(selection);
    }
    if (isSameSelection && tr2.storedMarks) {
      tr2.setStoredMarks(tr2.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var forEach = (items, fn2) => (props) => {
  return items.every((item, index) => fn2(item, { ...props, index }));
};
var insertContent = (value, options) => ({ tr: tr2, commands: commands2 }) => {
  return commands2.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options);
};
var removeWhitespaces = (node) => {
  const children2 = node.childNodes;
  for (let i = children2.length - 1; i >= 0; i -= 1) {
    const child = children2[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html);
}
function createNodeFromContent(content, schema, options) {
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  if (typeof content === "object" && content !== null) {
    try {
      if (Array.isArray(content) && content.length > 0) {
        return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      return schema.nodeFromJSON(content);
    } catch (error) {
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema, options);
    }
  }
  if (typeof content === "string") {
    const parser = DOMParser2.fromSchema(schema);
    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function selectionToInsertionEnd2(tr2, startLen, bias) {
  const last = tr2.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step = tr2.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map2 = tr2.mapping.maps[last];
  let end2 = 0;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 === 0) {
      end2 = newTo;
    }
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end2), bias));
}
var isFragment = (nodeOrFragment) => {
  return nodeOrFragment.toString().startsWith("<");
};
var insertContentAt = (position, value, options) => ({ tr: tr2, dispatch, editor }) => {
  if (dispatch) {
    options = {
      parseOptions: {},
      updateSelection: true,
      ...options
    };
    const content = createNodeFromContent(value, editor.schema, {
      parseOptions: {
        preserveWhitespace: "full",
        ...options.parseOptions
      }
    });
    if (content.toString() === "<>") {
      return true;
    }
    let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr2.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        tr2.insertText(value.map((v) => v.text || "").join(""), from2, to);
      } else if (typeof value === "object" && !!value && !!value.text) {
        tr2.insertText(value.text, from2, to);
      } else {
        tr2.insertText(value, from2, to);
      }
    } else {
      tr2.replaceWith(from2, to, content);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd2(tr2, tr2.steps.length - 1, -1);
    }
  }
  return true;
};
var joinUp2 = () => ({ state, dispatch }) => {
  return joinUp(state, dispatch);
};
var joinDown2 = () => ({ state, dispatch }) => {
  return joinDown(state, dispatch);
};
var joinBackward2 = () => ({ state, dispatch }) => {
  return joinBackward(state, dispatch);
};
var joinForward2 = () => ({ state, dispatch }) => {
  return joinForward(state, dispatch);
};
var joinItemBackward = () => ({ tr: tr2, state, dispatch }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch) {
      dispatch(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
var joinItemForward = () => ({ state, dispatch, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch) {
      dispatch(tr2);
    }
    return true;
  } catch (e) {
    return false;
  }
};
var joinTextblockBackward2 = () => ({ state, dispatch }) => {
  return joinTextblockBackward(state, dispatch);
};
var joinTextblockForward2 = () => ({ state, dispatch }) => {
  return joinTextblockForward(state, dispatch);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName2(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift2;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift2) {
    result = `Shift-${result}`;
  }
  return result;
}
var keyboardShortcut = (name) => ({ editor, view, tr: tr2, dispatch }) => {
  const keys2 = normalizeKeyName2(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr2.mapping);
    if (newStep && dispatch) {
      tr2.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty3 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty3) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
var lift3 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift2(state, dispatch);
};
var liftEmptyBlock2 = () => ({ state, dispatch }) => {
  return liftEmptyBlock(state, dispatch);
};
var liftListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem(type)(state, dispatch);
};
var newlineInCode2 = () => ({ state, dispatch }) => {
  return newlineInCode(state, dispatch);
};
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes = (typeOrName, attributes) => ({ tr: tr2, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr2.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr2.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var scrollIntoView = () => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    tr2.scrollIntoView();
  }
  return true;
};
var selectAll2 = () => ({ tr: tr2, commands: commands2 }) => {
  return commands2.setTextSelection({
    from: 0,
    to: tr2.doc.content.size
  });
};
var selectNodeBackward2 = () => ({ state, dispatch }) => {
  return selectNodeBackward(state, dispatch);
};
var selectNodeForward2 = () => ({ state, dispatch }) => {
  return selectNodeForward(state, dispatch);
};
var selectParentNode2 = () => ({ state, dispatch }) => {
  return selectParentNode(state, dispatch);
};
var selectTextblockEnd2 = () => ({ state, dispatch }) => {
  return selectTextblockEnd(state, dispatch);
};
var selectTextblockStart2 = () => ({ state, dispatch }) => {
  return selectTextblockStart(state, dispatch);
};
function createDocument(content, schema, parseOptions = {}) {
  return createNodeFromContent(content, schema, { slice: false, parseOptions });
}
var setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr: tr2, editor, dispatch }) => {
  const { doc: doc3 } = tr2;
  const document2 = createDocument(content, editor.schema, parseOptions);
  if (dispatch) {
    tr2.replaceWith(0, doc3.content.size, document2).setMeta("preventUpdate", !emitUpdate);
  }
  return true;
};
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from2, to, empty: empty3 } = state.selection;
  const marks = [];
  if (empty3) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function combineTransactionSteps(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction) => {
    transaction.steps.forEach((step) => {
      transform.step(step);
    });
  });
  return transform;
}
function defaultBlockAt2(match) {
  for (let i = 0; i < match.edgeCount; i += 1) {
    const { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildrenInRange(node, range, predicate) {
  const nodesWithPos = [];
  node.nodesBetween(range.from, range.to, (child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function getText2(node, options) {
  const range = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween(node, range, options);
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from: from2, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from2, to, (node2) => {
    nodes.push(node2);
  });
  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return { ...node.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function removeDuplicates(array, by = JSON.stringify) {
  const seen = {};
  return array.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {
    const rest = uniqueChanges.filter((_, i) => i !== index);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  const { mapping, steps } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from2, to } = steps[index];
      if (from2 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from2, to });
    } else {
      stepMap.forEach((from2, to) => {
        ranges.push({ from: from2, to });
      });
    }
    ranges.forEach(({ from: from2, to }) => {
      const newStart = mapping.slice(index).map(from2, -1);
      const newEnd = mapping.slice(index).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function getMarksBetween(from2, to, doc3) {
  const marks = [];
  if (from2 === to) {
    doc3.resolve(from2).marks().forEach((mark) => {
      const $pos = doc3.resolve(from2 - 1);
      const range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push({
        mark,
        ...range
      });
    });
  } else {
    doc3.nodesBetween(from2, to, (node, pos) => {
      if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === void 0) {
        return;
      }
      marks.push(...node.marks.map((mark) => ({
        from: pos,
        to: pos + node.nodeSize,
        mark
      })));
    });
  }
  return marks;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
    const extensionAttribute = extensionAttributes.find((item) => {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty3, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty3) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(...node.marks.map((mark) => ({
        mark,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
function isList(name, extensions2) {
  const { nodeExtensions } = splitExtensions(extensions2);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty(node) {
  var _a;
  const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
  const content = node.toJSON();
  return JSON.stringify(defaultContent) === JSON.stringify(content);
}
function isNodeSelection(value) {
  return value instanceof NodeSelection;
}
function posToDOMRect(view, from2, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from2, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start2 = view.coordsAtPos(resolvedFrom);
  const end2 = view.coordsAtPos(resolvedEnd, -1);
  const top2 = Math.min(start2.top, end2.top);
  const bottom2 = Math.max(start2.bottom, end2.bottom);
  const left2 = Math.min(start2.left, end2.left);
  const right2 = Math.max(start2.right, end2.right);
  const width = right2 - left2;
  const height = bottom2 - top2;
  const x = left2;
  const y = top2;
  const data = {
    top: top2,
    bottom: bottom2,
    left: left2,
    right: right2,
    width,
    height,
    x,
    y
  };
  return {
    ...data,
    toJSON: () => data
  };
}
function canSetMark(state, tr2, newMarkType) {
  var _a;
  const { selection } = tr2;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  const { selection } = tr2;
  const { empty: empty3, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch) {
    if (empty3) {
      const oldAttributes = getMarkAttributes(state, type);
      tr2.addStoredMark(type.create({
        ...oldAttributes,
        ...attributes
      }));
    } else {
      ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr2.addMark(trimmedFrom, trimmedTo, type.create({
                  ...mark.attrs,
                  ...attributes
                }));
              }
            });
          } else {
            tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr2, type);
};
var setMeta = (key, value) => ({ tr: tr2 }) => {
  tr2.setMeta(key, value);
  return true;
};
var setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
  const type = getNodeType(typeOrName, state.schema);
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain().command(({ commands: commands2 }) => {
    const canSetBlock = setBlockType2(type, attributes)(state);
    if (canSetBlock) {
      return true;
    }
    return commands2.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType2(type, attributes)(updatedState, dispatch);
  }).run();
};
var setNodeSelection = (position) => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr2;
    const from2 = minMax(position, 0, doc3.content.size);
    const selection = NodeSelection.create(doc3, from2);
    tr2.setSelection(selection);
  }
  return true;
};
var setTextSelection = (position) => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr2;
    const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = TextSelection.atStart(doc3).from;
    const maxPos = TextSelection.atEnd(doc3).to;
    const resolvedFrom = minMax(from2, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc3, resolvedFrom, resolvedEnd);
    tr2.setSelection(selection);
  }
  return true;
};
var sinkListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem(type)(state, dispatch);
};
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch, editor }) => {
  const { selection, doc: doc3 } = tr2;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc3, $from.pos)) {
      return false;
    }
    if (dispatch) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr2.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  if (dispatch) {
    const atEnd = $to.parentOffset === $to.parent.content.size;
    if (selection instanceof TextSelection) {
      tr2.deleteSelection();
    }
    const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    let types = atEnd && deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
    let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
      can = true;
      types = deflt ? [
        {
          type: deflt,
          attrs: newAttributes
        }
      ] : void 0;
    }
    if (can) {
      tr2.split(tr2.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr2.mapping.map($from.before());
        const $first = tr2.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr2.scrollIntoView();
  }
  return true;
};
var splitListItem = (typeOrName) => ({ tr: tr2, state, dispatch, editor }) => {
  var _a;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch) {
      let wrap2 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment.from($from.node(d).copy(wrap2));
      }
      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
      const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start2 = $from.before($from.depth - (depthBefore - 1));
      tr2.replace(start2, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr2.doc.nodesBetween(start2, tr2.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
      }
      tr2.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  tr2.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr2.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr2.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
  }
  return true;
};
var joinListBackwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const before = tr2.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr2.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr2.join(list.pos);
  return true;
};
var joinListForwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const after = tr2.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr2.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr2.join(after);
  return true;
};
var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr2, state, dispatch, chain, commands: commands2, can }) => {
  const { extensions: extensions2, splittableMarks } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode((node) => isList(node.type.name, extensions2))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands2.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions2) && listType.validContent(parentList.node.content) && dispatch) {
      return chain().command(() => {
        tr2.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch) {
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
  }
  return chain().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands2.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
};
var toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands2.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands2.setMark(type, attributes);
};
var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands2.setNode(toggleType);
  }
  return commands2.setNode(type, attributes);
};
var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands2.lift(type);
  }
  return commands2.wrapIn(type, attributes);
};
var undoInputRule = () => ({ state, dispatch }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        const tr2 = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr2.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr2.doc.resolve(undoable.from).marks();
          tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr2.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var unsetAllMarks = () => ({ tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const { empty: empty3, ranges } = selection;
  if (empty3) {
    return true;
  }
  if (dispatch) {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
var unsetMark = (typeOrName, options = {}) => ({ tr: tr2, state, dispatch }) => {
  var _a;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr2;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty3, ranges } = selection;
  if (!dispatch) {
    return true;
  }
  if (empty3 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
    const range = getMarkRange($from, type, attrs);
    if (range) {
      from2 = range.from;
      to = range.to;
    }
    tr2.removeMark(from2, to, type);
  } else {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr2.removeStoredMark(type);
  return true;
};
var updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr2.selection.ranges.forEach((range) => {
      const from2 = range.$from.pos;
      const to = range.$to.pos;
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr2.setNodeMarkup(pos, void 0, {
            ...node.attrs,
            ...attributes
          });
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              const trimmedFrom = Math.max(pos, from2);
              const trimmedTo = Math.min(pos + node.nodeSize, to);
              tr2.addMark(trimmedFrom, trimmedTo, markType.create({
                ...mark.attrs,
                ...attributes
              }));
            }
          });
        }
      });
    });
  }
  return true;
};
var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn(type, attributes)(state, dispatch);
};
var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList(type, attributes)(state, dispatch);
};
var commands = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur,
  clearContent,
  clearNodes,
  command,
  createParagraphNear: createParagraphNear2,
  cut,
  deleteCurrentNode,
  deleteNode,
  deleteRange: deleteRange2,
  deleteSelection: deleteSelection2,
  enter,
  exitCode: exitCode2,
  extendMarkRange,
  first,
  focus,
  forEach,
  insertContent,
  insertContentAt,
  joinUp: joinUp2,
  joinDown: joinDown2,
  joinBackward: joinBackward2,
  joinForward: joinForward2,
  joinItemBackward,
  joinItemForward,
  joinTextblockBackward: joinTextblockBackward2,
  joinTextblockForward: joinTextblockForward2,
  keyboardShortcut,
  lift: lift3,
  liftEmptyBlock: liftEmptyBlock2,
  liftListItem: liftListItem2,
  newlineInCode: newlineInCode2,
  resetAttributes,
  scrollIntoView,
  selectAll: selectAll2,
  selectNodeBackward: selectNodeBackward2,
  selectNodeForward: selectNodeForward2,
  selectParentNode: selectParentNode2,
  selectTextblockEnd: selectTextblockEnd2,
  selectTextblockStart: selectTextblockStart2,
  setContent,
  setMark,
  setMeta,
  setNode,
  setNodeSelection,
  setTextSelection,
  sinkListItem: sinkListItem2,
  splitBlock: splitBlock2,
  splitListItem,
  toggleList,
  toggleMark,
  toggleNode,
  toggleWrap,
  undoInputRule,
  unsetAllMarks,
  unsetMark,
  updateAttributes,
  wrapIn: wrapIn2,
  wrapInList: wrapInList2
});
var Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...commands
    };
  }
});
var Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: new PluginKey("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
var Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands2.command(({ tr: tr2 }) => {
        const { selection, doc: doc3 } = tr2;
        const { empty: empty3, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock ? tr2.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc3).from === pos;
        if (!empty3 || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {
          return false;
        }
        return commands2.clearNodes();
      }),
      () => commands2.deleteSelection(),
      () => commands2.joinBackward(),
      () => commands2.selectNodeBackward()
    ]);
    const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.deleteSelection(),
      () => commands2.deleteCurrentNode(),
      () => commands2.joinForward(),
      () => commands2.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.newlineInCode(),
      () => commands2.createParagraphNear(),
      () => commands2.liftEmptyBlock(),
      () => commands2.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete,
      "Mod-Delete": handleDelete,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete,
      "Ctrl-Alt-Backspace": handleDelete,
      "Alt-Delete": handleDelete,
      "Alt-d": handleDelete,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          if (!docChanges) {
            return;
          }
          const { empty: empty3, from: from2, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from2 === allFrom && to === allEnd;
          if (empty3 || !allWasSelected) {
            return;
          }
          const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, " ", " ").length === 0;
          if (!isEmpty) {
            return;
          }
          const tr2 = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr2
          });
          const { commands: commands2 } = new CommandManager({
            editor: this.editor,
            state
          });
          commands2.clearNodes();
          if (!tr2.steps.length) {
            return;
          }
          return tr2;
        }
      })
    ];
  }
});
var Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var extensions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ClipboardTextSerializer,
  Commands,
  Editable,
  FocusEvents,
  Keymap,
  Tabindex
});
var NodePos = class _NodePos {
  constructor(pos, editor, isBlock = false, node = null) {
    this.currentNode = null;
    this.actualDepth = null;
    this.isBlock = isBlock;
    this.resolvedPos = pos;
    this.editor = editor;
    this.currentNode = node;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var _a;
    return (_a = this.actualDepth) !== null && _a !== void 0 ? _a : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(content) {
    let from2 = this.from;
    let to = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      from2 = this.from + 1;
      to = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: from2, to }, content);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    if (this.isBlock) {
      return this.pos;
    }
    return this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    if (this.isBlock) {
      return this.pos + this.size;
    }
    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) {
      return null;
    }
    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
    const $pos = this.resolvedPos.doc.resolve(parentPos);
    return new _NodePos($pos, this.editor);
  }
  get before() {
    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.from - 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get after() {
    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.to + 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get children() {
    const children2 = [];
    this.node.content.forEach((node, offset2) => {
      const isBlock = node.isBlock && !node.isTextblock;
      const targetPos = this.pos + offset2 + (isBlock ? 0 : 1);
      const $pos = this.resolvedPos.doc.resolve(targetPos);
      if (!isBlock && $pos.depth <= this.depth) {
        return;
      }
      const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);
      if (isBlock) {
        childNodePos.actualDepth = this.depth + 1;
      }
      children2.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));
    });
    return children2;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const children2 = this.children;
    return children2[children2.length - 1] || null;
  }
  closest(selector, attributes = {}) {
    let node = null;
    let currentNode = this.parent;
    while (currentNode && !node) {
      if (currentNode.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = currentNode.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index = 0; index < attrKeys.length; index += 1) {
            const key = attrKeys[index];
            if (nodeAttributes[key] !== attributes[key]) {
              break;
            }
          }
        } else {
          node = currentNode;
        }
      }
      currentNode = currentNode.parent;
    }
    return node;
  }
  querySelector(selector, attributes = {}) {
    return this.querySelectorAll(selector, attributes, true)[0] || null;
  }
  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
    let nodes = [];
    if (this.isBlock || !this.children || this.children.length === 0) {
      return nodes;
    }
    this.children.forEach((childPos) => {
      if (childPos.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = childPos.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index = 0; index < attrKeys.length; index += 1) {
            const key = attrKeys[index];
            if (nodeAttributes[key] !== attributes[key]) {
              return;
            }
          }
        }
        nodes.push(childPos);
        if (firstItemOnly) {
          return;
        }
      }
      nodes = nodes.concat(childPos.querySelectorAll(selector));
    });
    return nodes;
  }
  setAttribute(attributes) {
    const oldSelection = this.editor.state.selection;
    this.editor.chain().setTextSelection(this.from).updateAttributes(this.node.type.name, attributes).setTextSelection(oldSelection.from).run();
  }
};
var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function createStyleTag(style2, nonce, suffix) {
  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
var Editor = class extends EventEmitter {
  constructor(options = {}) {
    super();
    this.isFocused = false;
    this.extensionStorage = {};
    this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.createView();
    this.injectCSS();
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    if (this.options.injectCSS && document) {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr });
    }
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   */
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKey The plugins name
   */
  unregisterPlugin(nameOrPluginKey) {
    if (this.isDestroyed) {
      return;
    }
    const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
    const state = this.state.reconfigure({
      // @ts-ignore
      plugins: this.state.plugins.filter((plugin) => !plugin.key.startsWith(name))
    });
    this.view.updateState(state);
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    const doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions);
    const selection = resolveFocusPosition(doc3, this.options.autofocus);
    this.view = new EditorView(this.options.element, {
      ...this.options.editorProps,
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: EditorState.create({
        doc: doc3,
        selection: selection || void 0
      })
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    this.prependClass();
    const dom = this.view.dom;
    dom.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(fn2) {
    this.isCapturingTransaction = true;
    fn2();
    this.isCapturingTransaction = false;
    const tr2 = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr2;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(transaction) {
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach((step) => {
        var _a;
        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);
      });
      return;
    }
    const state = this.state.apply(transaction);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction
      });
    }
    const focus2 = transaction.getMeta("focus");
    const blur2 = transaction.getMeta("blur");
    if (focus2) {
      this.emit("focus", {
        editor: this,
        event: focus2.event,
        transaction
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        transaction
      });
    }
    if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(options) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    return getText2(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(this.schema),
        ...textSerializers
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
    return this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy");
    if (this.view) {
      this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var _a;
    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
  }
  $node(selector, attributes) {
    var _a;
    return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelector(selector, attributes)) || null;
  }
  $nodes(selector, attributes) {
    var _a;
    return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector, attributes)) || null;
  }
  $pos(pos) {
    const $pos = this.state.doc.resolve(pos);
    return new NodePos($pos, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        const markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
function nodeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const { tr: tr2 } = state;
      const start2 = range.from;
      let end2 = range.to;
      const newNode = config.type.create(attributes);
      if (match[1]) {
        const offset2 = match[0].lastIndexOf(match[1]);
        let matchStart = start2 + offset2;
        if (matchStart > end2) {
          matchStart = end2;
        } else {
          end2 = matchStart + match[1].length;
        }
        const lastChar = match[0][match[0].length - 1];
        tr2.insertText(lastChar, start2 + match[0].length - 1);
        tr2.replaceWith(matchStart, end2, newNode);
      } else if (match[0]) {
        tr2.insert(start2 - 1, config.type.create(attributes)).delete(tr2.mapping.map(start2), tr2.mapping.map(end2));
      }
      tr2.scrollIntoView();
    }
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const $start = state.doc.resolve(range.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    }
  });
}
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match, chain }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const tr2 = state.tr.delete(range.from, range.to);
      const $start = tr2.doc.resolve(range.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr2.wrap(blockRange, wrapping);
      if (config.keepMarks && config.editor) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = config.editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (marks) {
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr2.ensureMarks(filteredMarks);
        }
      }
      if (config.keepAttributes) {
        const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
        chain().updateAttributes(nodeType, attributes).run();
      }
      const before = tr2.doc.resolve(range.from - 1).nodeBefore;
      if (before && before.type === config.type && canJoin(tr2.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
        tr2.join(range.from - 1);
      }
    }
  });
}
var Mark2 = class _Mark {
  constructor(config = {}) {
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Mark(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Mark({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  static handleExit({ editor, mark }) {
    const { tr: tr2 } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (removeMark2) {
        tr2.removeStoredMark(removeMark2);
      }
      tr2.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr2);
      return true;
    }
    return false;
  }
};
var Node2 = class _Node {
  constructor(config = {}) {
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Node(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Node({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function isAndroid() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
var NodeView = class {
  constructor(component, props, options) {
    this.isDragging = false;
    this.component = component;
    this.editor = props.editor;
    this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...options
    };
    this.extension = props.extension;
    this.node = props.node;
    this.decorations = props.decorations;
    this.getPos = props.getPos;
    this.mount();
  }
  mount() {
    return;
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(event) {
    var _a, _b, _c, _d, _e, _f, _g;
    const { view } = this.editor;
    const target = event.target;
    const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest("[data-drag-handle]") : target.closest("[data-drag-handle]");
    if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {
      return;
    }
    let x = 0;
    let y = 0;
    if (this.dom !== dragHandle) {
      const domBox = this.dom.getBoundingClientRect();
      const handleBox = dragHandle.getBoundingClientRect();
      const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;
      const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;
      x = handleBox.x - domBox.x + offsetX;
      y = handleBox.y - domBox.y + offsetY;
    }
    (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y);
    const selection = NodeSelection.create(view.state.doc, this.getPos());
    const transaction = view.state.tr.setSelection(selection);
    view.dispatch(transaction);
  }
  stopEvent(event) {
    var _a;
    if (!this.dom) {
      return false;
    }
    if (typeof this.options.stopEvent === "function") {
      return this.options.stopEvent({ event });
    }
    const target = event.target;
    const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));
    if (!isInElement) {
      return false;
    }
    const isDragEvent = event.type.startsWith("drag");
    const isDropEvent = event.type === "drop";
    const isInput = ["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(target.tagName) || target.isContentEditable;
    if (isInput && !isDropEvent && !isDragEvent) {
      return true;
    }
    const { isEditable } = this.editor;
    const { isDragging } = this;
    const isDraggable = !!this.node.type.spec.draggable;
    const isSelectable = NodeSelection.isSelectable(this.node);
    const isCopyEvent = event.type === "copy";
    const isPasteEvent = event.type === "paste";
    const isCutEvent = event.type === "cut";
    const isClickEvent = event.type === "mousedown";
    if (!isDraggable && isSelectable && isDragEvent) {
      event.preventDefault();
    }
    if (isDraggable && isDragEvent && !isDragging) {
      event.preventDefault();
      return false;
    }
    if (isDraggable && isEditable && !isDragging && isClickEvent) {
      const dragHandle = target.closest("[data-drag-handle]");
      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));
      if (isValidDragHandle) {
        this.isDragging = true;
        document.addEventListener("dragend", () => {
          this.isDragging = false;
        }, { once: true });
        document.addEventListener("drop", () => {
          this.isDragging = false;
        }, { once: true });
        document.addEventListener("mouseup", () => {
          this.isDragging = false;
        }, { once: true });
      }
    }
    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {
      return false;
    }
    return true;
  }
  ignoreMutation(mutation) {
    if (!this.dom || !this.contentDOM) {
      return true;
    }
    if (typeof this.options.ignoreMutation === "function") {
      return this.options.ignoreMutation({ mutation });
    }
    if (this.node.isLeaf || this.node.isAtom) {
      return true;
    }
    if (mutation.type === "selection") {
      return false;
    }
    if (this.dom.contains(mutation.target) && mutation.type === "childList" && (isiOS() || isAndroid()) && this.editor.isFocused) {
      const changedNodes = [
        ...Array.from(mutation.addedNodes),
        ...Array.from(mutation.removedNodes)
      ];
      if (changedNodes.every((node) => node.isContentEditable)) {
        return false;
      }
    }
    if (this.contentDOM === mutation.target && mutation.type === "attributes") {
      return true;
    }
    if (this.contentDOM.contains(mutation.target)) {
      return false;
    }
    return true;
  }
  updateAttributes(attributes) {
    this.editor.commands.command(({ tr: tr2 }) => {
      const pos = this.getPos();
      tr2.setNodeMarkup(pos, void 0, {
        ...this.node.attrs,
        ...attributes
      });
      return true;
    });
  }
  deleteNode() {
    const from2 = this.getPos();
    const to = from2 + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: from2, to });
  }
};
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range, match, pasteEvent }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
function escapeForRegEx(string) {
  return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect2 = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect2.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect2.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect2.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect2.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect2.width / scaleX;
  var height = clientRect2.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect2 = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect2.width - width) <= 1) {
    width = clientRect2.width;
  }
  if (Math.abs(clientRect2.height - height) <= 1) {
    height = clientRect2.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element2.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element2.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element2.parentNode || // DOM Element detected
    (isShadowRoot(element2) ? element2.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element2)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance13 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance13.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance13.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance13.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance13.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element2),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers2) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers2.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance13 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance13.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance: instance13
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance13.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance13;
    }
    instance13.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect5 = _ref.effect;
        if (typeof effect5 === "function") {
          var cleanupFn = effect5({
            state,
            name,
            instance: instance13,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance13;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// node_modules/tippy.js/dist/tippy.esm.js
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce2(fn2, ms) {
  if (ms === 0) {
    return fn2;
  }
  var timeout;
  return function(arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      fn2(arg);
    }, ms);
  };
}
function removeProperties(obj, keys2) {
  var clone = Object.assign({}, obj);
  keys2.forEach(function(key) {
    delete clone[key];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function(item, index) {
    return arr.indexOf(item) === index;
  });
}
function getBasePlacement2(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement2(value) {
  return ["Element", "Fragment"].some(function(type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement2(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function(el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function(el) {
    if (el) {
      el.setAttribute("data-state", state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element2 = _normalizeToArray[0];
  return element2 != null && (_element$ownerDocumen = element2.ownerDocument) != null && _element$ownerDocumen.body ? element2.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref) {
    var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement2(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method](event, listener);
  });
}
function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now2 = performance.now();
  if (now2 - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now2;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance13 = activeElement._tippy;
    if (activeElement.blur && !instance13.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser ? (
  // @ts-ignore
  !!window.msCrypto
) : false;
function createMemoryLeakWarning(method) {
  var txt = method === "destroy" ? "n already-" : " ";
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
}
function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\u{1F477}\u200D This is a development-only message. It will be removed in production.\n  ");
}
function getFormattedMessage(message) {
  return [
    getDevMessage(message),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var visitedMessages;
if (true) {
  resetVisitedMessages();
}
function resetVisitedMessages() {
  visitedMessages = /* @__PURE__ */ new Set();
}
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;
    visitedMessages.add(message);
    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;
    visitedMessages.add(message);
    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
  errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {
  },
  onBeforeUpdate: function onBeforeUpdate() {
  },
  onCreate: function onCreate() {
  },
  onDestroy: function onDestroy2() {
  },
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount2() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  onUntrigger: function onUntrigger() {
  },
  onClickOutside: function onClickOutside() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  if (true) {
    validateProps(partialProps, []);
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps2 = plugins.reduce(function(acc, plugin) {
    var name = plugin.name, defaultValue = plugin.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key) {
    var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference2, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference2])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function(plugin) {
        return plugin.name === prop;
      }).length === 0;
    }
    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element2, html) {
  element2[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow3 = div();
  if (value === true) {
    arrow3.className = ARROW_CLASS;
  } else {
    arrow3.className = SVG_ARROW_CLASS;
    if (isElement2(value)) {
      arrow3.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow3, value);
    }
  }
  return arrow3;
}
function setContent2(content, props) {
  if (isElement2(props.content)) {
    dangerouslySetInnerHTML(content, "");
    content.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function(node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance13) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute("data-state", "hidden");
  setContent2(content, instance13.props);
  popper2.appendChild(box);
  box.appendChild(content);
  onUpdate(instance13.props, instance13.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow3 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent2(content2, instance13.props);
    }
    if (nextProps.arrow) {
      if (!arrow3) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow3);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow3) {
      box2.removeChild(arrow3);
    }
  }
  return {
    popper: popper2,
    onUpdate
  };
}
render.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce2(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance13 = {
    // properties
    id,
    reference: reference2,
    popper: div(),
    popperInstance,
    props,
    state,
    plugins,
    // methods
    clearDelayTimeouts,
    setProps,
    setContent: setContent3,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy
  };
  if (!props.render) {
    if (true) {
      errorWhen(true, "render() function has not been supplied.");
    }
    return instance13;
  }
  var _props$render = props.render(instance13), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance13.id;
  instance13.popper = popper2;
  reference2._tippy = instance13;
  popper2._tippy = instance13;
  var pluginsHooks = plugins.map(function(plugin) {
    return plugin.fn(instance13);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance13]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance13.props.interactive && instance13.state.isVisible) {
      instance13.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance13.props.interactive && instance13.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance13;
  function getNormalizedTouchSettings() {
    var touch = instance13.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance13.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance13.state.isMounted && !instance13.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance13.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance13.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance13.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance13.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance13.props.aria;
    if (!aria.content) {
      return;
    }
    var attr2 = "aria-" + aria.content;
    var id2 = popper2.id;
    var nodes = normalizeToArray(instance13.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      var currentValue = node.getAttribute(attr2);
      if (instance13.state.isVisible) {
        node.setAttribute(attr2, currentValue ? currentValue + " " + id2 : id2);
      } else {
        var nextValue = currentValue && currentValue.replace(id2, "").trim();
        if (nextValue) {
          node.setAttribute(attr2, nextValue);
        } else {
          node.removeAttribute(attr2);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance13.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance13.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      if (instance13.props.interactive) {
        node.setAttribute("aria-expanded", instance13.state.isVisible && node === getCurrentTarget() ? "true" : "false");
      } else {
        node.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance13.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance13.props.triggerTarget || reference2).some(function(el) {
      return actualContains(el, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance13.state.isVisible && instance13.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance13, event]);
    }
    if (instance13.props.hideOnClick === true) {
      instance13.clearDelayTimeouts();
      instance13.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance13.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc3 = getDocument();
    doc3.addEventListener("mousedown", onDocumentPress, true);
    doc3.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc3.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc3.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc3 = getDocument();
    doc3.removeEventListener("mousedown", onDocumentPress, true);
    doc3.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc3.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc3.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance13.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance13.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node,
        eventType,
        handler,
        options
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on("touchstart", onTrigger2, {
        passive: true
      });
      on("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance13.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on("mouseleave", onMouseLeave);
          break;
        case "focus":
          on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function(_ref) {
      var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance13.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance13.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance13.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance13.props.hideOnClick !== false && instance13.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
      var _instance$popperInsta;
      var instance14 = popper3._tippy;
      var state2 = (_instance$popperInsta = instance14.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state2) {
        return {
          popperRect: popper3.getBoundingClientRect(),
          popperState: state2,
          props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance13.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance13.props.interactive) {
      instance13.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance13.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance13.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance13.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow3 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference2;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn2(_ref2) {
        var state2 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr2) {
            if (attr2 === "placement") {
              box.setAttribute("data-placement", state2.placement);
            } else {
              if (state2.attributes.popper["data-popper-" + attr2]) {
                box.setAttribute("data-" + attr2, "");
              } else {
                box.removeAttribute("data-" + attr2);
              }
            }
          });
          state2.attributes.popper = {};
        }
      }
    };
    var modifiers2 = [{
      name: "offset",
      options: {
        offset: offset2
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow3) {
      modifiers2.push({
        name: "arrow",
        options: {
          element: arrow3,
          padding: 3
        }
      });
    }
    modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance13.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers: modifiers2
    }));
  }
  function destroyPopperInstance() {
    if (instance13.popperInstance) {
      instance13.popperInstance.destroy();
      instance13.popperInstance = null;
    }
  }
  function mount() {
    var appendTo = instance13.props.appendTo;
    var parentNode2;
    var node = getCurrentTarget();
    if (instance13.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode2 = node.parentNode;
    } else {
      parentNode2 = invokeWithArgsOrReturn(appendTo, [node]);
    }
    if (!parentNode2.contains(popper2)) {
      parentNode2.appendChild(popper2);
    }
    instance13.state.isMounted = true;
    createPopperInstance();
    if (true) {
      warnWhen(instance13.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
    }
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance13.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance13, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance13.show();
      }, delay);
    } else {
      instance13.show();
    }
  }
  function scheduleHide(event) {
    instance13.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance13, event]);
    if (!instance13.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance13.props.trigger.indexOf("mouseenter") >= 0 && instance13.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance13.state.isVisible) {
          instance13.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance13.hide();
      });
    }
  }
  function enable() {
    instance13.state.isEnabled = true;
  }
  function disable() {
    instance13.hide();
    instance13.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    if (true) {
      warnWhen(instance13.state.isDestroyed, createMemoryLeakWarning("setProps"));
    }
    if (instance13.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance13, partialProps]);
    removeListeners();
    var prevProps = instance13.props;
    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance13.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce2(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
        node.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance13.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance13, partialProps]);
  }
  function setContent3(content) {
    instance13.setProps({
      content
    });
  }
  function show() {
    if (true) {
      warnWhen(instance13.state.isDestroyed, createMemoryLeakWarning("show"));
    }
    var isAlreadyVisible = instance13.state.isVisible;
    var isDestroyed = instance13.state.isDestroyed;
    var isDisabled = !instance13.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance13.props.touch;
    var duration = getValueAtIndexOrReturn(instance13.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance13], false);
    if (instance13.props.onShow(instance13) === false) {
      return;
    }
    instance13.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance13.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance13.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance13.props.moveTransition;
      if (getIsDefaultRenderFn() && instance13.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance13);
      (_instance$popperInsta2 = instance13.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance13]);
      if (instance13.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance13.state.isShown = true;
          invokeHook("onShown", [instance13]);
        });
      }
    };
    mount();
  }
  function hide2() {
    if (true) {
      warnWhen(instance13.state.isDestroyed, createMemoryLeakWarning("hide"));
    }
    var isAlreadyHidden = !instance13.state.isVisible;
    var isDestroyed = instance13.state.isDestroyed;
    var isDisabled = !instance13.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance13.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance13], false);
    if (instance13.props.onHide(instance13) === false) {
      return;
    }
    instance13.state.isVisible = false;
    instance13.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
      if (instance13.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance13.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance13.unmount);
      }
    } else {
      instance13.unmount();
    }
  }
  function hideWithInteractivity(event) {
    if (true) {
      warnWhen(instance13.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
    }
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    if (true) {
      warnWhen(instance13.state.isDestroyed, createMemoryLeakWarning("unmount"));
    }
    if (instance13.state.isVisible) {
      instance13.hide();
    }
    if (!instance13.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i) {
      return i !== instance13;
    });
    instance13.state.isMounted = false;
    invokeHook("onHidden", [instance13]);
  }
  function destroy() {
    if (true) {
      warnWhen(instance13.state.isDestroyed, createMemoryLeakWarning("destroy"));
    }
    if (instance13.state.isDestroyed) {
      return;
    }
    instance13.clearDelayTimeouts();
    instance13.unmount();
    removeListeners();
    delete reference2._tippy;
    instance13.state.isDestroyed = true;
    invokeHook("onDestroy", [instance13]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  if (true) {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins
  });
  var elements = getArrayOfElements(targets);
  if (true) {
    var isSingleContentElement = isElement2(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var instances = elements.reduce(function(acc, reference2) {
    var instance13 = reference2 && createTippy(reference2, passedProps);
    if (instance13) {
      acc.push(instance13);
    }
    return acc;
  }, []);
  return isElement2(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
var applyStylesModifier = Object.assign({}, applyStyles_default, {
  effect: function effect4(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
  }
});
tippy.setDefaultProps({
  render
});
var tippy_esm_default = tippy;

// node_modules/@tiptap/extension-bubble-menu/dist/index.js
var BubbleMenuView = class {
  constructor({ editor, element: element2, view, tippyOptions = {}, updateDelay = 250, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state, from: from2, to }) => {
      const { doc: doc3, selection } = state;
      const { empty: empty3 } = selection;
      const isEmptyTextBlock = !doc3.textBetween(from2, to).length && isTextSelection(state.selection);
      const isChildOfMenu = this.element.contains(document.activeElement);
      const hasEditorFocus = view2.hasFocus() || isChildOfMenu;
      if (!hasEditorFocus || empty3 || isEmptyTextBlock || !this.editor.isEditable) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.dragstartHandler = () => {
      this.hide();
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      this.hide();
    };
    this.tippyBlurHandler = (event) => {
      this.blurHandler({ event });
    };
    this.handleDebouncedUpdate = (view2, oldState) => {
      const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view2.state.selection));
      const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view2.state.doc));
      if (!selectionChanged && !docChanged) {
        return;
      }
      if (this.updateDebounceTimer) {
        clearTimeout(this.updateDebounceTimer);
      }
      this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(view2, selectionChanged, docChanged, oldState);
      }, this.updateDelay);
    };
    this.updateHandler = (view2, selectionChanged, docChanged, oldState) => {
      var _a, _b, _c;
      const { state, composing } = view2;
      const { selection } = state;
      const isSame = !selectionChanged && !docChanged;
      if (composing || isSame) {
        return;
      }
      this.createTooltip();
      const { ranges } = selection;
      const from2 = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      const shouldShow2 = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
        editor: this.editor,
        view: view2,
        state,
        oldState,
        from: from2,
        to
      });
      if (!shouldShow2) {
        this.hide();
        return;
      }
      (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
        getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {
          if (isNodeSelection(state.selection)) {
            let node = view2.nodeDOM(from2);
            const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector("[data-node-view-wrapper]");
            if (nodeViewWrapper) {
              node = nodeViewWrapper.firstChild;
            }
            if (node) {
              return node.getBoundingClientRect();
            }
          }
          return posToDOMRect(view2, from2, to);
        })
      });
      this.show();
    };
    this.editor = editor;
    this.element = element2;
    this.view = view;
    this.updateDelay = updateDelay;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.addEventListener("dragstart", this.dragstartHandler);
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy_esm_default(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
    }
  }
  update(view, oldState) {
    const { state } = view;
    const hasValidSelection = state.selection.$from.pos !== state.selection.$to.pos;
    if (this.updateDelay > 0 && hasValidSelection) {
      this.handleDebouncedUpdate(view, oldState);
      return;
    }
    const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));
    const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));
    this.updateHandler(view, selectionChanged, docChanged, oldState);
  }
  show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a, _b;
    if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {
      this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
};
var BubbleMenuPlugin = (options) => {
  return new Plugin({
    key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
    view: (view) => new BubbleMenuView({ view, ...options })
  });
};
var BubbleMenu = Extension.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      BubbleMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});

// resources/js/extensions/ClassExtension.js
var ClassExtension_default = Extension.create({
  name: "classExtension",
  addGlobalAttributes() {
    return [
      {
        types: [
          "heading",
          "paragraph",
          "link",
          "image",
          "listItem",
          "bulletList",
          "orderedList",
          "table",
          "tableHeader",
          "tableRow",
          "tableCell",
          "textStyle"
        ],
        attributes: {
          class: {
            default: null,
            parseHTML: (element2) => element2.getAttribute("class") ?? null,
            renderHTML: (attributes) => {
              if (!attributes.class) {
                return null;
              }
              return {
                class: attributes.class
              };
            }
          }
        }
      }
    ];
  }
});

// resources/js/extensions/CommandsExtension.js
var CommandsExtension_default = Extension.create({
  name: "commandsExtension",
  addCommands() {
    return {
      moveToEnd: () => ({ chain, state, dispatch }) => {
        if (state.selection.empty)
          return false;
        return chain().setTextSelection(state.selection.$to.pos).run();
      }
    };
  }
});

// resources/js/extensions/Grid/utils/createColumn.js
function createColumn(colType, colSpan, colContent = null) {
  if (colContent) {
    return colType.createChecked({ "data-col-span": colSpan }, colContent);
  }
  return colType.createAndFill({ "data-col-span": colSpan });
}

// resources/js/extensions/Grid/utils/getGridNodeTypes.js
function getGridNodeTypes(schema) {
  if (schema.cached.gridNodeTypes) {
    return schema.cached.gridNodeTypes;
  }
  const roles = {};
  Object.keys(schema.nodes).forEach((type) => {
    const nodeType = schema.nodes[type];
    if (nodeType.spec.gridRole) {
      roles[nodeType.spec.gridRole] = nodeType;
    }
  });
  schema.cached.gridNodeTypes = roles;
  return roles;
}

// resources/js/extensions/Grid/utils/createGrid.js
function createGrid(schema, colsCount, stackAt, asymmetric, leftSpan = null, rightSpan = null, colContent = null) {
  const { grid, column } = getGridNodeTypes(schema);
  const cols = [];
  if (asymmetric) {
    cols.push(createColumn(column, leftSpan, colContent));
    cols.push(createColumn(column, rightSpan, colContent));
  } else {
    for (let index = 0; index < colsCount; index += 1) {
      const col = createColumn(column, 1, colContent);
      if (col) {
        cols.push(col);
      }
    }
  }
  return grid.createChecked({ "data-columns": colsCount, "data-type": asymmetric ?? "responsive", "data-stack-at": stackAt }, cols);
}

// resources/js/extensions/Grid/Grid.js
var Grid_default = Node2.create({
  name: "grid",
  group: "block",
  defining: true,
  isolating: true,
  allowGapCursor: false,
  content: "gridColumn+",
  gridRole: "grid",
  addOptions() {
    return {
      HTMLAttributes: {
        class: "scribble-grid"
      }
    };
  },
  addAttributes() {
    return {
      "data-type": {
        default: "responsive",
        parseHTML: (element2) => element2.getAttribute("data-type")
      },
      "data-columns": {
        default: 2,
        parseHTML: (element2) => element2.getAttribute("data-columns")
      },
      "data-stack-at": {
        default: "md",
        parseHTML: (element2) => element2.getAttribute("data-stack-at")
      },
      "style": {
        default: null,
        parseHTML: (element2) => element2.getAttribute("style"),
        renderHTML: (attributes) => {
          return {
            style: `grid-template-columns: repeat(${attributes["data-columns"]}, 1fr);`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "div[data-type='grid']"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["div", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      insertGrid: ({ columns = 2, stack_at, asymmetric, left_span = null, right_span = null } = {}) => ({ tr: tr2, dispatch, editor }) => {
        const node = createGrid(editor.schema, columns, stack_at, asymmetric, left_span, right_span);
        if (dispatch) {
          const offset2 = tr2.selection.anchor + 1;
          tr2.replaceSelectionWith(node).scrollIntoView().setSelection(TextSelection.near(tr2.doc.resolve(offset2)));
        }
        return true;
      }
    };
  },
  extendNodeSchema(extension) {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      gridRole: callOrReturn(getExtensionField(extension, "gridRole", context))
    };
  }
});

// resources/js/extensions/Grid/GridColumn.js
var GridColumn_default = Node2.create({
  name: "gridColumn",
  content: "block+",
  gridRole: "column",
  isolating: true,
  addOptions() {
    return {
      HTMLAttributes: {
        class: "scribble-grid-column"
      }
    };
  },
  addAttributes() {
    return {
      "data-col-span": {
        default: 1,
        parseHTML: (element2) => element2.getAttribute("data-col-span"),
        renderHTML: (attributes) => {
          return {
            "data-col-span": attributes["data-col-span"] ?? 1
          };
        }
      },
      "style": {
        default: null,
        parseHTML: (element2) => element2.getAttribute("style"),
        renderHTML: (attributes) => {
          return {
            style: `grid-column: span ${attributes["data-col-span"] ?? 1};`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "div",
        getAttrs: (node) => node.classList.contains("scribble-grid-column") && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["div", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  }
});

// resources/js/extensions/IdExtension.js
var IdExtension_default = Extension.create({
  name: "idExtension",
  addGlobalAttributes() {
    return [
      {
        types: [
          "heading",
          "link"
        ],
        attributes: {
          id: {
            default: null,
            parseHTML: (element2) => element2.getAttribute("id") ?? null,
            renderHTML: (attributes) => {
              if (!attributes.id) {
                return null;
              }
              return {
                id: attributes.id
              };
            }
          }
        }
      }
    ];
  }
});

// node_modules/linkifyjs/dist/linkify.es.js
var encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5m\xF6gensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
var encodedUtlds = "\u03B5\u03BB1\u03C52\u0431\u04331\u0435\u043B3\u0434\u0435\u0442\u04384\u0435\u044E2\u043A\u0430\u0442\u043E\u043B\u0438\u043A6\u043E\u043C3\u043C\u043A\u04342\u043E\u043D1\u0441\u043A\u0432\u04306\u043E\u043D\u043B\u0430\u0439\u043D5\u0440\u04333\u0440\u0443\u04412\u04442\u0441\u0430\u0439\u04423\u0440\u04313\u0443\u043A\u04403\u049B\u0430\u04373\u0570\u0561\u05753\u05D9\u05E9\u05E8\u05D0\u05DC5\u05E7\u05D5\u05DD3\u0627\u0628\u0648\u0638\u0628\u064A5\u0631\u0627\u0645\u0643\u06485\u0644\u0627\u0631\u062F\u06464\u0628\u062D\u0631\u064A\u06465\u062C\u0632\u0627\u0626\u06315\u0633\u0639\u0648\u062F\u064A\u06296\u0639\u0644\u064A\u0627\u06465\u0645\u063A\u0631\u06285\u0645\u0627\u0631\u0627\u062A5\u06CC\u0631\u0627\u06465\u0628\u0627\u0631\u062A2\u0632\u0627\u06314\u064A\u062A\u06433\u06BE\u0627\u0631\u062A5\u062A\u0648\u0646\u06334\u0633\u0648\u062F\u0627\u06463\u0631\u064A\u06295\u0634\u0628\u0643\u06294\u0639\u0631\u0627\u06422\u06282\u0645\u0627\u06464\u0641\u0644\u0633\u0637\u064A\u06466\u0642\u0637\u06313\u0643\u0627\u062B\u0648\u0644\u064A\u06436\u0648\u06453\u0645\u0635\u06312\u0644\u064A\u0633\u064A\u06275\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u06277\u0642\u06394\u0647\u0645\u0631\u0627\u06475\u067E\u0627\u06A9\u0633\u062A\u0627\u06467\u0680\u0627\u0631\u062A4\u0915\u0949\u092E3\u0928\u0947\u091F3\u092D\u093E\u0930\u09240\u092E\u094D3\u094B\u09245\u0938\u0902\u0917\u0920\u09285\u09AC\u09BE\u0982\u09B2\u09BE5\u09AD\u09BE\u09B0\u09A42\u09F0\u09A44\u0A2D\u0A3E\u0A30\u0A244\u0AAD\u0ABE\u0AB0\u0AA44\u0B2D\u0B3E\u0B30\u0B244\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE6\u0BB2\u0B99\u0BCD\u0B95\u0BC86\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD11\u0C2D\u0C3E\u0C30\u0C24\u0C4D5\u0CAD\u0CBE\u0CB0\u0CA44\u0D2D\u0D3E\u0D30\u0D24\u0D025\u0DBD\u0D82\u0D9A\u0DCF4\u0E04\u0E2D\u0E213\u0E44\u0E17\u0E223\u0EA5\u0EB2\u0EA73\u10D2\u10D42\u307F\u3093\u306A3\u30A2\u30DE\u30BE\u30F34\u30AF\u30E9\u30A6\u30C94\u30B0\u30FC\u30B0\u30EB4\u30B3\u30E02\u30B9\u30C8\u30A23\u30BB\u30FC\u30EB3\u30D5\u30A1\u30C3\u30B7\u30E7\u30F36\u30DD\u30A4\u30F3\u30C84\u4E16\u754C2\u4E2D\u4FE11\u56FD1\u570B1\u6587\u7F513\u4E9A\u9A6C\u900A3\u4F01\u4E1A2\u4F5B\u5C712\u4FE1\u606F2\u5065\u5EB72\u516B\u53662\u516C\u53F81\u76CA2\u53F0\u6E7E1\u70632\u5546\u57CE1\u5E971\u68072\u5609\u91CC0\u5927\u9152\u5E975\u5728\u7EBF2\u5927\u62FF2\u5929\u4E3B\u65593\u5A31\u4E502\u5BB6\u96FB2\u5E7F\u4E1C2\u5FAE\u535A2\u6148\u55842\u6211\u7231\u4F603\u624B\u673A2\u62DB\u80582\u653F\u52A11\u5E9C2\u65B0\u52A0\u57612\u95FB2\u65F6\u5C1A2\u66F8\u7C4D2\u673A\u67842\u6DE1\u9A6C\u95213\u6E38\u620F2\u6FB3\u95802\u70B9\u770B2\u79FB\u52A82\u7EC4\u7EC7\u673A\u67844\u7F51\u57401\u5E971\u7AD91\u7EDC2\u8054\u901A2\u8C37\u6B4C2\u8D2D\u72692\u901A\u8CA92\u96C6\u56E22\u96FB\u8A0A\u76C8\u79D14\u98DE\u5229\u6D663\u98DF\u54C12\u9910\u53852\u9999\u683C\u91CC\u62C93\u6E2F2\uB2F7\uB1371\uCEF42\uC0BC\uC1312\uD55C\uAD6D2";
var assign2 = (target, properties) => {
  for (const key in properties) {
    target[key] = properties[key];
  }
  return target;
};
var numeric = "numeric";
var ascii = "ascii";
var alpha = "alpha";
var asciinumeric = "asciinumeric";
var alphanumeric = "alphanumeric";
var domain = "domain";
var emoji = "emoji";
var scheme = "scheme";
var slashscheme = "slashscheme";
var whitespace = "whitespace";
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}
function addToGroups(t, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (const k in flags) {
    const group = registerGroup(k, groups);
    if (group.indexOf(t) < 0) {
      group.push(t);
    }
  }
}
function flagsForToken(t, groups) {
  const result = {};
  for (const c in groups) {
    if (groups[c].indexOf(t) >= 0) {
      result[c] = true;
    }
  }
  return result;
}
function State(token) {
  if (token === void 0) {
    token = null;
  }
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.groups = {};
State.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(input) {
    const state = this;
    const nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (let i = 0; i < state.jr.length; i++) {
      const regex = state.jr[i][0];
      const nextState2 = state.jr[i][1];
      if (nextState2 && regex.test(input)) {
        return nextState2;
      }
    }
    return state.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(input, exactOnly) {
    if (exactOnly === void 0) {
      exactOnly = false;
    }
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(inputs, next, flags, groups) {
    for (let i = 0; i < inputs.length; i++) {
      this.tt(inputs[i], next, flags, groups);
    }
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(regexp, next, flags, groups) {
    groups = groups || State.groups;
    let nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp, nextState]);
    return nextState;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(input, next, flags, groups) {
    let state = this;
    const len = input.length;
    if (!len) {
      return state;
    }
    for (let i = 0; i < len - 1; i++) {
      state = state.tt(input[i]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(input, next, flags, groups) {
    groups = groups || State.groups;
    const state = this;
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    const t = next;
    let nextState, templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      assign2(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t) {
      if (groups) {
        if (nextState.t && typeof nextState.t === "string") {
          const allFlags = assign2(flagsForToken(nextState.t, groups), flags);
          addToGroups(t, allFlags, groups);
        } else if (flags) {
          addToGroups(t, flags, groups);
        }
      }
      nextState.t = t;
    }
    state.j[input] = nextState;
    return nextState;
  }
};
var ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);
var tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);
var ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);
var tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);
var WORD = "WORD";
var UWORD = "UWORD";
var LOCALHOST = "LOCALHOST";
var TLD = "TLD";
var UTLD = "UTLD";
var SCHEME = "SCHEME";
var SLASH_SCHEME = "SLASH_SCHEME";
var NUM = "NUM";
var WS = "WS";
var NL$1 = "NL";
var OPENBRACE = "OPENBRACE";
var CLOSEBRACE = "CLOSEBRACE";
var OPENBRACKET = "OPENBRACKET";
var CLOSEBRACKET = "CLOSEBRACKET";
var OPENPAREN = "OPENPAREN";
var CLOSEPAREN = "CLOSEPAREN";
var OPENANGLEBRACKET = "OPENANGLEBRACKET";
var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
var FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
var FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
var LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
var RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
var LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
var RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
var FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
var FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
var AMPERSAND = "AMPERSAND";
var APOSTROPHE = "APOSTROPHE";
var ASTERISK = "ASTERISK";
var AT = "AT";
var BACKSLASH = "BACKSLASH";
var BACKTICK = "BACKTICK";
var CARET = "CARET";
var COLON = "COLON";
var COMMA = "COMMA";
var DOLLAR = "DOLLAR";
var DOT = "DOT";
var EQUALS = "EQUALS";
var EXCLAMATION = "EXCLAMATION";
var HYPHEN = "HYPHEN";
var PERCENT = "PERCENT";
var PIPE = "PIPE";
var PLUS = "PLUS";
var POUND = "POUND";
var QUERY = "QUERY";
var QUOTE = "QUOTE";
var SEMI = "SEMI";
var SLASH = "SLASH";
var TILDE = "TILDE";
var UNDERSCORE = "UNDERSCORE";
var EMOJI$1 = "EMOJI";
var SYM = "SYM";
var tk = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD,
  UWORD,
  LOCALHOST,
  TLD,
  UTLD,
  SCHEME,
  SLASH_SCHEME,
  NUM,
  WS,
  NL: NL$1,
  OPENBRACE,
  CLOSEBRACE,
  OPENBRACKET,
  CLOSEBRACKET,
  OPENPAREN,
  CLOSEPAREN,
  OPENANGLEBRACKET,
  CLOSEANGLEBRACKET,
  FULLWIDTHLEFTPAREN,
  FULLWIDTHRIGHTPAREN,
  LEFTCORNERBRACKET,
  RIGHTCORNERBRACKET,
  LEFTWHITECORNERBRACKET,
  RIGHTWHITECORNERBRACKET,
  FULLWIDTHLESSTHAN,
  FULLWIDTHGREATERTHAN,
  AMPERSAND,
  APOSTROPHE,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EQUALS,
  EXCLAMATION,
  HYPHEN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  SEMI,
  SLASH,
  TILDE,
  UNDERSCORE,
  EMOJI: EMOJI$1,
  SYM
});
var ASCII_LETTER = /[a-z]/;
var LETTER = /\p{L}/u;
var EMOJI = /\p{Emoji}/u;
var DIGIT = /\d/;
var SPACE = /\s/;
var NL = "\n";
var EMOJI_VARIATION = "\uFE0F";
var EMOJI_JOINER = "\u200D";
var tlds = null;
var utlds = null;
function init$2(customSchemes) {
  if (customSchemes === void 0) {
    customSchemes = [];
  }
  const groups = {};
  State.groups = groups;
  const Start = new State();
  if (tlds == null) {
    tlds = decodeTlds(encodedTlds);
  }
  if (utlds == null) {
    utlds = decodeTlds(encodedUtlds);
  }
  tt(Start, "'", APOSTROPHE);
  tt(Start, "{", OPENBRACE);
  tt(Start, "}", CLOSEBRACE);
  tt(Start, "[", OPENBRACKET);
  tt(Start, "]", CLOSEBRACKET);
  tt(Start, "(", OPENPAREN);
  tt(Start, ")", CLOSEPAREN);
  tt(Start, "<", OPENANGLEBRACKET);
  tt(Start, ">", CLOSEANGLEBRACKET);
  tt(Start, "\uFF08", FULLWIDTHLEFTPAREN);
  tt(Start, "\uFF09", FULLWIDTHRIGHTPAREN);
  tt(Start, "\u300C", LEFTCORNERBRACKET);
  tt(Start, "\u300D", RIGHTCORNERBRACKET);
  tt(Start, "\u300E", LEFTWHITECORNERBRACKET);
  tt(Start, "\u300F", RIGHTWHITECORNERBRACKET);
  tt(Start, "\uFF1C", FULLWIDTHLESSTHAN);
  tt(Start, "\uFF1E", FULLWIDTHGREATERTHAN);
  tt(Start, "&", AMPERSAND);
  tt(Start, "*", ASTERISK);
  tt(Start, "@", AT);
  tt(Start, "`", BACKTICK);
  tt(Start, "^", CARET);
  tt(Start, ":", COLON);
  tt(Start, ",", COMMA);
  tt(Start, "$", DOLLAR);
  tt(Start, ".", DOT);
  tt(Start, "=", EQUALS);
  tt(Start, "!", EXCLAMATION);
  tt(Start, "-", HYPHEN);
  tt(Start, "%", PERCENT);
  tt(Start, "|", PIPE);
  tt(Start, "+", PLUS);
  tt(Start, "#", POUND);
  tt(Start, "?", QUERY);
  tt(Start, '"', QUOTE);
  tt(Start, "/", SLASH);
  tt(Start, ";", SEMI);
  tt(Start, "~", TILDE);
  tt(Start, "_", UNDERSCORE);
  tt(Start, "\\", BACKSLASH);
  const Num = tr(Start, DIGIT, NUM, {
    [numeric]: true
  });
  tr(Num, DIGIT, Num);
  const Word = tr(Start, ASCII_LETTER, WORD, {
    [ascii]: true
  });
  tr(Word, ASCII_LETTER, Word);
  const UWord = tr(Start, LETTER, UWORD, {
    [alpha]: true
  });
  tr(UWord, ASCII_LETTER);
  tr(UWord, LETTER, UWord);
  const Ws = tr(Start, SPACE, WS, {
    [whitespace]: true
  });
  tt(Start, NL, NL$1, {
    [whitespace]: true
  });
  tt(Ws, NL);
  tr(Ws, SPACE, Ws);
  const Emoji = tr(Start, EMOJI, EMOJI$1, {
    [emoji]: true
  });
  tr(Emoji, EMOJI, Emoji);
  tt(Emoji, EMOJI_VARIATION, Emoji);
  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
  tr(EmojiJoiner, EMOJI, Emoji);
  const wordjr = [[ASCII_LETTER, Word]];
  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];
  for (let i = 0; i < tlds.length; i++) {
    fastts(Start, tlds[i], TLD, WORD, wordjr);
  }
  for (let i = 0; i < utlds.length; i++) {
    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);
  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);
  for (let i = 0; i < customSchemes.length; i++) {
    const sch = customSchemes[i][0];
    const optionalSlashSlash = customSchemes[i][1];
    const flags = optionalSlashSlash ? {
      [scheme]: true
    } : {
      [slashscheme]: true
    };
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts(Start, sch, sch, flags);
  }
  ts(Start, "localhost", LOCALHOST, {
    ascii: true
  });
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: assign2({
      groups
    }, tk)
  };
}
function run$12(start2, str) {
  const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
  const charCount = iterable.length;
  const tokens = [];
  let cursor = 0;
  let charCursor = 0;
  while (charCursor < charCount) {
    let state = start2;
    let nextState = null;
    let tokenLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    let charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str) {
  const result = [];
  const len = str.length;
  let index = 0;
  while (index < len) {
    let first2 = str.charCodeAt(index);
    let second;
    let char = first2 < 55296 || first2 > 56319 || index + 1 === len || (second = str.charCodeAt(index + 1)) < 56320 || second > 57343 ? str[index] : str.slice(index, index + 2);
    result.push(char);
    index += char.length;
  }
  return result;
}
function fastts(state, input, t, defaultt, jr) {
  let next;
  const len = input.length;
  for (let i = 0; i < len - 1; i++) {
    const char = input[i];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function decodeTlds(encoded) {
  const words = [];
  const stack = [];
  let i = 0;
  let digits = "0123456789";
  while (i < encoded.length) {
    let popDigitCount = 0;
    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
      popDigitCount++;
    }
    if (popDigitCount > 0) {
      words.push(stack.join(""));
      for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {
        stack.pop();
      }
      i += popDigitCount;
    } else {
      stack.push(encoded[i]);
      i++;
    }
  }
  return words;
}
var defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop2,
  formatHref: noop2,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: Infinity,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Options(opts, defaultRender) {
  if (defaultRender === void 0) {
    defaultRender = null;
  }
  let o = assign2({}, defaults);
  if (opts) {
    o = assign2(o, opts instanceof Options ? opts.o : opts);
  }
  const ignoredTags = o.ignoreTags;
  const uppercaseIgnoredTags = [];
  for (let i = 0; i < ignoredTags.length; i++) {
    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
  }
  this.o = o;
  if (defaultRender) {
    this.defaultRender = defaultRender;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(ir) {
    return ir;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(token) {
    return this.get("validate", token.toString(), token);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(key, operator, token) {
    const isCallable = operator != null;
    let option = this.o[key];
    if (!option) {
      return option;
    }
    if (typeof option === "object") {
      option = token.t in option ? option[token.t] : defaults[key];
      if (typeof option === "function" && isCallable) {
        option = option(operator, token);
      }
    } else if (typeof option === "function" && isCallable) {
      option = option(operator, token.t, token);
    }
    return option;
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(key, operator, token) {
    let obj = this.o[key];
    if (typeof obj === "function" && operator != null) {
      obj = obj(operator, token.t, token);
    }
    return obj;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(token) {
    const ir = token.render(this);
    const renderFn = this.get("render", null, token) || this.defaultRender;
    return renderFn(ir, token.t, token);
  }
};
function noop2(val) {
  return val;
}
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
MultiToken.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
  */
  toHref(scheme2) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(options) {
    const val = this.toString();
    const truncate = options.get("truncate", val, this);
    const formatted = options.get("format", val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "\u2026" : formatted;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(options) {
    return options.get("formatHref", this.toHref(options.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(protocol) {
    if (protocol === void 0) {
      protocol = defaults.defaultProtocol;
    }
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(options) {
    return {
      type: this.t,
      value: this.toFormattedString(options),
      isLink: this.isLink,
      href: this.toFormattedHref(options),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(options) {
    return options.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(options) {
    const token = this;
    const href = this.toHref(options.get("defaultProtocol"));
    const formattedHref = options.get("formatHref", href, this);
    const tagName = options.get("tagName", href, token);
    const content = this.toFormattedString(options);
    const attributes = {};
    const className = options.get("className", href, token);
    const target = options.get("target", href, token);
    const rel = options.get("rel", href, token);
    const attrs = options.getObj("attributes", href, token);
    const eventListeners = options.getObj("events", href, token);
    attributes.href = formattedHref;
    if (className) {
      attributes.class = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs) {
      assign2(attributes, attrs);
    }
    return {
      tagName,
      attributes,
      content,
      eventListeners
    };
  }
};
function createTokenClass(type, props) {
  class Token extends MultiToken {
    constructor(value, tokens) {
      super(value, tokens);
      this.t = type;
    }
  }
  for (const p in props) {
    Token.prototype[p] = props[p];
  }
  Token.t = type;
  return Token;
}
var Email = createTokenClass("email", {
  isLink: true,
  toHref() {
    return "mailto:" + this.toString();
  }
});
var Text = createTokenClass("text");
var Nl = createTokenClass("nl");
var Url = createTokenClass("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(scheme2) {
    if (scheme2 === void 0) {
      scheme2 = defaults.defaultProtocol;
    }
    return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
var makeState = (arg) => new State(arg);
function init$1(_ref) {
  let {
    groups
  } = _ref;
  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  const Start = makeState();
  const Localpart = tt(Start, TILDE);
  ta(Localpart, localpartAccepting, Localpart);
  ta(Localpart, groups.domain, Localpart);
  const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta(Start, groups.domain, Domain);
  ta(Start, groups.scheme, Scheme);
  ta(Start, groups.slashscheme, SlashScheme);
  ta(Domain, localpartAccepting, Localpart);
  ta(Domain, groups.domain, Domain);
  const LocalpartAt = tt(Domain, AT);
  tt(Localpart, AT, LocalpartAt);
  tt(Scheme, AT, LocalpartAt);
  tt(SlashScheme, AT, LocalpartAt);
  const LocalpartDot = tt(Localpart, DOT);
  ta(LocalpartDot, localpartAccepting, Localpart);
  ta(LocalpartDot, groups.domain, Localpart);
  const EmailDomain = makeState();
  ta(LocalpartAt, groups.domain, EmailDomain);
  ta(EmailDomain, groups.domain, EmailDomain);
  const EmailDomainDot = tt(EmailDomain, DOT);
  ta(EmailDomainDot, groups.domain, EmailDomain);
  const Email$1 = makeState(Email);
  ta(EmailDomainDot, groups.tld, Email$1);
  ta(EmailDomainDot, groups.utld, Email$1);
  tt(LocalpartAt, LOCALHOST, Email$1);
  const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
  ta(EmailDomainHyphen, groups.domain, EmailDomain);
  ta(Email$1, groups.domain, EmailDomain);
  tt(Email$1, DOT, EmailDomainDot);
  tt(Email$1, HYPHEN, EmailDomainHyphen);
  const EmailColon = tt(Email$1, COLON);
  ta(EmailColon, groups.numeric, Email);
  const DomainHyphen = tt(Domain, HYPHEN);
  const DomainDot = tt(Domain, DOT);
  ta(DomainHyphen, groups.domain, Domain);
  ta(DomainDot, localpartAccepting, Localpart);
  ta(DomainDot, groups.domain, Domain);
  const DomainDotTld = makeState(Url);
  ta(DomainDot, groups.tld, DomainDotTld);
  ta(DomainDot, groups.utld, DomainDotTld);
  ta(DomainDotTld, groups.domain, Domain);
  ta(DomainDotTld, localpartAccepting, Localpart);
  tt(DomainDotTld, DOT, DomainDot);
  tt(DomainDotTld, HYPHEN, DomainHyphen);
  tt(DomainDotTld, AT, LocalpartAt);
  const DomainDotTldColon = tt(DomainDotTld, COLON);
  const DomainDotTldColonPort = makeState(Url);
  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  const Url$1 = makeState(Url);
  const UrlNonaccept = makeState();
  ta(Url$1, qsAccepting, Url$1);
  ta(Url$1, qsNonAccepting, UrlNonaccept);
  ta(UrlNonaccept, qsAccepting, Url$1);
  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt(DomainDotTld, SLASH, Url$1);
  tt(DomainDotTldColonPort, SLASH, Url$1);
  const SchemeColon = tt(Scheme, COLON);
  const SlashSchemeColon = tt(SlashScheme, COLON);
  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
  const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
  ta(Scheme, groups.domain, Domain);
  tt(Scheme, DOT, DomainDot);
  tt(Scheme, HYPHEN, DomainHyphen);
  ta(SlashScheme, groups.domain, Domain);
  tt(SlashScheme, DOT, DomainDot);
  tt(SlashScheme, HYPHEN, DomainHyphen);
  ta(SchemeColon, groups.domain, Url$1);
  tt(SchemeColon, SLASH, Url$1);
  ta(UriPrefix, groups.domain, Url$1);
  ta(UriPrefix, qsAccepting, Url$1);
  tt(UriPrefix, SLASH, Url$1);
  const bracketPairs = [
    [OPENBRACE, CLOSEBRACE],
    // {}
    [OPENBRACKET, CLOSEBRACKET],
    // []
    [OPENPAREN, CLOSEPAREN],
    // ()
    [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
    // <>
    [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
    // （）
    [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
    // 「」
    [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
    // 『』
    [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
    // ＜＞
  ];
  for (let i = 0; i < bracketPairs.length; i++) {
    const [OPEN, CLOSE] = bracketPairs[i];
    const UrlOpen = tt(Url$1, OPEN);
    tt(UrlNonaccept, OPEN, UrlOpen);
    tt(UrlOpen, CLOSE, Url$1);
    const UrlOpenQ = makeState(Url);
    ta(UrlOpen, qsAccepting, UrlOpenQ);
    const UrlOpenSyms = makeState();
    ta(UrlOpen, qsNonAccepting);
    ta(UrlOpenQ, qsAccepting, UrlOpenQ);
    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
    tt(UrlOpenQ, CLOSE, Url$1);
    tt(UrlOpenSyms, CLOSE, Url$1);
  }
  tt(Start, LOCALHOST, DomainDotTld);
  tt(Start, NL$1, Nl);
  return {
    start: Start,
    tokens: tk
  };
}
function run3(start2, input, tokens) {
  let len = tokens.length;
  let cursor = 0;
  let multis = [];
  let textTokens = [];
  while (cursor < len) {
    let state = start2;
    let secondState = null;
    let nextState = null;
    let multiLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      const Multi = latestAccepting.t;
      const subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  const startIdx = tokens[0].s;
  const endIdx = tokens[tokens.length - 1].e;
  const value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
var warn = typeof console !== "undefined" && console && console.warn || (() => {
});
var warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
var INIT = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};
function reset() {
  State.groups = {};
  INIT.scanner = null;
  INIT.parser = null;
  INIT.tokenQueue = [];
  INIT.pluginQueue = [];
  INIT.customSchemes = [];
  INIT.initialized = false;
}
function registerCustomProtocol(scheme2, optionalSlashSlash) {
  if (optionalSlashSlash === void 0) {
    optionalSlashSlash = false;
  }
  if (INIT.initialized) {
    warn(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
  }
  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  }
  INIT.customSchemes.push([scheme2, optionalSlashSlash]);
}
function init2() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (let i = 0; i < INIT.tokenQueue.length; i++) {
    INIT.tokenQueue[i][1]({
      scanner: INIT.scanner
    });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (let i = 0; i < INIT.pluginQueue.length; i++) {
    INIT.pluginQueue[i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init2();
  }
  return run3(INIT.parser.start, str, run$12(INIT.scanner.start, str));
}
function find(str, type, opts) {
  if (type === void 0) {
    type = null;
  }
  if (opts === void 0) {
    opts = null;
  }
  if (type && typeof type === "object") {
    if (opts) {
      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);
    }
    opts = type;
    type = null;
  }
  const options = new Options(opts);
  const tokens = tokenize(str);
  const filtered = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token.isLink && (!type || token.t === type) && options.check(token)) {
      filtered.push(token.toFormattedObject(options));
    }
  }
  return filtered;
}

// node_modules/@tiptap/extension-link/dist/index.js
function autolink(options) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr: tr2 } = newState;
      const transform = combineTransactionSteps(oldState.doc, [...transactions]);
      const changes = getChangedRanges(transform);
      changes.forEach(({ newRange }) => {
        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node) => node.isTextblock);
        let textBlock;
        let textBeforeWhitespace;
        if (nodesInChangedRanges.length > 1) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
        } else if (nodesInChangedRanges.length && newState.doc.textBetween(newRange.from, newRange.to, " ", " ").endsWith(" ")) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
        }
        if (textBlock && textBeforeWhitespace) {
          const wordsBeforeWhitespace = textBeforeWhitespace.split(" ").filter((s) => s !== "");
          if (wordsBeforeWhitespace.length <= 0) {
            return false;
          }
          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
          if (!lastWordBeforeSpace) {
            return false;
          }
          find(lastWordBeforeSpace).filter((link) => link.isLink).map((link) => ({
            ...link,
            from: lastWordAndBlockOffset + link.start + 1,
            to: lastWordAndBlockOffset + link.end + 1
          })).filter((link) => {
            if (!newState.schema.marks.code) {
              return true;
            }
            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
          }).filter((link) => {
            if (options.validate) {
              return options.validate(link.value);
            }
            return true;
          }).forEach((link) => {
            if (getMarksBetween(link.from, link.to, newState.doc).some((item) => item.mark.type === options.type)) {
              return;
            }
            tr2.addMark(link.from, link.to, options.type.create({
              href: link.href
            }));
          });
        }
      });
      if (!tr2.steps.length) {
        return;
      }
      return tr2;
    }
  });
}
function clickHandler(options) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a, _b;
        if (event.button !== 0) {
          return false;
        }
        let a = event.target;
        const els = [];
        while (a.nodeName !== "DIV") {
          els.push(a);
          a = a.parentNode;
        }
        if (!els.find((value) => value.nodeName === "A")) {
          return false;
        }
        const attrs = getAttributes(view.state, options.type.name);
        const link = event.target;
        const href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs.href;
        const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;
        if (link && href) {
          window.open(href, target);
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, event, slice2) => {
        const { state } = view;
        const { selection } = state;
        const { empty: empty3 } = selection;
        if (empty3) {
          return false;
        }
        let textContent = "";
        slice2.content.forEach((node) => {
          textContent += node.textContent;
        });
        const link = find(textContent).find((item) => item.isLink && item.value === textContent);
        if (!textContent || !link) {
          return false;
        }
        options.editor.commands.setMark(options.type, {
          href: link.href
        });
        return true;
      }
    }
  });
}
var Link = Mark2.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  onCreate() {
    this.options.protocols.forEach((protocol) => {
      if (typeof protocol === "string") {
        registerCustomProtocol(protocol);
        return;
      }
      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
    });
  },
  onDestroy() {
    reset();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      validate: void 0
    };
  },
  addAttributes() {
    return {
      href: {
        default: null
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [{ tag: 'a[href]:not([href *= "javascript:" i])' }];
  },
  renderHTML({ HTMLAttributes }) {
    var _a;
    if ((_a = HTMLAttributes.href) === null || _a === void 0 ? void 0 : _a.startsWith("javascript:")) {
      return ["a", mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }), 0];
    }
    return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain }) => {
        return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain }) => {
        return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain }) => {
        return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: (text2, event) => {
          var _a;
          const html = (_a = event === null || event === void 0 ? void 0 : event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
          const foundLinks = [];
          if (html) {
            const dom = new DOMParser().parseFromString(html, "text/html");
            const anchors = dom.querySelectorAll("a");
            if (anchors.length) {
              [...anchors].forEach((anchor) => foundLinks.push({
                text: anchor.innerText,
                data: {
                  href: anchor.getAttribute("href")
                },
                // get the index of the anchor inside the text
                // and add the length of the anchor text
                index: dom.body.innerText.indexOf(anchor.innerText) + anchor.innerText.length
              }));
            }
          }
          if (text2) {
            const links = find(text2).filter((item) => item.isLink);
            if (links.length) {
              links.forEach((link) => foundLinks.push({
                text: link.value,
                data: {
                  href: link.href
                },
                index: link.start
              }));
            }
          }
          return foundLinks;
        },
        type: this.type,
        getAttributes: (match) => {
          var _a;
          return {
            href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins = [];
    if (this.options.autolink) {
      plugins.push(autolink({
        type: this.type,
        validate: this.options.validate
      }));
    }
    if (this.options.openOnClick) {
      plugins.push(clickHandler({
        type: this.type
      }));
    }
    if (this.options.linkOnPaste) {
      plugins.push(pasteHandler({
        editor: this.editor,
        type: this.type
      }));
    }
    return plugins;
  }
});

// resources/js/extensions/LinkExtension.js
var LinkExtension_default = Link.extend({
  inclusive: false,
  addOptions() {
    return {
      openOnClick: false,
      linkOnPaste: true,
      autolink: false,
      protocols: [],
      HTMLAttributes: {},
      validate: void 0
    };
  },
  addAttributes() {
    return {
      href: {
        default: null
      },
      id: {
        default: null
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      hreflang: {
        default: null
      },
      rel: {
        default: null
      },
      referrerpolicy: {
        default: null
      },
      class: {
        default: null
      },
      as_button: {
        default: null,
        parseHTML: (element2) => element2.getAttribute("data-as-button") ?? null,
        renderHTML: (attributes) => {
          if (!attributes.as_button)
            return;
          return {
            "data-as-button": attributes.as_button
          };
        }
      },
      button_theme: {
        default: null,
        parseHTML: (element2) => element2.getAttribute("data-as-button-theme") ?? null,
        renderHTML: (attributes) => {
          if (!attributes.button_theme)
            return;
          return {
            "data-as-button-theme": attributes.button_theme
          };
        }
      }
    };
  }
});

// node_modules/@tiptap/extension-image/dist/index.js
var inputRegex = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
var Image = Node2.create({
  name: "image",
  addOptions() {
    return {
      inline: false,
      allowBase64: false,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["img", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setImage: (options) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: options
        });
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: inputRegex,
        type: this.type,
        getAttributes: (match) => {
          const [, , alt, src, title] = match;
          return { src, alt, title };
        }
      })
    ];
  }
});

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function writable(value, start2 = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn2) {
    set(fn2(value));
  }
  function subscribe2(run4, invalidate = noop) {
    const subscriber = [run4, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set, update2) || noop;
    }
    run4(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// node_modules/svelte-tiptap/dist/SvelteRenderer.js
var SvelteRenderer = class {
  constructor(component, { element: element2 }) {
    this.component = component;
    this.dom = element2;
    this.dom.classList.add("svelte-renderer");
  }
  updateProps(props) {
    this.component.$set(props);
  }
  destroy() {
    this.component.$destroy();
  }
};
var SvelteRenderer_default = SvelteRenderer;

// node_modules/svelte-tiptap/dist/context.js
var TIPTAP_NODE_VIEW = "TipTapNodeView";

// node_modules/svelte-tiptap/dist/SvelteNodeViewRenderer.js
var SvelteNodeView = class extends NodeView {
  mount() {
    const Component = this.component;
    const props = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      selected: false,
      extension: this.extension,
      getPos: () => this.getPos(),
      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),
      deleteNode: () => this.deleteNode()
    };
    this.contentDOMElement = this.node.isLeaf ? null : document.createElement(this.node.isInline ? "span" : "div");
    if (this.contentDOMElement) {
      this.contentDOMElement.style.whiteSpace = "inherit";
    }
    const context = /* @__PURE__ */ new Map();
    context.set(TIPTAP_NODE_VIEW, {
      onDragStart: this.onDragStart.bind(this)
    });
    const as = this.options.as ?? (this.node.isInline ? "span" : "div");
    const target = document.createElement(as);
    target.classList.add(`node-${this.node.type.name}`);
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);
    this.editor.on("selectionUpdate", this.handleSelectionUpdate);
    const svelteComponent = new Component({
      target,
      props,
      context
    });
    this.renderer = new SvelteRenderer_default(svelteComponent, {
      element: target
    });
    this.appendContendDom();
  }
  appendContendDom() {
    const contentElement = this.dom.querySelector("[data-node-view-content]");
    if (this.contentDOMElement && contentElement && !contentElement.contains(this.contentDOMElement)) {
      contentElement.appendChild(this.contentDOMElement);
    }
  }
  get dom() {
    if (!this.renderer.dom.firstElementChild?.hasAttribute("data-node-view-wrapper")) {
      throw Error("Please use the NodeViewWrapper component for your node view.");
    }
    return this.renderer.dom;
  }
  get contentDOM() {
    if (this.node.isLeaf) {
      return null;
    }
    return this.contentDOMElement;
  }
  handleSelectionUpdate() {
    const { from: from2, to } = this.editor.state.selection;
    if (from2 <= this.getPos() && to >= this.getPos() + this.node.nodeSize) {
      this.selectNode();
    } else {
      this.deselectNode();
    }
  }
  update(node, decorations) {
    const updateProps = () => {
      this.renderer.updateProps({ node, decorations });
    };
    if (typeof this.options.update === "function") {
      const oldNode = this.node;
      const oldDecorations = this.decorations;
      this.node = node;
      this.decorations = decorations;
      return this.options.update({
        oldNode,
        oldDecorations,
        newNode: node,
        newDecorations: decorations,
        updateProps: () => updateProps()
      });
    }
    if (node.type !== this.node.type) {
      return false;
    }
    if (node === this.node && this.decorations === decorations) {
      return true;
    }
    this.node = node;
    this.decorations = decorations;
    updateProps();
    return true;
  }
  selectNode() {
    this.renderer.updateProps({ selected: true });
  }
  deselectNode() {
    this.renderer.updateProps({ selected: false });
  }
  destroy() {
    this.renderer.destroy();
    this.editor.off("selectionUpdate", this.handleSelectionUpdate);
    this.contentDOMElement = null;
  }
};
var SvelteNodeViewRenderer = (component, options) => {
  return (props) => new SvelteNodeView(component, props, options);
};
var SvelteNodeViewRenderer_default = SvelteNodeViewRenderer;

// node_modules/svelte-tiptap/dist/NodeViewWrapper.svelte
function create_dynamic_element(ctx) {
  let svelte_element;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let svelte_element_levels = [
    { "data-node-view-wrapper": "" },
    { role: "none" },
    /*$$restProps*/
    ctx[3]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  return {
    c() {
      svelte_element = element(
        /*as*/
        ctx[0]
      );
      if (default_slot)
        default_slot.c();
      set_dynamic_element_data(
        /*as*/
        ctx[0]
      )(svelte_element, svelte_element_data);
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[6](svelte_element);
      current = true;
      if (!mounted) {
        dispose = listen(
          svelte_element,
          "dragstart",
          /*onDragStart*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*as*/
        ctx2[0]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        { "data-node-view-wrapper": "" },
        { role: "none" },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let previous_tag = (
    /*as*/
    ctx[0]
  );
  let svelte_element_anchor;
  let current;
  let svelte_element = (
    /*as*/
    ctx[0] && create_dynamic_element(ctx)
  );
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*as*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*as*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*as*/
        ctx2[0];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(svelte_element, local);
      current = true;
    },
    o(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["as"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const { onDragStart } = getContext(TIPTAP_NODE_VIEW);
  let element2;
  let { as = "div" } = $$props;
  onMount(async () => {
    await tick();
    $$invalidate(1, element2.style.whiteSpace = "normal", element2);
  });
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  return [as, element2, onDragStart, $$restProps, $$scope, slots, svelte_element_binding];
}
var NodeViewWrapper = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { as: 0 });
  }
};
var NodeViewWrapper_default = NodeViewWrapper;

// resources/js/utils.js
var uuid = () => {
  return ("10000000-1000-4000-8000" + -1e11).replace(
    /[018]/g,
    (c) => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  );
};
var pounce = (component, args) => {
  window.Livewire.dispatch("pounce", { component, arguments: args });
};
var commandRunner = (editor, commands2, args = null) => {
  commands2.forEach((command2) => {
    editor.chain().focus()[command2.command](command2?.arguments ?? args).run();
  });
};

// resources/js/stores.js
var getStatePath = writable(null);

// resources/js/components/BlockActions.svelte
function create_fragment2(ctx) {
  let div2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div2, "class", "scribble-block-actions");
      attr(div2, "contenteditable", "false");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var BlockActions = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
  }
};
var BlockActions_default = BlockActions;

// resources/js/components/DragHandle.svelte
function create_fragment3(ctx) {
  let div2;
  return {
    c() {
      div2 = element("div");
      div2.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="size-4"><path d="m22.67 12l-4.49 4.5l-2.51-2.5l1.98-2l-1.98-1.96l2.51-2.51zM12 1.33l4.47 4.49l-2.51 2.51L12 6.35l-2 1.98l-2.5-2.51zm0 21.34l-4.47-4.49l2.51-2.51L12 17.65l2-1.98l2.5 2.51zM1.33 12l4.49-4.5L8.33 10l-1.98 2l1.98 1.96l-2.51 2.51zM12 10a2 2 0 0 1 2 2a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2"></path></svg>`;
      attr(div2, "data-drag-handle", "");
      attr(div2, "class", "scribble-block-action block-drag");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
var DragHandle = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment3, safe_not_equal, {});
  }
};
var DragHandle_default = DragHandle;

// resources/js/components/BlockSettings.svelte
function create_fragment4(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="size-4"><path fill-rule="evenodd" d="M15 4.5A3.5 3.5 0 0 1 11.435 8c-.99-.019-2.093.132-2.7.913l-4.13 5.31a2.015 2.015 0 1 1-2.827-2.828l5.309-4.13c.78-.607.932-1.71.914-2.7L8 4.5a3.5 3.5 0 0 1 4.477-3.362c.325.094.39.497.15.736L10.6 3.902a.48.48 0 0 0-.033.653c.271.314.565.608.879.879a.48.48 0 0 0 .653-.033l2.027-2.027c.239-.24.642-.175.736.15.09.31.138.637.138.976ZM3.75 13a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0Z" clip-rule="evenodd"></path><path d="M11.5 9.5c.313 0 .62-.029.917-.084l1.962 1.962a2.121 2.121 0 0 1-3 3l-2.81-2.81 1.35-1.734c.05-.064.158-.158.426-.233.278-.078.639-.11 1.062-.102l.093.001ZM5 4l1.446 1.445a2.256 2.256 0 0 1-.047.21c-.075.268-.169.377-.233.427l-.61.474L4 5H2.655a.25.25 0 0 1-.224-.139l-1.35-2.7a.25.25 0 0 1 .047-.289l.745-.745a.25.25 0 0 1 .289-.047l2.7 1.35A.25.25 0 0 1 5 2.654V4Z"></path></svg>`;
      attr(button, "type", "button");
      attr(button, "class", "scribble-block-action block-settings");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(function() {
          if (is_function(
            /*handleOpen*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        })));
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { handleOpen } = $$props;
  $$self.$$set = ($$props2) => {
    if ("handleOpen" in $$props2)
      $$invalidate(0, handleOpen = $$props2.handleOpen);
  };
  return [handleOpen];
}
var BlockSettings = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment4, safe_not_equal, { handleOpen: 0 });
  }
};
var BlockSettings_default = BlockSettings;

// resources/js/components/RemoveBlock.svelte
function create_fragment5(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="size-4"><path fill-rule="evenodd" d="M5 3.25V4H2.75a.75.75 0 0 0 0 1.5h.3l.815 8.15A1.5 1.5 0 0 0 5.357 15h5.285a1.5 1.5 0 0 0 1.493-1.35l.815-8.15h.3a.75.75 0 0 0 0-1.5H11v-.75A2.25 2.25 0 0 0 8.75 1h-1.5A2.25 2.25 0 0 0 5 3.25Zm2.25-.75a.75.75 0 0 0-.75.75V4h3v-.75a.75.75 0 0 0-.75-.75h-1.5ZM6.05 6a.75.75 0 0 1 .787.713l.275 5.5a.75.75 0 0 1-1.498.075l-.275-5.5A.75.75 0 0 1 6.05 6Zm3.9 0a.75.75 0 0 1 .712.787l-.275 5.5a.75.75 0 0 1-1.498-.075l.275-5.5a.75.75 0 0 1 .786-.711Z" clip-rule="evenodd"></path></svg>`;
      attr(button, "type", "button");
      attr(button, "class", "scribble-block-action block-remove");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(function() {
          if (is_function(
            /*handleRemove*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        })));
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { handleRemove } = $$props;
  $$self.$$set = ($$props2) => {
    if ("handleRemove" in $$props2)
      $$invalidate(0, handleRemove = $$props2.handleRemove);
  };
  return [handleRemove];
}
var RemoveBlock = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment5, safe_not_equal, { handleRemove: 0 });
  }
};
var RemoveBlock_default = RemoveBlock;

// resources/js/components/MediaView.svelte
function create_default_slot_1(ctx) {
  let draghandle;
  let t0;
  let blocksettings;
  let t1;
  let removeblock;
  let current;
  draghandle = new DragHandle_default({});
  blocksettings = new BlockSettings_default({
    props: { handleOpen: (
      /*handleOpen*/
      ctx[2]
    ) }
  });
  removeblock = new RemoveBlock_default({
    props: { handleRemove: (
      /*handleRemove*/
      ctx[3]
    ) }
  });
  return {
    c() {
      create_component(draghandle.$$.fragment);
      t0 = space();
      create_component(blocksettings.$$.fragment);
      t1 = space();
      create_component(removeblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(draghandle, target, anchor);
      insert(target, t0, anchor);
      mount_component(blocksettings, target, anchor);
      insert(target, t1, anchor);
      mount_component(removeblock, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(draghandle.$$.fragment, local);
      transition_in(blocksettings.$$.fragment, local);
      transition_in(removeblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(draghandle.$$.fragment, local);
      transition_out(blocksettings.$$.fragment, local);
      transition_out(removeblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(draghandle, detaching);
      destroy_component(blocksettings, detaching);
      destroy_component(removeblock, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let div1;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let img_title_value;
  let img_width_value;
  let img_height_value;
  let img_loading_value;
  let div0_class_value;
  let t;
  let blockactions;
  let current;
  blockactions = new BlockActions_default({
    props: {
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      img = element("img");
      t = space();
      create_component(blockactions.$$.fragment);
      if (!src_url_equal(img.src, img_src_value = /*node*/
      ctx[0].attrs.src))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*node*/
      ctx[0].attrs.alt);
      attr(img, "title", img_title_value = /*node*/
      ctx[0].attrs?.title ?? null);
      attr(img, "width", img_width_value = /*node*/
      ctx[0].attrs.width);
      attr(img, "height", img_height_value = /*node*/
      ctx[0].attrs.height);
      attr(img, "loading", img_loading_value = /*node*/
      ctx[0].attrs.loading);
      attr(div0, "class", div0_class_value = "scribble-block-content " + /*selected*/
      (ctx[1] ? "ProseMirror-selectednode" : ""));
      attr(div1, "class", "scribble-block");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, img);
      append(div1, t);
      mount_component(blockactions, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*node*/
      1 && !src_url_equal(img.src, img_src_value = /*node*/
      ctx2[0].attrs.src)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*node*/
      1 && img_alt_value !== (img_alt_value = /*node*/
      ctx2[0].attrs.alt)) {
        attr(img, "alt", img_alt_value);
      }
      if (!current || dirty & /*node*/
      1 && img_title_value !== (img_title_value = /*node*/
      ctx2[0].attrs?.title ?? null)) {
        attr(img, "title", img_title_value);
      }
      if (!current || dirty & /*node*/
      1 && img_width_value !== (img_width_value = /*node*/
      ctx2[0].attrs.width)) {
        attr(img, "width", img_width_value);
      }
      if (!current || dirty & /*node*/
      1 && img_height_value !== (img_height_value = /*node*/
      ctx2[0].attrs.height)) {
        attr(img, "height", img_height_value);
      }
      if (!current || dirty & /*node*/
      1 && img_loading_value !== (img_loading_value = /*node*/
      ctx2[0].attrs.loading)) {
        attr(img, "loading", img_loading_value);
      }
      if (!current || dirty & /*selected*/
      2 && div0_class_value !== (div0_class_value = "scribble-block-content " + /*selected*/
      (ctx2[1] ? "ProseMirror-selectednode" : ""))) {
        attr(div0, "class", div0_class_value);
      }
      const blockactions_changes = {};
      if (dirty & /*$$scope*/
      128) {
        blockactions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      blockactions.$set(blockactions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(blockactions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(blockactions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(blockactions);
    }
  };
}
function create_fragment6(ctx) {
  let nodeviewwrapper;
  let current;
  nodeviewwrapper = new NodeViewWrapper_default({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(nodeviewwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nodeviewwrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const nodeviewwrapper_changes = {};
      if (dirty & /*$$scope, selected, node*/
      131) {
        nodeviewwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      nodeviewwrapper.$set(nodeviewwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nodeviewwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodeviewwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nodeviewwrapper, detaching);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let $getStatePath;
  component_subscribe($$self, getStatePath, ($$value) => $$invalidate(6, $getStatePath = $$value));
  let { editor } = $$props;
  let { node } = $$props;
  let { selected = false } = $$props;
  let { updateAttributes: updateAttributes2 } = $$props;
  const handleOpen = () => {
    pounce("scribble-media", {
      update: true,
      statePath: $getStatePath,
      ...node.attrs
    });
  };
  const handleRemove = () => {
    editor.commands.deleteSelection();
  };
  onMount(() => {
    window.addEventListener("updatedBlock", (e) => {
      if (e.detail.type === node.attrs.type && e.detail.statePath === $getStatePath) {
        updateAttributes2({ values: e.detail.values });
      }
    });
  });
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(4, editor = $$props2.editor);
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("selected" in $$props2)
      $$invalidate(1, selected = $$props2.selected);
    if ("updateAttributes" in $$props2)
      $$invalidate(5, updateAttributes2 = $$props2.updateAttributes);
  };
  return [node, selected, handleOpen, handleRemove, editor, updateAttributes2];
}
var MediaView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment6, safe_not_equal, {
      editor: 4,
      node: 0,
      selected: 1,
      updateAttributes: 5
    });
  }
};
var MediaView_default = MediaView;

// resources/js/extensions/MediaExtension.js
var MediaExtension_default = Image.extend({
  selectable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      },
      width: {
        default: null
      },
      height: {
        default: null
      },
      loading: {
        default: null
      },
      sizes: {
        default: null
      },
      srcset: {
        default: null
      }
    };
  },
  addNodeView() {
    return SvelteNodeViewRenderer_default(MediaView_default);
  }
});

// node_modules/@tiptap/extension-placeholder/dist/index.js
var Placeholder = Extension.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something \u2026",
      showOnlyWhenEditable: true,
      considerAnyAsEmpty: false,
      showOnlyCurrent: true,
      includeChildren: false
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("placeholder"),
        props: {
          decorations: ({ doc: doc3, selection }) => {
            var _a;
            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
            const { anchor } = selection;
            const decorations = [];
            if (!active) {
              return null;
            }
            const { firstChild } = doc3.content;
            const isLeaf = firstChild && firstChild.type.isLeaf;
            const isAtom = firstChild && firstChild.isAtom;
            const isValidNode = this.options.considerAnyAsEmpty ? true : firstChild && firstChild.type.name === ((_a = doc3.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.name);
            const isEmptyDoc = doc3.content.childCount <= 1 && firstChild && isValidNode && (firstChild.nodeSize <= 2 && (!isLeaf || !isAtom));
            doc3.descendants((node, pos) => {
              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;
              const isEmpty = !node.isLeaf && !node.childCount;
              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {
                const classes = [this.options.emptyNodeClass];
                if (isEmptyDoc) {
                  classes.push(this.options.emptyEditorClass);
                }
                const decoration = Decoration.node(pos, pos + node.nodeSize, {
                  class: classes.join(" "),
                  "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                    editor: this.editor,
                    node,
                    pos,
                    hasAnchor
                  }) : this.options.placeholder
                });
                decorations.push(decoration);
              }
              return this.options.includeChildren;
            });
            return DecorationSet.create(doc3, decorations);
          }
        }
      })
    ];
  }
});

// node_modules/@tiptap/extension-blockquote/dist/index.js
var inputRegex2 = /^\s*>\s$/;
var Blockquote = Node2.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: commands2 }) => {
        return commands2.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands: commands2 }) => {
        return commands2.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands: commands2 }) => {
        return commands2.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex2,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-bold/dist/index.js
var starInputRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/;
var starPasteRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g;
var underscoreInputRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/;
var underscorePasteRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;
var Bold = Mark2.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node) => node.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleBold: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetBold: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-bullet-list/dist/index.js
var ListItem = Node2.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
var TextStyle = Mark2.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (element2) => {
          const hasStyles = element2.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
        const attributes = getMarkAttributes(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) {
          return true;
        }
        return commands2.unsetMark(this.name);
      }
    };
  }
});
var inputRegex3 = /^\s*([-+*])\s$/;
var BulletList = Node2.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: commands2, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem.name, this.editor.getAttributes(TextStyle.name)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex3,
      type: this.type
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex3,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: () => {
          return this.editor.getAttributes(TextStyle.name);
        },
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});

// node_modules/@tiptap/extension-code/dist/index.js
var inputRegex4 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/;
var pasteRegex = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g;
var Code = Mark2.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  exitable: true,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleCode: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetCode: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex4,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-code-block/dist/index.js
var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
var CodeBlock = Node2.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: null,
        parseHTML: (element2) => {
          var _a;
          const { languageClassPrefix } = this.options;
          const classNames = [...((_a = element2.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []];
          const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
          const language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "pre",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      [
        "code",
        {
          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.setNode(this.name, attributes);
      },
      toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: empty3, $anchor } = this.editor.state.selection;
        const isAtStart = $anchor.pos === 1;
        if (!empty3 || $anchor.parent.type.name !== this.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return this.editor.commands.clearNodes();
        }
        return false;
      },
      // exit node on triple enter
      Enter: ({ editor }) => {
        if (!this.options.exitOnTripleEnter) {
          return false;
        }
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty3 } = selection;
        if (!empty3 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(({ tr: tr2 }) => {
          tr2.delete($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor }) => {
        if (!this.options.exitOnArrowDown) {
          return false;
        }
        const { state } = editor;
        const { selection, doc: doc3 } = state;
        const { $from, empty: empty3 } = selection;
        if (!empty3 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        const after = $from.after();
        if (after === void 0) {
          return false;
        }
        const nodeAfter = doc3.nodeAt(after);
        if (nodeAfter) {
          return false;
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      textblockTypeInputRule({
        find: backtickInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      }),
      textblockTypeInputRule({
        find: tildeInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Plugin({
        key: new PluginKey("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (view, event) => {
            if (!event.clipboardData) {
              return false;
            }
            if (this.editor.isActive(this.type.name)) {
              return false;
            }
            const text2 = event.clipboardData.getData("text/plain");
            const vscode = event.clipboardData.getData("vscode-editor-data");
            const vscodeData = vscode ? JSON.parse(vscode) : void 0;
            const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
            if (!text2 || !language) {
              return false;
            }
            const { tr: tr2 } = view.state;
            tr2.replaceSelectionWith(this.type.create({ language }));
            tr2.setSelection(TextSelection.near(tr2.doc.resolve(Math.max(0, tr2.selection.from - 2))));
            tr2.insertText(text2.replace(/\r\n?/g, "\n"));
            tr2.setMeta("paste", true);
            view.dispatch(tr2);
            return true;
          }
        }
      })
    ];
  }
});

// node_modules/@tiptap/extension-document/dist/index.js
var Document = Node2.create({
  name: "doc",
  topNode: true,
  content: "block+"
});

// node_modules/prosemirror-dropcursor/dist/index.js
function dropCursor(options = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}
var DropCursorView = class {
  constructor(editorView, options) {
    var _a;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
    this.color = options.color === false ? void 0 : options.color || "black";
    this.class = options.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    if (isBlock) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top2 = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top2 = (top2 + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top2 - this.width / 2, bottom: top2 + this.width / 2 };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      parentLeft = rect2.left - parent.scrollLeft;
      parentTop = rect2.top - parent.scrollTop;
    }
    this.element.style.left = rect.left - parentLeft + "px";
    this.element.style.top = rect.top - parentTop + "px";
    this.element.style.width = rect.right - rect.left + "px";
    this.element.style.height = rect.bottom - rect.top + "px";
  }
  scheduleRemoval(timeout) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
};

// node_modules/@tiptap/extension-dropcursor/dist/index.js
var Dropcursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      dropCursor(this.options)
    ];
  }
});

// node_modules/prosemirror-gapcursor/dist/index.js
var GapCursor = class _GapCursor extends Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc3, mapping) {
    let $pos = doc3.resolve(mapping.map(this.head));
    return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof _GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new _GapCursor(doc3.resolve(json.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search:
      for (; ; ) {
        if (!mustMove && _GapCursor.valid($pos))
          return $pos;
        let pos = $pos.pos, next = null;
        for (let d = $pos.depth; ; d--) {
          let parent = $pos.node(d);
          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
            break;
          } else if (d == 0) {
            return null;
          }
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        for (; ; ) {
          let inside = dir > 0 ? next.firstChild : next.lastChild;
          if (!inside) {
            if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
              mustMove = false;
              continue search;
            }
            break;
          }
          next = inside;
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        return null;
      }
  }
};
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
var GapBookmark = class _GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new _GapBookmark(mapping.map(this.pos));
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
};
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.index(d), parent = $pos.node(d);
    if (index == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.indexAfter(d), parent = $pos.node(d);
    if (index == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
var handleKeyDown = keydownHandler({
  "ArrowLeft": arrow2("horiz", -1),
  "ArrowRight": arrow2("horiz", 1),
  "ArrowUp": arrow2("vert", -1),
  "ArrowDown": arrow2("vert", 1)
});
function arrow2(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert2 = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert2)
    return false;
  let frag = Fragment.empty;
  for (let i = insert2.length - 1; i >= 0; i--)
    frag = Fragment.from(insert2[i].createAndFill(null, frag));
  let tr2 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr2.setSelection(TextSelection.near(tr2.doc.resolve($from.pos + 1)));
  view.dispatch(tr2);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}

// node_modules/@tiptap/extension-gapcursor/dist/index.js
var Gapcursor = Extension.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      gapCursor()
    ];
  },
  extendNodeSchema(extension) {
    var _a;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      allowGapCursor: (_a = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a !== void 0 ? _a : null
    };
  }
});

// node_modules/@tiptap/extension-hard-break/dist/index.js
var HardBreak = Node2.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return "\n";
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: commands2, chain, state, editor }) => {
        return commands2.first([
          () => commands2.exitCode(),
          () => commands2.command(() => {
            const { selection, storedMarks } = state;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain().insertContent({ type: this.name }).command(({ tr: tr2, dispatch }) => {
              if (dispatch && marks && keepMarks) {
                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                tr2.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});

// node_modules/@tiptap/extension-heading/dist/index.js
var Heading = Node2.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((items, level) => ({
      ...items,
      ...{
        [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
      }
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{1,${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});

// node_modules/rope-sequence/dist/index.js
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append2(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3)
    Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    for (var i = from2; i < to; i++) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    for (var i = from2 - 1; i >= to; i--) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(RopeSequence3) {
  function Append2(left2, right2) {
    RopeSequence3.call(this);
    this.left = left2;
    this.right = right2;
    this.length = left2.length + right2.length;
    this.depth = Math.max(left2.depth, right2.depth) + 1;
  }
  if (RopeSequence3)
    Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start2) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start2 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start2 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start2) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var dist_default2 = RopeSequence;

// node_modules/prosemirror-history/dist/index.js
var max_empty_items = 500;
var Branch = class _Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end2 = this.items.length;
    for (; ; end2--) {
      let next = this.items.get(end2 - 1);
      if (next.selection) {
        --end2;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end2, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end2, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map2;
        if (step && transform.maybeStep(step).doc) {
          map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new _Branch(this.items.slice(0, end2).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform.steps.length; i++) {
      let step = transform.steps[i].invert(transform.docs[i]);
      let item = new Item(transform.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new _Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new _Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start2 = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start2);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map2 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map2, step, selection));
      } else {
        rebasedItems.push(new Item(map2));
      }
    }, start2);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item(mapping.maps[i]));
    let items = this.items.slice(0, start2).append(newMaps).append(rebasedItems);
    let branch = new _Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count++;
    });
    return count;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;
          if (merged = items.length && items[last].merge(newItem))
            items[last] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new _Branch(dist_default2.from(items.reverse()), events);
  }
};
Branch.empty = new Branch(dist_default2.empty, 0);
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i) => {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item = class _Item {
  constructor(map2, step, selection, mirrorOffset) {
    this.map = map2;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new _Item(step.getMap().invert(), step, this.selection);
    }
  }
};
var HistoryState = class {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
};
var DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr2, options) {
  let historyTr = tr2.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr2.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr2.getMeta("appendedTransaction");
  if (tr2.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr2, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr2.mapping.maps[tr2.steps.length - 1]), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr2, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr2.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr2.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr2.time || 0) - options.newGroupDelay || !isAdjacentTo(tr2, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr2.mapping) : rangesFor(tr2.mapping.maps[tr2.steps.length - 1]);
    return new HistoryState(history2.done.addTransform(tr2, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr2.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr2.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr2, rebased), history2.undone.rebased(tr2, rebased), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr2.mapping.maps), history2.undone.addMaps(tr2.mapping.maps), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start2, end2) => {
    for (let i = 0; i < prevRanges.length; i += 2)
      if (start2 <= prevRanges[i + 1] && end2 >= prevRanges[i])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(map2) {
  let result = [];
  map2.forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i = 0; i < ranges.length; i += 2) {
    let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state, dispatch, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
}
var cachedPreserveItems = false;
var cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i = 0; i < plugins.length; i++)
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr2, hist, state) {
        return applyTransaction(hist, state, tr2, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
var undo = (state, dispatch) => {
  let hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0)
    return false;
  if (dispatch)
    histTransaction(hist, state, dispatch, false);
  return true;
};
var redo = (state, dispatch) => {
  let hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0)
    return false;
  if (dispatch)
    histTransaction(hist, state, dispatch, true);
  return true;
};

// node_modules/@tiptap/extension-history/dist/index.js
var History = Extension.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch }) => {
        return undo(state, dispatch);
      },
      redo: () => ({ state, dispatch }) => {
        return redo(state, dispatch);
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      history(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-\u044F": () => this.editor.commands.undo(),
      "Shift-Mod-\u044F": () => this.editor.commands.redo()
    };
  }
});

// node_modules/@tiptap/extension-horizontal-rule/dist/index.js
var HorizontalRule = Node2.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain, state }) => {
        const { $to: $originTo } = state.selection;
        const currentChain = chain();
        if ($originTo.parentOffset === 0) {
          currentChain.insertContentAt(Math.max($originTo.pos - 2, 0), { type: this.name });
        } else {
          currentChain.insertContent({ type: this.name });
        }
        return currentChain.command(({ tr: tr2, dispatch }) => {
          var _a;
          if (dispatch) {
            const { $to } = tr2.selection;
            const posAfter = $to.end();
            if ($to.nodeAfter) {
              if ($to.nodeAfter.isTextblock) {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos + 1));
              } else if ($to.nodeAfter.isBlock) {
                tr2.setSelection(NodeSelection.create(tr2.doc, $to.pos));
              } else {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos));
              }
            } else {
              const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
              if (node) {
                tr2.insert(posAfter, node);
                tr2.setSelection(TextSelection.create(tr2.doc, posAfter + 1));
              }
            }
            tr2.scrollIntoView();
          }
          return true;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-italic/dist/index.js
var starInputRegex2 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/;
var starPasteRegex2 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g;
var underscoreInputRegex2 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/;
var underscorePasteRegex2 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;
var Italic = Mark2.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node) => node.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleItalic: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex2,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex2,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex2,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-list-item/dist/index.js
var ListItem2 = Node2.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});

// node_modules/@tiptap/extension-ordered-list/dist/index.js
var ListItem3 = Node2.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
var TextStyle2 = Mark2.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (element2) => {
          const hasStyles = element2.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
        const attributes = getMarkAttributes(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) {
          return true;
        }
        return commands2.unsetMark(this.name);
      }
    };
  }
});
var inputRegex5 = /^(\d+)\.\s$/;
var OrderedList = Node2.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element2) => {
          return element2.hasAttribute("start") ? parseInt(element2.getAttribute("start") || "", 10) : 1;
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const { start: start2, ...attributesWithoutStart } = HTMLAttributes;
    return start2 === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: commands2, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem3.name, this.editor.getAttributes(TextStyle2.name)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex5,
      type: this.type,
      getAttributes: (match) => ({ start: +match[1] }),
      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex5,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyle2.name) }),
        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});

// node_modules/@tiptap/extension-paragraph/dist/index.js
var Paragraph = Node2.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: commands2 }) => {
        return commands2.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});

// node_modules/@tiptap/extension-strike/dist/index.js
var inputRegex6 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/;
var pasteRegex2 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;
var Strike = Mark2.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleStrike: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    const shortcuts = {};
    if (isMacOS()) {
      shortcuts["Mod-Shift-s"] = () => this.editor.commands.toggleStrike();
    } else {
      shortcuts["Ctrl-Shift-s"] = () => this.editor.commands.toggleStrike();
    }
    return shortcuts;
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex2,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-text/dist/index.js
var Text2 = Node2.create({
  name: "text",
  group: "inline"
});

// node_modules/@tiptap/starter-kit/dist/index.js
var StarterKit = Extension.create({
  name: "starterKit",
  addExtensions() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const extensions2 = [];
    if (this.options.blockquote !== false) {
      extensions2.push(Blockquote.configure((_a = this.options) === null || _a === void 0 ? void 0 : _a.blockquote));
    }
    if (this.options.bold !== false) {
      extensions2.push(Bold.configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.bold));
    }
    if (this.options.bulletList !== false) {
      extensions2.push(BulletList.configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));
    }
    if (this.options.code !== false) {
      extensions2.push(Code.configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));
    }
    if (this.options.codeBlock !== false) {
      extensions2.push(CodeBlock.configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));
    }
    if (this.options.document !== false) {
      extensions2.push(Document.configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));
    }
    if (this.options.dropcursor !== false) {
      extensions2.push(Dropcursor.configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));
    }
    if (this.options.gapcursor !== false) {
      extensions2.push(Gapcursor.configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));
    }
    if (this.options.hardBreak !== false) {
      extensions2.push(HardBreak.configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));
    }
    if (this.options.heading !== false) {
      extensions2.push(Heading.configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));
    }
    if (this.options.history !== false) {
      extensions2.push(History.configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));
    }
    if (this.options.horizontalRule !== false) {
      extensions2.push(HorizontalRule.configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));
    }
    if (this.options.italic !== false) {
      extensions2.push(Italic.configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));
    }
    if (this.options.listItem !== false) {
      extensions2.push(ListItem2.configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));
    }
    if (this.options.orderedList !== false) {
      extensions2.push(OrderedList.configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));
    }
    if (this.options.paragraph !== false) {
      extensions2.push(Paragraph.configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));
    }
    if (this.options.strike !== false) {
      extensions2.push(Strike.configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));
    }
    if (this.options.text !== false) {
      extensions2.push(Text2.configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));
    }
    return extensions2;
  }
});

// resources/js/components/ScribbleBlock.svelte
function create_if_block(ctx) {
  let blocksettings;
  let current;
  blocksettings = new BlockSettings_default({
    props: { handleOpen: (
      /*handleOpen*/
      ctx[4]
    ) }
  });
  return {
    c() {
      create_component(blocksettings.$$.fragment);
    },
    m(target, anchor) {
      mount_component(blocksettings, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(blocksettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(blocksettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(blocksettings, detaching);
    }
  };
}
function create_default_slot_12(ctx) {
  let draghandle;
  let t0;
  let t1;
  let removeblock;
  let current;
  draghandle = new DragHandle_default({});
  let if_block = (
    /*node*/
    ctx[0].attrs.type !== "static" && create_if_block(ctx)
  );
  removeblock = new RemoveBlock_default({
    props: { handleRemove: (
      /*handleRemove*/
      ctx[5]
    ) }
  });
  return {
    c() {
      create_component(draghandle.$$.fragment);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      create_component(removeblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(draghandle, target, anchor);
      insert(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(removeblock, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*node*/
        ctx2[0].attrs.type !== "static"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*node*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(draghandle.$$.fragment, local);
      transition_in(if_block);
      transition_in(removeblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(draghandle.$$.fragment, local);
      transition_out(if_block);
      transition_out(removeblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(draghandle, detaching);
      if (if_block)
        if_block.d(detaching);
      destroy_component(removeblock, detaching);
    }
  };
}
function create_default_slot2(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let t;
  let blockactions;
  let current;
  blockactions = new BlockActions_default({
    props: {
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      create_component(blockactions.$$.fragment);
      attr(div0, "class", div0_class_value = "scribble-block-content " + /*selected*/
      (ctx[1] ? "ProseMirror-selectednode" : ""));
      attr(div1, "class", "scribble-block");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      div0.innerHTML = /*view*/
      ctx[3];
      ctx[8](div0);
      append(div1, t);
      mount_component(blockactions, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*view*/
      8)
        div0.innerHTML = /*view*/
        ctx2[3];
      ;
      if (!current || dirty & /*selected*/
      2 && div0_class_value !== (div0_class_value = "scribble-block-content " + /*selected*/
      (ctx2[1] ? "ProseMirror-selectednode" : ""))) {
        attr(div0, "class", div0_class_value);
      }
      const blockactions_changes = {};
      if (dirty & /*$$scope, node*/
      2049) {
        blockactions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      blockactions.$set(blockactions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(blockactions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(blockactions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      ctx[8](null);
      destroy_component(blockactions);
    }
  };
}
function create_fragment7(ctx) {
  let nodeviewwrapper;
  let current;
  nodeviewwrapper = new NodeViewWrapper_default({
    props: {
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(nodeviewwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nodeviewwrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const nodeviewwrapper_changes = {};
      if (dirty & /*$$scope, node, selected, wrapper, view*/
      2063) {
        nodeviewwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      nodeviewwrapper.$set(nodeviewwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nodeviewwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodeviewwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nodeviewwrapper, detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let wrapper;
  let getView;
  let $getStatePath;
  component_subscribe($$self, getStatePath, ($$value) => $$invalidate(10, $getStatePath = $$value));
  let { editor } = $$props;
  let { node } = $$props;
  let { selected = false } = $$props;
  let { updateAttributes: updateAttributes2 } = $$props;
  let view = null;
  const handleOpen = () => {
    pounce(node.attrs.identifier, {
      update: true,
      statePath: $getStatePath,
      blockId: node.attrs.id,
      ...node.attrs.values
    });
  };
  const handleRemove = () => {
    editor.commands.deleteSelection();
  };
  onMount(() => {
    getView();
    window.addEventListener("updatedBlock", (e) => {
      if (e.detail.identifier === node.attrs.identifier && e.detail.statePath === $getStatePath && e.detail.blockId === node.attrs.id) {
        updateAttributes2({ values: e.detail.values });
        getView();
        setTimeout(
          () => {
            let currentNode = editor.$node("scribbleBlock", { id: node.attrs.id });
            editor.commands.setNodeSelection(currentNode.pos);
          },
          100
        );
      }
    });
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapper = $$value;
      $$invalidate(2, wrapper);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(6, editor = $$props2.editor);
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("selected" in $$props2)
      $$invalidate(1, selected = $$props2.selected);
    if ("updateAttributes" in $$props2)
      $$invalidate(7, updateAttributes2 = $$props2.updateAttributes);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*node, wrapper, updateAttributes*/
    133) {
      $:
        getView = () => {
          const component = document.querySelector("#scribble-renderer").getAttribute("wire:id");
          window.Livewire.find(component).call("getView", node.attrs.identifier, node.attrs.values).then((e) => {
            $$invalidate(3, view = e);
          }).then(() => {
            wrapper.addEventListener("change", (e) => {
              let name = e.target.getAttribute("id").replace("data.", "");
              let value = e.target.value;
              updateAttributes2({
                values: { ...node.attrs.values, [name]: value }
              });
            });
          });
        };
    }
  };
  $:
    $$invalidate(2, wrapper = null);
  return [
    node,
    selected,
    wrapper,
    view,
    handleOpen,
    handleRemove,
    editor,
    updateAttributes2,
    div0_binding
  ];
}
var ScribbleBlock = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment7, safe_not_equal, {
      editor: 6,
      node: 0,
      selected: 1,
      updateAttributes: 7
    });
  }
};
var ScribbleBlock_default = ScribbleBlock;

// resources/js/extensions/ScribbleBlock.js
var ScribbleBlock_default2 = Node2.create({
  name: "scribbleBlock",
  isBlock: true,
  inline: false,
  group: "block",
  draggable: true,
  defining: true,
  selectable: true,
  addAttributes() {
    return {
      id: {
        default: null
      },
      type: {
        default: "block"
      },
      identifier: {
        default: null
      },
      values: {
        default: {}
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "scribble-block",
        getAttrs: (dom) => {
          return JSON.parse(dom.innerHTML);
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["scribble-block", JSON.stringify(HTMLAttributes)];
  },
  addCommands() {
    return {
      setScribbleBlock: (options) => ({ tr: tr2, state }) => {
        pounce(options.identifier, { statePath: options.statePath });
        return true;
      },
      insertScribbleBlock: (options) => {
        return ({ tr: tr2, dispatch, state }) => {
          const { selection } = tr2;
          const node = this.type.create({
            ...{ id: uuid() },
            ...options
          });
          if (dispatch) {
            tr2.replaceRangeWith(selection.from - selection.$anchor.parentOffset, selection.to, node);
          }
          return true;
        };
      }
    };
  },
  addNodeView() {
    return SvelteNodeViewRenderer_default(ScribbleBlock_default);
  }
});

// node_modules/@tiptap/suggestion/dist/index.js
function findSuggestionMatch(config) {
  var _a;
  const { char, allowSpaces, allowedPrefixes, startOfLine, $position } = config;
  const escapedChar = escapeForRegEx(char);
  const suffix = new RegExp(`\\s${escapedChar}$`);
  const prefix = startOfLine ? "^" : "";
  const regexp = allowSpaces ? new RegExp(`${prefix}${escapedChar}.*?(?=\\s${escapedChar}|$)`, "gm") : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\s${escapedChar}]*`, "gm");
  const text2 = ((_a = $position.nodeBefore) === null || _a === void 0 ? void 0 : _a.isText) && $position.nodeBefore.text;
  if (!text2) {
    return null;
  }
  const textFrom = $position.pos - text2.length;
  const match = Array.from(text2.matchAll(regexp)).pop();
  if (!match || match.input === void 0 || match.index === void 0) {
    return null;
  }
  const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);
  const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join("")}\0]?$`).test(matchPrefix);
  if (allowedPrefixes !== null && !matchPrefixIsAllowed) {
    return null;
  }
  const from2 = textFrom + match.index;
  let to = from2 + match[0].length;
  if (allowSpaces && suffix.test(text2.slice(to - 1, to + 1))) {
    match[0] += " ";
    to += 1;
  }
  if (from2 < $position.pos && to >= $position.pos) {
    return {
      range: {
        from: from2,
        to
      },
      query: match[0].slice(char.length),
      text: match[0]
    };
  }
  return null;
}
var SuggestionPluginKey = new PluginKey("suggestion");
function Suggestion({ pluginKey = SuggestionPluginKey, editor, char = "@", allowSpaces = false, allowedPrefixes = [" "], startOfLine = false, decorationTag = "span", decorationClass = "suggestion", command: command2 = () => null, items = () => [], render: render2 = () => ({}), allow = () => true, findSuggestionMatch: findSuggestionMatch$1 = findSuggestionMatch }) {
  let props;
  const renderer = render2 === null || render2 === void 0 ? void 0 : render2();
  const plugin = new Plugin({
    key: pluginKey,
    view() {
      return {
        update: async (view, prevState) => {
          var _a, _b, _c, _d, _e, _f, _g;
          const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);
          const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);
          const moved = prev.active && next.active && prev.range.from !== next.range.from;
          const started = !prev.active && next.active;
          const stopped = prev.active && !next.active;
          const changed = !started && !stopped && prev.query !== next.query;
          const handleStart = started || moved;
          const handleChange = changed && !moved;
          const handleExit = stopped || moved;
          if (!handleStart && !handleChange && !handleExit) {
            return;
          }
          const state = handleExit && !handleStart ? prev : next;
          const decorationNode = view.dom.querySelector(`[data-decoration-id="${state.decorationId}"]`);
          props = {
            editor,
            range: state.range,
            query: state.query,
            text: state.text,
            items: [],
            command: (commandProps) => {
              command2({
                editor,
                range: state.range,
                props: commandProps
              });
            },
            decorationNode,
            // virtual node for popper.js or tippy.js
            // this can be used for building popups without a DOM node
            clientRect: decorationNode ? () => {
              var _a2;
              const { decorationId } = (_a2 = this.key) === null || _a2 === void 0 ? void 0 : _a2.getState(editor.state);
              const currentDecorationNode = view.dom.querySelector(`[data-decoration-id="${decorationId}"]`);
              return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;
            } : null
          };
          if (handleStart) {
            (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);
          }
          if (handleChange) {
            (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);
          }
          if (handleChange || handleStart) {
            props.items = await items({
              editor,
              query: state.query
            });
          }
          if (handleExit) {
            (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e === void 0 ? void 0 : _e.call(renderer, props);
          }
          if (handleChange) {
            (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);
          }
          if (handleStart) {
            (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);
          }
        },
        destroy: () => {
          var _a;
          if (!props) {
            return;
          }
          (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        const state = {
          active: false,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: false
        };
        return state;
      },
      // Apply changes to the plugin state from a view transaction.
      apply(transaction, prev, oldState, state) {
        const { isEditable } = editor;
        const { composing } = editor.view;
        const { selection } = transaction;
        const { empty: empty3, from: from2 } = selection;
        const next = { ...prev };
        next.composing = composing;
        if (isEditable && (empty3 || editor.view.composing)) {
          if ((from2 < prev.range.from || from2 > prev.range.to) && !composing && !prev.composing) {
            next.active = false;
          }
          const match = findSuggestionMatch$1({
            char,
            allowSpaces,
            allowedPrefixes,
            startOfLine,
            $position: selection.$from
          });
          const decorationId = `id_${Math.floor(Math.random() * 4294967295)}`;
          if (match && allow({ editor, state, range: match.range })) {
            next.active = true;
            next.decorationId = prev.decorationId ? prev.decorationId : decorationId;
            next.range = match.range;
            next.query = match.query;
            next.text = match.text;
          } else {
            next.active = false;
          }
        } else {
          next.active = false;
        }
        if (!next.active) {
          next.decorationId = null;
          next.range = { from: 0, to: 0 };
          next.query = null;
          next.text = null;
        }
        return next;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(view, event) {
        var _a;
        const { active, range } = plugin.getState(view.state);
        if (!active) {
          return false;
        }
        return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, { view, event, range })) || false;
      },
      // Setup decorator on the currently active suggestion.
      decorations(state) {
        const { active, range, decorationId } = plugin.getState(state);
        if (!active) {
          return null;
        }
        return DecorationSet.create(state.doc, [
          Decoration.inline(range.from, range.to, {
            nodeName: decorationTag,
            class: decorationClass,
            "data-decoration-id": decorationId
          })
        ]);
      }
    }
  });
  return plugin;
}

// resources/js/components/CommandsList.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
function create_if_block_1(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(Object.keys(
    /*groups*/
    ctx[3]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups, Object, selectedIndex, selectItem*/
      26) {
        each_value = ensure_array_like(Object.keys(
          /*groups*/
          ctx2[3]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let div2;
  let t_value = (
    /*group*/
    ctx[17] + ""
  );
  let t;
  return {
    c() {
      div2 = element("div");
      t = text(t_value);
      attr(div2, "class", "group-title");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups*/
      8 && t_value !== (t_value = /*group*/
      ctx2[17] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_if_block_2(ctx) {
  let span;
  let t_value = (
    /*item*/
    ctx[20].description + ""
  );
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "description");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups*/
      8 && t_value !== (t_value = /*item*/
      ctx2[20].description + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block_1(ctx) {
  let button;
  let span0;
  let raw_value = (
    /*item*/
    ctx[20].icon + ""
  );
  let t0;
  let span2;
  let span1;
  let t1_value = (
    /*item*/
    ctx[20].label + ""
  );
  let t1;
  let t2;
  let t3;
  let button_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*item*/
    ctx[20].description && create_if_block_2(ctx)
  );
  function click_handler() {
    return (
      /*click_handler*/
      ctx[9](
        /*item*/
        ctx[20]
      )
    );
  }
  return {
    c() {
      button = element("button");
      span0 = element("span");
      t0 = space();
      span2 = element("span");
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      attr(span0, "class", "icon");
      attr(span1, "class", "label");
      attr(span2, "class", "text");
      attr(button, "class", button_class_value = /*item*/
      ctx[20].index === /*selectedIndex*/
      ctx[1] ? "active-option" : "");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span0);
      span0.innerHTML = raw_value;
      append(button, t0);
      append(button, span2);
      append(span2, span1);
      append(span1, t1);
      append(span2, t2);
      if (if_block)
        if_block.m(span2, null);
      append(button, t3);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*groups*/
      8 && raw_value !== (raw_value = /*item*/
      ctx[20].icon + ""))
        span0.innerHTML = raw_value;
      ;
      if (dirty & /*groups*/
      8 && t1_value !== (t1_value = /*item*/
      ctx[20].label + ""))
        set_data(t1, t1_value);
      if (
        /*item*/
        ctx[20].description
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_2(ctx);
          if_block.c();
          if_block.m(span2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*groups, selectedIndex*/
      10 && button_class_value !== (button_class_value = /*item*/
      ctx[20].index === /*selectedIndex*/
      ctx[1] ? "active-option" : "")) {
        attr(button, "class", button_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_each_block(ctx) {
  let t;
  let each_1_anchor;
  let if_block = (
    /*group*/
    ctx[17] && create_if_block_3(ctx)
  );
  let each_value_1 = ensure_array_like(
    /*groups*/
    ctx[3][
      /*group*/
      ctx[17]
    ]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*group*/
        ctx2[17]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*groups, Object, selectedIndex, selectItem*/
      26) {
        each_value_1 = ensure_array_like(
          /*groups*/
          ctx2[3][
            /*group*/
            ctx2[17]
          ]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(each_1_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block2(ctx) {
  let div2;
  return {
    c() {
      div2 = element("div");
      div2.textContent = "No blocks found";
      attr(div2, "class", "no-blocks");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_fragment8(ctx) {
  let div1;
  let div0;
  let t;
  let if_block0 = (
    /*items*/
    ctx[0].length && create_if_block_1(ctx)
  );
  let if_block1 = !/*items*/
  ctx[0].length && create_if_block2(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "group");
      attr(div1, "class", "scribble-suggestions");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t);
      if (if_block1)
        if_block1.m(div0, null);
      ctx[10](div1);
    },
    p(ctx2, [dirty]) {
      if (
        /*items*/
        ctx2[0].length
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(div0, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*items*/
      ctx2[0].length) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[10](null);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let $getStatePath;
  component_subscribe($$self, getStatePath, ($$value) => $$invalidate(11, $getStatePath = $$value));
  let { items } = $$props;
  let { editor } = $$props;
  let { range } = $$props;
  let selectedIndex = 0;
  let dropdown;
  let groups;
  const getGroups = (array) => {
    let map2 = array.map((e, i) => {
      e.index = i;
      return e;
    });
    $$invalidate(3, groups = map2.reduce(
      function(r2, a) {
        r2[a.group] = r2[a.group] || [];
        r2[a.group].push(a);
        return r2;
      },
      /* @__PURE__ */ Object.create(null)
    ));
  };
  const resetIndex = () => $$invalidate(1, selectedIndex = 0);
  const onKeyDown = ({ event }) => {
    if (event.key === "ArrowUp") {
      upHandler();
      return true;
    }
    if (event.key === "ArrowDown") {
      downHandler();
      return true;
    }
    if (event.key === "Enter") {
      enterHandler();
      return true;
    }
    return false;
  };
  const upHandler = () => {
    $$invalidate(1, selectedIndex = (selectedIndex + items.length - 1) % items.length);
    scrollToSelect();
  };
  const downHandler = () => {
    $$invalidate(1, selectedIndex = (selectedIndex + 1) % items.length);
    scrollToSelect();
  };
  const enterHandler = () => {
    selectItem(selectedIndex);
  };
  const selectItem = (index) => {
    const item = items[index];
    if (item) {
      editor.commands.deleteRange(range);
      switch (item.type) {
        case "command":
          commandRunner(editor, item.commands);
          break;
        case "modal":
          pounce(item.identifier, {
            statePath: $getStatePath,
            ...editor.getAttributes(item.extension)
          });
          break;
        case "static":
          editor.chain().insertScribbleBlock({
            identifier: item.identifier,
            type: item.type,
            values: {}
          }).focus().run();
          break;
        default:
          editor.commands.setScribbleBlock({
            identifier: item.identifier,
            statePath: item.statePath
          });
      }
    }
  };
  const scrollToSelect = () => {
    setTimeout(
      () => {
        dropdown.querySelector(".active-option").scrollIntoView({
          behavior: "smooth",
          block: "nearest",
          inline: "end"
        });
      },
      0
    );
  };
  const click_handler = (item) => selectItem(item.index);
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dropdown = $$value;
      $$invalidate(2, dropdown);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("editor" in $$props2)
      $$invalidate(5, editor = $$props2.editor);
    if ("range" in $$props2)
      $$invalidate(6, range = $$props2.range);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*items*/
    1) {
      $:
        getGroups(items);
    }
  };
  return [
    items,
    selectedIndex,
    dropdown,
    groups,
    selectItem,
    editor,
    range,
    resetIndex,
    onKeyDown,
    click_handler,
    div1_binding
  ];
}
var CommandsList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment8, safe_not_equal, {
      items: 0,
      editor: 5,
      range: 6,
      resetIndex: 7,
      onKeyDown: 8
    });
  }
  get resetIndex() {
    return this.$$.ctx[7];
  }
  get onKeyDown() {
    return this.$$.ctx[8];
  }
};
var CommandsList_default = CommandsList;

// resources/js/extensions/SlashExtension.js
var SlashExtension_default = Extension.create({
  name: "slashExtension",
  addOptions() {
    return {
      blocks: {
        default: []
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      Suggestion({
        editor: this.editor,
        char: "/",
        command: ({ editor, range, props }) => {
          props.command({ editor, range });
        },
        startOfLine: true,
        pluginKey: new PluginKey("slashExtension"),
        items: ({ query }) => {
          return this.options.tools.filter((item) => item.label.toLowerCase().includes(query.toLowerCase()));
        },
        render: () => {
          let component;
          let popup;
          return {
            onStart: (props) => {
              if (!props.clientRect) {
                return;
              }
              const element2 = document.createElement("div");
              component = new CommandsList_default({
                target: element2,
                props: {
                  items: props.items,
                  editor: props.editor,
                  range: props.range
                }
              });
              popup = tippy_esm_default("body", {
                getReferenceClientRect: props.clientRect,
                appendTo: () => document.body,
                content: component.$$.root,
                showOnCreate: true,
                interactive: true,
                trigger: "manual",
                placement: "bottom-start",
                theme: "scribble-panel",
                arrow: false,
                zIndex: 40
              });
            },
            onUpdate(props) {
              component.$set({
                items: props.items,
                editor: props.editor,
                range: props.range
              });
              component.resetIndex();
              if (!props.clientRect) {
                return;
              }
              popup[0].setProps({
                getReferenceClientRect: props.clientRect
              });
            },
            onKeyDown(props) {
              if (props.event.key === "Escape") {
                popup[0].hide();
                return true;
              }
              return component.onKeyDown(props);
            },
            onExit() {
              popup[0].destroy();
              component.$destroy();
            }
          };
        }
      })
    ];
  }
});

// node_modules/@tiptap/extension-subscript/dist/index.js
var Subscript = Mark2.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(value) {
          if (value !== "sub") {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["sub", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleSubscript: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetSubscript: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
});

// node_modules/@tiptap/extension-superscript/dist/index.js
var Superscript = Mark2.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(value) {
          if (value !== "super") {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["sup", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleSuperscript: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetSuperscript: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
});

// resources/js/extensions/TextAlignExtension.js
var TextAlignExtension_default = Extension.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["start", "center", "end", "justify"],
      defaultAlignment: "start"
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (element2) => element2.style.textAlign || this.options.defaultAlignment,
            renderHTML: (attributes) => {
              if (attributes.textAlign === this.options.defaultAlignment) {
                return {};
              }
              return { style: `text-align: ${attributes.textAlign}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (alignment) => ({ commands: commands2 }) => {
        if (!this.options.alignments.includes(alignment)) {
          return false;
        }
        return this.options.types.every((type) => commands2.updateAttributes(type, { textAlign: alignment }));
      },
      unsetTextAlign: () => ({ commands: commands2 }) => {
        return this.options.types.every((type) => commands2.resetAttributes(type, "textAlign"));
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("start"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("end"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});

// node_modules/@tiptap/extension-text-style/dist/index.js
var TextStyle3 = Mark2.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (element2) => {
          const hasStyles = element2.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
        const attributes = getMarkAttributes(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) {
          return true;
        }
        return commands2.unsetMark(this.name);
      }
    };
  }
});

// node_modules/@tiptap/extension-underline/dist/index.js
var Underline = Mark2.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("underline") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleUnderline: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetUnderline: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e)
    n += e;
  else if ("object" == typeof e)
    if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++)
        e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else
      for (f in e)
        e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++)
    (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_default = clsx;

// resources/js/components/Button.svelte
function create_if_block3(ctx) {
  let button;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(button, "type", "button");
      attr(button, "class", button_class_value = clsx_default(`scribble-button ${/*key*/
      ctx[1]}`, { "active": (
        /*active*/
        ctx[2]
      ) }));
      toggle_class(
        button,
        "active",
        /*active*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*key, active*/
      6 && button_class_value !== (button_class_value = clsx_default(`scribble-button ${/*key*/
      ctx2[1]}`, { "active": (
        /*active*/
        ctx2[2]
      ) }))) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*key, active, active*/
      6) {
        toggle_class(
          button,
          "active",
          /*active*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment9(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*editor*/
    ctx[0] && !/*hidden*/
    ctx[3] && create_if_block3(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*editor*/
        ctx2[0] && !/*hidden*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*editor, hidden*/
          9) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { editor } = $$props;
  let { key } = $$props;
  let { active = false } = $$props;
  let { hidden } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(0, editor = $$props2.editor);
    if ("key" in $$props2)
      $$invalidate(1, key = $$props2.key);
    if ("active" in $$props2)
      $$invalidate(2, active = $$props2.active);
    if ("hidden" in $$props2)
      $$invalidate(3, hidden = $$props2.hidden);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [editor, key, active, hidden, $$scope, slots, click_handler];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment9, safe_not_equal, { editor: 0, key: 1, active: 2, hidden: 3 });
  }
};
var Button_default = Button;

// resources/js/components/Controls.svelte
function create_if_block4(ctx) {
  let div1;
  let div0;
  let button0;
  let t0;
  let button1;
  let t1;
  let button2;
  let t2;
  let button3;
  let t3;
  let button4;
  let current;
  button0 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: "undo",
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*click_handler*/
    ctx[2]
  );
  button1 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: "redo",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*click_handler_1*/
    ctx[3]
  );
  button2 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: "clear",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  button2.$on(
    "click",
    /*click_handler_2*/
    ctx[4]
  );
  button3 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: "enter-fullscreen",
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  button3.$on(
    "click",
    /*toggleFullscreen*/
    ctx[1]
  );
  button4 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: "exit-fullscreen",
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    }
  });
  button4.$on(
    "click",
    /*toggleFullscreen*/
    ctx[1]
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(button2.$$.fragment);
      t2 = space();
      create_component(button3.$$.fragment);
      t3 = space();
      create_component(button4.$$.fragment);
      attr(div0, "class", "scribble-controls-panel");
      attr(div1, "class", "scribble-controls");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(button0, div0, null);
      append(div0, t0);
      mount_component(button1, div0, null);
      append(div0, t1);
      mount_component(button2, div0, null);
      append(div0, t2);
      mount_component(button3, div0, null);
      append(div0, t3);
      mount_component(button4, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*editor*/
      1)
        button0_changes.editor = /*editor*/
        ctx2[0];
      if (dirty & /*$$scope*/
      64) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*editor*/
      1)
        button1_changes.editor = /*editor*/
        ctx2[0];
      if (dirty & /*$$scope*/
      64) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*editor*/
      1)
        button2_changes.editor = /*editor*/
        ctx2[0];
      if (dirty & /*$$scope*/
      64) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      const button3_changes = {};
      if (dirty & /*editor*/
      1)
        button3_changes.editor = /*editor*/
        ctx2[0];
      if (dirty & /*$$scope*/
      64) {
        button3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button3.$set(button3_changes);
      const button4_changes = {};
      if (dirty & /*editor*/
      1)
        button4_changes.editor = /*editor*/
        ctx2[0];
      if (dirty & /*$$scope*/
      64) {
        button4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button4.$set(button4_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      transition_in(button4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      transition_out(button4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button2);
      destroy_component(button3);
      destroy_component(button4);
    }
  };
}
function create_default_slot_4(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "none");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "32");
      attr(path, "d", "M240 424v-96c116.4 0 159.39 33.76 208 96c0-119.23-39.57-240-208-240V88L64 256Z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "32");
      attr(svg, "height", "32");
      attr(svg, "viewBox", "0 0 512 512");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot_3(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "none");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "32");
      attr(path, "d", "M448 256L272 88v96C103.57 184 64 304.77 64 424c48.61-62.24 91.6-96 208-96v96Z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "32");
      attr(svg, "height", "32");
      attr(svg, "viewBox", "0 0 512 512");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot_2(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M13.9999 18.9967H20.9999V20.9967H11.9999L8.00229 20.9992L1.51457 14.5115C1.12405 14.1209 1.12405 13.4878 1.51457 13.0972L12.1212 2.49065C12.5117 2.10012 13.1449 2.10012 13.5354 2.49065L21.3136 10.2688C21.7041 10.6593 21.7041 11.2925 21.3136 11.683L13.9999 18.9967ZM15.6567 14.5115L19.1922 10.9759L12.8283 4.61197L9.29275 8.1475L15.6567 14.5115Z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot_13(ctx) {
  let svg;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "fill", "none");
      attr(path0, "d", "M0 0h24v24H0z");
      attr(path1, "d", "M20 3h2v6h-2V5h-4V3h4zM4 3h4v2H4v4H2V3h2zm16 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot3(ctx) {
  let svg;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "fill", "none");
      attr(path0, "d", "M0 0h24v24H0z");
      attr(path1, "d", "M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_fragment10(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*editor*/
    ctx[0] && create_if_block4(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*editor*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*editor*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let $getStatePath;
  component_subscribe($$self, getStatePath, ($$value) => $$invalidate(5, $getStatePath = $$value));
  let { editor } = $$props;
  const toggleFullscreen = () => {
    window.dispatchEvent(new CustomEvent("toggle-fullscreen", { detail: { statePath: $getStatePath } }));
    editor.commands.focus();
  };
  const click_handler = () => editor.chain().focus().undo().run();
  const click_handler_1 = () => editor.chain().focus().redo().run();
  const click_handler_2 = () => editor.chain().focus().clearContent(true).run();
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(0, editor = $$props2.editor);
  };
  return [editor, toggleFullscreen, click_handler, click_handler_1, click_handler_2];
}
var Controls = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment10, safe_not_equal, { editor: 0 });
  }
};
var Controls_default = Controls;

// resources/js/components/BubbleMenu.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function create_if_block5(ctx) {
  let div2;
  let show_if;
  let show_if_1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_12, create_if_block_4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*isActive*/
    4)
      show_if = null;
    if (dirty & /*isActive*/
    4)
      show_if_1 = null;
    if (show_if == null)
      show_if = !!!/*isActive*/
      ctx2[2]("link");
    if (show_if)
      return 0;
    if (show_if_1 == null)
      show_if_1 = !!/*isActive*/
      ctx2[2]("link");
    if (show_if_1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      attr(div2, "class", "scribble-bubble-menu");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div2, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block_4(ctx) {
  let span;
  let t0_value = (
    /*editor*/
    ctx[1].getAttributes("link").href + ""
  );
  let t0;
  let t1;
  let button0;
  let t2;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[1]
      ),
      key: "editLink",
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*click_handler_2*/
    ctx[7]
  );
  button1 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[1]
      ),
      key: "unsetLink",
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*click_handler_3*/
    ctx[8]
  );
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      create_component(button0.$$.fragment);
      t2 = space();
      create_component(button1.$$.fragment);
      attr(span, "class", "link-preview");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      mount_component(button0, target, anchor);
      insert(target, t2, anchor);
      mount_component(button1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*editor*/
      2) && t0_value !== (t0_value = /*editor*/
      ctx2[1].getAttributes("link").href + ""))
        set_data(t0, t0_value);
      const button0_changes = {};
      if (dirty & /*editor*/
      2)
        button0_changes.editor = /*editor*/
        ctx2[1];
      if (dirty & /*$$scope*/
      262144) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*editor*/
      2)
        button1_changes.editor = /*editor*/
        ctx2[1];
      if (dirty & /*$$scope*/
      262144) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t1);
        detach(t2);
      }
      destroy_component(button0, detaching);
      destroy_component(button1, detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*tools*/
    ctx[0].length && create_if_block_22(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*tools*/
        ctx2[0].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*tools*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_22(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_default_slot_32(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M18.3643 15.5353L16.95 14.1211L18.3643 12.7069C20.3169 10.7543 20.3169 7.58847 18.3643 5.63585C16.4116 3.68323 13.2458 3.68323 11.2932 5.63585L9.87898 7.05007L8.46477 5.63585L9.87898 4.22164C12.6127 1.48797 17.0448 1.48797 19.7785 4.22164C22.5121 6.95531 22.5121 11.3875 19.7785 14.1211L18.3643 15.5353ZM15.5358 18.3638L14.1216 19.778C11.388 22.5117 6.9558 22.5117 4.22213 19.778C1.48846 17.0443 1.48846 12.6122 4.22213 9.87849L5.63634 8.46428L7.05055 9.87849L5.63634 11.2927C3.68372 13.2453 3.68372 16.4112 5.63634 18.3638C7.58896 20.3164 10.7548 20.3164 12.7074 18.3638L14.1216 16.9496L15.5358 18.3638ZM14.8287 7.75717L16.2429 9.17139L9.17187 16.2425L7.75766 14.8282L14.8287 7.75717Z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot_22(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M17 17H22V19H19V22H17V17ZM7 7H2V5H5V2H7V7ZM18.364 15.5355L16.9497 14.1213L18.364 12.7071C20.3166 10.7545 20.3166 7.58866 18.364 5.63604C16.4113 3.68342 13.2455 3.68342 11.2929 5.63604L9.87868 7.05025L8.46447 5.63604L9.87868 4.22183C12.6123 1.48816 17.0445 1.48816 19.7782 4.22183C22.5118 6.9555 22.5118 11.3877 19.7782 14.1213L18.364 15.5355ZM15.5355 18.364L14.1213 19.7782C11.3877 22.5118 6.9555 22.5118 4.22183 19.7782C1.48816 17.0445 1.48816 12.6123 4.22183 9.87868L5.63604 8.46447L7.05025 9.87868L5.63604 11.2929C3.68342 13.2455 3.68342 16.4113 5.63604 18.364C7.58866 20.3166 10.7545 20.3166 12.7071 18.364L14.1213 16.9497L15.5355 18.364ZM14.8284 7.75736L16.2426 9.17157L9.17157 16.2426L7.75736 14.8284L14.8284 7.75736Z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_22(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(Object.keys(
    /*groups*/
    ctx[4]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*groups, Object, editor, isActive, handleToolClick*/
      30) {
        each_value = ensure_array_like(Object.keys(
          /*groups*/
          ctx2[4]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ensure_array_like(
    /*groups*/
    ctx[4][
      /*group*/
      ctx[10]
    ]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*editor, groups, Object, isActive, handleToolClick*/
      30) {
        each_value_2 = ensure_array_like(
          /*groups*/
          ctx2[4][
            /*group*/
            ctx2[10]
          ]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_32(ctx) {
  let div2;
  let t;
  let current;
  let each_value_1 = ensure_array_like(
    /*groups*/
    ctx[4][
      /*group*/
      ctx[10]
    ]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div2 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      attr(div2, "class", "bubble-group");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      append(div2, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*editor, groups, Object, isActive, handleToolClick*/
      30) {
        each_value_1 = ensure_array_like(
          /*groups*/
          ctx2[4][
            /*group*/
            ctx2[10]
          ]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_12(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div2, t);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_14(ctx) {
  let html_tag;
  let raw_value = (
    /*tool*/
    ctx[13].icon + ""
  );
  let t;
  return {
    c() {
      html_tag = new HtmlTag(false);
      t = space();
      html_tag.a = t;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups*/
      16 && raw_value !== (raw_value = /*tool*/
      ctx2[13].icon + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        html_tag.d();
        detach(t);
      }
    }
  };
}
function create_each_block_2(ctx) {
  let button;
  let current;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[6](
        /*tool*/
        ctx[13]
      )
    );
  }
  button = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[1]
      ),
      key: (
        /*tool*/
        ctx[13].extension
      ),
      active: (
        /*isActive*/
        ctx[2](
          /*tool*/
          ctx[13].extension,
          /*tool*/
          ctx[13].activeAttributes
        )
      ),
      hidden: (
        /*tool*/
        ctx[13].isHidden
      ),
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler_1);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*editor*/
      2)
        button_changes.editor = /*editor*/
        ctx[1];
      if (dirty & /*groups*/
      16)
        button_changes.key = /*tool*/
        ctx[13].extension;
      if (dirty & /*isActive, groups*/
      20)
        button_changes.active = /*isActive*/
        ctx[2](
          /*tool*/
          ctx[13].extension,
          /*tool*/
          ctx[13].activeAttributes
        );
      if (dirty & /*groups*/
      16)
        button_changes.hidden = /*tool*/
        ctx[13].isHidden;
      if (dirty & /*$$scope, groups*/
      262160) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot4(ctx) {
  let html_tag;
  let raw_value = (
    /*tool*/
    ctx[13].icon + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups*/
      16 && raw_value !== (raw_value = /*tool*/
      ctx2[13].icon + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_each_block_12(ctx) {
  let button;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[5](
        /*tool*/
        ctx[13]
      )
    );
  }
  button = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[1]
      ),
      key: (
        /*tool*/
        ctx[13].extension
      ),
      active: (
        /*isActive*/
        ctx[2](
          /*tool*/
          ctx[13].extension,
          /*tool*/
          ctx[13].activeAttributes
        )
      ),
      hidden: (
        /*tool*/
        ctx[13].isHidden
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*editor*/
      2)
        button_changes.editor = /*editor*/
        ctx[1];
      if (dirty & /*groups*/
      16)
        button_changes.key = /*tool*/
        ctx[13].extension;
      if (dirty & /*isActive, groups*/
      20)
        button_changes.active = /*isActive*/
        ctx[2](
          /*tool*/
          ctx[13].extension,
          /*tool*/
          ctx[13].activeAttributes
        );
      if (dirty & /*groups*/
      16)
        button_changes.hidden = /*tool*/
        ctx[13].isHidden;
      if (dirty & /*$$scope, groups*/
      262160) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_each_block2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_32, create_else_block];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*group*/
      ctx2[10] !== ""
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_fragment11(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*editor*/
    ctx[1] && create_if_block5(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*editor*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*editor*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { editor } = $$props;
  let { isActive: isActive2 } = $$props;
  let { tools } = $$props;
  let { handleToolClick } = $$props;
  let groups = {};
  const getGroups = (array) => {
    let map2 = array.map((e, i) => {
      e.index = i;
      return e;
    });
    $$invalidate(4, groups = map2.reduce(
      function(r2, a) {
        r2[a.group] = r2[a.group] || [];
        r2[a.group].push(a);
        return r2;
      },
      /* @__PURE__ */ Object.create(null)
    ));
  };
  onMount(() => {
    $$invalidate(0, tools = tools.filter((tool) => {
      return !tool.isHidden;
    }));
  });
  const click_handler = (tool) => handleToolClick(tool);
  const click_handler_1 = (tool) => handleToolClick(tool);
  const click_handler_2 = () => handleToolClick(tools.find((item) => item.extension === "link"), true);
  const click_handler_3 = () => editor.chain().focus().extendMarkRange("link").unsetLink().selectTextblockEnd().run();
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(1, editor = $$props2.editor);
    if ("isActive" in $$props2)
      $$invalidate(2, isActive2 = $$props2.isActive);
    if ("tools" in $$props2)
      $$invalidate(0, tools = $$props2.tools);
    if ("handleToolClick" in $$props2)
      $$invalidate(3, handleToolClick = $$props2.handleToolClick);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tools*/
    1) {
      $:
        getGroups(tools);
    }
  };
  return [
    tools,
    editor,
    isActive2,
    handleToolClick,
    groups,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
var BubbleMenu2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment11, safe_not_equal, {
      editor: 1,
      isActive: 2,
      tools: 0,
      handleToolClick: 3
    });
  }
};
var BubbleMenu_default2 = BubbleMenu2;

// resources/js/components/Toolbar.svelte
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function get_each_context_22(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function create_if_block6(ctx) {
  let div2;
  let current;
  let if_block = (
    /*tools*/
    ctx[2].length && create_if_block_13(ctx)
  );
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      attr(div2, "class", "scribble-toolbar");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block)
        if_block.m(div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*tools*/
        ctx2[2].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*tools*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_13(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(Object.keys(
    /*groups*/
    ctx[4]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*groups, Object, editor, isActive, handleToolClick*/
      27) {
        each_value = ensure_array_like(Object.keys(
          /*groups*/
          ctx2[4]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block2(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ensure_array_like(
    /*groups*/
    ctx[4][
      /*group*/
      ctx[8]
    ]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_22(get_each_context_22(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*editor, groups, Object, isActive, handleToolClick*/
      27) {
        each_value_2 = ensure_array_like(
          /*groups*/
          ctx2[4][
            /*group*/
            ctx2[8]
          ]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_22(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_22(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_23(ctx) {
  let div2;
  let t;
  let current;
  let each_value_1 = ensure_array_like(
    /*groups*/
    ctx[4][
      /*group*/
      ctx[8]
    ]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div2 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      attr(div2, "class", "toolbar-group");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      append(div2, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*editor, groups, Object, isActive, handleToolClick*/
      27) {
        each_value_1 = ensure_array_like(
          /*groups*/
          ctx2[4][
            /*group*/
            ctx2[8]
          ]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_13(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_13(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div2, t);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_15(ctx) {
  let html_tag;
  let raw_value = (
    /*tool*/
    ctx[11].icon + ""
  );
  let t;
  return {
    c() {
      html_tag = new HtmlTag(false);
      t = space();
      html_tag.a = t;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups*/
      16 && raw_value !== (raw_value = /*tool*/
      ctx2[11].icon + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        html_tag.d();
        detach(t);
      }
    }
  };
}
function create_each_block_22(ctx) {
  let button;
  let current;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[6](
        /*tool*/
        ctx[11]
      )
    );
  }
  button = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: (
        /*tool*/
        ctx[11].extension
      ),
      active: (
        /*isActive*/
        ctx[1](
          /*tool*/
          ctx[11].extension,
          /*tool*/
          ctx[11].activeAttributes
        )
      ),
      hidden: (
        /*tool*/
        ctx[11].isHidden
      ),
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler_1);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*editor*/
      1)
        button_changes.editor = /*editor*/
        ctx[0];
      if (dirty & /*groups*/
      16)
        button_changes.key = /*tool*/
        ctx[11].extension;
      if (dirty & /*isActive, groups*/
      18)
        button_changes.active = /*isActive*/
        ctx[1](
          /*tool*/
          ctx[11].extension,
          /*tool*/
          ctx[11].activeAttributes
        );
      if (dirty & /*groups*/
      16)
        button_changes.hidden = /*tool*/
        ctx[11].isHidden;
      if (dirty & /*$$scope, groups*/
      65552) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot5(ctx) {
  let html_tag;
  let raw_value = (
    /*tool*/
    ctx[11].icon + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups*/
      16 && raw_value !== (raw_value = /*tool*/
      ctx2[11].icon + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_each_block_13(ctx) {
  let button;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[5](
        /*tool*/
        ctx[11]
      )
    );
  }
  button = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: (
        /*tool*/
        ctx[11].extension
      ),
      active: (
        /*isActive*/
        ctx[1](
          /*tool*/
          ctx[11].extension,
          /*tool*/
          ctx[11].activeAttributes
        )
      ),
      hidden: (
        /*tool*/
        ctx[11].isHidden
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*editor*/
      1)
        button_changes.editor = /*editor*/
        ctx[0];
      if (dirty & /*groups*/
      16)
        button_changes.key = /*tool*/
        ctx[11].extension;
      if (dirty & /*isActive, groups*/
      18)
        button_changes.active = /*isActive*/
        ctx[1](
          /*tool*/
          ctx[11].extension,
          /*tool*/
          ctx[11].activeAttributes
        );
      if (dirty & /*groups*/
      16)
        button_changes.hidden = /*tool*/
        ctx[11].isHidden;
      if (dirty & /*$$scope, groups*/
      65552) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_each_block3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_23, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*group*/
      ctx2[8] !== ""
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_fragment12(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*editor*/
    ctx[0] && /*tools*/
    ctx[2] && /*tools*/
    ctx[2].length > 0 && create_if_block6(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*editor*/
        ctx2[0] && /*tools*/
        ctx2[2] && /*tools*/
        ctx2[2].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*editor, tools*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { editor } = $$props;
  let { isActive: isActive2 } = $$props;
  let { tools } = $$props;
  let { handleToolClick } = $$props;
  let groups = {};
  const getGroups = (array) => {
    let map2 = array.map((e, i) => {
      e.index = i;
      return e;
    });
    $$invalidate(4, groups = map2.reduce(
      function(r2, a) {
        r2[a.group] = r2[a.group] || [];
        r2[a.group].push(a);
        return r2;
      },
      /* @__PURE__ */ Object.create(null)
    ));
  };
  const click_handler = (tool) => handleToolClick(tool);
  const click_handler_1 = (tool) => handleToolClick(tool);
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(0, editor = $$props2.editor);
    if ("isActive" in $$props2)
      $$invalidate(1, isActive2 = $$props2.isActive);
    if ("tools" in $$props2)
      $$invalidate(2, tools = $$props2.tools);
    if ("handleToolClick" in $$props2)
      $$invalidate(3, handleToolClick = $$props2.handleToolClick);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tools*/
    4) {
      $:
        getGroups(tools);
    }
  };
  return [
    editor,
    isActive2,
    tools,
    handleToolClick,
    groups,
    click_handler,
    click_handler_1
  ];
}
var Toolbar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment12, safe_not_equal, {
      editor: 0,
      isActive: 1,
      tools: 2,
      handleToolClick: 3
    });
  }
};
var Toolbar_default = Toolbar;

// resources/js/Scribble.svelte
function create_fragment13(ctx) {
  let div2;
  let controls;
  let t0;
  let toolbar;
  let t1;
  let div0;
  let t2;
  let div1;
  let bubblemenu;
  let current;
  controls = new Controls_default({ props: { editor: (
    /*editor*/
    ctx[2]
  ) } });
  toolbar = new Toolbar_default({
    props: {
      editor: (
        /*editor*/
        ctx[2]
      ),
      tools: (
        /*toolbarTools*/
        ctx[1]
      ),
      handleToolClick: (
        /*handleToolClick*/
        ctx[6]
      ),
      isActive: (
        /*isActive*/
        ctx[5]
      )
    }
  });
  bubblemenu = new BubbleMenu_default2({
    props: {
      editor: (
        /*editor*/
        ctx[2]
      ),
      tools: (
        /*bubbleTools*/
        ctx[0]
      ),
      handleToolClick: (
        /*handleToolClick*/
        ctx[6]
      ),
      isActive: (
        /*isActive*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      div2 = element("div");
      create_component(controls.$$.fragment);
      t0 = space();
      create_component(toolbar.$$.fragment);
      t1 = space();
      div0 = element("div");
      t2 = space();
      div1 = element("div");
      create_component(bubblemenu.$$.fragment);
      attr(div0, "class", "scribble-editor");
      attr(div2, "class", "scribble-editor-wrapper");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(controls, div2, null);
      append(div2, t0);
      mount_component(toolbar, div2, null);
      append(div2, t1);
      append(div2, div0);
      ctx[11](div0);
      append(div2, t2);
      append(div2, div1);
      mount_component(bubblemenu, div1, null);
      ctx[12](div1);
      current = true;
    },
    p(ctx2, [dirty]) {
      const controls_changes = {};
      if (dirty & /*editor*/
      4)
        controls_changes.editor = /*editor*/
        ctx2[2];
      controls.$set(controls_changes);
      const toolbar_changes = {};
      if (dirty & /*editor*/
      4)
        toolbar_changes.editor = /*editor*/
        ctx2[2];
      if (dirty & /*toolbarTools*/
      2)
        toolbar_changes.tools = /*toolbarTools*/
        ctx2[1];
      if (dirty & /*isActive*/
      32)
        toolbar_changes.isActive = /*isActive*/
        ctx2[5];
      toolbar.$set(toolbar_changes);
      const bubblemenu_changes = {};
      if (dirty & /*editor*/
      4)
        bubblemenu_changes.editor = /*editor*/
        ctx2[2];
      if (dirty & /*bubbleTools*/
      1)
        bubblemenu_changes.tools = /*bubbleTools*/
        ctx2[0];
      if (dirty & /*isActive*/
      32)
        bubblemenu_changes.isActive = /*isActive*/
        ctx2[5];
      bubblemenu.$set(bubblemenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(controls.$$.fragment, local);
      transition_in(toolbar.$$.fragment, local);
      transition_in(bubblemenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(controls.$$.fragment, local);
      transition_out(toolbar.$$.fragment, local);
      transition_out(bubblemenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(controls);
      destroy_component(toolbar);
      ctx[11](null);
      destroy_component(bubblemenu);
      ctx[12](null);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let isActive2;
  let $getStatePath;
  component_subscribe($$self, getStatePath, ($$value) => $$invalidate(14, $getStatePath = $$value));
  let editor;
  let element2;
  let bubbleMenuElement;
  let tools;
  let { content } = $$props;
  let { statePath } = $$props;
  let { placeholder } = $$props;
  let { bubbleTools } = $$props;
  let { suggestionTools } = $$props;
  let { toolbarTools } = $$props;
  set_store_value(getStatePath, $getStatePath = statePath, $getStatePath);
  onMount(() => {
    $$invalidate(2, editor = new Editor({
      content,
      element: element2,
      extensions: [
        StarterKit,
        ClassExtension_default,
        CommandsExtension_default,
        LinkExtension_default,
        IdExtension_default,
        Grid_default,
        GridColumn_default,
        ScribbleBlock_default2,
        Subscript,
        Superscript,
        MediaExtension_default,
        Underline,
        TextAlignExtension_default.configure({ types: ["heading", "paragraph"] }),
        TextStyle3,
        SlashExtension_default.configure({ tools: suggestionTools }),
        BubbleMenu.configure({
          element: bubbleMenuElement,
          tippyOptions: {
            maxWidth: "none",
            placement: "bottom-start",
            theme: "scribble-bubble",
            interactive: true
          },
          shouldShow: ({ editor: editor2, from: from2, to }) => {
            if (from2 === to && editor2.isActive("link")) {
              return true;
            }
            return from2 !== to && !(editor2.isActive("image") || editor2.isActive("scribbleBlock") || editor2.isActive("slashExtension"));
          }
        }),
        Placeholder.configure({
          placeholder,
          emptyEditorClass: "is-editor-empty"
        })
      ],
      onTransaction: () => {
        $$invalidate(2, editor);
      },
      onUpdate({ editor: editor2 }) {
        window.dispatchEvent(new CustomEvent(
          "updatedEditor",
          {
            detail: { statePath, content: editor2.getJSON() }
          }
        ));
      }
    }));
  });
  onDestroy(() => {
    editor.destroy();
  });
  tools = [...bubbleTools.flat(), ...suggestionTools.flat(), ...toolbarTools.flat()];
  tools.forEach((tool) => {
    window.addEventListener(`insert-${tool.extension}`, (data) => {
      if (data.detail.statePath !== statePath) {
        return;
      }
      if (tool.type === "block" || tool.type === "static") {
        editor.chain().insertScribbleBlock({
          identifier: tool.identifier,
          type: tool.type,
          values: data.detail.values
        }).focus().run();
        return;
      }
      commandRunner(editor, tool.commands, data.detail.values);
    });
    window.addEventListener(`update-${tool.extension}`, (data) => {
      if (data.detail.statePath !== statePath) {
        return;
      }
      if (tool.type === "block" || tool.type === "static") {
        window.dispatchEvent(new CustomEvent(
          "updatedBlock",
          {
            detail: {
              statePath,
              identifier: tool.identifier,
              type: tool.type,
              blockId: data.detail.blockId,
              values: data.detail.values
            }
          }
        ));
        return;
      }
      commandRunner(editor, tool.commands, data.detail.values);
    });
  });
  const handleToolClick = (tool, update2 = false) => {
    switch (tool.type) {
      case "command":
        commandRunner(editor, tool.commands);
        return;
      case "modal":
        pounce(tool.identifier, {
          statePath: tool.statePath,
          update: update2,
          ...editor.getAttributes(tool.extension)
        });
        return;
      case "static":
        editor.chain().insertScribbleBlock({
          identifier: tool.identifier,
          type: tool.type,
          values: {}
        }).focus().run();
        return;
      default:
        editor.commands.setScribbleBlock({
          statePath,
          identifier: tool.identifier,
          type: tool.type
        });
    }
  };
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(3, element2);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      bubbleMenuElement = $$value;
      $$invalidate(4, bubbleMenuElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(7, content = $$props2.content);
    if ("statePath" in $$props2)
      $$invalidate(8, statePath = $$props2.statePath);
    if ("placeholder" in $$props2)
      $$invalidate(9, placeholder = $$props2.placeholder);
    if ("bubbleTools" in $$props2)
      $$invalidate(0, bubbleTools = $$props2.bubbleTools);
    if ("suggestionTools" in $$props2)
      $$invalidate(10, suggestionTools = $$props2.suggestionTools);
    if ("toolbarTools" in $$props2)
      $$invalidate(1, toolbarTools = $$props2.toolbarTools);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*editor*/
    4) {
      $:
        $$invalidate(5, isActive2 = (name, attrs = {}) => editor.isActive(name, attrs));
    }
  };
  return [
    bubbleTools,
    toolbarTools,
    editor,
    element2,
    bubbleMenuElement,
    isActive2,
    handleToolClick,
    content,
    statePath,
    placeholder,
    suggestionTools,
    div0_binding,
    div1_binding
  ];
}
var Scribble = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment13, safe_not_equal, {
      content: 7,
      statePath: 8,
      placeholder: 9,
      bubbleTools: 0,
      suggestionTools: 10,
      toolbarTools: 1
    });
  }
};
var Scribble_default = Scribble;

// resources/js/index.js
function scribble(bubbleTools, suggestionTools, toolbarTools, state, statePath, placeholder) {
  return {
    bubbleTools,
    suggestionTools,
    toolbarTools,
    state,
    statePath,
    placeholder: placeholder ?? "press '/' for blocks",
    fullscreen: false,
    init() {
      const _this = this;
      new Scribble_default({
        target: _this.$root,
        props: {
          bubbleTools: _this.bubbleTools,
          suggestionTools: _this.suggestionTools,
          toolbarTools: _this.toolbarTools,
          content: _this.state,
          statePath: _this.statePath,
          placeholder: _this.placeholder
        }
      });
      window.addEventListener("updatedEditor", (e) => {
        if (e.detail.statePath === _this.statePath) {
          _this.state = e.detail.content;
        }
      });
    },
    toggleFullscreen(event) {
      if (event.detail.statePath !== this.statePath)
        return;
      this.fullscreen = !this.fullscreen;
    }
  };
}
export {
  scribble as default
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC91dGlscy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2dsb2JhbHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9SZXNpemVPYnNlcnZlclNpbmdsZXRvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2RvbS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2xpZmVjeWNsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3NjaGVkdWxlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3RyYW5zaXRpb25zLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZWFjaC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3NwcmVhZC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9zaGFyZWQvYm9vbGVhbl9hdHRyaWJ1dGVzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvQ29tcG9uZW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3NoYXJlZC92ZXJzaW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZGlzY2xvc2UtdmVyc2lvbi9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb3JkZXJlZG1hcC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1tb2RlbC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci10cmFuc2Zvcm0vZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itc3RhdGUvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itdmlldy9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy93M2Mta2V5bmFtZS9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Ita2V5bWFwL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWNvbW1hbmRzL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXNjaGVtYS1saXN0L2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9jcmVhdGVDaGFpbmFibGVTdGF0ZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9Db21tYW5kTWFuYWdlci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9FdmVudEVtaXR0ZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL3NwbGl0RXh0ZW5zaW9ucy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE5vZGVUeXBlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9tZXJnZUF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRSZW5kZXJlZEF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzRnVuY3Rpb24udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2NhbGxPclJldHVybi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNFbXB0eU9iamVjdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvZnJvbVN0cmluZy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2luamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZUJ5TmFtZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzRXh0ZW5zaW9uUnVsZXNFbmFibGVkLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzUmVnRXhwLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL0lucHV0UnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNOdW1iZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvUGFzdGVSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9maW5kRHVwbGljYXRlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9FeHRlbnNpb25NYW5hZ2VyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc1BsYWluT2JqZWN0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9tZXJnZURlZXAudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvRXh0ZW5zaW9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0VGV4dEJldHdlZW4udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2V4dGVuc2lvbnMvY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvYmx1ci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9jbGVhckNvbnRlbnQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvY2xlYXJOb2Rlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9jb21tYW5kLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2NyZWF0ZVBhcmFncmFwaE5lYXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvY3V0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2RlbGV0ZUN1cnJlbnROb2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2RlbGV0ZU5vZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZGVsZXRlUmFuZ2UudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZGVsZXRlU2VsZWN0aW9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2VudGVyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2V4aXRDb2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9vYmplY3RJbmNsdWRlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE1hcmtSYW5nZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE1hcmtUeXBlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2V4dGVuZE1hcmtSYW5nZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9maXJzdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzVGV4dFNlbGVjdGlvbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvbWluTWF4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvcmVzb2x2ZUZvY3VzUG9zaXRpb24udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzaU9TLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2ZvY3VzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2ZvckVhY2gudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvaW5zZXJ0Q29udGVudC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvZWxlbWVudEZyb21TdHJpbmcudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9jcmVhdGVOb2RlRnJvbUNvbnRlbnQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9zZWxlY3Rpb25Ub0luc2VydGlvbkVuZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9pbnNlcnRDb250ZW50QXQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvam9pbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9qb2luSXRlbUJhY2t3YXJkLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2pvaW5JdGVtRm9yd2FyZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9qb2luVGV4dGJsb2NrQmFja3dhcmQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvam9pblRleHRibG9ja0ZvcndhcmQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzTWFjT1MudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMva2V5Ym9hcmRTaG9ydGN1dC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzTm9kZUFjdGl2ZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9saWZ0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2xpZnRFbXB0eUJsb2NrLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2xpZnRMaXN0SXRlbS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9uZXdsaW5lSW5Db2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2RlbGV0ZVByb3BzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3Jlc2V0QXR0cmlidXRlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zY3JvbGxJbnRvVmlldy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZWxlY3RBbGwudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2VsZWN0Tm9kZUJhY2t3YXJkLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdE5vZGVGb3J3YXJkLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdFBhcmVudE5vZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2VsZWN0VGV4dGJsb2NrRW5kLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdFRleHRibG9ja1N0YXJ0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY3JlYXRlRG9jdW1lbnQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0Q29udGVudC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE1hcmtBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY29tYmluZVRyYW5zYWN0aW9uU3RlcHMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9kZWZhdWx0QmxvY2tBdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRDaGlsZHJlbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRDaGlsZHJlbkluUmFuZ2UudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9maW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1Bvcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRQYXJlbnROb2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0SFRNTEZyb21GcmFnbWVudC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNjaGVtYS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dlbmVyYXRlSFRNTC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dlbmVyYXRlSlNPTi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZW5lcmF0ZVRleHQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXROb2RlQXR0cmlidXRlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldEF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL3JlbW92ZUR1cGxpY2F0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRDaGFuZ2VkUmFuZ2VzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0RGVidWdKU09OLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0TWFya3NCZXR3ZWVuLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0Tm9kZUF0UG9zaXRpb24udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRTcGxpdHRlZEF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc01hcmtBY3RpdmUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0FjdGl2ZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzQXRFbmRPZk5vZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0F0U3RhcnRPZk5vZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0xpc3QudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc05vZGVFbXB0eS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzTm9kZVNlbGVjdGlvbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL3Bvc1RvRE9NUmVjdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXRNYXJrLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldE1ldGEudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0Tm9kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXROb2RlU2VsZWN0aW9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldFRleHRTZWxlY3Rpb24udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2lua0xpc3RJdGVtLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NwbGl0QmxvY2sudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc3BsaXRMaXN0SXRlbS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy90b2dnbGVMaXN0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3RvZ2dsZU1hcmsudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdG9nZ2xlTm9kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy90b2dnbGVXcmFwLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3VuZG9JbnB1dFJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdW5zZXRBbGxNYXJrcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy91bnNldE1hcmsudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdXBkYXRlQXR0cmlidXRlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy93cmFwSW4udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvd3JhcEluTGlzdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2NvbW1hbmRzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2V4dGVuc2lvbnMvZWRpdGFibGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvZXh0ZW5zaW9ucy9mb2N1c0V2ZW50cy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2tleW1hcC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL3RhYmluZGV4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL05vZGVQb3MudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvc3R5bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2NyZWF0ZVN0eWxlVGFnLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL0VkaXRvci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9pbnB1dFJ1bGVzL21hcmtJbnB1dFJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaW5wdXRSdWxlcy9ub2RlSW5wdXRSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2lucHV0UnVsZXMvdGV4dGJsb2NrVHlwZUlucHV0UnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9pbnB1dFJ1bGVzL3RleHRJbnB1dFJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaW5wdXRSdWxlcy93cmFwcGluZ0lucHV0UnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9NYXJrLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL05vZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzQW5kcm9pZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9Ob2RlVmlldy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9wYXN0ZVJ1bGVzL21hcmtQYXN0ZVJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2VzY2FwZUZvclJlZ0V4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc1N0cmluZy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9wYXN0ZVJ1bGVzL25vZGVQYXN0ZVJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvcGFzdGVSdWxlcy90ZXh0UGFzdGVSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL1RyYWNrZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlTmFtZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcHBseVN0eWxlcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tYXRoLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdXNlckFnZW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzTGF5b3V0Vmlld3BvcnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvY29udGFpbnMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0UGFyZW50Tm9kZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy93aXRoaW4uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9leHBhbmRUb0hhc2hNYXAuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXJyb3cuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRWYXJpYXRpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2hpZGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRBbHRBeGlzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRIVE1MRWxlbWVudFNjcm9sbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9vcmRlck1vZGlmaWVycy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9jcmVhdGVQb3BwZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy9jb25zdGFudHMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy91dGlscy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL2RvbS11dGlscy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL2JpbmRHbG9iYWxFdmVudExpc3RlbmVycy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL2Jyb3dzZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy92YWxpZGF0aW9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvcHJvcHMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy90ZW1wbGF0ZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL2NyZWF0ZVRpcHB5LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvaW5kZXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy9hZGRvbnMvY3JlYXRlU2luZ2xldG9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvYWRkb25zL2RlbGVnYXRlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvcGx1Z2lucy9hbmltYXRlRmlsbC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL3BsdWdpbnMvZm9sbG93Q3Vyc29yLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvcGx1Z2lucy9pbmxpbmVQb3NpdGlvbmluZy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL3BsdWdpbnMvc3RpY2t5LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9idWlsZC9iYXNlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1idWJibGUtbWVudS9zcmMvYnViYmxlLW1lbnUtcGx1Z2luLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1idWJibGUtbWVudS9zcmMvYnViYmxlLW1lbnUudHMiLCAiLi4vanMvZXh0ZW5zaW9ucy9DbGFzc0V4dGVuc2lvbi5qcyIsICIuLi9qcy9leHRlbnNpb25zL0NvbW1hbmRzRXh0ZW5zaW9uLmpzIiwgIi4uL2pzL2V4dGVuc2lvbnMvR3JpZC91dGlscy9jcmVhdGVDb2x1bW4uanMiLCAiLi4vanMvZXh0ZW5zaW9ucy9HcmlkL3V0aWxzL2dldEdyaWROb2RlVHlwZXMuanMiLCAiLi4vanMvZXh0ZW5zaW9ucy9HcmlkL3V0aWxzL2NyZWF0ZUdyaWQuanMiLCAiLi4vanMvZXh0ZW5zaW9ucy9HcmlkL0dyaWQuanMiLCAiLi4vanMvZXh0ZW5zaW9ucy9HcmlkL0dyaWRDb2x1bW4uanMiLCAiLi4vanMvZXh0ZW5zaW9ucy9JZEV4dGVuc2lvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGlua2lmeWpzL2Rpc3QvbGlua2lmeS5lcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9zcmMvaGVscGVycy9hdXRvbGluay50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9zcmMvaGVscGVycy9jbGlja0hhbmRsZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpbmsvc3JjL2hlbHBlcnMvcGFzdGVIYW5kbGVyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saW5rL3NyYy9saW5rLnRzIiwgIi4uL2pzL2V4dGVuc2lvbnMvTGlua0V4dGVuc2lvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taW1hZ2Uvc3JjL2ltYWdlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvc3RvcmUvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS10aXB0YXAvZGlzdC9TdmVsdGVSZW5kZXJlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXRpcHRhcC9kaXN0L2NvbnRleHQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS10aXB0YXAvZGlzdC9TdmVsdGVOb2RlVmlld1JlbmRlcmVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtdGlwdGFwL2Rpc3QvTm9kZVZpZXdXcmFwcGVyLnN2ZWx0ZSIsICIuLi9qcy91dGlscy5qcyIsICIuLi9qcy9zdG9yZXMuanMiLCAiLi4vanMvY29tcG9uZW50cy9CbG9ja0FjdGlvbnMuc3ZlbHRlIiwgIi4uL2pzL2NvbXBvbmVudHMvRHJhZ0hhbmRsZS5zdmVsdGUiLCAiLi4vanMvY29tcG9uZW50cy9CbG9ja1NldHRpbmdzLnN2ZWx0ZSIsICIuLi9qcy9jb21wb25lbnRzL1JlbW92ZUJsb2NrLnN2ZWx0ZSIsICIuLi9qcy9jb21wb25lbnRzL01lZGlhVmlldy5zdmVsdGUiLCAiLi4vanMvZXh0ZW5zaW9ucy9NZWRpYUV4dGVuc2lvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGxhY2Vob2xkZXIvc3JjL3BsYWNlaG9sZGVyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ibG9ja3F1b3RlL3NyYy9ibG9ja3F1b3RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ib2xkL3NyYy9ib2xkLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saXN0LWl0ZW0vc3JjL2xpc3QtaXRlbS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC1zdHlsZS9zcmMvdGV4dC1zdHlsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnVsbGV0LWxpc3Qvc3JjL2J1bGxldC1saXN0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2RlL3NyYy9jb2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2RlLWJsb2NrL3NyYy9jb2RlLWJsb2NrLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1kb2N1bWVudC9zcmMvZG9jdW1lbnQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWRyb3BjdXJzb3IvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZHJvcGN1cnNvci9zcmMvZHJvcGN1cnNvci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItZ2FwY3Vyc29yL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWdhcGN1cnNvci9zcmMvZ2FwY3Vyc29yLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oYXJkLWJyZWFrL3NyYy9oYXJkLWJyZWFrLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oZWFkaW5nL3NyYy9oZWFkaW5nLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9yb3BlLXNlcXVlbmNlL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWhpc3RvcnkvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGlzdG9yeS9zcmMvaGlzdG9yeS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlL3NyYy9ob3Jpem9udGFsLXJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWl0YWxpYy9zcmMvaXRhbGljLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saXN0LWl0ZW0vc3JjL2xpc3QtaXRlbS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC1pdGVtL3NyYy9saXN0LWl0ZW0udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXRleHQtc3R5bGUvc3JjL3RleHQtc3R5bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLW9yZGVyZWQtbGlzdC9zcmMvb3JkZXJlZC1saXN0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1wYXJhZ3JhcGgvc3JjL3BhcmFncmFwaC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlL3NyYy9zdHJpa2UudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXRleHQvc3JjL3RleHQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvc3RhcnRlci1raXQvc3JjL3N0YXJ0ZXIta2l0LnRzIiwgIi4uL2pzL2NvbXBvbmVudHMvU2NyaWJibGVCbG9jay5zdmVsdGUiLCAiLi4vanMvZXh0ZW5zaW9ucy9TY3JpYmJsZUJsb2NrLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3N1Z2dlc3Rpb24vc3JjL2ZpbmRTdWdnZXN0aW9uTWF0Y2gudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvc3VnZ2VzdGlvbi9zcmMvc3VnZ2VzdGlvbi50cyIsICIuLi9qcy9jb21wb25lbnRzL0NvbW1hbmRzTGlzdC5zdmVsdGUiLCAiLi4vanMvZXh0ZW5zaW9ucy9TbGFzaEV4dGVuc2lvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tc3Vic2NyaXB0L3NyYy9zdWJzY3JpcHQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXN1cGVyc2NyaXB0L3NyYy9zdXBlcnNjcmlwdC50cyIsICIuLi9qcy9leHRlbnNpb25zL1RleHRBbGlnbkV4dGVuc2lvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC1zdHlsZS9zcmMvdGV4dC1zdHlsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lL3NyYy91bmRlcmxpbmUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm1qcyIsICIuLi9qcy9jb21wb25lbnRzL0J1dHRvbi5zdmVsdGUiLCAiLi4vanMvY29tcG9uZW50cy9Db250cm9scy5zdmVsdGUiLCAiLi4vanMvY29tcG9uZW50cy9CdWJibGVNZW51LnN2ZWx0ZSIsICIuLi9qcy9jb21wb25lbnRzL1Rvb2xiYXIuc3ZlbHRlIiwgIi4uL2pzL1NjcmliYmxlLnN2ZWx0ZSIsICIuLi9qcy9pbmRleC5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5leHBvcnQgY29uc3QgaWRlbnRpdHkgPSAoeCkgPT4geDtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIFNcbiAqIEBwYXJhbSB7VH0gdGFyXG4gKiBAcGFyYW0ge1N9IHNyY1xuICogQHJldHVybnMge1QgJiBTfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhciwgc3JjKSB7XG5cdC8vIEB0cy1pZ25vcmVcblx0Zm9yIChjb25zdCBrIGluIHNyYykgdGFyW2tdID0gc3JjW2tdO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtUICYgU30gKi8gKHRhcik7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL0xJQ0VOU0Vcbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgUHJvbWlzZUxpa2U8YW55Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3Byb21pc2UodmFsdWUpIHtcblx0cmV0dXJuIChcblx0XHQhIXZhbHVlICYmXG5cdFx0KHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSAmJlxuXHRcdHR5cGVvZiAoLyoqIEB0eXBlIHthbnl9ICovICh2YWx1ZSkudGhlbikgPT09ICdmdW5jdGlvbidcblx0KTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9sb2NhdGlvbihlbGVtZW50LCBmaWxlLCBsaW5lLCBjb2x1bW4sIGNoYXIpIHtcblx0ZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuXHRcdGxvYzogeyBmaWxlLCBsaW5lLCBjb2x1bW4sIGNoYXIgfVxuXHR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVuKGZuKSB7XG5cdHJldHVybiBmbigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmxhbmtfb2JqZWN0KCkge1xuXHRyZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW119IGZuc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5fYWxsKGZucykge1xuXHRmbnMuZm9yRWFjaChydW4pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB0aGluZ1xuICogQHJldHVybnMge3RoaW5nIGlzIEZ1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfZnVuY3Rpb24odGhpbmcpIHtcblx0cmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqIEByZXR1cm5zIHtib29sZWFufSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhZmVfbm90X2VxdWFsKGEsIGIpIHtcblx0cmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGIgfHwgKGEgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB8fCB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxubGV0IHNyY191cmxfZXF1YWxfYW5jaG9yO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50X3NyY1xuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcmNfdXJsX2VxdWFsKGVsZW1lbnRfc3JjLCB1cmwpIHtcblx0aWYgKGVsZW1lbnRfc3JjID09PSB1cmwpIHJldHVybiB0cnVlO1xuXHRpZiAoIXNyY191cmxfZXF1YWxfYW5jaG9yKSB7XG5cdFx0c3JjX3VybF9lcXVhbF9hbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdH1cblx0Ly8gVGhpcyBpcyBhY3R1YWxseSBmYXN0ZXIgdGhhbiBkb2luZyBVUkwoLi4pLmhyZWZcblx0c3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZiA9IHVybDtcblx0cmV0dXJuIGVsZW1lbnRfc3JjID09PSBzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmO1xufVxuXG4vKiogQHBhcmFtIHtzdHJpbmd9IHNyY3NldCAqL1xuZnVuY3Rpb24gc3BsaXRfc3Jjc2V0KHNyY3NldCkge1xuXHRyZXR1cm4gc3Jjc2V0LnNwbGl0KCcsJykubWFwKChzcmMpID0+IHNyYy50cmltKCkuc3BsaXQoJyAnKS5maWx0ZXIoQm9vbGVhbikpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFNvdXJjZUVsZW1lbnQgfCBIVE1MSW1hZ2VFbGVtZW50fSBlbGVtZW50X3NyY3NldFxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBzcmNzZXRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3Jjc2V0X3VybF9lcXVhbChlbGVtZW50X3NyY3NldCwgc3Jjc2V0KSB7XG5cdGNvbnN0IGVsZW1lbnRfdXJscyA9IHNwbGl0X3NyY3NldChlbGVtZW50X3NyY3NldC5zcmNzZXQpO1xuXHRjb25zdCB1cmxzID0gc3BsaXRfc3Jjc2V0KHNyY3NldCB8fCAnJyk7XG5cblx0cmV0dXJuIChcblx0XHR1cmxzLmxlbmd0aCA9PT0gZWxlbWVudF91cmxzLmxlbmd0aCAmJlxuXHRcdHVybHMuZXZlcnkoXG5cdFx0XHQoW3VybCwgd2lkdGhdLCBpKSA9PlxuXHRcdFx0XHR3aWR0aCA9PT0gZWxlbWVudF91cmxzW2ldWzFdICYmXG5cdFx0XHRcdC8vIFdlIG5lZWQgdG8gdGVzdCBib3RoIHdheXMgYmVjYXVzZSBWaXRlIHdpbGwgY3JlYXRlIGFuIGEgZnVsbCBVUkwgd2l0aFxuXHRcdFx0XHQvLyBgbmV3IFVSTChhc3NldCwgaW1wb3J0Lm1ldGEudXJsKS5ocmVmYCBmb3IgdGhlIGNsaWVudCB3aGVuIGBiYXNlOiAnLi8nYCwgYW5kIHRoZVxuXHRcdFx0XHQvLyByZWxhdGl2ZSBVUkxzIGluc2lkZSBzcmNzZXQgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IHJlc29sdmVkIHRvIGFic29sdXRlIFVSTHMgYnlcblx0XHRcdFx0Ly8gYnJvd3NlcnMgKGluIGNvbnRyYXN0IHRvIGltZy5zcmMpLiBUaGlzIG1lYW5zIGJvdGggU1NSIGFuZCBET00gY29kZSBjb3VsZFxuXHRcdFx0XHQvLyBjb250YWluIHJlbGF0aXZlIG9yIGFic29sdXRlIFVSTHMuXG5cdFx0XHRcdChzcmNfdXJsX2VxdWFsKGVsZW1lbnRfdXJsc1tpXVswXSwgdXJsKSB8fCBzcmNfdXJsX2VxdWFsKHVybCwgZWxlbWVudF91cmxzW2ldWzBdKSlcblx0XHQpXG5cdCk7XG59XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3RfZXF1YWwoYSwgYikge1xuXHRyZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYjtcbn1cblxuLyoqIEByZXR1cm5zIHtib29sZWFufSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2VtcHR5KG9iaikge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZV9zdG9yZShzdG9yZSwgbmFtZSkge1xuXHRpZiAoc3RvcmUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RvcmUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGAnJHtuYW1lfScgaXMgbm90IGEgc3RvcmUgd2l0aCBhICdzdWJzY3JpYmUnIG1ldGhvZGApO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJzY3JpYmUoc3RvcmUsIC4uLmNhbGxiYWNrcykge1xuXHRpZiAoc3RvcmUgPT0gbnVsbCkge1xuXHRcdGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XG5cdFx0XHRjYWxsYmFjayh1bmRlZmluZWQpO1xuXHRcdH1cblx0XHRyZXR1cm4gbm9vcDtcblx0fVxuXHRjb25zdCB1bnN1YiA9IHN0b3JlLnN1YnNjcmliZSguLi5jYWxsYmFja3MpO1xuXHRyZXR1cm4gdW5zdWIudW5zdWJzY3JpYmUgPyAoKSA9PiB1bnN1Yi51bnN1YnNjcmliZSgpIDogdW5zdWI7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIGZyb20gYSBzdG9yZSBieSBzdWJzY3JpYmluZyBhbmQgaW1tZWRpYXRlbHkgdW5zdWJzY3JpYmluZy5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjZ2V0XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3N0b3JlL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fSBzdG9yZVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfc3RvcmVfdmFsdWUoc3RvcmUpIHtcblx0bGV0IHZhbHVlO1xuXHRzdWJzY3JpYmUoc3RvcmUsIChfKSA9PiAodmFsdWUgPSBfKSkoKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50X3N1YnNjcmliZShjb21wb25lbnQsIHN0b3JlLCBjYWxsYmFjaykge1xuXHRjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKHN1YnNjcmliZShzdG9yZSwgY2FsbGJhY2spKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9zbG90KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcblx0aWYgKGRlZmluaXRpb24pIHtcblx0XHRjb25zdCBzbG90X2N0eCA9IGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbik7XG5cdFx0cmV0dXJuIGRlZmluaXRpb25bMF0oc2xvdF9jdHgpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuXHRyZXR1cm4gZGVmaW5pdGlvblsxXSAmJiBmbiA/IGFzc2lnbigkJHNjb3BlLmN0eC5zbGljZSgpLCBkZWZpbml0aW9uWzFdKGZuKGN0eCkpKSA6ICQkc2NvcGUuY3R4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3Nsb3RfY2hhbmdlcyhkZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZm4pIHtcblx0aWYgKGRlZmluaXRpb25bMl0gJiYgZm4pIHtcblx0XHRjb25zdCBsZXRzID0gZGVmaW5pdGlvblsyXShmbihkaXJ0eSkpO1xuXHRcdGlmICgkJHNjb3BlLmRpcnR5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBsZXRzO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIGxldHMgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRjb25zdCBtZXJnZWQgPSBbXTtcblx0XHRcdGNvbnN0IGxlbiA9IE1hdGgubWF4KCQkc2NvcGUuZGlydHkubGVuZ3RoLCBsZXRzLmxlbmd0aCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG5cdFx0XHRcdG1lcmdlZFtpXSA9ICQkc2NvcGUuZGlydHlbaV0gfCBsZXRzW2ldO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1lcmdlZDtcblx0XHR9XG5cdFx0cmV0dXJuICQkc2NvcGUuZGlydHkgfCBsZXRzO1xuXHR9XG5cdHJldHVybiAkJHNjb3BlLmRpcnR5O1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3Nsb3RfYmFzZShcblx0c2xvdCxcblx0c2xvdF9kZWZpbml0aW9uLFxuXHRjdHgsXG5cdCQkc2NvcGUsXG5cdHNsb3RfY2hhbmdlcyxcblx0Z2V0X3Nsb3RfY29udGV4dF9mblxuKSB7XG5cdGlmIChzbG90X2NoYW5nZXMpIHtcblx0XHRjb25zdCBzbG90X2NvbnRleHQgPSBnZXRfc2xvdF9jb250ZXh0KHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcblx0XHRzbG90LnAoc2xvdF9jb250ZXh0LCBzbG90X2NoYW5nZXMpO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfc2xvdChcblx0c2xvdCxcblx0c2xvdF9kZWZpbml0aW9uLFxuXHRjdHgsXG5cdCQkc2NvcGUsXG5cdGRpcnR5LFxuXHRnZXRfc2xvdF9jaGFuZ2VzX2ZuLFxuXHRnZXRfc2xvdF9jb250ZXh0X2ZuXG4pIHtcblx0Y29uc3Qgc2xvdF9jaGFuZ2VzID0gZ2V0X3Nsb3RfY2hhbmdlcyhzbG90X2RlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBnZXRfc2xvdF9jaGFuZ2VzX2ZuKTtcblx0dXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbn1cblxuLyoqIEByZXR1cm5zIHthbnlbXSB8IC0xfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSgkJHNjb3BlKSB7XG5cdGlmICgkJHNjb3BlLmN0eC5sZW5ndGggPiAzMikge1xuXHRcdGNvbnN0IGRpcnR5ID0gW107XG5cdFx0Y29uc3QgbGVuZ3RoID0gJCRzY29wZS5jdHgubGVuZ3RoIC8gMzI7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0ZGlydHlbaV0gPSAtMTtcblx0XHR9XG5cdFx0cmV0dXJuIGRpcnR5O1xuXHR9XG5cdHJldHVybiAtMTtcbn1cblxuLyoqIEByZXR1cm5zIHt7fX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGNsdWRlX2ludGVybmFsX3Byb3BzKHByb3BzKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRmb3IgKGNvbnN0IGsgaW4gcHJvcHMpIGlmIChrWzBdICE9PSAnJCcpIHJlc3VsdFtrXSA9IHByb3BzW2tdO1xuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogQHJldHVybnMge3t9fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVfcmVzdF9wcm9wcyhwcm9wcywga2V5cykge1xuXHRjb25zdCByZXN0ID0ge307XG5cdGtleXMgPSBuZXcgU2V0KGtleXMpO1xuXHRmb3IgKGNvbnN0IGsgaW4gcHJvcHMpIGlmICgha2V5cy5oYXMoaykgJiYga1swXSAhPT0gJyQnKSByZXN0W2tdID0gcHJvcHNba107XG5cdHJldHVybiByZXN0O1xufVxuXG4vKiogQHJldHVybnMge3t9fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVfc2xvdHMoc2xvdHMpIHtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG5cdFx0cmVzdWx0W2tleV0gPSB0cnVlO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBAcmV0dXJucyB7KHRoaXM6IGFueSwgLi4uYXJnczogYW55W10pID0+IHZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gb25jZShmbikge1xuXHRsZXQgcmFuID0gZmFsc2U7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdGlmIChyYW4pIHJldHVybjtcblx0XHRyYW4gPSB0cnVlO1xuXHRcdGZuLmNhbGwodGhpcywgLi4uYXJncyk7XG5cdH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBudWxsX3RvX2VtcHR5KHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldF9zdG9yZV92YWx1ZShzdG9yZSwgcmV0LCB2YWx1ZSkge1xuXHRzdG9yZS5zZXQodmFsdWUpO1xuXHRyZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgY29uc3QgaGFzX3Byb3AgPSAob2JqLCBwcm9wKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFjdGlvbl9kZXN0cm95ZXIoYWN0aW9uX3Jlc3VsdCkge1xuXHRyZXR1cm4gYWN0aW9uX3Jlc3VsdCAmJiBpc19mdW5jdGlvbihhY3Rpb25fcmVzdWx0LmRlc3Ryb3kpID8gYWN0aW9uX3Jlc3VsdC5kZXN0cm95IDogbm9vcDtcbn1cblxuLyoqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge1tudW1iZXIsIHN0cmluZ119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdF9jc3NfdW5pdCh2YWx1ZSkge1xuXHRjb25zdCBzcGxpdCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubWF0Y2goL15cXHMqKC0/W1xcZC5dKykoW15cXHNdKilcXHMqJC8pO1xuXHRyZXR1cm4gc3BsaXQgPyBbcGFyc2VGbG9hdChzcGxpdFsxXSksIHNwbGl0WzJdIHx8ICdweCddIDogWy8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodmFsdWUpLCAncHgnXTtcbn1cblxuZXhwb3J0IGNvbnN0IGNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzID0gWycnLCB0cnVlLCAxLCAndHJ1ZScsICdjb250ZW50ZWRpdGFibGUnXTtcbiIsICIvKiogQHR5cGUge3R5cGVvZiBnbG9iYWxUaGlzfSAqL1xuZXhwb3J0IGNvbnN0IGdsb2JhbHMgPVxuXHR0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuXHRcdD8gd2luZG93XG5cdFx0OiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcblx0XHQ/IGdsb2JhbFRoaXNcblx0XHQ6IC8vIEB0cy1pZ25vcmUgTm9kZSB0eXBpbmdzIGhhdmUgdGhpc1xuXHRcdCAgZ2xvYmFsO1xuIiwgImltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuL2dsb2JhbHMuanMnO1xuXG4vKipcbiAqIFJlc2l6ZSBvYnNlcnZlciBzaW5nbGV0b24uXG4gKiBPbmUgbGlzdGVuZXIgcGVyIGVsZW1lbnQgb25seSFcbiAqIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZy9ibGluay1kZXYvYy96Nmllbk9OVWI1QS9tL0Y1LVZjVVp0QkFBSlxuICovXG5leHBvcnQgY2xhc3MgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24ge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHJlYWRvbmx5XG5cdCAqIEB0eXBlIHtXZWFrTWFwPEVsZW1lbnQsIGltcG9ydCgnLi9wcml2YXRlLmpzJykuTGlzdGVuZXI+fVxuXHQgKi9cblx0X2xpc3RlbmVycyA9ICdXZWFrTWFwJyBpbiBnbG9iYWxzID8gbmV3IFdlYWtNYXAoKSA6IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHR5cGUge1Jlc2l6ZU9ic2VydmVyfVxuXHQgKi9cblx0X29ic2VydmVyID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7UmVzaXplT2JzZXJ2ZXJPcHRpb25zfSAqL1xuXHRvcHRpb25zO1xuXG5cdC8qKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyT3B0aW9uc30gb3B0aW9ucyAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcblx0ICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkxpc3RlbmVyfSBsaXN0ZW5lclxuXHQgKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cblx0ICovXG5cdG9ic2VydmUoZWxlbWVudCwgbGlzdGVuZXIpIHtcblx0XHR0aGlzLl9saXN0ZW5lcnMuc2V0KGVsZW1lbnQsIGxpc3RlbmVyKTtcblx0XHR0aGlzLl9nZXRPYnNlcnZlcigpLm9ic2VydmUoZWxlbWVudCwgdGhpcy5vcHRpb25zKTtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0dGhpcy5fbGlzdGVuZXJzLmRlbGV0ZShlbGVtZW50KTtcblx0XHRcdHRoaXMuX29ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTsgLy8gdGhpcyBsaW5lIGNhbiBwcm9iYWJseSBiZSByZW1vdmVkXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldE9ic2VydmVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLl9vYnNlcnZlciA/P1xuXHRcdFx0KHRoaXMuX29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG5cdFx0XHRcdGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuXHRcdFx0XHRcdFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmVudHJpZXMuc2V0KGVudHJ5LnRhcmdldCwgZW50cnkpO1xuXHRcdFx0XHRcdHRoaXMuX2xpc3RlbmVycy5nZXQoZW50cnkudGFyZ2V0KT8uKGVudHJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSkpXG5cdFx0KTtcblx0fVxufVxuXG4vLyBOZWVkcyB0byBiZSB3cml0dGVuIGxpa2UgdGhpcyB0byBwYXNzIHRoZSB0cmVlLXNoYWtlLXRlc3RcblJlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmVudHJpZXMgPSAnV2Vha01hcCcgaW4gZ2xvYmFscyA/IG5ldyBXZWFrTWFwKCkgOiB1bmRlZmluZWQ7XG4iLCAiaW1wb3J0IHsgY29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMsIGhhc19wcm9wIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmltcG9ydCB7IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZlclNpbmdsZXRvbi5qcyc7XG5cbi8vIFRyYWNrIHdoaWNoIG5vZGVzIGFyZSBjbGFpbWVkIGR1cmluZyBoeWRyYXRpb24uIFVuY2xhaW1lZCBub2RlcyBjYW4gdGhlbiBiZSByZW1vdmVkIGZyb20gdGhlIERPTVxuLy8gYXQgdGhlIGVuZCBvZiBoeWRyYXRpb24gd2l0aG91dCB0b3VjaGluZyB0aGUgcmVtYWluaW5nIG5vZGVzLlxubGV0IGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRfaHlkcmF0aW5nKCkge1xuXHRpc19oeWRyYXRpbmcgPSB0cnVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5kX2h5ZHJhdGluZygpIHtcblx0aXNfaHlkcmF0aW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGxvd1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hcbiAqIEBwYXJhbSB7KGluZGV4OiBudW1iZXIpID0+IG51bWJlcn0ga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHVwcGVyX2JvdW5kKGxvdywgaGlnaCwga2V5LCB2YWx1ZSkge1xuXHQvLyBSZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUgbGFyZ2VyIHRoYW4gaW5wdXQgdmFsdWUgaW4gdGhlIHJhbmdlIFtsb3csIGhpZ2gpXG5cdHdoaWxlIChsb3cgPCBoaWdoKSB7XG5cdFx0Y29uc3QgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSA+PiAxKTtcblx0XHRpZiAoa2V5KG1pZCkgPD0gdmFsdWUpIHtcblx0XHRcdGxvdyA9IG1pZCArIDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhpZ2ggPSBtaWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBsb3c7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlRXh9IHRhcmdldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGluaXRfaHlkcmF0ZSh0YXJnZXQpIHtcblx0aWYgKHRhcmdldC5oeWRyYXRlX2luaXQpIHJldHVybjtcblx0dGFyZ2V0Lmh5ZHJhdGVfaW5pdCA9IHRydWU7XG5cdC8vIFdlIGtub3cgdGhhdCBhbGwgY2hpbGRyZW4gaGF2ZSBjbGFpbV9vcmRlciB2YWx1ZXMgc2luY2UgdGhlIHVuY2xhaW1lZCBoYXZlIGJlZW4gZGV0YWNoZWQgaWYgdGFyZ2V0IGlzIG5vdCA8aGVhZD5cblxuXHRsZXQgY2hpbGRyZW4gPSAvKiogQHR5cGUge0FycmF5TGlrZTxOb2RlRXgyPn0gKi8gKHRhcmdldC5jaGlsZE5vZGVzKTtcblx0Ly8gSWYgdGFyZ2V0IGlzIDxoZWFkPiwgdGhlcmUgbWF5IGJlIGNoaWxkcmVuIHdpdGhvdXQgY2xhaW1fb3JkZXJcblx0aWYgKHRhcmdldC5ub2RlTmFtZSA9PT0gJ0hFQUQnKSB7XG5cdFx0Y29uc3QgbXlfY2hpbGRyZW4gPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBub2RlID0gY2hpbGRyZW5baV07XG5cdFx0XHRpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG15X2NoaWxkcmVuLnB1c2gobm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNoaWxkcmVuID0gbXlfY2hpbGRyZW47XG5cdH1cblx0Lypcblx0ICogUmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseS5cblx0ICogV2UgY2FuIHJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkgYnkgZmluZGluZyB0aGUgbG9uZ2VzdCBzdWJzZXF1ZW5jZSBvZlxuXHQgKiBub2RlcyB0aGF0IGFyZSBhbHJlYWR5IGNsYWltZWQgaW4gb3JkZXIgYW5kIG9ubHkgbW92aW5nIHRoZSByZXN0LiBUaGUgbG9uZ2VzdFxuXHQgKiBzdWJzZXF1ZW5jZSBvZiBub2RlcyB0aGF0IGFyZSBjbGFpbWVkIGluIG9yZGVyIGNhbiBiZSBmb3VuZCBieVxuXHQgKiBjb21wdXRpbmcgdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiAuY2xhaW1fb3JkZXIgdmFsdWVzLlxuXHQgKlxuXHQgKiBUaGlzIGFsZ29yaXRobSBpcyBvcHRpbWFsIGluIGdlbmVyYXRpbmcgdGhlIGxlYXN0IGFtb3VudCBvZiByZW9yZGVyIG9wZXJhdGlvbnNcblx0ICogcG9zc2libGUuXG5cdCAqXG5cdCAqIFByb29mOlxuXHQgKiBXZSBrbm93IHRoYXQsIGdpdmVuIGEgc2V0IG9mIHJlb3JkZXJpbmcgb3BlcmF0aW9ucywgdGhlIG5vZGVzIHRoYXQgZG8gbm90IG1vdmVcblx0ICogYWx3YXlzIGZvcm0gYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSwgc2luY2UgdGhleSBkbyBub3QgbW92ZSBhbW9uZyBlYWNoIG90aGVyXG5cdCAqIG1lYW5pbmcgdGhhdCB0aGV5IG11c3QgYmUgYWxyZWFkeSBvcmRlcmVkIGFtb25nIGVhY2ggb3RoZXIuIFRodXMsIHRoZSBtYXhpbWFsXG5cdCAqIHNldCBvZiBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlIGZvcm0gYSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UuXG5cdCAqL1xuXHQvLyBDb21wdXRlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuXHQvLyBtOiBzdWJzZXF1ZW5jZSBsZW5ndGggaiA9PiBpbmRleCBrIG9mIHNtYWxsZXN0IHZhbHVlIHRoYXQgZW5kcyBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGxlbmd0aCBqXG5cdGNvbnN0IG0gPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGggKyAxKTtcblx0Ly8gUHJlZGVjZXNzb3IgaW5kaWNlcyArIDFcblx0Y29uc3QgcCA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCk7XG5cdG1bMF0gPSAtMTtcblx0bGV0IGxvbmdlc3QgPSAwO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgY3VycmVudCA9IGNoaWxkcmVuW2ldLmNsYWltX29yZGVyO1xuXHRcdC8vIEZpbmQgdGhlIGxhcmdlc3Qgc3Vic2VxdWVuY2UgbGVuZ3RoIHN1Y2ggdGhhdCBpdCBlbmRzIGluIGEgdmFsdWUgbGVzcyB0aGFuIG91ciBjdXJyZW50IHZhbHVlXG5cdFx0Ly8gdXBwZXJfYm91bmQgcmV0dXJucyBmaXJzdCBncmVhdGVyIHZhbHVlLCBzbyB3ZSBzdWJ0cmFjdCBvbmVcblx0XHQvLyB3aXRoIGZhc3QgcGF0aCBmb3Igd2hlbiB3ZSBhcmUgb24gdGhlIGN1cnJlbnQgbG9uZ2VzdCBzdWJzZXF1ZW5jZVxuXHRcdGNvbnN0IHNlcV9sZW4gPVxuXHRcdFx0KGxvbmdlc3QgPiAwICYmIGNoaWxkcmVuW21bbG9uZ2VzdF1dLmNsYWltX29yZGVyIDw9IGN1cnJlbnRcblx0XHRcdFx0PyBsb25nZXN0ICsgMVxuXHRcdFx0XHQ6IHVwcGVyX2JvdW5kKDEsIGxvbmdlc3QsIChpZHgpID0+IGNoaWxkcmVuW21baWR4XV0uY2xhaW1fb3JkZXIsIGN1cnJlbnQpKSAtIDE7XG5cdFx0cFtpXSA9IG1bc2VxX2xlbl0gKyAxO1xuXHRcdGNvbnN0IG5ld19sZW4gPSBzZXFfbGVuICsgMTtcblx0XHQvLyBXZSBjYW4gZ3VhcmFudGVlIHRoYXQgY3VycmVudCBpcyB0aGUgc21hbGxlc3QgdmFsdWUuIE90aGVyd2lzZSwgd2Ugd291bGQgaGF2ZSBnZW5lcmF0ZWQgYSBsb25nZXIgc2VxdWVuY2UuXG5cdFx0bVtuZXdfbGVuXSA9IGk7XG5cdFx0bG9uZ2VzdCA9IE1hdGgubWF4KG5ld19sZW4sIGxvbmdlc3QpO1xuXHR9XG5cdC8vIFRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgKGluaXRpYWxseSByZXZlcnNlZClcblxuXHQvKipcblx0ICogQHR5cGUge05vZGVFeDJbXX1cblx0ICovXG5cdGNvbnN0IGxpcyA9IFtdO1xuXHQvLyBUaGUgcmVzdCBvZiB0aGUgbm9kZXMsIG5vZGVzIHRoYXQgd2lsbCBiZSBtb3ZlZFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7Tm9kZUV4MltdfVxuXHQgKi9cblx0Y29uc3QgdG9fbW92ZSA9IFtdO1xuXHRsZXQgbGFzdCA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG5cdGZvciAobGV0IGN1ciA9IG1bbG9uZ2VzdF0gKyAxOyBjdXIgIT0gMDsgY3VyID0gcFtjdXIgLSAxXSkge1xuXHRcdGxpcy5wdXNoKGNoaWxkcmVuW2N1ciAtIDFdKTtcblx0XHRmb3IgKDsgbGFzdCA+PSBjdXI7IGxhc3QtLSkge1xuXHRcdFx0dG9fbW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcblx0XHR9XG5cdFx0bGFzdC0tO1xuXHR9XG5cdGZvciAoOyBsYXN0ID49IDA7IGxhc3QtLSkge1xuXHRcdHRvX21vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG5cdH1cblx0bGlzLnJldmVyc2UoKTtcblx0Ly8gV2Ugc29ydCB0aGUgbm9kZXMgYmVpbmcgbW92ZWQgdG8gZ3VhcmFudGVlIHRoYXQgdGhlaXIgaW5zZXJ0aW9uIG9yZGVyIG1hdGNoZXMgdGhlIGNsYWltIG9yZGVyXG5cdHRvX21vdmUuc29ydCgoYSwgYikgPT4gYS5jbGFpbV9vcmRlciAtIGIuY2xhaW1fb3JkZXIpO1xuXHQvLyBGaW5hbGx5LCB3ZSBtb3ZlIHRoZSBub2Rlc1xuXHRmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB0b19tb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0d2hpbGUgKGogPCBsaXMubGVuZ3RoICYmIHRvX21vdmVbaV0uY2xhaW1fb3JkZXIgPj0gbGlzW2pdLmNsYWltX29yZGVyKSB7XG5cdFx0XHRqKys7XG5cdFx0fVxuXHRcdGNvbnN0IGFuY2hvciA9IGogPCBsaXMubGVuZ3RoID8gbGlzW2pdIDogbnVsbDtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRvX21vdmVbaV0sIGFuY2hvcik7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZCh0YXJnZXQsIG5vZGUpIHtcblx0dGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVfc2hlZXRfaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kX3N0eWxlcyh0YXJnZXQsIHN0eWxlX3NoZWV0X2lkLCBzdHlsZXMpIHtcblx0Y29uc3QgYXBwZW5kX3N0eWxlc190byA9IGdldF9yb290X2Zvcl9zdHlsZSh0YXJnZXQpO1xuXHRpZiAoIWFwcGVuZF9zdHlsZXNfdG8uZ2V0RWxlbWVudEJ5SWQoc3R5bGVfc2hlZXRfaWQpKSB7XG5cdFx0Y29uc3Qgc3R5bGUgPSBlbGVtZW50KCdzdHlsZScpO1xuXHRcdHN0eWxlLmlkID0gc3R5bGVfc2hlZXRfaWQ7XG5cdFx0c3R5bGUudGV4dENvbnRlbnQgPSBzdHlsZXM7XG5cdFx0YXBwZW5kX3N0eWxlc2hlZXQoYXBwZW5kX3N0eWxlc190bywgc3R5bGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7U2hhZG93Um9vdCB8IERvY3VtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpIHtcblx0aWYgKCFub2RlKSByZXR1cm4gZG9jdW1lbnQ7XG5cdGNvbnN0IHJvb3QgPSBub2RlLmdldFJvb3ROb2RlID8gbm9kZS5nZXRSb290Tm9kZSgpIDogbm9kZS5vd25lckRvY3VtZW50O1xuXHRpZiAocm9vdCAmJiAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovIChyb290KS5ob3N0KSB7XG5cdFx0cmV0dXJuIC8qKiBAdHlwZSB7U2hhZG93Um9vdH0gKi8gKHJvb3QpO1xuXHR9XG5cdHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7Q1NTU3R5bGVTaGVldH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0KG5vZGUpIHtcblx0Y29uc3Qgc3R5bGVfZWxlbWVudCA9IGVsZW1lbnQoJ3N0eWxlJyk7XG5cdC8vIEZvciB0cmFuc2l0aW9ucyB0byB3b3JrIHdpdGhvdXQgJ3N0eWxlLXNyYzogdW5zYWZlLWlubGluZScgQ29udGVudCBTZWN1cml0eSBQb2xpY3ksXG5cdC8vIHRoZXNlIGVtcHR5IHRhZ3MgbmVlZCB0byBiZSBhbGxvd2VkIHdpdGggYSBoYXNoIGFzIGEgd29ya2Fyb3VuZCB1bnRpbCB3ZSBtb3ZlIHRvIHRoZSBXZWIgQW5pbWF0aW9ucyBBUEkuXG5cdC8vIFVzaW5nIHRoZSBoYXNoIGZvciB0aGUgZW1wdHkgc3RyaW5nIChmb3IgYW4gZW1wdHkgdGFnKSB3b3JrcyBpbiBhbGwgYnJvd3NlcnMgZXhjZXB0IFNhZmFyaS5cblx0Ly8gU28gYXMgYSB3b3JrYXJvdW5kIGZvciB0aGUgd29ya2Fyb3VuZCwgd2hlbiB3ZSBhcHBlbmQgZW1wdHkgc3R5bGUgdGFncyB3ZSBzZXQgdGhlaXIgY29udGVudCB0byAvKiBlbXB0eSAqLy5cblx0Ly8gVGhlIGhhc2ggJ3NoYTI1Ni05T2xOTzBETkVlYVZ6SEw0Ulp3Q0xzQkhBOFdCUTh0b0JwLzRGNVhWMm5jPScgd2lsbCB0aGVuIHdvcmsgZXZlbiBpbiBTYWZhcmkuXG5cdHN0eWxlX2VsZW1lbnQudGV4dENvbnRlbnQgPSAnLyogZW1wdHkgKi8nO1xuXHRhcHBlbmRfc3R5bGVzaGVldChnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSksIHN0eWxlX2VsZW1lbnQpO1xuXHRyZXR1cm4gc3R5bGVfZWxlbWVudC5zaGVldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NoYWRvd1Jvb3QgfCBEb2N1bWVudH0gbm9kZVxuICogQHBhcmFtIHtIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICogQHJldHVybnMge0NTU1N0eWxlU2hlZXR9XG4gKi9cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXNoZWV0KG5vZGUsIHN0eWxlKSB7XG5cdGFwcGVuZCgvKiogQHR5cGUge0RvY3VtZW50fSAqLyAobm9kZSkuaGVhZCB8fCBub2RlLCBzdHlsZSk7XG5cdHJldHVybiBzdHlsZS5zaGVldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGVFeH0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGVFeH0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSkge1xuXHRpZiAoaXNfaHlkcmF0aW5nKSB7XG5cdFx0aW5pdF9oeWRyYXRlKHRhcmdldCk7XG5cdFx0aWYgKFxuXHRcdFx0dGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0KHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsICYmIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLnBhcmVudE5vZGUgIT09IHRhcmdldClcblx0XHQpIHtcblx0XHRcdHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmZpcnN0Q2hpbGQ7XG5cdFx0fVxuXHRcdC8vIFNraXAgbm9kZXMgb2YgdW5kZWZpbmVkIG9yZGVyaW5nXG5cdFx0d2hpbGUgKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsICYmIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLmNsYWltX29yZGVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHRcdGlmIChub2RlICE9PSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCkge1xuXHRcdFx0Ly8gV2Ugb25seSBpbnNlcnQgaWYgdGhlIG9yZGVyaW5nIG9mIHRoaXMgbm9kZSBzaG91bGQgYmUgbW9kaWZpZWQgb3IgdGhlIHBhcmVudCBub2RlIGlzIG5vdCB0YXJnZXRcblx0XHRcdGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQgfHwgbm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQpIHtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gbm9kZS5uZXh0U2libGluZztcblx0XHR9XG5cdH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQgfHwgbm9kZS5uZXh0U2libGluZyAhPT0gbnVsbCkge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gW2FuY2hvcl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG5cdHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZUV4fSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZUV4fSBub2RlXG4gKiBAcGFyYW0ge05vZGVFeH0gW2FuY2hvcl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuXHRpZiAoaXNfaHlkcmF0aW5nICYmICFhbmNob3IpIHtcblx0XHRhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG5cdH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQgfHwgbm9kZS5uZXh0U2libGluZyAhPSBhbmNob3IpIHtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRhY2gobm9kZSkge1xuXHRpZiAobm9kZS5wYXJlbnROb2RlKSB7XG5cdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9lYWNoKGl0ZXJhdGlvbnMsIGRldGFjaGluZykge1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoaXRlcmF0aW9uc1tpXSkgaXRlcmF0aW9uc1tpXS5kKGRldGFjaGluZyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gS1xuICogQHBhcmFtIHtLfSBuYW1lXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRUYWdOYW1lTWFwW0tdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudChuYW1lKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwfSBLXG4gKiBAcGFyYW0ge0t9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpc1xuICogQHJldHVybnMge0hUTUxFbGVtZW50VGFnTmFtZU1hcFtLXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRfaXMobmFtZSwgaXMpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSwgeyBpcyB9KTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHtrZXlvZiBUfSBLXG4gKiBAcGFyYW0ge1R9IG9ialxuICogQHBhcmFtIHtLW119IGV4Y2x1ZGVcbiAqIEByZXR1cm5zIHtQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcyhvYmosIGV4Y2x1ZGUpIHtcblx0Y29uc3QgdGFyZ2V0ID0gLyoqIEB0eXBlIHtQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+fSAqLyAoe30pO1xuXHRmb3IgKGNvbnN0IGsgaW4gb2JqKSB7XG5cdFx0aWYgKFxuXHRcdFx0aGFzX3Byb3Aob2JqLCBrKSAmJlxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0ZXhjbHVkZS5pbmRleE9mKGspID09PSAtMVxuXHRcdCkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0dGFyZ2V0W2tdID0gb2JqW2tdO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgU1ZHRWxlbWVudFRhZ05hbWVNYXB9IEtcbiAqIEBwYXJhbSB7S30gbmFtZVxuICogQHJldHVybnMge1NWR0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdmdfZWxlbWVudChuYW1lKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAqIEByZXR1cm5zIHtUZXh0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGV4dChkYXRhKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7VGV4dH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGFjZSgpIHtcblx0cmV0dXJuIHRleHQoJyAnKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7VGV4dH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eSgpIHtcblx0cmV0dXJuIHRleHQoJycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcmV0dXJucyB7Q29tbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1lbnQoY29udGVudCkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChjb250ZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdH0gaGFuZGxlclxuICogQHBhcmFtIHtib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMgfCBFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuXHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuXHRyZXR1cm4gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IGFueX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50X2RlZmF1bHQoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IGFueX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wX3Byb3BhZ2F0aW9uKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gYW55fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gdm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxmKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0aWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcykgZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiB2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRydXN0ZWQoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRpZiAoZXZlbnQuaXNUcnVzdGVkKSBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHRpZiAodmFsdWUgPT0gbnVsbCkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcblx0ZWxzZSBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKSAhPT0gdmFsdWUpIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuLyoqXG4gKiBMaXN0IG9mIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYWx3YXlzIGJlIHNldCB0aHJvdWdoIHRoZSBhdHRyIG1ldGhvZCxcbiAqIGJlY2F1c2UgdXBkYXRpbmcgdGhlbSB0aHJvdWdoIHRoZSBwcm9wZXJ0eSBzZXR0ZXIgZG9lc24ndCB3b3JrIHJlbGlhYmx5LlxuICogSW4gdGhlIGV4YW1wbGUgb2YgYHdpZHRoYC9gaGVpZ2h0YCwgdGhlIHByb2JsZW0gaXMgdGhhdCB0aGUgc2V0dGVyIG9ubHlcbiAqIGFjY2VwdHMgbnVtZXJpYyB2YWx1ZXMsIGJ1dCB0aGUgYXR0cmlidXRlIGNhbiBhbHNvIGJlIHNldCB0byBhIHN0cmluZyBsaWtlIGA1MCVgLlxuICogSWYgdGhpcyBsaXN0IGJlY29tZXMgdG9vIGJpZywgcmV0aGluayB0aGlzIGFwcHJvYWNoLlxuICovXG5jb25zdCBhbHdheXNfc2V0X3Rocm91Z2hfc2V0X2F0dHJpYnV0ZSA9IFsnd2lkdGgnLCAnaGVpZ2h0J107XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge3sgW3g6IHN0cmluZ106IHN0cmluZyB9fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG5vZGUuX19wcm90b19fKTtcblx0Zm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdGlmIChhdHRyaWJ1dGVzW2tleV0gPT0gbnVsbCkge1xuXHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuXHRcdFx0bm9kZS5zdHlsZS5jc3NUZXh0ID0gYXR0cmlidXRlc1trZXldO1xuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnX192YWx1ZScpIHtcblx0XHRcdC8qKiBAdHlwZSB7YW55fSAqLyAobm9kZSkudmFsdWUgPSBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdGRlc2NyaXB0b3JzW2tleV0gJiZcblx0XHRcdGRlc2NyaXB0b3JzW2tleV0uc2V0ICYmXG5cdFx0XHRhbHdheXNfc2V0X3Rocm91Z2hfc2V0X2F0dHJpYnV0ZS5pbmRleE9mKGtleSkgPT09IC0xXG5cdFx0KSB7XG5cdFx0XHRub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHt7IFt4OiBzdHJpbmddOiBzdHJpbmcgfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc3ZnX2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuXHRmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0YXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBkYXRhX21hcFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YV9tYXAobm9kZSwgZGF0YV9tYXApIHtcblx0T2JqZWN0LmtleXMoZGF0YV9tYXApLmZvckVhY2goKGtleSkgPT4ge1xuXHRcdHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIGtleSwgZGF0YV9tYXBba2V5XSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIHByb3AsIHZhbHVlKSB7XG5cdGNvbnN0IGxvd2VyID0gcHJvcC50b0xvd2VyQ2FzZSgpOyAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBiZWhhdmlvciB3ZSBkbyBsb3dlcmNhc2UgZmlyc3Rcblx0aWYgKGxvd2VyIGluIG5vZGUpIHtcblx0XHRub2RlW2xvd2VyXSA9IHR5cGVvZiBub2RlW2xvd2VyXSA9PT0gJ2Jvb2xlYW4nICYmIHZhbHVlID09PSAnJyA/IHRydWUgOiB2YWx1ZTtcblx0fSBlbHNlIGlmIChwcm9wIGluIG5vZGUpIHtcblx0XHRub2RlW3Byb3BdID0gdHlwZW9mIG5vZGVbcHJvcF0gPT09ICdib29sZWFuJyAmJiB2YWx1ZSA9PT0gJycgPyB0cnVlIDogdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0YXR0cihub2RlLCBwcm9wLCB2YWx1ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZHluYW1pY19lbGVtZW50X2RhdGEodGFnKSB7XG5cdHJldHVybiAvLS8udGVzdCh0YWcpID8gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGFfbWFwIDogc2V0X2F0dHJpYnV0ZXM7XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB4bGlua19hdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0bm9kZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfc3ZlbHRlX2RhdGFzZXQobm9kZSkge1xuXHRyZXR1cm4gbm9kZS5kYXRhc2V0LnN2ZWx0ZUg7XG59XG5cbi8qKlxuICogQHJldHVybnMge3Vua25vd25bXX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cF92YWx1ZShncm91cCwgX192YWx1ZSwgY2hlY2tlZCkge1xuXHRjb25zdCB2YWx1ZSA9IG5ldyBTZXQoKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChncm91cFtpXS5jaGVja2VkKSB2YWx1ZS5hZGQoZ3JvdXBbaV0uX192YWx1ZSk7XG5cdH1cblx0aWYgKCFjaGVja2VkKSB7XG5cdFx0dmFsdWUuZGVsZXRlKF9fdmFsdWUpO1xuXHR9XG5cdHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnRbXX0gZ3JvdXBcbiAqIEByZXR1cm5zIHt7IHAoLi4uaW5wdXRzOiBIVE1MSW5wdXRFbGVtZW50W10pOiB2b2lkOyByKCk6IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50W119ICovXG5cdGxldCBfaW5wdXRzO1xuXHRyZXR1cm4ge1xuXHRcdC8qIHB1c2ggKi8gcCguLi5pbnB1dHMpIHtcblx0XHRcdF9pbnB1dHMgPSBpbnB1dHM7XG5cdFx0XHRfaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBncm91cC5wdXNoKGlucHV0KSk7XG5cdFx0fSxcblx0XHQvKiByZW1vdmUgKi8gcigpIHtcblx0XHRcdF9pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IGdyb3VwLnNwbGljZShncm91cC5pbmRleE9mKGlucHV0KSwgMSkpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzXG4gKiBAcmV0dXJucyB7eyB1KG5ld19pbmRleGVzOiBudW1iZXJbXSk6IHZvaWQ7IHAoLi4uaW5wdXRzOiBIVE1MSW5wdXRFbGVtZW50W10pOiB2b2lkOyByOiAoKSA9PiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9iaW5kaW5nX2dyb3VwX2R5bmFtaWMoZ3JvdXAsIGluZGV4ZXMpIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50W119ICovXG5cdGxldCBfZ3JvdXAgPSBnZXRfYmluZGluZ19ncm91cChncm91cCk7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50W119ICovXG5cdGxldCBfaW5wdXRzO1xuXG5cdGZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwKGdyb3VwKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRncm91cCA9IGdyb3VwW2luZGV4ZXNbaV1dID0gZ3JvdXBbaW5kZXhlc1tpXV0gfHwgW107XG5cdFx0fVxuXHRcdHJldHVybiBncm91cDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gcHVzaCgpIHtcblx0XHRfaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBfZ3JvdXAucHVzaChpbnB1dCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiByZW1vdmUoKSB7XG5cdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gX2dyb3VwLnNwbGljZShfZ3JvdXAuaW5kZXhPZihpbnB1dCksIDEpKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdC8qIHVwZGF0ZSAqLyB1KG5ld19pbmRleGVzKSB7XG5cdFx0XHRpbmRleGVzID0gbmV3X2luZGV4ZXM7XG5cdFx0XHRjb25zdCBuZXdfZ3JvdXAgPSBnZXRfYmluZGluZ19ncm91cChncm91cCk7XG5cdFx0XHRpZiAobmV3X2dyb3VwICE9PSBfZ3JvdXApIHtcblx0XHRcdFx0cmVtb3ZlKCk7XG5cdFx0XHRcdF9ncm91cCA9IG5ld19ncm91cDtcblx0XHRcdFx0cHVzaCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyogcHVzaCAqLyBwKC4uLmlucHV0cykge1xuXHRcdFx0X2lucHV0cyA9IGlucHV0cztcblx0XHRcdHB1c2goKTtcblx0XHR9LFxuXHRcdC8qIHJlbW92ZSAqLyByOiByZW1vdmVcblx0fTtcbn1cblxuLyoqIEByZXR1cm5zIHtudW1iZXJ9ICovXG5leHBvcnQgZnVuY3Rpb24gdG9fbnVtYmVyKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSA9PT0gJycgPyBudWxsIDogK3ZhbHVlO1xufVxuXG4vKiogQHJldHVybnMge2FueVtdfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVfcmFuZ2VzX3RvX2FycmF5KHJhbmdlcykge1xuXHRjb25zdCBhcnJheSA9IFtdO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGFycmF5LnB1c2goeyBzdGFydDogcmFuZ2VzLnN0YXJ0KGkpLCBlbmQ6IHJhbmdlcy5lbmQoaSkgfSk7XG5cdH1cblx0cmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0NoaWxkTm9kZVtdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCkge1xuXHRyZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gaW5pdF9jbGFpbV9pbmZvKG5vZGVzKSB7XG5cdGlmIChub2Rlcy5jbGFpbV9pbmZvID09PSB1bmRlZmluZWQpIHtcblx0XHRub2Rlcy5jbGFpbV9pbmZvID0geyBsYXN0X2luZGV4OiAwLCB0b3RhbF9jbGFpbWVkOiAwIH07XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge0NoaWxkTm9kZUV4fSBSXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHBhcmFtIHsobm9kZTogQ2hpbGROb2RlRXgpID0+IG5vZGUgaXMgUn0gcHJlZGljYXRlXG4gKiBAcGFyYW0geyhub2RlOiBDaGlsZE5vZGVFeCkgPT4gQ2hpbGROb2RlRXggfCB1bmRlZmluZWR9IHByb2Nlc3Nfbm9kZVxuICogQHBhcmFtIHsoKSA9PiBSfSBjcmVhdGVfbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBkb250X3VwZGF0ZV9sYXN0X2luZGV4XG4gKiBAcmV0dXJucyB7Un1cbiAqL1xuZnVuY3Rpb24gY2xhaW1fbm9kZShub2RlcywgcHJlZGljYXRlLCBwcm9jZXNzX25vZGUsIGNyZWF0ZV9ub2RlLCBkb250X3VwZGF0ZV9sYXN0X2luZGV4ID0gZmFsc2UpIHtcblx0Ly8gVHJ5IHRvIGZpbmQgbm9kZXMgaW4gYW4gb3JkZXIgc3VjaCB0aGF0IHdlIGxlbmd0aGVuIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Vcblx0aW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcblx0Y29uc3QgcmVzdWx0X25vZGUgPSAoKCkgPT4ge1xuXHRcdC8vIFdlIGZpcnN0IHRyeSB0byBmaW5kIGFuIGVsZW1lbnQgYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZVxuXHRcdGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXg7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXHRcdFx0aWYgKHByZWRpY2F0ZShub2RlKSkge1xuXHRcdFx0XHRjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3Nfbm9kZShub2RlKTtcblx0XHRcdFx0aWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRub2Rlcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm9kZXNbaV0gPSByZXBsYWNlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWRvbnRfdXBkYXRlX2xhc3RfaW5kZXgpIHtcblx0XHRcdFx0XHRub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBPdGhlcndpc2UsIHdlIHRyeSB0byBmaW5kIG9uZSBiZWZvcmVcblx0XHQvLyBXZSBpdGVyYXRlIGluIHJldmVyc2Ugc28gdGhhdCB3ZSBkb24ndCBnbyB0b28gZmFyIGJhY2tcblx0XHRmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdGlmIChwcmVkaWNhdGUobm9kZSkpIHtcblx0XHRcdFx0Y29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzX25vZGUobm9kZSk7XG5cdFx0XHRcdGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0bm9kZXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFkb250X3VwZGF0ZV9sYXN0X2luZGV4KSB7XG5cdFx0XHRcdFx0bm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcblx0XHRcdFx0fSBlbHNlIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Ly8gU2luY2Ugd2Ugc3BsaWNlZCBiZWZvcmUgdGhlIGxhc3RfaW5kZXgsIHdlIGRlY3JlYXNlIGl0XG5cdFx0XHRcdFx0bm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIElmIHdlIGNhbid0IGZpbmQgYW55IG1hdGNoaW5nIG5vZGUsIHdlIGNyZWF0ZSBhIG5ldyBvbmVcblx0XHRyZXR1cm4gY3JlYXRlX25vZGUoKTtcblx0fSkoKTtcblx0cmVzdWx0X25vZGUuY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG5cdG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuXHRyZXR1cm4gcmVzdWx0X25vZGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3sgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9fSBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0geyhuYW1lOiBzdHJpbmcpID0+IEVsZW1lbnQgfCBTVkdFbGVtZW50fSBjcmVhdGVfZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnQgfCBTVkdFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGNyZWF0ZV9lbGVtZW50KSB7XG5cdHJldHVybiBjbGFpbV9ub2RlKFxuXHRcdG5vZGVzLFxuXHRcdC8qKiBAcmV0dXJucyB7bm9kZSBpcyBFbGVtZW50IHwgU1ZHRWxlbWVudH0gKi9cblx0XHQobm9kZSkgPT4gbm9kZS5ub2RlTmFtZSA9PT0gbmFtZSxcblx0XHQvKiogQHBhcmFtIHtFbGVtZW50fSBub2RlICovXG5cdFx0KG5vZGUpID0+IHtcblx0XHRcdGNvbnN0IHJlbW92ZSA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2pdO1xuXHRcdFx0XHRpZiAoIWF0dHJpYnV0ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG5cdFx0XHRcdFx0cmVtb3ZlLnB1c2goYXR0cmlidXRlLm5hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZW1vdmUuZm9yRWFjaCgodikgPT4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUodikpO1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9LFxuXHRcdCgpID0+IGNyZWF0ZV9lbGVtZW50KG5hbWUpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3sgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7RWxlbWVudCB8IFNWR0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG5cdHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge0VsZW1lbnQgfCBTVkdFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fc3ZnX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcblx0cmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgc3ZnX2VsZW1lbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcmV0dXJucyB7VGV4dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX3RleHQobm9kZXMsIGRhdGEpIHtcblx0cmV0dXJuIGNsYWltX25vZGUoXG5cdFx0bm9kZXMsXG5cdFx0LyoqIEByZXR1cm5zIHtub2RlIGlzIFRleHR9ICovXG5cdFx0KG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDMsXG5cdFx0LyoqIEBwYXJhbSB7VGV4dH0gbm9kZSAqL1xuXHRcdChub2RlKSA9PiB7XG5cdFx0XHRjb25zdCBkYXRhX3N0ciA9ICcnICsgZGF0YTtcblx0XHRcdGlmIChub2RlLmRhdGEuc3RhcnRzV2l0aChkYXRhX3N0cikpIHtcblx0XHRcdFx0aWYgKG5vZGUuZGF0YS5sZW5ndGggIT09IGRhdGFfc3RyLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlLnNwbGl0VGV4dChkYXRhX3N0ci5sZW5ndGgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLmRhdGEgPSBkYXRhX3N0cjtcblx0XHRcdH1cblx0XHR9LFxuXHRcdCgpID0+IHRleHQoZGF0YSksXG5cdFx0dHJ1ZSAvLyBUZXh0IG5vZGVzIHNob3VsZCBub3QgdXBkYXRlIGxhc3QgaW5kZXggc2luY2UgaXQgaXMgbGlrZWx5IG5vdCB3b3J0aCBpdCB0byBlbGltaW5hdGUgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBhY3R1YWwgZWxlbWVudHNcblx0KTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7VGV4dH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9zcGFjZShub2Rlcykge1xuXHRyZXR1cm4gY2xhaW1fdGV4dChub2RlcywgJyAnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHJldHVybnMge0NvbW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9jb21tZW50KG5vZGVzLCBkYXRhKSB7XG5cdHJldHVybiBjbGFpbV9ub2RlKFxuXHRcdG5vZGVzLFxuXHRcdC8qKiBAcmV0dXJucyB7bm9kZSBpcyBDb21tZW50fSAqL1xuXHRcdChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4LFxuXHRcdC8qKiBAcGFyYW0ge0NvbW1lbnR9IG5vZGUgKi9cblx0XHQobm9kZSkgPT4ge1xuXHRcdFx0bm9kZS5kYXRhID0gJycgKyBkYXRhO1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9LFxuXHRcdCgpID0+IGNvbW1lbnQoZGF0YSksXG5cdFx0dHJ1ZVxuXHQpO1xufVxuXG5mdW5jdGlvbiBnZXRfY29tbWVudF9pZHgobm9kZXMsIHRleHQsIHN0YXJ0KSB7XG5cdGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0Y29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXHRcdGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLyAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSA9PT0gdGV4dCkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzX3N2Z1xuICogQHJldHVybnMge0h0bWxUYWdIeWRyYXRpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9odG1sX3RhZyhub2RlcywgaXNfc3ZnKSB7XG5cdC8vIGZpbmQgaHRtbCBvcGVuaW5nIHRhZ1xuXHRjb25zdCBzdGFydF9pbmRleCA9IGdldF9jb21tZW50X2lkeChub2RlcywgJ0hUTUxfVEFHX1NUQVJUJywgMCk7XG5cdGNvbnN0IGVuZF9pbmRleCA9IGdldF9jb21tZW50X2lkeChub2RlcywgJ0hUTUxfVEFHX0VORCcsIHN0YXJ0X2luZGV4ICsgMSk7XG5cdGlmIChzdGFydF9pbmRleCA9PT0gLTEgfHwgZW5kX2luZGV4ID09PSAtMSkge1xuXHRcdHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihpc19zdmcpO1xuXHR9XG5cblx0aW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcblx0Y29uc3QgaHRtbF90YWdfbm9kZXMgPSBub2Rlcy5zcGxpY2Uoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSk7XG5cdGRldGFjaChodG1sX3RhZ19ub2Rlc1swXSk7XG5cdGRldGFjaChodG1sX3RhZ19ub2Rlc1todG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxXSk7XG5cdGNvbnN0IGNsYWltZWRfbm9kZXMgPSBodG1sX3RhZ19ub2Rlcy5zbGljZSgxLCBodG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxKTtcblx0aWYgKGNsYWltZWRfbm9kZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKGlzX3N2Zyk7XG5cdH1cblx0Zm9yIChjb25zdCBuIG9mIGNsYWltZWRfbm9kZXMpIHtcblx0XHRuLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuXHRcdG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuXHR9XG5cdHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihpc19zdmcsIGNsYWltZWRfbm9kZXMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhKHRleHQsIGRhdGEpIHtcblx0ZGF0YSA9ICcnICsgZGF0YTtcblx0aWYgKHRleHQuZGF0YSA9PT0gZGF0YSkgcmV0dXJuO1xuXHR0ZXh0LmRhdGEgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGRhdGEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhKSB7XG5cdGRhdGEgPSAnJyArIGRhdGE7XG5cdGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSkgcmV0dXJuO1xuXHR0ZXh0LmRhdGEgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGRhdGEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cl92YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSwgYXR0cl92YWx1ZSkge1xuXHRpZiAofmNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzLmluZGV4T2YoYXR0cl92YWx1ZSkpIHtcblx0XHRzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSk7XG5cdH0gZWxzZSB7XG5cdFx0c2V0X2RhdGEodGV4dCwgZGF0YSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaW5wdXRfdmFsdWUoaW5wdXQsIHZhbHVlKSB7XG5cdGlucHV0LnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2lucHV0X3R5cGUoaW5wdXQsIHR5cGUpIHtcblx0dHJ5IHtcblx0XHRpbnB1dC50eXBlID0gdHlwZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIGRvIG5vdGhpbmdcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zdHlsZShub2RlLCBrZXksIHZhbHVlLCBpbXBvcnRhbnQpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG5cdH0gZWxzZSB7XG5cdFx0bm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlLCBpbXBvcnRhbnQgPyAnaW1wb3J0YW50JyA6ICcnKTtcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSwgbW91bnRpbmcpIHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuXHRcdGlmIChvcHRpb24uX192YWx1ZSA9PT0gdmFsdWUpIHtcblx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cdGlmICghbW91bnRpbmcgfHwgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gLTE7IC8vIG5vIG9wdGlvbiBzaG91bGQgYmUgc2VsZWN0ZWRcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9vcHRpb25zKHNlbGVjdCwgdmFsdWUpIHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuXHRcdG9wdGlvbi5zZWxlY3RlZCA9IH52YWx1ZS5pbmRleE9mKG9wdGlvbi5fX3ZhbHVlKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X3ZhbHVlKHNlbGVjdCkge1xuXHRjb25zdCBzZWxlY3RlZF9vcHRpb24gPSBzZWxlY3QucXVlcnlTZWxlY3RvcignOmNoZWNrZWQnKTtcblx0cmV0dXJuIHNlbGVjdGVkX29wdGlvbiAmJiBzZWxlY3RlZF9vcHRpb24uX192YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV92YWx1ZShzZWxlY3QpIHtcblx0cmV0dXJuIFtdLm1hcC5jYWxsKHNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKCc6Y2hlY2tlZCcpLCAob3B0aW9uKSA9PiBvcHRpb24uX192YWx1ZSk7XG59XG4vLyB1bmZvcnR1bmF0ZWx5IHRoaXMgY2FuJ3QgYmUgYSBjb25zdGFudCBhcyB0aGF0IHdvdWxkbid0IGJlIHRyZWUtc2hha2VhYmxlXG4vLyBzbyB3ZSBjYWNoZSB0aGUgcmVzdWx0IGluc3RlYWRcblxuLyoqXG4gKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbmxldCBjcm9zc29yaWdpbjtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19jcm9zc29yaWdpbigpIHtcblx0aWYgKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQpIHtcblx0XHRjcm9zc29yaWdpbiA9IGZhbHNlO1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBhcmVudCkge1xuXHRcdFx0XHR2b2lkIHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNyb3Nzb3JpZ2luID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGNyb3Nzb3JpZ2luO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2lmcmFtZV9yZXNpemVfbGlzdGVuZXIobm9kZSwgZm4pIHtcblx0Y29uc3QgY29tcHV0ZWRfc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRpZiAoY29tcHV0ZWRfc3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG5cdFx0bm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cdH1cblx0Y29uc3QgaWZyYW1lID0gZWxlbWVudCgnaWZyYW1lJyk7XG5cdGlmcmFtZS5zZXRBdHRyaWJ1dGUoXG5cdFx0J3N0eWxlJyxcblx0XHQnZGlzcGxheTogYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyAnICtcblx0XHRcdCdvdmVyZmxvdzogaGlkZGVuOyBib3JkZXI6IDA7IG9wYWNpdHk6IDA7IHBvaW50ZXItZXZlbnRzOiBub25lOyB6LWluZGV4OiAtMTsnXG5cdCk7XG5cdGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblx0aWZyYW1lLnRhYkluZGV4ID0gLTE7XG5cdGNvbnN0IGNyb3Nzb3JpZ2luID0gaXNfY3Jvc3NvcmlnaW4oKTtcblxuXHQvKipcblx0ICogQHR5cGUgeygpID0+IHZvaWR9XG5cdCAqL1xuXHRsZXQgdW5zdWJzY3JpYmU7XG5cdGlmIChjcm9zc29yaWdpbikge1xuXHRcdGlmcmFtZS5zcmMgPSBcImRhdGE6dGV4dC9odG1sLDxzY3JpcHQ+b25yZXNpemU9ZnVuY3Rpb24oKXtwYXJlbnQucG9zdE1lc3NhZ2UoMCwnKicpfTwvc2NyaXB0PlwiO1xuXHRcdHVuc3Vic2NyaWJlID0gbGlzdGVuKFxuXHRcdFx0d2luZG93LFxuXHRcdFx0J21lc3NhZ2UnLFxuXHRcdFx0LyoqIEBwYXJhbSB7TWVzc2FnZUV2ZW50fSBldmVudCAqLyAoZXZlbnQpID0+IHtcblx0XHRcdFx0aWYgKGV2ZW50LnNvdXJjZSA9PT0gaWZyYW1lLmNvbnRlbnRXaW5kb3cpIGZuKCk7XG5cdFx0XHR9XG5cdFx0KTtcblx0fSBlbHNlIHtcblx0XHRpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcblx0XHRpZnJhbWUub25sb2FkID0gKCkgPT4ge1xuXHRcdFx0dW5zdWJzY3JpYmUgPSBsaXN0ZW4oaWZyYW1lLmNvbnRlbnRXaW5kb3csICdyZXNpemUnLCBmbik7XG5cdFx0XHQvLyBtYWtlIHN1cmUgYW4gaW5pdGlhbCByZXNpemUgZXZlbnQgaXMgZmlyZWQgX2FmdGVyXyB0aGUgaWZyYW1lIGlzIGxvYWRlZCAod2hpY2ggaXMgYXN5bmNocm9ub3VzKVxuXHRcdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzQyMzNcblx0XHRcdGZuKCk7XG5cdFx0fTtcblx0fVxuXHRhcHBlbmQobm9kZSwgaWZyYW1lKTtcblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoY3Jvc3NvcmlnaW4pIHtcblx0XHRcdHVuc3Vic2NyaWJlKCk7XG5cdFx0fSBlbHNlIGlmICh1bnN1YnNjcmliZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuXHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHR9XG5cdFx0ZGV0YWNoKGlmcmFtZSk7XG5cdH07XG59XG5leHBvcnQgY29uc3QgcmVzaXplX29ic2VydmVyX2NvbnRlbnRfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7XG5cdGJveDogJ2NvbnRlbnQtYm94J1xufSk7XG5leHBvcnQgY29uc3QgcmVzaXplX29ic2VydmVyX2JvcmRlcl9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKHtcblx0Ym94OiAnYm9yZGVyLWJveCdcbn0pO1xuZXhwb3J0IGNvbnN0IHJlc2l6ZV9vYnNlcnZlcl9kZXZpY2VfcGl4ZWxfY29udGVudF9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKFxuXHR7IGJveDogJ2RldmljZS1waXhlbC1jb250ZW50LWJveCcgfVxuKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIH07XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlX2NsYXNzKGVsZW1lbnQsIG5hbWUsIHRvZ2dsZSkge1xuXHQvLyBUaGUgYCEhYCBpcyByZXF1aXJlZCBiZWNhdXNlIGFuIGB1bmRlZmluZWRgIGZsYWcgbWVhbnMgZmxpcHBpbmcgdGhlIGN1cnJlbnQgc3RhdGUuXG5cdGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShuYW1lLCAhIXRvZ2dsZSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1R9IFtkZXRhaWxdXG4gKiBAcGFyYW0ge3sgYnViYmxlcz86IGJvb2xlYW4sIGNhbmNlbGFibGU/OiBib29sZWFuIH19IFtvcHRpb25zXVxuICogQHJldHVybnMge0N1c3RvbUV2ZW50PFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBidWJibGVzID0gZmFsc2UsIGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pIHtcblx0cmV0dXJuIG5ldyBDdXN0b21FdmVudCh0eXBlLCB7IGRldGFpbCwgYnViYmxlcywgY2FuY2VsYWJsZSB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybnMge0NoaWxkTm9kZUFycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVlcnlfc2VsZWN0b3JfYWxsKHNlbGVjdG9yLCBwYXJlbnQgPSBkb2N1bWVudC5ib2R5KSB7XG5cdHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVJZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaGVhZFxuICogQHJldHVybnMge2FueVtdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGVhZF9zZWxlY3Rvcihub2RlSWQsIGhlYWQpIHtcblx0Y29uc3QgcmVzdWx0ID0gW107XG5cdGxldCBzdGFydGVkID0gMDtcblx0Zm9yIChjb25zdCBub2RlIG9mIGhlYWQuY2hpbGROb2Rlcykge1xuXHRcdGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLykge1xuXHRcdFx0Y29uc3QgY29tbWVudCA9IG5vZGUudGV4dENvbnRlbnQudHJpbSgpO1xuXHRcdFx0aWYgKGNvbW1lbnQgPT09IGBIRUFEXyR7bm9kZUlkfV9FTkRgKSB7XG5cdFx0XHRcdHN0YXJ0ZWQgLT0gMTtcblx0XHRcdFx0cmVzdWx0LnB1c2gobm9kZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGNvbW1lbnQgPT09IGBIRUFEXyR7bm9kZUlkfV9TVEFSVGApIHtcblx0XHRcdFx0c3RhcnRlZCArPSAxO1xuXHRcdFx0XHRyZXN1bHQucHVzaChub2RlKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHN0YXJ0ZWQgPiAwKSB7XG5cdFx0XHRyZXN1bHQucHVzaChub2RlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cbi8qKiAqL1xuZXhwb3J0IGNsYXNzIEh0bWxUYWcge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICovXG5cdGlzX3N2ZyA9IGZhbHNlO1xuXHQvKiogcGFyZW50IGZvciBjcmVhdGluZyBub2RlICovXG5cdGUgPSB1bmRlZmluZWQ7XG5cdC8qKiBodG1sIHRhZyBub2RlcyAqL1xuXHRuID0gdW5kZWZpbmVkO1xuXHQvKiogdGFyZ2V0ICovXG5cdHQgPSB1bmRlZmluZWQ7XG5cdC8qKiBhbmNob3IgKi9cblx0YSA9IHVuZGVmaW5lZDtcblx0Y29uc3RydWN0b3IoaXNfc3ZnID0gZmFsc2UpIHtcblx0XHR0aGlzLmlzX3N2ZyA9IGlzX3N2Zztcblx0XHR0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0YyhodG1sKSB7XG5cdFx0dGhpcy5oKGh0bWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50fSB0YXJnZXRcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9IGFuY2hvclxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdG0oaHRtbCwgdGFyZ2V0LCBhbmNob3IgPSBudWxsKSB7XG5cdFx0aWYgKCF0aGlzLmUpIHtcblx0XHRcdGlmICh0aGlzLmlzX3N2Zylcblx0XHRcdFx0dGhpcy5lID0gc3ZnX2VsZW1lbnQoLyoqIEB0eXBlIHtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcH0gKi8gKHRhcmdldC5ub2RlTmFtZSkpO1xuXHRcdFx0LyoqICM3MzY0ICB0YXJnZXQgZm9yIDx0ZW1wbGF0ZT4gbWF5IGJlIHByb3ZpZGVkIGFzICNkb2N1bWVudC1mcmFnbWVudCgxMSkgKi8gZWxzZVxuXHRcdFx0XHR0aGlzLmUgPSBlbGVtZW50KFxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7a2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwfSAqLyAoXG5cdFx0XHRcdFx0XHR0YXJnZXQubm9kZVR5cGUgPT09IDExID8gJ1RFTVBMQVRFJyA6IHRhcmdldC5ub2RlTmFtZVxuXHRcdFx0XHRcdClcblx0XHRcdFx0KTtcblx0XHRcdHRoaXMudCA9XG5cdFx0XHRcdHRhcmdldC50YWdOYW1lICE9PSAnVEVNUExBVEUnXG5cdFx0XHRcdFx0PyB0YXJnZXRcblx0XHRcdFx0XHQ6IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8gKHRhcmdldCkuY29udGVudDtcblx0XHRcdHRoaXMuYyhodG1sKTtcblx0XHR9XG5cdFx0dGhpcy5pKGFuY2hvcik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRoKGh0bWwpIHtcblx0XHR0aGlzLmUuaW5uZXJIVE1MID0gaHRtbDtcblx0XHR0aGlzLm4gPSBBcnJheS5mcm9tKFxuXHRcdFx0dGhpcy5lLm5vZGVOYW1lID09PSAnVEVNUExBVEUnID8gdGhpcy5lLmNvbnRlbnQuY2hpbGROb2RlcyA6IHRoaXMuZS5jaGlsZE5vZGVzXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0aShhbmNob3IpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0aW5zZXJ0KHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdHAoaHRtbCkge1xuXHRcdHRoaXMuZCgpO1xuXHRcdHRoaXMuaChodG1sKTtcblx0XHR0aGlzLmkodGhpcy5hKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZCgpIHtcblx0XHR0aGlzLm4uZm9yRWFjaChkZXRhY2gpO1xuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBIdG1sVGFnSHlkcmF0aW9uIGV4dGVuZHMgSHRtbFRhZyB7XG5cdC8qKiBAdHlwZSB7RWxlbWVudFtdfSBoeWRyYXRpb24gY2xhaW1lZCBub2RlcyAqL1xuXHRsID0gdW5kZWZpbmVkO1xuXG5cdGNvbnN0cnVjdG9yKGlzX3N2ZyA9IGZhbHNlLCBjbGFpbWVkX25vZGVzKSB7XG5cdFx0c3VwZXIoaXNfc3ZnKTtcblx0XHR0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuXHRcdHRoaXMubCA9IGNsYWltZWRfbm9kZXM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRjKGh0bWwpIHtcblx0XHRpZiAodGhpcy5sKSB7XG5cdFx0XHR0aGlzLm4gPSB0aGlzLmw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN1cGVyLmMoaHRtbCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRpKGFuY2hvcikge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRpbnNlcnRfaHlkcmF0aW9uKHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TmFtZWROb2RlTWFwfSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7e319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyaWJ1dGVfdG9fb2JqZWN0KGF0dHJpYnV0ZXMpIHtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZXMpIHtcblx0XHRyZXN1bHRbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IGVzY2FwZWQgPSB7XG5cdCdcIic6ICcmcXVvdDsnLFxuXHQnJic6ICcmYW1wOycsXG5cdCc8JzogJyZsdDsnXG59O1xuXG5jb25zdCByZWdleF9hdHRyaWJ1dGVfY2hhcmFjdGVyc190b19lc2NhcGUgPSAvW1wiJjxdL2c7XG5cbi8qKlxuICogTm90ZSB0aGF0IHRoZSBhdHRyaWJ1dGUgaXRzZWxmIHNob3VsZCBiZSBzdXJyb3VuZGVkIGluIGRvdWJsZSBxdW90ZXNcbiAqIEBwYXJhbSB7YW55fSBhdHRyaWJ1dGVcbiAqL1xuZnVuY3Rpb24gZXNjYXBlX2F0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcblx0cmV0dXJuIFN0cmluZyhhdHRyaWJ1dGUpLnJlcGxhY2UocmVnZXhfYXR0cmlidXRlX2NoYXJhY3RlcnNfdG9fZXNjYXBlLCAobWF0Y2gpID0+IGVzY2FwZWRbbWF0Y2hdKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IGF0dHJpYnV0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeV9zcHJlYWQoYXR0cmlidXRlcykge1xuXHRsZXQgc3RyID0gJyAnO1xuXHRmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0aWYgKGF0dHJpYnV0ZXNba2V5XSAhPSBudWxsKSB7XG5cdFx0XHRzdHIgKz0gYCR7a2V5fT1cIiR7ZXNjYXBlX2F0dHJpYnV0ZShhdHRyaWJ1dGVzW2tleV0pfVwiIGA7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7e319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKGVsZW1lbnQpIHtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdGVsZW1lbnQuY2hpbGROb2Rlcy5mb3JFYWNoKFxuXHRcdC8qKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgKi8gKG5vZGUpID0+IHtcblx0XHRcdHJlc3VsdFtub2RlLnNsb3QgfHwgJ2RlZmF1bHQnXSA9IHRydWU7XG5cdFx0fVxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnQoY29tcG9uZW50LCBwcm9wcykge1xuXHRyZXR1cm4gbmV3IGNvbXBvbmVudChwcm9wcyk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge05vZGUgJiB7XG4gKiBcdGNsYWltX29yZGVyPzogbnVtYmVyO1xuICogXHRoeWRyYXRlX2luaXQ/OiB0cnVlO1xuICogXHRhY3R1YWxfZW5kX2NoaWxkPzogTm9kZUV4O1xuICogXHRjaGlsZE5vZGVzOiBOb2RlTGlzdE9mPE5vZGVFeD47XG4gKiB9fSBOb2RlRXhcbiAqL1xuXG4vKiogQHR5cGVkZWYge0NoaWxkTm9kZSAmIE5vZGVFeH0gQ2hpbGROb2RlRXggKi9cblxuLyoqIEB0eXBlZGVmIHtOb2RlRXggJiB7IGNsYWltX29yZGVyOiBudW1iZXIgfX0gTm9kZUV4MiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtDaGlsZE5vZGVFeFtdICYge1xuICogXHRjbGFpbV9pbmZvPzoge1xuICogXHRcdGxhc3RfaW5kZXg6IG51bWJlcjtcbiAqIFx0XHR0b3RhbF9jbGFpbWVkOiBudW1iZXI7XG4gKiBcdH07XG4gKiB9fSBDaGlsZE5vZGVBcnJheVxuICovXG4iLCAiaW1wb3J0IHsgY3VzdG9tX2V2ZW50IH0gZnJvbSAnLi9kb20uanMnO1xuXG5leHBvcnQgbGV0IGN1cnJlbnRfY29tcG9uZW50O1xuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCkge1xuXHRjdXJyZW50X2NvbXBvbmVudCA9IGNvbXBvbmVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldF9jdXJyZW50X2NvbXBvbmVudCgpIHtcblx0aWYgKCFjdXJyZW50X2NvbXBvbmVudCkgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsZWQgb3V0c2lkZSBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24nKTtcblx0cmV0dXJuIGN1cnJlbnRfY29tcG9uZW50O1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1cGRhdGVkIGFmdGVyIGFueSBzdGF0ZSBjaGFuZ2UuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBiZWZvcmUgdGhlIGluaXRpYWwgYG9uTW91bnRgXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2JlZm9yZXVwZGF0ZVxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShmbikge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5iZWZvcmVfdXBkYXRlLnB1c2goZm4pO1xufVxuXG4vKipcbiAqIFRoZSBgb25Nb3VudGAgZnVuY3Rpb24gc2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGFzIHNvb24gYXMgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIHRvIHRoZSBET00uXG4gKiBJdCBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgdGhlIGNvbXBvbmVudCdzIGluaXRpYWxpc2F0aW9uIChidXQgZG9lc24ndCBuZWVkIHRvIGxpdmUgKmluc2lkZSogdGhlIGNvbXBvbmVudDtcbiAqIGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBhbiBleHRlcm5hbCBtb2R1bGUpLlxuICpcbiAqIElmIGEgZnVuY3Rpb24gaXMgcmV0dXJuZWQgX3N5bmNocm9ub3VzbHlfIGZyb20gYG9uTW91bnRgLCBpdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICpcbiAqIGBvbk1vdW50YCBkb2VzIG5vdCBydW4gaW5zaWRlIGEgW3NlcnZlci1zaWRlIGNvbXBvbmVudF0oL2RvY3MjcnVuLXRpbWUtc2VydmVyLXNpZGUtY29tcG9uZW50LWFwaSkuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI29ubW91bnRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IGltcG9ydCgnLi9wcml2YXRlLmpzJykuTm90RnVuY3Rpb248VD4gfCBQcm9taXNlPGltcG9ydCgnLi9wcml2YXRlLmpzJykuTm90RnVuY3Rpb248VD4+IHwgKCgpID0+IGFueSl9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uTW91bnQoZm4pIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fbW91bnQucHVzaChmbik7XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gdXBkYXRlZC5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGFmdGVyIHRoZSBpbml0aWFsIGBvbk1vdW50YFxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNhZnRlcnVwZGF0ZVxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFmdGVyVXBkYXRlKGZuKSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmFmdGVyX3VwZGF0ZS5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICpcbiAqIE91dCBvZiBgb25Nb3VudGAsIGBiZWZvcmVVcGRhdGVgLCBgYWZ0ZXJVcGRhdGVgIGFuZCBgb25EZXN0cm95YCwgdGhpcyBpcyB0aGVcbiAqIG9ubHkgb25lIHRoYXQgcnVucyBpbnNpZGUgYSBzZXJ2ZXItc2lkZSBjb21wb25lbnQuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI29uZGVzdHJveVxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uRGVzdHJveShmbikge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9kZXN0cm95LnB1c2goZm4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXZlbnQgZGlzcGF0Y2hlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGRpc3BhdGNoIFtjb21wb25lbnQgZXZlbnRzXSgvZG9jcyN0ZW1wbGF0ZS1zeW50YXgtY29tcG9uZW50LWRpcmVjdGl2ZXMtb24tZXZlbnRuYW1lKS5cbiAqIEV2ZW50IGRpc3BhdGNoZXJzIGFyZSBmdW5jdGlvbnMgdGhhdCBjYW4gdGFrZSB0d28gYXJndW1lbnRzOiBgbmFtZWAgYW5kIGBkZXRhaWxgLlxuICpcbiAqIENvbXBvbmVudCBldmVudHMgY3JlYXRlZCB3aXRoIGBjcmVhdGVFdmVudERpc3BhdGNoZXJgIGNyZWF0ZSBhXG4gKiBbQ3VzdG9tRXZlbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudCkuXG4gKiBUaGVzZSBldmVudHMgZG8gbm90IFtidWJibGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTGVhcm4vSmF2YVNjcmlwdC9CdWlsZGluZ19ibG9ja3MvRXZlbnRzI0V2ZW50X2J1YmJsaW5nX2FuZF9jYXB0dXJlKS5cbiAqIFRoZSBgZGV0YWlsYCBhcmd1bWVudCBjb3JyZXNwb25kcyB0byB0aGUgW0N1c3RvbUV2ZW50LmRldGFpbF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L2RldGFpbClcbiAqIHByb3BlcnR5IGFuZCBjYW4gY29udGFpbiBhbnkgdHlwZSBvZiBkYXRhLlxuICpcbiAqIFRoZSBldmVudCBkaXNwYXRjaGVyIGNhbiBiZSB0eXBlZCB0byBuYXJyb3cgdGhlIGFsbG93ZWQgZXZlbnQgbmFtZXMgYW5kIHRoZSB0eXBlIG9mIHRoZSBgZGV0YWlsYCBhcmd1bWVudDpcbiAqIGBgYHRzXG4gKiBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcjx7XG4gKiAgbG9hZGVkOiBuZXZlcjsgLy8gZG9lcyBub3QgdGFrZSBhIGRldGFpbCBhcmd1bWVudFxuICogIGNoYW5nZTogc3RyaW5nOyAvLyB0YWtlcyBhIGRldGFpbCBhcmd1bWVudCBvZiB0eXBlIHN0cmluZywgd2hpY2ggaXMgcmVxdWlyZWRcbiAqICBvcHRpb25hbDogbnVtYmVyIHwgbnVsbDsgLy8gdGFrZXMgYW4gb3B0aW9uYWwgZGV0YWlsIGFyZ3VtZW50IG9mIHR5cGUgbnVtYmVyXG4gKiB9PigpO1xuICogYGBgXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2NyZWF0ZWV2ZW50ZGlzcGF0Y2hlclxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbRXZlbnRNYXA9YW55XVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5FdmVudERpc3BhdGNoZXI8RXZlbnRNYXA+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuXHRjb25zdCBjb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcblx0cmV0dXJuICh0eXBlLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkgPT4ge1xuXHRcdGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbdHlwZV07XG5cdFx0aWYgKGNhbGxiYWNrcykge1xuXHRcdFx0Ly8gVE9ETyBhcmUgdGhlcmUgc2l0dWF0aW9ucyB3aGVyZSBldmVudHMgY291bGQgYmUgZGlzcGF0Y2hlZFxuXHRcdFx0Ly8gaW4gYSBzZXJ2ZXIgKG5vbi1ET00pIGVudmlyb25tZW50P1xuXHRcdFx0Y29uc3QgZXZlbnQgPSBjdXN0b21fZXZlbnQoLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgZGV0YWlsLCB7IGNhbmNlbGFibGUgfSk7XG5cdFx0XHRjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKChmbikgPT4ge1xuXHRcdFx0XHRmbi5jYWxsKGNvbXBvbmVudCwgZXZlbnQpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xufVxuXG4vKipcbiAqIEFzc29jaWF0ZXMgYW4gYXJiaXRyYXJ5IGBjb250ZXh0YCBvYmplY3Qgd2l0aCB0aGUgY3VycmVudCBjb21wb25lbnQgYW5kIHRoZSBzcGVjaWZpZWQgYGtleWBcbiAqIGFuZCByZXR1cm5zIHRoYXQgb2JqZWN0LiBUaGUgY29udGV4dCBpcyB0aGVuIGF2YWlsYWJsZSB0byBjaGlsZHJlbiBvZiB0aGUgY29tcG9uZW50XG4gKiAoaW5jbHVkaW5nIHNsb3R0ZWQgY29udGVudCkgd2l0aCBgZ2V0Q29udGV4dGAuXG4gKlxuICogTGlrZSBsaWZlY3ljbGUgZnVuY3Rpb25zLCB0aGlzIG11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI3NldGNvbnRleHRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcGFyYW0ge1R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29udGV4dChrZXksIGNvbnRleHQpIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5zZXQoa2V5LCBjb250ZXh0KTtcblx0cmV0dXJuIGNvbnRleHQ7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBjb250ZXh0IHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50IHdpdGggdGhlIHNwZWNpZmllZCBga2V5YC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2dldGNvbnRleHRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRleHQoa2V5KSB7XG5cdHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmdldChrZXkpO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgd2hvbGUgY29udGV4dCBtYXAgdGhhdCBiZWxvbmdzIHRvIHRoZSBjbG9zZXN0IHBhcmVudCBjb21wb25lbnQuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLiBVc2VmdWwsIGZvciBleGFtcGxlLCBpZiB5b3VcbiAqIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgY29tcG9uZW50IGFuZCB3YW50IHRvIHBhc3MgdGhlIGV4aXN0aW5nIGNvbnRleHQgdG8gaXQuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2dldGFsbGNvbnRleHRzXG4gKiBAdGVtcGxhdGUge01hcDxhbnksIGFueT59IFtUPU1hcDxhbnksIGFueT5dXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbENvbnRleHRzKCkge1xuXHRyZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIGBrZXlgIGhhcyBiZWVuIHNldCBpbiB0aGUgY29udGV4dCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNoYXNjb250ZXh0XG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0NvbnRleHQoa2V5KSB7XG5cdHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmhhcyhrZXkpO1xufVxuXG4vLyBUT0RPIGZpZ3VyZSBvdXQgaWYgd2Ugc3RpbGwgd2FudCB0byBzdXBwb3J0XG4vLyBzaG9ydGhhbmQgZXZlbnRzLCBvciBpZiB3ZSB3YW50IHRvIGltcGxlbWVudFxuLy8gYSByZWFsIGJ1YmJsaW5nIG1lY2hhbmlzbVxuLyoqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKiBAcGFyYW0gZXZlbnRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnViYmxlKGNvbXBvbmVudCwgZXZlbnQpIHtcblx0Y29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1tldmVudC50eXBlXTtcblx0aWYgKGNhbGxiYWNrcykge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKChmbikgPT4gZm4uY2FsbCh0aGlzLCBldmVudCkpO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgcnVuX2FsbCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgY3VycmVudF9jb21wb25lbnQsIHNldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcblxuZXhwb3J0IGNvbnN0IGRpcnR5X2NvbXBvbmVudHMgPSBbXTtcbmV4cG9ydCBjb25zdCBpbnRyb3MgPSB7IGVuYWJsZWQ6IGZhbHNlIH07XG5leHBvcnQgY29uc3QgYmluZGluZ19jYWxsYmFja3MgPSBbXTtcblxubGV0IHJlbmRlcl9jYWxsYmFja3MgPSBbXTtcblxuY29uc3QgZmx1c2hfY2FsbGJhY2tzID0gW107XG5cbmNvbnN0IHJlc29sdmVkX3Byb21pc2UgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbmxldCB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2hlZHVsZV91cGRhdGUoKSB7XG5cdGlmICghdXBkYXRlX3NjaGVkdWxlZCkge1xuXHRcdHVwZGF0ZV9zY2hlZHVsZWQgPSB0cnVlO1xuXHRcdHJlc29sdmVkX3Byb21pc2UudGhlbihmbHVzaCk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpY2soKSB7XG5cdHNjaGVkdWxlX3VwZGF0ZSgpO1xuXHRyZXR1cm4gcmVzb2x2ZWRfcHJvbWlzZTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9yZW5kZXJfY2FsbGJhY2soZm4pIHtcblx0cmVuZGVyX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9mbHVzaF9jYWxsYmFjayhmbikge1xuXHRmbHVzaF9jYWxsYmFja3MucHVzaChmbik7XG59XG5cbi8vIGZsdXNoKCkgY2FsbHMgY2FsbGJhY2tzIGluIHRoaXMgb3JkZXI6XG4vLyAxLiBBbGwgYmVmb3JlVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuXG4vLyAyLiBBbGwgYmluZDp0aGlzIGNhbGxiYWNrcywgaW4gcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyAzLiBBbGwgYWZ0ZXJVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW4uIEVYQ0VQVFxuLy8gICAgZm9yIGFmdGVyVXBkYXRlcyBjYWxsZWQgZHVyaW5nIHRoZSBpbml0aWFsIG9uTW91bnQsIHdoaWNoIGFyZSBjYWxsZWQgaW5cbi8vICAgIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gU2luY2UgY2FsbGJhY2tzIG1pZ2h0IHVwZGF0ZSBjb21wb25lbnQgdmFsdWVzLCB3aGljaCBjb3VsZCB0cmlnZ2VyIGFub3RoZXJcbi8vIGNhbGwgdG8gZmx1c2goKSwgdGhlIGZvbGxvd2luZyBzdGVwcyBndWFyZCBhZ2FpbnN0IHRoaXM6XG4vLyAxLiBEdXJpbmcgYmVmb3JlVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyAgICBkaXJ0eV9jb21wb25lbnRzIGFycmF5IGFuZCB3aWxsIGNhdXNlIGEgcmVlbnRyYW50IGNhbGwgdG8gZmx1c2goKS4gQmVjYXVzZVxuLy8gICAgdGhlIGZsdXNoIGluZGV4IGlzIGtlcHQgb3V0c2lkZSB0aGUgZnVuY3Rpb24sIHRoZSByZWVudHJhbnQgY2FsbCB3aWxsIHBpY2tcbi8vICAgIHVwIHdoZXJlIHRoZSBlYXJsaWVyIGNhbGwgbGVmdCBvZmYgYW5kIGdvIHRocm91Z2ggYWxsIGRpcnR5IGNvbXBvbmVudHMuIFRoZVxuLy8gICAgY3VycmVudF9jb21wb25lbnQgdmFsdWUgaXMgc2F2ZWQgYW5kIHJlc3RvcmVkIHNvIHRoYXQgdGhlIHJlZW50cmFudCBjYWxsIHdpbGxcbi8vICAgIG5vdCBpbnRlcmZlcmUgd2l0aCB0aGUgXCJwYXJlbnRcIiBmbHVzaCgpIGNhbGwuXG4vLyAyLiBiaW5kOnRoaXMgY2FsbGJhY2tzIGNhbm5vdCB0cmlnZ2VyIG5ldyBmbHVzaCgpIGNhbGxzLlxuLy8gMy4gRHVyaW5nIGFmdGVyVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgTk9UIGhhdmUgdGhlaXIgYWZ0ZXJVcGRhdGVcbi8vICAgIGNhbGxiYWNrIGNhbGxlZCBhIHNlY29uZCB0aW1lOyB0aGUgc2Vlbl9jYWxsYmFja3Mgc2V0LCBvdXRzaWRlIHRoZSBmbHVzaCgpXG4vLyAgICBmdW5jdGlvbiwgZ3VhcmFudGVlcyB0aGlzIGJlaGF2aW9yLlxuY29uc3Qgc2Vlbl9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5cbmxldCBmbHVzaGlkeCA9IDA7IC8vIERvICpub3QqIG1vdmUgdGhpcyBpbnNpZGUgdGhlIGZsdXNoKCkgZnVuY3Rpb25cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoKCkge1xuXHQvLyBEbyBub3QgcmVlbnRlciBmbHVzaCB3aGlsZSBkaXJ0eSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBhcyB0aGlzIGNhblxuXHQvLyByZXN1bHQgaW4gYW4gaW5maW5pdGUgbG9vcC4gSW5zdGVhZCwgbGV0IHRoZSBpbm5lciBmbHVzaCBoYW5kbGUgaXQuXG5cdC8vIFJlZW50cmFuY3kgaXMgb2sgYWZ0ZXJ3YXJkcyBmb3IgYmluZGluZ3MgZXRjLlxuXHRpZiAoZmx1c2hpZHggIT09IDApIHtcblx0XHRyZXR1cm47XG5cdH1cblx0Y29uc3Qgc2F2ZWRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG5cdGRvIHtcblx0XHQvLyBmaXJzdCwgY2FsbCBiZWZvcmVVcGRhdGUgZnVuY3Rpb25zXG5cdFx0Ly8gYW5kIHVwZGF0ZSBjb21wb25lbnRzXG5cdFx0dHJ5IHtcblx0XHRcdHdoaWxlIChmbHVzaGlkeCA8IGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGNvbnN0IGNvbXBvbmVudCA9IGRpcnR5X2NvbXBvbmVudHNbZmx1c2hpZHhdO1xuXHRcdFx0XHRmbHVzaGlkeCsrO1xuXHRcdFx0XHRzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcblx0XHRcdFx0dXBkYXRlKGNvbXBvbmVudC4kJCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gcmVzZXQgZGlydHkgc3RhdGUgdG8gbm90IGVuZCB1cCBpbiBhIGRlYWRsb2NrZWQgc3RhdGUgYW5kIHRoZW4gcmV0aHJvd1xuXHRcdFx0ZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuXHRcdFx0Zmx1c2hpZHggPSAwO1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuXHRcdGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcblx0XHRmbHVzaGlkeCA9IDA7XG5cdFx0d2hpbGUgKGJpbmRpbmdfY2FsbGJhY2tzLmxlbmd0aCkgYmluZGluZ19jYWxsYmFja3MucG9wKCkoKTtcblx0XHQvLyB0aGVuLCBvbmNlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGNhbGxcblx0XHQvLyBhZnRlclVwZGF0ZSBmdW5jdGlvbnMuIFRoaXMgbWF5IGNhdXNlXG5cdFx0Ly8gc3Vic2VxdWVudCB1cGRhdGVzLi4uXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRjb25zdCBjYWxsYmFjayA9IHJlbmRlcl9jYWxsYmFja3NbaV07XG5cdFx0XHRpZiAoIXNlZW5fY2FsbGJhY2tzLmhhcyhjYWxsYmFjaykpIHtcblx0XHRcdFx0Ly8gLi4uc28gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBsb29wc1xuXHRcdFx0XHRzZWVuX2NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZW5kZXJfY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG5cdH0gd2hpbGUgKGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKTtcblx0d2hpbGUgKGZsdXNoX2NhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRmbHVzaF9jYWxsYmFja3MucG9wKCkoKTtcblx0fVxuXHR1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5cdHNlZW5fY2FsbGJhY2tzLmNsZWFyKCk7XG5cdHNldF9jdXJyZW50X2NvbXBvbmVudChzYXZlZF9jb21wb25lbnQpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5mdW5jdGlvbiB1cGRhdGUoJCQpIHtcblx0aWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG5cdFx0JCQudXBkYXRlKCk7XG5cdFx0cnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcblx0XHRjb25zdCBkaXJ0eSA9ICQkLmRpcnR5O1xuXHRcdCQkLmRpcnR5ID0gWy0xXTtcblx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5wKCQkLmN0eCwgZGlydHkpO1xuXHRcdCQkLmFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xuXHR9XG59XG5cbi8qKlxuICogVXNlZnVsIGZvciBleGFtcGxlIHRvIGV4ZWN1dGUgcmVtYWluaW5nIGBhZnRlclVwZGF0ZWAgY2FsbGJhY2tzIGJlZm9yZSBleGVjdXRpbmcgYGRlc3Ryb3lgLlxuICogQHBhcmFtIHtGdW5jdGlvbltdfSBmbnNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hfcmVuZGVyX2NhbGxiYWNrcyhmbnMpIHtcblx0Y29uc3QgZmlsdGVyZWQgPSBbXTtcblx0Y29uc3QgdGFyZ2V0cyA9IFtdO1xuXHRyZW5kZXJfY2FsbGJhY2tzLmZvckVhY2goKGMpID0+IChmbnMuaW5kZXhPZihjKSA9PT0gLTEgPyBmaWx0ZXJlZC5wdXNoKGMpIDogdGFyZ2V0cy5wdXNoKGMpKSk7XG5cdHRhcmdldHMuZm9yRWFjaCgoYykgPT4gYygpKTtcblx0cmVuZGVyX2NhbGxiYWNrcyA9IGZpbHRlcmVkO1xufVxuIiwgImltcG9ydCB7IGlkZW50aXR5IGFzIGxpbmVhciwgaXNfZnVuY3Rpb24sIG5vb3AsIHJ1bl9hbGwgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IG5vdyB9IGZyb20gJy4vZW52aXJvbm1lbnQuanMnO1xuaW1wb3J0IHsgbG9vcCB9IGZyb20gJy4vbG9vcC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfcnVsZSwgZGVsZXRlX3J1bGUgfSBmcm9tICcuL3N0eWxlX21hbmFnZXIuanMnO1xuaW1wb3J0IHsgY3VzdG9tX2V2ZW50IH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgYWRkX3JlbmRlcl9jYWxsYmFjayB9IGZyb20gJy4vc2NoZWR1bGVyLmpzJztcblxuLyoqXG4gKiBAdHlwZSB7UHJvbWlzZTx2b2lkPiB8IG51bGx9XG4gKi9cbmxldCBwcm9taXNlO1xuXG4vKipcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5mdW5jdGlvbiB3YWl0KCkge1xuXHRpZiAoIXByb21pc2UpIHtcblx0XHRwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0cHJvbWlzZS50aGVuKCgpID0+IHtcblx0XHRcdHByb21pc2UgPSBudWxsO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBwcm9taXNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtJTlRSTyB8IE9VVFJPIHwgYm9vbGVhbn0gZGlyZWN0aW9uXG4gKiBAcGFyYW0geydzdGFydCcgfCAnZW5kJ30ga2luZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGRpc3BhdGNoKG5vZGUsIGRpcmVjdGlvbiwga2luZCkge1xuXHRub2RlLmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KGAke2RpcmVjdGlvbiA/ICdpbnRybycgOiAnb3V0cm8nfSR7a2luZH1gKSk7XG59XG5cbmNvbnN0IG91dHJvaW5nID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIEB0eXBlIHtPdXRyb31cbiAqL1xubGV0IG91dHJvcztcblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBncm91cF9vdXRyb3MoKSB7XG5cdG91dHJvcyA9IHtcblx0XHRyOiAwLFxuXHRcdGM6IFtdLFxuXHRcdHA6IG91dHJvcyAvLyBwYXJlbnQgZ3JvdXBcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja19vdXRyb3MoKSB7XG5cdGlmICghb3V0cm9zLnIpIHtcblx0XHRydW5fYWxsKG91dHJvcy5jKTtcblx0fVxuXHRvdXRyb3MgPSBvdXRyb3MucDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuRnJhZ21lbnR9IGJsb2NrXG4gKiBAcGFyYW0gezAgfCAxfSBbbG9jYWxdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zaXRpb25faW4oYmxvY2ssIGxvY2FsKSB7XG5cdGlmIChibG9jayAmJiBibG9jay5pKSB7XG5cdFx0b3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcblx0XHRibG9jay5pKGxvY2FsKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5GcmFnbWVudH0gYmxvY2tcbiAqIEBwYXJhbSB7MCB8IDF9IGxvY2FsXG4gKiBAcGFyYW0gezAgfCAxfSBbZGV0YWNoXVxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zaXRpb25fb3V0KGJsb2NrLCBsb2NhbCwgZGV0YWNoLCBjYWxsYmFjaykge1xuXHRpZiAoYmxvY2sgJiYgYmxvY2subykge1xuXHRcdGlmIChvdXRyb2luZy5oYXMoYmxvY2spKSByZXR1cm47XG5cdFx0b3V0cm9pbmcuYWRkKGJsb2NrKTtcblx0XHRvdXRyb3MuYy5wdXNoKCgpID0+IHtcblx0XHRcdG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0aWYgKGRldGFjaCkgYmxvY2suZCgxKTtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRibG9jay5vKGxvY2FsKTtcblx0fSBlbHNlIGlmIChjYWxsYmFjaykge1xuXHRcdGNhbGxiYWNrKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuLi90cmFuc2l0aW9uL3B1YmxpYy5qcycpLlRyYW5zaXRpb25Db25maWd9XG4gKi9cbmNvbnN0IG51bGxfdHJhbnNpdGlvbiA9IHsgZHVyYXRpb246IDAgfTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbkZufSBmblxuICogQHBhcmFtIHthbnl9IHBhcmFtc1xuICogQHJldHVybnMge3sgc3RhcnQoKTogdm9pZDsgaW52YWxpZGF0ZSgpOiB2b2lkOyBlbmQoKTogdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9pbl90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtUcmFuc2l0aW9uT3B0aW9uc30gKi9cblx0Y29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnaW4nIH07XG5cdGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuXHRsZXQgcnVubmluZyA9IGZhbHNlO1xuXHRsZXQgYW5pbWF0aW9uX25hbWU7XG5cdGxldCB0YXNrO1xuXHRsZXQgdWlkID0gMDtcblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGNsZWFudXAoKSB7XG5cdFx0aWYgKGFuaW1hdGlvbl9uYW1lKSBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGdvKCkge1xuXHRcdGNvbnN0IHtcblx0XHRcdGRlbGF5ID0gMCxcblx0XHRcdGR1cmF0aW9uID0gMzAwLFxuXHRcdFx0ZWFzaW5nID0gbGluZWFyLFxuXHRcdFx0dGljayA9IG5vb3AsXG5cdFx0XHRjc3Ncblx0XHR9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcblx0XHRpZiAoY3NzKSBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MsIHVpZCsrKTtcblx0XHR0aWNrKDAsIDEpO1xuXHRcdGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuXHRcdGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuXHRcdGlmICh0YXNrKSB0YXNrLmFib3J0KCk7XG5cdFx0cnVubmluZyA9IHRydWU7XG5cdFx0YWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCB0cnVlLCAnc3RhcnQnKSk7XG5cdFx0dGFzayA9IGxvb3AoKG5vdykgPT4ge1xuXHRcdFx0aWYgKHJ1bm5pbmcpIHtcblx0XHRcdFx0aWYgKG5vdyA+PSBlbmRfdGltZSkge1xuXHRcdFx0XHRcdHRpY2soMSwgMCk7XG5cdFx0XHRcdFx0ZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ2VuZCcpO1xuXHRcdFx0XHRcdGNsZWFudXAoKTtcblx0XHRcdFx0XHRyZXR1cm4gKHJ1bm5pbmcgPSBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG5cdFx0XHRcdFx0dGljayh0LCAxIC0gdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBydW5uaW5nO1xuXHRcdH0pO1xuXHR9XG5cdGxldCBzdGFydGVkID0gZmFsc2U7XG5cdHJldHVybiB7XG5cdFx0c3RhcnQoKSB7XG5cdFx0XHRpZiAoc3RhcnRlZCkgcmV0dXJuO1xuXHRcdFx0c3RhcnRlZCA9IHRydWU7XG5cdFx0XHRkZWxldGVfcnVsZShub2RlKTtcblx0XHRcdGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG5cdFx0XHRcdGNvbmZpZyA9IGNvbmZpZyhvcHRpb25zKTtcblx0XHRcdFx0d2FpdCgpLnRoZW4oZ28pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z28oKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGludmFsaWRhdGUoKSB7XG5cdFx0XHRzdGFydGVkID0gZmFsc2U7XG5cdFx0fSxcblx0XHRlbmQoKSB7XG5cdFx0XHRpZiAocnVubmluZykge1xuXHRcdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRcdHJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge1RyYW5zaXRpb25Gbn0gZm5cbiAqIEBwYXJhbSB7YW55fSBwYXJhbXNcbiAqIEByZXR1cm5zIHt7IGVuZChyZXNldDogYW55KTogdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG5cdC8qKiBAdHlwZSB7VHJhbnNpdGlvbk9wdGlvbnN9ICovXG5cdGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ291dCcgfTtcblx0bGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG5cdGxldCBydW5uaW5nID0gdHJ1ZTtcblx0bGV0IGFuaW1hdGlvbl9uYW1lO1xuXHRjb25zdCBncm91cCA9IG91dHJvcztcblx0Z3JvdXAuciArPSAxO1xuXHQvKiogQHR5cGUge2Jvb2xlYW59ICovXG5cdGxldCBvcmlnaW5hbF9pbmVydF92YWx1ZTtcblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGdvKCkge1xuXHRcdGNvbnN0IHtcblx0XHRcdGRlbGF5ID0gMCxcblx0XHRcdGR1cmF0aW9uID0gMzAwLFxuXHRcdFx0ZWFzaW5nID0gbGluZWFyLFxuXHRcdFx0dGljayA9IG5vb3AsXG5cdFx0XHRjc3Ncblx0XHR9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcblxuXHRcdGlmIChjc3MpIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMSwgMCwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG5cblx0XHRjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcblx0XHRjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcblx0XHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnc3RhcnQnKSk7XG5cblx0XHRpZiAoJ2luZXJ0JyBpbiBub2RlKSB7XG5cdFx0XHRvcmlnaW5hbF9pbmVydF92YWx1ZSA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChub2RlKS5pbmVydDtcblx0XHRcdG5vZGUuaW5lcnQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGxvb3AoKG5vdykgPT4ge1xuXHRcdFx0aWYgKHJ1bm5pbmcpIHtcblx0XHRcdFx0aWYgKG5vdyA+PSBlbmRfdGltZSkge1xuXHRcdFx0XHRcdHRpY2soMCwgMSk7XG5cdFx0XHRcdFx0ZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdlbmQnKTtcblx0XHRcdFx0XHRpZiAoIS0tZ3JvdXAucikge1xuXHRcdFx0XHRcdFx0Ly8gdGhpcyB3aWxsIHJlc3VsdCBpbiBgZW5kKClgIGJlaW5nIGNhbGxlZCxcblx0XHRcdFx0XHRcdC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gY2xlYW4gdXAgaGVyZVxuXHRcdFx0XHRcdFx0cnVuX2FsbChncm91cC5jKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuXHRcdFx0XHRcdGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuXHRcdFx0XHRcdHRpY2soMSAtIHQsIHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcnVubmluZztcblx0XHR9KTtcblx0fVxuXG5cdGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG5cdFx0d2FpdCgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0Y29uZmlnID0gY29uZmlnKG9wdGlvbnMpO1xuXHRcdFx0Z28oKTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRnbygpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRlbmQocmVzZXQpIHtcblx0XHRcdGlmIChyZXNldCAmJiAnaW5lcnQnIGluIG5vZGUpIHtcblx0XHRcdFx0bm9kZS5pbmVydCA9IG9yaWdpbmFsX2luZXJ0X3ZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJlc2V0ICYmIGNvbmZpZy50aWNrKSB7XG5cdFx0XHRcdGNvbmZpZy50aWNrKDEsIDApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJ1bm5pbmcpIHtcblx0XHRcdFx0aWYgKGFuaW1hdGlvbl9uYW1lKSBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG5cdFx0XHRcdHJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge1RyYW5zaXRpb25Gbn0gZm5cbiAqIEBwYXJhbSB7YW55fSBwYXJhbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW50cm9cbiAqIEByZXR1cm5zIHt7IHJ1bihiOiAwIHwgMSk6IHZvaWQ7IGVuZCgpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zLCBpbnRybykge1xuXHQvKipcblx0ICogQHR5cGUge1RyYW5zaXRpb25PcHRpb25zfSAqL1xuXHRjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdib3RoJyB9O1xuXHRsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcblx0bGV0IHQgPSBpbnRybyA/IDAgOiAxO1xuXG5cdC8qKlxuXHQgKiBAdHlwZSB7UHJvZ3JhbSB8IG51bGx9ICovXG5cdGxldCBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBAdHlwZSB7UGVuZGluZ1Byb2dyYW0gfCBudWxsfSAqL1xuXHRsZXQgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcblx0bGV0IGFuaW1hdGlvbl9uYW1lID0gbnVsbDtcblxuXHQvKiogQHR5cGUge2Jvb2xlYW59ICovXG5cdGxldCBvcmlnaW5hbF9pbmVydF92YWx1ZTtcblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGNsZWFyX2FuaW1hdGlvbigpIHtcblx0XHRpZiAoYW5pbWF0aW9uX25hbWUpIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1BlbmRpbmdQcm9ncmFtfSBwcm9ncmFtXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxuXHQgKiBAcmV0dXJucyB7UHJvZ3JhbX1cblx0ICovXG5cdGZ1bmN0aW9uIGluaXQocHJvZ3JhbSwgZHVyYXRpb24pIHtcblx0XHRjb25zdCBkID0gLyoqIEB0eXBlIHtQcm9ncmFtWydkJ119ICovIChwcm9ncmFtLmIgLSB0KTtcblx0XHRkdXJhdGlvbiAqPSBNYXRoLmFicyhkKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0YTogdCxcblx0XHRcdGI6IHByb2dyYW0uYixcblx0XHRcdGQsXG5cdFx0XHRkdXJhdGlvbixcblx0XHRcdHN0YXJ0OiBwcm9ncmFtLnN0YXJ0LFxuXHRcdFx0ZW5kOiBwcm9ncmFtLnN0YXJ0ICsgZHVyYXRpb24sXG5cdFx0XHRncm91cDogcHJvZ3JhbS5ncm91cFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJTlRSTyB8IE9VVFJPfSBiXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gZ28oYikge1xuXHRcdGNvbnN0IHtcblx0XHRcdGRlbGF5ID0gMCxcblx0XHRcdGR1cmF0aW9uID0gMzAwLFxuXHRcdFx0ZWFzaW5nID0gbGluZWFyLFxuXHRcdFx0dGljayA9IG5vb3AsXG5cdFx0XHRjc3Ncblx0XHR9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtQZW5kaW5nUHJvZ3JhbX0gKi9cblx0XHRjb25zdCBwcm9ncmFtID0ge1xuXHRcdFx0c3RhcnQ6IG5vdygpICsgZGVsYXksXG5cdFx0XHRiXG5cdFx0fTtcblxuXHRcdGlmICghYikge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3Ncblx0XHRcdHByb2dyYW0uZ3JvdXAgPSBvdXRyb3M7XG5cdFx0XHRvdXRyb3MuciArPSAxO1xuXHRcdH1cblxuXHRcdGlmICgnaW5lcnQnIGluIG5vZGUpIHtcblx0XHRcdGlmIChiKSB7XG5cdFx0XHRcdGlmIChvcmlnaW5hbF9pbmVydF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Ly8gYWJvcnRlZC9yZXZlcnNlZCBvdXRybyBcdTIwMTQgcmVzdG9yZSBwcmV2aW91cyBpbmVydCB2YWx1ZVxuXHRcdFx0XHRcdG5vZGUuaW5lcnQgPSBvcmlnaW5hbF9pbmVydF92YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3JpZ2luYWxfaW5lcnRfdmFsdWUgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAobm9kZSkuaW5lcnQ7XG5cdFx0XHRcdG5vZGUuaW5lcnQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKSB7XG5cdFx0XHRwZW5kaW5nX3Byb2dyYW0gPSBwcm9ncmFtO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpZiB0aGlzIGlzIGFuIGludHJvLCBhbmQgdGhlcmUncyBhIGRlbGF5LCB3ZSBuZWVkIHRvIGRvXG5cdFx0XHQvLyBhbiBpbml0aWFsIHRpY2sgYW5kL29yIGFwcGx5IENTUyBhbmltYXRpb24gaW1tZWRpYXRlbHlcblx0XHRcdGlmIChjc3MpIHtcblx0XHRcdFx0Y2xlYXJfYW5pbWF0aW9uKCk7XG5cdFx0XHRcdGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYikgdGljaygwLCAxKTtcblx0XHRcdHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocHJvZ3JhbSwgZHVyYXRpb24pO1xuXHRcdFx0YWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBiLCAnc3RhcnQnKSk7XG5cdFx0XHRsb29wKChub3cpID0+IHtcblx0XHRcdFx0aWYgKHBlbmRpbmdfcHJvZ3JhbSAmJiBub3cgPiBwZW5kaW5nX3Byb2dyYW0uc3RhcnQpIHtcblx0XHRcdFx0XHRydW5uaW5nX3Byb2dyYW0gPSBpbml0KHBlbmRpbmdfcHJvZ3JhbSwgZHVyYXRpb24pO1xuXHRcdFx0XHRcdHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG5cdFx0XHRcdFx0ZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdzdGFydCcpO1xuXHRcdFx0XHRcdGlmIChjc3MpIHtcblx0XHRcdFx0XHRcdGNsZWFyX2FuaW1hdGlvbigpO1xuXHRcdFx0XHRcdFx0YW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShcblx0XHRcdFx0XHRcdFx0bm9kZSxcblx0XHRcdFx0XHRcdFx0dCxcblx0XHRcdFx0XHRcdFx0cnVubmluZ19wcm9ncmFtLmIsXG5cdFx0XHRcdFx0XHRcdHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbixcblx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0ZWFzaW5nLFxuXHRcdFx0XHRcdFx0XHRjb25maWcuY3NzXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocnVubmluZ19wcm9ncmFtKSB7XG5cdFx0XHRcdFx0aWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uZW5kKSB7XG5cdFx0XHRcdFx0XHR0aWNrKCh0ID0gcnVubmluZ19wcm9ncmFtLmIpLCAxIC0gdCk7XG5cdFx0XHRcdFx0XHRkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ2VuZCcpO1xuXHRcdFx0XHRcdFx0aWYgKCFwZW5kaW5nX3Byb2dyYW0pIHtcblx0XHRcdFx0XHRcdFx0Ly8gd2UncmUgZG9uZVxuXHRcdFx0XHRcdFx0XHRpZiAocnVubmluZ19wcm9ncmFtLmIpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBpbnRybyBcdTIwMTQgd2UgY2FuIHRpZHkgdXAgaW1tZWRpYXRlbHlcblx0XHRcdFx0XHRcdFx0XHRjbGVhcl9hbmltYXRpb24oKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBvdXRybyBcdTIwMTQgbmVlZHMgdG8gYmUgY29vcmRpbmF0ZWRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIS0tcnVubmluZ19wcm9ncmFtLmdyb3VwLnIpIHJ1bl9hbGwocnVubmluZ19wcm9ncmFtLmdyb3VwLmMpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5zdGFydCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgcCA9IG5vdyAtIHJ1bm5pbmdfcHJvZ3JhbS5zdGFydDtcblx0XHRcdFx0XHRcdHQgPSBydW5uaW5nX3Byb2dyYW0uYSArIHJ1bm5pbmdfcHJvZ3JhbS5kICogZWFzaW5nKHAgLyBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24pO1xuXHRcdFx0XHRcdFx0dGljayh0LCAxIC0gdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAhIShydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4ge1xuXHRcdHJ1bihiKSB7XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuXHRcdFx0XHR3YWl0KCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qgb3B0cyA9IHsgZGlyZWN0aW9uOiBiID8gJ2luJyA6ICdvdXQnIH07XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdGNvbmZpZyA9IGNvbmZpZyhvcHRzKTtcblx0XHRcdFx0XHRnbyhiKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRnbyhiKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGVuZCgpIHtcblx0XHRcdGNsZWFyX2FuaW1hdGlvbigpO1xuXHRcdFx0cnVubmluZ19wcm9ncmFtID0gcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcblx0XHR9XG5cdH07XG59XG5cbi8qKiBAdHlwZWRlZiB7MX0gSU5UUk8gKi9cbi8qKiBAdHlwZWRlZiB7MH0gT1VUUk8gKi9cbi8qKiBAdHlwZWRlZiB7eyBkaXJlY3Rpb246ICdpbicgfCAnb3V0JyB8ICdib3RoJyB9fSBUcmFuc2l0aW9uT3B0aW9ucyAqL1xuLyoqIEB0eXBlZGVmIHsobm9kZTogRWxlbWVudCwgcGFyYW1zOiBhbnksIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zKSA9PiBpbXBvcnQoJy4uL3RyYW5zaXRpb24vcHVibGljLmpzJykuVHJhbnNpdGlvbkNvbmZpZ30gVHJhbnNpdGlvbkZuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3V0cm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9uW119IGNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQZW5kaW5nUHJvZ3JhbVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0XG4gKiBAcHJvcGVydHkge0lOVFJPfE9VVFJPfSBiXG4gKiBAcHJvcGVydHkge091dHJvfSBbZ3JvdXBdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9ncmFtXG4gKiBAcHJvcGVydHkge251bWJlcn0gYVxuICogQHByb3BlcnR5IHtJTlRST3xPVVRST30gYlxuICogQHByb3BlcnR5IHsxfC0xfSBkXG4gKiBAcHJvcGVydHkge251bWJlcn0gZHVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZFxuICogQHByb3BlcnR5IHtPdXRyb30gW2dyb3VwXVxuICovXG4iLCAiaW1wb3J0IHsgdHJhbnNpdGlvbl9pbiwgdHJhbnNpdGlvbl9vdXQgfSBmcm9tICcuL3RyYW5zaXRpb25zLmpzJztcbmltcG9ydCB7IHJ1bl9hbGwgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLy8gZ2VuZXJhbCBlYWNoIGZ1bmN0aW9uczpcblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZV9hcnJheV9saWtlKGFycmF5X2xpa2Vfb3JfaXRlcmF0b3IpIHtcblx0cmV0dXJuIGFycmF5X2xpa2Vfb3JfaXRlcmF0b3I/Lmxlbmd0aCAhPT0gdW5kZWZpbmVkXG5cdFx0PyBhcnJheV9saWtlX29yX2l0ZXJhdG9yXG5cdFx0OiBBcnJheS5mcm9tKGFycmF5X2xpa2Vfb3JfaXRlcmF0b3IpO1xufVxuXG4vLyBrZXllZCBlYWNoIGZ1bmN0aW9uczpcblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuXHRibG9jay5kKDEpO1xuXHRsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG5cdHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG5cdFx0bG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xuXHR9KTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpeF9hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG5cdGJsb2NrLmYoKTtcblx0ZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuXHRibG9jay5mKCk7XG5cdG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuXG4vKiogQHJldHVybnMge2FueVtdfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9rZXllZF9lYWNoKFxuXHRvbGRfYmxvY2tzLFxuXHRkaXJ0eSxcblx0Z2V0X2tleSxcblx0ZHluYW1pYyxcblx0Y3R4LFxuXHRsaXN0LFxuXHRsb29rdXAsXG5cdG5vZGUsXG5cdGRlc3Ryb3ksXG5cdGNyZWF0ZV9lYWNoX2Jsb2NrLFxuXHRuZXh0LFxuXHRnZXRfY29udGV4dFxuKSB7XG5cdGxldCBvID0gb2xkX2Jsb2Nrcy5sZW5ndGg7XG5cdGxldCBuID0gbGlzdC5sZW5ndGg7XG5cdGxldCBpID0gbztcblx0Y29uc3Qgb2xkX2luZGV4ZXMgPSB7fTtcblx0d2hpbGUgKGktLSkgb2xkX2luZGV4ZXNbb2xkX2Jsb2Nrc1tpXS5rZXldID0gaTtcblx0Y29uc3QgbmV3X2Jsb2NrcyA9IFtdO1xuXHRjb25zdCBuZXdfbG9va3VwID0gbmV3IE1hcCgpO1xuXHRjb25zdCBkZWx0YXMgPSBuZXcgTWFwKCk7XG5cdGNvbnN0IHVwZGF0ZXMgPSBbXTtcblx0aSA9IG47XG5cdHdoaWxlIChpLS0pIHtcblx0XHRjb25zdCBjaGlsZF9jdHggPSBnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpO1xuXHRcdGNvbnN0IGtleSA9IGdldF9rZXkoY2hpbGRfY3R4KTtcblx0XHRsZXQgYmxvY2sgPSBsb29rdXAuZ2V0KGtleSk7XG5cdFx0aWYgKCFibG9jaykge1xuXHRcdFx0YmxvY2sgPSBjcmVhdGVfZWFjaF9ibG9jayhrZXksIGNoaWxkX2N0eCk7XG5cdFx0XHRibG9jay5jKCk7XG5cdFx0fSBlbHNlIGlmIChkeW5hbWljKSB7XG5cdFx0XHQvLyBkZWZlciB1cGRhdGVzIHVudGlsIGFsbCB0aGUgRE9NIHNodWZmbGluZyBpcyBkb25lXG5cdFx0XHR1cGRhdGVzLnB1c2goKCkgPT4gYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KSk7XG5cdFx0fVxuXHRcdG5ld19sb29rdXAuc2V0KGtleSwgKG5ld19ibG9ja3NbaV0gPSBibG9jaykpO1xuXHRcdGlmIChrZXkgaW4gb2xkX2luZGV4ZXMpIGRlbHRhcy5zZXQoa2V5LCBNYXRoLmFicyhpIC0gb2xkX2luZGV4ZXNba2V5XSkpO1xuXHR9XG5cdGNvbnN0IHdpbGxfbW92ZSA9IG5ldyBTZXQoKTtcblx0Y29uc3QgZGlkX21vdmUgPSBuZXcgU2V0KCk7XG5cdC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gaW5zZXJ0KGJsb2NrKSB7XG5cdFx0dHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG5cdFx0YmxvY2subShub2RlLCBuZXh0KTtcblx0XHRsb29rdXAuc2V0KGJsb2NrLmtleSwgYmxvY2spO1xuXHRcdG5leHQgPSBibG9jay5maXJzdDtcblx0XHRuLS07XG5cdH1cblx0d2hpbGUgKG8gJiYgbikge1xuXHRcdGNvbnN0IG5ld19ibG9jayA9IG5ld19ibG9ja3NbbiAtIDFdO1xuXHRcdGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3NbbyAtIDFdO1xuXHRcdGNvbnN0IG5ld19rZXkgPSBuZXdfYmxvY2sua2V5O1xuXHRcdGNvbnN0IG9sZF9rZXkgPSBvbGRfYmxvY2sua2V5O1xuXHRcdGlmIChuZXdfYmxvY2sgPT09IG9sZF9ibG9jaykge1xuXHRcdFx0Ly8gZG8gbm90aGluZ1xuXHRcdFx0bmV4dCA9IG5ld19ibG9jay5maXJzdDtcblx0XHRcdG8tLTtcblx0XHRcdG4tLTtcblx0XHR9IGVsc2UgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfa2V5KSkge1xuXHRcdFx0Ly8gcmVtb3ZlIG9sZCBibG9ja1xuXHRcdFx0ZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG5cdFx0XHRvLS07XG5cdFx0fSBlbHNlIGlmICghbG9va3VwLmhhcyhuZXdfa2V5KSB8fCB3aWxsX21vdmUuaGFzKG5ld19rZXkpKSB7XG5cdFx0XHRpbnNlcnQobmV3X2Jsb2NrKTtcblx0XHR9IGVsc2UgaWYgKGRpZF9tb3ZlLmhhcyhvbGRfa2V5KSkge1xuXHRcdFx0by0tO1xuXHRcdH0gZWxzZSBpZiAoZGVsdGFzLmdldChuZXdfa2V5KSA+IGRlbHRhcy5nZXQob2xkX2tleSkpIHtcblx0XHRcdGRpZF9tb3ZlLmFkZChuZXdfa2V5KTtcblx0XHRcdGluc2VydChuZXdfYmxvY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aWxsX21vdmUuYWRkKG9sZF9rZXkpO1xuXHRcdFx0by0tO1xuXHRcdH1cblx0fVxuXHR3aGlsZSAoby0tKSB7XG5cdFx0Y29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvXTtcblx0XHRpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9ibG9jay5rZXkpKSBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcblx0fVxuXHR3aGlsZSAobikgaW5zZXJ0KG5ld19ibG9ja3NbbiAtIDFdKTtcblx0cnVuX2FsbCh1cGRhdGVzKTtcblx0cmV0dXJuIG5ld19ibG9ja3M7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2tleXMoY3R4LCBsaXN0LCBnZXRfY29udGV4dCwgZ2V0X2tleSkge1xuXHRjb25zdCBrZXlzID0gbmV3IE1hcCgpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBrZXkgPSBnZXRfa2V5KGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSkpO1xuXHRcdGlmIChrZXlzLmhhcyhrZXkpKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSAnJztcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhbHVlID0gYHdpdGggdmFsdWUgJyR7U3RyaW5nKGtleSl9JyBgO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBjYW4ndCBzdHJpbmdpZnlcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0YENhbm5vdCBoYXZlIGR1cGxpY2F0ZSBrZXlzIGluIGEga2V5ZWQgZWFjaDogS2V5cyBhdCBpbmRleCAke2tleXMuZ2V0KFxuXHRcdFx0XHRcdGtleVxuXHRcdFx0XHQpfSBhbmQgJHtpfSAke3ZhbHVlfWFyZSBkdXBsaWNhdGVzYFxuXHRcdFx0KTtcblx0XHR9XG5cdFx0a2V5cy5zZXQoa2V5LCBpKTtcblx0fVxufVxuIiwgIi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3NwcmVhZF91cGRhdGUobGV2ZWxzLCB1cGRhdGVzKSB7XG5cdGNvbnN0IHVwZGF0ZSA9IHt9O1xuXHRjb25zdCB0b19udWxsX291dCA9IHt9O1xuXHRjb25zdCBhY2NvdW50ZWRfZm9yID0geyAkJHNjb3BlOiAxIH07XG5cdGxldCBpID0gbGV2ZWxzLmxlbmd0aDtcblx0d2hpbGUgKGktLSkge1xuXHRcdGNvbnN0IG8gPSBsZXZlbHNbaV07XG5cdFx0Y29uc3QgbiA9IHVwZGF0ZXNbaV07XG5cdFx0aWYgKG4pIHtcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIG8pIHtcblx0XHRcdFx0aWYgKCEoa2V5IGluIG4pKSB0b19udWxsX291dFtrZXldID0gMTtcblx0XHRcdH1cblx0XHRcdGZvciAoY29uc3Qga2V5IGluIG4pIHtcblx0XHRcdFx0aWYgKCFhY2NvdW50ZWRfZm9yW2tleV0pIHtcblx0XHRcdFx0XHR1cGRhdGVba2V5XSA9IG5ba2V5XTtcblx0XHRcdFx0XHRhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsZXZlbHNbaV0gPSBuO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG5cdFx0XHRcdGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZvciAoY29uc3Qga2V5IGluIHRvX251bGxfb3V0KSB7XG5cdFx0aWYgKCEoa2V5IGluIHVwZGF0ZSkpIHVwZGF0ZVtrZXldID0gdW5kZWZpbmVkO1xuXHR9XG5cdHJldHVybiB1cGRhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfc3ByZWFkX29iamVjdChzcHJlYWRfcHJvcHMpIHtcblx0cmV0dXJuIHR5cGVvZiBzcHJlYWRfcHJvcHMgPT09ICdvYmplY3QnICYmIHNwcmVhZF9wcm9wcyAhPT0gbnVsbCA/IHNwcmVhZF9wcm9wcyA6IHt9O1xufVxuIiwgImNvbnN0IF9ib29sZWFuX2F0dHJpYnV0ZXMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuXHQnYWxsb3dmdWxsc2NyZWVuJyxcblx0J2FsbG93cGF5bWVudHJlcXVlc3QnLFxuXHQnYXN5bmMnLFxuXHQnYXV0b2ZvY3VzJyxcblx0J2F1dG9wbGF5Jyxcblx0J2NoZWNrZWQnLFxuXHQnY29udHJvbHMnLFxuXHQnZGVmYXVsdCcsXG5cdCdkZWZlcicsXG5cdCdkaXNhYmxlZCcsXG5cdCdmb3Jtbm92YWxpZGF0ZScsXG5cdCdoaWRkZW4nLFxuXHQnaW5lcnQnLFxuXHQnaXNtYXAnLFxuXHQnbG9vcCcsXG5cdCdtdWx0aXBsZScsXG5cdCdtdXRlZCcsXG5cdCdub21vZHVsZScsXG5cdCdub3ZhbGlkYXRlJyxcblx0J29wZW4nLFxuXHQncGxheXNpbmxpbmUnLFxuXHQncmVhZG9ubHknLFxuXHQncmVxdWlyZWQnLFxuXHQncmV2ZXJzZWQnLFxuXHQnc2VsZWN0ZWQnXG5dKTtcblxuLyoqXG4gKiBMaXN0IG9mIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzIChlLmcuIGA8aW5wdXQgZGlzYWJsZWQ+YCkuXG4gKiBTb3VyY2U6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbFxuICpcbiAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGJvb2xlYW5fYXR0cmlidXRlcyA9IG5ldyBTZXQoWy4uLl9ib29sZWFuX2F0dHJpYnV0ZXNdKTtcblxuLyoqIEB0eXBlZGVmIHt0eXBlb2YgX2Jvb2xlYW5fYXR0cmlidXRlc1tudW1iZXJdfSBCb29sZWFuQXR0cmlidXRlcyAqL1xuIiwgImltcG9ydCB7XG5cdGFkZF9yZW5kZXJfY2FsbGJhY2ssXG5cdGZsdXNoLFxuXHRmbHVzaF9yZW5kZXJfY2FsbGJhY2tzLFxuXHRzY2hlZHVsZV91cGRhdGUsXG5cdGRpcnR5X2NvbXBvbmVudHNcbn0gZnJvbSAnLi9zY2hlZHVsZXIuanMnO1xuaW1wb3J0IHsgY3VycmVudF9jb21wb25lbnQsIHNldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IGJsYW5rX29iamVjdCwgaXNfZW1wdHksIGlzX2Z1bmN0aW9uLCBydW4sIHJ1bl9hbGwsIG5vb3AgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdGNoaWxkcmVuLFxuXHRkZXRhY2gsXG5cdHN0YXJ0X2h5ZHJhdGluZyxcblx0ZW5kX2h5ZHJhdGluZyxcblx0Z2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyxcblx0aW5zZXJ0LFxuXHRlbGVtZW50LFxuXHRhdHRyXG59IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IHRyYW5zaXRpb25faW4gfSBmcm9tICcuL3RyYW5zaXRpb25zLmpzJztcblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmQoY29tcG9uZW50LCBuYW1lLCBjYWxsYmFjaykge1xuXHRjb25zdCBpbmRleCA9IGNvbXBvbmVudC4kJC5wcm9wc1tuYW1lXTtcblx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRjb21wb25lbnQuJCQuYm91bmRbaW5kZXhdID0gY2FsbGJhY2s7XG5cdFx0Y2FsbGJhY2soY29tcG9uZW50LiQkLmN0eFtpbmRleF0pO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfY29tcG9uZW50KGJsb2NrKSB7XG5cdGJsb2NrICYmIGJsb2NrLmMoKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX2NvbXBvbmVudChibG9jaywgcGFyZW50X25vZGVzKSB7XG5cdGJsb2NrICYmIGJsb2NrLmwocGFyZW50X25vZGVzKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yKSB7XG5cdGNvbnN0IHsgZnJhZ21lbnQsIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuXHRmcmFnbWVudCAmJiBmcmFnbWVudC5tKHRhcmdldCwgYW5jaG9yKTtcblx0Ly8gb25Nb3VudCBoYXBwZW5zIGJlZm9yZSB0aGUgaW5pdGlhbCBhZnRlclVwZGF0ZVxuXHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IHtcblx0XHRjb25zdCBuZXdfb25fZGVzdHJveSA9IGNvbXBvbmVudC4kJC5vbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuXHRcdC8vIGlmIHRoZSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseVxuXHRcdC8vIGl0IHdpbGwgdXBkYXRlIHRoZSBgJCQub25fZGVzdHJveWAgcmVmZXJlbmNlIHRvIGBudWxsYC5cblx0XHQvLyB0aGUgZGVzdHJ1Y3R1cmVkIG9uX2Rlc3Ryb3kgbWF5IHN0aWxsIHJlZmVyZW5jZSB0byB0aGUgb2xkIGFycmF5XG5cdFx0aWYgKGNvbXBvbmVudC4kJC5vbl9kZXN0cm95KSB7XG5cdFx0XHRjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKC4uLm5ld19vbl9kZXN0cm95KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRWRnZSBjYXNlIC0gY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHksXG5cdFx0XHQvLyBtb3N0IGxpa2VseSBhcyBhIHJlc3VsdCBvZiBhIGJpbmRpbmcgaW5pdGlhbGlzaW5nXG5cdFx0XHRydW5fYWxsKG5ld19vbl9kZXN0cm95KTtcblx0XHR9XG5cdFx0Y29tcG9uZW50LiQkLm9uX21vdW50ID0gW107XG5cdH0pO1xuXHRhZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfY29tcG9uZW50KGNvbXBvbmVudCwgZGV0YWNoaW5nKSB7XG5cdGNvbnN0ICQkID0gY29tcG9uZW50LiQkO1xuXHRpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcblx0XHRmbHVzaF9yZW5kZXJfY2FsbGJhY2tzKCQkLmFmdGVyX3VwZGF0ZSk7XG5cdFx0cnVuX2FsbCgkJC5vbl9kZXN0cm95KTtcblx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5kKGRldGFjaGluZyk7XG5cdFx0Ly8gVE9ETyBudWxsIG91dCBvdGhlciByZWZzLCBpbmNsdWRpbmcgY29tcG9uZW50LiQkIChidXQgbmVlZCB0b1xuXHRcdC8vIHByZXNlcnZlIGZpbmFsIHN0YXRlPylcblx0XHQkJC5vbl9kZXN0cm95ID0gJCQuZnJhZ21lbnQgPSBudWxsO1xuXHRcdCQkLmN0eCA9IFtdO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmZ1bmN0aW9uIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKSB7XG5cdGlmIChjb21wb25lbnQuJCQuZGlydHlbMF0gPT09IC0xKSB7XG5cdFx0ZGlydHlfY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG5cdFx0c2NoZWR1bGVfdXBkYXRlKCk7XG5cdFx0Y29tcG9uZW50LiQkLmRpcnR5LmZpbGwoMCk7XG5cdH1cblx0Y29tcG9uZW50LiQkLmRpcnR5WyhpIC8gMzEpIHwgMF0gfD0gMSA8PCBpICUgMzE7XG59XG5cbi8vIFRPRE86IERvY3VtZW50IHRoZSBvdGhlciBwYXJhbXNcbi8qKlxuICogQHBhcmFtIHtTdmVsdGVDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuQ29tcG9uZW50Q29uc3RydWN0b3JPcHRpb25zfSBvcHRpb25zXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vdXRpbHMuanMnKVsnbm90X2VxdWFsJ119IG5vdF9lcXVhbCBVc2VkIHRvIGNvbXBhcmUgcHJvcHMgYW5kIHN0YXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7KHRhcmdldDogRWxlbWVudCB8IFNoYWRvd1Jvb3QpID0+IHZvaWR9IFthcHBlbmRfc3R5bGVzXSBGdW5jdGlvbiB0aGF0IGFwcGVuZHMgc3R5bGVzIHRvIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGlzIGZpcnN0IGluaXRpYWxpc2VkLlxuICogVGhpcyB3aWxsIGJlIHRoZSBgYWRkX2Nzc2AgZnVuY3Rpb24gZnJvbSB0aGUgY29tcGlsZWQgY29tcG9uZW50LlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdChcblx0Y29tcG9uZW50LFxuXHRvcHRpb25zLFxuXHRpbnN0YW5jZSxcblx0Y3JlYXRlX2ZyYWdtZW50LFxuXHRub3RfZXF1YWwsXG5cdHByb3BzLFxuXHRhcHBlbmRfc3R5bGVzID0gbnVsbCxcblx0ZGlydHkgPSBbLTFdXG4pIHtcblx0Y29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuXHRzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlQkJH0gKi9cblx0Y29uc3QgJCQgPSAoY29tcG9uZW50LiQkID0ge1xuXHRcdGZyYWdtZW50OiBudWxsLFxuXHRcdGN0eDogW10sXG5cdFx0Ly8gc3RhdGVcblx0XHRwcm9wcyxcblx0XHR1cGRhdGU6IG5vb3AsXG5cdFx0bm90X2VxdWFsLFxuXHRcdGJvdW5kOiBibGFua19vYmplY3QoKSxcblx0XHQvLyBsaWZlY3ljbGVcblx0XHRvbl9tb3VudDogW10sXG5cdFx0b25fZGVzdHJveTogW10sXG5cdFx0b25fZGlzY29ubmVjdDogW10sXG5cdFx0YmVmb3JlX3VwZGF0ZTogW10sXG5cdFx0YWZ0ZXJfdXBkYXRlOiBbXSxcblx0XHRjb250ZXh0OiBuZXcgTWFwKG9wdGlvbnMuY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG5cdFx0Ly8gZXZlcnl0aGluZyBlbHNlXG5cdFx0Y2FsbGJhY2tzOiBibGFua19vYmplY3QoKSxcblx0XHRkaXJ0eSxcblx0XHRza2lwX2JvdW5kOiBmYWxzZSxcblx0XHRyb290OiBvcHRpb25zLnRhcmdldCB8fCBwYXJlbnRfY29tcG9uZW50LiQkLnJvb3Rcblx0fSk7XG5cdGFwcGVuZF9zdHlsZXMgJiYgYXBwZW5kX3N0eWxlcygkJC5yb290KTtcblx0bGV0IHJlYWR5ID0gZmFsc2U7XG5cdCQkLmN0eCA9IGluc3RhbmNlXG5cdFx0PyBpbnN0YW5jZShjb21wb25lbnQsIG9wdGlvbnMucHJvcHMgfHwge30sIChpLCByZXQsIC4uLnJlc3QpID0+IHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSByZXN0Lmxlbmd0aCA/IHJlc3RbMF0gOiByZXQ7XG5cdFx0XHRcdGlmICgkJC5jdHggJiYgbm90X2VxdWFsKCQkLmN0eFtpXSwgKCQkLmN0eFtpXSA9IHZhbHVlKSkpIHtcblx0XHRcdFx0XHRpZiAoISQkLnNraXBfYm91bmQgJiYgJCQuYm91bmRbaV0pICQkLmJvdW5kW2ldKHZhbHVlKTtcblx0XHRcdFx0XHRpZiAocmVhZHkpIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdCAgfSlcblx0XHQ6IFtdO1xuXHQkJC51cGRhdGUoKTtcblx0cmVhZHkgPSB0cnVlO1xuXHRydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuXHQvLyBgZmFsc2VgIGFzIGEgc3BlY2lhbCBjYXNlIG9mIG5vIERPTSBjb21wb25lbnRcblx0JCQuZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnQgPyBjcmVhdGVfZnJhZ21lbnQoJCQuY3R4KSA6IGZhbHNlO1xuXHRpZiAob3B0aW9ucy50YXJnZXQpIHtcblx0XHRpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG5cdFx0XHRzdGFydF9oeWRyYXRpbmcoKTtcblx0XHRcdC8vIFRPRE86IHdoYXQgaXMgdGhlIGNvcnJlY3QgdHlwZSBoZXJlP1xuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0Y29uc3Qgbm9kZXMgPSBjaGlsZHJlbihvcHRpb25zLnRhcmdldCk7XG5cdFx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5sKG5vZGVzKTtcblx0XHRcdG5vZGVzLmZvckVhY2goZGV0YWNoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cblx0XHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmMoKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuaW50cm8pIHRyYW5zaXRpb25faW4oY29tcG9uZW50LiQkLmZyYWdtZW50KTtcblx0XHRtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IpO1xuXHRcdGVuZF9oeWRyYXRpbmcoKTtcblx0XHRmbHVzaCgpO1xuXHR9XG5cdHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbn1cblxuZXhwb3J0IGxldCBTdmVsdGVFbGVtZW50O1xuXG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFN2ZWx0ZUVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcblx0XHQvKiogVGhlIFN2ZWx0ZSBjb21wb25lbnQgY29uc3RydWN0b3IgKi9cblx0XHQkJGN0b3I7XG5cdFx0LyoqIFNsb3RzICovXG5cdFx0JCRzO1xuXHRcdC8qKiBUaGUgU3ZlbHRlIGNvbXBvbmVudCBpbnN0YW5jZSAqL1xuXHRcdCQkYztcblx0XHQvKiogV2hldGhlciBvciBub3QgdGhlIGN1c3RvbSBlbGVtZW50IGlzIGNvbm5lY3RlZCAqL1xuXHRcdCQkY24gPSBmYWxzZTtcblx0XHQvKiogQ29tcG9uZW50IHByb3BzIGRhdGEgKi9cblx0XHQkJGQgPSB7fTtcblx0XHQvKiogYHRydWVgIGlmIGN1cnJlbnRseSBpbiB0aGUgcHJvY2VzcyBvZiByZWZsZWN0aW5nIGNvbXBvbmVudCBwcm9wcyBiYWNrIHRvIGF0dHJpYnV0ZXMgKi9cblx0XHQkJHIgPSBmYWxzZTtcblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvbj59IFByb3BzIGRlZmluaXRpb24gKG5hbWUsIHJlZmxlY3RlZCwgdHlwZSBldGMpICovXG5cdFx0JCRwX2QgPSB7fTtcblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEZ1bmN0aW9uW10+fSBFdmVudCBsaXN0ZW5lcnMgKi9cblx0XHQkJGwgPSB7fTtcblx0XHQvKiogQHR5cGUge01hcDxGdW5jdGlvbiwgRnVuY3Rpb24+fSBFdmVudCBsaXN0ZW5lciB1bnN1YnNjcmliZSBmdW5jdGlvbnMgKi9cblx0XHQkJGxfdSA9IG5ldyBNYXAoKTtcblxuXHRcdGNvbnN0cnVjdG9yKCQkY29tcG9uZW50Q3RvciwgJCRzbG90cywgdXNlX3NoYWRvd19kb20pIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLiQkY3RvciA9ICQkY29tcG9uZW50Q3Rvcjtcblx0XHRcdHRoaXMuJCRzID0gJCRzbG90cztcblx0XHRcdGlmICh1c2Vfc2hhZG93X2RvbSkge1xuXHRcdFx0XHR0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG5cdFx0XHQvLyBXZSBjYW4ndCBkZXRlcm1pbmUgdXBmcm9udCBpZiB0aGUgZXZlbnQgaXMgYSBjdXN0b20gZXZlbnQgb3Igbm90LCBzbyB3ZSBoYXZlIHRvXG5cdFx0XHQvLyBsaXN0ZW4gdG8gYm90aC4gSWYgc29tZW9uZSB1c2VzIGEgY3VzdG9tIGV2ZW50IHdpdGggdGhlIHNhbWUgbmFtZSBhcyBhIHJlZ3VsYXJcblx0XHRcdC8vIGJyb3dzZXIgZXZlbnQsIHRoaXMgZmlyZXMgdHdpY2UgLSB3ZSBjYW4ndCBhdm9pZCB0aGF0LlxuXHRcdFx0dGhpcy4kJGxbdHlwZV0gPSB0aGlzLiQkbFt0eXBlXSB8fCBbXTtcblx0XHRcdHRoaXMuJCRsW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuXHRcdFx0aWYgKHRoaXMuJCRjKSB7XG5cdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGMuJG9uKHR5cGUsIGxpc3RlbmVyKTtcblx0XHRcdFx0dGhpcy4kJGxfdS5zZXQobGlzdGVuZXIsIHVuc3ViKTtcblx0XHRcdH1cblx0XHRcdHN1cGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcblx0XHRcdHN1cGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKHRoaXMuJCRjKSB7XG5cdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGxfdS5nZXQobGlzdGVuZXIpO1xuXHRcdFx0XHRpZiAodW5zdWIpIHtcblx0XHRcdFx0XHR1bnN1YigpO1xuXHRcdFx0XHRcdHRoaXMuJCRsX3UuZGVsZXRlKGxpc3RlbmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFzeW5jIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuXHRcdFx0dGhpcy4kJGNuID0gdHJ1ZTtcblx0XHRcdGlmICghdGhpcy4kJGMpIHtcblx0XHRcdFx0Ly8gV2Ugd2FpdCBvbmUgdGljayB0byBsZXQgcG9zc2libGUgY2hpbGQgc2xvdCBlbGVtZW50cyBiZSBjcmVhdGVkL21vdW50ZWRcblx0XHRcdFx0YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHRcdGlmICghdGhpcy4kJGNuKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmN0aW9uIGNyZWF0ZV9zbG90KG5hbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IG5vZGU7XG5cdFx0XHRcdFx0XHRjb25zdCBvYmogPSB7XG5cdFx0XHRcdFx0XHRcdGM6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbWVudCgnc2xvdCcpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChuYW1lICE9PSAnZGVmYXVsdCcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGF0dHIobm9kZSwgJ25hbWUnLCBuYW1lKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdFx0XHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcblx0XHRcdFx0XHRcdFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2FuY2hvcl1cblx0XHRcdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0XHRcdG06IGZ1bmN0aW9uIG1vdW50KHRhcmdldCwgYW5jaG9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZDogZnVuY3Rpb24gZGVzdHJveShkZXRhY2hpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZGV0YWNoaW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZXRhY2gobm9kZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0ICQkc2xvdHMgPSB7fTtcblx0XHRcdFx0Y29uc3QgZXhpc3Rpbmdfc2xvdHMgPSBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKHRoaXMpO1xuXHRcdFx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy4kJHMpIHtcblx0XHRcdFx0XHRpZiAobmFtZSBpbiBleGlzdGluZ19zbG90cykge1xuXHRcdFx0XHRcdFx0JCRzbG90c1tuYW1lXSA9IFtjcmVhdGVfc2xvdChuYW1lKV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoY29uc3QgYXR0cmlidXRlIG9mIHRoaXMuYXR0cmlidXRlcykge1xuXHRcdFx0XHRcdC8vIHRoaXMuJCRkYXRhIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzLmF0dHJpYnV0ZXNcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gdGhpcy4kJGdfcChhdHRyaWJ1dGUubmFtZSk7XG5cdFx0XHRcdFx0aWYgKCEobmFtZSBpbiB0aGlzLiQkZCkpIHtcblx0XHRcdFx0XHRcdHRoaXMuJCRkW25hbWVdID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKG5hbWUsIGF0dHJpYnV0ZS52YWx1ZSwgdGhpcy4kJHBfZCwgJ3RvUHJvcCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBQb3J0IG92ZXIgcHJvcHMgdGhhdCB3ZXJlIHNldCBwcm9ncmFtbWF0aWNhbGx5IGJlZm9yZSBjZSB3YXMgaW5pdGlhbGl6ZWRcblx0XHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gdGhpcy4kJHBfZCkge1xuXHRcdFx0XHRcdGlmICghKGtleSBpbiB0aGlzLiQkZCkgJiYgdGhpc1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRoaXMuJCRkW2tleV0gPSB0aGlzW2tleV07IC8vIGRvbid0IHRyYW5zZm9ybSwgdGhlc2Ugd2VyZSBzZXQgdGhyb3VnaCBKYXZhU2NyaXB0XG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpc1trZXldOyAvLyByZW1vdmUgdGhlIHByb3BlcnR5IHRoYXQgc2hhZG93cyB0aGUgZ2V0dGVyL3NldHRlclxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLiQkYyA9IG5ldyB0aGlzLiQkY3Rvcih7XG5cdFx0XHRcdFx0dGFyZ2V0OiB0aGlzLnNoYWRvd1Jvb3QgfHwgdGhpcyxcblx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0Li4udGhpcy4kJGQsXG5cdFx0XHRcdFx0XHQkJHNsb3RzLFxuXHRcdFx0XHRcdFx0JCRzY29wZToge1xuXHRcdFx0XHRcdFx0XHRjdHg6IFtdXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBSZWZsZWN0IGNvbXBvbmVudCBwcm9wcyBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdGNvbnN0IHJlZmxlY3RfYXR0cmlidXRlcyA9ICgpID0+IHtcblx0XHRcdFx0XHR0aGlzLiQkciA9IHRydWU7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gdGhpcy4kJHBfZCkge1xuXHRcdFx0XHRcdFx0dGhpcy4kJGRba2V5XSA9IHRoaXMuJCRjLiQkLmN0eFt0aGlzLiQkYy4kJC5wcm9wc1trZXldXTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLiQkcF9kW2tleV0ucmVmbGVjdCkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVfdmFsdWUgPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUoXG5cdFx0XHRcdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuJCRkW2tleV0sXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy4kJHBfZCxcblx0XHRcdFx0XHRcdFx0XHQndG9BdHRyaWJ1dGUnXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGlmIChhdHRyaWJ1dGVfdmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRlKHRoaXMuJCRwX2Rba2V5XS5hdHRyaWJ1dGUgfHwga2V5KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSh0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlIHx8IGtleSwgYXR0cmlidXRlX3ZhbHVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLiQkciA9IGZhbHNlO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLiQkYy4kJC5hZnRlcl91cGRhdGUucHVzaChyZWZsZWN0X2F0dHJpYnV0ZXMpO1xuXHRcdFx0XHRyZWZsZWN0X2F0dHJpYnV0ZXMoKTsgLy8gb25jZSBpbml0aWFsbHkgYmVjYXVzZSBhZnRlcl91cGRhdGUgaXMgYWRkZWQgdG9vIGxhdGUgZm9yIGZpcnN0IHJlbmRlclxuXG5cdFx0XHRcdGZvciAoY29uc3QgdHlwZSBpbiB0aGlzLiQkbCkge1xuXHRcdFx0XHRcdGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4kJGxbdHlwZV0pIHtcblx0XHRcdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGMuJG9uKHR5cGUsIGxpc3RlbmVyKTtcblx0XHRcdFx0XHRcdHRoaXMuJCRsX3Uuc2V0KGxpc3RlbmVyLCB1bnN1Yik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuJCRsID0ge307XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gV2UgZG9uJ3QgbmVlZCB0aGlzIHdoZW4gd29ya2luZyB3aXRoaW4gU3ZlbHRlIGNvZGUsIGJ1dCBmb3IgY29tcGF0aWJpbGl0eSBvZiBwZW9wbGUgdXNpbmcgdGhpcyBvdXRzaWRlIG9mIFN2ZWx0ZVxuXHRcdC8vIGFuZCBzZXR0aW5nIGF0dHJpYnV0ZXMgdGhyb3VnaCBzZXRBdHRyaWJ1dGUgZXRjLCB0aGlzIGlzIGhlbHBmdWxcblx0XHRhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgX29sZFZhbHVlLCBuZXdWYWx1ZSkge1xuXHRcdFx0aWYgKHRoaXMuJCRyKSByZXR1cm47XG5cdFx0XHRhdHRyID0gdGhpcy4kJGdfcChhdHRyKTtcblx0XHRcdHRoaXMuJCRkW2F0dHJdID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKGF0dHIsIG5ld1ZhbHVlLCB0aGlzLiQkcF9kLCAndG9Qcm9wJyk7XG5cdFx0XHR0aGlzLiQkYz8uJHNldCh7IFthdHRyXTogdGhpcy4kJGRbYXR0cl0gfSk7XG5cdFx0fVxuXG5cdFx0ZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cdFx0XHR0aGlzLiQkY24gPSBmYWxzZTtcblx0XHRcdC8vIEluIGEgbWljcm90YXNrLCBiZWNhdXNlIHRoaXMgY291bGQgYmUgYSBtb3ZlIHdpdGhpbiB0aGUgRE9NXG5cdFx0XHRQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHRcdFx0aWYgKCF0aGlzLiQkY24pIHtcblx0XHRcdFx0XHR0aGlzLiQkYy4kZGVzdHJveSgpO1xuXHRcdFx0XHRcdHRoaXMuJCRjID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQkJGdfcChhdHRyaWJ1dGVfbmFtZSkge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0T2JqZWN0LmtleXModGhpcy4kJHBfZCkuZmluZChcblx0XHRcdFx0XHQoa2V5KSA9PlxuXHRcdFx0XHRcdFx0dGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSA9PT0gYXR0cmlidXRlX25hbWUgfHxcblx0XHRcdFx0XHRcdCghdGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gYXR0cmlidXRlX25hbWUpXG5cdFx0XHRcdCkgfHwgYXR0cmlidXRlX25hbWVcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gcHJvcHNfZGVmaW5pdGlvblxuICogQHBhcmFtIHsndG9BdHRyaWJ1dGUnIHwgJ3RvUHJvcCd9IFt0cmFuc2Zvcm1dXG4gKi9cbmZ1bmN0aW9uIGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShwcm9wLCB2YWx1ZSwgcHJvcHNfZGVmaW5pdGlvbiwgdHJhbnNmb3JtKSB7XG5cdGNvbnN0IHR5cGUgPSBwcm9wc19kZWZpbml0aW9uW3Byb3BdPy50eXBlO1xuXHR2YWx1ZSA9IHR5cGUgPT09ICdCb29sZWFuJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJyA/IHZhbHVlICE9IG51bGwgOiB2YWx1ZTtcblx0aWYgKCF0cmFuc2Zvcm0gfHwgIXByb3BzX2RlZmluaXRpb25bcHJvcF0pIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0gZWxzZSBpZiAodHJhbnNmb3JtID09PSAndG9BdHRyaWJ1dGUnKSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJycgOiBudWxsO1xuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBudWxsIDogdmFsdWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnT2JqZWN0Jzpcblx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlICYmIEpTT04ucGFyc2UodmFsdWUpO1xuXHRcdFx0Y2FzZSAnQm9vbGVhbic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTsgLy8gY29udmVyc2lvbiBhbHJlYWR5IGhhbmRsZWQgYWJvdmVcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAhPSBudWxsID8gK3ZhbHVlIDogdmFsdWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKlxuICogVHVybiBhIFN2ZWx0ZSBjb21wb25lbnQgaW50byBhIGN1c3RvbSBlbGVtZW50LlxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuQ29tcG9uZW50VHlwZX0gQ29tcG9uZW50ICBBIFN2ZWx0ZSBjb21wb25lbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gcHJvcHNfZGVmaW5pdGlvbiAgVGhlIHByb3BzIHRvIG9ic2VydmVcbiAqIEBwYXJhbSB7c3RyaW5nW119IHNsb3RzICBUaGUgc2xvdHMgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhY2Nlc3NvcnMgIE90aGVyIGFjY2Vzc29ycyBiZXNpZGVzIHRoZSBvbmVzIGZvciBwcm9wcyB0aGUgY29tcG9uZW50IGhhc1xuICogQHBhcmFtIHtib29sZWFufSB1c2Vfc2hhZG93X2RvbSAgV2hldGhlciB0byB1c2Ugc2hhZG93IERPTVxuICogQHBhcmFtIHsoY2U6IG5ldyAoKSA9PiBIVE1MRWxlbWVudCkgPT4gbmV3ICgpID0+IEhUTUxFbGVtZW50fSBbZXh0ZW5kXVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2N1c3RvbV9lbGVtZW50KFxuXHRDb21wb25lbnQsXG5cdHByb3BzX2RlZmluaXRpb24sXG5cdHNsb3RzLFxuXHRhY2Nlc3NvcnMsXG5cdHVzZV9zaGFkb3dfZG9tLFxuXHRleHRlbmRcbikge1xuXHRsZXQgQ2xhc3MgPSBjbGFzcyBleHRlbmRzIFN2ZWx0ZUVsZW1lbnQge1xuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0c3VwZXIoQ29tcG9uZW50LCBzbG90cywgdXNlX3NoYWRvd19kb20pO1xuXHRcdFx0dGhpcy4kJHBfZCA9IHByb3BzX2RlZmluaXRpb247XG5cdFx0fVxuXHRcdHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKHByb3BzX2RlZmluaXRpb24pLm1hcCgoa2V5KSA9PlxuXHRcdFx0XHQocHJvcHNfZGVmaW5pdGlvbltrZXldLmF0dHJpYnV0ZSB8fCBrZXkpLnRvTG93ZXJDYXNlKClcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xuXHRPYmplY3Qua2V5cyhwcm9wc19kZWZpbml0aW9uKS5mb3JFYWNoKChwcm9wKSA9PiB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgcHJvcCwge1xuXHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy4kJGMgJiYgcHJvcCBpbiB0aGlzLiQkYyA/IHRoaXMuJCRjW3Byb3BdIDogdGhpcy4kJGRbcHJvcF07XG5cdFx0XHR9LFxuXHRcdFx0c2V0KHZhbHVlKSB7XG5cdFx0XHRcdHZhbHVlID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKHByb3AsIHZhbHVlLCBwcm9wc19kZWZpbml0aW9uKTtcblx0XHRcdFx0dGhpcy4kJGRbcHJvcF0gPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy4kJGM/LiRzZXQoeyBbcHJvcF06IHZhbHVlIH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0YWNjZXNzb3JzLmZvckVhY2goKGFjY2Vzc29yKSA9PiB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgYWNjZXNzb3IsIHtcblx0XHRcdGdldCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuJCRjPy5bYWNjZXNzb3JdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0aWYgKGV4dGVuZCkge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgLSBhc3NpZ25pbmcgaGVyZSBpcyBmaW5lXG5cdFx0Q2xhc3MgPSBleHRlbmQoQ2xhc3MpO1xuXHR9XG5cdENvbXBvbmVudC5lbGVtZW50ID0gLyoqIEB0eXBlIHthbnl9ICovIChDbGFzcyk7XG5cdHJldHVybiBDbGFzcztcbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cy4gVXNlZCB3aGVuIGRldj1mYWxzZS5cbiAqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtQcm9wcz1hbnldXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtFdmVudHM9YW55XVxuICovXG5leHBvcnQgY2xhc3MgU3ZlbHRlQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqICMjIyBQUklWQVRFIEFQSVxuXHQgKlxuXHQgKiBEbyBub3QgdXNlLCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lXG5cdCAqXG5cdCAqIEB0eXBlIHthbnl9XG5cdCAqL1xuXHQkJCA9IHVuZGVmaW5lZDtcblx0LyoqXG5cdCAqICMjIyBQUklWQVRFIEFQSVxuXHQgKlxuXHQgKiBEbyBub3QgdXNlLCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lXG5cdCAqXG5cdCAqIEB0eXBlIHthbnl9XG5cdCAqL1xuXHQkJHNldCA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHJldHVybnMge3ZvaWR9ICovXG5cdCRkZXN0cm95KCkge1xuXHRcdGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuXHRcdHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0ZW1wbGF0ZSB7RXh0cmFjdDxrZXlvZiBFdmVudHMsIHN0cmluZz59IEtcblx0ICogQHBhcmFtIHtLfSB0eXBlXG5cdCAqIEBwYXJhbSB7KChlOiBFdmVudHNbS10pID0+IHZvaWQpIHwgbnVsbCB8IHVuZGVmaW5lZH0gY2FsbGJhY2tcblx0ICogQHJldHVybnMgeygpID0+IHZvaWR9XG5cdCAqL1xuXHQkb24odHlwZSwgY2FsbGJhY2spIHtcblx0XHRpZiAoIWlzX2Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuXHRcdFx0cmV0dXJuIG5vb3A7XG5cdFx0fVxuXHRcdGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKTtcblx0XHRjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1BhcnRpYWw8UHJvcHM+fSBwcm9wc1xuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdCRzZXQocHJvcHMpIHtcblx0XHRpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkocHJvcHMpKSB7XG5cdFx0XHR0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuXHRcdFx0dGhpcy4kJHNldChwcm9wcyk7XG5cdFx0XHR0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXR0cmlidXRlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVmbGVjdF1cbiAqIEBwcm9wZXJ0eSB7J1N0cmluZyd8J0Jvb2xlYW4nfCdOdW1iZXInfCdBcnJheSd8J09iamVjdCd9IFt0eXBlXVxuICovXG4iLCAiLy8gZ2VuZXJhdGVkIGR1cmluZyByZWxlYXNlLCBkbyBub3QgbW9kaWZ5XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgdmVyc2lvbiwgYXMgc2V0IGluIHBhY2thZ2UuanNvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtY29tcGlsZXIjc3ZlbHRlLXZlcnNpb25cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzQuMi45JztcbmV4cG9ydCBjb25zdCBQVUJMSUNfVkVSU0lPTiA9ICc0JztcbiIsICJpbXBvcnQgeyBQVUJMSUNfVkVSU0lPTiB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC92ZXJzaW9uLmpzJztcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxuXHQvLyBAdHMtaWdub3JlXG5cdCh3aW5kb3cuX19zdmVsdGUgfHwgKHdpbmRvdy5fX3N2ZWx0ZSA9IHsgdjogbmV3IFNldCgpIH0pKS52LmFkZChQVUJMSUNfVkVSU0lPTik7XG4iLCAiLy8gOjotIFBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGFuIG9yZGVyZWQgbWFwcGluZyBmcm9tXG4vLyBzdHJpbmdzIHRvIHZhbHVlcywgd2l0aCBzb21lIGNvbnZlbmllbnQgdXBkYXRlIG1ldGhvZHMuXG5mdW5jdGlvbiBPcmRlcmVkTWFwKGNvbnRlbnQpIHtcbiAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbn1cblxuT3JkZXJlZE1hcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBPcmRlcmVkTWFwLFxuXG4gIGZpbmQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSArPSAyKVxuICAgICAgaWYgKHRoaXMuY29udGVudFtpXSA9PT0ga2V5KSByZXR1cm4gaVxuICAgIHJldHVybiAtMVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcpIFx1MjE5MiA/YW55XG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZSBzdG9yZWQgdW5kZXIgYGtleWAsIG9yIHJldHVybiB1bmRlZmluZWQgd2hlblxuICAvLyBubyBzdWNoIGtleSBleGlzdHMuXG4gIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5maW5kKGtleSk7XG4gICAgcmV0dXJuIGZvdW5kID09IC0xID8gdW5kZWZpbmVkIDogdGhpcy5jb250ZW50W2ZvdW5kICsgMV1cbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnksID9zdHJpbmcpIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgcmVwbGFjaW5nIHRoZSB2YWx1ZSBvZiBga2V5YCB3aXRoIGEgbmV3XG4gIC8vIHZhbHVlLCBvciBhZGRpbmcgYSBiaW5kaW5nIHRvIHRoZSBlbmQgb2YgdGhlIG1hcC4gSWYgYG5ld0tleWAgaXNcbiAgLy8gZ2l2ZW4sIHRoZSBrZXkgb2YgdGhlIGJpbmRpbmcgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoYXQga2V5LlxuICB1cGRhdGU6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG5ld0tleSkge1xuICAgIHZhciBzZWxmID0gbmV3S2V5ICYmIG5ld0tleSAhPSBrZXkgPyB0aGlzLnJlbW92ZShuZXdLZXkpIDogdGhpcztcbiAgICB2YXIgZm91bmQgPSBzZWxmLmZpbmQoa2V5KSwgY29udGVudCA9IHNlbGYuY29udGVudC5zbGljZSgpO1xuICAgIGlmIChmb3VuZCA9PSAtMSkge1xuICAgICAgY29udGVudC5wdXNoKG5ld0tleSB8fCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudFtmb3VuZCArIDFdID0gdmFsdWU7XG4gICAgICBpZiAobmV3S2V5KSBjb250ZW50W2ZvdW5kXSA9IG5ld0tleTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZykgXHUyMTkyIE9yZGVyZWRNYXBcbiAgLy8gUmV0dXJuIGEgbWFwIHdpdGggdGhlIGdpdmVuIGtleSByZW1vdmVkLCBpZiBpdCBleGlzdGVkLlxuICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZChrZXkpO1xuICAgIGlmIChmb3VuZCA9PSAtMSkgcmV0dXJuIHRoaXNcbiAgICB2YXIgY29udGVudCA9IHRoaXMuY29udGVudC5zbGljZSgpO1xuICAgIGNvbnRlbnQuc3BsaWNlKGZvdW5kLCAyKTtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnkpIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIG5ldyBrZXkgdG8gdGhlIHN0YXJ0IG9mIHRoZSBtYXAuXG4gIGFkZFRvU3RhcnQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoW2tleSwgdmFsdWVdLmNvbmNhdCh0aGlzLnJlbW92ZShrZXkpLmNvbnRlbnQpKVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcsIGFueSkgXHUyMTkyIE9yZGVyZWRNYXBcbiAgLy8gQWRkIGEgbmV3IGtleSB0byB0aGUgZW5kIG9mIHRoZSBtYXAuXG4gIGFkZFRvRW5kOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLnJlbW92ZShrZXkpLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBjb250ZW50LnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgc3RyaW5nLCBhbnkpIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIGtleSBhZnRlciB0aGUgZ2l2ZW4ga2V5LiBJZiBgcGxhY2VgIGlzIG5vdCBmb3VuZCwgdGhlIG5ld1xuICAvLyBrZXkgaXMgYWRkZWQgdG8gdGhlIGVuZC5cbiAgYWRkQmVmb3JlOiBmdW5jdGlvbihwbGFjZSwga2V5LCB2YWx1ZSkge1xuICAgIHZhciB3aXRob3V0ID0gdGhpcy5yZW1vdmUoa2V5KSwgY29udGVudCA9IHdpdGhvdXQuY29udGVudC5zbGljZSgpO1xuICAgIHZhciBmb3VuZCA9IHdpdGhvdXQuZmluZChwbGFjZSk7XG4gICAgY29udGVudC5zcGxpY2UoZm91bmQgPT0gLTEgPyBjb250ZW50Lmxlbmd0aCA6IGZvdW5kLCAwLCBrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbiAgfSxcblxuICAvLyA6OiAoKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSlcbiAgLy8gQ2FsbCB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIG1hcCwgaW5cbiAgLy8gb3JkZXIuXG4gIGZvckVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIGYodGhpcy5jb250ZW50W2ldLCB0aGlzLmNvbnRlbnRbaSArIDFdKTtcbiAgfSxcblxuICAvLyA6OiAodW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikgXHUyMTkyIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbmV3IG1hcCBieSBwcmVwZW5kaW5nIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgIGJlZm9yZSB0aGUga2V5cyBpbiBgbWFwYC5cbiAgcHJlcGVuZDogZnVuY3Rpb24obWFwKSB7XG4gICAgbWFwID0gT3JkZXJlZE1hcC5mcm9tKG1hcCk7XG4gICAgaWYgKCFtYXAuc2l6ZSkgcmV0dXJuIHRoaXNcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAobWFwLmNvbnRlbnQuY29uY2F0KHRoaXMuc3VidHJhY3QobWFwKS5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAodW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikgXHUyMTkyIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbmV3IG1hcCBieSBhcHBlbmRpbmcgdGhlIGtleXMgaW4gdGhpcyBtYXAgdGhhdCBkb24ndFxuICAvLyBhcHBlYXIgaW4gYG1hcGAgYWZ0ZXIgdGhlIGtleXMgaW4gYG1hcGAuXG4gIGFwcGVuZDogZnVuY3Rpb24obWFwKSB7XG4gICAgbWFwID0gT3JkZXJlZE1hcC5mcm9tKG1hcCk7XG4gICAgaWYgKCFtYXAuc2l6ZSkgcmV0dXJuIHRoaXNcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAodGhpcy5zdWJ0cmFjdChtYXApLmNvbnRlbnQuY29uY2F0KG1hcC5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAodW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikgXHUyMTkyIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbWFwIGNvbnRhaW5pbmcgYWxsIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgLlxuICBzdWJ0cmFjdDogZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgbWFwID0gT3JkZXJlZE1hcC5mcm9tKG1hcCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXAuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZW1vdmUobWFwLmNvbnRlbnRbaV0pO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSxcblxuICAvLyA6OiAoKSBcdTIxOTIgT2JqZWN0XG4gIC8vIFR1cm4gb3JkZXJlZCBtYXAgaW50byBhIHBsYWluIG9iamVjdC5cbiAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkgeyByZXN1bHRba2V5XSA9IHZhbHVlOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG5cbiAgLy8gOjogbnVtYmVyXG4gIC8vIFRoZSBhbW91bnQgb2Yga2V5cyBpbiB0aGlzIG1hcC5cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPj4gMVxuICB9XG59O1xuXG4vLyA6OiAoP3VuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIFx1MjE5MiBPcmRlcmVkTWFwXG4vLyBSZXR1cm4gYSBtYXAgd2l0aCB0aGUgZ2l2ZW4gY29udGVudC4gSWYgbnVsbCwgY3JlYXRlIGFuIGVtcHR5XG4vLyBtYXAuIElmIGdpdmVuIGFuIG9yZGVyZWQgbWFwLCByZXR1cm4gdGhhdCBtYXAgaXRzZWxmLiBJZiBnaXZlbiBhblxuLy8gb2JqZWN0LCBjcmVhdGUgYSBtYXAgZnJvbSB0aGUgb2JqZWN0J3MgcHJvcGVydGllcy5cbk9yZGVyZWRNYXAuZnJvbSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9yZGVyZWRNYXApIHJldHVybiB2YWx1ZVxuICB2YXIgY29udGVudCA9IFtdO1xuICBpZiAodmFsdWUpIGZvciAodmFyIHByb3AgaW4gdmFsdWUpIGNvbnRlbnQucHVzaChwcm9wLCB2YWx1ZVtwcm9wXSk7XG4gIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxufTtcblxuZXhwb3J0IGRlZmF1bHQgT3JkZXJlZE1hcDtcbiIsICJpbXBvcnQgT3JkZXJlZE1hcCBmcm9tICdvcmRlcmVkbWFwJztcblxuZnVuY3Rpb24gZmluZERpZmZTdGFydChhLCBiLCBwb3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBpZiAoaSA9PSBhLmNoaWxkQ291bnQgfHwgaSA9PSBiLmNoaWxkQ291bnQpXG4gICAgICAgICAgICByZXR1cm4gYS5jaGlsZENvdW50ID09IGIuY2hpbGRDb3VudCA/IG51bGwgOiBwb3M7XG4gICAgICAgIGxldCBjaGlsZEEgPSBhLmNoaWxkKGkpLCBjaGlsZEIgPSBiLmNoaWxkKGkpO1xuICAgICAgICBpZiAoY2hpbGRBID09IGNoaWxkQikge1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hpbGRBLnNhbWVNYXJrdXAoY2hpbGRCKSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGlmIChjaGlsZEEuaXNUZXh0ICYmIGNoaWxkQS50ZXh0ICE9IGNoaWxkQi50ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgY2hpbGRBLnRleHRbal0gPT0gY2hpbGRCLnRleHRbal07IGorKylcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkQS5jb250ZW50LnNpemUgfHwgY2hpbGRCLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZERpZmZTdGFydChjaGlsZEEuY29udGVudCwgY2hpbGRCLmNvbnRlbnQsIHBvcyArIDEpO1xuICAgICAgICAgICAgaWYgKGlubmVyICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjaGlsZEEubm9kZVNpemU7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZERpZmZFbmQoYSwgYiwgcG9zQSwgcG9zQikge1xuICAgIGZvciAobGV0IGlBID0gYS5jaGlsZENvdW50LCBpQiA9IGIuY2hpbGRDb3VudDs7KSB7XG4gICAgICAgIGlmIChpQSA9PSAwIHx8IGlCID09IDApXG4gICAgICAgICAgICByZXR1cm4gaUEgPT0gaUIgPyBudWxsIDogeyBhOiBwb3NBLCBiOiBwb3NCIH07XG4gICAgICAgIGxldCBjaGlsZEEgPSBhLmNoaWxkKC0taUEpLCBjaGlsZEIgPSBiLmNoaWxkKC0taUIpLCBzaXplID0gY2hpbGRBLm5vZGVTaXplO1xuICAgICAgICBpZiAoY2hpbGRBID09IGNoaWxkQikge1xuICAgICAgICAgICAgcG9zQSAtPSBzaXplO1xuICAgICAgICAgICAgcG9zQiAtPSBzaXplO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKVxuICAgICAgICAgICAgcmV0dXJuIHsgYTogcG9zQSwgYjogcG9zQiB9O1xuICAgICAgICBpZiAoY2hpbGRBLmlzVGV4dCAmJiBjaGlsZEEudGV4dCAhPSBjaGlsZEIudGV4dCkge1xuICAgICAgICAgICAgbGV0IHNhbWUgPSAwLCBtaW5TaXplID0gTWF0aC5taW4oY2hpbGRBLnRleHQubGVuZ3RoLCBjaGlsZEIudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgd2hpbGUgKHNhbWUgPCBtaW5TaXplICYmIGNoaWxkQS50ZXh0W2NoaWxkQS50ZXh0Lmxlbmd0aCAtIHNhbWUgLSAxXSA9PSBjaGlsZEIudGV4dFtjaGlsZEIudGV4dC5sZW5ndGggLSBzYW1lIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBzYW1lKys7XG4gICAgICAgICAgICAgICAgcG9zQS0tO1xuICAgICAgICAgICAgICAgIHBvc0ItLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGE6IHBvc0EsIGI6IHBvc0IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRBLmNvbnRlbnQuc2l6ZSB8fCBjaGlsZEIuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBmaW5kRGlmZkVuZChjaGlsZEEuY29udGVudCwgY2hpbGRCLmNvbnRlbnQsIHBvc0EgLSAxLCBwb3NCIC0gMSk7XG4gICAgICAgICAgICBpZiAoaW5uZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICB9XG4gICAgICAgIHBvc0EgLT0gc2l6ZTtcbiAgICAgICAgcG9zQiAtPSBzaXplO1xuICAgIH1cbn1cblxuLyoqXG5BIGZyYWdtZW50IHJlcHJlc2VudHMgYSBub2RlJ3MgY29sbGVjdGlvbiBvZiBjaGlsZCBub2Rlcy5cblxuTGlrZSBub2RlcywgZnJhZ21lbnRzIGFyZSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlcywgYW5kIHlvdVxuc2hvdWxkIG5vdCBtdXRhdGUgdGhlbSBvciB0aGVpciBjb250ZW50LiBSYXRoZXIsIHlvdSBjcmVhdGUgbmV3XG5pbnN0YW5jZXMgd2hlbmV2ZXIgbmVlZGVkLiBUaGUgQVBJIHRyaWVzIHRvIG1ha2UgdGhpcyBlYXN5LlxuKi9cbmNsYXNzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29udGVudCwgc2l6ZSkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplIHx8IDA7XG4gICAgICAgIGlmIChzaXplID09IG51bGwpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplICs9IGNvbnRlbnRbaV0ubm9kZVNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIEludm9rZSBhIGNhbGxiYWNrIGZvciBhbGwgZGVzY2VuZGFudCBub2RlcyBiZXR3ZWVuIHRoZSBnaXZlbiB0d29cbiAgICBwb3NpdGlvbnMgKHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHRoaXMgZnJhZ21lbnQpLiBEb2Vzbid0IGRlc2NlbmRcbiAgICBpbnRvIGEgbm9kZSB3aGVuIHRoZSBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAuXG4gICAgKi9cbiAgICBub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIG5vZGVTdGFydCA9IDAsIHBhcmVudCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPiBmcm9tICYmIGYoY2hpbGQsIG5vZGVTdGFydCArIHBvcywgcGFyZW50IHx8IG51bGwsIGkpICE9PSBmYWxzZSAmJiBjaGlsZC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgIGNoaWxkLm5vZGVzQmV0d2VlbihNYXRoLm1heCgwLCBmcm9tIC0gc3RhcnQpLCBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gc3RhcnQpLCBmLCBub2RlU3RhcnQgKyBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IGRlc2NlbmRhbnQgbm9kZS4gYHBvc2Agd2lsbCBiZVxuICAgIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQuIFRoZSBjYWxsYmFjayBtYXkgcmV0dXJuXG4gICAgYGZhbHNlYCB0byBwcmV2ZW50IHRyYXZlcnNhbCBvZiBhIGdpdmVuIG5vZGUncyBjaGlsZHJlbi5cbiAgICAqL1xuICAgIGRlc2NlbmRhbnRzKGYpIHtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oMCwgdGhpcy5zaXplLCBmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0cmFjdCB0aGUgdGV4dCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC4gU2VlIHRoZSBzYW1lIG1ldGhvZCBvblxuICAgIFtgTm9kZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnRleHRCZXR3ZWVuKS5cbiAgICAqL1xuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgICAgICAgbGV0IHRleHQgPSBcIlwiLCBmaXJzdCA9IHRydWU7XG4gICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICBsZXQgbm9kZVRleHQgPSBub2RlLmlzVGV4dCA/IG5vZGUudGV4dC5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcylcbiAgICAgICAgICAgICAgICA6ICFub2RlLmlzTGVhZiA/IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgOiBsZWFmVGV4dCA/ICh0eXBlb2YgbGVhZlRleHQgPT09IFwiZnVuY3Rpb25cIiA/IGxlYWZUZXh0KG5vZGUpIDogbGVhZlRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5vZGUudHlwZS5zcGVjLmxlYWZUZXh0ID8gbm9kZS50eXBlLnNwZWMubGVhZlRleHQobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0Jsb2NrICYmIChub2RlLmlzTGVhZiAmJiBub2RlVGV4dCB8fCBub2RlLmlzVGV4dGJsb2NrKSAmJiBibG9ja1NlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdClcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gYmxvY2tTZXBhcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ICs9IG5vZGVUZXh0O1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBjb250YWluaW5nIHRoZSBjb21iaW5lZCBjb250ZW50IG9mIHRoaXNcbiAgICBmcmFnbWVudCBhbmQgdGhlIG90aGVyLlxuICAgICovXG4gICAgYXBwZW5kKG90aGVyKSB7XG4gICAgICAgIGlmICghb3RoZXIuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmxhc3RDaGlsZCwgZmlyc3QgPSBvdGhlci5maXJzdENoaWxkLCBjb250ZW50ID0gdGhpcy5jb250ZW50LnNsaWNlKCksIGkgPSAwO1xuICAgICAgICBpZiAobGFzdC5pc1RleHQgJiYgbGFzdC5zYW1lTWFya3VwKGZpcnN0KSkge1xuICAgICAgICAgICAgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID0gbGFzdC53aXRoVGV4dChsYXN0LnRleHQgKyBmaXJzdC50ZXh0KTtcbiAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpIDwgb3RoZXIuY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChvdGhlci5jb250ZW50W2ldKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50LCB0aGlzLnNpemUgKyBvdGhlci5zaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3V0IG91dCB0aGUgc3ViLWZyYWdtZW50IGJldHdlZW4gdGhlIHR3byBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBjdXQoZnJvbSwgdG8gPSB0aGlzLnNpemUpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBzaXplID0gMDtcbiAgICAgICAgaWYgKHRvID4gZnJvbSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBwb3MgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zIDwgZnJvbSB8fCBlbmQgPiB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlzVGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zKSwgTWF0aC5taW4oY2hpbGQudGV4dC5sZW5ndGgsIHRvIC0gcG9zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jdXQoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyAtIDEpLCBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gcG9zIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHJlc3VsdCwgc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3V0QnlJbmRleChmcm9tLCB0bykge1xuICAgICAgICBpZiAoZnJvbSA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5jb250ZW50LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBpbiB3aGljaCB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXggaXNcbiAgICByZXBsYWNlZCBieSB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAqL1xuICAgIHJlcGxhY2VDaGlsZChpbmRleCwgbm9kZSkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuY29udGVudFtpbmRleF07XG4gICAgICAgIGlmIChjdXJyZW50ID09IG5vZGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IGNvcHkgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplIC0gY3VycmVudC5ub2RlU2l6ZTtcbiAgICAgICAgY29weVtpbmRleF0gPSBub2RlO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvcHksIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgYnkgcHJlcGVuZGluZyB0aGUgZ2l2ZW4gbm9kZSB0byB0aGlzXG4gICAgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBhZGRUb1N0YXJ0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZV0uY29uY2F0KHRoaXMuY29udGVudCksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgYnkgYXBwZW5kaW5nIHRoZSBnaXZlbiBub2RlIHRvIHRoaXNcbiAgICBmcmFnbWVudC5cbiAgICAqL1xuICAgIGFkZFRvRW5kKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmNvbnRlbnQuY29uY2F0KG5vZGUpLCB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIGZyYWdtZW50IHRvIGFub3RoZXIgb25lLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggIT0gb3RoZXIuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRbaV0uZXEob3RoZXIuY29udGVudFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBmcmFnbWVudCwgb3IgYG51bGxgIGlmIGl0IGlzIGVtcHR5LlxuICAgICovXG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50WzBdIDogbnVsbDsgfVxuICAgIC8qKlxuICAgIFRoZSBsYXN0IGNoaWxkIG9mIHRoZSBmcmFnbWVudCwgb3IgYG51bGxgIGlmIGl0IGlzIGVtcHR5LlxuICAgICovXG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdIDogbnVsbDsgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2YgY2hpbGQgbm9kZXMgaW4gdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIGdldCBjaGlsZENvdW50KCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguIFJhaXNlIGFuIGVycm9yIHdoZW4gdGhlXG4gICAgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgICovXG4gICAgY2hpbGQoaW5kZXgpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggXCIgKyBpbmRleCArIFwiIG91dCBvZiByYW5nZSBmb3IgXCIgKyB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBpdCBleGlzdHMuXG4gICAgKi9cbiAgICBtYXliZUNoaWxkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbaW5kZXhdIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgYGZgIGZvciBldmVyeSBjaGlsZCBub2RlLCBwYXNzaW5nIHRoZSBub2RlLCBpdHMgb2Zmc2V0XG4gICAgaW50byB0aGlzIHBhcmVudCBub2RlLCBhbmQgaXRzIGluZGV4LlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldO1xuICAgICAgICAgICAgZihjaGlsZCwgcCwgaSk7XG4gICAgICAgICAgICBwICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uIGF0IHdoaWNoIHRoaXMgZnJhZ21lbnQgYW5kIGFub3RoZXJcbiAgICBmcmFnbWVudCBkaWZmZXIsIG9yIGBudWxsYCBpZiB0aGV5IGFyZSB0aGUgc2FtZS5cbiAgICAqL1xuICAgIGZpbmREaWZmU3RhcnQob3RoZXIsIHBvcyA9IDApIHtcbiAgICAgICAgcmV0dXJuIGZpbmREaWZmU3RhcnQodGhpcywgb3RoZXIsIHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uLCBzZWFyY2hpbmcgZnJvbSB0aGUgZW5kLCBhdCB3aGljaCB0aGlzXG4gICAgZnJhZ21lbnQgYW5kIHRoZSBnaXZlbiBmcmFnbWVudCBkaWZmZXIsIG9yIGBudWxsYCBpZiB0aGV5IGFyZVxuICAgIHRoZSBzYW1lLiBTaW5jZSB0aGlzIHBvc2l0aW9uIHdpbGwgbm90IGJlIHRoZSBzYW1lIGluIGJvdGhcbiAgICBub2RlcywgYW4gb2JqZWN0IHdpdGggdHdvIHNlcGFyYXRlIHBvc2l0aW9ucyBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGZpbmREaWZmRW5kKG90aGVyLCBwb3MgPSB0aGlzLnNpemUsIG90aGVyUG9zID0gb3RoZXIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmluZERpZmZFbmQodGhpcywgb3RoZXIsIHBvcywgb3RoZXJQb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBpbmRleCBhbmQgaW5uZXIgb2Zmc2V0IGNvcnJlc3BvbmRpbmcgdG8gYSBnaXZlbiByZWxhdGl2ZVxuICAgIHBvc2l0aW9uIGluIHRoaXMgZnJhZ21lbnQuIFRoZSByZXN1bHQgb2JqZWN0IHdpbGwgYmUgcmV1c2VkXG4gICAgKG92ZXJ3cml0dGVuKSB0aGUgbmV4dCB0aW1lIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQuIChOb3QgcHVibGljLilcbiAgICAqL1xuICAgIGZpbmRJbmRleChwb3MsIHJvdW5kID0gLTEpIHtcbiAgICAgICAgaWYgKHBvcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KDAsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPT0gdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KHRoaXMuY29udGVudC5sZW5ndGgsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPiB0aGlzLnNpemUgfHwgcG9zIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQb3NpdGlvbiAke3Bvc30gb3V0c2lkZSBvZiBmcmFnbWVudCAoJHt0aGlzfSlgKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGN1clBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLmNoaWxkKGkpLCBlbmQgPSBjdXJQb3MgKyBjdXIubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPT0gcG9zIHx8IHJvdW5kID4gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KGkgKyAxLCBlbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRJbmRleChpLCBjdXJQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIGRlYnVnZ2luZyBzdHJpbmcgdGhhdCBkZXNjcmliZXMgdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gXCI8XCIgKyB0aGlzLnRvU3RyaW5nSW5uZXIoKSArIFwiPlwiOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZ0lubmVyKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmpvaW4oXCIsIFwiKTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudC5tYXAobiA9PiBuLnRvSlNPTigpKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgZnJhZ21lbnQgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEZyYWdtZW50LmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHZhbHVlLm1hcChzY2hlbWEubm9kZUZyb21KU09OKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgZnJhZ21lbnQgZnJvbSBhbiBhcnJheSBvZiBub2Rlcy4gRW5zdXJlcyB0aGF0IGFkamFjZW50XG4gICAgdGV4dCBub2RlcyB3aXRoIHRoZSBzYW1lIG1hcmtzIGFyZSBqb2luZWQgdG9nZXRoZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUFycmF5KGFycmF5KSB7XG4gICAgICAgIGlmICghYXJyYXkubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBsZXQgam9pbmVkLCBzaXplID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChpICYmIG5vZGUuaXNUZXh0ICYmIGFycmF5W2kgLSAxXS5zYW1lTWFya3VwKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFqb2luZWQpXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZCA9IGFycmF5LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGpvaW5lZFtqb2luZWQubGVuZ3RoIC0gMV0gPSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC53aXRoVGV4dChqb2luZWRbam9pbmVkLmxlbmd0aCAtIDFdLnRleHQgKyBub2RlLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoam9pbmVkKSB7XG4gICAgICAgICAgICAgICAgam9pbmVkLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChqb2luZWQgfHwgYXJyYXksIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmcmFnbWVudCBmcm9tIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBpbnRlcnByZXRlZCBhcyBhXG4gICAgc2V0IG9mIG5vZGVzLiBGb3IgYG51bGxgLCBpdCByZXR1cm5zIHRoZSBlbXB0eSBmcmFnbWVudC4gRm9yIGFcbiAgICBmcmFnbWVudCwgdGhlIGZyYWdtZW50IGl0c2VsZi4gRm9yIGEgbm9kZSBvciBhcnJheSBvZiBub2RlcywgYVxuICAgIGZyYWdtZW50IGNvbnRhaW5pbmcgdGhvc2Ugbm9kZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbShub2Rlcykge1xuICAgICAgICBpZiAoIW5vZGVzKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAobm9kZXMgaW5zdGFuY2VvZiBGcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUFycmF5KG5vZGVzKTtcbiAgICAgICAgaWYgKG5vZGVzLmF0dHJzKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZXNdLCBub2Rlcy5ub2RlU2l6ZSk7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IFwiICsgbm9kZXMgKyBcIiB0byBhIEZyYWdtZW50XCIgK1xuICAgICAgICAgICAgKG5vZGVzLm5vZGVzQmV0d2VlbiA/IFwiIChsb29rcyBsaWtlIG11bHRpcGxlIHZlcnNpb25zIG9mIHByb3NlbWlycm9yLW1vZGVsIHdlcmUgbG9hZGVkKVwiIDogXCJcIikpO1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZnJhZ21lbnQuIEludGVuZGVkIHRvIGJlIHJldXNlZCB3aGVuZXZlciBhIG5vZGUgZG9lc24ndFxuY29udGFpbiBhbnl0aGluZyAocmF0aGVyIHRoYW4gYWxsb2NhdGluZyBhIG5ldyBlbXB0eSBmcmFnbWVudCBmb3JcbmVhY2ggbGVhZiBub2RlKS5cbiovXG5GcmFnbWVudC5lbXB0eSA9IG5ldyBGcmFnbWVudChbXSwgMCk7XG5jb25zdCBmb3VuZCA9IHsgaW5kZXg6IDAsIG9mZnNldDogMCB9O1xuZnVuY3Rpb24gcmV0SW5kZXgoaW5kZXgsIG9mZnNldCkge1xuICAgIGZvdW5kLmluZGV4ID0gaW5kZXg7XG4gICAgZm91bmQub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZURlZXAoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIShhICYmIHR5cGVvZiBhID09IFwib2JqZWN0XCIpIHx8XG4gICAgICAgICEoYiAmJiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhcnJheSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYikgIT0gYXJyYXkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWNvbXBhcmVEZWVwKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IHAgaW4gYSlcbiAgICAgICAgICAgIGlmICghKHAgaW4gYikgfHwgIWNvbXBhcmVEZWVwKGFbcF0sIGJbcF0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgcCBpbiBiKVxuICAgICAgICAgICAgaWYgKCEocCBpbiBhKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbkEgbWFyayBpcyBhIHBpZWNlIG9mIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgbm9kZSxcbnN1Y2ggYXMgaXQgYmVpbmcgZW1waGFzaXplZCwgaW4gY29kZSBmb250LCBvciBhIGxpbmsuIEl0IGhhcyBhXG50eXBlIGFuZCBvcHRpb25hbGx5IGEgc2V0IG9mIGF0dHJpYnV0ZXMgdGhhdCBwcm92aWRlIGZ1cnRoZXJcbmluZm9ybWF0aW9uIChzdWNoIGFzIHRoZSB0YXJnZXQgb2YgdGhlIGxpbmspLiBNYXJrcyBhcmUgY3JlYXRlZFxudGhyb3VnaCBhIGBTY2hlbWFgLCB3aGljaCBjb250cm9scyB3aGljaCB0eXBlcyBleGlzdCBhbmQgd2hpY2hcbmF0dHJpYnV0ZXMgdGhleSBoYXZlLlxuKi9cbmNsYXNzIE1hcmsge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgdGhpcyBtYXJrLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFyay5cbiAgICAqL1xuICAgIGF0dHJzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYSBzZXQgb2YgbWFya3MsIGNyZWF0ZSBhIG5ldyBzZXQgd2hpY2ggY29udGFpbnMgdGhpcyBvbmUgYXNcbiAgICB3ZWxsLCBpbiB0aGUgcmlnaHQgcG9zaXRpb24uIElmIHRoaXMgbWFyayBpcyBhbHJlYWR5IGluIHRoZSBzZXQsXG4gICAgdGhlIHNldCBpdHNlbGYgaXMgcmV0dXJuZWQuIElmIGFueSBtYXJrcyB0aGF0IGFyZSBzZXQgdG8gYmVcbiAgICBbZXhjbHVzaXZlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuZXhjbHVkZXMpIHdpdGggdGhpcyBtYXJrIGFyZSBwcmVzZW50LFxuICAgIHRob3NlIGFyZSByZXBsYWNlZCBieSB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFkZFRvU2V0KHNldCkge1xuICAgICAgICBsZXQgY29weSwgcGxhY2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgb3RoZXIgPSBzZXRbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5lcShvdGhlcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUuZXhjbHVkZXMob3RoZXIudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzZXQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdGhlci50eXBlLmV4Y2x1ZGVzKHRoaXMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwbGFjZWQgJiYgb3RoZXIudHlwZS5yYW5rID4gdGhpcy50eXBlLnJhbmspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29weSA9IHNldC5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgY29weS5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwbGFjZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29weSlcbiAgICAgICAgICAgICAgICAgICAgY29weS5wdXNoKG90aGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICBjb3B5ID0gc2V0LnNsaWNlKCk7XG4gICAgICAgIGlmICghcGxhY2VkKVxuICAgICAgICAgICAgY29weS5wdXNoKHRoaXMpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIHRoaXMgbWFyayBmcm9tIHRoZSBnaXZlbiBzZXQsIHJldHVybmluZyBhIG5ldyBzZXQuIElmIHRoaXNcbiAgICBtYXJrIGlzIG5vdCBpbiB0aGUgc2V0LCB0aGUgc2V0IGl0c2VsZiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIHJlbW92ZUZyb21TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuZXEoc2V0W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0LnNsaWNlKDAsIGkpLmNvbmNhdChzZXQuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgbWFyayBpcyBpbiB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzLlxuICAgICovXG4gICAgaXNJblNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5lcShzZXRbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGlzIG1hcmsgaGFzIHRoZSBzYW1lIHR5cGUgYW5kIGF0dHJpYnV0ZXMgYXNcbiAgICBhbm90aGVyIG1hcmsuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKHRoaXMudHlwZSA9PSBvdGhlci50eXBlICYmIGNvbXBhcmVEZWVwKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBtYXJrIHRvIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgb2JqID0geyB0eXBlOiB0aGlzLnR5cGUubmFtZSB9O1xuICAgICAgICBmb3IgKGxldCBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgIG9iai5hdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG1hcmsgZnJvbSBKU09OLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE1hcmsuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCB0eXBlID0gc2NoZW1hLm1hcmtzW2pzb24udHlwZV07XG4gICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGVyZSBpcyBubyBtYXJrIHR5cGUgJHtqc29uLnR5cGV9IGluIHRoaXMgc2NoZW1hYCk7XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZShqc29uLmF0dHJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHR3byBzZXRzIG9mIG1hcmtzIGFyZSBpZGVudGljYWwuXG4gICAgKi9cbiAgICBzdGF0aWMgc2FtZVNldChhLCBiKSB7XG4gICAgICAgIGlmIChhID09IGIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWFbaV0uZXEoYltpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcHJvcGVybHkgc29ydGVkIG1hcmsgc2V0IGZyb20gbnVsbCwgYSBzaW5nbGUgbWFyaywgb3IgYW5cbiAgICB1bnNvcnRlZCBhcnJheSBvZiBtYXJrcy5cbiAgICAqL1xuICAgIHN0YXRpYyBzZXRGcm9tKG1hcmtzKSB7XG4gICAgICAgIGlmICghbWFya3MgfHwgQXJyYXkuaXNBcnJheShtYXJrcykgJiYgbWFya3MubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gTWFyay5ub25lO1xuICAgICAgICBpZiAobWFya3MgaW5zdGFuY2VvZiBNYXJrKVxuICAgICAgICAgICAgcmV0dXJuIFttYXJrc107XG4gICAgICAgIGxldCBjb3B5ID0gbWFya3Muc2xpY2UoKTtcbiAgICAgICAgY29weS5zb3J0KChhLCBiKSA9PiBhLnR5cGUucmFuayAtIGIudHlwZS5yYW5rKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIG1hcmtzLlxuKi9cbk1hcmsubm9uZSA9IFtdO1xuXG4vKipcbkVycm9yIHR5cGUgcmFpc2VkIGJ5IFtgTm9kZS5yZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVwbGFjZSkgd2hlblxuZ2l2ZW4gYW4gaW52YWxpZCByZXBsYWNlbWVudC5cbiovXG5jbGFzcyBSZXBsYWNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG4vKlxuUmVwbGFjZUVycm9yID0gZnVuY3Rpb24odGhpczogYW55LCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgbGV0IGVyciA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSlcbiAgOyhlcnIgYXMgYW55KS5fX3Byb3RvX18gPSBSZXBsYWNlRXJyb3IucHJvdG90eXBlXG4gIHJldHVybiBlcnJcbn0gYXMgYW55XG5cblJlcGxhY2VFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcblJlcGxhY2VFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXBsYWNlRXJyb3JcblJlcGxhY2VFcnJvci5wcm90b3R5cGUubmFtZSA9IFwiUmVwbGFjZUVycm9yXCJcbiovXG4vKipcbkEgc2xpY2UgcmVwcmVzZW50cyBhIHBpZWNlIGN1dCBvdXQgb2YgYSBsYXJnZXIgZG9jdW1lbnQuIEl0XG5zdG9yZXMgbm90IG9ubHkgYSBmcmFnbWVudCwgYnV0IGFsc28gdGhlIGRlcHRoIHVwIHRvIHdoaWNoIG5vZGVzIG9uXG5ib3RoIHNpZGUgYXJlIFx1MjAxOG9wZW5cdTIwMTkgKGN1dCB0aHJvdWdoKS5cbiovXG5jbGFzcyBTbGljZSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2xpY2UuIFdoZW4gc3BlY2lmeWluZyBhIG5vbi16ZXJvIG9wZW4gZGVwdGgsIHlvdSBtdXN0XG4gICAgbWFrZSBzdXJlIHRoYXQgdGhlcmUgYXJlIG5vZGVzIG9mIGF0IGxlYXN0IHRoYXQgZGVwdGggYXQgdGhlXG4gICAgYXBwcm9wcmlhdGUgc2lkZSBvZiB0aGUgZnJhZ21lbnRcdTIwMTRpLmUuIGlmIHRoZSBmcmFnbWVudCBpcyBhblxuICAgIGVtcHR5IHBhcmFncmFwaCBub2RlLCBgb3BlblN0YXJ0YCBhbmQgYG9wZW5FbmRgIGNhbid0IGJlIGdyZWF0ZXJcbiAgICB0aGFuIDEuXG4gICAgXG4gICAgSXQgaXMgbm90IG5lY2Vzc2FyeSBmb3IgdGhlIGNvbnRlbnQgb2Ygb3BlbiBub2RlcyB0byBjb25mb3JtIHRvXG4gICAgdGhlIHNjaGVtYSdzIGNvbnRlbnQgY29uc3RyYWludHMsIHRob3VnaCBpdCBzaG91bGQgYmUgYSB2YWxpZFxuICAgIHN0YXJ0L2VuZC9taWRkbGUgZm9yIHN1Y2ggYSBub2RlLCBkZXBlbmRpbmcgb24gd2hpY2ggc2lkZXMgYXJlXG4gICAgb3Blbi5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSdzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBjb250ZW50LCBcbiAgICAvKipcbiAgICBUaGUgb3BlbiBkZXB0aCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50LlxuICAgICovXG4gICAgb3BlblN0YXJ0LCBcbiAgICAvKipcbiAgICBUaGUgb3BlbiBkZXB0aCBhdCB0aGUgZW5kLlxuICAgICovXG4gICAgb3BlbkVuZCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICAgICAgdGhpcy5vcGVuRW5kID0gb3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgdGhpcyBzbGljZSB3b3VsZCBhZGQgd2hlbiBpbnNlcnRlZCBpbnRvIGEgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5zaXplIC0gdGhpcy5vcGVuU3RhcnQgLSB0aGlzLm9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5zZXJ0QXQocG9zLCBmcmFnbWVudCkge1xuICAgICAgICBsZXQgY29udGVudCA9IGluc2VydEludG8odGhpcy5jb250ZW50LCBwb3MgKyB0aGlzLm9wZW5TdGFydCwgZnJhZ21lbnQpO1xuICAgICAgICByZXR1cm4gY29udGVudCAmJiBuZXcgU2xpY2UoY29udGVudCwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVtb3ZlQmV0d2Vlbihmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKHJlbW92ZVJhbmdlKHRoaXMuY29udGVudCwgZnJvbSArIHRoaXMub3BlblN0YXJ0LCB0byArIHRoaXMub3BlblN0YXJ0KSwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3RzIHdoZXRoZXIgdGhpcyBzbGljZSBpcyBlcXVhbCB0byBhbm90aGVyIHNsaWNlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5lcShvdGhlci5jb250ZW50KSAmJiB0aGlzLm9wZW5TdGFydCA9PSBvdGhlci5vcGVuU3RhcnQgJiYgdGhpcy5vcGVuRW5kID09IG90aGVyLm9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQgKyBcIihcIiArIHRoaXMub3BlblN0YXJ0ICsgXCIsXCIgKyB0aGlzLm9wZW5FbmQgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCBhIHNsaWNlIHRvIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGpzb24gPSB7IGNvbnRlbnQ6IHRoaXMuY29udGVudC50b0pTT04oKSB9O1xuICAgICAgICBpZiAodGhpcy5vcGVuU3RhcnQgPiAwKVxuICAgICAgICAgICAganNvbi5vcGVuU3RhcnQgPSB0aGlzLm9wZW5TdGFydDtcbiAgICAgICAgaWYgKHRoaXMub3BlbkVuZCA+IDApXG4gICAgICAgICAgICBqc29uLm9wZW5FbmQgPSB0aGlzLm9wZW5FbmQ7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHNsaWNlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHJldHVybiBTbGljZS5lbXB0eTtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IGpzb24ub3BlblN0YXJ0IHx8IDAsIG9wZW5FbmQgPSBqc29uLm9wZW5FbmQgfHwgMDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcGVuU3RhcnQgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygb3BlbkVuZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTbGljZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShGcmFnbWVudC5mcm9tSlNPTihzY2hlbWEsIGpzb24uY29udGVudCksIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNsaWNlIGZyb20gYSBmcmFnbWVudCBieSB0YWtpbmcgdGhlIG1heGltdW0gcG9zc2libGVcbiAgICBvcGVuIHZhbHVlIG9uIGJvdGggc2lkZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgbWF4T3BlbihmcmFnbWVudCwgb3Blbklzb2xhdGluZyA9IHRydWUpIHtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IDAsIG9wZW5FbmQgPSAwO1xuICAgICAgICBmb3IgKGxldCBuID0gZnJhZ21lbnQuZmlyc3RDaGlsZDsgbiAmJiAhbi5pc0xlYWYgJiYgKG9wZW5Jc29sYXRpbmcgfHwgIW4udHlwZS5zcGVjLmlzb2xhdGluZyk7IG4gPSBuLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgZm9yIChsZXQgbiA9IGZyYWdtZW50Lmxhc3RDaGlsZDsgbiAmJiAhbi5pc0xlYWYgJiYgKG9wZW5Jc29sYXRpbmcgfHwgIW4udHlwZS5zcGVjLmlzb2xhdGluZyk7IG4gPSBuLmxhc3RDaGlsZClcbiAgICAgICAgICAgIG9wZW5FbmQrKztcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShmcmFnbWVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzbGljZS5cbiovXG5TbGljZS5lbXB0eSA9IG5ldyBTbGljZShGcmFnbWVudC5lbXB0eSwgMCwgMCk7XG5mdW5jdGlvbiByZW1vdmVSYW5nZShjb250ZW50LCBmcm9tLCB0bykge1xuICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IGNvbnRlbnQuZmluZEluZGV4KGZyb20pLCBjaGlsZCA9IGNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgbGV0IHsgaW5kZXg6IGluZGV4VG8sIG9mZnNldDogb2Zmc2V0VG8gfSA9IGNvbnRlbnQuZmluZEluZGV4KHRvKTtcbiAgICBpZiAob2Zmc2V0ID09IGZyb20gfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgIGlmIChvZmZzZXRUbyAhPSB0byAmJiAhY29udGVudC5jaGlsZChpbmRleFRvKS5pc1RleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZnJvbSkuYXBwZW5kKGNvbnRlbnQuY3V0KHRvKSk7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPSBpbmRleFRvKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpO1xuICAgIHJldHVybiBjb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgY2hpbGQuY29weShyZW1vdmVSYW5nZShjaGlsZC5jb250ZW50LCBmcm9tIC0gb2Zmc2V0IC0gMSwgdG8gLSBvZmZzZXQgLSAxKSkpO1xufVxuZnVuY3Rpb24gaW5zZXJ0SW50byhjb250ZW50LCBkaXN0LCBpbnNlcnQsIHBhcmVudCkge1xuICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IGNvbnRlbnQuZmluZEluZGV4KGRpc3QpLCBjaGlsZCA9IGNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgaWYgKG9mZnNldCA9PSBkaXN0IHx8IGNoaWxkLmlzVGV4dCkge1xuICAgICAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXgsIGluc2VydCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQuY3V0KDAsIGRpc3QpLmFwcGVuZChpbnNlcnQpLmFwcGVuZChjb250ZW50LmN1dChkaXN0KSk7XG4gICAgfVxuICAgIGxldCBpbm5lciA9IGluc2VydEludG8oY2hpbGQuY29udGVudCwgZGlzdCAtIG9mZnNldCAtIDEsIGluc2VydCk7XG4gICAgcmV0dXJuIGlubmVyICYmIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KGlubmVyKSk7XG59XG5mdW5jdGlvbiByZXBsYWNlKCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gICAgaWYgKHNsaWNlLm9wZW5TdGFydCA+ICRmcm9tLmRlcHRoKVxuICAgICAgICB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiSW5zZXJ0ZWQgY29udGVudCBkZWVwZXIgdGhhbiBpbnNlcnRpb24gcG9zaXRpb25cIik7XG4gICAgaWYgKCRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0ICE9ICR0by5kZXB0aCAtIHNsaWNlLm9wZW5FbmQpXG4gICAgICAgIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbmNvbnNpc3RlbnQgb3BlbiBkZXB0aHNcIik7XG4gICAgcmV0dXJuIHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgMCk7XG59XG5mdW5jdGlvbiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoKSB7XG4gICAgbGV0IGluZGV4ID0gJGZyb20uaW5kZXgoZGVwdGgpLCBub2RlID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgaWYgKGluZGV4ID09ICR0by5pbmRleChkZXB0aCkgJiYgZGVwdGggPCAkZnJvbS5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCkge1xuICAgICAgICBsZXQgaW5uZXIgPSByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoICsgMSk7XG4gICAgICAgIHJldHVybiBub2RlLmNvcHkobm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgaW5uZXIpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXNsaWNlLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICghc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLmRlcHRoID09IGRlcHRoICYmICR0by5kZXB0aCA9PSBkZXB0aCkgeyAvLyBTaW1wbGUsIGZsYXQgY2FzZVxuICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ucGFyZW50LCBjb250ZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICAgIHJldHVybiBjbG9zZShwYXJlbnQsIGNvbnRlbnQuY3V0KDAsICRmcm9tLnBhcmVudE9mZnNldCkuYXBwZW5kKHNsaWNlLmNvbnRlbnQpLmFwcGVuZChjb250ZW50LmN1dCgkdG8ucGFyZW50T2Zmc2V0KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcHJlcGFyZVNsaWNlRm9yUmVwbGFjZShzbGljZSwgJGZyb20pO1xuICAgICAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCBzdGFydCwgZW5kLCAkdG8sIGRlcHRoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tKb2luKG1haW4sIHN1Yikge1xuICAgIGlmICghc3ViLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobWFpbi50eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkNhbm5vdCBqb2luIFwiICsgc3ViLnR5cGUubmFtZSArIFwiIG9udG8gXCIgKyBtYWluLnR5cGUubmFtZSk7XG59XG5mdW5jdGlvbiBqb2luYWJsZSgkYmVmb3JlLCAkYWZ0ZXIsIGRlcHRoKSB7XG4gICAgbGV0IG5vZGUgPSAkYmVmb3JlLm5vZGUoZGVwdGgpO1xuICAgIGNoZWNrSm9pbihub2RlLCAkYWZ0ZXIubm9kZShkZXB0aCkpO1xuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gYWRkTm9kZShjaGlsZCwgdGFyZ2V0KSB7XG4gICAgbGV0IGxhc3QgPSB0YXJnZXQubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA+PSAwICYmIGNoaWxkLmlzVGV4dCAmJiBjaGlsZC5zYW1lTWFya3VwKHRhcmdldFtsYXN0XSkpXG4gICAgICAgIHRhcmdldFtsYXN0XSA9IGNoaWxkLndpdGhUZXh0KHRhcmdldFtsYXN0XS50ZXh0ICsgY2hpbGQudGV4dCk7XG4gICAgZWxzZVxuICAgICAgICB0YXJnZXQucHVzaChjaGlsZCk7XG59XG5mdW5jdGlvbiBhZGRSYW5nZSgkc3RhcnQsICRlbmQsIGRlcHRoLCB0YXJnZXQpIHtcbiAgICBsZXQgbm9kZSA9ICgkZW5kIHx8ICRzdGFydCkubm9kZShkZXB0aCk7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwLCBlbmRJbmRleCA9ICRlbmQgPyAkZW5kLmluZGV4KGRlcHRoKSA6IG5vZGUuY2hpbGRDb3VudDtcbiAgICBpZiAoJHN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSAkc3RhcnQuaW5kZXgoZGVwdGgpO1xuICAgICAgICBpZiAoJHN0YXJ0LmRlcHRoID4gZGVwdGgpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgkc3RhcnQudGV4dE9mZnNldCkge1xuICAgICAgICAgICAgYWRkTm9kZSgkc3RhcnQubm9kZUFmdGVyLCB0YXJnZXQpO1xuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKylcbiAgICAgICAgYWRkTm9kZShub2RlLmNoaWxkKGkpLCB0YXJnZXQpO1xuICAgIGlmICgkZW5kICYmICRlbmQuZGVwdGggPT0gZGVwdGggJiYgJGVuZC50ZXh0T2Zmc2V0KVxuICAgICAgICBhZGROb2RlKCRlbmQubm9kZUJlZm9yZSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGNsb3NlKG5vZGUsIGNvbnRlbnQpIHtcbiAgICBub2RlLnR5cGUuY2hlY2tDb250ZW50KGNvbnRlbnQpO1xuICAgIHJldHVybiBub2RlLmNvcHkoY29udGVudCk7XG59XG5mdW5jdGlvbiByZXBsYWNlVGhyZWVXYXkoJGZyb20sICRzdGFydCwgJGVuZCwgJHRvLCBkZXB0aCkge1xuICAgIGxldCBvcGVuU3RhcnQgPSAkZnJvbS5kZXB0aCA+IGRlcHRoICYmIGpvaW5hYmxlKCRmcm9tLCAkc3RhcnQsIGRlcHRoICsgMSk7XG4gICAgbGV0IG9wZW5FbmQgPSAkdG8uZGVwdGggPiBkZXB0aCAmJiBqb2luYWJsZSgkZW5kLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgbGV0IGNvbnRlbnQgPSBbXTtcbiAgICBhZGRSYW5nZShudWxsLCAkZnJvbSwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIGlmIChvcGVuU3RhcnQgJiYgb3BlbkVuZCAmJiAkc3RhcnQuaW5kZXgoZGVwdGgpID09ICRlbmQuaW5kZXgoZGVwdGgpKSB7XG4gICAgICAgIGNoZWNrSm9pbihvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICBhZGROb2RlKGNsb3NlKG9wZW5TdGFydCwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCAkc3RhcnQsICRlbmQsICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9wZW5TdGFydClcbiAgICAgICAgICAgIGFkZE5vZGUoY2xvc2Uob3BlblN0YXJ0LCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkc3RhcnQsIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICAgICAgYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgY29udGVudCk7XG4gICAgICAgIGlmIChvcGVuRW5kKVxuICAgICAgICAgICAgYWRkTm9kZShjbG9zZShvcGVuRW5kLCByZXBsYWNlVHdvV2F5KCRlbmQsICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCkge1xuICAgIGxldCBjb250ZW50ID0gW107XG4gICAgYWRkUmFuZ2UobnVsbCwgJGZyb20sIGRlcHRoLCBjb250ZW50KTtcbiAgICBpZiAoJGZyb20uZGVwdGggPiBkZXB0aCkge1xuICAgICAgICBsZXQgdHlwZSA9IGpvaW5hYmxlKCRmcm9tLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgICAgIGFkZE5vZGUoY2xvc2UodHlwZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGFkZFJhbmdlKCR0bywgbnVsbCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCk7XG59XG5mdW5jdGlvbiBwcmVwYXJlU2xpY2VGb3JSZXBsYWNlKHNsaWNlLCAkYWxvbmcpIHtcbiAgICBsZXQgZXh0cmEgPSAkYWxvbmcuZGVwdGggLSBzbGljZS5vcGVuU3RhcnQsIHBhcmVudCA9ICRhbG9uZy5ub2RlKGV4dHJhKTtcbiAgICBsZXQgbm9kZSA9IHBhcmVudC5jb3B5KHNsaWNlLmNvbnRlbnQpO1xuICAgIGZvciAobGV0IGkgPSBleHRyYSAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBub2RlID0gJGFsb25nLm5vZGUoaSkuY29weShGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICByZXR1cm4geyBzdGFydDogbm9kZS5yZXNvbHZlTm9DYWNoZShzbGljZS5vcGVuU3RhcnQgKyBleHRyYSksXG4gICAgICAgIGVuZDogbm9kZS5yZXNvbHZlTm9DYWNoZShub2RlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQgLSBleHRyYSkgfTtcbn1cblxuLyoqXG5Zb3UgY2FuIFtfcmVzb2x2ZV9dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnJlc29sdmUpIGEgcG9zaXRpb24gdG8gZ2V0IG1vcmVcbmluZm9ybWF0aW9uIGFib3V0IGl0LiBPYmplY3RzIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50IHN1Y2ggYVxucmVzb2x2ZWQgcG9zaXRpb24sIHByb3ZpZGluZyB2YXJpb3VzIHBpZWNlcyBvZiBjb250ZXh0XG5pbmZvcm1hdGlvbiwgYW5kIHNvbWUgaGVscGVyIG1ldGhvZHMuXG5cblRocm91Z2hvdXQgdGhpcyBpbnRlcmZhY2UsIG1ldGhvZHMgdGhhdCB0YWtlIGFuIG9wdGlvbmFsIGBkZXB0aGBcbnBhcmFtZXRlciB3aWxsIGludGVycHJldCB1bmRlZmluZWQgYXMgYHRoaXMuZGVwdGhgIGFuZCBuZWdhdGl2ZVxubnVtYmVycyBhcyBgdGhpcy5kZXB0aCArIHZhbHVlYC5cbiovXG5jbGFzcyBSZXNvbHZlZFBvcyB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gdGhhdCB3YXMgcmVzb2x2ZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcGF0aCwgXG4gICAgLyoqXG4gICAgVGhlIG9mZnNldCB0aGlzIHBvc2l0aW9uIGhhcyBpbnRvIGl0cyBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIHBhcmVudE9mZnNldCkge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5wYXJlbnRPZmZzZXQgPSBwYXJlbnRPZmZzZXQ7XG4gICAgICAgIHRoaXMuZGVwdGggPSBwYXRoLmxlbmd0aCAvIDMgLSAxO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVEZXB0aCh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGg7XG4gICAgICAgIGlmICh2YWwgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGggKyB2YWw7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwYXJlbnQgbm9kZSB0aGF0IHRoZSBwb3NpdGlvbiBwb2ludHMgaW50by4gTm90ZSB0aGF0IGV2ZW4gaWZcbiAgICBhIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCB0aGF0IG5vZGUgaXMgbm90IGNvbnNpZGVyZWRcbiAgICB0aGUgcGFyZW50XHUyMDE0dGV4dCBub2RlcyBhcmUgXHUyMDE4ZmxhdFx1MjAxOSBpbiB0aGlzIG1vZGVsLCBhbmQgaGF2ZSBubyBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMubm9kZSh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSByb290IG5vZGUgaW4gd2hpY2ggdGhlIHBvc2l0aW9uIHdhcyByZXNvbHZlZC5cbiAgICAqL1xuICAgIGdldCBkb2MoKSB7IHJldHVybiB0aGlzLm5vZGUoMCk7IH1cbiAgICAvKipcbiAgICBUaGUgYW5jZXN0b3Igbm9kZSBhdCB0aGUgZ2l2ZW4gbGV2ZWwuIGBwLm5vZGUocC5kZXB0aClgIGlzIHRoZVxuICAgIHNhbWUgYXMgYHAucGFyZW50YC5cbiAgICAqL1xuICAgIG5vZGUoZGVwdGgpIHsgcmV0dXJuIHRoaXMucGF0aFt0aGlzLnJlc29sdmVEZXB0aChkZXB0aCkgKiAzXTsgfVxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBpbnRvIHRoZSBhbmNlc3RvciBhdCB0aGUgZ2l2ZW4gbGV2ZWwuIElmIHRoaXMgcG9pbnRzXG4gICAgYXQgdGhlIDNyZCBub2RlIGluIHRoZSAybmQgcGFyYWdyYXBoIG9uIHRoZSB0b3AgbGV2ZWwsIGZvclxuICAgIGV4YW1wbGUsIGBwLmluZGV4KDApYCBpcyAxIGFuZCBgcC5pbmRleCgxKWAgaXMgMi5cbiAgICAqL1xuICAgIGluZGV4KGRlcHRoKSB7IHJldHVybiB0aGlzLnBhdGhbdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpICogMyArIDFdOyB9XG4gICAgLyoqXG4gICAgVGhlIGluZGV4IHBvaW50aW5nIGFmdGVyIHRoaXMgcG9zaXRpb24gaW50byB0aGUgYW5jZXN0b3IgYXQgdGhlXG4gICAgZ2l2ZW4gbGV2ZWwuXG4gICAgKi9cbiAgICBpbmRleEFmdGVyKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleChkZXB0aCkgKyAoZGVwdGggPT0gdGhpcy5kZXB0aCAmJiAhdGhpcy50ZXh0T2Zmc2V0ID8gMCA6IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuXG4gICAgbGV2ZWwuXG4gICAgKi9cbiAgICBzdGFydChkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IDAgPyAwIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW5cbiAgICBsZXZlbC5cbiAgICAqL1xuICAgIGVuZChkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoZGVwdGgpICsgdGhpcy5ub2RlKGRlcHRoKS5jb250ZW50LnNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGRpcmVjdGx5IGJlZm9yZSB0aGUgd3JhcHBpbmcgbm9kZSBhdCB0aGVcbiAgICBnaXZlbiBsZXZlbCwgb3IsIHdoZW4gYGRlcHRoYCBpcyBgdGhpcy5kZXB0aCArIDFgLCB0aGUgb3JpZ2luYWxcbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGJlZm9yZShkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gcG9zaXRpb24gYmVmb3JlIHRoZSB0b3AtbGV2ZWwgbm9kZVwiKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IHRoaXMuZGVwdGggKyAxID8gdGhpcy5wb3MgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV07XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGRpcmVjdGx5IGFmdGVyIHRoZSB3cmFwcGluZyBub2RlIGF0IHRoZVxuICAgIGdpdmVuIGxldmVsLCBvciB0aGUgb3JpZ2luYWwgcG9zaXRpb24gd2hlbiBgZGVwdGhgIGlzIGB0aGlzLmRlcHRoICsgMWAuXG4gICAgKi9cbiAgICBhZnRlcihkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gcG9zaXRpb24gYWZ0ZXIgdGhlIHRvcC1sZXZlbCBub2RlXCIpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gdGhpcy5kZXB0aCArIDEgPyB0aGlzLnBvcyA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIHRoaXMucGF0aFtkZXB0aCAqIDNdLm5vZGVTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGVuIHRoaXMgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIHRoaXMgcmV0dXJucyB0aGVcbiAgICBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb3NpdGlvbiBhbmQgdGhlIHN0YXJ0IG9mIHRoZSB0ZXh0IG5vZGUuXG4gICAgV2lsbCBiZSB6ZXJvIGZvciBwb3NpdGlvbnMgdGhhdCBwb2ludCBiZXR3ZWVuIG5vZGVzLlxuICAgICovXG4gICAgZ2V0IHRleHRPZmZzZXQoKSB7IHJldHVybiB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG5vZGUgZGlyZWN0bHkgYWZ0ZXIgdGhlIHBvc2l0aW9uLCBpZiBhbnkuIElmIHRoZSBwb3NpdGlvblxuICAgIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCBvbmx5IHRoZSBwYXJ0IG9mIHRoYXQgbm9kZSBhZnRlciB0aGVcbiAgICBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGdldCBub2RlQWZ0ZXIoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudCwgaW5kZXggPSB0aGlzLmluZGV4KHRoaXMuZGVwdGgpO1xuICAgICAgICBpZiAoaW5kZXggPT0gcGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRPZmYgPSB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV0sIGNoaWxkID0gcGFyZW50LmNoaWxkKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGRPZmYgPyBwYXJlbnQuY2hpbGQoaW5kZXgpLmN1dChkT2ZmKSA6IGNoaWxkO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG5vZGUgZGlyZWN0bHkgYmVmb3JlIHRoZSBwb3NpdGlvbiwgaWYgYW55LiBJZiB0aGVcbiAgICBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgb25seSB0aGUgcGFydCBvZiB0aGF0IG5vZGVcbiAgICBiZWZvcmUgdGhlIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZ2V0IG5vZGVCZWZvcmUoKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgICAgIGxldCBkT2ZmID0gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZE9mZilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCkuY3V0KDAsIGRPZmYpO1xuICAgICAgICByZXR1cm4gaW5kZXggPT0gMCA/IG51bGwgOiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgcGFyZW50IG5vZGUgYXQgdGhlXG4gICAgZ2l2ZW4gZGVwdGggKHdoaWNoIGRlZmF1bHRzIHRvIGB0aGlzLmRlcHRoYCkuXG4gICAgKi9cbiAgICBwb3NBdEluZGV4KGluZGV4LCBkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnBhdGhbZGVwdGggKiAzXSwgcG9zID0gZGVwdGggPT0gMCA/IDAgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspXG4gICAgICAgICAgICBwb3MgKz0gbm9kZS5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXJrcyBhdCB0aGlzIHBvc2l0aW9uLCBmYWN0b3JpbmcgaW4gdGhlIHN1cnJvdW5kaW5nXG4gICAgbWFya3MnIFtgaW5jbHVzaXZlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtTcGVjLmluY2x1c2l2ZSkgcHJvcGVydHkuIElmIHRoZVxuICAgIHBvc2l0aW9uIGlzIGF0IHRoZSBzdGFydCBvZiBhIG5vbi1lbXB0eSBub2RlLCB0aGUgbWFya3Mgb2YgdGhlXG4gICAgbm9kZSBhZnRlciBpdCAoaWYgYW55KSBhcmUgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBtYXJrcygpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50LCBpbmRleCA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgLy8gSW4gYW4gZW1wdHkgcGFyZW50LCByZXR1cm4gdGhlIGVtcHR5IGFycmF5XG4gICAgICAgIGlmIChwYXJlbnQuY29udGVudC5zaXplID09IDApXG4gICAgICAgICAgICByZXR1cm4gTWFyay5ub25lO1xuICAgICAgICAvLyBXaGVuIGluc2lkZSBhIHRleHQgbm9kZSwganVzdCByZXR1cm4gdGhlIHRleHQgbm9kZSdzIG1hcmtzXG4gICAgICAgIGlmICh0aGlzLnRleHRPZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkKGluZGV4KS5tYXJrcztcbiAgICAgICAgbGV0IG1haW4gPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCAtIDEpLCBvdGhlciA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgLy8gSWYgdGhlIGBhZnRlcmAgZmxhZyBpcyB0cnVlIG9mIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlLCBtYWtlXG4gICAgICAgIC8vIHRoZSBub2RlIGFmdGVyIHRoaXMgcG9zaXRpb24gdGhlIG1haW4gcmVmZXJlbmNlLlxuICAgICAgICBpZiAoIW1haW4pIHtcbiAgICAgICAgICAgIGxldCB0bXAgPSBtYWluO1xuICAgICAgICAgICAgbWFpbiA9IG90aGVyO1xuICAgICAgICAgICAgb3RoZXIgPSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGFsbCBtYXJrcyBpbiB0aGUgbWFpbiBub2RlLCBleGNlcHQgdGhvc2UgdGhhdCBoYXZlXG4gICAgICAgIC8vIGBpbmNsdXNpdmVgIHNldCB0byBmYWxzZSBhbmQgYXJlIG5vdCBwcmVzZW50IGluIHRoZSBvdGhlciBub2RlLlxuICAgICAgICBsZXQgbWFya3MgPSBtYWluLm1hcmtzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghb3RoZXIgfHwgIW1hcmtzW2ldLmlzSW5TZXQob3RoZXIubWFya3MpKSlcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzW2ktLV0ucmVtb3ZlRnJvbVNldChtYXJrcyk7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXJrcyBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbiwgaWYgYW55LCBleGNlcHQgdGhvc2VcbiAgICB0aGF0IGFyZSBub24taW5jbHVzaXZlIGFuZCBub3QgcHJlc2VudCBhdCBwb3NpdGlvbiBgJGVuZGAuIFRoaXNcbiAgICBpcyBtb3N0bHkgdXNlZnVsIGZvciBnZXR0aW5nIHRoZSBzZXQgb2YgbWFya3MgdG8gcHJlc2VydmUgYWZ0ZXIgYVxuICAgIGRlbGV0aW9uLiBXaWxsIHJldHVybiBgbnVsbGAgaWYgdGhpcyBwb3NpdGlvbiBpcyBhdCB0aGUgZW5kIG9mXG4gICAgaXRzIHBhcmVudCBub2RlIG9yIGl0cyBwYXJlbnQgbm9kZSBpc24ndCBhIHRleHRibG9jayAoaW4gd2hpY2hcbiAgICBjYXNlIG5vIG1hcmtzIHNob3VsZCBiZSBwcmVzZXJ2ZWQpLlxuICAgICovXG4gICAgbWFya3NBY3Jvc3MoJGVuZCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLnBhcmVudC5tYXliZUNoaWxkKHRoaXMuaW5kZXgoKSk7XG4gICAgICAgIGlmICghYWZ0ZXIgfHwgIWFmdGVyLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBtYXJrcyA9IGFmdGVyLm1hcmtzLCBuZXh0ID0gJGVuZC5wYXJlbnQubWF5YmVDaGlsZCgkZW5kLmluZGV4KCkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghbmV4dCB8fCAhbWFya3NbaV0uaXNJblNldChuZXh0Lm1hcmtzKSkpXG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrc1tpLS1dLnJlbW92ZUZyb21TZXQobWFya3MpO1xuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBkZXB0aCB1cCB0byB3aGljaCB0aGlzIHBvc2l0aW9uIGFuZCB0aGUgZ2l2ZW4gKG5vbi1yZXNvbHZlZClcbiAgICBwb3NpdGlvbiBzaGFyZSB0aGUgc2FtZSBwYXJlbnQgbm9kZXMuXG4gICAgKi9cbiAgICBzaGFyZWREZXB0aChwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSB0aGlzLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoLS0pXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydChkZXB0aCkgPD0gcG9zICYmIHRoaXMuZW5kKGRlcHRoKSA+PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHJhbmdlIGJhc2VkIG9uIHRoZSBwbGFjZSB3aGVyZSB0aGlzIHBvc2l0aW9uIGFuZCB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbiBkaXZlcmdlIGFyb3VuZCBibG9jayBjb250ZW50LiBJZiBib3RoIHBvaW50IGludG9cbiAgICB0aGUgc2FtZSB0ZXh0YmxvY2ssIGZvciBleGFtcGxlLCBhIHJhbmdlIGFyb3VuZCB0aGF0IHRleHRibG9ja1xuICAgIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZXkgcG9pbnQgaW50byBkaWZmZXJlbnQgYmxvY2tzLCB0aGUgcmFuZ2VcbiAgICBhcm91bmQgdGhvc2UgYmxvY2tzIGluIHRoZWlyIHNoYXJlZCBhbmNlc3RvciBpcyByZXR1cm5lZC4gWW91IGNhblxuICAgIHBhc3MgaW4gYW4gb3B0aW9uYWwgcHJlZGljYXRlIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHBhcmVudFxuICAgIG5vZGUgdG8gc2VlIGlmIGEgcmFuZ2UgaW50byB0aGF0IHBhcmVudCBpcyBhY2NlcHRhYmxlLlxuICAgICovXG4gICAgYmxvY2tSYW5nZShvdGhlciA9IHRoaXMsIHByZWQpIHtcbiAgICAgICAgaWYgKG90aGVyLnBvcyA8IHRoaXMucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG90aGVyLmJsb2NrUmFuZ2UodGhpcyk7XG4gICAgICAgIGZvciAobGV0IGQgPSB0aGlzLmRlcHRoIC0gKHRoaXMucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdGhpcy5wb3MgPT0gb3RoZXIucG9zID8gMSA6IDApOyBkID49IDA7IGQtLSlcbiAgICAgICAgICAgIGlmIChvdGhlci5wb3MgPD0gdGhpcy5lbmQoZCkgJiYgKCFwcmVkIHx8IHByZWQodGhpcy5ub2RlKGQpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlUmFuZ2UodGhpcywgb3RoZXIsIGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcnkgd2hldGhlciB0aGUgZ2l2ZW4gcG9zaXRpb24gc2hhcmVzIHRoZSBzYW1lIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgc2FtZVBhcmVudChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgLSB0aGlzLnBhcmVudE9mZnNldCA9PSBvdGhlci5wb3MgLSBvdGhlci5wYXJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZ3JlYXRlciBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBtYXgob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLnBvcyA+IHRoaXMucG9zID8gb3RoZXIgOiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIHNtYWxsZXIgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbWluKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5wb3MgPCB0aGlzLnBvcyA/IG90aGVyIDogdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMuZGVwdGg7IGkrKylcbiAgICAgICAgICAgIHN0ciArPSAoc3RyID8gXCIvXCIgOiBcIlwiKSArIHRoaXMubm9kZShpKS50eXBlLm5hbWUgKyBcIl9cIiArIHRoaXMuaW5kZXgoaSAtIDEpO1xuICAgICAgICByZXR1cm4gc3RyICsgXCI6XCIgKyB0aGlzLnBhcmVudE9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZShkb2MsIHBvcykge1xuICAgICAgICBpZiAoIShwb3MgPj0gMCAmJiBwb3MgPD0gZG9jLmNvbnRlbnQuc2l6ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBvc2l0aW9uIFwiICsgcG9zICsgXCIgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICBsZXQgcGF0aCA9IFtdO1xuICAgICAgICBsZXQgc3RhcnQgPSAwLCBwYXJlbnRPZmZzZXQgPSBwb3M7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSBkb2M7Oykge1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwYXJlbnRPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IHJlbSA9IHBhcmVudE9mZnNldCAtIG9mZnNldDtcbiAgICAgICAgICAgIHBhdGgucHVzaChub2RlLCBpbmRleCwgc3RhcnQgKyBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFyZW0pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAobm9kZS5pc1RleHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSByZW0gLSAxO1xuICAgICAgICAgICAgc3RhcnQgKz0gb2Zmc2V0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkUG9zKHBvcywgcGF0aCwgcGFyZW50T2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZUNhY2hlZChkb2MsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVDYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHJlc29sdmVDYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQucG9zID09IHBvcyAmJiBjYWNoZWQuZG9jID09IGRvYylcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSByZXNvbHZlQ2FjaGVbcmVzb2x2ZUNhY2hlUG9zXSA9IFJlc29sdmVkUG9zLnJlc29sdmUoZG9jLCBwb3MpO1xuICAgICAgICByZXNvbHZlQ2FjaGVQb3MgPSAocmVzb2x2ZUNhY2hlUG9zICsgMSkgJSByZXNvbHZlQ2FjaGVTaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmxldCByZXNvbHZlQ2FjaGUgPSBbXSwgcmVzb2x2ZUNhY2hlUG9zID0gMCwgcmVzb2x2ZUNhY2hlU2l6ZSA9IDEyO1xuLyoqXG5SZXByZXNlbnRzIGEgZmxhdCByYW5nZSBvZiBjb250ZW50LCBpLmUuIG9uZSB0aGF0IHN0YXJ0cyBhbmRcbmVuZHMgaW4gdGhlIHNhbWUgbm9kZS5cbiovXG5jbGFzcyBOb2RlUmFuZ2Uge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIG5vZGUgcmFuZ2UuIGAkZnJvbWAgYW5kIGAkdG9gIHNob3VsZCBwb2ludCBpbnRvIHRoZVxuICAgIHNhbWUgbm9kZSB1bnRpbCBhdCBsZWFzdCB0aGUgZ2l2ZW4gYGRlcHRoYCwgc2luY2UgYSBub2RlIHJhbmdlXG4gICAgZGVub3RlcyBhbiBhZGphY2VudCBzZXQgb2Ygbm9kZXMgaW4gYSBzaW5nbGUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBBIHJlc29sdmVkIHBvc2l0aW9uIGFsb25nIHRoZSBzdGFydCBvZiB0aGUgY29udGVudC4gTWF5IGhhdmUgYVxuICAgIGBkZXB0aGAgZ3JlYXRlciB0aGFuIHRoaXMgb2JqZWN0J3MgYGRlcHRoYCBwcm9wZXJ0eSwgc2luY2VcbiAgICB0aGVzZSBhcmUgdGhlIHBvc2l0aW9ucyB0aGF0IHdlcmUgdXNlZCB0byBjb21wdXRlIHRoZSByYW5nZSxcbiAgICBub3QgcmUtcmVzb2x2ZWQgcG9zaXRpb25zIGRpcmVjdGx5IGF0IGl0cyBib3VuZGFyaWVzLlxuICAgICovXG4gICAgJGZyb20sIFxuICAgIC8qKlxuICAgIEEgcG9zaXRpb24gYWxvbmcgdGhlIGVuZCBvZiB0aGUgY29udGVudC4gU2VlXG4gICAgY2F2ZWF0IGZvciBbYCRmcm9tYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVSYW5nZS4kZnJvbSkuXG4gICAgKi9cbiAgICAkdG8sIFxuICAgIC8qKlxuICAgIFRoZSBkZXB0aCBvZiB0aGUgbm9kZSB0aGF0IHRoaXMgcmFuZ2UgcG9pbnRzIGludG8uXG4gICAgKi9cbiAgICBkZXB0aCkge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5iZWZvcmUodGhpcy5kZXB0aCArIDEpOyB9XG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuJHRvLmFmdGVyKHRoaXMuZGVwdGggKyAxKTsgfVxuICAgIC8qKlxuICAgIFRoZSBwYXJlbnQgbm9kZSB0aGF0IHRoZSByYW5nZSBwb2ludHMgaW50by5cbiAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7IHJldHVybiB0aGlzLiRmcm9tLm5vZGUodGhpcy5kZXB0aCk7IH1cbiAgICAvKipcbiAgICBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIHJhbmdlIGluIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBzdGFydEluZGV4KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5pbmRleCh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSBlbmQgaW5kZXggb2YgdGhlIHJhbmdlIGluIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBlbmRJbmRleCgpIHsgcmV0dXJuIHRoaXMuJHRvLmluZGV4QWZ0ZXIodGhpcy5kZXB0aCk7IH1cbn1cblxuY29uc3QgZW1wdHlBdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcblRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIG5vZGUgaW4gdGhlIHRyZWUgdGhhdCBtYWtlcyB1cCBhXG5Qcm9zZU1pcnJvciBkb2N1bWVudC4gU28gYSBkb2N1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBgTm9kZWAsIHdpdGhcbmNoaWxkcmVuIHRoYXQgYXJlIGFsc28gaW5zdGFuY2VzIG9mIGBOb2RlYC5cblxuTm9kZXMgYXJlIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVzLiBJbnN0ZWFkIG9mIGNoYW5naW5nIHRoZW0sIHlvdVxuY3JlYXRlIG5ldyBvbmVzIHdpdGggdGhlIGNvbnRlbnQgeW91IHdhbnQuIE9sZCBvbmVzIGtlZXAgcG9pbnRpbmdcbmF0IHRoZSBvbGQgZG9jdW1lbnQgc2hhcGUuIFRoaXMgaXMgbWFkZSBjaGVhcGVyIGJ5IHNoYXJpbmdcbnN0cnVjdHVyZSBiZXR3ZWVuIHRoZSBvbGQgYW5kIG5ldyBkYXRhIGFzIG11Y2ggYXMgcG9zc2libGUsIHdoaWNoIGFcbnRyZWUgc2hhcGUgbGlrZSB0aGlzICh3aXRob3V0IGJhY2sgcG9pbnRlcnMpIG1ha2VzIGVhc3kuXG5cbioqRG8gbm90KiogZGlyZWN0bHkgbXV0YXRlIHRoZSBwcm9wZXJ0aWVzIG9mIGEgYE5vZGVgIG9iamVjdC4gU2VlXG5bdGhlIGd1aWRlXSgvZG9jcy9ndWlkZS8jZG9jKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiovXG5jbGFzcyBOb2RlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIG5vZGUgdGhhdCB0aGlzIGlzLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgQW4gb2JqZWN0IG1hcHBpbmcgYXR0cmlidXRlIG5hbWVzIHRvIHZhbHVlcy4gVGhlIGtpbmQgb2ZcbiAgICBhdHRyaWJ1dGVzIGFsbG93ZWQgYW5kIHJlcXVpcmVkIGFyZVxuICAgIFtkZXRlcm1pbmVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuYXR0cnMpIGJ5IHRoZSBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBhdHRycywgXG4gICAgLy8gQSBmcmFnbWVudCBob2xkaW5nIHRoZSBub2RlJ3MgY2hpbGRyZW4uXG4gICAgY29udGVudCwgXG4gICAgLyoqXG4gICAgVGhlIG1hcmtzICh0aGluZ3MgbGlrZSB3aGV0aGVyIGl0IGlzIGVtcGhhc2l6ZWQgb3IgcGFydCBvZiBhXG4gICAgbGluaykgYXBwbGllZCB0byB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBtYXJrcyA9IE1hcmsubm9uZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudCB8fCBGcmFnbWVudC5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgb2YgdGhpcyBub2RlLCBhcyBkZWZpbmVkIGJ5IHRoZSBpbnRlZ2VyLWJhc2VkIFtpbmRleGluZ1xuICAgIHNjaGVtZV0oL2RvY3MvZ3VpZGUvI2RvYy5pbmRleGluZykuIEZvciB0ZXh0IG5vZGVzLCB0aGlzIGlzIHRoZVxuICAgIGFtb3VudCBvZiBjaGFyYWN0ZXJzLiBGb3Igb3RoZXIgbGVhZiBub2RlcywgaXQgaXMgb25lLiBGb3JcbiAgICBub24tbGVhZiBub2RlcywgaXQgaXMgdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgcGx1cyB0d28gKHRoZVxuICAgIHN0YXJ0IGFuZCBlbmQgdG9rZW4pLlxuICAgICovXG4gICAgZ2V0IG5vZGVTaXplKCkgeyByZXR1cm4gdGhpcy5pc0xlYWYgPyAxIDogMiArIHRoaXMuY29udGVudC5zaXplOyB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IHRoZSBub2RlIGhhcy5cbiAgICAqL1xuICAgIGdldCBjaGlsZENvdW50KCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkQ291bnQ7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LiBSYWlzZXMgYW4gZXJyb3Igd2hlbiB0aGVcbiAgICBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgKi9cbiAgICBjaGlsZChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4KTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGl0IGV4aXN0cy5cbiAgICAqL1xuICAgIG1heWJlQ2hpbGQoaW5kZXgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KTsgfVxuICAgIC8qKlxuICAgIENhbGwgYGZgIGZvciBldmVyeSBjaGlsZCBub2RlLCBwYXNzaW5nIHRoZSBub2RlLCBpdHMgb2Zmc2V0XG4gICAgaW50byB0aGlzIHBhcmVudCBub2RlLCBhbmQgaXRzIGluZGV4LlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7IHRoaXMuY29udGVudC5mb3JFYWNoKGYpOyB9XG4gICAgLyoqXG4gICAgSW52b2tlIGEgY2FsbGJhY2sgZm9yIGFsbCBkZXNjZW5kYW50IG5vZGVzIHJlY3Vyc2l2ZWx5IGJldHdlZW5cbiAgICB0aGUgZ2l2ZW4gdHdvIHBvc2l0aW9ucyB0aGF0IGFyZSByZWxhdGl2ZSB0byBzdGFydCBvZiB0aGlzXG4gICAgbm9kZSdzIGNvbnRlbnQuIFRoZSBjYWxsYmFjayBpcyBpbnZva2VkIHdpdGggdGhlIG5vZGUsIGl0c1xuICAgIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5hbCBub2RlIChtZXRob2QgcmVjZWl2ZXIpLFxuICAgIGl0cyBwYXJlbnQgbm9kZSwgYW5kIGl0cyBjaGlsZCBpbmRleC4gV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJuc1xuICAgIGZhbHNlIGZvciBhIGdpdmVuIG5vZGUsIHRoYXQgbm9kZSdzIGNoaWxkcmVuIHdpbGwgbm90IGJlXG4gICAgcmVjdXJzZWQgb3Zlci4gVGhlIGxhc3QgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgYVxuICAgIHN0YXJ0aW5nIHBvc2l0aW9uIHRvIGNvdW50IGZyb20uXG4gICAgKi9cbiAgICBub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIHN0YXJ0UG9zID0gMCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBzdGFydFBvcywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBldmVyeSBkZXNjZW5kYW50IG5vZGUuIERvZXNuJ3RcbiAgICBkZXNjZW5kIGludG8gYSBub2RlIHdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYC5cbiAgICAqL1xuICAgIGRlc2NlbmRhbnRzKGYpIHtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oMCwgdGhpcy5jb250ZW50LnNpemUsIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb25jYXRlbmF0ZXMgYWxsIHRoZSB0ZXh0IG5vZGVzIGZvdW5kIGluIHRoaXMgZnJhZ21lbnQgYW5kIGl0c1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IHRleHRDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaXNMZWFmICYmIHRoaXMudHlwZS5zcGVjLmxlYWZUZXh0KVxuICAgICAgICAgICAgPyB0aGlzLnR5cGUuc3BlYy5sZWFmVGV4dCh0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLnRleHRCZXR3ZWVuKDAsIHRoaXMuY29udGVudC5zaXplLCBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGFsbCB0ZXh0IGJldHdlZW4gcG9zaXRpb25zIGBmcm9tYCBhbmQgYHRvYC4gV2hlblxuICAgIGBibG9ja1NlcGFyYXRvcmAgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgaW5zZXJ0ZWQgdG8gc2VwYXJhdGUgdGV4dFxuICAgIGZyb20gZGlmZmVyZW50IGJsb2NrIG5vZGVzLiBJZiBgbGVhZlRleHRgIGlzIGdpdmVuLCBpdCdsbCBiZVxuICAgIGluc2VydGVkIGZvciBldmVyeSBub24tdGV4dCBsZWFmIG5vZGUgZW5jb3VudGVyZWQsIG90aGVyd2lzZVxuICAgIFtgbGVhZlRleHRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWNebGVhZlRleHQpIHdpbGwgYmUgdXNlZC5cbiAgICAqL1xuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC50ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGlzIG5vZGUncyBmaXJzdCBjaGlsZCwgb3IgYG51bGxgIGlmIHRoZXJlIGFyZSBub1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZDsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhpcyBub2RlJ3MgbGFzdCBjaGlsZCwgb3IgYG51bGxgIGlmIHRoZXJlIGFyZSBub1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sYXN0Q2hpbGQ7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdHdvIG5vZGVzIHJlcHJlc2VudCB0aGUgc2FtZSBwaWVjZSBvZiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8ICh0aGlzLnNhbWVNYXJrdXAob3RoZXIpICYmIHRoaXMuY29udGVudC5lcShvdGhlci5jb250ZW50KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhlIG1hcmt1cCAodHlwZSwgYXR0cmlidXRlcywgYW5kIG1hcmtzKSBvZiB0aGlzIG5vZGUgdG9cbiAgICB0aG9zZSBvZiBhbm90aGVyLiBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGhhdmUgdGhlIHNhbWUgbWFya3VwLlxuICAgICovXG4gICAgc2FtZU1hcmt1cChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNNYXJrdXAob3RoZXIudHlwZSwgb3RoZXIuYXR0cnMsIG90aGVyLm1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIG5vZGUncyBtYXJrdXAgY29ycmVzcG9uZCB0byB0aGUgZ2l2ZW4gdHlwZSxcbiAgICBhdHRyaWJ1dGVzLCBhbmQgbWFya3MuXG4gICAgKi9cbiAgICBoYXNNYXJrdXAodHlwZSwgYXR0cnMsIG1hcmtzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gdHlwZSAmJlxuICAgICAgICAgICAgY29tcGFyZURlZXAodGhpcy5hdHRycywgYXR0cnMgfHwgdHlwZS5kZWZhdWx0QXR0cnMgfHwgZW1wdHlBdHRycykgJiZcbiAgICAgICAgICAgIE1hcmsuc2FtZVNldCh0aGlzLm1hcmtzLCBtYXJrcyB8fCBNYXJrLm5vbmUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgbm9kZSB3aXRoIHRoZSBzYW1lIG1hcmt1cCBhcyB0aGlzIG5vZGUsIGNvbnRhaW5pbmdcbiAgICB0aGUgZ2l2ZW4gY29udGVudCAob3IgZW1wdHksIGlmIG5vIGNvbnRlbnQgaXMgZ2l2ZW4pLlxuICAgICovXG4gICAgY29weShjb250ZW50ID0gbnVsbCkge1xuICAgICAgICBpZiAoY29udGVudCA9PSB0aGlzLmNvbnRlbnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgY29udGVudCwgdGhpcy5tYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlLCB3aXRoIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MgaW5zdGVhZFxuICAgIG9mIHRoZSBub2RlJ3Mgb3duIG1hcmtzLlxuICAgICovXG4gICAgbWFyayhtYXJrcykge1xuICAgICAgICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgTm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRoaXMuY29udGVudCwgbWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgbm9kZSB3aXRoIG9ubHkgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbnMuIElmIGB0b2AgaXMgbm90IGdpdmVuLCBpdCBkZWZhdWx0cyB0byB0aGUgZW5kIG9mXG4gICAgdGhlIG5vZGUuXG4gICAgKi9cbiAgICBjdXQoZnJvbSwgdG8gPSB0aGlzLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5jb250ZW50LmN1dChmcm9tLCB0bykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDdXQgb3V0IHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMsIGFuZFxuICAgIHJldHVybiBpdCBhcyBhIGBTbGljZWAgb2JqZWN0LlxuICAgICovXG4gICAgc2xpY2UoZnJvbSwgdG8gPSB0aGlzLmNvbnRlbnQuc2l6ZSwgaW5jbHVkZVBhcmVudHMgPSBmYWxzZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBTbGljZS5lbXB0eTtcbiAgICAgICAgbGV0ICRmcm9tID0gdGhpcy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0aGlzLnJlc29sdmUodG8pO1xuICAgICAgICBsZXQgZGVwdGggPSBpbmNsdWRlUGFyZW50cyA/IDAgOiAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gICAgICAgIGxldCBzdGFydCA9ICRmcm9tLnN0YXJ0KGRlcHRoKSwgbm9kZSA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICBsZXQgY29udGVudCA9IG5vZGUuY29udGVudC5jdXQoJGZyb20ucG9zIC0gc3RhcnQsICR0by5wb3MgLSBzdGFydCk7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoY29udGVudCwgJGZyb20uZGVwdGggLSBkZXB0aCwgJHRvLmRlcHRoIC0gZGVwdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMgd2l0aFxuICAgIHRoZSBnaXZlbiBzbGljZS4gVGhlIHNsaWNlIG11c3QgJ2ZpdCcsIG1lYW5pbmcgaXRzIG9wZW4gc2lkZXNcbiAgICBtdXN0IGJlIGFibGUgdG8gY29ubmVjdCB0byB0aGUgc3Vycm91bmRpbmcgY29udGVudCwgYW5kIGl0c1xuICAgIGNvbnRlbnQgbm9kZXMgbXVzdCBiZSB2YWxpZCBjaGlsZHJlbiBmb3IgdGhlIG5vZGUgdGhleSBhcmUgcGxhY2VkXG4gICAgaW50by4gSWYgYW55IG9mIHRoaXMgaXMgdmlvbGF0ZWQsIGFuIGVycm9yIG9mIHR5cGVcbiAgICBbYFJlcGxhY2VFcnJvcmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5SZXBsYWNlRXJyb3IpIGlzIHRocm93bi5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlKHRoaXMucmVzb2x2ZShmcm9tKSwgdGhpcy5yZXNvbHZlKHRvKSwgc2xpY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBub2RlIGRpcmVjdGx5IGFmdGVyIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHRoaXM7Oykge1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IHBvcyB8fCBub2RlLmlzVGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIHBvcyAtPSBvZmZzZXQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIChkaXJlY3QpIGNoaWxkIG5vZGUgYWZ0ZXIgdGhlIGdpdmVuIG9mZnNldCwgaWYgYW55LFxuICAgIGFuZCByZXR1cm4gaXQgYWxvbmcgd2l0aCBpdHMgaW5kZXggYW5kIG9mZnNldCByZWxhdGl2ZSB0byB0aGlzXG4gICAgbm9kZS5cbiAgICAqL1xuICAgIGNoaWxkQWZ0ZXIocG9zKSB7XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IHRoaXMuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpLCBpbmRleCwgb2Zmc2V0IH07XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIChkaXJlY3QpIGNoaWxkIG5vZGUgYmVmb3JlIHRoZSBnaXZlbiBvZmZzZXQsIGlmIGFueSxcbiAgICBhbmQgcmV0dXJuIGl0IGFsb25nIHdpdGggaXRzIGluZGV4IGFuZCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhpc1xuICAgIG5vZGUuXG4gICAgKi9cbiAgICBjaGlsZEJlZm9yZShwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogbnVsbCwgaW5kZXg6IDAsIG9mZnNldDogMCB9O1xuICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSB0aGlzLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgICAgIGlmIChvZmZzZXQgPCBwb3MpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXgpLCBpbmRleCwgb2Zmc2V0IH07XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgIHJldHVybiB7IG5vZGUsIGluZGV4OiBpbmRleCAtIDEsIG9mZnNldDogb2Zmc2V0IC0gbm9kZS5ub2RlU2l6ZSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXNvbHZlIHRoZSBnaXZlbiBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQsIHJldHVybmluZyBhblxuICAgIFtvYmplY3RdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5SZXNvbHZlZFBvcykgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCBpdHMgY29udGV4dC5cbiAgICAqL1xuICAgIHJlc29sdmUocG9zKSB7IHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlQ2FjaGVkKHRoaXMsIHBvcyk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVOb0NhY2hlKHBvcykgeyByZXR1cm4gUmVzb2x2ZWRQb3MucmVzb2x2ZSh0aGlzLCBwb3MpOyB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gbWFyayBvciBtYXJrIHR5cGUgb2NjdXJzIGluIHRoaXMgZG9jdW1lbnRcbiAgICBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgcmFuZ2VIYXNNYXJrKGZyb20sIHRvLCB0eXBlKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBpZiAodG8gPiBmcm9tKVxuICAgICAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWZvdW5kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSBibG9jayAobm9uLWlubGluZSBub2RlKVxuICAgICovXG4gICAgZ2V0IGlzQmxvY2soKSB7IHJldHVybiB0aGlzLnR5cGUuaXNCbG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgdGV4dGJsb2NrIG5vZGUsIGEgYmxvY2sgbm9kZSB3aXRoIGlubGluZVxuICAgIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0YmxvY2soKSB7IHJldHVybiB0aGlzLnR5cGUuaXNUZXh0YmxvY2s7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBub2RlIGFsbG93cyBpbmxpbmUgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpbmxpbmVDb250ZW50KCkgeyByZXR1cm4gdGhpcy50eXBlLmlubGluZUNvbnRlbnQ7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhbiBpbmxpbmUgbm9kZSAoYSB0ZXh0IG5vZGUgb3IgYSBub2RlIHRoYXQgY2FuXG4gICAgYXBwZWFyIGFtb25nIHRleHQpLlxuICAgICovXG4gICAgZ2V0IGlzSW5saW5lKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzSW5saW5lOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSB0ZXh0IG5vZGUuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0KCkgeyByZXR1cm4gdGhpcy50eXBlLmlzVGV4dDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgbGVhZiBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzTGVhZigpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0xlYWY7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhbiBhdG9tLCBpLmUuIHdoZW4gaXQgZG9lcyBub3QgaGF2ZSBkaXJlY3RseVxuICAgIGVkaXRhYmxlIGNvbnRlbnQuIFRoaXMgaXMgdXN1YWxseSB0aGUgc2FtZSBhcyBgaXNMZWFmYCwgYnV0IGNhblxuICAgIGJlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgW2BhdG9tYCBwcm9wZXJ0eV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmF0b20pXG4gICAgb24gYSBub2RlJ3Mgc3BlYyAodHlwaWNhbGx5IHVzZWQgd2hlbiB0aGUgbm9kZSBpcyBkaXNwbGF5ZWQgYXNcbiAgICBhbiB1bmVkaXRhYmxlIFtub2RlIHZpZXddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3Lk5vZGVWaWV3KSkuXG4gICAgKi9cbiAgICBnZXQgaXNBdG9tKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzQXRvbTsgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUgZm9yIGRlYnVnZ2luZ1xuICAgIHB1cnBvc2VzLlxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcyk7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy50eXBlLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIG5hbWUgKz0gXCIoXCIgKyB0aGlzLmNvbnRlbnQudG9TdHJpbmdJbm5lcigpICsgXCIpXCI7XG4gICAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgbmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGVudCBtYXRjaCBpbiB0aGlzIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICovXG4gICAgY29udGVudE1hdGNoQXQoaW5kZXgpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgMCwgaW5kZXgpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIGNvbnRlbnRNYXRjaEF0IG9uIGEgbm9kZSB3aXRoIGludmFsaWQgY29udGVudFwiKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgcmVwbGFjaW5nIHRoZSByYW5nZSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYCAoYnlcbiAgICBjaGlsZCBpbmRleCkgd2l0aCB0aGUgZ2l2ZW4gcmVwbGFjZW1lbnQgZnJhZ21lbnQgKHdoaWNoIGRlZmF1bHRzXG4gICAgdG8gdGhlIGVtcHR5IGZyYWdtZW50KSB3b3VsZCBsZWF2ZSB0aGUgbm9kZSdzIGNvbnRlbnQgdmFsaWQuIFlvdVxuICAgIGNhbiBvcHRpb25hbGx5IHBhc3MgYHN0YXJ0YCBhbmQgYGVuZGAgaW5kaWNlcyBpbnRvIHRoZVxuICAgIHJlcGxhY2VtZW50IGZyYWdtZW50LlxuICAgICovXG4gICAgY2FuUmVwbGFjZShmcm9tLCB0bywgcmVwbGFjZW1lbnQgPSBGcmFnbWVudC5lbXB0eSwgc3RhcnQgPSAwLCBlbmQgPSByZXBsYWNlbWVudC5jaGlsZENvdW50KSB7XG4gICAgICAgIGxldCBvbmUgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoRnJhZ21lbnQocmVwbGFjZW1lbnQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICBsZXQgdHdvID0gb25lICYmIG9uZS5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgICBpZiAoIXR3byB8fCAhdHdvLnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy50eXBlLmFsbG93c01hcmtzKHJlcGxhY2VtZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgcmVwbGFjaW5nIHRoZSByYW5nZSBgZnJvbWAgdG8gYHRvYCAoYnkgaW5kZXgpIHdpdGhcbiAgICBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgd291bGQgbGVhdmUgdGhlIG5vZGUncyBjb250ZW50IHZhbGlkLlxuICAgICovXG4gICAgY2FuUmVwbGFjZVdpdGgoZnJvbSwgdG8sIHR5cGUsIG1hcmtzKSB7XG4gICAgICAgIGlmIChtYXJrcyAmJiAhdGhpcy50eXBlLmFsbG93c01hcmtzKG1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jb250ZW50TWF0Y2hBdChmcm9tKS5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIGxldCBlbmQgPSBzdGFydCAmJiBzdGFydC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgICByZXR1cm4gZW5kID8gZW5kLnZhbGlkRW5kIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gbm9kZSdzIGNvbnRlbnQgY291bGQgYmUgYXBwZW5kZWQgdG8gdGhpc1xuICAgIG5vZGUuIElmIHRoYXQgbm9kZSBpcyBlbXB0eSwgdGhpcyB3aWxsIG9ubHkgcmV0dXJuIHRydWUgaWYgdGhlcmVcbiAgICBpcyBhdCBsZWFzdCBvbmUgbm9kZSB0eXBlIHRoYXQgY2FuIGFwcGVhciBpbiBib3RoIG5vZGVzICh0byBhdm9pZFxuICAgIG1lcmdpbmcgY29tcGxldGVseSBpbmNvbXBhdGlibGUgbm9kZXMpLlxuICAgICovXG4gICAgY2FuQXBwZW5kKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYW5SZXBsYWNlKHRoaXMuY2hpbGRDb3VudCwgdGhpcy5jaGlsZENvdW50LCBvdGhlci5jb250ZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5jb21wYXRpYmxlQ29udGVudChvdGhlci50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cyBjb25mb3JtIHRvIHRoZVxuICAgIHNjaGVtYSwgYW5kIHJhaXNlIGVycm9yIHdoZW4gdGhleSBkbyBub3QuXG4gICAgKi9cbiAgICBjaGVjaygpIHtcbiAgICAgICAgdGhpcy50eXBlLmNoZWNrQ29udGVudCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICBsZXQgY29weSA9IE1hcmsubm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgY29weSA9IHRoaXMubWFya3NbaV0uYWRkVG9TZXQoY29weSk7XG4gICAgICAgIGlmICghTWFyay5zYW1lU2V0KGNvcHksIHRoaXMubWFya3MpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY29sbGVjdGlvbiBvZiBtYXJrcyBmb3Igbm9kZSAke3RoaXMudHlwZS5uYW1lfTogJHt0aGlzLm1hcmtzLm1hcChtID0+IG0udHlwZS5uYW1lKX1gKTtcbiAgICAgICAgdGhpcy5jb250ZW50LmZvckVhY2gobm9kZSA9PiBub2RlLmNoZWNrKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBub2RlLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgb2JqID0geyB0eXBlOiB0aGlzLnR5cGUubmFtZSB9O1xuICAgICAgICBmb3IgKGxldCBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgIG9iai5hdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICBvYmouY29udGVudCA9IHRoaXMuY29udGVudC50b0pTT04oKTtcbiAgICAgICAgaWYgKHRoaXMubWFya3MubGVuZ3RoKVxuICAgICAgICAgICAgb2JqLm1hcmtzID0gdGhpcy5tYXJrcy5tYXAobiA9PiBuLnRvSlNPTigpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBub2RlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTm9kZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgbGV0IG1hcmtzID0gbnVsbDtcbiAgICAgICAgaWYgKGpzb24ubWFya3MpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uLm1hcmtzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbWFyayBkYXRhIGZvciBOb2RlLmZyb21KU09OXCIpO1xuICAgICAgICAgICAgbWFya3MgPSBqc29uLm1hcmtzLm1hcChzY2hlbWEubWFya0Zyb21KU09OKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi50eXBlID09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24udGV4dCAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0ZXh0IG5vZGUgaW4gSlNPTlwiKTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEudGV4dChqc29uLnRleHQsIG1hcmtzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmZyb21KU09OKHNjaGVtYSwganNvbi5jb250ZW50KTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5ub2RlVHlwZShqc29uLnR5cGUpLmNyZWF0ZShqc29uLmF0dHJzLCBjb250ZW50LCBtYXJrcyk7XG4gICAgfVxufVxuTm9kZS5wcm90b3R5cGUudGV4dCA9IHVuZGVmaW5lZDtcbmNsYXNzIFRleHROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBhdHRycywgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgYXR0cnMsIG51bGwsIG1hcmtzKTtcbiAgICAgICAgaWYgKCFjb250ZW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFbXB0eSB0ZXh0IG5vZGVzIGFyZSBub3QgYWxsb3dlZFwiKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gY29udGVudDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcyk7XG4gICAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgSlNPTi5zdHJpbmdpZnkodGhpcy50ZXh0KSk7XG4gICAgfVxuICAgIGdldCB0ZXh0Q29udGVudCgpIHsgcmV0dXJuIHRoaXMudGV4dDsgfVxuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvKSB7IHJldHVybiB0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pOyB9XG4gICAgZ2V0IG5vZGVTaXplKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIG1hcmsobWFya3MpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtzID09IHRoaXMubWFya3MgPyB0aGlzIDogbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy50ZXh0LCBtYXJrcyk7XG4gICAgfVxuICAgIHdpdGhUZXh0KHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQgPT0gdGhpcy50ZXh0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0ZXh0LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gICAgY3V0KGZyb20gPSAwLCB0byA9IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhUZXh0KHRoaXMudGV4dC5zbGljZShmcm9tLCB0bykpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zYW1lTWFya3VwKG90aGVyKSAmJiB0aGlzLnRleHQgPT0gb3RoZXIudGV4dDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgYmFzZSA9IHN1cGVyLnRvSlNPTigpO1xuICAgICAgICBiYXNlLnRleHQgPSB0aGlzLnRleHQ7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyYXBNYXJrcyhtYXJrcywgc3RyKSB7XG4gICAgZm9yIChsZXQgaSA9IG1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBzdHIgPSBtYXJrc1tpXS50eXBlLm5hbWUgKyBcIihcIiArIHN0ciArIFwiKVwiO1xuICAgIHJldHVybiBzdHI7XG59XG5cbi8qKlxuSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50IGEgbWF0Y2ggc3RhdGUgb2YgYSBub2RlIHR5cGUnc1xuW2NvbnRlbnQgZXhwcmVzc2lvbl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvbnRlbnQpLCBhbmQgY2FuIGJlIHVzZWQgdG9cbmZpbmQgb3V0IHdoZXRoZXIgZnVydGhlciBjb250ZW50IG1hdGNoZXMgaGVyZSwgYW5kIHdoZXRoZXIgYSBnaXZlblxucG9zaXRpb24gaXMgYSB2YWxpZCBlbmQgb2YgdGhlIG5vZGUuXG4qL1xuY2xhc3MgQ29udGVudE1hdGNoIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG1hdGNoIHN0YXRlIHJlcHJlc2VudHMgYSB2YWxpZCBlbmQgb2YgdGhlIG5vZGUuXG4gICAgKi9cbiAgICB2YWxpZEVuZCkge1xuICAgICAgICB0aGlzLnZhbGlkRW5kID0gdmFsaWRFbmQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cmFwQ2FjaGUgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcGFyc2Uoc3RyaW5nLCBub2RlVHlwZXMpIHtcbiAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBUb2tlblN0cmVhbShzdHJpbmcsIG5vZGVUeXBlcyk7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIENvbnRlbnRNYXRjaC5lbXB0eTtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyZWFtKTtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0KVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIlVuZXhwZWN0ZWQgdHJhaWxpbmcgdGV4dFwiKTtcbiAgICAgICAgbGV0IG1hdGNoID0gZGZhKG5mYShleHByKSk7XG4gICAgICAgIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSk7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggYSBub2RlIHR5cGUsIHJldHVybmluZyBhIG1hdGNoIGFmdGVyIHRoYXQgbm9kZSBpZlxuICAgIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBtYXRjaFR5cGUodHlwZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRbaV0udHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRbaV0ubmV4dDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtYXRjaCBhIGZyYWdtZW50LiBSZXR1cm5zIHRoZSByZXN1bHRpbmcgbWF0Y2ggd2hlblxuICAgIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBtYXRjaEZyYWdtZW50KGZyYWcsIHN0YXJ0ID0gMCwgZW5kID0gZnJhZy5jaGlsZENvdW50KSB7XG4gICAgICAgIGxldCBjdXIgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGN1ciAmJiBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICBjdXIgPSBjdXIubWF0Y2hUeXBlKGZyYWcuY2hpbGQoaSkudHlwZSk7XG4gICAgICAgIHJldHVybiBjdXI7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlubGluZUNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQubGVuZ3RoICE9IDAgJiYgdGhpcy5uZXh0WzBdLnR5cGUuaXNJbmxpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZmlyc3QgbWF0Y2hpbmcgbm9kZSB0eXBlIGF0IHRoaXMgbWF0Y2ggcG9zaXRpb24gdGhhdCBjYW5cbiAgICBiZSBnZW5lcmF0ZWQuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdFR5cGUoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyB0eXBlIH0gPSB0aGlzLm5leHRbaV07XG4gICAgICAgICAgICBpZiAoISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGF0aWJsZShvdGhlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3RoZXIubmV4dC5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gb3RoZXIubmV4dFtqXS50eXBlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gbWF0Y2ggdGhlIGdpdmVuIGZyYWdtZW50LCBhbmQgaWYgdGhhdCBmYWlscywgc2VlIGlmIGl0IGNhblxuICAgIGJlIG1hZGUgdG8gbWF0Y2ggYnkgaW5zZXJ0aW5nIG5vZGVzIGluIGZyb250IG9mIGl0LiBXaGVuXG4gICAgc3VjY2Vzc2Z1bCwgcmV0dXJuIGEgZnJhZ21lbnQgb2YgaW5zZXJ0ZWQgbm9kZXMgKHdoaWNoIG1heSBiZVxuICAgIGVtcHR5IGlmIG5vdGhpbmcgaGFkIHRvIGJlIGluc2VydGVkKS4gV2hlbiBgdG9FbmRgIGlzIHRydWUsIG9ubHlcbiAgICByZXR1cm4gYSBmcmFnbWVudCBpZiB0aGUgcmVzdWx0aW5nIG1hdGNoIGdvZXMgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICBjb250ZW50IGV4cHJlc3Npb24uXG4gICAgKi9cbiAgICBmaWxsQmVmb3JlKGFmdGVyLCB0b0VuZCA9IGZhbHNlLCBzdGFydEluZGV4ID0gMCkge1xuICAgICAgICBsZXQgc2VlbiA9IFt0aGlzXTtcbiAgICAgICAgZnVuY3Rpb24gc2VhcmNoKG1hdGNoLCB0eXBlcykge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gbWF0Y2gubWF0Y2hGcmFnbWVudChhZnRlciwgc3RhcnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQgJiYgKCF0b0VuZCB8fCBmaW5pc2hlZC52YWxpZEVuZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20odHlwZXMubWFwKHRwID0+IHRwLmNyZWF0ZUFuZEZpbGwoKSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2gubmV4dFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkgJiYgc2Vlbi5pbmRleE9mKG5leHQpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW4ucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gc2VhcmNoKG5leHQsIHR5cGVzLmNvbmNhdCh0eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VhcmNoKHRoaXMsIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhIHNldCBvZiB3cmFwcGluZyBub2RlIHR5cGVzIHRoYXQgd291bGQgYWxsb3cgYSBub2RlIG9mIHRoZVxuICAgIGdpdmVuIHR5cGUgdG8gYXBwZWFyIGF0IHRoaXMgcG9zaXRpb24uIFRoZSByZXN1bHQgbWF5IGJlIGVtcHR5XG4gICAgKHdoZW4gaXQgZml0cyBkaXJlY3RseSkgYW5kIHdpbGwgYmUgbnVsbCB3aGVuIG5vIHN1Y2ggd3JhcHBpbmdcbiAgICBleGlzdHMuXG4gICAgKi9cbiAgICBmaW5kV3JhcHBpbmcodGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53cmFwQ2FjaGUubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICBpZiAodGhpcy53cmFwQ2FjaGVbaV0gPT0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBDYWNoZVtpICsgMV07XG4gICAgICAgIGxldCBjb21wdXRlZCA9IHRoaXMuY29tcHV0ZVdyYXBwaW5nKHRhcmdldCk7XG4gICAgICAgIHRoaXMud3JhcENhY2hlLnB1c2godGFyZ2V0LCBjb21wdXRlZCk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wdXRlV3JhcHBpbmcodGFyZ2V0KSB7XG4gICAgICAgIGxldCBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgYWN0aXZlID0gW3sgbWF0Y2g6IHRoaXMsIHR5cGU6IG51bGwsIHZpYTogbnVsbCB9XTtcbiAgICAgICAgd2hpbGUgKGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gYWN0aXZlLnNoaWZ0KCksIG1hdGNoID0gY3VycmVudC5tYXRjaDtcbiAgICAgICAgICAgIGlmIChtYXRjaC5tYXRjaFR5cGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvYmogPSBjdXJyZW50OyBvYmoudHlwZTsgb2JqID0gb2JqLnZpYSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqLnR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2gubmV4dFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuaXNMZWFmICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSAmJiAhKHR5cGUubmFtZSBpbiBzZWVuKSAmJiAoIWN1cnJlbnQudHlwZSB8fCBuZXh0LnZhbGlkRW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmUucHVzaCh7IG1hdGNoOiB0eXBlLmNvbnRlbnRNYXRjaCwgdHlwZSwgdmlhOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWVuW3R5cGUubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBvdXRnb2luZyBlZGdlcyB0aGlzIG5vZGUgaGFzIGluIHRoZSBmaW5pdGVcbiAgICBhdXRvbWF0b24gdGhhdCBkZXNjcmliZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbi5cbiAgICAqL1xuICAgIGdldCBlZGdlQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIF9uX1x1MjAwQnRoIG91dGdvaW5nIGVkZ2UgZnJvbSB0aGlzIG5vZGUgaW4gdGhlIGZpbml0ZVxuICAgIGF1dG9tYXRvbiB0aGF0IGRlc2NyaWJlcyB0aGUgY29udGVudCBleHByZXNzaW9uLlxuICAgICovXG4gICAgZWRnZShuKSB7XG4gICAgICAgIGlmIChuID49IHRoaXMubmV4dC5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlcmUncyBubyAke259dGggZWRnZSBpbiB0aGlzIGNvbnRlbnQgbWF0Y2hgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFtuXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHNlZW4gPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gc2NhbihtKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2gobSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG0ubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG0ubmV4dFtpXS5uZXh0KSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2NhbihtLm5leHRbaV0ubmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Nhbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNlZW4ubWFwKChtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgb3V0ID0gaSArIChtLnZhbGlkRW5kID8gXCIqXCIgOiBcIiBcIikgKyBcIiBcIjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIG91dCArPSAoaSA/IFwiLCBcIiA6IFwiXCIpICsgbS5uZXh0W2ldLnR5cGUubmFtZSArIFwiLT5cIiArIHNlZW4uaW5kZXhPZihtLm5leHRbaV0ubmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbn1cbi8qKlxuQGludGVybmFsXG4qL1xuQ29udGVudE1hdGNoLmVtcHR5ID0gbmV3IENvbnRlbnRNYXRjaCh0cnVlKTtcbmNsYXNzIFRva2VuU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgICAgdGhpcy5ub2RlVHlwZXMgPSBub2RlVHlwZXM7XG4gICAgICAgIHRoaXMuaW5saW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnRva2VucyA9IHN0cmluZy5zcGxpdCgvXFxzKig/PVxcYnxcXFd8JCkvKTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdID09IFwiXCIpXG4gICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zWzBdID09IFwiXCIpXG4gICAgICAgICAgICB0aGlzLnRva2Vucy5zaGlmdCgpO1xuICAgIH1cbiAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucG9zXTsgfVxuICAgIGVhdCh0b2spIHsgcmV0dXJuIHRoaXMubmV4dCA9PSB0b2sgJiYgKHRoaXMucG9zKysgfHwgdHJ1ZSk7IH1cbiAgICBlcnIoc3RyKSB7IHRocm93IG5ldyBTeW50YXhFcnJvcihzdHIgKyBcIiAoaW4gY29udGVudCBleHByZXNzaW9uICdcIiArIHRoaXMuc3RyaW5nICsgXCInKVwiKTsgfVxufVxuZnVuY3Rpb24gcGFyc2VFeHByKHN0cmVhbSkge1xuICAgIGxldCBleHBycyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgZXhwcnMucHVzaChwYXJzZUV4cHJTZXEoc3RyZWFtKSk7XG4gICAgfSB3aGlsZSAoc3RyZWFtLmVhdChcInxcIikpO1xuICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcImNob2ljZVwiLCBleHBycyB9O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByU2VxKHN0cmVhbSkge1xuICAgIGxldCBleHBycyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgZXhwcnMucHVzaChwYXJzZUV4cHJTdWJzY3JpcHQoc3RyZWFtKSk7XG4gICAgfSB3aGlsZSAoc3RyZWFtLm5leHQgJiYgc3RyZWFtLm5leHQgIT0gXCIpXCIgJiYgc3RyZWFtLm5leHQgIT0gXCJ8XCIpO1xuICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcInNlcVwiLCBleHBycyB9O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByU3Vic2NyaXB0KHN0cmVhbSkge1xuICAgIGxldCBleHByID0gcGFyc2VFeHByQXRvbShzdHJlYW0pO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIrXCIpKVxuICAgICAgICAgICAgZXhwciA9IHsgdHlwZTogXCJwbHVzXCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIipcIikpXG4gICAgICAgICAgICBleHByID0geyB0eXBlOiBcInN0YXJcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwiP1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSB7IHR5cGU6IFwib3B0XCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIntcIikpXG4gICAgICAgICAgICBleHByID0gcGFyc2VFeHByUmFuZ2Uoc3RyZWFtLCBleHByKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xufVxuZnVuY3Rpb24gcGFyc2VOdW0oc3RyZWFtKSB7XG4gICAgaWYgKC9cXEQvLnRlc3Qoc3RyZWFtLm5leHQpKVxuICAgICAgICBzdHJlYW0uZXJyKFwiRXhwZWN0ZWQgbnVtYmVyLCBnb3QgJ1wiICsgc3RyZWFtLm5leHQgKyBcIidcIik7XG4gICAgbGV0IHJlc3VsdCA9IE51bWJlcihzdHJlYW0ubmV4dCk7XG4gICAgc3RyZWFtLnBvcysrO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpIHtcbiAgICBsZXQgbWluID0gcGFyc2VOdW0oc3RyZWFtKSwgbWF4ID0gbWluO1xuICAgIGlmIChzdHJlYW0uZWF0KFwiLFwiKSkge1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQgIT0gXCJ9XCIpXG4gICAgICAgICAgICBtYXggPSBwYXJzZU51bShzdHJlYW0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXggPSAtMTtcbiAgICB9XG4gICAgaWYgKCFzdHJlYW0uZWF0KFwifVwiKSlcbiAgICAgICAgc3RyZWFtLmVycihcIlVuY2xvc2VkIGJyYWNlZCByYW5nZVwiKTtcbiAgICByZXR1cm4geyB0eXBlOiBcInJhbmdlXCIsIG1pbiwgbWF4LCBleHByIH07XG59XG5mdW5jdGlvbiByZXNvbHZlTmFtZShzdHJlYW0sIG5hbWUpIHtcbiAgICBsZXQgdHlwZXMgPSBzdHJlYW0ubm9kZVR5cGVzLCB0eXBlID0gdHlwZXNbbmFtZV07XG4gICAgaWYgKHR5cGUpXG4gICAgICAgIHJldHVybiBbdHlwZV07XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHR5cGVOYW1lIGluIHR5cGVzKSB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbdHlwZU5hbWVdO1xuICAgICAgICBpZiAodHlwZS5ncm91cHMuaW5kZXhPZihuYW1lKSA+IC0xKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godHlwZSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQubGVuZ3RoID09IDApXG4gICAgICAgIHN0cmVhbS5lcnIoXCJObyBub2RlIHR5cGUgb3IgZ3JvdXAgJ1wiICsgbmFtZSArIFwiJyBmb3VuZFwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByQXRvbShzdHJlYW0pIHtcbiAgICBpZiAoc3RyZWFtLmVhdChcIihcIikpIHtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyZWFtKTtcbiAgICAgICAgaWYgKCFzdHJlYW0uZWF0KFwiKVwiKSlcbiAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJNaXNzaW5nIGNsb3NpbmcgcGFyZW5cIik7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICBlbHNlIGlmICghL1xcVy8udGVzdChzdHJlYW0ubmV4dCkpIHtcbiAgICAgICAgbGV0IGV4cHJzID0gcmVzb2x2ZU5hbWUoc3RyZWFtLCBzdHJlYW0ubmV4dCkubWFwKHR5cGUgPT4ge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5pbmxpbmUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBzdHJlYW0uaW5saW5lID0gdHlwZS5pc0lubGluZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5pbmxpbmUgIT0gdHlwZS5pc0lubGluZSlcbiAgICAgICAgICAgICAgICBzdHJlYW0uZXJyKFwiTWl4aW5nIGlubGluZSBhbmQgYmxvY2sgY29udGVudFwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibmFtZVwiLCB2YWx1ZTogdHlwZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLnBvcysrO1xuICAgICAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHsgdHlwZTogXCJjaG9pY2VcIiwgZXhwcnMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRva2VuICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpO1xuICAgIH1cbn1cbi8qKlxuQ29uc3RydWN0IGFuIE5GQSBmcm9tIGFuIGV4cHJlc3Npb24gYXMgcmV0dXJuZWQgYnkgdGhlIHBhcnNlci4gVGhlXG5ORkEgaXMgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2Ygc3RhdGVzLCB3aGljaCBhcmUgdGhlbXNlbHZlc1xuYXJyYXlzIG9mIGVkZ2VzLCB3aGljaCBhcmUgYHt0ZXJtLCB0b31gIG9iamVjdHMuIFRoZSBmaXJzdCBzdGF0ZSBpc1xudGhlIGVudHJ5IHN0YXRlIGFuZCB0aGUgbGFzdCBub2RlIGlzIHRoZSBzdWNjZXNzIHN0YXRlLlxuXG5Ob3RlIHRoYXQgdW5saWtlIHR5cGljYWwgTkZBcywgdGhlIGVkZ2Ugb3JkZXJpbmcgaW4gdGhpcyBvbmUgaXNcbnNpZ25pZmljYW50LCBpbiB0aGF0IGl0IGlzIHVzZWQgdG8gY29udHJ1Y3QgZmlsbGVyIGNvbnRlbnQgd2hlblxubmVjZXNzYXJ5LlxuKi9cbmZ1bmN0aW9uIG5mYShleHByKSB7XG4gICAgbGV0IG5mYSA9IFtbXV07XG4gICAgY29ubmVjdChjb21waWxlKGV4cHIsIDApLCBub2RlKCkpO1xuICAgIHJldHVybiBuZmE7XG4gICAgZnVuY3Rpb24gbm9kZSgpIHsgcmV0dXJuIG5mYS5wdXNoKFtdKSAtIDE7IH1cbiAgICBmdW5jdGlvbiBlZGdlKGZyb20sIHRvLCB0ZXJtKSB7XG4gICAgICAgIGxldCBlZGdlID0geyB0ZXJtLCB0byB9O1xuICAgICAgICBuZmFbZnJvbV0ucHVzaChlZGdlKTtcbiAgICAgICAgcmV0dXJuIGVkZ2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbm5lY3QoZWRnZXMsIHRvKSB7XG4gICAgICAgIGVkZ2VzLmZvckVhY2goZWRnZSA9PiBlZGdlLnRvID0gdG8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21waWxlKGV4cHIsIGZyb20pIHtcbiAgICAgICAgaWYgKGV4cHIudHlwZSA9PSBcImNob2ljZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwci5leHBycy5yZWR1Y2UoKG91dCwgZXhwcikgPT4gb3V0LmNvbmNhdChjb21waWxlKGV4cHIsIGZyb20pKSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInNlcVwiKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY29tcGlsZShleHByLmV4cHJzW2ldLCBmcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBleHByLmV4cHJzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgIGNvbm5lY3QobmV4dCwgZnJvbSA9IG5vZGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwic3RhclwiKSB7XG4gICAgICAgICAgICBsZXQgbG9vcCA9IG5vZGUoKTtcbiAgICAgICAgICAgIGVkZ2UoZnJvbSwgbG9vcCk7XG4gICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBsb29wKSwgbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UobG9vcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInBsdXNcIikge1xuICAgICAgICAgICAgbGV0IGxvb3AgPSBub2RlKCk7XG4gICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBmcm9tKSwgbG9vcCk7XG4gICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBsb29wKSwgbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UobG9vcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm9wdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UoZnJvbSldLmNvbmNhdChjb21waWxlKGV4cHIuZXhwciwgZnJvbSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBmcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByLm1pbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlKCk7XG4gICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHByLm1heCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZXhwci5taW47IGkgPCBleHByLm1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBlZGdlKGN1ciwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbZWRnZShjdXIpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShmcm9tLCB1bmRlZmluZWQsIGV4cHIudmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZXhwciB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY21wKGEsIGIpIHsgcmV0dXJuIGIgLSBhOyB9XG4vLyBHZXQgdGhlIHNldCBvZiBub2RlcyByZWFjaGFibGUgYnkgbnVsbCBlZGdlcyBmcm9tIGBub2RlYC4gT21pdFxuLy8gbm9kZXMgd2l0aCBvbmx5IGEgc2luZ2xlIG51bGwtb3V0LWVkZ2UsIHNpbmNlIHRoZXkgbWF5IGxlYWQgdG9cbi8vIG5lZWRsZXNzIGR1cGxpY2F0ZWQgbm9kZXMuXG5mdW5jdGlvbiBudWxsRnJvbShuZmEsIG5vZGUpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgc2Nhbihub2RlKTtcbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKTtcbiAgICBmdW5jdGlvbiBzY2FuKG5vZGUpIHtcbiAgICAgICAgbGV0IGVkZ2VzID0gbmZhW25vZGVdO1xuICAgICAgICBpZiAoZWRnZXMubGVuZ3RoID09IDEgJiYgIWVkZ2VzWzBdLnRlcm0pXG4gICAgICAgICAgICByZXR1cm4gc2NhbihlZGdlc1swXS50byk7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyB0ZXJtLCB0byB9ID0gZWRnZXNbaV07XG4gICAgICAgICAgICBpZiAoIXRlcm0gJiYgcmVzdWx0LmluZGV4T2YodG8pID09IC0xKVxuICAgICAgICAgICAgICAgIHNjYW4odG8pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gQ29tcGlsZXMgYW4gTkZBIGFzIHByb2R1Y2VkIGJ5IGBuZmFgIGludG8gYSBERkEsIG1vZGVsZWQgYXMgYSBzZXRcbi8vIG9mIHN0YXRlIG9iamVjdHMgKGBDb250ZW50TWF0Y2hgIGluc3RhbmNlcykgd2l0aCB0cmFuc2l0aW9uc1xuLy8gYmV0d2VlbiB0aGVtLlxuZnVuY3Rpb24gZGZhKG5mYSkge1xuICAgIGxldCBsYWJlbGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gZXhwbG9yZShudWxsRnJvbShuZmEsIDApKTtcbiAgICBmdW5jdGlvbiBleHBsb3JlKHN0YXRlcykge1xuICAgICAgICBsZXQgb3V0ID0gW107XG4gICAgICAgIHN0YXRlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgbmZhW25vZGVdLmZvckVhY2goKHsgdGVybSwgdG8gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGVybSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCBzZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRbaV1bMF0gPT0gdGVybSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldCA9IG91dFtpXVsxXTtcbiAgICAgICAgICAgICAgICBudWxsRnJvbShuZmEsIHRvKS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldClcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKFt0ZXJtLCBzZXQgPSBbXV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0LmluZGV4T2Yobm9kZSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHN0YXRlID0gbGFiZWxlZFtzdGF0ZXMuam9pbihcIixcIildID0gbmV3IENvbnRlbnRNYXRjaChzdGF0ZXMuaW5kZXhPZihuZmEubGVuZ3RoIC0gMSkgPiAtMSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhdGVzID0gb3V0W2ldWzFdLnNvcnQoY21wKTtcbiAgICAgICAgICAgIHN0YXRlLm5leHQucHVzaCh7IHR5cGU6IG91dFtpXVswXSwgbmV4dDogbGFiZWxlZFtzdGF0ZXMuam9pbihcIixcIildIHx8IGV4cGxvcmUoc3RhdGVzKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tGb3JEZWFkRW5kcyhtYXRjaCwgc3RyZWFtKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIHdvcmsgPSBbbWF0Y2hdOyBpIDwgd29yay5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc3RhdGUgPSB3b3JrW2ldLCBkZWFkID0gIXN0YXRlLnZhbGlkRW5kLCBub2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0YXRlLm5leHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IHN0YXRlLm5leHRbal07XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHR5cGUubmFtZSk7XG4gICAgICAgICAgICBpZiAoZGVhZCAmJiAhKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSlcbiAgICAgICAgICAgICAgICBkZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAod29yay5pbmRleE9mKG5leHQpID09IC0xKVxuICAgICAgICAgICAgICAgIHdvcmsucHVzaChuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVhZClcbiAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJPbmx5IG5vbi1nZW5lcmF0YWJsZSBub2RlcyAoXCIgKyBub2Rlcy5qb2luKFwiLCBcIikgKyBcIikgaW4gYSByZXF1aXJlZCBwb3NpdGlvbiAoc2VlIGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvZ3VpZGUvI2dlbmVyYXRhYmxlKVwiKTtcbiAgICB9XG59XG5cbi8vIEZvciBub2RlIHR5cGVzIHdoZXJlIGFsbCBhdHRycyBoYXZlIGEgZGVmYXVsdCB2YWx1ZSAob3Igd2hpY2ggZG9uJ3Rcbi8vIGhhdmUgYW55IGF0dHJpYnV0ZXMpLCBidWlsZCB1cCBhIHNpbmdsZSByZXVzYWJsZSBkZWZhdWx0IGF0dHJpYnV0ZVxuLy8gb2JqZWN0LCBhbmQgdXNlIGl0IGZvciBhbGwgbm9kZXMgdGhhdCBkb24ndCBzcGVjaWZ5IHNwZWNpZmljXG4vLyBhdHRyaWJ1dGVzLlxuZnVuY3Rpb24gZGVmYXVsdEF0dHJzKGF0dHJzKSB7XG4gICAgbGV0IGRlZmF1bHRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBhdHRyTmFtZSBpbiBhdHRycykge1xuICAgICAgICBsZXQgYXR0ciA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgaWYgKCFhdHRyLmhhc0RlZmF1bHQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZGVmYXVsdHNbYXR0ck5hbWVdID0gYXR0ci5kZWZhdWx0O1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdHM7XG59XG5mdW5jdGlvbiBjb21wdXRlQXR0cnMoYXR0cnMsIHZhbHVlKSB7XG4gICAgbGV0IGJ1aWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKSB7XG4gICAgICAgIGxldCBnaXZlbiA9IHZhbHVlICYmIHZhbHVlW25hbWVdO1xuICAgICAgICBpZiAoZ2l2ZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGF0dHIgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChhdHRyLmhhc0RlZmF1bHQpXG4gICAgICAgICAgICAgICAgZ2l2ZW4gPSBhdHRyLmRlZmF1bHQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyB2YWx1ZSBzdXBwbGllZCBmb3IgYXR0cmlidXRlIFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbHRbbmFtZV0gPSBnaXZlbjtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWx0O1xufVxuZnVuY3Rpb24gaW5pdEF0dHJzKGF0dHJzKSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGF0dHJzKVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gbmV3IEF0dHJpYnV0ZShhdHRyc1tuYW1lXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuTm9kZSB0eXBlcyBhcmUgb2JqZWN0cyBhbGxvY2F0ZWQgb25jZSBwZXIgYFNjaGVtYWAgYW5kIHVzZWQgdG9cblt0YWddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnR5cGUpIGBOb2RlYCBpbnN0YW5jZXMuIFRoZXkgY29udGFpbiBpbmZvcm1hdGlvblxuYWJvdXQgdGhlIG5vZGUgdHlwZSwgc3VjaCBhcyBpdHMgbmFtZSBhbmQgd2hhdCBraW5kIG9mIG5vZGUgaXRcbnJlcHJlc2VudHMuXG4qL1xuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgdGhlIG5vZGUgdHlwZSBoYXMgaW4gdGhpcyBzY2hlbWEuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBBIGxpbmsgYmFjayB0byB0aGUgYFNjaGVtYWAgdGhlIG5vZGUgdHlwZSBiZWxvbmdzIHRvLlxuICAgICovXG4gICAgc2NoZW1hLCBcbiAgICAvKipcbiAgICBUaGUgc3BlYyB0aGF0IHRoaXMgdHlwZSBpcyBiYXNlZCBvblxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBzZXQgb2YgbWFya3MgYWxsb3dlZCBpbiB0aGlzIG5vZGUuIGBudWxsYCBtZWFucyBhbGwgbWFya3NcbiAgICAgICAgYXJlIGFsbG93ZWQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFya1NldCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gc3BlYy5ncm91cCA/IHNwZWMuZ3JvdXAuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMoc3BlYy5hdHRycyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdEF0dHJzID0gZGVmYXVsdEF0dHJzKHRoaXMuYXR0cnMpO1xuICAgICAgICB0aGlzLmNvbnRlbnRNYXRjaCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5saW5lQ29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNCbG9jayA9ICEoc3BlYy5pbmxpbmUgfHwgbmFtZSA9PSBcInRleHRcIik7XG4gICAgICAgIHRoaXMuaXNUZXh0ID0gbmFtZSA9PSBcInRleHRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB0aGlzIGlzIGFuIGlubGluZSB0eXBlLlxuICAgICovXG4gICAgZ2V0IGlzSW5saW5lKCkgeyByZXR1cm4gIXRoaXMuaXNCbG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgdGhpcyBpcyBhIHRleHRibG9jayB0eXBlLCBhIGJsb2NrIHRoYXQgY29udGFpbnMgaW5saW5lXG4gICAgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc1RleHRibG9jaygpIHsgcmV0dXJuIHRoaXMuaXNCbG9jayAmJiB0aGlzLmlubGluZUNvbnRlbnQ7IH1cbiAgICAvKipcbiAgICBUcnVlIGZvciBub2RlIHR5cGVzIHRoYXQgYWxsb3cgbm8gY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc0xlYWYoKSB7IHJldHVybiB0aGlzLmNvbnRlbnRNYXRjaCA9PSBDb250ZW50TWF0Y2guZW1wdHk7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBub2RlIGlzIGFuIGF0b20sIGkuZS4gd2hlbiBpdCBkb2VzIG5vdCBoYXZlXG4gICAgZGlyZWN0bHkgZWRpdGFibGUgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc0F0b20oKSB7IHJldHVybiB0aGlzLmlzTGVhZiB8fCAhIXRoaXMuc3BlYy5hdG9tOyB9XG4gICAgLyoqXG4gICAgVGhlIG5vZGUgdHlwZSdzIFt3aGl0ZXNwYWNlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMud2hpdGVzcGFjZSkgb3B0aW9uLlxuICAgICovXG4gICAgZ2V0IHdoaXRlc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMud2hpdGVzcGFjZSB8fCAodGhpcy5zcGVjLmNvZGUgPyBcInByZVwiIDogXCJub3JtYWxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoaXMgbm9kZSB0eXBlIGhhcyBhbnkgcmVxdWlyZWQgYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIGhhc1JlcXVpcmVkQXR0cnMoKSB7XG4gICAgICAgIGZvciAobGV0IG4gaW4gdGhpcy5hdHRycylcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzW25dLmlzUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBub2RlIGFsbG93cyBzb21lIG9mIHRoZSBzYW1lIGNvbnRlbnQgYXNcbiAgICB0aGUgZ2l2ZW4gbm9kZSB0eXBlLlxuICAgICovXG4gICAgY29tcGF0aWJsZUNvbnRlbnQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb250ZW50TWF0Y2guY29tcGF0aWJsZShvdGhlci5jb250ZW50TWF0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXB1dGVBdHRycyhhdHRycykge1xuICAgICAgICBpZiAoIWF0dHJzICYmIHRoaXMuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEF0dHJzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZUF0dHJzKHRoaXMuYXR0cnMsIGF0dHJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgYE5vZGVgIG9mIHRoaXMgdHlwZS4gVGhlIGdpdmVuIGF0dHJpYnV0ZXMgYXJlXG4gICAgY2hlY2tlZCBhbmQgZGVmYXVsdGVkICh5b3UgY2FuIHBhc3MgYG51bGxgIHRvIHVzZSB0aGUgdHlwZSdzXG4gICAgZGVmYXVsdHMgZW50aXJlbHksIGlmIG5vIHJlcXVpcmVkIGF0dHJpYnV0ZXMgZXhpc3QpLiBgY29udGVudGBcbiAgICBtYXkgYmUgYSBgRnJhZ21lbnRgLCBhIG5vZGUsIGFuIGFycmF5IG9mIG5vZGVzLCBvclxuICAgIGBudWxsYC4gU2ltaWxhcmx5IGBtYXJrc2AgbWF5IGJlIGBudWxsYCB0byBkZWZhdWx0IHRvIHRoZSBlbXB0eVxuICAgIHNldCBvZiBtYXJrcy5cbiAgICAqL1xuICAgIGNyZWF0ZShhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGVUeXBlLmNyZWF0ZSBjYW4ndCBjb25zdHJ1Y3QgdGV4dCBub2Rlc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKSwgRnJhZ21lbnQuZnJvbShjb250ZW50KSwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIExpa2UgW2BjcmVhdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUuY3JlYXRlKSwgYnV0IGNoZWNrIHRoZSBnaXZlbiBjb250ZW50XG4gICAgYWdhaW5zdCB0aGUgbm9kZSB0eXBlJ3MgY29udGVudCByZXN0cmljdGlvbnMsIGFuZCB0aHJvdyBhbiBlcnJvclxuICAgIGlmIGl0IGRvZXNuJ3QgbWF0Y2guXG4gICAgKi9cbiAgICBjcmVhdGVDaGVja2VkKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG4gICAgICAgIHRoaXMuY2hlY2tDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpLCBjb250ZW50LCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYGNyZWF0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZS5jcmVhdGUpLCBidXQgc2VlIGlmIGl0IGlzXG4gICAgbmVjZXNzYXJ5IHRvIGFkZCBub2RlcyB0byB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBnaXZlbiBmcmFnbWVudFxuICAgIHRvIG1ha2UgaXQgZml0IHRoZSBub2RlLiBJZiBubyBmaXR0aW5nIHdyYXBwaW5nIGNhbiBiZSBmb3VuZCxcbiAgICByZXR1cm4gbnVsbC4gTm90ZSB0aGF0LCBkdWUgdG8gdGhlIGZhY3QgdGhhdCByZXF1aXJlZCBub2RlcyBjYW5cbiAgICBhbHdheXMgYmUgY3JlYXRlZCwgdGhpcyB3aWxsIGFsd2F5cyBzdWNjZWVkIGlmIHlvdSBwYXNzIG51bGwgb3JcbiAgICBgRnJhZ21lbnQuZW1wdHlgIGFzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBjcmVhdGVBbmRGaWxsKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgYXR0cnMgPSB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyk7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKGNvbnRlbnQpO1xuICAgICAgICBpZiAoY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gdGhpcy5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShjb250ZW50KTtcbiAgICAgICAgICAgIGlmICghYmVmb3JlKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29udGVudCA9IGJlZm9yZS5hcHBlbmQoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hdGNoZWQgPSB0aGlzLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICBsZXQgYWZ0ZXIgPSBtYXRjaGVkICYmIG1hdGNoZWQuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgICAgIGlmICghYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIGF0dHJzLCBjb250ZW50LmFwcGVuZChhZnRlciksIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGZyYWdtZW50IGlzIHZhbGlkIGNvbnRlbnQgZm9yIHRoaXMgbm9kZVxuICAgIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIHZhbGlkQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtzKGNvbnRlbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRocm93cyBhIFJhbmdlRXJyb3IgaWYgdGhlIGdpdmVuIGZyYWdtZW50IGlzIG5vdCB2YWxpZCBjb250ZW50IGZvciB0aGlzXG4gICAgbm9kZSB0eXBlLlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hlY2tDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkQ29udGVudChjb250ZW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNvbnRlbnQgZm9yIG5vZGUgJHt0aGlzLm5hbWV9OiAke2NvbnRlbnQudG9TdHJpbmcoKS5zbGljZSgwLCA1MCl9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIG1hcmsgdHlwZSBpcyBhbGxvd2VkIGluIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIGFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtTZXQgPT0gbnVsbCB8fCB0aGlzLm1hcmtTZXQuaW5kZXhPZihtYXJrVHlwZSkgPiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MgYXJlIGFsbG93ZWQgaW4gdGhpcyBub2RlLlxuICAgICovXG4gICAgYWxsb3dzTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya1NldCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya1R5cGUobWFya3NbaV0udHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyB0aGUgbWFya3MgdGhhdCBhcmUgbm90IGFsbG93ZWQgaW4gdGhpcyBub2RlIGZyb20gdGhlIGdpdmVuIHNldC5cbiAgICAqL1xuICAgIGFsbG93ZWRNYXJrcyhtYXJrcykge1xuICAgICAgICBpZiAodGhpcy5tYXJrU2V0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgICAgIGxldCBjb3B5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya1R5cGUobWFya3NbaV0udHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBtYXJrcy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgICAgICBjb3B5LnB1c2gobWFya3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhY29weSA/IG1hcmtzIDogY29weS5sZW5ndGggPyBjb3B5IDogTWFyay5ub25lO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjb21waWxlKG5vZGVzLCBzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIG5vZGVzLmZvckVhY2goKG5hbWUsIHNwZWMpID0+IHJlc3VsdFtuYW1lXSA9IG5ldyBOb2RlVHlwZShuYW1lLCBzY2hlbWEsIHNwZWMpKTtcbiAgICAgICAgbGV0IHRvcFR5cGUgPSBzY2hlbWEuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCI7XG4gICAgICAgIGlmICghcmVzdWx0W3RvcFR5cGVdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTY2hlbWEgaXMgbWlzc2luZyBpdHMgdG9wIG5vZGUgdHlwZSAoJ1wiICsgdG9wVHlwZSArIFwiJylcIik7XG4gICAgICAgIGlmICghcmVzdWx0LnRleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkV2ZXJ5IHNjaGVtYSBuZWVkcyBhICd0ZXh0JyB0eXBlXCIpO1xuICAgICAgICBmb3IgKGxldCBfIGluIHJlc3VsdC50ZXh0LmF0dHJzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdGV4dCBub2RlIHR5cGUgc2hvdWxkIG5vdCBoYXZlIGF0dHJpYnV0ZXNcIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8gQXR0cmlidXRlIGRlc2NyaXB0b3JzXG5jbGFzcyBBdHRyaWJ1dGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5oYXNEZWZhdWx0ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwiZGVmYXVsdFwiKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gb3B0aW9ucy5kZWZhdWx0O1xuICAgIH1cbiAgICBnZXQgaXNSZXF1aXJlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmhhc0RlZmF1bHQ7XG4gICAgfVxufVxuLy8gTWFya3Ncbi8qKlxuTGlrZSBub2RlcywgbWFya3MgKHdoaWNoIGFyZSBhc3NvY2lhdGVkIHdpdGggbm9kZXMgdG8gc2lnbmlmeVxudGhpbmdzIGxpa2UgZW1waGFzaXMgb3IgYmVpbmcgcGFydCBvZiBhIGxpbmspIGFyZVxuW3RhZ2dlZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmsudHlwZSkgd2l0aCB0eXBlIG9iamVjdHMsIHdoaWNoIGFyZVxuaW5zdGFudGlhdGVkIG9uY2UgcGVyIGBTY2hlbWFgLlxuKi9cbmNsYXNzIE1hcmtUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoZSBtYXJrIHR5cGUuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJhbmssIFxuICAgIC8qKlxuICAgIFRoZSBzY2hlbWEgdGhhdCB0aGlzIG1hcmsgdHlwZSBpbnN0YW5jZSBpcyBwYXJ0IG9mLlxuICAgICovXG4gICAgc2NoZW1hLCBcbiAgICAvKipcbiAgICBUaGUgc3BlYyBvbiB3aGljaCB0aGUgdHlwZSBpcyBiYXNlZC5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5yYW5rID0gcmFuaztcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMoc3BlYy5hdHRycyk7XG4gICAgICAgIHRoaXMuZXhjbHVkZWQgPSBudWxsO1xuICAgICAgICBsZXQgZGVmYXVsdHMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBkZWZhdWx0cyA/IG5ldyBNYXJrKHRoaXMsIGRlZmF1bHRzKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgb2YgdGhpcyB0eXBlLiBgYXR0cnNgIG1heSBiZSBgbnVsbGAgb3IgYW4gb2JqZWN0XG4gICAgY29udGFpbmluZyBvbmx5IHNvbWUgb2YgdGhlIG1hcmsncyBhdHRyaWJ1dGVzLiBUaGUgb3RoZXJzLCBpZlxuICAgIHRoZXkgaGF2ZSBkZWZhdWx0cywgd2lsbCBiZSBhZGRlZC5cbiAgICAqL1xuICAgIGNyZWF0ZShhdHRycyA9IG51bGwpIHtcbiAgICAgICAgaWYgKCFhdHRycyAmJiB0aGlzLmluc3RhbmNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiBuZXcgTWFyayh0aGlzLCBjb21wdXRlQXR0cnModGhpcy5hdHRycywgYXR0cnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGlsZShtYXJrcywgc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpLCByYW5rID0gMDtcbiAgICAgICAgbWFya3MuZm9yRWFjaCgobmFtZSwgc3BlYykgPT4gcmVzdWx0W25hbWVdID0gbmV3IE1hcmtUeXBlKG5hbWUsIHJhbmsrKywgc2NoZW1hLCBzcGVjKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhlcmUgaXMgYSBtYXJrIG9mIHRoaXMgdHlwZSBpbiB0aGUgZ2l2ZW4gc2V0LCBhIG5ldyBzZXRcbiAgICB3aXRob3V0IGl0IGlzIHJldHVybmVkLiBPdGhlcndpc2UsIHRoZSBpbnB1dCBzZXQgaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICByZW1vdmVGcm9tU2V0KHNldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXRbaV0udHlwZSA9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgc2V0ID0gc2V0LnNsaWNlKDAsIGkpLmNvbmNhdChzZXQuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3RzIHdoZXRoZXIgdGhlcmUgaXMgYSBtYXJrIG9mIHRoaXMgdHlwZSBpbiB0aGUgZ2l2ZW4gc2V0LlxuICAgICovXG4gICAgaXNJblNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0W2ldO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyaWVzIHdoZXRoZXIgYSBnaXZlbiBtYXJrIHR5cGUgaXNcbiAgICBbZXhjbHVkZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrU3BlYy5leGNsdWRlcykgYnkgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBleGNsdWRlcyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5leGNsdWRlZC5pbmRleE9mKG90aGVyKSA+IC0xO1xuICAgIH1cbn1cbi8qKlxuQSBkb2N1bWVudCBzY2hlbWEuIEhvbGRzIFtub2RlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUpIGFuZCBbbWFya1xudHlwZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtUeXBlKSBvYmplY3RzIGZvciB0aGUgbm9kZXMgYW5kIG1hcmtzIHRoYXQgbWF5XG5vY2N1ciBpbiBjb25mb3JtaW5nIGRvY3VtZW50cywgYW5kIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yXG5jcmVhdGluZyBhbmQgZGVzZXJpYWxpemluZyBzdWNoIGRvY3VtZW50cy5cblxuV2hlbiBnaXZlbiwgdGhlIHR5cGUgcGFyYW1ldGVycyBwcm92aWRlIHRoZSBuYW1lcyBvZiB0aGUgbm9kZXMgYW5kXG5tYXJrcyBpbiB0aGlzIHNjaGVtYS5cbiovXG5jbGFzcyBTY2hlbWEge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIHNjaGVtYSBmcm9tIGEgc2NoZW1hIFtzcGVjaWZpY2F0aW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuU2NoZW1hU3BlYykuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIC8qKlxuICAgICAgICBBbiBvYmplY3QgZm9yIHN0b3Jpbmcgd2hhdGV2ZXIgdmFsdWVzIG1vZHVsZXMgbWF5IHdhbnQgdG9cbiAgICAgICAgY29tcHV0ZSBhbmQgY2FjaGUgcGVyIHNjaGVtYS4gKElmIHlvdSB3YW50IHRvIHN0b3JlIHNvbWV0aGluZ1xuICAgICAgICBpbiBpdCwgdHJ5IHRvIHVzZSBwcm9wZXJ0eSBuYW1lcyB1bmxpa2VseSB0byBjbGFzaC4pXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2FjaGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IGluc3RhbmNlU3BlYyA9IHRoaXMuc3BlYyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpXG4gICAgICAgICAgICBpbnN0YW5jZVNwZWNbcHJvcF0gPSBzcGVjW3Byb3BdO1xuICAgICAgICBpbnN0YW5jZVNwZWMubm9kZXMgPSBPcmRlcmVkTWFwLmZyb20oc3BlYy5ub2RlcyksXG4gICAgICAgICAgICBpbnN0YW5jZVNwZWMubWFya3MgPSBPcmRlcmVkTWFwLmZyb20oc3BlYy5tYXJrcyB8fCB7fSksXG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gTm9kZVR5cGUuY29tcGlsZSh0aGlzLnNwZWMubm9kZXMsIHRoaXMpO1xuICAgICAgICB0aGlzLm1hcmtzID0gTWFya1R5cGUuY29tcGlsZSh0aGlzLnNwZWMubWFya3MsIHRoaXMpO1xuICAgICAgICBsZXQgY29udGVudEV4cHJDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gdGhpcy5tYXJrcylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihwcm9wICsgXCIgY2FuIG5vdCBiZSBib3RoIGEgbm9kZSBhbmQgYSBtYXJrXCIpO1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm5vZGVzW3Byb3BdLCBjb250ZW50RXhwciA9IHR5cGUuc3BlYy5jb250ZW50IHx8IFwiXCIsIG1hcmtFeHByID0gdHlwZS5zcGVjLm1hcmtzO1xuICAgICAgICAgICAgdHlwZS5jb250ZW50TWF0Y2ggPSBjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSB8fFxuICAgICAgICAgICAgICAgIChjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSA9IENvbnRlbnRNYXRjaC5wYXJzZShjb250ZW50RXhwciwgdGhpcy5ub2RlcykpO1xuICAgICAgICAgICAgdHlwZS5pbmxpbmVDb250ZW50ID0gdHlwZS5jb250ZW50TWF0Y2guaW5saW5lQ29udGVudDtcbiAgICAgICAgICAgIHR5cGUubWFya1NldCA9IG1hcmtFeHByID09IFwiX1wiID8gbnVsbCA6XG4gICAgICAgICAgICAgICAgbWFya0V4cHIgPyBnYXRoZXJNYXJrcyh0aGlzLCBtYXJrRXhwci5zcGxpdChcIiBcIikpIDpcbiAgICAgICAgICAgICAgICAgICAgbWFya0V4cHIgPT0gXCJcIiB8fCAhdHlwZS5pbmxpbmVDb250ZW50ID8gW10gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGhpcy5tYXJrcykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm1hcmtzW3Byb3BdLCBleGNsID0gdHlwZS5zcGVjLmV4Y2x1ZGVzO1xuICAgICAgICAgICAgdHlwZS5leGNsdWRlZCA9IGV4Y2wgPT0gbnVsbCA/IFt0eXBlXSA6IGV4Y2wgPT0gXCJcIiA/IFtdIDogZ2F0aGVyTWFya3ModGhpcywgZXhjbC5zcGxpdChcIiBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZUZyb21KU09OID0gdGhpcy5ub2RlRnJvbUpTT04uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tYXJrRnJvbUpTT04gPSB0aGlzLm1hcmtGcm9tSlNPTi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRvcE5vZGVUeXBlID0gdGhpcy5ub2Rlc1t0aGlzLnNwZWMudG9wTm9kZSB8fCBcImRvY1wiXTtcbiAgICAgICAgdGhpcy5jYWNoZWQud3JhcHBpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBpbiB0aGlzIHNjaGVtYS4gVGhlIGB0eXBlYCBtYXkgYmUgYSBzdHJpbmcgb3IgYVxuICAgIGBOb2RlVHlwZWAgaW5zdGFuY2UuIEF0dHJpYnV0ZXMgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGRlZmF1bHRzLFxuICAgIGBjb250ZW50YCBtYXkgYmUgYSBgRnJhZ21lbnRgLCBgbnVsbGAsIGEgYE5vZGVgLCBvciBhbiBhcnJheSBvZlxuICAgIG5vZGVzLlxuICAgICovXG4gICAgbm9kZSh0eXBlLCBhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdHlwZSA9IHRoaXMubm9kZVR5cGUodHlwZSk7XG4gICAgICAgIGVsc2UgaWYgKCEodHlwZSBpbnN0YW5jZW9mIE5vZGVUeXBlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBub2RlIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUuc2NoZW1hICE9IHRoaXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBmcm9tIGRpZmZlcmVudCBzY2hlbWEgdXNlZCAoXCIgKyB0eXBlLm5hbWUgKyBcIilcIik7XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZUNoZWNrZWQoYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBub2RlIGluIHRoZSBzY2hlbWEuIEVtcHR5IHRleHQgbm9kZXMgYXJlIG5vdFxuICAgIGFsbG93ZWQuXG4gICAgKi9cbiAgICB0ZXh0KHRleHQsIG1hcmtzKSB7XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5ub2Rlcy50ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKHR5cGUsIHR5cGUuZGVmYXVsdEF0dHJzLCB0ZXh0LCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgbWFyayh0eXBlLCBhdHRycykge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLm1hcmtzW3R5cGVdO1xuICAgICAgICByZXR1cm4gdHlwZS5jcmVhdGUoYXR0cnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG5vZGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVGhpcyBtZXRob2QgaXNcbiAgICBib3VuZC5cbiAgICAqL1xuICAgIG5vZGVGcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBOb2RlLmZyb21KU09OKHRoaXMsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG1hcmsgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVGhpcyBtZXRob2QgaXNcbiAgICBib3VuZC5cbiAgICAqL1xuICAgIG1hcmtGcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBNYXJrLmZyb21KU09OKHRoaXMsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5vZGVUeXBlKG5hbWUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5ub2Rlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiICsgbmFtZSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG59XG5mdW5jdGlvbiBnYXRoZXJNYXJrcyhzY2hlbWEsIG1hcmtzKSB7XG4gICAgbGV0IGZvdW5kID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbmFtZSA9IG1hcmtzW2ldLCBtYXJrID0gc2NoZW1hLm1hcmtzW25hbWVdLCBvayA9IG1hcms7XG4gICAgICAgIGlmIChtYXJrKSB7XG4gICAgICAgICAgICBmb3VuZC5wdXNoKG1hcmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyayA9IHNjaGVtYS5tYXJrc1twcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcIl9cIiB8fCAobWFyay5zcGVjLmdyb3VwICYmIG1hcmsuc3BlYy5ncm91cC5zcGxpdChcIiBcIikuaW5kZXhPZihuYW1lKSA+IC0xKSlcbiAgICAgICAgICAgICAgICAgICAgZm91bmQucHVzaChvayA9IG1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb2spXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbmtub3duIG1hcmsgdHlwZTogJ1wiICsgbWFya3NbaV0gKyBcIidcIik7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cblxuLyoqXG5BIERPTSBwYXJzZXIgcmVwcmVzZW50cyBhIHN0cmF0ZWd5IGZvciBwYXJzaW5nIERPTSBjb250ZW50IGludG8gYVxuUHJvc2VNaXJyb3IgZG9jdW1lbnQgY29uZm9ybWluZyB0byBhIGdpdmVuIHNjaGVtYS4gSXRzIGJlaGF2aW9yIGlzXG5kZWZpbmVkIGJ5IGFuIGFycmF5IG9mIFtydWxlc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlBhcnNlUnVsZSkuXG4qL1xuY2xhc3MgRE9NUGFyc2VyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwYXJzZXIgdGhhdCB0YXJnZXRzIHRoZSBnaXZlbiBzY2hlbWEsIHVzaW5nIHRoZSBnaXZlblxuICAgIHBhcnNpbmcgcnVsZXMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIGludG8gd2hpY2ggdGhlIHBhcnNlciBwYXJzZXMuXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzZXQgb2YgW3BhcnNlIHJ1bGVzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlKSB0aGF0IHRoZSBwYXJzZXJcbiAgICB1c2VzLCBpbiBvcmRlciBvZiBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgcnVsZXMpIHtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bGUudGFnKVxuICAgICAgICAgICAgICAgIHRoaXMudGFncy5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5zdHlsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gT25seSBub3JtYWxpemUgbGlzdCBlbGVtZW50cyB3aGVuIGxpc3RzIGluIHRoZSBzY2hlbWEgY2FuJ3QgZGlyZWN0bHkgY29udGFpbiB0aGVtc2VsdmVzXG4gICAgICAgIHRoaXMubm9ybWFsaXplTGlzdHMgPSAhdGhpcy50YWdzLnNvbWUociA9PiB7XG4gICAgICAgICAgICBpZiAoIS9eKHVsfG9sKVxcYi8udGVzdChyLnRhZykgfHwgIXIubm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHNjaGVtYS5ub2Rlc1tyLm5vZGVdO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY29udGVudE1hdGNoLm1hdGNoVHlwZShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFBhcnNlIGEgZG9jdW1lbnQgZnJvbSB0aGUgY29udGVudCBvZiBhIERPTSBub2RlLlxuICAgICovXG4gICAgcGFyc2UoZG9tLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgY29udGV4dC5hZGRBbGwoZG9tLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICAgICAgICByZXR1cm4gY29udGV4dC5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUGFyc2VzIHRoZSBjb250ZW50IG9mIHRoZSBnaXZlbiBET00gbm9kZSwgbGlrZVxuICAgIFtgcGFyc2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuRE9NUGFyc2VyLnBhcnNlKSwgYW5kIHRha2VzIHRoZSBzYW1lIHNldCBvZlxuICAgIG9wdGlvbnMuIEJ1dCB1bmxpa2UgdGhhdCBtZXRob2QsIHdoaWNoIHByb2R1Y2VzIGEgd2hvbGUgbm9kZSxcbiAgICB0aGlzIG9uZSByZXR1cm5zIGEgc2xpY2UgdGhhdCBpcyBvcGVuIGF0IHRoZSBzaWRlcywgbWVhbmluZyB0aGF0XG4gICAgdGhlIHNjaGVtYSBjb25zdHJhaW50cyBhcmVuJ3QgYXBwbGllZCB0byB0aGUgc3RhcnQgb2Ygbm9kZXMgdG9cbiAgICB0aGUgbGVmdCBvZiB0aGUgaW5wdXQgYW5kIHRoZSBlbmQgb2Ygbm9kZXMgYXQgdGhlIGVuZC5cbiAgICAqL1xuICAgIHBhcnNlU2xpY2UoZG9tLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG9wdGlvbnMsIHRydWUpO1xuICAgICAgICBjb250ZXh0LmFkZEFsbChkb20sIG9wdGlvbnMuZnJvbSwgb3B0aW9ucy50byk7XG4gICAgICAgIHJldHVybiBTbGljZS5tYXhPcGVuKGNvbnRleHQuZmluaXNoKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hdGNoVGFnKGRvbSwgY29udGV4dCwgYWZ0ZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFmdGVyID8gdGhpcy50YWdzLmluZGV4T2YoYWZ0ZXIpICsgMSA6IDA7IGkgPCB0aGlzLnRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBydWxlID0gdGhpcy50YWdzW2ldO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMoZG9tLCBydWxlLnRhZykgJiZcbiAgICAgICAgICAgICAgICAocnVsZS5uYW1lc3BhY2UgPT09IHVuZGVmaW5lZCB8fCBkb20ubmFtZXNwYWNlVVJJID09IHJ1bGUubmFtZXNwYWNlKSAmJlxuICAgICAgICAgICAgICAgICghcnVsZS5jb250ZXh0IHx8IGNvbnRleHQubWF0Y2hlc0NvbnRleHQocnVsZS5jb250ZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5nZXRBdHRycykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcnVsZS5nZXRBdHRycyhkb20pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBydWxlLmF0dHJzID0gcmVzdWx0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXRjaFN0eWxlKHByb3AsIHZhbHVlLCBjb250ZXh0LCBhZnRlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gYWZ0ZXIgPyB0aGlzLnN0eWxlcy5pbmRleE9mKGFmdGVyKSArIDEgOiAwOyBpIDwgdGhpcy5zdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBydWxlID0gdGhpcy5zdHlsZXNbaV0sIHN0eWxlID0gcnVsZS5zdHlsZTtcbiAgICAgICAgICAgIGlmIChzdHlsZS5pbmRleE9mKHByb3ApICE9IDAgfHxcbiAgICAgICAgICAgICAgICBydWxlLmNvbnRleHQgJiYgIWNvbnRleHQubWF0Y2hlc0NvbnRleHQocnVsZS5jb250ZXh0KSB8fFxuICAgICAgICAgICAgICAgIC8vIFRlc3QgdGhhdCB0aGUgc3R5bGUgc3RyaW5nIGVpdGhlciBwcmVjaXNlbHkgbWF0Y2hlcyB0aGUgcHJvcCxcbiAgICAgICAgICAgICAgICAvLyBvciBoYXMgYW4gJz0nIHNpZ24gYWZ0ZXIgdGhlIHByb3AsIGZvbGxvd2VkIGJ5IHRoZSBnaXZlblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHN0eWxlLmxlbmd0aCA+IHByb3AubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIChzdHlsZS5jaGFyQ29kZUF0KHByb3AubGVuZ3RoKSAhPSA2MSB8fCBzdHlsZS5zbGljZShwcm9wLmxlbmd0aCArIDEpICE9IHZhbHVlKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChydWxlLmdldEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJ1bGUuZ2V0QXR0cnModmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBydWxlLmF0dHJzID0gcmVzdWx0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHNjaGVtYVJ1bGVzKHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGluc2VydChydWxlKSB7XG4gICAgICAgICAgICBsZXQgcHJpb3JpdHkgPSBydWxlLnByaW9yaXR5ID09IG51bGwgPyA1MCA6IHJ1bGUucHJpb3JpdHksIGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHJlc3VsdFtpXSwgbmV4dFByaW9yaXR5ID0gbmV4dC5wcmlvcml0eSA9PSBudWxsID8gNTAgOiBuZXh0LnByaW9yaXR5O1xuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJpb3JpdHkgPCBwcmlvcml0eSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuc3BsaWNlKGksIDAsIHJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gc2NoZW1hLm1hcmtzKSB7XG4gICAgICAgICAgICBsZXQgcnVsZXMgPSBzY2hlbWEubWFya3NbbmFtZV0uc3BlYy5wYXJzZURPTTtcbiAgICAgICAgICAgIGlmIChydWxlcylcbiAgICAgICAgICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQocnVsZSA9IGNvcHkocnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShydWxlLm1hcmsgfHwgcnVsZS5pZ25vcmUgfHwgcnVsZS5jbGVhck1hcmspKVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5tYXJrID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHNjaGVtYS5ub2Rlcykge1xuICAgICAgICAgICAgbGV0IHJ1bGVzID0gc2NoZW1hLm5vZGVzW25hbWVdLnNwZWMucGFyc2VET007XG4gICAgICAgICAgICBpZiAocnVsZXMpXG4gICAgICAgICAgICAgICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KHJ1bGUgPSBjb3B5KHJ1bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocnVsZS5ub2RlIHx8IHJ1bGUuaWdub3JlIHx8IHJ1bGUubWFyaykpXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm5vZGUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIERPTSBwYXJzZXIgdXNpbmcgdGhlIHBhcnNpbmcgcnVsZXMgbGlzdGVkIGluIGFcbiAgICBzY2hlbWEncyBbbm9kZSBzcGVjc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnBhcnNlRE9NKSwgcmVvcmRlcmVkIGJ5XG4gICAgW3ByaW9yaXR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlLnByaW9yaXR5KS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmNhY2hlZC5kb21QYXJzZXIgfHxcbiAgICAgICAgICAgIChzY2hlbWEuY2FjaGVkLmRvbVBhcnNlciA9IG5ldyBET01QYXJzZXIoc2NoZW1hLCBET01QYXJzZXIuc2NoZW1hUnVsZXMoc2NoZW1hKSkpO1xuICAgIH1cbn1cbmNvbnN0IGJsb2NrVGFncyA9IHtcbiAgICBhZGRyZXNzOiB0cnVlLCBhcnRpY2xlOiB0cnVlLCBhc2lkZTogdHJ1ZSwgYmxvY2txdW90ZTogdHJ1ZSwgY2FudmFzOiB0cnVlLFxuICAgIGRkOiB0cnVlLCBkaXY6IHRydWUsIGRsOiB0cnVlLCBmaWVsZHNldDogdHJ1ZSwgZmlnY2FwdGlvbjogdHJ1ZSwgZmlndXJlOiB0cnVlLFxuICAgIGZvb3RlcjogdHJ1ZSwgZm9ybTogdHJ1ZSwgaDE6IHRydWUsIGgyOiB0cnVlLCBoMzogdHJ1ZSwgaDQ6IHRydWUsIGg1OiB0cnVlLFxuICAgIGg2OiB0cnVlLCBoZWFkZXI6IHRydWUsIGhncm91cDogdHJ1ZSwgaHI6IHRydWUsIGxpOiB0cnVlLCBub3NjcmlwdDogdHJ1ZSwgb2w6IHRydWUsXG4gICAgb3V0cHV0OiB0cnVlLCBwOiB0cnVlLCBwcmU6IHRydWUsIHNlY3Rpb246IHRydWUsIHRhYmxlOiB0cnVlLCB0Zm9vdDogdHJ1ZSwgdWw6IHRydWVcbn07XG5jb25zdCBpZ25vcmVUYWdzID0ge1xuICAgIGhlYWQ6IHRydWUsIG5vc2NyaXB0OiB0cnVlLCBvYmplY3Q6IHRydWUsIHNjcmlwdDogdHJ1ZSwgc3R5bGU6IHRydWUsIHRpdGxlOiB0cnVlXG59O1xuY29uc3QgbGlzdFRhZ3MgPSB7IG9sOiB0cnVlLCB1bDogdHJ1ZSB9O1xuLy8gVXNpbmcgYSBiaXRmaWVsZCBmb3Igbm9kZSBjb250ZXh0IG9wdGlvbnNcbmNvbnN0IE9QVF9QUkVTRVJWRV9XUyA9IDEsIE9QVF9QUkVTRVJWRV9XU19GVUxMID0gMiwgT1BUX09QRU5fTEVGVCA9IDQ7XG5mdW5jdGlvbiB3c09wdGlvbnNGb3IodHlwZSwgcHJlc2VydmVXaGl0ZXNwYWNlLCBiYXNlKSB7XG4gICAgaWYgKHByZXNlcnZlV2hpdGVzcGFjZSAhPSBudWxsKVxuICAgICAgICByZXR1cm4gKHByZXNlcnZlV2hpdGVzcGFjZSA/IE9QVF9QUkVTRVJWRV9XUyA6IDApIHxcbiAgICAgICAgICAgIChwcmVzZXJ2ZVdoaXRlc3BhY2UgPT09IFwiZnVsbFwiID8gT1BUX1BSRVNFUlZFX1dTX0ZVTEwgOiAwKTtcbiAgICByZXR1cm4gdHlwZSAmJiB0eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIiA/IE9QVF9QUkVTRVJWRV9XUyB8IE9QVF9QUkVTRVJWRV9XU19GVUxMIDogYmFzZSAmIH5PUFRfT1BFTl9MRUZUO1xufVxuY2xhc3MgTm9kZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGF0dHJzLCBcbiAgICAvLyBNYXJrcyBhcHBsaWVkIHRvIHRoaXMgbm9kZSBpdHNlbGZcbiAgICBtYXJrcywgXG4gICAgLy8gTWFya3MgdGhhdCBjYW4ndCBhcHBseSBoZXJlLCBidXQgd2lsbCBiZSB1c2VkIGluIGNoaWxkcmVuIGlmIHBvc3NpYmxlXG4gICAgcGVuZGluZ01hcmtzLCBzb2xpZCwgbWF0Y2gsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgICAgIHRoaXMucGVuZGluZ01hcmtzID0gcGVuZGluZ01hcmtzO1xuICAgICAgICB0aGlzLnNvbGlkID0gc29saWQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgICAgICAvLyBNYXJrcyBhcHBsaWVkIHRvIHRoZSBub2RlJ3MgY2hpbGRyZW5cbiAgICAgICAgdGhpcy5hY3RpdmVNYXJrcyA9IE1hcmsubm9uZTtcbiAgICAgICAgLy8gTmVzdGVkIE1hcmtzIHdpdGggc2FtZSB0eXBlXG4gICAgICAgIHRoaXMuc3Rhc2hNYXJrcyA9IFtdO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2ggfHwgKG9wdGlvbnMgJiBPUFRfT1BFTl9MRUZUID8gbnVsbCA6IHR5cGUuY29udGVudE1hdGNoKTtcbiAgICB9XG4gICAgZmluZFdyYXBwaW5nKG5vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICBsZXQgZmlsbCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICAgICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChmaWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gsIHdyYXA7XG4gICAgICAgICAgICAgICAgaWYgKHdyYXAgPSBzdGFydC5maW5kV3JhcHBpbmcobm9kZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoLmZpbmRXcmFwcGluZyhub2RlLnR5cGUpO1xuICAgIH1cbiAgICBmaW5pc2gob3BlbkVuZCkge1xuICAgICAgICBpZiAoISh0aGlzLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpKSB7IC8vIFN0cmlwIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSwgbTtcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QuaXNUZXh0ICYmIChtID0gL1sgXFx0XFxyXFxuXFx1MDAwY10rJC8uZXhlYyhsYXN0LnRleHQpKSkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdC50ZXh0Lmxlbmd0aCA9PSBtWzBdLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnBvcCgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSA9IHRleHQud2l0aFRleHQodGV4dC50ZXh0LnNsaWNlKDAsIHRleHQudGV4dC5sZW5ndGggLSBtWzBdLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh0aGlzLmNvbnRlbnQpO1xuICAgICAgICBpZiAoIW9wZW5FbmQgJiYgdGhpcy5tYXRjaClcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmFwcGVuZCh0aGlzLm1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA/IHRoaXMudHlwZS5jcmVhdGUodGhpcy5hdHRycywgY29udGVudCwgdGhpcy5tYXJrcykgOiBjb250ZW50O1xuICAgIH1cbiAgICBwb3BGcm9tU3Rhc2hNYXJrKG1hcmspIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3Rhc2hNYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGlmIChtYXJrLmVxKHRoaXMuc3Rhc2hNYXJrc1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3Rhc2hNYXJrcy5zcGxpY2UoaSwgMSlbMF07XG4gICAgfVxuICAgIGFwcGx5UGVuZGluZyhuZXh0VHlwZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcGVuZGluZyA9IHRoaXMucGVuZGluZ01hcmtzOyBpIDwgcGVuZGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcmsgPSBwZW5kaW5nW2ldO1xuICAgICAgICAgICAgaWYgKCh0aGlzLnR5cGUgPyB0aGlzLnR5cGUuYWxsb3dzTWFya1R5cGUobWFyay50eXBlKSA6IG1hcmtNYXlBcHBseShtYXJrLnR5cGUsIG5leHRUeXBlKSkgJiZcbiAgICAgICAgICAgICAgICAhbWFyay5pc0luU2V0KHRoaXMuYWN0aXZlTWFya3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVNYXJrcyA9IG1hcmsuYWRkVG9TZXQodGhpcy5hY3RpdmVNYXJrcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWFya3MgPSBtYXJrLnJlbW92ZUZyb21TZXQodGhpcy5wZW5kaW5nTWFya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlubGluZUNvbnRleHQobm9kZSkge1xuICAgICAgICBpZiAodGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5pbmxpbmVDb250ZW50O1xuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbMF0uaXNJbmxpbmU7XG4gICAgICAgIHJldHVybiBub2RlLnBhcmVudE5vZGUgJiYgIWJsb2NrVGFncy5oYXNPd25Qcm9wZXJ0eShub2RlLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxufVxuY2xhc3MgUGFyc2VDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgcGFyc2VyIHdlIGFyZSB1c2luZy5cbiAgICBwYXJzZXIsIFxuICAgIC8vIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGlzIHBhcnNlLlxuICAgIG9wdGlvbnMsIGlzT3Blbikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pc09wZW4gPSBpc09wZW47XG4gICAgICAgIHRoaXMub3BlbiA9IDA7XG4gICAgICAgIGxldCB0b3BOb2RlID0gb3B0aW9ucy50b3BOb2RlLCB0b3BDb250ZXh0O1xuICAgICAgICBsZXQgdG9wT3B0aW9ucyA9IHdzT3B0aW9uc0ZvcihudWxsLCBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSwgMCkgfCAoaXNPcGVuID8gT1BUX09QRU5fTEVGVCA6IDApO1xuICAgICAgICBpZiAodG9wTm9kZSlcbiAgICAgICAgICAgIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQodG9wTm9kZS50eXBlLCB0b3BOb2RlLmF0dHJzLCBNYXJrLm5vbmUsIE1hcmsubm9uZSwgdHJ1ZSwgb3B0aW9ucy50b3BNYXRjaCB8fCB0b3BOb2RlLnR5cGUuY29udGVudE1hdGNoLCB0b3BPcHRpb25zKTtcbiAgICAgICAgZWxzZSBpZiAoaXNPcGVuKVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dChudWxsLCBudWxsLCBNYXJrLm5vbmUsIE1hcmsubm9uZSwgdHJ1ZSwgbnVsbCwgdG9wT3B0aW9ucyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQocGFyc2VyLnNjaGVtYS50b3BOb2RlVHlwZSwgbnVsbCwgTWFyay5ub25lLCBNYXJrLm5vbmUsIHRydWUsIG51bGwsIHRvcE9wdGlvbnMpO1xuICAgICAgICB0aGlzLm5vZGVzID0gW3RvcENvbnRleHRdO1xuICAgICAgICB0aGlzLmZpbmQgPSBvcHRpb25zLmZpbmRQb3NpdGlvbnM7XG4gICAgICAgIHRoaXMubmVlZHNCbG9jayA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgdG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1t0aGlzLm9wZW5dO1xuICAgIH1cbiAgICAvLyBBZGQgYSBET00gbm9kZSB0byB0aGUgY29udGVudC4gVGV4dCBpcyBpbnNlcnRlZCBhcyB0ZXh0IG5vZGUsXG4gICAgLy8gb3RoZXJ3aXNlLCB0aGUgbm9kZSBpcyBwYXNzZWQgdG8gYGFkZEVsZW1lbnRgIG9yLCBpZiBpdCBoYXMgYVxuICAgIC8vIGBzdHlsZWAgYXR0cmlidXRlLCBgYWRkRWxlbWVudFdpdGhTdHlsZXNgLlxuICAgIGFkZERPTShkb20pIHtcbiAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgdGhpcy5hZGRUZXh0Tm9kZShkb20pO1xuICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudChkb20pO1xuICAgIH1cbiAgICB3aXRoU3R5bGVSdWxlcyhkb20sIGYpIHtcbiAgICAgICAgbGV0IHN0eWxlID0gZG9tLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgICAgICBpZiAoIXN0eWxlKVxuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgbGV0IG1hcmtzID0gdGhpcy5yZWFkU3R5bGVzKHBhcnNlU3R5bGVzKHN0eWxlKSk7XG4gICAgICAgIGlmICghbWFya3MpXG4gICAgICAgICAgICByZXR1cm47IC8vIEEgc3R5bGUgd2l0aCBpZ25vcmU6IHRydWVcbiAgICAgICAgbGV0IFthZGRNYXJrcywgcmVtb3ZlTWFya3NdID0gbWFya3MsIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZU1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVQZW5kaW5nTWFyayhyZW1vdmVNYXJrc1tpXSwgdG9wKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuYWRkUGVuZGluZ01hcmsoYWRkTWFya3NbaV0pO1xuICAgICAgICBmKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkTWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBlbmRpbmdNYXJrKGFkZE1hcmtzW2ldLCB0b3ApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZU1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5hZGRQZW5kaW5nTWFyayhyZW1vdmVNYXJrc1tpXSk7XG4gICAgfVxuICAgIGFkZFRleHROb2RlKGRvbSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBkb20ubm9kZVZhbHVlO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy50b3A7XG4gICAgICAgIGlmICh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XU19GVUxMIHx8XG4gICAgICAgICAgICB0b3AuaW5saW5lQ29udGV4dChkb20pIHx8XG4gICAgICAgICAgICAvW14gXFx0XFxyXFxuXFx1MDAwY10vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoISh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XUykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1sgXFx0XFxyXFxuXFx1MDAwY10rL2csIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UsIGFuZCB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSBpdCwgb3JcbiAgICAgICAgICAgICAgICAvLyBhIGhhcmQgYnJlYWssIG9yIGEgdGV4dCBub2RlIHRoYXQgZW5kcyB3aXRoIHdoaXRlc3BhY2UsIHN0cmlwIHRoZVxuICAgICAgICAgICAgICAgIC8vIGxlYWRpbmcgc3BhY2UuXG4gICAgICAgICAgICAgICAgaWYgKC9eWyBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkgJiYgdGhpcy5vcGVuID09IHRoaXMubm9kZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZUJlZm9yZSA9IHRvcC5jb250ZW50W3RvcC5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZG9tTm9kZUJlZm9yZSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZUJlZm9yZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGRvbU5vZGVCZWZvcmUgJiYgZG9tTm9kZUJlZm9yZS5ub2RlTmFtZSA9PSAnQlInKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGVCZWZvcmUuaXNUZXh0ICYmIC9bIFxcdFxcclxcblxcdTAwMGNdJC8udGVzdChub2RlQmVmb3JlLnRleHQpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoISh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XU19GVUxMKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywgXCIgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0Tm9kZSh0aGlzLnBhcnNlci5zY2hlbWEudGV4dCh2YWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy5maW5kSW5UZXh0KGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiB0YWcgYW5kIHVzZSB0aGF0IHRvIHBhcnNlLiBJZlxuICAgIC8vIG5vbmUgaXMgZm91bmQsIHRoZSBlbGVtZW50J3MgY29udGVudCBub2RlcyBhcmUgYWRkZWQgZGlyZWN0bHkuXG4gICAgYWRkRWxlbWVudChkb20sIG1hdGNoQWZ0ZXIpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBkb20ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgcnVsZUlEO1xuICAgICAgICBpZiAobGlzdFRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgdGhpcy5wYXJzZXIubm9ybWFsaXplTGlzdHMpXG4gICAgICAgICAgICBub3JtYWxpemVMaXN0KGRvbSk7XG4gICAgICAgIGxldCBydWxlID0gKHRoaXMub3B0aW9ucy5ydWxlRnJvbU5vZGUgJiYgdGhpcy5vcHRpb25zLnJ1bGVGcm9tTm9kZShkb20pKSB8fFxuICAgICAgICAgICAgKHJ1bGVJRCA9IHRoaXMucGFyc2VyLm1hdGNoVGFnKGRvbSwgdGhpcywgbWF0Y2hBZnRlcikpO1xuICAgICAgICBpZiAocnVsZSA/IHJ1bGUuaWdub3JlIDogaWdub3JlVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUZhbGxiYWNrKGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXJ1bGUgfHwgcnVsZS5za2lwIHx8IHJ1bGUuY2xvc2VQYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChydWxlICYmIHJ1bGUuY2xvc2VQYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuID0gTWF0aC5tYXgoMCwgdGhpcy5vcGVuIC0gMSk7XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlICYmIHJ1bGUuc2tpcC5ub2RlVHlwZSlcbiAgICAgICAgICAgICAgICBkb20gPSBydWxlLnNraXA7XG4gICAgICAgICAgICBsZXQgc3luYywgdG9wID0gdGhpcy50b3AsIG9sZE5lZWRzQmxvY2sgPSB0aGlzLm5lZWRzQmxvY2s7XG4gICAgICAgICAgICBpZiAoYmxvY2tUYWdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcC5jb250ZW50Lmxlbmd0aCAmJiB0b3AuY29udGVudFswXS5pc0lubGluZSAmJiB0aGlzLm9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuLS07XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRvcC50eXBlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRvbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFmRmFsbGJhY2soZG9tKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVsZSAmJiBydWxlLnNraXApXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBbGwoZG9tKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLndpdGhTdHlsZVJ1bGVzKGRvbSwgKCkgPT4gdGhpcy5hZGRBbGwoZG9tKSk7XG4gICAgICAgICAgICBpZiAoc3luYylcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmModG9wKTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNCbG9jayA9IG9sZE5lZWRzQmxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndpdGhTdHlsZVJ1bGVzKGRvbSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudEJ5UnVsZShkb20sIHJ1bGUsIHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSA/IHJ1bGVJRCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYWxsZWQgZm9yIGxlYWYgRE9NIG5vZGVzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGJlIGlnbm9yZWRcbiAgICBsZWFmRmFsbGJhY2soZG9tKSB7XG4gICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmIHRoaXMudG9wLnR5cGUgJiYgdGhpcy50b3AudHlwZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgdGhpcy5hZGRUZXh0Tm9kZShkb20ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSk7XG4gICAgfVxuICAgIC8vIENhbGxlZCBmb3IgaWdub3JlZCBub2Rlc1xuICAgIGlnbm9yZUZhbGxiYWNrKGRvbSkge1xuICAgICAgICAvLyBJZ25vcmVkIEJSIG5vZGVzIHNob3VsZCBhdCBsZWFzdCBjcmVhdGUgYW4gaW5saW5lIGNvbnRleHRcbiAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgKCF0aGlzLnRvcC50eXBlIHx8ICF0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpKVxuICAgICAgICAgICAgdGhpcy5maW5kUGxhY2UodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQoXCItXCIpKTtcbiAgICB9XG4gICAgLy8gUnVuIGFueSBzdHlsZSBwYXJzZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBub2RlJ3Mgc3R5bGVzLiBFaXRoZXJcbiAgICAvLyByZXR1cm4gYW4gYXJyYXkgb2YgbWFya3MsIG9yIG51bGwgdG8gaW5kaWNhdGUgc29tZSBvZiB0aGUgc3R5bGVzXG4gICAgLy8gaGFkIGEgcnVsZSB3aXRoIGBpZ25vcmVgIHNldC5cbiAgICByZWFkU3R5bGVzKHN0eWxlcykge1xuICAgICAgICBsZXQgYWRkID0gTWFyay5ub25lLCByZW1vdmUgPSBNYXJrLm5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBhZnRlciA9IHVuZGVmaW5lZDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnBhcnNlci5tYXRjaFN0eWxlKHN0eWxlc1tpXSwgc3R5bGVzW2kgKyAxXSwgdGhpcywgYWZ0ZXIpO1xuICAgICAgICAgICAgICAgIGlmICghcnVsZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuaWdub3JlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5jbGVhck1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3AucGVuZGluZ01hcmtzLmNvbmNhdCh0aGlzLnRvcC5hY3RpdmVNYXJrcykuZm9yRWFjaChtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmNsZWFyTWFyayhtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUgPSBtLmFkZFRvU2V0KHJlbW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkID0gdGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya10uY3JlYXRlKHJ1bGUuYXR0cnMpLmFkZFRvU2V0KGFkZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydWxlLmNvbnN1bWluZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gcnVsZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbYWRkLCByZW1vdmVdO1xuICAgIH1cbiAgICAvLyBMb29rIHVwIGEgaGFuZGxlciBmb3IgdGhlIGdpdmVuIG5vZGUuIElmIG5vbmUgYXJlIGZvdW5kLCByZXR1cm5cbiAgICAvLyBmYWxzZS4gT3RoZXJ3aXNlLCBhcHBseSBpdCwgdXNlIGl0cyByZXR1cm4gdmFsdWUgdG8gZHJpdmUgdGhlIHdheVxuICAgIC8vIHRoZSBub2RlJ3MgY29udGVudCBpcyB3cmFwcGVkLCBhbmQgcmV0dXJuIHRydWUuXG4gICAgYWRkRWxlbWVudEJ5UnVsZShkb20sIHJ1bGUsIGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICAgICAgbGV0IHN5bmMsIG5vZGVUeXBlLCBtYXJrO1xuICAgICAgICBpZiAocnVsZS5ub2RlKSB7XG4gICAgICAgICAgICBub2RlVHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tydWxlLm5vZGVdO1xuICAgICAgICAgICAgaWYgKCFub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICBzeW5jID0gdGhpcy5lbnRlcihub2RlVHlwZSwgcnVsZS5hdHRycyB8fCBudWxsLCBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5pbnNlcnROb2RlKG5vZGVUeXBlLmNyZWF0ZShydWxlLmF0dHJzKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlYWZGYWxsYmFjayhkb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1hcmtUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya107XG4gICAgICAgICAgICBtYXJrID0gbWFya1R5cGUuY3JlYXRlKHJ1bGUuYXR0cnMpO1xuICAgICAgICAgICAgdGhpcy5hZGRQZW5kaW5nTWFyayhtYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRJbiA9IHRoaXMudG9wO1xuICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUuaXNMZWFmKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250aW51ZUFmdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZG9tLCBjb250aW51ZUFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydWxlLmdldENvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50KGRvbSwgdGhpcy5wYXJzZXIuc2NoZW1hKS5mb3JFYWNoKG5vZGUgPT4gdGhpcy5pbnNlcnROb2RlKG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50RE9NID0gZG9tO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlLmNvbnRlbnRFbGVtZW50ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IGRvbS5xdWVyeVNlbGVjdG9yKHJ1bGUuY29udGVudEVsZW1lbnQpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJ1bGUuY29udGVudEVsZW1lbnQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBydWxlLmNvbnRlbnRFbGVtZW50KGRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLmNvbnRlbnRFbGVtZW50KVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBydWxlLmNvbnRlbnRFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5maW5kQXJvdW5kKGRvbSwgY29udGVudERPTSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmFkZEFsbChjb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3luYyAmJiB0aGlzLnN5bmMoc3RhcnRJbikpXG4gICAgICAgICAgICB0aGlzLm9wZW4tLTtcbiAgICAgICAgaWYgKG1hcmspXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBlbmRpbmdNYXJrKG1hcmssIHN0YXJ0SW4pO1xuICAgIH1cbiAgICAvLyBBZGQgYWxsIGNoaWxkIG5vZGVzIGJldHdlZW4gYHN0YXJ0SW5kZXhgIGFuZCBgZW5kSW5kZXhgIChvciB0aGVcbiAgICAvLyB3aG9sZSBub2RlLCBpZiBub3QgZ2l2ZW4pLiBJZiBgc3luY2AgaXMgcGFzc2VkLCB1c2UgaXQgdG9cbiAgICAvLyBzeW5jaHJvbml6ZSBhZnRlciBldmVyeSBibG9jayBlbGVtZW50LlxuICAgIGFkZEFsbChwYXJlbnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcbiAgICAgICAgZm9yIChsZXQgZG9tID0gc3RhcnRJbmRleCA/IHBhcmVudC5jaGlsZE5vZGVzW3N0YXJ0SW5kZXhdIDogcGFyZW50LmZpcnN0Q2hpbGQsIGVuZCA9IGVuZEluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50LmNoaWxkTm9kZXNbZW5kSW5kZXhdOyBkb20gIT0gZW5kOyBkb20gPSBkb20ubmV4dFNpYmxpbmcsICsraW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEF0UG9pbnQocGFyZW50LCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmFkZERPTShkb20pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluZEF0UG9pbnQocGFyZW50LCBpbmRleCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byBmaW5kIGEgd2F5IHRvIGZpdCB0aGUgZ2l2ZW4gbm9kZSB0eXBlIGludG8gdGhlIGN1cnJlbnRcbiAgICAvLyBjb250ZXh0LiBNYXkgYWRkIGludGVybWVkaWF0ZSB3cmFwcGVycyBhbmQvb3IgbGVhdmUgbm9uLXNvbGlkXG4gICAgLy8gbm9kZXMgdGhhdCB3ZSdyZSBpbi5cbiAgICBmaW5kUGxhY2Uobm9kZSkge1xuICAgICAgICBsZXQgcm91dGUsIHN5bmM7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gdGhpcy5vcGVuOyBkZXB0aCA+PSAwOyBkZXB0aC0tKSB7XG4gICAgICAgICAgICBsZXQgY3ggPSB0aGlzLm5vZGVzW2RlcHRoXTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGN4LmZpbmRXcmFwcGluZyhub2RlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCAmJiAoIXJvdXRlIHx8IHJvdXRlLmxlbmd0aCA+IGZvdW5kLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICByb3V0ZSA9IGZvdW5kO1xuICAgICAgICAgICAgICAgIHN5bmMgPSBjeDtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3guc29saWQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyb3V0ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jKHN5bmMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5lbnRlcklubmVyKHJvdXRlW2ldLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gaW5zZXJ0IHRoZSBnaXZlbiBub2RlLCBhZGp1c3RpbmcgdGhlIGNvbnRleHQgd2hlbiBuZWVkZWQuXG4gICAgaW5zZXJ0Tm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmlzSW5saW5lICYmIHRoaXMubmVlZHNCbG9jayAmJiAhdGhpcy50b3AudHlwZSkge1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gdGhpcy50ZXh0YmxvY2tGcm9tQ29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKGJsb2NrKVxuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJJbm5lcihibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmluZFBsYWNlKG5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgICAgIHRvcC5hcHBseVBlbmRpbmcobm9kZS50eXBlKTtcbiAgICAgICAgICAgIGlmICh0b3AubWF0Y2gpXG4gICAgICAgICAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZShub2RlLnR5cGUpO1xuICAgICAgICAgICAgbGV0IG1hcmtzID0gdG9wLmFjdGl2ZU1hcmtzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICghdG9wLnR5cGUgfHwgdG9wLnR5cGUuYWxsb3dzTWFya1R5cGUobm9kZS5tYXJrc1tpXS50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgbWFya3MgPSBub2RlLm1hcmtzW2ldLmFkZFRvU2V0KG1hcmtzKTtcbiAgICAgICAgICAgIHRvcC5jb250ZW50LnB1c2gobm9kZS5tYXJrKG1hcmtzKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRyeSB0byBzdGFydCBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUsIGFkanVzdGluZyB0aGUgY29udGV4dCB3aGVuXG4gICAgLy8gbmVjZXNzYXJ5LlxuICAgIGVudGVyKHR5cGUsIGF0dHJzLCBwcmVzZXJ2ZVdTKSB7XG4gICAgICAgIGxldCBvayA9IHRoaXMuZmluZFBsYWNlKHR5cGUuY3JlYXRlKGF0dHJzKSk7XG4gICAgICAgIGlmIChvaylcbiAgICAgICAgICAgIHRoaXMuZW50ZXJJbm5lcih0eXBlLCBhdHRycywgdHJ1ZSwgcHJlc2VydmVXUyk7XG4gICAgICAgIHJldHVybiBvaztcbiAgICB9XG4gICAgLy8gT3BlbiBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGVcbiAgICBlbnRlcklubmVyKHR5cGUsIGF0dHJzID0gbnVsbCwgc29saWQgPSBmYWxzZSwgcHJlc2VydmVXUykge1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgICB0b3AuYXBwbHlQZW5kaW5nKHR5cGUpO1xuICAgICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2ggJiYgdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB3c09wdGlvbnNGb3IodHlwZSwgcHJlc2VydmVXUywgdG9wLm9wdGlvbnMpO1xuICAgICAgICBpZiAoKHRvcC5vcHRpb25zICYgT1BUX09QRU5fTEVGVCkgJiYgdG9wLmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICBvcHRpb25zIHw9IE9QVF9PUEVOX0xFRlQ7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgTm9kZUNvbnRleHQodHlwZSwgYXR0cnMsIHRvcC5hY3RpdmVNYXJrcywgdG9wLnBlbmRpbmdNYXJrcywgc29saWQsIG51bGwsIG9wdGlvbnMpKTtcbiAgICAgICAgdGhpcy5vcGVuKys7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBhbGwgbm9kZXMgYWJvdmUgdGhpcy5vcGVuIGFyZSBmaW5pc2hlZCBhbmQgYWRkZWQgdG9cbiAgICAvLyB0aGVpciBwYXJlbnRzXG4gICAgY2xvc2VFeHRyYShvcGVuRW5kID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpID4gdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA+IHRoaXMub3BlbjsgaS0tKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXNbaSAtIDFdLmNvbnRlbnQucHVzaCh0aGlzLm5vZGVzW2ldLmZpbmlzaChvcGVuRW5kKSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmxlbmd0aCA9IHRoaXMub3BlbiArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICB0aGlzLm9wZW4gPSAwO1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEodGhpcy5pc09wZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXS5maW5pc2godGhpcy5pc09wZW4gfHwgdGhpcy5vcHRpb25zLnRvcE9wZW4pO1xuICAgIH1cbiAgICBzeW5jKHRvKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLm9wZW47IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbaV0gPT0gdG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4gPSBpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBjdXJyZW50UG9zKCkge1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLm9wZW47IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IHRoaXMubm9kZXNbaV0uY29udGVudDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBjb250ZW50Lmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuICAgICAgICAgICAgICAgIHBvcyArPSBjb250ZW50W2pdLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgZmluZEF0UG9pbnQocGFyZW50LCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5ub2RlID09IHBhcmVudCAmJiB0aGlzLmZpbmRbaV0ub2Zmc2V0ID09IG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZmluZEluc2lkZShwYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5wb3MgPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQuY29udGFpbnModGhpcy5maW5kW2ldLm5vZGUpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kQXJvdW5kKHBhcmVudCwgY29udGVudCwgYmVmb3JlKSB7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gY29udGVudCAmJiB0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ucG9zID09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09IDEgJiYgcGFyZW50LmNvbnRhaW5zKHRoaXMuZmluZFtpXS5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gY29udGVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzLmZpbmRbaV0ubm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgJiAoYmVmb3JlID8gMiA6IDQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRJblRleHQodGV4dE5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5ub2RlID09IHRleHROb2RlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zIC0gKHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGggLSB0aGlzLmZpbmRbaV0ub2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBjb250ZXh0IHN0cmluZyBtYXRjaGVzIHRoaXMgY29udGV4dC5cbiAgICBtYXRjaGVzQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmluZGV4T2YoXCJ8XCIpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5zcGxpdCgvXFxzKlxcfFxccyovKS5zb21lKHRoaXMubWF0Y2hlc0NvbnRleHQsIHRoaXMpO1xuICAgICAgICBsZXQgcGFydHMgPSBjb250ZXh0LnNwbGl0KFwiL1wiKTtcbiAgICAgICAgbGV0IG9wdGlvbiA9IHRoaXMub3B0aW9ucy5jb250ZXh0O1xuICAgICAgICBsZXQgdXNlUm9vdCA9ICF0aGlzLmlzT3BlbiAmJiAoIW9wdGlvbiB8fCBvcHRpb24ucGFyZW50LnR5cGUgPT0gdGhpcy5ub2Rlc1swXS50eXBlKTtcbiAgICAgICAgbGV0IG1pbkRlcHRoID0gLShvcHRpb24gPyBvcHRpb24uZGVwdGggKyAxIDogMCkgKyAodXNlUm9vdCA/IDAgOiAxKTtcbiAgICAgICAgbGV0IG1hdGNoID0gKGksIGRlcHRoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gcGFydHMubGVuZ3RoIC0gMSB8fCBpID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGRlcHRoID49IG1pbkRlcHRoOyBkZXB0aC0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKGkgLSAxLCBkZXB0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gZGVwdGggPiAwIHx8IChkZXB0aCA9PSAwICYmIHVzZVJvb3QpID8gdGhpcy5ub2Rlc1tkZXB0aF0udHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRpb24gJiYgZGVwdGggPj0gbWluRGVwdGggPyBvcHRpb24ubm9kZShkZXB0aCAtIG1pbkRlcHRoKS50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgKG5leHQubmFtZSAhPSBwYXJ0ICYmIG5leHQuZ3JvdXBzLmluZGV4T2YocGFydCkgPT0gLTEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWF0Y2gocGFydHMubGVuZ3RoIC0gMSwgdGhpcy5vcGVuKTtcbiAgICB9XG4gICAgdGV4dGJsb2NrRnJvbUNvbnRleHQoKSB7XG4gICAgICAgIGxldCAkY29udGV4dCA9IHRoaXMub3B0aW9ucy5jb250ZXh0O1xuICAgICAgICBpZiAoJGNvbnRleHQpXG4gICAgICAgICAgICBmb3IgKGxldCBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlZmx0ID0gJGNvbnRleHQubm9kZShkKS5jb250ZW50TWF0Y2hBdCgkY29udGV4dC5pbmRleEFmdGVyKGQpKS5kZWZhdWx0VHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmbHQgJiYgZGVmbHQuaXNUZXh0YmxvY2sgJiYgZGVmbHQuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmbHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmIHR5cGUuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFBlbmRpbmdNYXJrKG1hcmspIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmluZFNhbWVNYXJrSW5TZXQobWFyaywgdGhpcy50b3AucGVuZGluZ01hcmtzKTtcbiAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgdGhpcy50b3Auc3Rhc2hNYXJrcy5wdXNoKGZvdW5kKTtcbiAgICAgICAgdGhpcy50b3AucGVuZGluZ01hcmtzID0gbWFyay5hZGRUb1NldCh0aGlzLnRvcC5wZW5kaW5nTWFya3MpO1xuICAgIH1cbiAgICByZW1vdmVQZW5kaW5nTWFyayhtYXJrLCB1cHRvKSB7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gdGhpcy5vcGVuOyBkZXB0aCA+PSAwOyBkZXB0aC0tKSB7XG4gICAgICAgICAgICBsZXQgbGV2ZWwgPSB0aGlzLm5vZGVzW2RlcHRoXTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGxldmVsLnBlbmRpbmdNYXJrcy5sYXN0SW5kZXhPZihtYXJrKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwucGVuZGluZ01hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KGxldmVsLnBlbmRpbmdNYXJrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5hY3RpdmVNYXJrcyA9IG1hcmsucmVtb3ZlRnJvbVNldChsZXZlbC5hY3RpdmVNYXJrcyk7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXNoTWFyayA9IGxldmVsLnBvcEZyb21TdGFzaE1hcmsobWFyayk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXNoTWFyayAmJiBsZXZlbC50eXBlICYmIGxldmVsLnR5cGUuYWxsb3dzTWFya1R5cGUoc3Rhc2hNYXJrLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICBsZXZlbC5hY3RpdmVNYXJrcyA9IHN0YXNoTWFyay5hZGRUb1NldChsZXZlbC5hY3RpdmVNYXJrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGV2ZWwgPT0gdXB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBkaXJlY3RseSBuZXN0ZWQgbGlzdCBub2RlcyBwcm9kdWNlZCBieSBzb21lXG4vLyB0b29scyBhbmQgYWxsb3dlZCBieSBicm93c2VycyB0byBtZWFuIHRoYXQgdGhlIG5lc3RlZCBsaXN0IGlzXG4vLyBhY3R1YWxseSBwYXJ0IG9mIHRoZSBsaXN0IGl0ZW0gYWJvdmUgaXQuXG5mdW5jdGlvbiBub3JtYWxpemVMaXN0KGRvbSkge1xuICAgIGZvciAobGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQsIHByZXZJdGVtID0gbnVsbDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBjaGlsZC5ub2RlVHlwZSA9PSAxID8gY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgICAgIGlmIChuYW1lICYmIGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHByZXZJdGVtKSB7XG4gICAgICAgICAgICBwcmV2SXRlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICBjaGlsZCA9IHByZXZJdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJsaVwiKSB7XG4gICAgICAgICAgICBwcmV2SXRlbSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHByZXZJdGVtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEFwcGx5IGEgQ1NTIHNlbGVjdG9yLlxuZnVuY3Rpb24gbWF0Y2hlcyhkb20sIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIChkb20ubWF0Y2hlcyB8fCBkb20ubXNNYXRjaGVzU2VsZWN0b3IgfHwgZG9tLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBkb20ubW96TWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGRvbSwgc2VsZWN0b3IpO1xufVxuLy8gVG9rZW5pemUgYSBzdHlsZSBhdHRyaWJ1dGUgaW50byBwcm9wZXJ0eS92YWx1ZSBwYWlycy5cbmZ1bmN0aW9uIHBhcnNlU3R5bGVzKHN0eWxlKSB7XG4gICAgbGV0IHJlID0gL1xccyooW1xcdy1dKylcXHMqOlxccyooW147XSspL2csIG0sIHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChtID0gcmUuZXhlYyhzdHlsZSkpXG4gICAgICAgIHJlc3VsdC5wdXNoKG1bMV0sIG1bMl0udHJpbSgpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICBsZXQgY29weSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICBjb3B5W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIHJldHVybiBjb3B5O1xufVxuLy8gVXNlZCB3aGVuIGZpbmRpbmcgYSBtYXJrIGF0IHRoZSB0b3AgbGV2ZWwgb2YgYSBmcmFnbWVudCBwYXJzZS5cbi8vIENoZWNrcyB3aGV0aGVyIGl0IHdvdWxkIGJlIHJlYXNvbmFibGUgdG8gYXBwbHkgYSBnaXZlbiBtYXJrIHR5cGUgdG9cbi8vIGEgZ2l2ZW4gbm9kZSwgYnkgbG9va2luZyBhdCB0aGUgd2F5IHRoZSBtYXJrIG9jY3VycyBpbiB0aGUgc2NoZW1hLlxuZnVuY3Rpb24gbWFya01heUFwcGx5KG1hcmtUeXBlLCBub2RlVHlwZSkge1xuICAgIGxldCBub2RlcyA9IG5vZGVUeXBlLnNjaGVtYS5ub2RlcztcbiAgICBmb3IgKGxldCBuYW1lIGluIG5vZGVzKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBub2Rlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFwYXJlbnQuYWxsb3dzTWFya1R5cGUobWFya1R5cGUpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBzZWVuID0gW10sIHNjYW4gPSAobWF0Y2gpID0+IHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChtYXRjaCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2guZWRnZShpKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBub2RlVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihuZXh0KSA8IDAgJiYgc2NhbihuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzY2FuKHBhcmVudC5jb250ZW50TWF0Y2gpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZFNhbWVNYXJrSW5TZXQobWFyaywgc2V0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG1hcmsuZXEoc2V0W2ldKSlcbiAgICAgICAgICAgIHJldHVybiBzZXRbaV07XG4gICAgfVxufVxuXG4vKipcbkEgRE9NIHNlcmlhbGl6ZXIga25vd3MgaG93IHRvIGNvbnZlcnQgUHJvc2VNaXJyb3Igbm9kZXMgYW5kXG5tYXJrcyBvZiB2YXJpb3VzIHR5cGVzIHRvIERPTSBub2Rlcy5cbiovXG5jbGFzcyBET01TZXJpYWxpemVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXJpYWxpemVyLiBgbm9kZXNgIHNob3VsZCBtYXAgbm9kZSBuYW1lcyB0byBmdW5jdGlvbnNcbiAgICB0aGF0IHRha2UgYSBub2RlIGFuZCByZXR1cm4gYSBkZXNjcmlwdGlvbiBvZiB0aGUgY29ycmVzcG9uZGluZ1xuICAgIERPTS4gYG1hcmtzYCBkb2VzIHRoZSBzYW1lIGZvciBtYXJrIG5hbWVzLCBidXQgYWxzbyBnZXRzIGFuXG4gICAgYXJndW1lbnQgdGhhdCB0ZWxscyBpdCB3aGV0aGVyIHRoZSBtYXJrJ3MgY29udGVudCBpcyBibG9jayBvclxuICAgIGlubGluZSBjb250ZW50IChmb3IgdHlwaWNhbCB1c2UsIGl0J2xsIGFsd2F5cyBiZSBpbmxpbmUpLiBBIG1hcmtcbiAgICBzZXJpYWxpemVyIG1heSBiZSBgbnVsbGAgdG8gaW5kaWNhdGUgdGhhdCBtYXJrcyBvZiB0aGF0IHR5cGVcbiAgICBzaG91bGQgbm90IGJlIHNlcmlhbGl6ZWQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbm9kZSBzZXJpYWxpemF0aW9uIGZ1bmN0aW9ucy5cbiAgICAqL1xuICAgIG5vZGVzLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayBzZXJpYWxpemF0aW9uIGZ1bmN0aW9ucy5cbiAgICAqL1xuICAgIG1hcmtzKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhlIGNvbnRlbnQgb2YgdGhpcyBmcmFnbWVudCB0byBhIERPTSBmcmFnbWVudC4gV2hlblxuICAgIG5vdCBpbiB0aGUgYnJvd3NlciwgdGhlIGBkb2N1bWVudGAgb3B0aW9uLCBjb250YWluaW5nIGEgRE9NXG4gICAgZG9jdW1lbnQsIHNob3VsZCBiZSBwYXNzZWQgc28gdGhhdCB0aGUgc2VyaWFsaXplciBjYW4gY3JlYXRlXG4gICAgbm9kZXMuXG4gICAgKi9cbiAgICBzZXJpYWxpemVGcmFnbWVudChmcmFnbWVudCwgb3B0aW9ucyA9IHt9LCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICB0YXJnZXQgPSBkb2Mob3B0aW9ucykuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBsZXQgdG9wID0gdGFyZ2V0LCBhY3RpdmUgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUubGVuZ3RoIHx8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtlZXAgPSAwLCByZW5kZXJlZCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoICYmIHJlbmRlcmVkIDwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLm1hcmtzW3JlbmRlcmVkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hcmtzW25leHQudHlwZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dC5lcShhY3RpdmVba2VlcF1bMF0pIHx8IG5leHQudHlwZS5zcGVjLnNwYW5uaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBrZWVwKys7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChrZWVwIDwgYWN0aXZlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gYWN0aXZlLnBvcCgpWzFdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZW5kZXJlZCA8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZGQgPSBub2RlLm1hcmtzW3JlbmRlcmVkKytdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFya0RPTSA9IHRoaXMuc2VyaWFsaXplTWFyayhhZGQsIG5vZGUuaXNJbmxpbmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFya0RPTSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlLnB1c2goW2FkZCwgdG9wXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuYXBwZW5kQ2hpbGQobWFya0RPTS5kb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gbWFya0RPTS5jb250ZW50RE9NIHx8IG1hcmtET00uZG9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9wLmFwcGVuZENoaWxkKHRoaXMuc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHsgZG9tLCBjb250ZW50RE9NIH0gPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0aGlzLm5vZGVzW25vZGUudHlwZS5uYW1lXShub2RlKSk7XG4gICAgICAgIGlmIChjb250ZW50RE9NKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDb250ZW50IGhvbGUgbm90IGFsbG93ZWQgaW4gYSBsZWFmIG5vZGUgc3BlY1wiKTtcbiAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplRnJhZ21lbnQobm9kZS5jb250ZW50LCBvcHRpb25zLCBjb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBub2RlIHRvIGEgRE9NIG5vZGUuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdVxuICAgIG5lZWQgdG8gc2VyaWFsaXplIGEgcGFydCBvZiBhIGRvY3VtZW50LCBhcyBvcHBvc2VkIHRvIHRoZSB3aG9sZVxuICAgIGRvY3VtZW50LiBUbyBzZXJpYWxpemUgYSB3aG9sZSBkb2N1bWVudCwgdXNlXG4gICAgW2BzZXJpYWxpemVGcmFnbWVudGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5ET01TZXJpYWxpemVyLnNlcmlhbGl6ZUZyYWdtZW50KSBvblxuICAgIGl0cyBbY29udGVudF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUuY29udGVudCkuXG4gICAgKi9cbiAgICBzZXJpYWxpemVOb2RlKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5zZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIGZvciAobGV0IGkgPSBub2RlLm1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgd3JhcCA9IHRoaXMuc2VyaWFsaXplTWFyayhub2RlLm1hcmtzW2ldLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICh3cmFwKSB7XG4gICAgICAgICAgICAgICAgKHdyYXAuY29udGVudERPTSB8fCB3cmFwLmRvbSkuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSB3cmFwLmRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlcmlhbGl6ZU1hcmsobWFyaywgaW5saW5lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHRvRE9NID0gdGhpcy5tYXJrc1ttYXJrLnR5cGUubmFtZV07XG4gICAgICAgIHJldHVybiB0b0RPTSAmJiBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0b0RPTShtYXJrLCBpbmxpbmUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVuZGVyIGFuIFtvdXRwdXQgc3BlY10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTU91dHB1dFNwZWMpIHRvIGEgRE9NIG5vZGUuIElmXG4gICAgdGhlIHNwZWMgaGFzIGEgaG9sZSAoemVybykgaW4gaXQsIGBjb250ZW50RE9NYCB3aWxsIHBvaW50IGF0IHRoZVxuICAgIG5vZGUgd2l0aCB0aGUgaG9sZS5cbiAgICAqL1xuICAgIHN0YXRpYyByZW5kZXJTcGVjKGRvYywgc3RydWN0dXJlLCB4bWxOUyA9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJ1Y3R1cmUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiB7IGRvbTogZG9jLmNyZWF0ZVRleHROb2RlKHN0cnVjdHVyZSkgfTtcbiAgICAgICAgaWYgKHN0cnVjdHVyZS5ub2RlVHlwZSAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHsgZG9tOiBzdHJ1Y3R1cmUgfTtcbiAgICAgICAgaWYgKHN0cnVjdHVyZS5kb20gJiYgc3RydWN0dXJlLmRvbS5ub2RlVHlwZSAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdHVyZTtcbiAgICAgICAgbGV0IHRhZ05hbWUgPSBzdHJ1Y3R1cmVbMF0sIHNwYWNlID0gdGFnTmFtZS5pbmRleE9mKFwiIFwiKTtcbiAgICAgICAgaWYgKHNwYWNlID4gMCkge1xuICAgICAgICAgICAgeG1sTlMgPSB0YWdOYW1lLnNsaWNlKDAsIHNwYWNlKTtcbiAgICAgICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnNsaWNlKHNwYWNlICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnRET007XG4gICAgICAgIGxldCBkb20gPSAoeG1sTlMgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHhtbE5TLCB0YWdOYW1lKSA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZ05hbWUpKTtcbiAgICAgICAgbGV0IGF0dHJzID0gc3RydWN0dXJlWzFdLCBzdGFydCA9IDE7XG4gICAgICAgIGlmIChhdHRycyAmJiB0eXBlb2YgYXR0cnMgPT0gXCJvYmplY3RcIiAmJiBhdHRycy5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuICAgICAgICAgICAgc3RhcnQgPSAyO1xuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycylcbiAgICAgICAgICAgICAgICBpZiAoYXR0cnNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2UgPSBuYW1lLmluZGV4T2YoXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BhY2UgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZU5TKG5hbWUuc2xpY2UoMCwgc3BhY2UpLCBuYW1lLnNsaWNlKHNwYWNlICsgMSksIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0cnVjdHVyZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gc3RydWN0dXJlW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBzdHJ1Y3R1cmUubGVuZ3RoIC0gMSB8fCBpID4gc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ29udGVudCBob2xlIG11c3QgYmUgdGhlIG9ubHkgY2hpbGQgb2YgaXRzIHBhcmVudCBub2RlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbSwgY29udGVudERPTTogZG9tIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBkb206IGlubmVyLCBjb250ZW50RE9NOiBpbm5lckNvbnRlbnQgfSA9IERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2MsIGNoaWxkLCB4bWxOUyk7XG4gICAgICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKGlubmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdWx0aXBsZSBjb250ZW50IGhvbGVzXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gaW5uZXJDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb20sIGNvbnRlbnRET00gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBzZXJpYWxpemVyIHVzaW5nIHRoZSBbYHRvRE9NYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnRvRE9NKVxuICAgIHByb3BlcnRpZXMgaW4gYSBzY2hlbWEncyBub2RlIGFuZCBtYXJrIHNwZWNzLlxuICAgICovXG4gICAgc3RhdGljIGZyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgfHxcbiAgICAgICAgICAgIChzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgPSBuZXcgRE9NU2VyaWFsaXplcih0aGlzLm5vZGVzRnJvbVNjaGVtYShzY2hlbWEpLCB0aGlzLm1hcmtzRnJvbVNjaGVtYShzY2hlbWEpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdhdGhlciB0aGUgc2VyaWFsaXplcnMgaW4gYSBzY2hlbWEncyBub2RlIHNwZWNzIGludG8gYW4gb2JqZWN0LlxuICAgIFRoaXMgY2FuIGJlIHVzZWZ1bCBhcyBhIGJhc2UgdG8gYnVpbGQgYSBjdXN0b20gc2VyaWFsaXplciBmcm9tLlxuICAgICovXG4gICAgc3RhdGljIG5vZGVzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGdhdGhlclRvRE9NKHNjaGVtYS5ub2Rlcyk7XG4gICAgICAgIGlmICghcmVzdWx0LnRleHQpXG4gICAgICAgICAgICByZXN1bHQudGV4dCA9IG5vZGUgPT4gbm9kZS50ZXh0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBHYXRoZXIgdGhlIHNlcmlhbGl6ZXJzIGluIGEgc2NoZW1hJ3MgbWFyayBzcGVjcyBpbnRvIGFuIG9iamVjdC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXJrc0Zyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBnYXRoZXJUb0RPTShzY2hlbWEubWFya3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdhdGhlclRvRE9NKG9iaikge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBuYW1lIGluIG9iaikge1xuICAgICAgICBsZXQgdG9ET00gPSBvYmpbbmFtZV0uc3BlYy50b0RPTTtcbiAgICAgICAgaWYgKHRvRE9NKVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gdG9ET007XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBkb2Mob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudDtcbn1cblxuZXhwb3J0IHsgQ29udGVudE1hdGNoLCBET01QYXJzZXIsIERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBNYXJrLCBNYXJrVHlwZSwgTm9kZSwgTm9kZVJhbmdlLCBOb2RlVHlwZSwgUmVwbGFjZUVycm9yLCBSZXNvbHZlZFBvcywgU2NoZW1hLCBTbGljZSB9O1xuIiwgImltcG9ydCB7IFJlcGxhY2VFcnJvciwgU2xpY2UsIEZyYWdtZW50LCBNYXJrVHlwZSwgTWFyayB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcblxuLy8gUmVjb3ZlcnkgdmFsdWVzIGVuY29kZSBhIHJhbmdlIGluZGV4IGFuZCBhbiBvZmZzZXQuIFRoZXkgYXJlXG4vLyByZXByZXNlbnRlZCBhcyBudW1iZXJzLCBiZWNhdXNlIHRvbnMgb2YgdGhlbSB3aWxsIGJlIGNyZWF0ZWQgd2hlblxuLy8gbWFwcGluZywgZm9yIGV4YW1wbGUsIGEgbGFyZ2UgbnVtYmVyIG9mIGRlY29yYXRpb25zLiBUaGUgbnVtYmVyJ3Ncbi8vIGxvd2VyIDE2IGJpdHMgcHJvdmlkZSB0aGUgaW5kZXgsIHRoZSByZW1haW5pbmcgYml0cyB0aGUgb2Zmc2V0LlxuLy9cbi8vIE5vdGU6IFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGJpdCBzaGlmdCBvcGVyYXRvcnMgdG8gZW4tIGFuZFxuLy8gZGVjb2RlIHRoZXNlLCBzaW5jZSB0aG9zZSBjbGlwIHRvIDMyIGJpdHMsIHdoaWNoIHdlIG1pZ2h0IGluIHJhcmVcbi8vIGNhc2VzIHdhbnQgdG8gb3ZlcmZsb3cuIEEgNjQtYml0IGZsb2F0IGNhbiByZXByZXNlbnQgNDgtYml0XG4vLyBpbnRlZ2VycyBwcmVjaXNlbHkuXG5jb25zdCBsb3dlcjE2ID0gMHhmZmZmO1xuY29uc3QgZmFjdG9yMTYgPSBNYXRoLnBvdygyLCAxNik7XG5mdW5jdGlvbiBtYWtlUmVjb3ZlcihpbmRleCwgb2Zmc2V0KSB7IHJldHVybiBpbmRleCArIG9mZnNldCAqIGZhY3RvcjE2OyB9XG5mdW5jdGlvbiByZWNvdmVySW5kZXgodmFsdWUpIHsgcmV0dXJuIHZhbHVlICYgbG93ZXIxNjsgfVxuZnVuY3Rpb24gcmVjb3Zlck9mZnNldCh2YWx1ZSkgeyByZXR1cm4gKHZhbHVlIC0gKHZhbHVlICYgbG93ZXIxNikpIC8gZmFjdG9yMTY7IH1cbmNvbnN0IERFTF9CRUZPUkUgPSAxLCBERUxfQUZURVIgPSAyLCBERUxfQUNST1NTID0gNCwgREVMX1NJREUgPSA4O1xuLyoqXG5BbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgbWFwcGVkIHBvc2l0aW9uIHdpdGggZXh0cmFcbmluZm9ybWF0aW9uLlxuKi9cbmNsYXNzIE1hcFJlc3VsdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbWFwcGVkIHZlcnNpb24gb2YgdGhlIHBvc2l0aW9uLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRlbEluZm8sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3Zlcikge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5kZWxJbmZvID0gZGVsSW5mbztcbiAgICAgICAgdGhpcy5yZWNvdmVyID0gcmVjb3ZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIHBvc2l0aW9uIHdhcyBkZWxldGVkLCB0aGF0IGlzLCB3aGV0aGVyIHRoZVxuICAgIHN0ZXAgcmVtb3ZlZCB0aGUgdG9rZW4gb24gdGhlIHNpZGUgcXVlcmllZCAodmlhIHRoZSBgYXNzb2NgKVxuICAgIGFyZ3VtZW50IGZyb20gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWQoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgREVMX1NJREUpID4gMDsgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoZSB0b2tlbiBiZWZvcmUgdGhlIG1hcHBlZCBwb3NpdGlvbiB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkQmVmb3JlKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIChERUxfQkVGT1JFIHwgREVMX0FDUk9TUykpID4gMDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGUgdG9rZW4gYWZ0ZXIgdGhlIG1hcHBlZCBwb3NpdGlvbiB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkQWZ0ZXIoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgKERFTF9BRlRFUiB8IERFTF9BQ1JPU1MpKSA+IDA7IH1cbiAgICAvKipcbiAgICBUZWxscyB3aGV0aGVyIGFueSBvZiB0aGUgc3RlcHMgbWFwcGVkIHRocm91Z2ggZGVsZXRlcyBhY3Jvc3MgdGhlXG4gICAgcG9zaXRpb24gKGluY2x1ZGluZyBib3RoIHRoZSB0b2tlbiBiZWZvcmUgYW5kIGFmdGVyIHRoZVxuICAgIHBvc2l0aW9uKS5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkQWNyb3NzKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIERFTF9BQ1JPU1MpID4gMDsgfVxufVxuLyoqXG5BIG1hcCBkZXNjcmliaW5nIHRoZSBkZWxldGlvbnMgYW5kIGluc2VydGlvbnMgbWFkZSBieSBhIHN0ZXAsIHdoaWNoXG5jYW4gYmUgdXNlZCB0byBmaW5kIHRoZSBjb3JyZXNwb25kZW5jZSBiZXR3ZWVuIHBvc2l0aW9ucyBpbiB0aGVcbnByZS1zdGVwIHZlcnNpb24gb2YgYSBkb2N1bWVudCBhbmQgdGhlIHNhbWUgcG9zaXRpb24gaW4gdGhlXG5wb3N0LXN0ZXAgdmVyc2lvbi5cbiovXG5jbGFzcyBTdGVwTWFwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwb3NpdGlvbiBtYXAuIFRoZSBtb2RpZmljYXRpb25zIHRvIHRoZSBkb2N1bWVudCBhcmVcbiAgICByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBudW1iZXJzLCBpbiB3aGljaCBlYWNoIGdyb3VwIG9mIHRocmVlXG4gICAgcmVwcmVzZW50cyBhIG1vZGlmaWVkIGNodW5rIGFzIGBbc3RhcnQsIG9sZFNpemUsIG5ld1NpemVdYC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmFuZ2VzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGludmVydGVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuaW52ZXJ0ZWQgPSBpbnZlcnRlZDtcbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoICYmIFN0ZXBNYXAuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gU3RlcE1hcC5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyKHZhbHVlKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgaW5kZXggPSByZWNvdmVySW5kZXgodmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMuaW52ZXJ0ZWQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgZGlmZiArPSB0aGlzLnJhbmdlc1tpICogMyArIDJdIC0gdGhpcy5yYW5nZXNbaSAqIDMgKyAxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzW2luZGV4ICogM10gKyBkaWZmICsgcmVjb3Zlck9mZnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIG1hcFJlc3VsdChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIGZhbHNlKTsgfVxuICAgIG1hcChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBfbWFwKHBvcywgYXNzb2MsIHNpbXBsZSkge1xuICAgICAgICBsZXQgZGlmZiA9IDAsIG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgbmV3U2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF0sIGVuZCA9IHN0YXJ0ICsgb2xkU2l6ZTtcbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNpZGUgPSAhb2xkU2l6ZSA/IGFzc29jIDogcG9zID09IHN0YXJ0ID8gLTEgOiBwb3MgPT0gZW5kID8gMSA6IGFzc29jO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBzdGFydCArIGRpZmYgKyAoc2lkZSA8IDAgPyAwIDogbmV3U2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpbXBsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBsZXQgcmVjb3ZlciA9IHBvcyA9PSAoYXNzb2MgPCAwID8gc3RhcnQgOiBlbmQpID8gbnVsbCA6IG1ha2VSZWNvdmVyKGkgLyAzLCBwb3MgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgbGV0IGRlbCA9IHBvcyA9PSBzdGFydCA/IERFTF9BRlRFUiA6IHBvcyA9PSBlbmQgPyBERUxfQkVGT1JFIDogREVMX0FDUk9TUztcbiAgICAgICAgICAgICAgICBpZiAoYXNzb2MgPCAwID8gcG9zICE9IHN0YXJ0IDogcG9zICE9IGVuZClcbiAgICAgICAgICAgICAgICAgICAgZGVsIHw9IERFTF9TSURFO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFwUmVzdWx0KHJlc3VsdCwgZGVsLCByZWNvdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpZmYgKz0gbmV3U2l6ZSAtIG9sZFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbXBsZSA/IHBvcyArIGRpZmYgOiBuZXcgTWFwUmVzdWx0KHBvcyArIGRpZmYsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvdWNoZXMocG9zLCByZWNvdmVyKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgaW5kZXggPSByZWNvdmVySW5kZXgocmVjb3Zlcik7XG4gICAgICAgIGxldCBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSwgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzW2ldIC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIGVuZCA9IHN0YXJ0ICsgb2xkU2l6ZTtcbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kICYmIGkgPT0gaW5kZXggKiAzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZGlmZiArPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiBvbiBlYWNoIG9mIHRoZSBjaGFuZ2VkIHJhbmdlcyBpbmNsdWRlZCBpblxuICAgIHRoaXMgbWFwLlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIGxldCBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSwgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBkaWZmID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSwgb2xkU3RhcnQgPSBzdGFydCAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApLCBuZXdTdGFydCA9IHN0YXJ0ICsgKHRoaXMuaW52ZXJ0ZWQgPyAwIDogZGlmZik7XG4gICAgICAgICAgICBsZXQgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIG5ld1NpemUgPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdO1xuICAgICAgICAgICAgZihvbGRTdGFydCwgb2xkU3RhcnQgKyBvbGRTaXplLCBuZXdTdGFydCwgbmV3U3RhcnQgKyBuZXdTaXplKTtcbiAgICAgICAgICAgIGRpZmYgKz0gbmV3U2l6ZSAtIG9sZFNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGludmVydGVkIHZlcnNpb24gb2YgdGhpcyBtYXAuIFRoZSByZXN1bHQgY2FuIGJlIHVzZWQgdG9cbiAgICBtYXAgcG9zaXRpb25zIGluIHRoZSBwb3N0LXN0ZXAgZG9jdW1lbnQgdG8gdGhlIHByZS1zdGVwIGRvY3VtZW50LlxuICAgICovXG4gICAgaW52ZXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXBNYXAodGhpcy5yYW5nZXMsICF0aGlzLmludmVydGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmludmVydGVkID8gXCItXCIgOiBcIlwiKSArIEpTT04uc3RyaW5naWZ5KHRoaXMucmFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFwIHRoYXQgbW92ZXMgYWxsIHBvc2l0aW9ucyBieSBvZmZzZXQgYG5gICh3aGljaCBtYXkgYmVcbiAgICBuZWdhdGl2ZSkuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIGFwcGx5aW5nIHN0ZXBzIG1lYW50IGZvciBhXG4gICAgc3ViLWRvY3VtZW50IHRvIGEgbGFyZ2VyIGRvY3VtZW50LCBvciB2aWNlLXZlcnNhLlxuICAgICovXG4gICAgc3RhdGljIG9mZnNldChuKSB7XG4gICAgICAgIHJldHVybiBuID09IDAgPyBTdGVwTWFwLmVtcHR5IDogbmV3IFN0ZXBNYXAobiA8IDAgPyBbMCwgLW4sIDBdIDogWzAsIDAsIG5dKTtcbiAgICB9XG59XG4vKipcbkEgU3RlcE1hcCB0aGF0IGNvbnRhaW5zIG5vIGNoYW5nZWQgcmFuZ2VzLlxuKi9cblN0ZXBNYXAuZW1wdHkgPSBuZXcgU3RlcE1hcChbXSk7XG4vKipcbkEgbWFwcGluZyByZXByZXNlbnRzIGEgcGlwZWxpbmUgb2YgemVybyBvciBtb3JlIFtzdGVwXG5tYXBzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXBNYXApLiBJdCBoYXMgc3BlY2lhbCBwcm92aXNpb25zIGZvciBsb3NzbGVzc2x5XG5oYW5kbGluZyBtYXBwaW5nIHBvc2l0aW9ucyB0aHJvdWdoIGEgc2VyaWVzIG9mIHN0ZXBzIGluIHdoaWNoIHNvbWVcbnN0ZXBzIGFyZSBpbnZlcnRlZCB2ZXJzaW9ucyBvZiBlYXJsaWVyIHN0ZXBzLiAoVGhpcyBjb21lcyB1cCB3aGVuXG5cdTIwMThbcmViYXNpbmddKC9kb2NzL2d1aWRlLyN0cmFuc2Zvcm0ucmViYXNpbmcpXHUyMDE5IHN0ZXBzIGZvclxuY29sbGFib3JhdGlvbiBvciBoaXN0b3J5IG1hbmFnZW1lbnQuKVxuKi9cbmNsYXNzIE1hcHBpbmcge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBtYXBwaW5nIHdpdGggdGhlIGdpdmVuIHBvc2l0aW9uIG1hcHMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RlcCBtYXBzIGluIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIG1hcHMgPSBbXSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtaXJyb3IsIFxuICAgIC8qKlxuICAgIFRoZSBzdGFydGluZyBwb3NpdGlvbiBpbiB0aGUgYG1hcHNgIGFycmF5LCB1c2VkIHdoZW4gYG1hcGAgb3JcbiAgICBgbWFwUmVzdWx0YCBpcyBjYWxsZWQuXG4gICAgKi9cbiAgICBmcm9tID0gMCwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbiBpbiB0aGUgYG1hcHNgIGFycmF5LlxuICAgICovXG4gICAgdG8gPSBtYXBzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm1hcHMgPSBtYXBzO1xuICAgICAgICB0aGlzLm1pcnJvciA9IG1pcnJvcjtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXBwaW5nIHRoYXQgbWFwcyBvbmx5IHRocm91Z2ggYSBwYXJ0IG9mIHRoaXMgb25lLlxuICAgICovXG4gICAgc2xpY2UoZnJvbSA9IDAsIHRvID0gdGhpcy5tYXBzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hcHBpbmcodGhpcy5tYXBzLCB0aGlzLm1pcnJvciwgZnJvbSwgdG8pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwcGluZyh0aGlzLm1hcHMuc2xpY2UoKSwgdGhpcy5taXJyb3IgJiYgdGhpcy5taXJyb3Iuc2xpY2UoKSwgdGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgc3RlcCBtYXAgdG8gdGhlIGVuZCBvZiB0aGlzIG1hcHBpbmcuIElmIGBtaXJyb3JzYCBpc1xuICAgIGdpdmVuLCBpdCBzaG91bGQgYmUgdGhlIGluZGV4IG9mIHRoZSBzdGVwIG1hcCB0aGF0IGlzIHRoZSBtaXJyb3JcbiAgICBpbWFnZSBvZiB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZE1hcChtYXAsIG1pcnJvcnMpIHtcbiAgICAgICAgdGhpcy50byA9IHRoaXMubWFwcy5wdXNoKG1hcCk7XG4gICAgICAgIGlmIChtaXJyb3JzICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNldE1pcnJvcih0aGlzLm1hcHMubGVuZ3RoIC0gMSwgbWlycm9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhbGwgdGhlIHN0ZXAgbWFwcyBpbiBhIGdpdmVuIG1hcHBpbmcgdG8gdGhpcyBvbmUgKHByZXNlcnZpbmdcbiAgICBtaXJyb3JpbmcgaW5mb3JtYXRpb24pLlxuICAgICovXG4gICAgYXBwZW5kTWFwcGluZyhtYXBwaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBzdGFydFNpemUgPSB0aGlzLm1hcHMubGVuZ3RoOyBpIDwgbWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5tYXBzW2ldLCBtaXJyICE9IG51bGwgJiYgbWlyciA8IGkgPyBzdGFydFNpemUgKyBtaXJyIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kcyB0aGUgb2Zmc2V0IG9mIHRoZSBzdGVwIG1hcCB0aGF0IG1pcnJvcnMgdGhlIG1hcCBhdCB0aGVcbiAgICBnaXZlbiBvZmZzZXQsIGluIHRoaXMgbWFwcGluZyAoYXMgcGVyIHRoZSBzZWNvbmQgYXJndW1lbnQgdG9cbiAgICBgYXBwZW5kTWFwYCkuXG4gICAgKi9cbiAgICBnZXRNaXJyb3Iobikge1xuICAgICAgICBpZiAodGhpcy5taXJyb3IpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWlycm9yLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pcnJvcltpXSA9PSBuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5taXJyb3JbaSArIChpICUgMiA/IC0xIDogMSldO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNldE1pcnJvcihuLCBtKSB7XG4gICAgICAgIGlmICghdGhpcy5taXJyb3IpXG4gICAgICAgICAgICB0aGlzLm1pcnJvciA9IFtdO1xuICAgICAgICB0aGlzLm1pcnJvci5wdXNoKG4sIG0pO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgdGhlIGludmVyc2Ugb2YgdGhlIGdpdmVuIG1hcHBpbmcgdG8gdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhcHBlbmRNYXBwaW5nSW52ZXJ0ZWQobWFwcGluZykge1xuICAgICAgICBmb3IgKGxldCBpID0gbWFwcGluZy5tYXBzLmxlbmd0aCAtIDEsIHRvdGFsU2l6ZSA9IHRoaXMubWFwcy5sZW5ndGggKyBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IG1pcnIgPSBtYXBwaW5nLmdldE1pcnJvcihpKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTWFwKG1hcHBpbmcubWFwc1tpXS5pbnZlcnQoKSwgbWlyciAhPSBudWxsICYmIG1pcnIgPiBpID8gdG90YWxTaXplIC0gbWlyciAtIDEgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIGludmVydCgpIHtcbiAgICAgICAgbGV0IGludmVyc2UgPSBuZXcgTWFwcGluZztcbiAgICAgICAgaW52ZXJzZS5hcHBlbmRNYXBwaW5nSW52ZXJ0ZWQodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnZlcnNlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0aHJvdWdoIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIG1hcChwb3MsIGFzc29jID0gMSkge1xuICAgICAgICBpZiAodGhpcy5taXJyb3IpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcm9tOyBpIDwgdGhpcy50bzsgaSsrKVxuICAgICAgICAgICAgcG9zID0gdGhpcy5tYXBzW2ldLm1hcChwb3MsIGFzc29jKTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGEgcG9zaXRpb24gdGhyb3VnaCB0aGlzIG1hcHBpbmcsIHJldHVybmluZyBhIG1hcHBpbmdcbiAgICByZXN1bHQuXG4gICAgKi9cbiAgICBtYXBSZXN1bHQocG9zLCBhc3NvYyA9IDEpIHsgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCBmYWxzZSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIF9tYXAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gICAgICAgIGxldCBkZWxJbmZvID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJvbTsgaSA8IHRoaXMudG87IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcCA9IHRoaXMubWFwc1tpXSwgcmVzdWx0ID0gbWFwLm1hcFJlc3VsdChwb3MsIGFzc29jKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvcnIgPSB0aGlzLmdldE1pcnJvcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoY29yciAhPSBudWxsICYmIGNvcnIgPiBpICYmIGNvcnIgPCB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBjb3JyO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB0aGlzLm1hcHNbY29ycl0ucmVjb3ZlcihyZXN1bHQucmVjb3Zlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbEluZm8gfD0gcmVzdWx0LmRlbEluZm87XG4gICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW1wbGUgPyBwb3MgOiBuZXcgTWFwUmVzdWx0KHBvcywgZGVsSW5mbywgbnVsbCk7XG4gICAgfVxufVxuXG5jb25zdCBzdGVwc0J5SUQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5BIHN0ZXAgb2JqZWN0IHJlcHJlc2VudHMgYW4gYXRvbWljIGNoYW5nZS4gSXQgZ2VuZXJhbGx5IGFwcGxpZXNcbm9ubHkgdG8gdGhlIGRvY3VtZW50IGl0IHdhcyBjcmVhdGVkIGZvciwgc2luY2UgdGhlIHBvc2l0aW9uc1xuc3RvcmVkIGluIGl0IHdpbGwgb25seSBtYWtlIHNlbnNlIGZvciB0aGF0IGRvY3VtZW50LlxuXG5OZXcgc3RlcHMgYXJlIGRlZmluZWQgYnkgY3JlYXRpbmcgY2xhc3NlcyB0aGF0IGV4dGVuZCBgU3RlcGAsXG5vdmVycmlkaW5nIHRoZSBgYXBwbHlgLCBgaW52ZXJ0YCwgYG1hcGAsIGBnZXRNYXBgIGFuZCBgZnJvbUpTT05gXG5tZXRob2RzLCBhbmQgcmVnaXN0ZXJpbmcgeW91ciBjbGFzcyB3aXRoIGEgdW5pcXVlXG5KU09OLXNlcmlhbGl6YXRpb24gaWRlbnRpZmllciB1c2luZ1xuW2BTdGVwLmpzb25JRGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcF5qc29uSUQpLlxuKi9cbmNsYXNzIFN0ZXAge1xuICAgIC8qKlxuICAgIEdldCB0aGUgc3RlcCBtYXAgdGhhdCByZXByZXNlbnRzIHRoZSBjaGFuZ2VzIG1hZGUgYnkgdGhpcyBzdGVwLFxuICAgIGFuZCB3aGljaCBjYW4gYmUgdXNlZCB0byB0cmFuc2Zvcm0gYmV0d2VlbiBwb3NpdGlvbnMgaW4gdGhlIG9sZFxuICAgIGFuZCB0aGUgbmV3IGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0TWFwKCkgeyByZXR1cm4gU3RlcE1hcC5lbXB0eTsgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtZXJnZSB0aGlzIHN0ZXAgd2l0aCBhbm90aGVyIG9uZSwgdG8gYmUgYXBwbGllZCBkaXJlY3RseVxuICAgIGFmdGVyIGl0LiBSZXR1cm5zIHRoZSBtZXJnZWQgc3RlcCB3aGVuIHBvc3NpYmxlLCBudWxsIGlmIHRoZVxuICAgIHN0ZXBzIGNhbid0IGJlIG1lcmdlZC5cbiAgICAqL1xuICAgIG1lcmdlKG90aGVyKSB7IHJldHVybiBudWxsOyB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzdGVwIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFdpbGwgY2FsbFxuICAgIHRocm91Z2ggdG8gdGhlIHN0ZXAgY2xhc3MnIG93biBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8ICFqc29uLnN0ZXBUeXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgdHlwZSA9IHN0ZXBzQnlJRFtqc29uLnN0ZXBUeXBlXTtcbiAgICAgICAgaWYgKCF0eXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE5vIHN0ZXAgdHlwZSAke2pzb24uc3RlcFR5cGV9IGRlZmluZWRgKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuZnJvbUpTT04oc2NoZW1hLCBqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVG8gYmUgYWJsZSB0byBzZXJpYWxpemUgc3RlcHMgdG8gSlNPTiwgZWFjaCBzdGVwIG5lZWRzIGEgc3RyaW5nXG4gICAgSUQgdG8gYXR0YWNoIHRvIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBVc2UgdGhpcyBtZXRob2QgdG9cbiAgICByZWdpc3RlciBhbiBJRCBmb3IgeW91ciBzdGVwIGNsYXNzZXMuIFRyeSB0byBwaWNrIHNvbWV0aGluZ1xuICAgIHRoYXQncyB1bmxpa2VseSB0byBjbGFzaCB3aXRoIHN0ZXBzIGZyb20gb3RoZXIgbW9kdWxlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBqc29uSUQoaWQsIHN0ZXBDbGFzcykge1xuICAgICAgICBpZiAoaWQgaW4gc3RlcHNCeUlEKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEdXBsaWNhdGUgdXNlIG9mIHN0ZXAgSlNPTiBJRCBcIiArIGlkKTtcbiAgICAgICAgc3RlcHNCeUlEW2lkXSA9IHN0ZXBDbGFzcztcbiAgICAgICAgc3RlcENsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgICAgICAgcmV0dXJuIHN0ZXBDbGFzcztcbiAgICB9XG59XG4vKipcblRoZSByZXN1bHQgb2YgW2FwcGx5aW5nXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXAuYXBwbHkpIGEgc3RlcC4gQ29udGFpbnMgZWl0aGVyIGFcbm5ldyBkb2N1bWVudCBvciBhIGZhaWx1cmUgdmFsdWUuXG4qL1xuY2xhc3MgU3RlcFJlc3VsdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHJhbnNmb3JtZWQgZG9jdW1lbnQsIGlmIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBkb2MsIFxuICAgIC8qKlxuICAgIFRoZSBmYWlsdXJlIG1lc3NhZ2UsIGlmIHVuc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIGZhaWxlZCkge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5mYWlsZWQgPSBmYWlsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHN1Y2Nlc3NmdWwgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBzdGF0aWMgb2soZG9jKSB7IHJldHVybiBuZXcgU3RlcFJlc3VsdChkb2MsIG51bGwpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZmFpbGVkIHN0ZXAgcmVzdWx0LlxuICAgICovXG4gICAgc3RhdGljIGZhaWwobWVzc2FnZSkgeyByZXR1cm4gbmV3IFN0ZXBSZXN1bHQobnVsbCwgbWVzc2FnZSk7IH1cbiAgICAvKipcbiAgICBDYWxsIFtgTm9kZS5yZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVwbGFjZSkgd2l0aCB0aGUgZ2l2ZW5cbiAgICBhcmd1bWVudHMuIENyZWF0ZSBhIHN1Y2Nlc3NmdWwgcmVzdWx0IGlmIGl0IHN1Y2NlZWRzLCBhbmQgYVxuICAgIGZhaWxlZCBvbmUgaWYgaXQgdGhyb3dzIGEgYFJlcGxhY2VFcnJvcmAuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbVJlcGxhY2UoZG9jLCBmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0Lm9rKGRvYy5yZXBsYWNlKGZyb20sIHRvLCBzbGljZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJlcGxhY2VFcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKGUubWVzc2FnZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtYXBGcmFnbWVudChmcmFnbWVudCwgZiwgcGFyZW50KSB7XG4gICAgbGV0IG1hcHBlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhZ21lbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZyYWdtZW50LmNoaWxkKGkpO1xuICAgICAgICBpZiAoY2hpbGQuY29udGVudC5zaXplKVxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jb3B5KG1hcEZyYWdtZW50KGNoaWxkLmNvbnRlbnQsIGYsIGNoaWxkKSk7XG4gICAgICAgIGlmIChjaGlsZC5pc0lubGluZSlcbiAgICAgICAgICAgIGNoaWxkID0gZihjaGlsZCwgcGFyZW50LCBpKTtcbiAgICAgICAgbWFwcGVkLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gRnJhZ21lbnQuZnJvbUFycmF5KG1hcHBlZCk7XG59XG4vKipcbkFkZCBhIG1hcmsgdG8gYWxsIGlubGluZSBjb250ZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucy5cbiovXG5jbGFzcyBBZGRNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgbWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgbWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIGFkZC5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG9sZFNsaWNlID0gZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50byksICRmcm9tID0gZG9jLnJlc29sdmUodGhpcy5mcm9tKTtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRmcm9tLm5vZGUoJGZyb20uc2hhcmVkRGVwdGgodGhpcy50bykpO1xuICAgICAgICBsZXQgc2xpY2UgPSBuZXcgU2xpY2UobWFwRnJhZ21lbnQob2xkU2xpY2UuY29udGVudCwgKG5vZGUsIHBhcmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFub2RlLmlzQXRvbSB8fCAhcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUodGhpcy5tYXJrLnR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubWFyayh0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICB9LCBwYXJlbnQpLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgc2xpY2UpO1xuICAgIH1cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQgfHwgZnJvbS5wb3MgPj0gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQWRkTWFya1N0ZXAgJiZcbiAgICAgICAgICAgIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJlxuICAgICAgICAgICAgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoTWF0aC5taW4odGhpcy5mcm9tLCBvdGhlci5mcm9tKSwgTWF0aC5tYXgodGhpcy50bywgb3RoZXIudG8pLCB0aGlzLm1hcmspO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhZGRNYXJrXCIsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQWRkTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYWRkTWFya1wiLCBBZGRNYXJrU3RlcCk7XG4vKipcblJlbW92ZSBhIG1hcmsgZnJvbSBhbGwgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLlxuKi9cbmNsYXNzIFJlbW92ZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyay1yZW1vdmluZyBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSB1bm1hcmtlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHVubWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIHJlbW92ZS5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG9sZFNsaWNlID0gZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShtYXBGcmFnbWVudChvbGRTbGljZS5jb250ZW50LCBub2RlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm1hcmsodGhpcy5tYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICB9LCBkb2MpLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgc2xpY2UpO1xuICAgIH1cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQgfHwgZnJvbS5wb3MgPj0gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgUmVtb3ZlTWFya1N0ZXAgJiZcbiAgICAgICAgICAgIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJlxuICAgICAgICAgICAgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoTWF0aC5taW4odGhpcy5mcm9tLCBvdGhlci5mcm9tKSwgTWF0aC5tYXgodGhpcy50bywgb3RoZXIudG8pLCB0aGlzLm1hcmspO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJyZW1vdmVNYXJrXCIsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVtb3ZlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVtb3ZlTWFya1wiLCBSZW1vdmVNYXJrU3RlcCk7XG4vKipcbkFkZCBhIG1hcmsgdG8gYSBzcGVjaWZpYyBub2RlLlxuKi9cbmNsYXNzIEFkZE5vZGVNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5vZGUgbWFyayBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gYWRkLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IG1hcmsgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUobm9kZS5hdHRycywgbnVsbCwgdGhpcy5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBsZXQgbmV3U2V0ID0gdGhpcy5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpO1xuICAgICAgICAgICAgaWYgKG5ld1NldC5sZW5ndGggPT0gbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5tYXJrc1tpXS5pc0luU2V0KG5ld1NldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgbm9kZS5tYXJrc1tpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBBZGROb2RlTWFya1N0ZXAocG9zLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhZGROb2RlTWFya1wiLCBwb3M6IHRoaXMucG9zLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQWRkTm9kZU1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcChqc29uLnBvcywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImFkZE5vZGVNYXJrXCIsIEFkZE5vZGVNYXJrU3RlcCk7XG4vKipcblJlbW92ZSBhIG1hcmsgZnJvbSBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgUmVtb3ZlTm9kZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyay1yZW1vdmluZyBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gcmVtb3ZlLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IG1hcmsgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUobm9kZS5hdHRycywgbnVsbCwgdGhpcy5tYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlIHx8ICF0aGlzLm1hcmsuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IFJlbW92ZU5vZGVNYXJrU3RlcChwb3MucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcInJlbW92ZU5vZGVNYXJrXCIsIHBvczogdGhpcy5wb3MsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZW1vdmVOb2RlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKGpzb24ucG9zLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVtb3ZlTm9kZU1hcmtcIiwgUmVtb3ZlTm9kZU1hcmtTdGVwKTtcblxuLyoqXG5SZXBsYWNlIGEgcGFydCBvZiB0aGUgZG9jdW1lbnQgd2l0aCBhIHNsaWNlIG9mIG5ldyBjb250ZW50LlxuKi9cbmNsYXNzIFJlcGxhY2VTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgVGhlIGdpdmVuIGBzbGljZWAgc2hvdWxkIGZpdCB0aGUgJ2dhcCcgYmV0d2VlbiBgZnJvbWAgYW5kXG4gICAgYHRvYFx1MjAxNHRoZSBkZXB0aHMgbXVzdCBsaW5lIHVwLCBhbmQgdGhlIHN1cnJvdW5kaW5nIG5vZGVzIG11c3QgYmVcbiAgICBhYmxlIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSBvcGVuIHNpZGVzIG9mIHRoZSBzbGljZS4gV2hlblxuICAgIGBzdHJ1Y3R1cmVgIGlzIHRydWUsIHRoZSBzdGVwIHdpbGwgZmFpbCBpZiB0aGUgY29udGVudCBiZXR3ZWVuXG4gICAgZnJvbSBhbmQgdG8gaXMgbm90IGp1c3QgYSBzZXF1ZW5jZSBvZiBjbG9zaW5nIGFuZCB0aGVuIG9wZW5pbmdcbiAgICB0b2tlbnMgKHRoaXMgaXMgdG8gZ3VhcmQgYWdhaW5zdCByZWJhc2VkIHJlcGxhY2Ugc3RlcHNcbiAgICBvdmVyd3JpdGluZyBzb21ldGhpbmcgdGhleSB3ZXJlbid0IHN1cHBvc2VkIHRvKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgc2xpY2UgdG8gaW5zZXJ0LlxuICAgICovXG4gICAgc2xpY2UsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RydWN0dXJlID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMuc3RydWN0dXJlID0gc3RydWN0dXJlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlICYmIGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvKSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMuc2xpY2UpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcChbdGhpcy5mcm9tLCB0aGlzLnRvIC0gdGhpcy5mcm9tLCB0aGlzLnNsaWNlLnNpemVdKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplLCBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWRBY3Jvc3MgJiYgdG8uZGVsZXRlZEFjcm9zcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20ucG9zLCBNYXRoLm1heChmcm9tLnBvcywgdG8ucG9zKSwgdGhpcy5zbGljZSk7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXApIHx8IG90aGVyLnN0cnVjdHVyZSB8fCB0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplID09IG90aGVyLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlbkVuZCAmJiAhb3RoZXIuc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnNsaWNlLnNpemUgKyBvdGhlci5zbGljZS5zaXplID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKHRoaXMuc2xpY2UuY29udGVudC5hcHBlbmQob3RoZXIuc2xpY2UuY29udGVudCksIHRoaXMuc2xpY2Uub3BlblN0YXJ0LCBvdGhlci5zbGljZS5vcGVuRW5kKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLnRvICsgKG90aGVyLnRvIC0gb3RoZXIuZnJvbSksIHNsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIudG8gPT0gdGhpcy5mcm9tICYmICF0aGlzLnNsaWNlLm9wZW5TdGFydCAmJiAhb3RoZXIuc2xpY2Uub3BlbkVuZCkge1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gdGhpcy5zbGljZS5zaXplICsgb3RoZXIuc2xpY2Uuc2l6ZSA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbGljZShvdGhlci5zbGljZS5jb250ZW50LmFwcGVuZCh0aGlzLnNsaWNlLmNvbnRlbnQpLCBvdGhlci5zbGljZS5vcGVuU3RhcnQsIHRoaXMuc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKG90aGVyLmZyb20sIHRoaXMudG8sIHNsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBqc29uID0geyBzdGVwVHlwZTogXCJyZXBsYWNlXCIsIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICAgICAgaWYgKHRoaXMuc2xpY2Uuc2l6ZSlcbiAgICAgICAgICAgIGpzb24uc2xpY2UgPSB0aGlzLnNsaWNlLnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUpXG4gICAgICAgICAgICBqc29uLnN0cnVjdHVyZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZXBsYWNlU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChqc29uLmZyb20sIGpzb24udG8sIFNsaWNlLmZyb21KU09OKHNjaGVtYSwganNvbi5zbGljZSksICEhanNvbi5zdHJ1Y3R1cmUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVwbGFjZVwiLCBSZXBsYWNlU3RlcCk7XG4vKipcblJlcGxhY2UgYSBwYXJ0IG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgc2xpY2Ugb2YgY29udGVudCwgYnV0XG5wcmVzZXJ2ZSBhIHJhbmdlIG9mIHRoZSByZXBsYWNlZCBjb250ZW50IGJ5IG1vdmluZyBpdCBpbnRvIHRoZVxuc2xpY2UuXG4qL1xuY2xhc3MgUmVwbGFjZUFyb3VuZFN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSByZXBsYWNlLWFyb3VuZCBzdGVwIHdpdGggdGhlIGdpdmVuIHJhbmdlIGFuZCBnYXAuXG4gICAgYGluc2VydGAgc2hvdWxkIGJlIHRoZSBwb2ludCBpbiB0aGUgc2xpY2UgaW50byB3aGljaCB0aGUgY29udGVudFxuICAgIG9mIHRoZSBnYXAgc2hvdWxkIGJlIG1vdmVkLiBgc3RydWN0dXJlYCBoYXMgdGhlIHNhbWUgbWVhbmluZyBhc1xuICAgIGl0IGhhcyBpbiB0aGUgW2BSZXBsYWNlU3RlcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uUmVwbGFjZVN0ZXApIGNsYXNzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiBwcmVzZXJ2ZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBnYXBGcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHByZXNlcnZlZCByYW5nZS5cbiAgICAqL1xuICAgIGdhcFRvLCBcbiAgICAvKipcbiAgICBUaGUgc2xpY2UgdG8gaW5zZXJ0LlxuICAgICovXG4gICAgc2xpY2UsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBpbiB0aGUgc2xpY2Ugd2hlcmUgdGhlIHByZXNlcnZlZCByYW5nZSBzaG91bGQgYmVcbiAgICBpbnNlcnRlZC5cbiAgICAqL1xuICAgIGluc2VydCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdHJ1Y3R1cmUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZ2FwRnJvbSA9IGdhcEZyb207XG4gICAgICAgIHRoaXMuZ2FwVG8gPSBnYXBUbztcbiAgICAgICAgdGhpcy5zbGljZSA9IHNsaWNlO1xuICAgICAgICB0aGlzLmluc2VydCA9IGluc2VydDtcbiAgICAgICAgdGhpcy5zdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUgJiYgKGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLmdhcEZyb20pIHx8XG4gICAgICAgICAgICBjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZ2FwVG8sIHRoaXMudG8pKSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgZ2FwLXJlcGxhY2Ugd291bGQgb3ZlcndyaXRlIGNvbnRlbnRcIik7XG4gICAgICAgIGxldCBnYXAgPSBkb2Muc2xpY2UodGhpcy5nYXBGcm9tLCB0aGlzLmdhcFRvKTtcbiAgICAgICAgaWYgKGdhcC5vcGVuU3RhcnQgfHwgZ2FwLm9wZW5FbmQpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiR2FwIGlzIG5vdCBhIGZsYXQgcmFuZ2VcIik7XG4gICAgICAgIGxldCBpbnNlcnRlZCA9IHRoaXMuc2xpY2UuaW5zZXJ0QXQodGhpcy5pbnNlcnQsIGdhcC5jb250ZW50KTtcbiAgICAgICAgaWYgKCFpbnNlcnRlZClcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJDb250ZW50IGRvZXMgbm90IGZpdCBpbiBnYXBcIik7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKFt0aGlzLmZyb20sIHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5pbnNlcnQsXG4gICAgICAgICAgICB0aGlzLmdhcFRvLCB0aGlzLnRvIC0gdGhpcy5nYXBUbywgdGhpcy5zbGljZS5zaXplIC0gdGhpcy5pbnNlcnRdKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgZ2FwID0gdGhpcy5nYXBUbyAtIHRoaXMuZ2FwRnJvbTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcCh0aGlzLmZyb20sIHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSArIGdhcCwgdGhpcy5mcm9tICsgdGhpcy5pbnNlcnQsIHRoaXMuZnJvbSArIHRoaXMuaW5zZXJ0ICsgZ2FwLCBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKS5yZW1vdmVCZXR3ZWVuKHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5nYXBUbyAtIHRoaXMuZnJvbSksIHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IG1hcHBpbmcubWFwKHRoaXMuZ2FwRnJvbSwgLTEpLCBnYXBUbyA9IG1hcHBpbmcubWFwKHRoaXMuZ2FwVG8sIDEpO1xuICAgICAgICBpZiAoKGZyb20uZGVsZXRlZEFjcm9zcyAmJiB0by5kZWxldGVkQWNyb3NzKSB8fCBnYXBGcm9tIDwgZnJvbS5wb3MgfHwgZ2FwVG8gPiB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcChmcm9tLnBvcywgdG8ucG9zLCBnYXBGcm9tLCBnYXBUbywgdGhpcy5zbGljZSwgdGhpcy5pbnNlcnQsIHRoaXMuc3RydWN0dXJlKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQganNvbiA9IHsgc3RlcFR5cGU6IFwicmVwbGFjZUFyb3VuZFwiLCBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvLFxuICAgICAgICAgICAgZ2FwRnJvbTogdGhpcy5nYXBGcm9tLCBnYXBUbzogdGhpcy5nYXBUbywgaW5zZXJ0OiB0aGlzLmluc2VydCB9O1xuICAgICAgICBpZiAodGhpcy5zbGljZS5zaXplKVxuICAgICAgICAgICAganNvbi5zbGljZSA9IHRoaXMuc2xpY2UudG9KU09OKCk7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIGpzb24uc3RydWN0dXJlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBqc29uLmdhcEZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5nYXBUbyAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmluc2VydCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZXBsYWNlQXJvdW5kU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcChqc29uLmZyb20sIGpzb24udG8sIGpzb24uZ2FwRnJvbSwganNvbi5nYXBUbywgU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwganNvbi5pbnNlcnQsICEhanNvbi5zdHJ1Y3R1cmUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVwbGFjZUFyb3VuZFwiLCBSZXBsYWNlQXJvdW5kU3RlcCk7XG5mdW5jdGlvbiBjb250ZW50QmV0d2Vlbihkb2MsIGZyb20sIHRvKSB7XG4gICAgbGV0ICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSksIGRpc3QgPSB0byAtIGZyb20sIGRlcHRoID0gJGZyb20uZGVwdGg7XG4gICAgd2hpbGUgKGRpc3QgPiAwICYmIGRlcHRoID4gMCAmJiAkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSA9PSAkZnJvbS5ub2RlKGRlcHRoKS5jaGlsZENvdW50KSB7XG4gICAgICAgIGRlcHRoLS07XG4gICAgICAgIGRpc3QtLTtcbiAgICB9XG4gICAgaWYgKGRpc3QgPiAwKSB7XG4gICAgICAgIGxldCBuZXh0ID0gJGZyb20ubm9kZShkZXB0aCkubWF5YmVDaGlsZCgkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSk7XG4gICAgICAgIHdoaWxlIChkaXN0ID4gMCkge1xuICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQuaXNMZWFmKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGRpc3QtLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZE1hcmsodHIsIGZyb20sIHRvLCBtYXJrKSB7XG4gICAgbGV0IHJlbW92ZWQgPSBbXSwgYWRkZWQgPSBbXTtcbiAgICBsZXQgcmVtb3ZpbmcsIGFkZGluZztcbiAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zLCBwYXJlbnQpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbWFya3MgPSBub2RlLm1hcmtzO1xuICAgICAgICBpZiAoIW1hcmsuaXNJblNldChtYXJrcykgJiYgcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUobWFyay50eXBlKSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSwgZW5kID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgbGV0IG5ld1NldCA9IG1hcmsuYWRkVG9TZXQobWFya3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghbWFya3NbaV0uaXNJblNldChuZXdTZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmluZyAmJiByZW1vdmluZy50byA9PSBzdGFydCAmJiByZW1vdmluZy5tYXJrLmVxKG1hcmtzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92aW5nLnRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2gocmVtb3ZpbmcgPSBuZXcgUmVtb3ZlTWFya1N0ZXAoc3RhcnQsIGVuZCwgbWFya3NbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWRkaW5nICYmIGFkZGluZy50byA9PSBzdGFydClcbiAgICAgICAgICAgICAgICBhZGRpbmcudG8gPSBlbmQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYWRkZWQucHVzaChhZGRpbmcgPSBuZXcgQWRkTWFya1N0ZXAoc3RhcnQsIGVuZCwgbWFyaykpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmVtb3ZlZC5mb3JFYWNoKHMgPT4gdHIuc3RlcChzKSk7XG4gICAgYWRkZWQuZm9yRWFjaChzID0+IHRyLnN0ZXAocykpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTWFyayh0ciwgZnJvbSwgdG8sIG1hcmspIHtcbiAgICBsZXQgbWF0Y2hlZCA9IFtdLCBzdGVwID0gMDtcbiAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5pc0lubGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc3RlcCsrO1xuICAgICAgICBsZXQgdG9SZW1vdmUgPSBudWxsO1xuICAgICAgICBpZiAobWFyayBpbnN0YW5jZW9mIE1hcmtUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc2V0ID0gbm9kZS5tYXJrcywgZm91bmQ7XG4gICAgICAgICAgICB3aGlsZSAoZm91bmQgPSBtYXJrLmlzSW5TZXQoc2V0KSkge1xuICAgICAgICAgICAgICAgICh0b1JlbW92ZSB8fCAodG9SZW1vdmUgPSBbXSkpLnB1c2goZm91bmQpO1xuICAgICAgICAgICAgICAgIHNldCA9IGZvdW5kLnJlbW92ZUZyb21TZXQoc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXJrKSB7XG4gICAgICAgICAgICBpZiAobWFyay5pc0luU2V0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgICAgIHRvUmVtb3ZlID0gW21hcmtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9SZW1vdmUgPSBub2RlLm1hcmtzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1JlbW92ZSAmJiB0b1JlbW92ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlID0gdG9SZW1vdmVbaV0sIGZvdW5kO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0Y2hlZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IG1hdGNoZWRbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtLnN0ZXAgPT0gc3RlcCAtIDEgJiYgc3R5bGUuZXEobWF0Y2hlZFtqXS5zdHlsZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IG07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZC50byA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQuc3RlcCA9IHN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLnB1c2goeyBzdHlsZSwgZnJvbTogTWF0aC5tYXgocG9zLCBmcm9tKSwgdG86IGVuZCwgc3RlcCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtYXRjaGVkLmZvckVhY2gobSA9PiB0ci5zdGVwKG5ldyBSZW1vdmVNYXJrU3RlcChtLmZyb20sIG0udG8sIG0uc3R5bGUpKSk7XG59XG5mdW5jdGlvbiBjbGVhckluY29tcGF0aWJsZSh0ciwgcG9zLCBwYXJlbnRUeXBlLCBtYXRjaCA9IHBhcmVudFR5cGUuY29udGVudE1hdGNoKSB7XG4gICAgbGV0IG5vZGUgPSB0ci5kb2Mubm9kZUF0KHBvcyk7XG4gICAgbGV0IHJlcGxTdGVwcyA9IFtdLCBjdXIgPSBwb3MgKyAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5jaGlsZChpKSwgZW5kID0gY3VyICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGxldCBhbGxvd2VkID0gbWF0Y2gubWF0Y2hUeXBlKGNoaWxkLnR5cGUpO1xuICAgICAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgICAgICAgIHJlcGxTdGVwcy5wdXNoKG5ldyBSZXBsYWNlU3RlcChjdXIsIGVuZCwgU2xpY2UuZW1wdHkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoID0gYWxsb3dlZDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGQubWFya3MubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRUeXBlLmFsbG93c01hcmtUeXBlKGNoaWxkLm1hcmtzW2pdLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICB0ci5zdGVwKG5ldyBSZW1vdmVNYXJrU3RlcChjdXIsIGVuZCwgY2hpbGQubWFya3Nbal0pKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5pc1RleHQgJiYgIXBhcmVudFR5cGUuc3BlYy5jb2RlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG0sIG5ld2xpbmUgPSAvXFxyP1xcbnxcXHIvZywgc2xpY2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG0gPSBuZXdsaW5lLmV4ZWMoY2hpbGQudGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzbGljZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20ocGFyZW50VHlwZS5zY2hlbWEudGV4dChcIiBcIiwgcGFyZW50VHlwZS5hbGxvd2VkTWFya3MoY2hpbGQubWFya3MpKSksIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICByZXBsU3RlcHMucHVzaChuZXcgUmVwbGFjZVN0ZXAoY3VyICsgbS5pbmRleCwgY3VyICsgbS5pbmRleCArIG1bMF0ubGVuZ3RoLCBzbGljZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBlbmQ7XG4gICAgfVxuICAgIGlmICghbWF0Y2gudmFsaWRFbmQpIHtcbiAgICAgICAgbGV0IGZpbGwgPSBtYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgdHIucmVwbGFjZShjdXIsIGN1ciwgbmV3IFNsaWNlKGZpbGwsIDAsIDApKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHJlcGxTdGVwcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgdHIuc3RlcChyZXBsU3RlcHNbaV0pO1xufVxuXG5mdW5jdGlvbiBjYW5DdXQobm9kZSwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoc3RhcnQgPT0gMCB8fCBub2RlLmNhblJlcGxhY2Uoc3RhcnQsIG5vZGUuY2hpbGRDb3VudCkpICYmXG4gICAgICAgIChlbmQgPT0gbm9kZS5jaGlsZENvdW50IHx8IG5vZGUuY2FuUmVwbGFjZSgwLCBlbmQpKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSB0YXJnZXQgZGVwdGggdG8gd2hpY2ggdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlXG5jYW4gYmUgbGlmdGVkLiBXaWxsIG5vdCBnbyBhY3Jvc3Ncbltpc29sYXRpbmddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5pc29sYXRpbmcpIHBhcmVudCBub2Rlcy5cbiovXG5mdW5jdGlvbiBsaWZ0VGFyZ2V0KHJhbmdlKSB7XG4gICAgbGV0IHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgICBsZXQgY29udGVudCA9IHBhcmVudC5jb250ZW50LmN1dEJ5SW5kZXgocmFuZ2Uuc3RhcnRJbmRleCwgcmFuZ2UuZW5kSW5kZXgpO1xuICAgIGZvciAobGV0IGRlcHRoID0gcmFuZ2UuZGVwdGg7OyAtLWRlcHRoKSB7XG4gICAgICAgIGxldCBub2RlID0gcmFuZ2UuJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgIGxldCBpbmRleCA9IHJhbmdlLiRmcm9tLmluZGV4KGRlcHRoKSwgZW5kSW5kZXggPSByYW5nZS4kdG8uaW5kZXhBZnRlcihkZXB0aCk7XG4gICAgICAgIGlmIChkZXB0aCA8IHJhbmdlLmRlcHRoICYmIG5vZGUuY2FuUmVwbGFjZShpbmRleCwgZW5kSW5kZXgsIGNvbnRlbnQpKVxuICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCB8fCBub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgIWNhbkN1dChub2RlLCBpbmRleCwgZW5kSW5kZXgpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbGlmdCh0ciwgcmFuZ2UsIHRhcmdldCkge1xuICAgIGxldCB7ICRmcm9tLCAkdG8sIGRlcHRoIH0gPSByYW5nZTtcbiAgICBsZXQgZ2FwU3RhcnQgPSAkZnJvbS5iZWZvcmUoZGVwdGggKyAxKSwgZ2FwRW5kID0gJHRvLmFmdGVyKGRlcHRoICsgMSk7XG4gICAgbGV0IHN0YXJ0ID0gZ2FwU3RhcnQsIGVuZCA9IGdhcEVuZDtcbiAgICBsZXQgYmVmb3JlID0gRnJhZ21lbnQuZW1wdHksIG9wZW5TdGFydCA9IDA7XG4gICAgZm9yIChsZXQgZCA9IGRlcHRoLCBzcGxpdHRpbmcgPSBmYWxzZTsgZCA+IHRhcmdldDsgZC0tKVxuICAgICAgICBpZiAoc3BsaXR0aW5nIHx8ICRmcm9tLmluZGV4KGQpID4gMCkge1xuICAgICAgICAgICAgc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGJlZm9yZSA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KGJlZm9yZSkpO1xuICAgICAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydC0tO1xuICAgICAgICB9XG4gICAgbGV0IGFmdGVyID0gRnJhZ21lbnQuZW1wdHksIG9wZW5FbmQgPSAwO1xuICAgIGZvciAobGV0IGQgPSBkZXB0aCwgc3BsaXR0aW5nID0gZmFsc2U7IGQgPiB0YXJnZXQ7IGQtLSlcbiAgICAgICAgaWYgKHNwbGl0dGluZyB8fCAkdG8uYWZ0ZXIoZCArIDEpIDwgJHRvLmVuZChkKSkge1xuICAgICAgICAgICAgc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGFmdGVyID0gRnJhZ21lbnQuZnJvbSgkdG8ubm9kZShkKS5jb3B5KGFmdGVyKSk7XG4gICAgICAgICAgICBvcGVuRW5kKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0LCBlbmQsIGdhcFN0YXJ0LCBnYXBFbmQsIG5ldyBTbGljZShiZWZvcmUuYXBwZW5kKGFmdGVyKSwgb3BlblN0YXJ0LCBvcGVuRW5kKSwgYmVmb3JlLnNpemUgLSBvcGVuU3RhcnQsIHRydWUpKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSB2YWxpZCB3YXkgdG8gd3JhcCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2UgaW4gYVxubm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZS4gTWF5IGludHJvZHVjZSBleHRyYSBub2RlcyBhcm91bmQgYW5kIGluc2lkZVxudGhlIHdyYXBwZXIgbm9kZSwgaWYgbmVjZXNzYXJ5LiBSZXR1cm5zIG51bGwgaWYgbm8gdmFsaWQgd3JhcHBpbmdcbmNvdWxkIGJlIGZvdW5kLiBXaGVuIGBpbm5lclJhbmdlYCBpcyBnaXZlbiwgdGhhdCByYW5nZSdzIGNvbnRlbnQgaXNcbnVzZWQgYXMgdGhlIGNvbnRlbnQgdG8gZml0IGludG8gdGhlIHdyYXBwaW5nLCBpbnN0ZWFkIG9mIHRoZVxuY29udGVudCBvZiBgcmFuZ2VgLlxuKi9cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzID0gbnVsbCwgaW5uZXJSYW5nZSA9IHJhbmdlKSB7XG4gICAgbGV0IGFyb3VuZCA9IGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIG5vZGVUeXBlKTtcbiAgICBsZXQgaW5uZXIgPSBhcm91bmQgJiYgZmluZFdyYXBwaW5nSW5zaWRlKGlubmVyUmFuZ2UsIG5vZGVUeXBlKTtcbiAgICBpZiAoIWlubmVyKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gYXJvdW5kLm1hcCh3aXRoQXR0cnMpXG4gICAgICAgIC5jb25jYXQoeyB0eXBlOiBub2RlVHlwZSwgYXR0cnMgfSkuY29uY2F0KGlubmVyLm1hcCh3aXRoQXR0cnMpKTtcbn1cbmZ1bmN0aW9uIHdpdGhBdHRycyh0eXBlKSB7IHJldHVybiB7IHR5cGUsIGF0dHJzOiBudWxsIH07IH1cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIHR5cGUpIHtcbiAgICBsZXQgeyBwYXJlbnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSByYW5nZTtcbiAgICBsZXQgYXJvdW5kID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KHN0YXJ0SW5kZXgpLmZpbmRXcmFwcGluZyh0eXBlKTtcbiAgICBpZiAoIWFyb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG91dGVyID0gYXJvdW5kLmxlbmd0aCA/IGFyb3VuZFswXSA6IHR5cGU7XG4gICAgcmV0dXJuIHBhcmVudC5jYW5SZXBsYWNlV2l0aChzdGFydEluZGV4LCBlbmRJbmRleCwgb3V0ZXIpID8gYXJvdW5kIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ0luc2lkZShyYW5nZSwgdHlwZSkge1xuICAgIGxldCB7IHBhcmVudCwgc3RhcnRJbmRleCwgZW5kSW5kZXggfSA9IHJhbmdlO1xuICAgIGxldCBpbm5lciA9IHBhcmVudC5jaGlsZChzdGFydEluZGV4KTtcbiAgICBsZXQgaW5zaWRlID0gdHlwZS5jb250ZW50TWF0Y2guZmluZFdyYXBwaW5nKGlubmVyLnR5cGUpO1xuICAgIGlmICghaW5zaWRlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbGFzdFR5cGUgPSBpbnNpZGUubGVuZ3RoID8gaW5zaWRlW2luc2lkZS5sZW5ndGggLSAxXSA6IHR5cGU7XG4gICAgbGV0IGlubmVyTWF0Y2ggPSBsYXN0VHlwZS5jb250ZW50TWF0Y2g7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGlubmVyTWF0Y2ggJiYgaSA8IGVuZEluZGV4OyBpKyspXG4gICAgICAgIGlubmVyTWF0Y2ggPSBpbm5lck1hdGNoLm1hdGNoVHlwZShwYXJlbnQuY2hpbGQoaSkudHlwZSk7XG4gICAgaWYgKCFpbm5lck1hdGNoIHx8ICFpbm5lck1hdGNoLnZhbGlkRW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gaW5zaWRlO1xufVxuZnVuY3Rpb24gd3JhcCh0ciwgcmFuZ2UsIHdyYXBwZXJzKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gd3JhcHBlcnNbaV0udHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgICAgICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoLnZhbGlkRW5kKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV3JhcHBlciB0eXBlIGdpdmVuIHRvIFRyYW5zZm9ybS53cmFwIGRvZXMgbm90IGZvcm0gdmFsaWQgY29udGVudCBvZiBpdHMgcGFyZW50IHdyYXBwZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20od3JhcHBlcnNbaV0udHlwZS5jcmVhdGUod3JhcHBlcnNbaV0uYXR0cnMsIGNvbnRlbnQpKTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ID0gcmFuZ2Uuc3RhcnQsIGVuZCA9IHJhbmdlLmVuZDtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCwgZW5kLCBzdGFydCwgZW5kLCBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xufVxuZnVuY3Rpb24gc2V0QmxvY2tUeXBlKHRyLCBmcm9tLCB0bywgdHlwZSwgYXR0cnMpIHtcbiAgICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHlwZSBnaXZlbiB0byBzZXRCbG9ja1R5cGUgc2hvdWxkIGJlIGEgdGV4dGJsb2NrXCIpO1xuICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0YmxvY2sgJiYgIW5vZGUuaGFzTWFya3VwKHR5cGUsIGF0dHJzKSAmJiBjYW5DaGFuZ2VUeXBlKHRyLmRvYywgdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zKSwgdHlwZSkpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBhbGwgbWFya3VwIHRoYXQgaXNuJ3QgYWxsb3dlZCBpbiB0aGUgbmV3IG5vZGUgdHlwZSBpcyBjbGVhcmVkXG4gICAgICAgICAgICB0ci5jbGVhckluY29tcGF0aWJsZSh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MsIDEpLCB0eXBlKTtcbiAgICAgICAgICAgIGxldCBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICAgICAgICAgIGxldCBzdGFydE0gPSBtYXBwaW5nLm1hcChwb3MsIDEpLCBlbmRNID0gbWFwcGluZy5tYXAocG9zICsgbm9kZS5ub2RlU2l6ZSwgMSk7XG4gICAgICAgICAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydE0sIGVuZE0sIHN0YXJ0TSArIDEsIGVuZE0gLSAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbm9kZS5tYXJrcykpLCAwLCAwKSwgMSwgdHJ1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjYW5DaGFuZ2VUeXBlKGRvYywgcG9zLCB0eXBlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICByZXR1cm4gJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4ICsgMSwgdHlwZSk7XG59XG4vKipcbkNoYW5nZSB0aGUgdHlwZSwgYXR0cmlidXRlcywgYW5kL29yIG1hcmtzIG9mIHRoZSBub2RlIGF0IGBwb3NgLlxuV2hlbiBgdHlwZWAgaXNuJ3QgZ2l2ZW4sIHRoZSBleGlzdGluZyBub2RlIHR5cGUgaXMgcHJlc2VydmVkLFxuKi9cbmZ1bmN0aW9uIHNldE5vZGVNYXJrdXAodHIsIHBvcywgdHlwZSwgYXR0cnMsIG1hcmtzKSB7XG4gICAgbGV0IG5vZGUgPSB0ci5kb2Mubm9kZUF0KHBvcyk7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYXQgZ2l2ZW4gcG9zaXRpb25cIik7XG4gICAgaWYgKCF0eXBlKVxuICAgICAgICB0eXBlID0gbm9kZS50eXBlO1xuICAgIGxldCBuZXdOb2RlID0gdHlwZS5jcmVhdGUoYXR0cnMsIG51bGwsIG1hcmtzIHx8IG5vZGUubWFya3MpO1xuICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgcmV0dXJuIHRyLnJlcGxhY2VXaXRoKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgbmV3Tm9kZSk7XG4gICAgaWYgKCF0eXBlLnZhbGlkQ29udGVudChub2RlLmNvbnRlbnQpKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY29udGVudCBmb3Igbm9kZSB0eXBlIFwiICsgdHlwZS5uYW1lKTtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIHBvcyArIDEsIHBvcyArIG5vZGUubm9kZVNpemUgLSAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShuZXdOb2RlKSwgMCwgMCksIDEsIHRydWUpKTtcbn1cbi8qKlxuQ2hlY2sgd2hldGhlciBzcGxpdHRpbmcgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIGFsbG93ZWQuXG4qL1xuZnVuY3Rpb24gY2FuU3BsaXQoZG9jLCBwb3MsIGRlcHRoID0gMSwgdHlwZXNBZnRlcikge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgYmFzZSA9ICRwb3MuZGVwdGggLSBkZXB0aDtcbiAgICBsZXQgaW5uZXJUeXBlID0gKHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlclt0eXBlc0FmdGVyLmxlbmd0aCAtIDFdKSB8fCAkcG9zLnBhcmVudDtcbiAgICBpZiAoYmFzZSA8IDAgfHwgJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZyB8fFxuICAgICAgICAhJHBvcy5wYXJlbnQuY2FuUmVwbGFjZSgkcG9zLmluZGV4KCksICRwb3MucGFyZW50LmNoaWxkQ291bnQpIHx8XG4gICAgICAgICFpbm5lclR5cGUudHlwZS52YWxpZENvbnRlbnQoJHBvcy5wYXJlbnQuY29udGVudC5jdXRCeUluZGV4KCRwb3MuaW5kZXgoKSwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxLCBpID0gZGVwdGggLSAyOyBkID4gYmFzZTsgZC0tLCBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSAkcG9zLm5vZGUoZCksIGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICAgICAgaWYgKG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHJlc3QgPSBub2RlLmNvbnRlbnQuY3V0QnlJbmRleChpbmRleCwgbm9kZS5jaGlsZENvdW50KTtcbiAgICAgICAgbGV0IG92ZXJyaWRlQ2hpbGQgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaSArIDFdO1xuICAgICAgICBpZiAob3ZlcnJpZGVDaGlsZClcbiAgICAgICAgICAgIHJlc3QgPSByZXN0LnJlcGxhY2VDaGlsZCgwLCBvdmVycmlkZUNoaWxkLnR5cGUuY3JlYXRlKG92ZXJyaWRlQ2hpbGQuYXR0cnMpKTtcbiAgICAgICAgbGV0IGFmdGVyID0gKHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpXSkgfHwgbm9kZTtcbiAgICAgICAgaWYgKCFub2RlLmNhblJlcGxhY2UoaW5kZXggKyAxLCBub2RlLmNoaWxkQ291bnQpIHx8ICFhZnRlci50eXBlLnZhbGlkQ29udGVudChyZXN0KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGJhc2UpO1xuICAgIGxldCBiYXNlVHlwZSA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlclswXTtcbiAgICByZXR1cm4gJHBvcy5ub2RlKGJhc2UpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgYmFzZVR5cGUgPyBiYXNlVHlwZS50eXBlIDogJHBvcy5ub2RlKGJhc2UgKyAxKS50eXBlKTtcbn1cbmZ1bmN0aW9uIHNwbGl0KHRyLCBwb3MsIGRlcHRoID0gMSwgdHlwZXNBZnRlcikge1xuICAgIGxldCAkcG9zID0gdHIuZG9jLnJlc29sdmUocG9zKSwgYmVmb3JlID0gRnJhZ21lbnQuZW1wdHksIGFmdGVyID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGgsIGUgPSAkcG9zLmRlcHRoIC0gZGVwdGgsIGkgPSBkZXB0aCAtIDE7IGQgPiBlOyBkLS0sIGktLSkge1xuICAgICAgICBiZWZvcmUgPSBGcmFnbWVudC5mcm9tKCRwb3Mubm9kZShkKS5jb3B5KGJlZm9yZSkpO1xuICAgICAgICBsZXQgdHlwZUFmdGVyID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldO1xuICAgICAgICBhZnRlciA9IEZyYWdtZW50LmZyb20odHlwZUFmdGVyID8gdHlwZUFmdGVyLnR5cGUuY3JlYXRlKHR5cGVBZnRlci5hdHRycywgYWZ0ZXIpIDogJHBvcy5ub2RlKGQpLmNvcHkoYWZ0ZXIpKTtcbiAgICB9XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAocG9zLCBwb3MsIG5ldyBTbGljZShiZWZvcmUuYXBwZW5kKGFmdGVyKSwgZGVwdGgsIGRlcHRoKSwgdHJ1ZSkpO1xufVxuLyoqXG5UZXN0IHdoZXRoZXIgdGhlIGJsb2NrcyBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gcG9zaXRpb24gY2FuIGJlXG5qb2luZWQuXG4qL1xuZnVuY3Rpb24gY2FuSm9pbihkb2MsIHBvcykge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgcmV0dXJuIGpvaW5hYmxlKCRwb3Mubm9kZUJlZm9yZSwgJHBvcy5ub2RlQWZ0ZXIpICYmXG4gICAgICAgICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSk7XG59XG5mdW5jdGlvbiBqb2luYWJsZShhLCBiKSB7XG4gICAgcmV0dXJuICEhKGEgJiYgYiAmJiAhYS5pc0xlYWYgJiYgYS5jYW5BcHBlbmQoYikpO1xufVxuLyoqXG5GaW5kIGFuIGFuY2VzdG9yIG9mIHRoZSBnaXZlbiBwb3NpdGlvbiB0aGF0IGNhbiBiZSBqb2luZWQgdG8gdGhlXG5ibG9jayBiZWZvcmUgKG9yIGFmdGVyIGlmIGBkaXJgIGlzIHBvc2l0aXZlKS4gUmV0dXJucyB0aGUgam9pbmFibGVcbnBvaW50LCBpZiBhbnkuXG4qL1xuZnVuY3Rpb24gam9pblBvaW50KGRvYywgcG9zLCBkaXIgPSAtMSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDs7IGQtLSkge1xuICAgICAgICBsZXQgYmVmb3JlLCBhZnRlciwgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgICBpZiAoZCA9PSAkcG9zLmRlcHRoKSB7XG4gICAgICAgICAgICBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZShkICsgMSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGUoZCkubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiZWZvcmUgPSAkcG9zLm5vZGUoZCkubWF5YmVDaGlsZChpbmRleCAtIDEpO1xuICAgICAgICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGUoZCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWZvcmUgJiYgIWJlZm9yZS5pc1RleHRibG9jayAmJiBqb2luYWJsZShiZWZvcmUsIGFmdGVyKSAmJlxuICAgICAgICAgICAgJHBvcy5ub2RlKGQpLmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSkpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICBpZiAoZCA9PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBvcyA9IGRpciA8IDAgPyAkcG9zLmJlZm9yZShkKSA6ICRwb3MuYWZ0ZXIoZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gam9pbih0ciwgcG9zLCBkZXB0aCkge1xuICAgIGxldCBzdGVwID0gbmV3IFJlcGxhY2VTdGVwKHBvcyAtIGRlcHRoLCBwb3MgKyBkZXB0aCwgU2xpY2UuZW1wdHksIHRydWUpO1xuICAgIHRyLnN0ZXAoc3RlcCk7XG59XG4vKipcblRyeSB0byBmaW5kIGEgcG9pbnQgd2hlcmUgYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIGNhbiBiZSBpbnNlcnRlZFxubmVhciBgcG9zYCwgYnkgc2VhcmNoaW5nIHVwIHRoZSBub2RlIGhpZXJhcmNoeSB3aGVuIGBwb3NgIGl0c2VsZlxuaXNuJ3QgYSB2YWxpZCBwbGFjZSBidXQgaXMgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIG5vZGUuIFJldHVyblxubnVsbCBpZiBubyBwb3NpdGlvbiB3YXMgZm91bmQuXG4qL1xuZnVuY3Rpb24gaW5zZXJ0UG9pbnQoZG9jLCBwb3MsIG5vZGVUeXBlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICgkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aCgkcG9zLmluZGV4KCksICRwb3MuaW5kZXgoKSwgbm9kZVR5cGUpKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PSAwKVxuICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShkKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIG5vZGVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5iZWZvcmUoZCArIDEpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PSAkcG9zLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXhBZnRlcihkKTtcbiAgICAgICAgICAgIGlmICgkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBub2RlVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuYWZ0ZXIoZCArIDEpO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgJHBvcy5ub2RlKGQpLmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuRmluZHMgYSBwb3NpdGlvbiBhdCBvciBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uIHdoZXJlIHRoZSBnaXZlblxuc2xpY2UgY2FuIGJlIGluc2VydGVkLiBXaWxsIGxvb2sgYXQgcGFyZW50IG5vZGVzJyBuZWFyZXN0IGJvdW5kYXJ5XG5hbmQgdHJ5IHRoZXJlLCBldmVuIGlmIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiB3YXNuJ3QgZGlyZWN0bHkgYXQgdGhlXG5zdGFydCBvciBlbmQgb2YgdGhhdCBub2RlLiBSZXR1cm5zIG51bGwgd2hlbiBubyBwb3NpdGlvbiB3YXMgZm91bmQuXG4qL1xuZnVuY3Rpb24gZHJvcFBvaW50KGRvYywgcG9zLCBzbGljZSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoIXNsaWNlLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBsZXQgY29udGVudCA9IHNsaWNlLmNvbnRlbnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGljZS5vcGVuU3RhcnQ7IGkrKylcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgIGZvciAobGV0IHBhc3MgPSAxOyBwYXNzIDw9IChzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5zaXplID8gMiA6IDEpOyBwYXNzKyspIHtcbiAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBsZXQgYmlhcyA9IGQgPT0gJHBvcy5kZXB0aCA/IDAgOiAkcG9zLnBvcyA8PSAoJHBvcy5zdGFydChkICsgMSkgKyAkcG9zLmVuZChkICsgMSkpIC8gMiA/IC0xIDogMTtcbiAgICAgICAgICAgIGxldCBpbnNlcnRQb3MgPSAkcG9zLmluZGV4KGQpICsgKGJpYXMgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRwb3Mubm9kZShkKSwgZml0cyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHBhc3MgPT0gMSkge1xuICAgICAgICAgICAgICAgIGZpdHMgPSBwYXJlbnQuY2FuUmVwbGFjZShpbnNlcnRQb3MsIGluc2VydFBvcywgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcHBpbmcgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoaW5zZXJ0UG9zKS5maW5kV3JhcHBpbmcoY29udGVudC5maXJzdENoaWxkLnR5cGUpO1xuICAgICAgICAgICAgICAgIGZpdHMgPSB3cmFwcGluZyAmJiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5zZXJ0UG9zLCBpbnNlcnRQb3MsIHdyYXBwaW5nWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXRzKVxuICAgICAgICAgICAgICAgIHJldHVybiBiaWFzID09IDAgPyAkcG9zLnBvcyA6IGJpYXMgPCAwID8gJHBvcy5iZWZvcmUoZCArIDEpIDogJHBvcy5hZnRlcihkICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuXHUyMDE4Rml0XHUyMDE5IGEgc2xpY2UgaW50byBhIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCwgcHJvZHVjaW5nIGFcbltzdGVwXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXApIHRoYXQgaW5zZXJ0cyBpdC4gV2lsbCByZXR1cm4gbnVsbCBpZlxudGhlcmUncyBubyBtZWFuaW5nZnVsIHdheSB0byBpbnNlcnQgdGhlIHNsaWNlIGhlcmUsIG9yIGluc2VydGluZyBpdFxud291bGQgYmUgYSBuby1vcCAoYW4gZW1wdHkgc2xpY2Ugb3ZlciBhbiBlbXB0eSByYW5nZSkuXG4qL1xuZnVuY3Rpb24gcmVwbGFjZVN0ZXAoZG9jLCBmcm9tLCB0byA9IGZyb20sIHNsaWNlID0gU2xpY2UuZW1wdHkpIHtcbiAgICBpZiAoZnJvbSA9PSB0byAmJiAhc2xpY2Uuc2l6ZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0ICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSksICR0byA9IGRvYy5yZXNvbHZlKHRvKTtcbiAgICAvLyBPcHRpbWl6YXRpb24gLS0gYXZvaWQgd29yayBpZiBpdCdzIG9idmlvdXMgdGhhdCBpdCdzIG5vdCBuZWVkZWQuXG4gICAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKVxuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSk7XG4gICAgcmV0dXJuIG5ldyBGaXR0ZXIoJGZyb20sICR0bywgc2xpY2UpLmZpdCgpO1xufVxuZnVuY3Rpb24gZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkge1xuICAgIHJldHVybiAhc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLnN0YXJ0KCkgPT0gJHRvLnN0YXJ0KCkgJiZcbiAgICAgICAgJGZyb20ucGFyZW50LmNhblJlcGxhY2UoJGZyb20uaW5kZXgoKSwgJHRvLmluZGV4KCksIHNsaWNlLmNvbnRlbnQpO1xufVxuLy8gQWxnb3JpdGhtIGZvciAncGxhY2luZycgdGhlIGVsZW1lbnRzIG9mIGEgc2xpY2UgaW50byBhIGdhcDpcbi8vXG4vLyBXZSBjb25zaWRlciB0aGUgY29udGVudCBvZiBlYWNoIG5vZGUgdGhhdCBpcyBvcGVuIHRvIHRoZSBsZWZ0IHRvIGJlXG4vLyBpbmRlcGVuZGVudGx5IHBsYWNlYWJsZS4gSS5lLiBpbiA8cChcImZvb1wiKSwgcChcImJhclwiKT4sIHdoZW4gdGhlXG4vLyBwYXJhZ3JhcGggb24gdGhlIGxlZnQgaXMgb3BlbiwgXCJmb29cIiBjYW4gYmUgcGxhY2VkIChzb21ld2hlcmUgb25cbi8vIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHJlcGxhY2VtZW50IGdhcCkgaW5kZXBlbmRlbnRseSBmcm9tIHAoXCJiYXJcIikuXG4vL1xuLy8gVGhpcyBjbGFzcyB0cmFja3MgdGhlIHN0YXRlIG9mIHRoZSBwbGFjZW1lbnQgcHJvZ3Jlc3MgaW4gdGhlXG4vLyBmb2xsb3dpbmcgcHJvcGVydGllczpcbi8vXG4vLyAgLSBgZnJvbnRpZXJgIGhvbGRzIGEgc3RhY2sgb2YgYHt0eXBlLCBtYXRjaH1gIG9iamVjdHMgdGhhdFxuLy8gICAgcmVwcmVzZW50IHRoZSBvcGVuIHNpZGUgb2YgdGhlIHJlcGxhY2VtZW50LiBJdCBzdGFydHMgYXRcbi8vICAgIGAkZnJvbWAsIHRoZW4gbW92ZXMgZm9yd2FyZCBhcyBjb250ZW50IGlzIHBsYWNlZCwgYW5kIGlzIGZpbmFsbHlcbi8vICAgIHJlY29uY2lsZWQgd2l0aCBgJHRvYC5cbi8vXG4vLyAgLSBgdW5wbGFjZWRgIGlzIGEgc2xpY2UgdGhhdCByZXByZXNlbnRzIHRoZSBjb250ZW50IHRoYXQgaGFzbid0XG4vLyAgICBiZWVuIHBsYWNlZCB5ZXQuXG4vL1xuLy8gIC0gYHBsYWNlZGAgaXMgYSBmcmFnbWVudCBvZiBwbGFjZWQgY29udGVudC4gSXRzIG9wZW4tc3RhcnQgdmFsdWVcbi8vICAgIGlzIGltcGxpY2l0IGluIGAkZnJvbWAsIGFuZCBpdHMgb3Blbi1lbmQgdmFsdWUgaW4gYGZyb250aWVyYC5cbmNsYXNzIEZpdHRlciB7XG4gICAgY29uc3RydWN0b3IoJGZyb20sICR0bywgdW5wbGFjZWQpIHtcbiAgICAgICAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICAgICAgICB0aGlzLiR0byA9ICR0bztcbiAgICAgICAgdGhpcy51bnBsYWNlZCA9IHVucGxhY2VkO1xuICAgICAgICB0aGlzLmZyb250aWVyID0gW107XG4gICAgICAgIHRoaXMucGxhY2VkID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9ICRmcm9tLmRlcHRoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gJGZyb20ubm9kZShpKTtcbiAgICAgICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIG1hdGNoOiBub2RlLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoaSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gJGZyb20uZGVwdGg7IGkgPiAwOyBpLS0pXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShpKS5jb3B5KHRoaXMucGxhY2VkKSk7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHsgcmV0dXJuIHRoaXMuZnJvbnRpZXIubGVuZ3RoIC0gMTsgfVxuICAgIGZpdCgpIHtcbiAgICAgICAgLy8gQXMgbG9uZyBhcyB0aGVyZSdzIHVucGxhY2VkIGNvbnRlbnQsIHRyeSB0byBwbGFjZSBzb21lIG9mIGl0LlxuICAgICAgICAvLyBJZiB0aGF0IGZhaWxzLCBlaXRoZXIgaW5jcmVhc2UgdGhlIG9wZW4gc2NvcmUgb2YgdGhlIHVucGxhY2VkXG4gICAgICAgIC8vIHNsaWNlLCBvciBkcm9wIG5vZGVzIGZyb20gaXQsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICAgICAgd2hpbGUgKHRoaXMudW5wbGFjZWQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGZpdCA9IHRoaXMuZmluZEZpdHRhYmxlKCk7XG4gICAgICAgICAgICBpZiAoZml0KVxuICAgICAgICAgICAgICAgIHRoaXMucGxhY2VOb2RlcyhmaXQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMub3Blbk1vcmUoKSB8fCB0aGlzLmRyb3BOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGVyZSdzIGlubGluZSBjb250ZW50IGRpcmVjdGx5IGFmdGVyIHRoZSBmcm9udGllciBfYW5kX1xuICAgICAgICAvLyBkaXJlY3RseSBhZnRlciBgdGhpcy4kdG9gLCB3ZSBtdXN0IGdlbmVyYXRlIGEgYFJlcGxhY2VBcm91bmRgXG4gICAgICAgIC8vIHN0ZXAgdGhhdCBwdWxscyB0aGF0IGNvbnRlbnQgaW50byB0aGUgbm9kZSBhZnRlciB0aGUgZnJvbnRpZXIuXG4gICAgICAgIC8vIFRoYXQgbWVhbnMgdGhlIGZpdHRpbmcgbXVzdCBiZSBkb25lIHRvIHRoZSBlbmQgb2YgdGhlIHRleHRibG9ja1xuICAgICAgICAvLyBub2RlIGFmdGVyIGB0aGlzLiR0b2AsIG5vdCBgdGhpcy4kdG9gIGl0c2VsZi5cbiAgICAgICAgbGV0IG1vdmVJbmxpbmUgPSB0aGlzLm11c3RNb3ZlSW5saW5lKCksIHBsYWNlZFNpemUgPSB0aGlzLnBsYWNlZC5zaXplIC0gdGhpcy5kZXB0aCAtIHRoaXMuJGZyb20uZGVwdGg7XG4gICAgICAgIGxldCAkZnJvbSA9IHRoaXMuJGZyb20sICR0byA9IHRoaXMuY2xvc2UobW92ZUlubGluZSA8IDAgPyB0aGlzLiR0byA6ICRmcm9tLmRvYy5yZXNvbHZlKG1vdmVJbmxpbmUpKTtcbiAgICAgICAgaWYgKCEkdG8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gSWYgY2xvc2luZyB0byBgJHRvYCBzdWNjZWVkZWQsIGNyZWF0ZSBhIHN0ZXBcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLnBsYWNlZCwgb3BlblN0YXJ0ID0gJGZyb20uZGVwdGgsIG9wZW5FbmQgPSAkdG8uZGVwdGg7XG4gICAgICAgIHdoaWxlIChvcGVuU3RhcnQgJiYgb3BlbkVuZCAmJiBjb250ZW50LmNoaWxkQ291bnQgPT0gMSkgeyAvLyBOb3JtYWxpemUgYnkgZHJvcHBpbmcgb3BlbiBwYXJlbnQgbm9kZXNcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICAgICAgICAgIG9wZW5TdGFydC0tO1xuICAgICAgICAgICAgb3BlbkVuZC0tO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICBpZiAobW92ZUlubGluZSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkZnJvbS5wb3MsIG1vdmVJbmxpbmUsIHRoaXMuJHRvLnBvcywgdGhpcy4kdG8uZW5kKCksIHNsaWNlLCBwbGFjZWRTaXplKTtcbiAgICAgICAgaWYgKHNsaWNlLnNpemUgfHwgJGZyb20ucG9zICE9IHRoaXMuJHRvLnBvcykgLy8gRG9uJ3QgZ2VuZXJhdGUgbm8tb3Agc3RlcHNcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoJGZyb20ucG9zLCAkdG8ucG9zLCBzbGljZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBGaW5kIGEgcG9zaXRpb24gb24gdGhlIHN0YXJ0IHNwaW5lIG9mIGB0aGlzLnVucGxhY2VkYCB0aGF0IGhhc1xuICAgIC8vIGNvbnRlbnQgdGhhdCBjYW4gYmUgbW92ZWQgc29tZXdoZXJlIG9uIHRoZSBmcm9udGllci4gUmV0dXJucyB0d29cbiAgICAvLyBkZXB0aHMsIG9uZSBmb3IgdGhlIHNsaWNlIGFuZCBvbmUgZm9yIHRoZSBmcm9udGllci5cbiAgICBmaW5kRml0dGFibGUoKSB7XG4gICAgICAgIGxldCBzdGFydERlcHRoID0gdGhpcy51bnBsYWNlZC5vcGVuU3RhcnQ7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHRoaXMudW5wbGFjZWQuY29udGVudCwgZCA9IDAsIG9wZW5FbmQgPSB0aGlzLnVucGxhY2VkLm9wZW5FbmQ7IGQgPCBzdGFydERlcHRoOyBkKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gY3VyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoY3VyLmNoaWxkQ291bnQgPiAxKVxuICAgICAgICAgICAgICAgIG9wZW5FbmQgPSAwO1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZyAmJiBvcGVuRW5kIDw9IGQpIHtcbiAgICAgICAgICAgICAgICBzdGFydERlcHRoID0gZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IG5vZGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IHRyeSB3cmFwcGluZyBub2RlcyAocGFzcyAyKSBhZnRlciBmaW5kaW5nIGEgcGxhY2Ugd2l0aG91dFxuICAgICAgICAvLyB3cmFwcGluZyBmYWlsZWQuXG4gICAgICAgIGZvciAobGV0IHBhc3MgPSAxOyBwYXNzIDw9IDI7IHBhc3MrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgc2xpY2VEZXB0aCA9IHBhc3MgPT0gMSA/IHN0YXJ0RGVwdGggOiB0aGlzLnVucGxhY2VkLm9wZW5TdGFydDsgc2xpY2VEZXB0aCA+PSAwOyBzbGljZURlcHRoLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJhZ21lbnQsIHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlRGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gY29udGVudEF0KHRoaXMudW5wbGFjZWQuY29udGVudCwgc2xpY2VEZXB0aCAtIDEpLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMudW5wbGFjZWQuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBmcm9udGllckRlcHRoID0gdGhpcy5kZXB0aDsgZnJvbnRpZXJEZXB0aCA+PSAwOyBmcm9udGllckRlcHRoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbWF0Y2ggfSA9IHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0sIHdyYXAsIGluamVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHBhc3MgMSwgaWYgdGhlIG5leHQgbm9kZSBtYXRjaGVzLCBvciB0aGVyZSBpcyBubyBuZXh0XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGUgYnV0IHRoZSBwYXJlbnRzIGxvb2sgY29tcGF0aWJsZSwgd2UndmUgZm91bmQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3MgPT0gMSAmJiAoZmlyc3QgPyBtYXRjaC5tYXRjaFR5cGUoZmlyc3QudHlwZSkgfHwgKGluamVjdCA9IG1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZnJvbShmaXJzdCksIGZhbHNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGFyZW50ICYmIHR5cGUuY29tcGF0aWJsZUNvbnRlbnQocGFyZW50LnR5cGUpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgaW5qZWN0IH07XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHBhc3MgMiwgbG9vayBmb3IgYSBzZXQgb2Ygd3JhcHBpbmcgbm9kZXMgdGhhdCBtYWtlXG4gICAgICAgICAgICAgICAgICAgIC8vIGBmaXJzdGAgZml0IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhc3MgPT0gMiAmJiBmaXJzdCAmJiAod3JhcCA9IG1hdGNoLmZpbmRXcmFwcGluZyhmaXJzdC50eXBlKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzbGljZURlcHRoLCBmcm9udGllckRlcHRoLCBwYXJlbnQsIHdyYXAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY29udGludWUgbG9va2luZyBmdXJ0aGVyIHVwIGlmIHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB3b3VsZCBmaXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBtYXRjaC5tYXRjaFR5cGUocGFyZW50LnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9wZW5Nb3JlKCkge1xuICAgICAgICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHRoaXMudW5wbGFjZWQ7XG4gICAgICAgIGxldCBpbm5lciA9IGNvbnRlbnRBdChjb250ZW50LCBvcGVuU3RhcnQpO1xuICAgICAgICBpZiAoIWlubmVyLmNoaWxkQ291bnQgfHwgaW5uZXIuZmlyc3RDaGlsZC5pc0xlYWYpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoY29udGVudCwgb3BlblN0YXJ0ICsgMSwgTWF0aC5tYXgob3BlbkVuZCwgaW5uZXIuc2l6ZSArIG9wZW5TdGFydCA+PSBjb250ZW50LnNpemUgLSBvcGVuRW5kID8gb3BlblN0YXJ0ICsgMSA6IDApKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRyb3BOb2RlKCkge1xuICAgICAgICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHRoaXMudW5wbGFjZWQ7XG4gICAgICAgIGxldCBpbm5lciA9IGNvbnRlbnRBdChjb250ZW50LCBvcGVuU3RhcnQpO1xuICAgICAgICBpZiAoaW5uZXIuY2hpbGRDb3VudCA8PSAxICYmIG9wZW5TdGFydCA+IDApIHtcbiAgICAgICAgICAgIGxldCBvcGVuQXRFbmQgPSBjb250ZW50LnNpemUgLSBvcGVuU3RhcnQgPD0gb3BlblN0YXJ0ICsgaW5uZXIuc2l6ZTtcbiAgICAgICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChjb250ZW50LCBvcGVuU3RhcnQgLSAxLCAxKSwgb3BlblN0YXJ0IC0gMSwgb3BlbkF0RW5kID8gb3BlblN0YXJ0IC0gMSA6IG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KGNvbnRlbnQsIG9wZW5TdGFydCwgMSksIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTW92ZSBjb250ZW50IGZyb20gdGhlIHVucGxhY2VkIHNsaWNlIGF0IGBzbGljZURlcHRoYCB0byB0aGVcbiAgICAvLyBmcm9udGllciBub2RlIGF0IGBmcm9udGllckRlcHRoYC4gQ2xvc2UgdGhhdCBmcm9udGllciBub2RlIHdoZW5cbiAgICAvLyBhcHBsaWNhYmxlLlxuICAgIHBsYWNlTm9kZXMoeyBzbGljZURlcHRoLCBmcm9udGllckRlcHRoLCBwYXJlbnQsIGluamVjdCwgd3JhcCB9KSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmRlcHRoID4gZnJvbnRpZXJEZXB0aClcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTtcbiAgICAgICAgaWYgKHdyYXApXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuRnJvbnRpZXJOb2RlKHdyYXBbaV0pO1xuICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnVucGxhY2VkLCBmcmFnbWVudCA9IHBhcmVudCA/IHBhcmVudC5jb250ZW50IDogc2xpY2UuY29udGVudDtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IHNsaWNlLm9wZW5TdGFydCAtIHNsaWNlRGVwdGg7XG4gICAgICAgIGxldCB0YWtlbiA9IDAsIGFkZCA9IFtdO1xuICAgICAgICBsZXQgeyBtYXRjaCwgdHlwZSB9ID0gdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXTtcbiAgICAgICAgaWYgKGluamVjdCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmplY3QuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICAgICAgICAgIGFkZC5wdXNoKGluamVjdC5jaGlsZChpKSk7XG4gICAgICAgICAgICBtYXRjaCA9IG1hdGNoLm1hdGNoRnJhZ21lbnQoaW5qZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgYW1vdW50IG9mIChlbmQpIG9wZW4gbm9kZXMgYXQgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgLy8gZnJhZ21lbnQuIFdoZW4gMCwgdGhlIHBhcmVudCBpcyBvcGVuLCBidXQgbm8gbW9yZS4gV2hlblxuICAgICAgICAvLyBuZWdhdGl2ZSwgbm90aGluZyBpcyBvcGVuLlxuICAgICAgICBsZXQgb3BlbkVuZENvdW50ID0gKGZyYWdtZW50LnNpemUgKyBzbGljZURlcHRoKSAtIChzbGljZS5jb250ZW50LnNpemUgLSBzbGljZS5vcGVuRW5kKTtcbiAgICAgICAgLy8gU2NhbiBvdmVyIHRoZSBmcmFnbWVudCwgZml0dGluZyBhcyBtYW55IGNoaWxkIG5vZGVzIGFzXG4gICAgICAgIC8vIHBvc3NpYmxlLlxuICAgICAgICB3aGlsZSAodGFrZW4gPCBmcmFnbWVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGZyYWdtZW50LmNoaWxkKHRha2VuKSwgbWF0Y2hlcyA9IG1hdGNoLm1hdGNoVHlwZShuZXh0LnR5cGUpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGFrZW4rKztcbiAgICAgICAgICAgIGlmICh0YWtlbiA+IDEgfHwgb3BlblN0YXJ0ID09IDAgfHwgbmV4dC5jb250ZW50LnNpemUpIHsgLy8gRHJvcCBlbXB0eSBvcGVuIG5vZGVzXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzO1xuICAgICAgICAgICAgICAgIGFkZC5wdXNoKGNsb3NlTm9kZVN0YXJ0KG5leHQubWFyayh0eXBlLmFsbG93ZWRNYXJrcyhuZXh0Lm1hcmtzKSksIHRha2VuID09IDEgPyBvcGVuU3RhcnQgOiAwLCB0YWtlbiA9PSBmcmFnbWVudC5jaGlsZENvdW50ID8gb3BlbkVuZENvdW50IDogLTEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9FbmQgPSB0YWtlbiA9PSBmcmFnbWVudC5jaGlsZENvdW50O1xuICAgICAgICBpZiAoIXRvRW5kKVxuICAgICAgICAgICAgb3BlbkVuZENvdW50ID0gLTE7XG4gICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgZnJvbnRpZXJEZXB0aCwgRnJhZ21lbnQuZnJvbShhZGQpKTtcbiAgICAgICAgdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXS5tYXRjaCA9IG1hdGNoO1xuICAgICAgICAvLyBJZiB0aGUgcGFyZW50IHR5cGVzIG1hdGNoLCBhbmQgdGhlIGVudGlyZSBub2RlIHdhcyBtb3ZlZCwgYW5kXG4gICAgICAgIC8vIGl0J3Mgbm90IG9wZW4sIGNsb3NlIHRoaXMgZnJvbnRpZXIgbm9kZSByaWdodCBhd2F5LlxuICAgICAgICBpZiAodG9FbmQgJiYgb3BlbkVuZENvdW50IDwgMCAmJiBwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXS50eXBlICYmIHRoaXMuZnJvbnRpZXIubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTtcbiAgICAgICAgLy8gQWRkIG5ldyBmcm9udGllciBub2RlcyBmb3IgYW55IG9wZW4gbm9kZXMgYXQgdGhlIGVuZC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGN1ciA9IGZyYWdtZW50OyBpIDwgb3BlbkVuZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gY3VyLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7IHR5cGU6IG5vZGUudHlwZSwgbWF0Y2g6IG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KSB9KTtcbiAgICAgICAgICAgIGN1ciA9IG5vZGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgYHRoaXMudW5wbGFjZWRgLiBEcm9wIHRoZSBlbnRpcmUgbm9kZSBmcm9tIHdoaWNoIHdlXG4gICAgICAgIC8vIHBsYWNlZCBpdCB3ZSBnb3QgdG8gaXRzIGVuZCwgb3RoZXJ3aXNlIGp1c3QgZHJvcCB0aGUgcGxhY2VkXG4gICAgICAgIC8vIG5vZGVzLlxuICAgICAgICB0aGlzLnVucGxhY2VkID0gIXRvRW5kID8gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoc2xpY2UuY29udGVudCwgc2xpY2VEZXB0aCwgdGFrZW4pLCBzbGljZS5vcGVuU3RhcnQsIHNsaWNlLm9wZW5FbmQpXG4gICAgICAgICAgICA6IHNsaWNlRGVwdGggPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgICAgICAgICAgICAgOiBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChzbGljZS5jb250ZW50LCBzbGljZURlcHRoIC0gMSwgMSksIHNsaWNlRGVwdGggLSAxLCBvcGVuRW5kQ291bnQgPCAwID8gc2xpY2Uub3BlbkVuZCA6IHNsaWNlRGVwdGggLSAxKTtcbiAgICB9XG4gICAgbXVzdE1vdmVJbmxpbmUoKSB7XG4gICAgICAgIGlmICghdGhpcy4kdG8ucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXSwgbGV2ZWw7XG4gICAgICAgIGlmICghdG9wLnR5cGUuaXNUZXh0YmxvY2sgfHwgIWNvbnRlbnRBZnRlckZpdHModGhpcy4kdG8sIHRoaXMuJHRvLmRlcHRoLCB0b3AudHlwZSwgdG9wLm1hdGNoLCBmYWxzZSkgfHxcbiAgICAgICAgICAgICh0aGlzLiR0by5kZXB0aCA9PSB0aGlzLmRlcHRoICYmIChsZXZlbCA9IHRoaXMuZmluZENsb3NlTGV2ZWwodGhpcy4kdG8pKSAmJiBsZXZlbC5kZXB0aCA9PSB0aGlzLmRlcHRoKSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgbGV0IHsgZGVwdGggfSA9IHRoaXMuJHRvLCBhZnRlciA9IHRoaXMuJHRvLmFmdGVyKGRlcHRoKTtcbiAgICAgICAgd2hpbGUgKGRlcHRoID4gMSAmJiBhZnRlciA9PSB0aGlzLiR0by5lbmQoLS1kZXB0aCkpXG4gICAgICAgICAgICArK2FmdGVyO1xuICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgfVxuICAgIGZpbmRDbG9zZUxldmVsKCR0bykge1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBpID0gTWF0aC5taW4odGhpcy5kZXB0aCwgJHRvLmRlcHRoKTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2ldO1xuICAgICAgICAgICAgbGV0IGRyb3BJbm5lciA9IGkgPCAkdG8uZGVwdGggJiYgJHRvLmVuZChpICsgMSkgPT0gJHRvLnBvcyArICgkdG8uZGVwdGggLSAoaSArIDEpKTtcbiAgICAgICAgICAgIGxldCBmaXQgPSBjb250ZW50QWZ0ZXJGaXRzKCR0bywgaSwgdHlwZSwgbWF0Y2gsIGRyb3BJbm5lcik7XG4gICAgICAgICAgICBpZiAoIWZpdClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSBpIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBtYXRjaCwgdHlwZSB9ID0gdGhpcy5mcm9udGllcltkXTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlcyA9IGNvbnRlbnRBZnRlckZpdHMoJHRvLCBkLCB0eXBlLCBtYXRjaCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRlcHRoOiBpLCBmaXQsIG1vdmU6IGRyb3BJbm5lciA/ICR0by5kb2MucmVzb2x2ZSgkdG8uYWZ0ZXIoaSArIDEpKSA6ICR0byB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCR0bykge1xuICAgICAgICBsZXQgY2xvc2UgPSB0aGlzLmZpbmRDbG9zZUxldmVsKCR0byk7XG4gICAgICAgIGlmICghY2xvc2UpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHRoaXMuZGVwdGggPiBjbG9zZS5kZXB0aClcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTtcbiAgICAgICAgaWYgKGNsb3NlLmZpdC5jaGlsZENvdW50KVxuICAgICAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCBjbG9zZS5kZXB0aCwgY2xvc2UuZml0KTtcbiAgICAgICAgJHRvID0gY2xvc2UubW92ZTtcbiAgICAgICAgZm9yIChsZXQgZCA9IGNsb3NlLmRlcHRoICsgMTsgZCA8PSAkdG8uZGVwdGg7IGQrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSAkdG8ubm9kZShkKSwgYWRkID0gbm9kZS50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKG5vZGUuY29udGVudCwgdHJ1ZSwgJHRvLmluZGV4KGQpKTtcbiAgICAgICAgICAgIHRoaXMub3BlbkZyb250aWVyTm9kZShub2RlLnR5cGUsIG5vZGUuYXR0cnMsIGFkZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0bztcbiAgICB9XG4gICAgb3BlbkZyb250aWVyTm9kZSh0eXBlLCBhdHRycyA9IG51bGwsIGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF07XG4gICAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaC5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgdGhpcy5kZXB0aCwgRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhdHRycywgY29udGVudCkpKTtcbiAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHsgdHlwZSwgbWF0Y2g6IHR5cGUuY29udGVudE1hdGNoIH0pO1xuICAgIH1cbiAgICBjbG9zZUZyb250aWVyTm9kZSgpIHtcbiAgICAgICAgbGV0IG9wZW4gPSB0aGlzLmZyb250aWVyLnBvcCgpO1xuICAgICAgICBsZXQgYWRkID0gb3Blbi5tYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgaWYgKGFkZC5jaGlsZENvdW50KVxuICAgICAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCB0aGlzLmZyb250aWVyLmxlbmd0aCwgYWRkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkcm9wRnJvbUZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgY291bnQpIHtcbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LmN1dEJ5SW5kZXgoY291bnQsIGZyYWdtZW50LmNoaWxkQ291bnQpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoMCwgZnJhZ21lbnQuZmlyc3RDaGlsZC5jb3B5KGRyb3BGcm9tRnJhZ21lbnQoZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50LCBkZXB0aCAtIDEsIGNvdW50KSkpO1xufVxuZnVuY3Rpb24gYWRkVG9GcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIGNvbnRlbnQpIHtcbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LmFwcGVuZChjb250ZW50KTtcbiAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKGZyYWdtZW50LmNoaWxkQ291bnQgLSAxLCBmcmFnbWVudC5sYXN0Q2hpbGQuY29weShhZGRUb0ZyYWdtZW50KGZyYWdtZW50Lmxhc3RDaGlsZC5jb250ZW50LCBkZXB0aCAtIDEsIGNvbnRlbnQpKSk7XG59XG5mdW5jdGlvbiBjb250ZW50QXQoZnJhZ21lbnQsIGRlcHRoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXB0aDsgaSsrKVxuICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiBjbG9zZU5vZGVTdGFydChub2RlLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBpZiAob3BlblN0YXJ0IDw9IDApXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIGxldCBmcmFnID0gbm9kZS5jb250ZW50O1xuICAgIGlmIChvcGVuU3RhcnQgPiAxKVxuICAgICAgICBmcmFnID0gZnJhZy5yZXBsYWNlQ2hpbGQoMCwgY2xvc2VOb2RlU3RhcnQoZnJhZy5maXJzdENoaWxkLCBvcGVuU3RhcnQgLSAxLCBmcmFnLmNoaWxkQ291bnQgPT0gMSA/IG9wZW5FbmQgLSAxIDogMCkpO1xuICAgIGlmIChvcGVuU3RhcnQgPiAwKSB7XG4gICAgICAgIGZyYWcgPSBub2RlLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoZnJhZykuYXBwZW5kKGZyYWcpO1xuICAgICAgICBpZiAob3BlbkVuZCA8PSAwKVxuICAgICAgICAgICAgZnJhZyA9IGZyYWcuYXBwZW5kKG5vZGUudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChmcmFnKS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLmNvcHkoZnJhZyk7XG59XG5mdW5jdGlvbiBjb250ZW50QWZ0ZXJGaXRzKCR0bywgZGVwdGgsIHR5cGUsIG1hdGNoLCBvcGVuKSB7XG4gICAgbGV0IG5vZGUgPSAkdG8ubm9kZShkZXB0aCksIGluZGV4ID0gb3BlbiA/ICR0by5pbmRleEFmdGVyKGRlcHRoKSA6ICR0by5pbmRleChkZXB0aCk7XG4gICAgaWYgKGluZGV4ID09IG5vZGUuY2hpbGRDb3VudCAmJiAhdHlwZS5jb21wYXRpYmxlQ29udGVudChub2RlLnR5cGUpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZml0ID0gbWF0Y2guZmlsbEJlZm9yZShub2RlLmNvbnRlbnQsIHRydWUsIGluZGV4KTtcbiAgICByZXR1cm4gZml0ICYmICFpbnZhbGlkTWFya3ModHlwZSwgbm9kZS5jb250ZW50LCBpbmRleCkgPyBmaXQgOiBudWxsO1xufVxuZnVuY3Rpb24gaW52YWxpZE1hcmtzKHR5cGUsIGZyYWdtZW50LCBzdGFydCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGZyYWdtZW50LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgaWYgKCF0eXBlLmFsbG93c01hcmtzKGZyYWdtZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRlZmluZXNDb250ZW50KHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZS5zcGVjLmRlZmluaW5nIHx8IHR5cGUuc3BlYy5kZWZpbmluZ0ZvckNvbnRlbnQ7XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2UodHIsIGZyb20sIHRvLCBzbGljZSkge1xuICAgIGlmICghc2xpY2Uuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gdHIuZG9jLnJlc29sdmUodG8pO1xuICAgIGlmIChmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSlcbiAgICAgICAgcmV0dXJuIHRyLnN0ZXAobmV3IFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSkpO1xuICAgIGxldCB0YXJnZXREZXB0aHMgPSBjb3ZlcmVkRGVwdGhzKCRmcm9tLCB0ci5kb2MucmVzb2x2ZSh0bykpO1xuICAgIC8vIENhbid0IHJlcGxhY2UgdGhlIHdob2xlIGRvY3VtZW50LCBzbyByZW1vdmUgMCBpZiBpdCdzIHByZXNlbnRcbiAgICBpZiAodGFyZ2V0RGVwdGhzW3RhcmdldERlcHRocy5sZW5ndGggLSAxXSA9PSAwKVxuICAgICAgICB0YXJnZXREZXB0aHMucG9wKCk7XG4gICAgLy8gTmVnYXRpdmUgbnVtYmVycyByZXByZXNlbnQgbm90IGV4cGFuc2lvbiBvdmVyIHRoZSB3aG9sZSBub2RlIGF0XG4gICAgLy8gdGhhdCBkZXB0aCwgYnV0IHJlcGxhY2luZyBmcm9tICRmcm9tLmJlZm9yZSgtRCkgdG8gJHRvLnBvcy5cbiAgICBsZXQgcHJlZmVycmVkVGFyZ2V0ID0gLSgkZnJvbS5kZXB0aCArIDEpO1xuICAgIHRhcmdldERlcHRocy51bnNoaWZ0KHByZWZlcnJlZFRhcmdldCk7XG4gICAgLy8gVGhpcyBsb29wIHBpY2tzIGEgcHJlZmVycmVkIHRhcmdldCBkZXB0aCwgaWYgb25lIG9mIHRoZSBjb3ZlcmluZ1xuICAgIC8vIGRlcHRocyBpcyBub3Qgb3V0c2lkZSBvZiBhIGRlZmluaW5nIG5vZGUsIGFuZCBhZGRzIG5lZ2F0aXZlXG4gICAgLy8gZGVwdGhzIGZvciBhbnkgZGVwdGggdGhhdCBoYXMgJGZyb20gYXQgaXRzIHN0YXJ0IGFuZCBkb2VzIG5vdFxuICAgIC8vIGNyb3NzIGEgZGVmaW5pbmcgbm9kZS5cbiAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGgsIHBvcyA9ICRmcm9tLnBvcyAtIDE7IGQgPiAwOyBkLS0sIHBvcy0tKSB7XG4gICAgICAgIGxldCBzcGVjID0gJGZyb20ubm9kZShkKS50eXBlLnNwZWM7XG4gICAgICAgIGlmIChzcGVjLmRlZmluaW5nIHx8IHNwZWMuZGVmaW5pbmdBc0NvbnRleHQgfHwgc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHRhcmdldERlcHRocy5pbmRleE9mKGQpID4gLTEpXG4gICAgICAgICAgICBwcmVmZXJyZWRUYXJnZXQgPSBkO1xuICAgICAgICBlbHNlIGlmICgkZnJvbS5iZWZvcmUoZCkgPT0gcG9zKVxuICAgICAgICAgICAgdGFyZ2V0RGVwdGhzLnNwbGljZSgxLCAwLCAtZCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byBmaXQgZWFjaCBwb3NzaWJsZSBkZXB0aCBvZiB0aGUgc2xpY2UgaW50byBlYWNoIHBvc3NpYmxlXG4gICAgLy8gdGFyZ2V0IGRlcHRoLCBzdGFydGluZyB3aXRoIHRoZSBwcmVmZXJyZWQgZGVwdGhzLlxuICAgIGxldCBwcmVmZXJyZWRUYXJnZXRJbmRleCA9IHRhcmdldERlcHRocy5pbmRleE9mKHByZWZlcnJlZFRhcmdldCk7XG4gICAgbGV0IGxlZnROb2RlcyA9IFtdLCBwcmVmZXJyZWREZXB0aCA9IHNsaWNlLm9wZW5TdGFydDtcbiAgICBmb3IgKGxldCBjb250ZW50ID0gc2xpY2UuY29udGVudCwgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBjb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGxlZnROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoaSA9PSBzbGljZS5vcGVuU3RhcnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY29udGVudCA9IG5vZGUuY29udGVudDtcbiAgICB9XG4gICAgLy8gQmFjayB1cCBwcmVmZXJyZWREZXB0aCB0byBjb3ZlciBkZWZpbmluZyB0ZXh0YmxvY2tzIGRpcmVjdGx5XG4gICAgLy8gYWJvdmUgaXQsIHBvc3NpYmx5IHNraXBwaW5nIGEgbm9uLWRlZmluaW5nIHRleHRibG9jay5cbiAgICBmb3IgKGxldCBkID0gcHJlZmVycmVkRGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgbGVmdE5vZGUgPSBsZWZ0Tm9kZXNbZF0sIGRlZiA9IGRlZmluZXNDb250ZW50KGxlZnROb2RlLnR5cGUpO1xuICAgICAgICBpZiAoZGVmICYmICFsZWZ0Tm9kZS5zYW1lTWFya3VwKCRmcm9tLm5vZGUoTWF0aC5hYnMocHJlZmVycmVkVGFyZ2V0KSAtIDEpKSlcbiAgICAgICAgICAgIHByZWZlcnJlZERlcHRoID0gZDtcbiAgICAgICAgZWxzZSBpZiAoZGVmIHx8ICFsZWZ0Tm9kZS50eXBlLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBzbGljZS5vcGVuU3RhcnQ7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIGxldCBvcGVuRGVwdGggPSAoaiArIHByZWZlcnJlZERlcHRoICsgMSkgJSAoc2xpY2Uub3BlblN0YXJ0ICsgMSk7XG4gICAgICAgIGxldCBpbnNlcnQgPSBsZWZ0Tm9kZXNbb3BlbkRlcHRoXTtcbiAgICAgICAgaWYgKCFpbnNlcnQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXREZXB0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciBwb3NzaWJsZSBleHBhbnNpb24gbGV2ZWxzLCBzdGFydGluZyB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gcHJlZmVycmVkIG9uZVxuICAgICAgICAgICAgbGV0IHRhcmdldERlcHRoID0gdGFyZ2V0RGVwdGhzWyhpICsgcHJlZmVycmVkVGFyZ2V0SW5kZXgpICUgdGFyZ2V0RGVwdGhzLmxlbmd0aF0sIGV4cGFuZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RGVwdGggPCAwKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGVwdGggPSAtdGFyZ2V0RGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ubm9kZSh0YXJnZXREZXB0aCAtIDEpLCBpbmRleCA9ICRmcm9tLmluZGV4KHRhcmdldERlcHRoIC0gMSk7XG4gICAgICAgICAgICBpZiAocGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgaW5zZXJ0LnR5cGUsIGluc2VydC5tYXJrcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyLnJlcGxhY2UoJGZyb20uYmVmb3JlKHRhcmdldERlcHRoKSwgZXhwYW5kID8gJHRvLmFmdGVyKHRhcmdldERlcHRoKSA6IHRvLCBuZXcgU2xpY2UoY2xvc2VGcmFnbWVudChzbGljZS5jb250ZW50LCAwLCBzbGljZS5vcGVuU3RhcnQsIG9wZW5EZXB0aCksIG9wZW5EZXB0aCwgc2xpY2Uub3BlbkVuZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdGFydFN0ZXBzID0gdHIuc3RlcHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSB0YXJnZXREZXB0aHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdHIucmVwbGFjZShmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgICBpZiAodHIuc3RlcHMubGVuZ3RoID4gc3RhcnRTdGVwcylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgZGVwdGggPSB0YXJnZXREZXB0aHNbaV07XG4gICAgICAgIGlmIChkZXB0aCA8IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZnJvbSA9ICRmcm9tLmJlZm9yZShkZXB0aCk7XG4gICAgICAgIHRvID0gJHRvLmFmdGVyKGRlcHRoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zZUZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgb2xkT3BlbiwgbmV3T3BlbiwgcGFyZW50KSB7XG4gICAgaWYgKGRlcHRoIDwgb2xkT3Blbikge1xuICAgICAgICBsZXQgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2VDaGlsZCgwLCBmaXJzdC5jb3B5KGNsb3NlRnJhZ21lbnQoZmlyc3QuY29udGVudCwgZGVwdGggKyAxLCBvbGRPcGVuLCBuZXdPcGVuLCBmaXJzdCkpKTtcbiAgICB9XG4gICAgaWYgKGRlcHRoID4gbmV3T3Blbikge1xuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJlbnQuY29udGVudE1hdGNoQXQoMCk7XG4gICAgICAgIGxldCBzdGFydCA9IG1hdGNoLmZpbGxCZWZvcmUoZnJhZ21lbnQpLmFwcGVuZChmcmFnbWVudCk7XG4gICAgICAgIGZyYWdtZW50ID0gc3RhcnQuYXBwZW5kKG1hdGNoLm1hdGNoRnJhZ21lbnQoc3RhcnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlV2l0aCh0ciwgZnJvbSwgdG8sIG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuaXNJbmxpbmUgJiYgZnJvbSA9PSB0byAmJiB0ci5kb2MucmVzb2x2ZShmcm9tKS5wYXJlbnQuY29udGVudC5zaXplKSB7XG4gICAgICAgIGxldCBwb2ludCA9IGluc2VydFBvaW50KHRyLmRvYywgZnJvbSwgbm9kZS50eXBlKTtcbiAgICAgICAgaWYgKHBvaW50ICE9IG51bGwpXG4gICAgICAgICAgICBmcm9tID0gdG8gPSBwb2ludDtcbiAgICB9XG4gICAgdHIucmVwbGFjZVJhbmdlKGZyb20sIHRvLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShub2RlKSwgMCwgMCkpO1xufVxuZnVuY3Rpb24gZGVsZXRlUmFuZ2UodHIsIGZyb20sIHRvKSB7XG4gICAgbGV0ICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksICR0byA9IHRyLmRvYy5yZXNvbHZlKHRvKTtcbiAgICBsZXQgY292ZXJlZCA9IGNvdmVyZWREZXB0aHMoJGZyb20sICR0byk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3ZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkZXB0aCA9IGNvdmVyZWRbaV0sIGxhc3QgPSBpID09IGNvdmVyZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKChsYXN0ICYmIGRlcHRoID09IDApIHx8ICRmcm9tLm5vZGUoZGVwdGgpLnR5cGUuY29udGVudE1hdGNoLnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZSgkZnJvbS5zdGFydChkZXB0aCksICR0by5lbmQoZGVwdGgpKTtcbiAgICAgICAgaWYgKGRlcHRoID4gMCAmJiAobGFzdCB8fCAkZnJvbS5ub2RlKGRlcHRoIC0gMSkuY2FuUmVwbGFjZSgkZnJvbS5pbmRleChkZXB0aCAtIDEpLCAkdG8uaW5kZXhBZnRlcihkZXB0aCAtIDEpKSkpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLmJlZm9yZShkZXB0aCksICR0by5hZnRlcihkZXB0aCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBkID0gMTsgZCA8PSAkZnJvbS5kZXB0aCAmJiBkIDw9ICR0by5kZXB0aDsgZCsrKSB7XG4gICAgICAgIGlmIChmcm9tIC0gJGZyb20uc3RhcnQoZCkgPT0gJGZyb20uZGVwdGggLSBkICYmIHRvID4gJGZyb20uZW5kKGQpICYmICR0by5lbmQoZCkgLSB0byAhPSAkdG8uZGVwdGggLSBkKVxuICAgICAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZSgkZnJvbS5iZWZvcmUoZCksIHRvKTtcbiAgICB9XG4gICAgdHIuZGVsZXRlKGZyb20sIHRvKTtcbn1cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGRlcHRocyBmb3Igd2hpY2ggJGZyb20gLSAkdG8gc3BhbnMgdGhlXG4vLyB3aG9sZSBjb250ZW50IG9mIHRoZSBub2RlcyBhdCB0aGF0IGRlcHRoLlxuZnVuY3Rpb24gY292ZXJlZERlcHRocygkZnJvbSwgJHRvKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdLCBtaW5EZXB0aCA9IE1hdGgubWluKCRmcm9tLmRlcHRoLCAkdG8uZGVwdGgpO1xuICAgIGZvciAobGV0IGQgPSBtaW5EZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uc3RhcnQoZCk7XG4gICAgICAgIGlmIChzdGFydCA8ICRmcm9tLnBvcyAtICgkZnJvbS5kZXB0aCAtIGQpIHx8XG4gICAgICAgICAgICAkdG8uZW5kKGQpID4gJHRvLnBvcyArICgkdG8uZGVwdGggLSBkKSB8fFxuICAgICAgICAgICAgJGZyb20ubm9kZShkKS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8XG4gICAgICAgICAgICAkdG8ubm9kZShkKS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChzdGFydCA9PSAkdG8uc3RhcnQoZCkgfHxcbiAgICAgICAgICAgIChkID09ICRmcm9tLmRlcHRoICYmIGQgPT0gJHRvLmRlcHRoICYmICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50ICYmICR0by5wYXJlbnQuaW5saW5lQ29udGVudCAmJlxuICAgICAgICAgICAgICAgIGQgJiYgJHRvLnN0YXJ0KGQgLSAxKSA9PSBzdGFydCAtIDEpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuVXBkYXRlIGFuIGF0dHJpYnV0ZSBpbiBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgQXR0clN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYW4gYXR0cmlidXRlIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgYXR0cmlidXRlIHRvIHNldC5cbiAgICAqL1xuICAgIGF0dHIsIFxuICAgIC8vIFRoZSBhdHRyaWJ1dGUncyBuZXcgdmFsdWUuXG4gICAgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuYXR0ciA9IGF0dHI7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IGF0dHJpYnV0ZSBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gbm9kZS5hdHRycylcbiAgICAgICAgICAgIGF0dHJzW25hbWVdID0gbm9kZS5hdHRyc1tuYW1lXTtcbiAgICAgICAgYXR0cnNbdGhpcy5hdHRyXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbm9kZS5tYXJrcyk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5wb3MsIHRoaXMucG9zICsgMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odXBkYXRlZCksIDAsIG5vZGUuaXNMZWFmID8gMCA6IDEpKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gU3RlcE1hcC5lbXB0eTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJTdGVwKHRoaXMucG9zLCB0aGlzLmF0dHIsIGRvYy5ub2RlQXQodGhpcy5wb3MpLmF0dHJzW3RoaXMuYXR0cl0pO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgcG9zID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5wb3MsIDEpO1xuICAgICAgICByZXR1cm4gcG9zLmRlbGV0ZWRBZnRlciA/IG51bGwgOiBuZXcgQXR0clN0ZXAocG9zLnBvcywgdGhpcy5hdHRyLCB0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhdHRyXCIsIHBvczogdGhpcy5wb3MsIGF0dHI6IHRoaXMuYXR0ciwgdmFsdWU6IHRoaXMudmFsdWUgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uYXR0ciAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBdHRyU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyU3RlcChqc29uLnBvcywganNvbi5hdHRyLCBqc29uLnZhbHVlKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImF0dHJcIiwgQXR0clN0ZXApO1xuLyoqXG5VcGRhdGUgYW4gYXR0cmlidXRlIGluIHRoZSBkb2Mgbm9kZS5cbiovXG5jbGFzcyBEb2NBdHRyU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhbiBhdHRyaWJ1dGUgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBhdHRyaWJ1dGUgdG8gc2V0LlxuICAgICovXG4gICAgYXR0ciwgXG4gICAgLy8gVGhlIGF0dHJpYnV0ZSdzIG5ldyB2YWx1ZS5cbiAgICB2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmF0dHIgPSBhdHRyO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGRvYy5hdHRycylcbiAgICAgICAgICAgIGF0dHJzW25hbWVdID0gZG9jLmF0dHJzW25hbWVdO1xuICAgICAgICBhdHRyc1t0aGlzLmF0dHJdID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBkb2MudHlwZS5jcmVhdGUoYXR0cnMsIGRvYy5jb250ZW50LCBkb2MubWFya3MpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5vayh1cGRhdGVkKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gU3RlcE1hcC5lbXB0eTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IERvY0F0dHJTdGVwKHRoaXMuYXR0ciwgZG9jLmF0dHJzW3RoaXMuYXR0cl0pO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJkb2NBdHRyXCIsIGF0dHI6IHRoaXMuYXR0ciwgdmFsdWU6IHRoaXMudmFsdWUgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uYXR0ciAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBEb2NBdHRyU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2NBdHRyU3RlcChqc29uLmF0dHIsIGpzb24udmFsdWUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiZG9jQXR0clwiLCBEb2NBdHRyU3RlcCk7XG5cbi8qKlxuQGludGVybmFsXG4qL1xubGV0IFRyYW5zZm9ybUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG59O1xuVHJhbnNmb3JtRXJyb3IgPSBmdW5jdGlvbiBUcmFuc2Zvcm1FcnJvcihtZXNzYWdlKSB7XG4gICAgbGV0IGVyciA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgZXJyLl9fcHJvdG9fXyA9IFRyYW5zZm9ybUVycm9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gZXJyO1xufTtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyYW5zZm9ybUVycm9yO1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlRyYW5zZm9ybUVycm9yXCI7XG4vKipcbkFic3RyYWN0aW9uIHRvIGJ1aWxkIHVwIGFuZCB0cmFjayBhbiBhcnJheSBvZlxuW3N0ZXBzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXApIHJlcHJlc2VudGluZyBhIGRvY3VtZW50IHRyYW5zZm9ybWF0aW9uLlxuXG5Nb3N0IHRyYW5zZm9ybWluZyBtZXRob2RzIHJldHVybiB0aGUgYFRyYW5zZm9ybWAgb2JqZWN0IGl0c2VsZiwgc29cbnRoYXQgdGhleSBjYW4gYmUgY2hhaW5lZC5cbiovXG5jbGFzcyBUcmFuc2Zvcm0ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRyYW5zZm9ybSB0aGF0IHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGRvY3VtZW50ICh0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBzdGVwcyBpbiB0aGVcbiAgICB0cmFuc2Zvcm0pLlxuICAgICovXG4gICAgZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHN0ZXBzIGluIHRoaXMgdHJhbnNmb3JtLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0ZXBzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgZG9jdW1lbnRzIGJlZm9yZSBlYWNoIG9mIHRoZSBzdGVwcy5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb2NzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBBIG1hcHBpbmcgd2l0aCB0aGUgbWFwcyBmb3IgZWFjaCBvZiB0aGUgc3RlcHMgaW4gdGhpcyB0cmFuc2Zvcm0uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3RhcnRpbmcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgYmVmb3JlKCkgeyByZXR1cm4gdGhpcy5kb2NzLmxlbmd0aCA/IHRoaXMuZG9jc1swXSA6IHRoaXMuZG9jOyB9XG4gICAgLyoqXG4gICAgQXBwbHkgYSBuZXcgc3RlcCBpbiB0aGlzIHRyYW5zZm9ybSwgc2F2aW5nIHRoZSByZXN1bHQuIFRocm93cyBhblxuICAgIGVycm9yIHdoZW4gdGhlIHN0ZXAgZmFpbHMuXG4gICAgKi9cbiAgICBzdGVwKHN0ZXApIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubWF5YmVTdGVwKHN0ZXApO1xuICAgICAgICBpZiAocmVzdWx0LmZhaWxlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2Zvcm1FcnJvcihyZXN1bHQuZmFpbGVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBhcHBseSBhIHN0ZXAgaW4gdGhpcyB0cmFuc2Zvcm1hdGlvbiwgaWdub3JpbmcgaXQgaWYgaXRcbiAgICBmYWlscy4gUmV0dXJucyB0aGUgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBtYXliZVN0ZXAoc3RlcCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3RlcC5hcHBseSh0aGlzLmRvYyk7XG4gICAgICAgIGlmICghcmVzdWx0LmZhaWxlZClcbiAgICAgICAgICAgIHRoaXMuYWRkU3RlcChzdGVwLCByZXN1bHQuZG9jKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBjaGFuZ2VkICh3aGVuIHRoZXJlIGFyZSBhbnlcbiAgICBzdGVwcykuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRTdGVwKHN0ZXAsIGRvYykge1xuICAgICAgICB0aGlzLmRvY3MucHVzaCh0aGlzLmRvYyk7XG4gICAgICAgIHRoaXMuc3RlcHMucHVzaChzdGVwKTtcbiAgICAgICAgdGhpcy5tYXBwaW5nLmFwcGVuZE1hcChzdGVwLmdldE1hcCgpKTtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIHdpdGggdGhlXG4gICAgZ2l2ZW4gYHNsaWNlYC5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8gPSBmcm9tLCBzbGljZSA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIGxldCBzdGVwID0gcmVwbGFjZVN0ZXAodGhpcy5kb2MsIGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIGlmIChzdGVwKVxuICAgICAgICAgICAgdGhpcy5zdGVwKHN0ZXApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gY29udGVudCwgd2hpY2ggbWF5IGJlIGFcbiAgICBmcmFnbWVudCwgbm9kZSwgb3IgYXJyYXkgb2Ygbm9kZXMuXG4gICAgKi9cbiAgICByZXBsYWNlV2l0aChmcm9tLCB0bywgY29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKGZyb20sIHRvLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShjb250ZW50KSwgMCwgMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgZGVsZXRlKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIFNsaWNlLmVtcHR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5zZXJ0IHRoZSBnaXZlbiBjb250ZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGluc2VydChwb3MsIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVdpdGgocG9zLCBwb3MsIGNvbnRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgcmFuZ2Ugb2YgdGhlIGRvY3VtZW50IHdpdGggYSBnaXZlbiBzbGljZSwgdXNpbmdcbiAgICBgZnJvbWAsIGB0b2AsIGFuZCB0aGUgc2xpY2Unc1xuICAgIFtgb3BlblN0YXJ0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlNsaWNlLm9wZW5TdGFydCkgcHJvcGVydHkgYXMgaGludHMsIHJhdGhlclxuICAgIHRoYW4gZml4ZWQgc3RhcnQgYW5kIGVuZCBwb2ludHMuIFRoaXMgbWV0aG9kIG1heSBncm93IHRoZVxuICAgIHJlcGxhY2VkIGFyZWEgb3IgY2xvc2Ugb3BlbiBub2RlcyBpbiB0aGUgc2xpY2UgaW4gb3JkZXIgdG8gZ2V0IGFcbiAgICBmaXQgdGhhdCBpcyBtb3JlIGluIGxpbmUgd2l0aCBXWVNJV1lHIGV4cGVjdGF0aW9ucywgYnkgZHJvcHBpbmdcbiAgICBmdWxseSBjb3ZlcmVkIHBhcmVudCBub2RlcyBvZiB0aGUgcmVwbGFjZWQgcmVnaW9uIHdoZW4gdGhleSBhcmVcbiAgICBtYXJrZWQgW25vbi1kZWZpbmluZyBhc1xuICAgIGNvbnRleHRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5kZWZpbmluZ0FzQ29udGV4dCksIG9yIGluY2x1ZGluZyBhblxuICAgIG9wZW4gcGFyZW50IG5vZGUgZnJvbSB0aGUgc2xpY2UgdGhhdCBfaXNfIG1hcmtlZCBhcyBbZGVmaW5pbmdcbiAgICBpdHMgY29udGVudF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmRlZmluaW5nRm9yQ29udGVudCkuXG4gICAgXG4gICAgVGhpcyBpcyB0aGUgbWV0aG9kLCBmb3IgZXhhbXBsZSwgdG8gaGFuZGxlIHBhc3RlLiBUaGUgc2ltaWxhclxuICAgIFtgcmVwbGFjZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uVHJhbnNmb3JtLnJlcGxhY2UpIG1ldGhvZCBpcyBhIG1vcmVcbiAgICBwcmltaXRpdmUgdG9vbCB3aGljaCB3aWxsIF9ub3RfIG1vdmUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgaXRzIGdpdmVuXG4gICAgcmFuZ2UsIGFuZCBpcyB1c2VmdWwgaW4gc2l0dWF0aW9ucyB3aGVyZSB5b3UgbmVlZCBtb3JlIHByZWNpc2VcbiAgICBjb250cm9sIG92ZXIgd2hhdCBoYXBwZW5zLlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlKGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgICByZXBsYWNlUmFuZ2UodGhpcywgZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGdpdmVuIHJhbmdlIHdpdGggYSBub2RlLCBidXQgdXNlIGBmcm9tYCBhbmQgYHRvYCBhc1xuICAgIGhpbnRzLCByYXRoZXIgdGhhbiBwcmVjaXNlIHBvc2l0aW9ucy4gV2hlbiBmcm9tIGFuZCB0byBhcmUgdGhlIHNhbWVcbiAgICBhbmQgYXJlIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBwYXJlbnQgbm9kZSBpbiB3aGljaCB0aGUgZ2l2ZW5cbiAgICBub2RlIGRvZXNuJ3QgZml0LCB0aGlzIG1ldGhvZCBtYXkgX21vdmVfIHRoZW0gb3V0IHRvd2FyZHMgYSBwYXJlbnRcbiAgICB0aGF0IGRvZXMgYWxsb3cgdGhlIGdpdmVuIG5vZGUgdG8gYmUgcGxhY2VkLiBXaGVuIHRoZSBnaXZlbiByYW5nZVxuICAgIGNvbXBsZXRlbHkgY292ZXJzIGEgcGFyZW50IG5vZGUsIHRoaXMgbWV0aG9kIG1heSBjb21wbGV0ZWx5IHJlcGxhY2VcbiAgICB0aGF0IHBhcmVudCBub2RlLlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgbm9kZSkge1xuICAgICAgICByZXBsYWNlUmFuZ2VXaXRoKHRoaXMsIGZyb20sIHRvLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgZ2l2ZW4gcmFuZ2UsIGV4cGFuZGluZyBpdCB0byBjb3ZlciBmdWxseSBjb3ZlcmVkXG4gICAgcGFyZW50IG5vZGVzIHVudGlsIGEgdmFsaWQgcmVwbGFjZSBpcyBmb3VuZC5cbiAgICAqL1xuICAgIGRlbGV0ZVJhbmdlKGZyb20sIHRvKSB7XG4gICAgICAgIGRlbGV0ZVJhbmdlKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNwbGl0IHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZSBvZmYgZnJvbSBpdHMgcGFyZW50LCBpZiB0aGVyZVxuICAgIGlzIHNpYmxpbmcgY29udGVudCBiZWZvcmUgb3IgYWZ0ZXIgaXQsIGFuZCBtb3ZlIGl0IHVwIHRoZSB0cmVlIHRvXG4gICAgdGhlIGRlcHRoIHNwZWNpZmllZCBieSBgdGFyZ2V0YC4gWW91J2xsIHByb2JhYmx5IHdhbnQgdG8gdXNlXG4gICAgW2BsaWZ0VGFyZ2V0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5saWZ0VGFyZ2V0KSB0byBjb21wdXRlIGB0YXJnZXRgLCB0byBtYWtlXG4gICAgc3VyZSB0aGUgbGlmdCBpcyB2YWxpZC5cbiAgICAqL1xuICAgIGxpZnQocmFuZ2UsIHRhcmdldCkge1xuICAgICAgICBsaWZ0KHRoaXMsIHJhbmdlLCB0YXJnZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgSm9pbiB0aGUgYmxvY2tzIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uIElmIGRlcHRoIGlzIDIsIHRoZWlyXG4gICAgbGFzdCBhbmQgZmlyc3Qgc2libGluZ3MgYXJlIGFsc28gam9pbmVkLCBhbmQgc28gb24uXG4gICAgKi9cbiAgICBqb2luKHBvcywgZGVwdGggPSAxKSB7XG4gICAgICAgIGpvaW4odGhpcywgcG9zLCBkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBXcmFwIHRoZSBnaXZlbiBbcmFuZ2VdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlUmFuZ2UpIGluIHRoZSBnaXZlbiBzZXQgb2Ygd3JhcHBlcnMuXG4gICAgVGhlIHdyYXBwZXJzIGFyZSBhc3N1bWVkIHRvIGJlIHZhbGlkIGluIHRoaXMgcG9zaXRpb24sIGFuZCBzaG91bGRcbiAgICBwcm9iYWJseSBiZSBjb21wdXRlZCB3aXRoIFtgZmluZFdyYXBwaW5nYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5maW5kV3JhcHBpbmcpLlxuICAgICovXG4gICAgd3JhcChyYW5nZSwgd3JhcHBlcnMpIHtcbiAgICAgICAgd3JhcCh0aGlzLCByYW5nZSwgd3JhcHBlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB0eXBlIG9mIGFsbCB0ZXh0YmxvY2tzIChwYXJ0bHkpIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIHRvXG4gICAgdGhlIGdpdmVuIG5vZGUgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgc2V0QmxvY2tUeXBlKGZyb20sIHRvID0gZnJvbSwgdHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgICAgIHNldEJsb2NrVHlwZSh0aGlzLCBmcm9tLCB0bywgdHlwZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hhbmdlIHRoZSB0eXBlLCBhdHRyaWJ1dGVzLCBhbmQvb3IgbWFya3Mgb2YgdGhlIG5vZGUgYXQgYHBvc2AuXG4gICAgV2hlbiBgdHlwZWAgaXNuJ3QgZ2l2ZW4sIHRoZSBleGlzdGluZyBub2RlIHR5cGUgaXMgcHJlc2VydmVkLFxuICAgICovXG4gICAgc2V0Tm9kZU1hcmt1cChwb3MsIHR5cGUsIGF0dHJzID0gbnVsbCwgbWFya3MpIHtcbiAgICAgICAgc2V0Tm9kZU1hcmt1cCh0aGlzLCBwb3MsIHR5cGUsIGF0dHJzLCBtYXJrcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgYSBzaW5nbGUgYXR0cmlidXRlIG9uIGEgZ2l2ZW4gbm9kZSB0byBhIG5ldyB2YWx1ZS5cbiAgICBUaGUgYHBvc2AgYWRkcmVzc2VzIHRoZSBkb2N1bWVudCBjb250ZW50LiBVc2UgYHNldERvY0F0dHJpYnV0ZWBcbiAgICB0byBzZXQgYXR0cmlidXRlcyBvbiB0aGUgZG9jdW1lbnQgaXRzZWxmLlxuICAgICovXG4gICAgc2V0Tm9kZUF0dHJpYnV0ZShwb3MsIGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RlcChuZXcgQXR0clN0ZXAocG9zLCBhdHRyLCB2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IGEgc2luZ2xlIGF0dHJpYnV0ZSBvbiB0aGUgZG9jdW1lbnQgdG8gYSBuZXcgdmFsdWUuXG4gICAgKi9cbiAgICBzZXREb2NBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdGVwKG5ldyBEb2NBdHRyU3RlcChhdHRyLCB2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgbWFyayB0byB0aGUgbm9kZSBhdCBwb3NpdGlvbiBgcG9zYC5cbiAgICAqL1xuICAgIGFkZE5vZGVNYXJrKHBvcywgbWFyaykge1xuICAgICAgICB0aGlzLnN0ZXAobmV3IEFkZE5vZGVNYXJrU3RlcChwb3MsIG1hcmspKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSBhIG1hcmsgKG9yIGEgbWFyayBvZiB0aGUgZ2l2ZW4gdHlwZSkgZnJvbSB0aGUgbm9kZSBhdFxuICAgIHBvc2l0aW9uIGBwb3NgLlxuICAgICovXG4gICAgcmVtb3ZlTm9kZU1hcmsocG9zLCBtYXJrKSB7XG4gICAgICAgIGlmICghKG1hcmsgaW5zdGFuY2VvZiBNYXJrKSkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmRvYy5ub2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYXQgcG9zaXRpb24gXCIgKyBwb3MpO1xuICAgICAgICAgICAgbWFyayA9IG1hcmsuaXNJblNldChub2RlLm1hcmtzKTtcbiAgICAgICAgICAgIGlmICghbWFyaylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0ZXAobmV3IFJlbW92ZU5vZGVNYXJrU3RlcChwb3MsIG1hcmspKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNwbGl0IHRoZSBub2RlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgYW5kIG9wdGlvbmFsbHksIGlmIGBkZXB0aGAgaXNcbiAgICBncmVhdGVyIHRoYW4gb25lLCBhbnkgbnVtYmVyIG9mIG5vZGVzIGFib3ZlIHRoYXQuIEJ5IGRlZmF1bHQsIHRoZVxuICAgIHBhcnRzIHNwbGl0IG9mZiB3aWxsIGluaGVyaXQgdGhlIG5vZGUgdHlwZSBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICBUaGlzIGNhbiBiZSBjaGFuZ2VkIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgdHlwZXMgYW5kIGF0dHJpYnV0ZXMgdG9cbiAgICB1c2UgYWZ0ZXIgdGhlIHNwbGl0LlxuICAgICovXG4gICAgc3BsaXQocG9zLCBkZXB0aCA9IDEsIHR5cGVzQWZ0ZXIpIHtcbiAgICAgICAgc3BsaXQodGhpcywgcG9zLCBkZXB0aCwgdHlwZXNBZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgdGhlIGdpdmVuIG1hcmsgdG8gdGhlIGlubGluZSBjb250ZW50IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLlxuICAgICovXG4gICAgYWRkTWFyayhmcm9tLCB0bywgbWFyaykge1xuICAgICAgICBhZGRNYXJrKHRoaXMsIGZyb20sIHRvLCBtYXJrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSBtYXJrcyBmcm9tIGlubGluZSBub2RlcyBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC4gV2hlblxuICAgIGBtYXJrYCBpcyBhIHNpbmdsZSBtYXJrLCByZW1vdmUgcHJlY2lzZWx5IHRoYXQgbWFyay4gV2hlbiBpdCBpc1xuICAgIGEgbWFyayB0eXBlLCByZW1vdmUgYWxsIG1hcmtzIG9mIHRoYXQgdHlwZS4gV2hlbiBpdCBpcyBudWxsLFxuICAgIHJlbW92ZSBhbGwgbWFya3Mgb2YgYW55IHR5cGUuXG4gICAgKi9cbiAgICByZW1vdmVNYXJrKGZyb20sIHRvLCBtYXJrKSB7XG4gICAgICAgIHJlbW92ZU1hcmsodGhpcywgZnJvbSwgdG8sIG1hcmspO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyBhbGwgbWFya3MgYW5kIG5vZGVzIGZyb20gdGhlIGNvbnRlbnQgb2YgdGhlIG5vZGUgYXRcbiAgICBgcG9zYCB0aGF0IGRvbid0IG1hdGNoIHRoZSBnaXZlbiBuZXcgcGFyZW50IG5vZGUgdHlwZS4gQWNjZXB0c1xuICAgIGFuIG9wdGlvbmFsIHN0YXJ0aW5nIFtjb250ZW50IG1hdGNoXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuQ29udGVudE1hdGNoKSBhc1xuICAgIHRoaXJkIGFyZ3VtZW50LlxuICAgICovXG4gICAgY2xlYXJJbmNvbXBhdGlibGUocG9zLCBwYXJlbnRUeXBlLCBtYXRjaCkge1xuICAgICAgICBjbGVhckluY29tcGF0aWJsZSh0aGlzLCBwb3MsIHBhcmVudFR5cGUsIG1hdGNoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5leHBvcnQgeyBBZGRNYXJrU3RlcCwgQWRkTm9kZU1hcmtTdGVwLCBBdHRyU3RlcCwgRG9jQXR0clN0ZXAsIE1hcFJlc3VsdCwgTWFwcGluZywgUmVtb3ZlTWFya1N0ZXAsIFJlbW92ZU5vZGVNYXJrU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIFJlcGxhY2VTdGVwLCBTdGVwLCBTdGVwTWFwLCBTdGVwUmVzdWx0LCBUcmFuc2Zvcm0sIFRyYW5zZm9ybUVycm9yLCBjYW5Kb2luLCBjYW5TcGxpdCwgZHJvcFBvaW50LCBmaW5kV3JhcHBpbmcsIGluc2VydFBvaW50LCBqb2luUG9pbnQsIGxpZnRUYXJnZXQsIHJlcGxhY2VTdGVwIH07XG4iLCAiaW1wb3J0IHsgU2xpY2UsIEZyYWdtZW50LCBNYXJrLCBOb2RlIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgUmVwbGFjZVN0ZXAsIFJlcGxhY2VBcm91bmRTdGVwLCBUcmFuc2Zvcm0gfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuXG5jb25zdCBjbGFzc2VzQnlJZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcblN1cGVyY2xhc3MgZm9yIGVkaXRvciBzZWxlY3Rpb25zLiBFdmVyeSBzZWxlY3Rpb24gdHlwZSBzaG91bGRcbmV4dGVuZCB0aGlzLiBTaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiovXG5jbGFzcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIEluaXRpYWxpemUgYSBzZWxlY3Rpb24gd2l0aCB0aGUgaGVhZCBhbmQgYW5jaG9yIGFuZCByYW5nZXMuIElmIG5vXG4gICAgcmFuZ2VzIGFyZSBnaXZlbiwgY29uc3RydWN0cyBhIHNpbmdsZSByYW5nZSBhY3Jvc3MgYCRhbmNob3JgIGFuZFxuICAgIGAkaGVhZGAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgYW5jaG9yIG9mIHRoZSBzZWxlY3Rpb24gKHRoZSBzaWRlIHRoYXQgc3RheXMgaW5cbiAgICBwbGFjZSB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgbW9kaWZpZWQpLlxuICAgICovXG4gICAgJGFuY2hvciwgXG4gICAgLyoqXG4gICAgVGhlIHJlc29sdmVkIGhlYWQgb2YgdGhlIHNlbGVjdGlvbiAodGhlIHNpZGUgdGhhdCBtb3ZlcyB3aGVuXG4gICAgdGhlIHNlbGVjdGlvbiBpcyBtb2RpZmllZCkuXG4gICAgKi9cbiAgICAkaGVhZCwgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMuJGFuY2hvciA9ICRhbmNob3I7XG4gICAgICAgIHRoaXMuJGhlYWQgPSAkaGVhZDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXMgfHwgW25ldyBTZWxlY3Rpb25SYW5nZSgkYW5jaG9yLm1pbigkaGVhZCksICRhbmNob3IubWF4KCRoZWFkKSldO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2VsZWN0aW9uJ3MgYW5jaG9yLCBhcyBhbiB1bnJlc29sdmVkIHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IGFuY2hvcigpIHsgcmV0dXJuIHRoaXMuJGFuY2hvci5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgc2VsZWN0aW9uJ3MgaGVhZC5cbiAgICAqL1xuICAgIGdldCBoZWFkKCkgeyByZXR1cm4gdGhpcy4kaGVhZC5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgbG93ZXIgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuJGZyb20ucG9zOyB9XG4gICAgLyoqXG4gICAgVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy4kdG8ucG9zOyB9XG4gICAgLyoqXG4gICAgVGhlIHJlc29sdmVkIGxvd2VyICBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCAkZnJvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzWzBdLiRmcm9tO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgdXBwZXIgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgJHRvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbMF0uJHRvO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc2VsZWN0aW9uIGNvbnRhaW5zIGFueSBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHJhbmdlc1tpXS4kZnJvbS5wb3MgIT0gcmFuZ2VzW2ldLiR0by5wb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb250ZW50IG9mIHRoaXMgc2VsZWN0aW9uIGFzIGEgc2xpY2UuXG4gICAgKi9cbiAgICBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZnJvbS5kb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBzbGljZSBvciwgaWYgbm8gc2xpY2UgaXMgZ2l2ZW4sXG4gICAgZGVsZXRlIHRoZSBzZWxlY3Rpb24uIFdpbGwgYXBwZW5kIHRvIHRoZSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHJlcGxhY2UodHIsIGNvbnRlbnQgPSBTbGljZS5lbXB0eSkge1xuICAgICAgICAvLyBQdXQgdGhlIG5ldyBzZWxlY3Rpb24gYXQgdGhlIHBvc2l0aW9uIGFmdGVyIHRoZSBpbnNlcnRlZFxuICAgICAgICAvLyBjb250ZW50LiBXaGVuIHRoYXQgZW5kZWQgaW4gYW4gaW5saW5lIG5vZGUsIHNlYXJjaCBiYWNrd2FyZHMsXG4gICAgICAgIC8vIHRvIGdldCB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhhdCBub2RlLiBJZiBub3QsIHNlYXJjaCBmb3J3YXJkLlxuICAgICAgICBsZXQgbGFzdE5vZGUgPSBjb250ZW50LmNvbnRlbnQubGFzdENoaWxkLCBsYXN0UGFyZW50ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50Lm9wZW5FbmQ7IGkrKykge1xuICAgICAgICAgICAgbGFzdFBhcmVudCA9IGxhc3ROb2RlO1xuICAgICAgICAgICAgbGFzdE5vZGUgPSBsYXN0Tm9kZS5sYXN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGgsIHJhbmdlcyA9IHRoaXMucmFuZ2VzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldLCBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICAgICAgICAgIHRyLnJlcGxhY2VSYW5nZShtYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCBtYXBwaW5nLm1hcCgkdG8ucG9zKSwgaSA/IFNsaWNlLmVtcHR5IDogY29udGVudCk7XG4gICAgICAgICAgICBpZiAoaSA9PSAwKVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBtYXBGcm9tLCAobGFzdE5vZGUgPyBsYXN0Tm9kZS5pc0lubGluZSA6IGxhc3RQYXJlbnQgJiYgbGFzdFBhcmVudC5pc1RleHRibG9jaykgPyAtMSA6IDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIHRoZSBnaXZlbiBub2RlLCBhcHBlbmRpbmcgdGhlIGNoYW5nZXNcbiAgICB0byB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICByZXBsYWNlV2l0aCh0ciwgbm9kZSkge1xuICAgICAgICBsZXQgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aCwgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV0sIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCB0byA9IG1hcHBpbmcubWFwKCR0by5wb3MpO1xuICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICB0ci5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ci5yZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBub2RlKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgbWFwRnJvbSwgbm9kZS5pc0lubGluZSA/IC0xIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhIHZhbGlkIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIHN0YXJ0aW5nIGF0IHRoZSBnaXZlblxuICAgIHBvc2l0aW9uIGFuZCBzZWFyY2hpbmcgYmFjayBpZiBgZGlyYCBpcyBuZWdhdGl2ZSwgYW5kIGZvcndhcmQgaWZcbiAgICBwb3NpdGl2ZS4gV2hlbiBgdGV4dE9ubHlgIGlzIHRydWUsIG9ubHkgY29uc2lkZXIgY3Vyc29yXG4gICAgc2VsZWN0aW9ucy4gV2lsbCByZXR1cm4gbnVsbCB3aGVuIG5vIHZhbGlkIHNlbGVjdGlvbiBwb3NpdGlvbiBpc1xuICAgIGZvdW5kLlxuICAgICovXG4gICAgc3RhdGljIGZpbmRGcm9tKCRwb3MsIGRpciwgdGV4dE9ubHkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgaW5uZXIgPSAkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50ID8gbmV3IFRleHRTZWxlY3Rpb24oJHBvcylcbiAgICAgICAgICAgIDogZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5wYXJlbnQsICRwb3MucG9zLCAkcG9zLmluZGV4KCksIGRpciwgdGV4dE9ubHkpO1xuICAgICAgICBpZiAoaW5uZXIpXG4gICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gJHBvcy5kZXB0aCAtIDE7IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGRpciA8IDBcbiAgICAgICAgICAgICAgICA/IGZpbmRTZWxlY3Rpb25JbigkcG9zLm5vZGUoMCksICRwb3Mubm9kZShkZXB0aCksICRwb3MuYmVmb3JlKGRlcHRoICsgMSksICRwb3MuaW5kZXgoZGVwdGgpLCBkaXIsIHRleHRPbmx5KVxuICAgICAgICAgICAgICAgIDogZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5ub2RlKGRlcHRoKSwgJHBvcy5hZnRlcihkZXB0aCArIDEpLCAkcG9zLmluZGV4KGRlcHRoKSArIDEsIGRpciwgdGV4dE9ubHkpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhIHZhbGlkIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIG5lYXIgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24uIFNlYXJjaGVzIGZvcndhcmQgZmlyc3QgYnkgZGVmYXVsdCwgYnV0IGlmIGBiaWFzYCBpc1xuICAgIG5lZ2F0aXZlLCBpdCB3aWxsIHNlYXJjaCBiYWNrd2FyZHMgZmlyc3QuXG4gICAgKi9cbiAgICBzdGF0aWMgbmVhcigkcG9zLCBiaWFzID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kRnJvbSgkcG9zLCBiaWFzKSB8fCB0aGlzLmZpbmRGcm9tKCRwb3MsIC1iaWFzKSB8fCBuZXcgQWxsU2VsZWN0aW9uKCRwb3Mubm9kZSgwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIGNsb3Nlc3QgdG8gdGhlIHN0YXJ0IG9mXG4gICAgdGhlIGdpdmVuIGRvY3VtZW50LiBXaWxsIHJldHVybiBhblxuICAgIFtgQWxsU2VsZWN0aW9uYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkFsbFNlbGVjdGlvbikgaWYgbm8gdmFsaWQgcG9zaXRpb25cbiAgICBleGlzdHMuXG4gICAgKi9cbiAgICBzdGF0aWMgYXRTdGFydChkb2MpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRTZWxlY3Rpb25Jbihkb2MsIGRvYywgMCwgMCwgMSkgfHwgbmV3IEFsbFNlbGVjdGlvbihkb2MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjdXJzb3Igb3IgbGVhZiBub2RlIHNlbGVjdGlvbiBjbG9zZXN0IHRvIHRoZSBlbmQgb2YgdGhlXG4gICAgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgYXRFbmQoZG9jKSB7XG4gICAgICAgIHJldHVybiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBkb2MsIGRvYy5jb250ZW50LnNpemUsIGRvYy5jaGlsZENvdW50LCAtMSkgfHwgbmV3IEFsbFNlbGVjdGlvbihkb2MpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHNlbGVjdGlvbi4gTXVzdCBiZVxuICAgIGltcGxlbWVudGVkIGZvciBjdXN0b20gY2xhc3NlcyAoYXMgYSBzdGF0aWMgY2xhc3MgbWV0aG9kKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8ICFqc29uLnR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFNlbGVjdGlvbi5mcm9tSlNPTlwiKTtcbiAgICAgICAgbGV0IGNscyA9IGNsYXNzZXNCeUlkW2pzb24udHlwZV07XG4gICAgICAgIGlmICghY2xzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE5vIHNlbGVjdGlvbiB0eXBlICR7anNvbi50eXBlfSBkZWZpbmVkYCk7XG4gICAgICAgIHJldHVybiBjbHMuZnJvbUpTT04oZG9jLCBqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVG8gYmUgYWJsZSB0byBkZXNlcmlhbGl6ZSBzZWxlY3Rpb25zIGZyb20gSlNPTiwgY3VzdG9tIHNlbGVjdGlvblxuICAgIGNsYXNzZXMgbXVzdCByZWdpc3RlciB0aGVtc2VsdmVzIHdpdGggYW4gSUQgc3RyaW5nLCBzbyB0aGF0IHRoZXlcbiAgICBjYW4gYmUgZGlzYW1iaWd1YXRlZC4gVHJ5IHRvIHBpY2sgc29tZXRoaW5nIHRoYXQncyB1bmxpa2VseSB0b1xuICAgIGNsYXNoIHdpdGggY2xhc3NlcyBmcm9tIG90aGVyIG1vZHVsZXMuXG4gICAgKi9cbiAgICBzdGF0aWMganNvbklEKGlkLCBzZWxlY3Rpb25DbGFzcykge1xuICAgICAgICBpZiAoaWQgaW4gY2xhc3Nlc0J5SWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkR1cGxpY2F0ZSB1c2Ugb2Ygc2VsZWN0aW9uIEpTT04gSUQgXCIgKyBpZCk7XG4gICAgICAgIGNsYXNzZXNCeUlkW2lkXSA9IHNlbGVjdGlvbkNsYXNzO1xuICAgICAgICBzZWxlY3Rpb25DbGFzcy5wcm90b3R5cGUuanNvbklEID0gaWQ7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25DbGFzcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW2Jvb2ttYXJrXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uQm9va21hcmspIGZvciB0aGlzIHNlbGVjdGlvbixcbiAgICB3aGljaCBpcyBhIHZhbHVlIHRoYXQgY2FuIGJlIG1hcHBlZCB3aXRob3V0IGhhdmluZyBhY2Nlc3MgdG8gYVxuICAgIGN1cnJlbnQgZG9jdW1lbnQsIGFuZCBsYXRlciByZXNvbHZlZCB0byBhIHJlYWwgc2VsZWN0aW9uIGZvciBhXG4gICAgZ2l2ZW4gZG9jdW1lbnQgYWdhaW4uIChUaGlzIGlzIHVzZWQgbW9zdGx5IGJ5IHRoZSBoaXN0b3J5IHRvXG4gICAgdHJhY2sgYW5kIHJlc3RvcmUgb2xkIHNlbGVjdGlvbnMuKSBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZlxuICAgIHRoaXMgbWV0aG9kIGp1c3QgY29udmVydHMgdGhlIHNlbGVjdGlvbiB0byBhIHRleHQgc2VsZWN0aW9uIGFuZFxuICAgIHJldHVybnMgdGhlIGJvb2ttYXJrIGZvciB0aGF0LlxuICAgICovXG4gICAgZ2V0Qm9va21hcmsoKSB7XG4gICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmJldHdlZW4odGhpcy4kYW5jaG9yLCB0aGlzLiRoZWFkKS5nZXRCb29rbWFyaygpO1xuICAgIH1cbn1cblNlbGVjdGlvbi5wcm90b3R5cGUudmlzaWJsZSA9IHRydWU7XG4vKipcblJlcHJlc2VudHMgYSBzZWxlY3RlZCByYW5nZSBpbiBhIGRvY3VtZW50LlxuKi9cbmNsYXNzIFNlbGVjdGlvblJhbmdlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSByYW5nZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsb3dlciBib3VuZCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICAkZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgICR0bykge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgIH1cbn1cbmxldCB3YXJuZWRBYm91dFRleHRTZWxlY3Rpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGNoZWNrVGV4dFNlbGVjdGlvbigkcG9zKSB7XG4gICAgaWYgKCF3YXJuZWRBYm91dFRleHRTZWxlY3Rpb24gJiYgISRwb3MucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgd2FybmVkQWJvdXRUZXh0U2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZVtcIndhcm5cIl0oXCJUZXh0U2VsZWN0aW9uIGVuZHBvaW50IG5vdCBwb2ludGluZyBpbnRvIGEgbm9kZSB3aXRoIGlubGluZSBjb250ZW50IChcIiArICRwb3MucGFyZW50LnR5cGUubmFtZSArIFwiKVwiKTtcbiAgICB9XG59XG4vKipcbkEgdGV4dCBzZWxlY3Rpb24gcmVwcmVzZW50cyBhIGNsYXNzaWNhbCBlZGl0b3Igc2VsZWN0aW9uLCB3aXRoIGFcbmhlYWQgKHRoZSBtb3Zpbmcgc2lkZSkgYW5kIGFuY2hvciAoaW1tb2JpbGUgc2lkZSksIGJvdGggb2Ygd2hpY2hcbnBvaW50IGludG8gdGV4dGJsb2NrIG5vZGVzLiBJdCBjYW4gYmUgZW1wdHkgKGEgcmVndWxhciBjdXJzb3JcbnBvc2l0aW9uKS5cbiovXG5jbGFzcyBUZXh0U2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSB0ZXh0IHNlbGVjdGlvbiBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludHMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigkYW5jaG9yLCAkaGVhZCA9ICRhbmNob3IpIHtcbiAgICAgICAgY2hlY2tUZXh0U2VsZWN0aW9uKCRhbmNob3IpO1xuICAgICAgICBjaGVja1RleHRTZWxlY3Rpb24oJGhlYWQpO1xuICAgICAgICBzdXBlcigkYW5jaG9yLCAkaGVhZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSByZXNvbHZlZCBwb3NpdGlvbiBpZiB0aGlzIGlzIGEgY3Vyc29yIHNlbGVjdGlvbiAoYW5cbiAgICBlbXB0eSB0ZXh0IHNlbGVjdGlvbiksIGFuZCBudWxsIG90aGVyd2lzZS5cbiAgICAqL1xuICAgIGdldCAkY3Vyc29yKCkgeyByZXR1cm4gdGhpcy4kYW5jaG9yLnBvcyA9PSB0aGlzLiRoZWFkLnBvcyA/IHRoaXMuJGhlYWQgOiBudWxsOyB9XG4gICAgbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgICBsZXQgJGhlYWQgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICAgICAgaWYgKCEkaGVhZC5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkaGVhZCk7XG4gICAgICAgIGxldCAkYW5jaG9yID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy5hbmNob3IpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0U2VsZWN0aW9uKCRhbmNob3IucGFyZW50LmlubGluZUNvbnRlbnQgPyAkYW5jaG9yIDogJGhlYWQsICRoZWFkKTtcbiAgICB9XG4gICAgcmVwbGFjZSh0ciwgY29udGVudCA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIHN1cGVyLnJlcGxhY2UodHIsIGNvbnRlbnQpO1xuICAgICAgICBpZiAoY29udGVudCA9PSBTbGljZS5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IG1hcmtzID0gdGhpcy4kZnJvbS5tYXJrc0Fjcm9zcyh0aGlzLiR0byk7XG4gICAgICAgICAgICBpZiAobWFya3MpXG4gICAgICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MobWFya3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgb3RoZXIuYW5jaG9yID09IHRoaXMuYW5jaG9yICYmIG90aGVyLmhlYWQgPT0gdGhpcy5oZWFkO1xuICAgIH1cbiAgICBnZXRCb29rbWFyaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Qm9va21hcmsodGhpcy5hbmNob3IsIHRoaXMuaGVhZCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIGFuY2hvcjogdGhpcy5hbmNob3IsIGhlYWQ6IHRoaXMuaGVhZCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmhlYWQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgVGV4dFNlbGVjdGlvbi5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0U2VsZWN0aW9uKGRvYy5yZXNvbHZlKGpzb24uYW5jaG9yKSwgZG9jLnJlc29sdmUoanNvbi5oZWFkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRleHQgc2VsZWN0aW9uIGZyb20gbm9uLXJlc29sdmVkIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZG9jLCBhbmNob3IsIGhlYWQgPSBhbmNob3IpIHtcbiAgICAgICAgbGV0ICRhbmNob3IgPSBkb2MucmVzb2x2ZShhbmNob3IpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoJGFuY2hvciwgaGVhZCA9PSBhbmNob3IgPyAkYW5jaG9yIDogZG9jLnJlc29sdmUoaGVhZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSB0ZXh0IHNlbGVjdGlvbiB0aGF0IHNwYW5zIHRoZSBnaXZlbiBwb3NpdGlvbnMgb3IsIGlmXG4gICAgdGhleSBhcmVuJ3QgdGV4dCBwb3NpdGlvbnMsIGZpbmQgYSB0ZXh0IHNlbGVjdGlvbiBuZWFyIHRoZW0uXG4gICAgYGJpYXNgIGRldGVybWluZXMgd2hldGhlciB0aGUgbWV0aG9kIHNlYXJjaGVzIGZvcndhcmQgKGRlZmF1bHQpXG4gICAgb3IgYmFja3dhcmRzIChuZWdhdGl2ZSBudW1iZXIpIGZpcnN0LiBXaWxsIGZhbGwgYmFjayB0byBjYWxsaW5nXG4gICAgW2BTZWxlY3Rpb24ubmVhcmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25ebmVhcikgd2hlbiB0aGUgZG9jdW1lbnRcbiAgICBkb2Vzbid0IGNvbnRhaW4gYSB2YWxpZCB0ZXh0IHBvc2l0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGJldHdlZW4oJGFuY2hvciwgJGhlYWQsIGJpYXMpIHtcbiAgICAgICAgbGV0IGRQb3MgPSAkYW5jaG9yLnBvcyAtICRoZWFkLnBvcztcbiAgICAgICAgaWYgKCFiaWFzIHx8IGRQb3MpXG4gICAgICAgICAgICBiaWFzID0gZFBvcyA+PSAwID8gMSA6IC0xO1xuICAgICAgICBpZiAoISRoZWFkLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBTZWxlY3Rpb24uZmluZEZyb20oJGhlYWQsIGJpYXMsIHRydWUpIHx8IFNlbGVjdGlvbi5maW5kRnJvbSgkaGVhZCwgLWJpYXMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICRoZWFkID0gZm91bmQuJGhlYWQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRoZWFkLCBiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISRhbmNob3IucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmIChkUG9zID09IDApIHtcbiAgICAgICAgICAgICAgICAkYW5jaG9yID0gJGhlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAkYW5jaG9yID0gKFNlbGVjdGlvbi5maW5kRnJvbSgkYW5jaG9yLCAtYmlhcywgdHJ1ZSkgfHwgU2VsZWN0aW9uLmZpbmRGcm9tKCRhbmNob3IsIGJpYXMsIHRydWUpKS4kYW5jaG9yO1xuICAgICAgICAgICAgICAgIGlmICgoJGFuY2hvci5wb3MgPCAkaGVhZC5wb3MpICE9IChkUG9zIDwgMCkpXG4gICAgICAgICAgICAgICAgICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oJGFuY2hvciwgJGhlYWQpO1xuICAgIH1cbn1cblNlbGVjdGlvbi5qc29uSUQoXCJ0ZXh0XCIsIFRleHRTZWxlY3Rpb24pO1xuY2xhc3MgVGV4dEJvb2ttYXJrIHtcbiAgICBjb25zdHJ1Y3RvcihhbmNob3IsIGhlYWQpIHtcbiAgICAgICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgICAgIHRoaXMuaGVhZCA9IGhlYWQ7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEJvb2ttYXJrKG1hcHBpbmcubWFwKHRoaXMuYW5jaG9yKSwgbWFwcGluZy5tYXAodGhpcy5oZWFkKSk7XG4gICAgfVxuICAgIHJlc29sdmUoZG9jKSB7XG4gICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmJldHdlZW4oZG9jLnJlc29sdmUodGhpcy5hbmNob3IpLCBkb2MucmVzb2x2ZSh0aGlzLmhlYWQpKTtcbiAgICB9XG59XG4vKipcbkEgbm9kZSBzZWxlY3Rpb24gaXMgYSBzZWxlY3Rpb24gdGhhdCBwb2ludHMgYXQgYSBzaW5nbGUgbm9kZS4gQWxsXG5ub2RlcyBtYXJrZWQgW3NlbGVjdGFibGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5zZWxlY3RhYmxlKSBjYW4gYmUgdGhlXG50YXJnZXQgb2YgYSBub2RlIHNlbGVjdGlvbi4gSW4gc3VjaCBhIHNlbGVjdGlvbiwgYGZyb21gIGFuZCBgdG9gXG5wb2ludCBkaXJlY3RseSBiZWZvcmUgYW5kIGFmdGVyIHRoZSBzZWxlY3RlZCBub2RlLCBgYW5jaG9yYCBlcXVhbHNcbmBmcm9tYCwgYW5kIGBoZWFkYCBlcXVhbHMgYHRvYC4uXG4qL1xuY2xhc3MgTm9kZVNlbGVjdGlvbiBleHRlbmRzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBzZWxlY3Rpb24uIERvZXMgbm90IHZlcmlmeSB0aGUgdmFsaWRpdHkgb2YgaXRzXG4gICAgYXJndW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigkcG9zKSB7XG4gICAgICAgIGxldCBub2RlID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgIGxldCAkZW5kID0gJHBvcy5ub2RlKDApLnJlc29sdmUoJHBvcy5wb3MgKyBub2RlLm5vZGVTaXplKTtcbiAgICAgICAgc3VwZXIoJHBvcywgJGVuZCk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfVxuICAgIG1hcChkb2MsIG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHsgZGVsZXRlZCwgcG9zIH0gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmFuY2hvcik7XG4gICAgICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICAgICAgaWYgKGRlbGV0ZWQpXG4gICAgICAgICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKTtcbiAgICB9XG4gICAgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHRoaXMubm9kZSksIDAsIDApO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIG90aGVyLmFuY2hvciA9PSB0aGlzLmFuY2hvcjtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm5vZGVcIiwgYW5jaG9yOiB0aGlzLmFuY2hvciB9O1xuICAgIH1cbiAgICBnZXRCb29rbWFyaygpIHsgcmV0dXJuIG5ldyBOb2RlQm9va21hcmsodGhpcy5hbmNob3IpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTm9kZVNlbGVjdGlvbi5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKGRvYy5yZXNvbHZlKGpzb24uYW5jaG9yKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5vZGUgc2VsZWN0aW9uIGZyb20gbm9uLXJlc29sdmVkIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZG9jLCBmcm9tKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbihkb2MucmVzb2x2ZShmcm9tKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gbm9kZSBtYXkgYmUgc2VsZWN0ZWQgYXMgYSBub2RlXG4gICAgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGlzU2VsZWN0YWJsZShub2RlKSB7XG4gICAgICAgIHJldHVybiAhbm9kZS5pc1RleHQgJiYgbm9kZS50eXBlLnNwZWMuc2VsZWN0YWJsZSAhPT0gZmFsc2U7XG4gICAgfVxufVxuTm9kZVNlbGVjdGlvbi5wcm90b3R5cGUudmlzaWJsZSA9IGZhbHNlO1xuU2VsZWN0aW9uLmpzb25JRChcIm5vZGVcIiwgTm9kZVNlbGVjdGlvbik7XG5jbGFzcyBOb2RlQm9va21hcmsge1xuICAgIGNvbnN0cnVjdG9yKGFuY2hvcikge1xuICAgICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHsgZGVsZXRlZCwgcG9zIH0gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmFuY2hvcik7XG4gICAgICAgIHJldHVybiBkZWxldGVkID8gbmV3IFRleHRCb29rbWFyayhwb3MsIHBvcykgOiBuZXcgTm9kZUJvb2ttYXJrKHBvcyk7XG4gICAgfVxuICAgIHJlc29sdmUoZG9jKSB7XG4gICAgICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUodGhpcy5hbmNob3IpLCBub2RlID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgIGlmIChub2RlICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpO1xuICAgICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgfVxufVxuLyoqXG5BIHNlbGVjdGlvbiB0eXBlIHRoYXQgcmVwcmVzZW50cyBzZWxlY3RpbmcgdGhlIHdob2xlIGRvY3VtZW50XG4od2hpY2ggY2FuIG5vdCBuZWNlc3NhcmlseSBiZSBleHByZXNzZWQgd2l0aCBhIHRleHQgc2VsZWN0aW9uLCB3aGVuXG50aGVyZSBhcmUgZm9yIGV4YW1wbGUgbGVhZiBibG9jayBub2RlcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZVxuZG9jdW1lbnQpLlxuKi9cbmNsYXNzIEFsbFNlbGVjdGlvbiBleHRlbmRzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGFsbC1zZWxlY3Rpb24gb3ZlciB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihkb2MpIHtcbiAgICAgICAgc3VwZXIoZG9jLnJlc29sdmUoMCksIGRvYy5yZXNvbHZlKGRvYy5jb250ZW50LnNpemUpKTtcbiAgICB9XG4gICAgcmVwbGFjZSh0ciwgY29udGVudCA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIGlmIChjb250ZW50ID09IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgICAgICB0ci5kZWxldGUoMCwgdHIuZG9jLmNvbnRlbnQuc2l6ZSk7XG4gICAgICAgICAgICBsZXQgc2VsID0gU2VsZWN0aW9uLmF0U3RhcnQodHIuZG9jKTtcbiAgICAgICAgICAgIGlmICghc2VsLmVxKHRyLnNlbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5yZXBsYWNlKHRyLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7IHJldHVybiB7IHR5cGU6IFwiYWxsXCIgfTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYykgeyByZXR1cm4gbmV3IEFsbFNlbGVjdGlvbihkb2MpOyB9XG4gICAgbWFwKGRvYykgeyByZXR1cm4gbmV3IEFsbFNlbGVjdGlvbihkb2MpOyB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uOyB9XG4gICAgZ2V0Qm9va21hcmsoKSB7IHJldHVybiBBbGxCb29rbWFyazsgfVxufVxuU2VsZWN0aW9uLmpzb25JRChcImFsbFwiLCBBbGxTZWxlY3Rpb24pO1xuY29uc3QgQWxsQm9va21hcmsgPSB7XG4gICAgbWFwKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICByZXNvbHZlKGRvYykgeyByZXR1cm4gbmV3IEFsbFNlbGVjdGlvbihkb2MpOyB9XG59O1xuLy8gRklYTUUgd2UnbGwgbmVlZCBzb21lIGF3YXJlbmVzcyBvZiB0ZXh0IGRpcmVjdGlvbiB3aGVuIHNjYW5uaW5nIGZvciBzZWxlY3Rpb25zXG4vLyBUcnkgdG8gZmluZCBhIHNlbGVjdGlvbiBpbnNpZGUgdGhlIGdpdmVuIG5vZGUuIGBwb3NgIHBvaW50cyBhdCB0aGVcbi8vIHBvc2l0aW9uIHdoZXJlIHRoZSBzZWFyY2ggc3RhcnRzLiBXaGVuIGB0ZXh0YCBpcyB0cnVlLCBvbmx5IHJldHVyblxuLy8gdGV4dCBzZWxlY3Rpb25zLlxuZnVuY3Rpb24gZmluZFNlbGVjdGlvbkluKGRvYywgbm9kZSwgcG9zLCBpbmRleCwgZGlyLCB0ZXh0ID0gZmFsc2UpIHtcbiAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50KVxuICAgICAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBwb3MpO1xuICAgIGZvciAobGV0IGkgPSBpbmRleCAtIChkaXIgPiAwID8gMCA6IDEpOyBkaXIgPiAwID8gaSA8IG5vZGUuY2hpbGRDb3VudCA6IGkgPj0gMDsgaSArPSBkaXIpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5jaGlsZChpKTtcbiAgICAgICAgaWYgKCFjaGlsZC5pc0F0b20pIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGZpbmRTZWxlY3Rpb25Jbihkb2MsIGNoaWxkLCBwb3MgKyBkaXIsIGRpciA8IDAgPyBjaGlsZC5jaGlsZENvdW50IDogMCwgZGlyLCB0ZXh0KTtcbiAgICAgICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRleHQgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoY2hpbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gTm9kZVNlbGVjdGlvbi5jcmVhdGUoZG9jLCBwb3MgLSAoZGlyIDwgMCA/IGNoaWxkLm5vZGVTaXplIDogMCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjaGlsZC5ub2RlU2l6ZSAqIGRpcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgc3RhcnRMZW4sIGJpYXMpIHtcbiAgICBsZXQgbGFzdCA9IHRyLnN0ZXBzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3QgPCBzdGFydExlbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBzdGVwID0gdHIuc3RlcHNbbGFzdF07XG4gICAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwIHx8IHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlQXJvdW5kU3RlcCkpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbWFwID0gdHIubWFwcGluZy5tYXBzW2xhc3RdLCBlbmQ7XG4gICAgbWFwLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4geyBpZiAoZW5kID09IG51bGwpXG4gICAgICAgIGVuZCA9IG5ld1RvOyB9KTtcbiAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoZW5kKSwgYmlhcykpO1xufVxuXG5jb25zdCBVUERBVEVEX1NFTCA9IDEsIFVQREFURURfTUFSS1MgPSAyLCBVUERBVEVEX1NDUk9MTCA9IDQ7XG4vKipcbkFuIGVkaXRvciBzdGF0ZSB0cmFuc2FjdGlvbiwgd2hpY2ggY2FuIGJlIGFwcGxpZWQgdG8gYSBzdGF0ZSB0b1xuY3JlYXRlIGFuIHVwZGF0ZWQgc3RhdGUuIFVzZVxuW2BFZGl0b3JTdGF0ZS50cmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50cikgdG8gY3JlYXRlIGFuIGluc3RhbmNlLlxuXG5UcmFuc2FjdGlvbnMgdHJhY2sgY2hhbmdlcyB0byB0aGUgZG9jdW1lbnQgKHRoZXkgYXJlIGEgc3ViY2xhc3Mgb2ZcbltgVHJhbnNmb3JtYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5UcmFuc2Zvcm0pKSwgYnV0IGFsc28gb3RoZXIgc3RhdGUgY2hhbmdlcyxcbmxpa2Ugc2VsZWN0aW9uIHVwZGF0ZXMgYW5kIGFkanVzdG1lbnRzIG9mIHRoZSBzZXQgb2YgW3N0b3JlZFxubWFya3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5zdG9yZWRNYXJrcykuIEluIGFkZGl0aW9uLCB5b3UgY2FuIHN0b3JlXG5tZXRhZGF0YSBwcm9wZXJ0aWVzIGluIGEgdHJhbnNhY3Rpb24sIHdoaWNoIGFyZSBleHRyYSBwaWVjZXMgb2ZcbmluZm9ybWF0aW9uIHRoYXQgY2xpZW50IGNvZGUgb3IgcGx1Z2lucyBjYW4gdXNlIHRvIGRlc2NyaWJlIHdoYXQgYVxudHJhbnNhY3Rpb24gcmVwcmVzZW50cywgc28gdGhhdCB0aGV5IGNhbiB1cGRhdGUgdGhlaXIgW293blxuc3RhdGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUZpZWxkKSBhY2NvcmRpbmdseS5cblxuVGhlIFtlZGl0b3Igdmlld10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldykgdXNlcyBhIGZldyBtZXRhZGF0YVxucHJvcGVydGllczogaXQgd2lsbCBhdHRhY2ggYSBwcm9wZXJ0eSBgXCJwb2ludGVyXCJgIHdpdGggdGhlIHZhbHVlXG5gdHJ1ZWAgdG8gc2VsZWN0aW9uIHRyYW5zYWN0aW9ucyBkaXJlY3RseSBjYXVzZWQgYnkgbW91c2Ugb3IgdG91Y2hcbmlucHV0LCBhIGBcImNvbXBvc2l0aW9uXCJgIHByb3BlcnR5IGhvbGRpbmcgYW4gSUQgaWRlbnRpZnlpbmcgdGhlXG5jb21wb3NpdGlvbiB0aGF0IGNhdXNlZCBpdCB0byB0cmFuc2FjdGlvbnMgY2F1c2VkIGJ5IGNvbXBvc2VkIERPTVxuaW5wdXQsIGFuZCBhIGBcInVpRXZlbnRcImAgcHJvcGVydHkgb2YgdGhhdCBtYXkgYmUgYFwicGFzdGVcImAsXG5gXCJjdXRcImAsIG9yIGBcImRyb3BcImAuXG4qL1xuY2xhc3MgVHJhbnNhY3Rpb24gZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoc3RhdGUuZG9jKTtcbiAgICAgICAgLy8gVGhlIHN0ZXAgY291bnQgZm9yIHdoaWNoIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyB2YWxpZC5cbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb25Gb3IgPSAwO1xuICAgICAgICAvLyBCaXRmaWVsZCB0byB0cmFjayB3aGljaCBhc3BlY3RzIG9mIHRoZSBzdGF0ZSB3ZXJlIHVwZGF0ZWQgYnlcbiAgICAgICAgLy8gdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgICAgdGhpcy51cGRhdGVkID0gMDtcbiAgICAgICAgLy8gT2JqZWN0IHVzZWQgdG8gc3RvcmUgbWV0YWRhdGEgcHJvcGVydGllcyBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICB0aGlzLm1ldGEgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgdHJhbnNhY3Rpb24ncyBjdXJyZW50IHNlbGVjdGlvbi4gVGhpcyBkZWZhdWx0cyB0byB0aGUgZWRpdG9yXG4gICAgc2VsZWN0aW9uIFttYXBwZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb24ubWFwKSB0aHJvdWdoIHRoZSBzdGVwcyBpbiB0aGVcbiAgICB0cmFuc2FjdGlvbiwgYnV0IGNhbiBiZSBvdmVyd3JpdHRlbiB3aXRoXG4gICAgW2BzZXRTZWxlY3Rpb25gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc2V0U2VsZWN0aW9uKS5cbiAgICAqL1xuICAgIGdldCBzZWxlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmN1clNlbGVjdGlvbkZvciA8IHRoaXMuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1clNlbGVjdGlvbiA9IHRoaXMuY3VyU2VsZWN0aW9uLm1hcCh0aGlzLmRvYywgdGhpcy5tYXBwaW5nLnNsaWNlKHRoaXMuY3VyU2VsZWN0aW9uRm9yKSk7XG4gICAgICAgICAgICB0aGlzLmN1clNlbGVjdGlvbkZvciA9IHRoaXMuc3RlcHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmN1clNlbGVjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB0cmFuc2FjdGlvbidzIGN1cnJlbnQgc2VsZWN0aW9uLiBXaWxsIGRldGVybWluZSB0aGVcbiAgICBzZWxlY3Rpb24gdGhhdCB0aGUgZWRpdG9yIGdldHMgd2hlbiB0aGUgdHJhbnNhY3Rpb24gaXMgYXBwbGllZC5cbiAgICAqL1xuICAgIHNldFNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi4kZnJvbS5kb2MgIT0gdGhpcy5kb2MpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlNlbGVjdGlvbiBwYXNzZWQgdG8gc2V0U2VsZWN0aW9uIG11c3QgcG9pbnQgYXQgdGhlIGN1cnJlbnQgZG9jdW1lbnRcIik7XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbkZvciA9IHRoaXMuc3RlcHMubGVuZ3RoO1xuICAgICAgICB0aGlzLnVwZGF0ZWQgPSAodGhpcy51cGRhdGVkIHwgVVBEQVRFRF9TRUwpICYgflVQREFURURfTUFSS1M7XG4gICAgICAgIHRoaXMuc3RvcmVkTWFya3MgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHdhcyBleHBsaWNpdGx5IHVwZGF0ZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25TZXQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9TRUwpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSBjdXJyZW50IHN0b3JlZCBtYXJrcy5cbiAgICAqL1xuICAgIHNldFN0b3JlZE1hcmtzKG1hcmtzKSB7XG4gICAgICAgIHRoaXMuc3RvcmVkTWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy51cGRhdGVkIHw9IFVQREFURURfTUFSS1M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBNYWtlIHN1cmUgdGhlIGN1cnJlbnQgc3RvcmVkIG1hcmtzIG9yLCBpZiB0aGF0IGlzIG51bGwsIHRoZSBtYXJrc1xuICAgIGF0IHRoZSBzZWxlY3Rpb24sIG1hdGNoIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MuIERvZXMgbm90aGluZyBpZlxuICAgIHRoaXMgaXMgYWxyZWFkeSB0aGUgY2FzZS5cbiAgICAqL1xuICAgIGVuc3VyZU1hcmtzKG1hcmtzKSB7XG4gICAgICAgIGlmICghTWFyay5zYW1lU2V0KHRoaXMuc3RvcmVkTWFya3MgfHwgdGhpcy5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSwgbWFya3MpKVxuICAgICAgICAgICAgdGhpcy5zZXRTdG9yZWRNYXJrcyhtYXJrcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBtYXJrIHRvIHRoZSBzZXQgb2Ygc3RvcmVkIG1hcmtzLlxuICAgICovXG4gICAgYWRkU3RvcmVkTWFyayhtYXJrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZU1hcmtzKG1hcmsuYWRkVG9TZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSBhIG1hcmsgb3IgbWFyayB0eXBlIGZyb20gdGhlIHNldCBvZiBzdG9yZWQgbWFya3MuXG4gICAgKi9cbiAgICByZW1vdmVTdG9yZWRNYXJrKG1hcmspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlTWFya3MobWFyay5yZW1vdmVGcm9tU2V0KHRoaXMuc3RvcmVkTWFya3MgfHwgdGhpcy5zZWxlY3Rpb24uJGhlYWQubWFya3MoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzdG9yZWQgbWFya3Mgd2VyZSBleHBsaWNpdGx5IHNldCBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGdldCBzdG9yZWRNYXJrc1NldCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnVwZGF0ZWQgJiBVUERBVEVEX01BUktTKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkU3RlcChzdGVwLCBkb2MpIHtcbiAgICAgICAgc3VwZXIuYWRkU3RlcChzdGVwLCBkb2MpO1xuICAgICAgICB0aGlzLnVwZGF0ZWQgPSB0aGlzLnVwZGF0ZWQgJiB+VVBEQVRFRF9NQVJLUztcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdGltZXN0YW1wIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBzZXRUaW1lKHRpbWUpIHtcbiAgICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIHNsaWNlLlxuICAgICovXG4gICAgcmVwbGFjZVNlbGVjdGlvbihzbGljZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5yZXBsYWNlKHRoaXMsIHNsaWNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIHRoZSBnaXZlbiBub2RlLiBXaGVuIGBpbmhlcml0TWFya3NgIGlzXG4gICAgdHJ1ZSBhbmQgdGhlIGNvbnRlbnQgaXMgaW5saW5lLCBpdCBpbmhlcml0cyB0aGUgbWFya3MgZnJvbSB0aGVcbiAgICBwbGFjZSB3aGVyZSBpdCBpcyBpbnNlcnRlZC5cbiAgICAqL1xuICAgIHJlcGxhY2VTZWxlY3Rpb25XaXRoKG5vZGUsIGluaGVyaXRNYXJrcyA9IHRydWUpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoaW5oZXJpdE1hcmtzKVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubWFyayh0aGlzLnN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uZW1wdHkgPyBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSA6IChzZWxlY3Rpb24uJGZyb20ubWFya3NBY3Jvc3Moc2VsZWN0aW9uLiR0bykgfHwgTWFyay5ub25lKSkpO1xuICAgICAgICBzZWxlY3Rpb24ucmVwbGFjZVdpdGgodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgdGhlIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGRlbGV0ZVNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ucmVwbGFjZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGdpdmVuIHJhbmdlLCBvciB0aGUgc2VsZWN0aW9uIGlmIG5vIHJhbmdlIGlzIGdpdmVuLFxuICAgIHdpdGggYSB0ZXh0IG5vZGUgY29udGFpbmluZyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgaW5zZXJ0VGV4dCh0ZXh0LCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgc2NoZW1hID0gdGhpcy5kb2MudHlwZS5zY2hlbWE7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghdGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNjaGVtYS50ZXh0KHRleHQpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRvID0gZnJvbTtcbiAgICAgICAgICAgIHRvID0gdG8gPT0gbnVsbCA/IGZyb20gOiB0bztcbiAgICAgICAgICAgIGlmICghdGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSB0aGlzLnN0b3JlZE1hcmtzO1xuICAgICAgICAgICAgaWYgKCFtYXJrcykge1xuICAgICAgICAgICAgICAgIGxldCAkZnJvbSA9IHRoaXMuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgICAgICAgICAgICAgbWFya3MgPSB0byA9PSBmcm9tID8gJGZyb20ubWFya3MoKSA6ICRmcm9tLm1hcmtzQWNyb3NzKHRoaXMuZG9jLnJlc29sdmUodG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgc2NoZW1hLnRleHQodGV4dCwgbWFya3MpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uZW1wdHkpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodGhpcy5zZWxlY3Rpb24uJHRvKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBTdG9yZSBhIG1ldGFkYXRhIHByb3BlcnR5IGluIHRoaXMgdHJhbnNhY3Rpb24sIGtleWVkIGVpdGhlciBieVxuICAgIG5hbWUgb3IgYnkgcGx1Z2luLlxuICAgICovXG4gICAgc2V0TWV0YShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWV0YVt0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgPyBrZXkgOiBrZXkua2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgYSBtZXRhZGF0YSBwcm9wZXJ0eSBmb3IgYSBnaXZlbiBuYW1lIG9yIHBsdWdpbi5cbiAgICAqL1xuICAgIGdldE1ldGEoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGFbdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiID8ga2V5IDoga2V5LmtleV07XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGRvZXNuJ3QgY29udGFpbiBhbnkgbWV0YWRhdGEsXG4gICAgYW5kIGNhbiB0aHVzIHNhZmVseSBiZSBleHRlbmRlZC5cbiAgICAqL1xuICAgIGdldCBpc0dlbmVyaWMoKSB7XG4gICAgICAgIGZvciAobGV0IF8gaW4gdGhpcy5tZXRhKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGUgdGhhdCB0aGUgZWRpdG9yIHNob3VsZCBzY3JvbGwgdGhlIHNlbGVjdGlvbiBpbnRvIHZpZXdcbiAgICB3aGVuIHVwZGF0ZWQgdG8gdGhlIHN0YXRlIHByb2R1Y2VkIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldygpIHtcbiAgICAgICAgdGhpcy51cGRhdGVkIHw9IFVQREFURURfU0NST0xMO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGhhZCBgc2Nyb2xsSW50b1ZpZXdgIGNhbGxlZCBvbiBpdC5cbiAgICAqL1xuICAgIGdldCBzY3JvbGxlZEludG9WaWV3KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfU0NST0xMKSA+IDA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiaW5kKGYsIHNlbGYpIHtcbiAgICByZXR1cm4gIXNlbGYgfHwgIWYgPyBmIDogZi5iaW5kKHNlbGYpO1xufVxuY2xhc3MgRmllbGREZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBkZXNjLCBzZWxmKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5pdCA9IGJpbmQoZGVzYy5pbml0LCBzZWxmKTtcbiAgICAgICAgdGhpcy5hcHBseSA9IGJpbmQoZGVzYy5hcHBseSwgc2VsZik7XG4gICAgfVxufVxuY29uc3QgYmFzZUZpZWxkcyA9IFtcbiAgICBuZXcgRmllbGREZXNjKFwiZG9jXCIsIHtcbiAgICAgICAgaW5pdChjb25maWcpIHsgcmV0dXJuIGNvbmZpZy5kb2MgfHwgY29uZmlnLnNjaGVtYS50b3BOb2RlVHlwZS5jcmVhdGVBbmRGaWxsKCk7IH0sXG4gICAgICAgIGFwcGx5KHRyKSB7IHJldHVybiB0ci5kb2M7IH1cbiAgICB9KSxcbiAgICBuZXcgRmllbGREZXNjKFwic2VsZWN0aW9uXCIsIHtcbiAgICAgICAgaW5pdChjb25maWcsIGluc3RhbmNlKSB7IHJldHVybiBjb25maWcuc2VsZWN0aW9uIHx8IFNlbGVjdGlvbi5hdFN0YXJ0KGluc3RhbmNlLmRvYyk7IH0sXG4gICAgICAgIGFwcGx5KHRyKSB7IHJldHVybiB0ci5zZWxlY3Rpb247IH1cbiAgICB9KSxcbiAgICBuZXcgRmllbGREZXNjKFwic3RvcmVkTWFya3NcIiwge1xuICAgICAgICBpbml0KGNvbmZpZykgeyByZXR1cm4gY29uZmlnLnN0b3JlZE1hcmtzIHx8IG51bGw7IH0sXG4gICAgICAgIGFwcGx5KHRyLCBfbWFya3MsIF9vbGQsIHN0YXRlKSB7IHJldHVybiBzdGF0ZS5zZWxlY3Rpb24uJGN1cnNvciA/IHRyLnN0b3JlZE1hcmtzIDogbnVsbDsgfVxuICAgIH0pLFxuICAgIG5ldyBGaWVsZERlc2MoXCJzY3JvbGxUb1NlbGVjdGlvblwiLCB7XG4gICAgICAgIGluaXQoKSB7IHJldHVybiAwOyB9LFxuICAgICAgICBhcHBseSh0ciwgcHJldikgeyByZXR1cm4gdHIuc2Nyb2xsZWRJbnRvVmlldyA/IHByZXYgKyAxIDogcHJldjsgfVxuICAgIH0pXG5dO1xuLy8gT2JqZWN0IHdyYXBwaW5nIHRoZSBwYXJ0IG9mIGEgc3RhdGUgb2JqZWN0IHRoYXQgc3RheXMgdGhlIHNhbWVcbi8vIGFjcm9zcyB0cmFuc2FjdGlvbnMuIFN0b3JlZCBpbiB0aGUgc3RhdGUncyBgY29uZmlnYCBwcm9wZXJ0eS5cbmNsYXNzIENvbmZpZ3VyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSwgcGx1Z2lucykge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMucGx1Z2luc0J5S2V5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBiYXNlRmllbGRzLnNsaWNlKCk7XG4gICAgICAgIGlmIChwbHVnaW5zKVxuICAgICAgICAgICAgcGx1Z2lucy5mb3JFYWNoKHBsdWdpbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGx1Z2luc0J5S2V5W3BsdWdpbi5rZXldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFkZGluZyBkaWZmZXJlbnQgaW5zdGFuY2VzIG9mIGEga2V5ZWQgcGx1Z2luIChcIiArIHBsdWdpbi5rZXkgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbnNCeUtleVtwbHVnaW4ua2V5XSA9IHBsdWdpbjtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMuc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmllbGRzLnB1c2gobmV3IEZpZWxkRGVzYyhwbHVnaW4ua2V5LCBwbHVnaW4uc3BlYy5zdGF0ZSwgcGx1Z2luKSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcblRoZSBzdGF0ZSBvZiBhIFByb3NlTWlycm9yIGVkaXRvciBpcyByZXByZXNlbnRlZCBieSBhbiBvYmplY3Qgb2ZcbnRoaXMgdHlwZS4gQSBzdGF0ZSBpcyBhIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVcdTIwMTRpdCBpc24ndFxudXBkYXRlZCwgYnV0IHJhdGhlciBhIG5ldyBzdGF0ZSB2YWx1ZSBpcyBjb21wdXRlZCBmcm9tIGFuIG9sZCBvbmVcbnVzaW5nIHRoZSBbYGFwcGx5YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmFwcGx5KSBtZXRob2QuXG5cbkEgc3RhdGUgaG9sZHMgYSBudW1iZXIgb2YgYnVpbHQtaW4gZmllbGRzLCBhbmQgcGx1Z2lucyBjYW5cbltkZWZpbmVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjLnN0YXRlKSBhZGRpdGlvbmFsIGZpZWxkcy5cbiovXG5jbGFzcyBFZGl0b3JTdGF0ZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNjaGVtYSBvZiB0aGUgc3RhdGUncyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5zY2hlbWE7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwbHVnaW5zIHRoYXQgYXJlIGFjdGl2ZSBpbiB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5wbHVnaW5zO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBseSB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24gdG8gcHJvZHVjZSBhIG5ldyBzdGF0ZS5cbiAgICAqL1xuICAgIGFwcGx5KHRyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5VHJhbnNhY3Rpb24odHIpLnN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbHRlclRyYW5zYWN0aW9uKHRyLCBpZ25vcmUgPSAtMSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoaSAhPSBpZ25vcmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5jb25maWcucGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMuZmlsdGVyVHJhbnNhY3Rpb24gJiYgIXBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uLmNhbGwocGx1Z2luLCB0ciwgdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFZlcmJvc2UgdmFyaWFudCBvZiBbYGFwcGx5YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmFwcGx5KSB0aGF0XG4gICAgcmV0dXJucyB0aGUgcHJlY2lzZSB0cmFuc2FjdGlvbnMgdGhhdCB3ZXJlIGFwcGxpZWQgKHdoaWNoIG1pZ2h0XG4gICAgYmUgaW5mbHVlbmNlZCBieSB0aGUgW3RyYW5zYWN0aW9uXG4gICAgaG9va3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjLmZpbHRlclRyYW5zYWN0aW9uKSBvZlxuICAgIHBsdWdpbnMpIGFsb25nIHdpdGggdGhlIG5ldyBzdGF0ZS5cbiAgICAqL1xuICAgIGFwcGx5VHJhbnNhY3Rpb24ocm9vdFRyKSB7XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXJUcmFuc2FjdGlvbihyb290VHIpKVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IHRoaXMsIHRyYW5zYWN0aW9uczogW10gfTtcbiAgICAgICAgbGV0IHRycyA9IFtyb290VHJdLCBuZXdTdGF0ZSA9IHRoaXMuYXBwbHlJbm5lcihyb290VHIpLCBzZWVuID0gbnVsbDtcbiAgICAgICAgLy8gVGhpcyBsb29wIHJlcGVhdGVkbHkgZ2l2ZXMgcGx1Z2lucyBhIGNoYW5jZSB0byByZXNwb25kIHRvXG4gICAgICAgIC8vIHRyYW5zYWN0aW9ucyBhcyBuZXcgdHJhbnNhY3Rpb25zIGFyZSBhZGRlZCwgbWFraW5nIHN1cmUgdG8gb25seVxuICAgICAgICAvLyBwYXNzIHRoZSB0cmFuc2FjdGlvbnMgdGhlIHBsdWdpbiBkaWQgbm90IHNlZSBiZWZvcmUuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBoYXZlTmV3ID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5jb25maWcucGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMuYXBwZW5kVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG4gPSBzZWVuID8gc2VlbltpXS5uIDogMCwgb2xkU3RhdGUgPSBzZWVuID8gc2VlbltpXS5zdGF0ZSA6IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ciA9IG4gPCB0cnMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbi5jYWxsKHBsdWdpbiwgbiA/IHRycy5zbGljZShuKSA6IHRycywgb2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyICYmIG5ld1N0YXRlLmZpbHRlclRyYW5zYWN0aW9uKHRyLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcImFwcGVuZGVkVHJhbnNhY3Rpb25cIiwgcm9vdFRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2Vlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZW4ucHVzaChqIDwgaSA/IHsgc3RhdGU6IG5ld1N0YXRlLCBuOiB0cnMubGVuZ3RoIH0gOiB7IHN0YXRlOiB0aGlzLCBuOiAwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJzLnB1c2godHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBuZXdTdGF0ZS5hcHBseUlubmVyKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVOZXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VlbltpXSA9IHsgc3RhdGU6IG5ld1N0YXRlLCBuOiB0cnMubGVuZ3RoIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXZlTmV3KVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBuZXdTdGF0ZSwgdHJhbnNhY3Rpb25zOiB0cnMgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFwcGx5SW5uZXIodHIpIHtcbiAgICAgICAgaWYgKCF0ci5iZWZvcmUuZXEodGhpcy5kb2MpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBcHBseWluZyBhIG1pc21hdGNoZWQgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGxldCBuZXdJbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSh0aGlzLmNvbmZpZyksIGZpZWxkcyA9IHRoaXMuY29uZmlnLmZpZWxkcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgICAgIG5ld0luc3RhbmNlW2ZpZWxkLm5hbWVdID0gZmllbGQuYXBwbHkodHIsIHRoaXNbZmllbGQubmFtZV0sIHRoaXMsIG5ld0luc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SW5zdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFN0YXJ0IGEgW3RyYW5zYWN0aW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pIGZyb20gdGhpcyBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCB0cigpIHsgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbih0aGlzKTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnKSB7XG4gICAgICAgIGxldCAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnLmRvYyA/IGNvbmZpZy5kb2MudHlwZS5zY2hlbWEgOiBjb25maWcuc2NoZW1hLCBjb25maWcucGx1Z2lucyk7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAkY29uZmlnLmZpZWxkcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGluc3RhbmNlWyRjb25maWcuZmllbGRzW2ldLm5hbWVdID0gJGNvbmZpZy5maWVsZHNbaV0uaW5pdChjb25maWcsIGluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgc3RhdGUgYmFzZWQgb24gdGhpcyBvbmUsIGJ1dCB3aXRoIGFuIGFkanVzdGVkIHNldFxuICAgIG9mIGFjdGl2ZSBwbHVnaW5zLiBTdGF0ZSBmaWVsZHMgdGhhdCBleGlzdCBpbiBib3RoIHNldHMgb2ZcbiAgICBwbHVnaW5zIGFyZSBrZXB0IHVuY2hhbmdlZC4gVGhvc2UgdGhhdCBubyBsb25nZXIgZXhpc3QgYXJlXG4gICAgZHJvcHBlZCwgYW5kIHRob3NlIHRoYXQgYXJlIG5ldyBhcmUgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlaXJcbiAgICBbYGluaXRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuU3RhdGVGaWVsZC5pbml0KSBtZXRob2QsIHBhc3NpbmcgaW4gdGhlIG5ld1xuICAgIGNvbmZpZ3VyYXRpb24gb2JqZWN0Li5cbiAgICAqL1xuICAgIHJlY29uZmlndXJlKGNvbmZpZykge1xuICAgICAgICBsZXQgJGNvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKHRoaXMuc2NoZW1hLCBjb25maWcucGx1Z2lucyk7XG4gICAgICAgIGxldCBmaWVsZHMgPSAkY29uZmlnLmZpZWxkcywgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGZpZWxkc1tpXS5uYW1lO1xuICAgICAgICAgICAgaW5zdGFuY2VbbmFtZV0gPSB0aGlzLmhhc093blByb3BlcnR5KG5hbWUpID8gdGhpc1tuYW1lXSA6IGZpZWxkc1tpXS5pbml0KGNvbmZpZywgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgc3RhdGUgdG8gSlNPTi4gSWYgeW91IHdhbnQgdG8gc2VyaWFsaXplIHRoZSBzdGF0ZVxuICAgIG9mIHBsdWdpbnMsIHBhc3MgYW4gb2JqZWN0IG1hcHBpbmcgcHJvcGVydHkgbmFtZXMgdG8gdXNlIGluIHRoZVxuICAgIHJlc3VsdGluZyBKU09OIG9iamVjdCB0byBwbHVnaW4gb2JqZWN0cy4gVGhlIGFyZ3VtZW50IG1heSBhbHNvIGJlXG4gICAgYSBzdHJpbmcgb3IgbnVtYmVyLCBpbiB3aGljaCBjYXNlIGl0IGlzIGlnbm9yZWQsIHRvIHN1cHBvcnQgdGhlXG4gICAgd2F5IGBKU09OLnN0cmluZ2lmeWAgY2FsbHMgYHRvU3RyaW5nYCBtZXRob2RzLlxuICAgICovXG4gICAgdG9KU09OKHBsdWdpbkZpZWxkcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBkb2M6IHRoaXMuZG9jLnRvSlNPTigpLCBzZWxlY3Rpb246IHRoaXMuc2VsZWN0aW9uLnRvSlNPTigpIH07XG4gICAgICAgIGlmICh0aGlzLnN0b3JlZE1hcmtzKVxuICAgICAgICAgICAgcmVzdWx0LnN0b3JlZE1hcmtzID0gdGhpcy5zdG9yZWRNYXJrcy5tYXAobSA9PiBtLnRvSlNPTigpKTtcbiAgICAgICAgaWYgKHBsdWdpbkZpZWxkcyAmJiB0eXBlb2YgcGx1Z2luRmllbGRzID09ICdvYmplY3QnKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwbHVnaW5GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PSBcImRvY1wiIHx8IHByb3AgPT0gXCJzZWxlY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgSlNPTiBmaWVsZHMgYGRvY2AgYW5kIGBzZWxlY3Rpb25gIGFyZSByZXNlcnZlZFwiKTtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gcGx1Z2luRmllbGRzW3Byb3BdLCBzdGF0ZSA9IHBsdWdpbi5zcGVjLnN0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS50b0pTT04pXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHN0YXRlLnRvSlNPTi5jYWxsKHBsdWdpbiwgdGhpc1twbHVnaW4ua2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHN0YXRlLiBgY29uZmlnYCBzaG91bGRcbiAgICBoYXZlIGF0IGxlYXN0IGEgYHNjaGVtYWAgZmllbGQsIGFuZCBzaG91bGQgY29udGFpbiBhcnJheSBvZlxuICAgIHBsdWdpbnMgdG8gaW5pdGlhbGl6ZSB0aGUgc3RhdGUgd2l0aC4gYHBsdWdpbkZpZWxkc2AgY2FuIGJlIHVzZWRcbiAgICB0byBkZXNlcmlhbGl6ZSB0aGUgc3RhdGUgb2YgcGx1Z2lucywgYnkgYXNzb2NpYXRpbmcgcGx1Z2luXG4gICAgaW5zdGFuY2VzIHdpdGggdGhlIHByb3BlcnR5IG5hbWVzIHRoZXkgdXNlIGluIHRoZSBKU09OIG9iamVjdC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihjb25maWcsIGpzb24sIHBsdWdpbkZpZWxkcykge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEVkaXRvclN0YXRlLmZyb21KU09OXCIpO1xuICAgICAgICBpZiAoIWNvbmZpZy5zY2hlbWEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlcXVpcmVkIGNvbmZpZyBmaWVsZCAnc2NoZW1hJyBtaXNzaW5nXCIpO1xuICAgICAgICBsZXQgJGNvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKGNvbmZpZy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKCRjb25maWcpO1xuICAgICAgICAkY29uZmlnLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5uYW1lID09IFwiZG9jXCIpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5kb2MgPSBOb2RlLmZyb21KU09OKGNvbmZpZy5zY2hlbWEsIGpzb24uZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLm5hbWUgPT0gXCJzZWxlY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLnNlbGVjdGlvbiA9IFNlbGVjdGlvbi5mcm9tSlNPTihpbnN0YW5jZS5kb2MsIGpzb24uc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLm5hbWUgPT0gXCJzdG9yZWRNYXJrc1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uc3RvcmVkTWFya3MpXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnN0b3JlZE1hcmtzID0ganNvbi5zdG9yZWRNYXJrcy5tYXAoY29uZmlnLnNjaGVtYS5tYXJrRnJvbUpTT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbkZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwbHVnaW5GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSBwbHVnaW5GaWVsZHNbcHJvcF0sIHN0YXRlID0gcGx1Z2luLnNwZWMuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2luLmtleSA9PSBmaWVsZC5uYW1lICYmIHN0YXRlICYmIHN0YXRlLmZyb21KU09OICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGpzb24sIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VbZmllbGQubmFtZV0gPSBzdGF0ZS5mcm9tSlNPTi5jYWxsKHBsdWdpbiwgY29uZmlnLCBqc29uW3Byb3BdLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VbZmllbGQubmFtZV0gPSBmaWVsZC5pbml0KGNvbmZpZywgaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYmluZFByb3BzKG9iaiwgc2VsZiwgdGFyZ2V0KSB7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgbGV0IHZhbCA9IG9ialtwcm9wXTtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICAgICAgdmFsID0gdmFsLmJpbmQoc2VsZik7XG4gICAgICAgIGVsc2UgaWYgKHByb3AgPT0gXCJoYW5kbGVET01FdmVudHNcIilcbiAgICAgICAgICAgIHZhbCA9IGJpbmRQcm9wcyh2YWwsIHNlbGYsIHt9KTtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuLyoqXG5QbHVnaW5zIGJ1bmRsZSBmdW5jdGlvbmFsaXR5IHRoYXQgY2FuIGJlIGFkZGVkIHRvIGFuIGVkaXRvci5cblRoZXkgYXJlIHBhcnQgb2YgdGhlIFtlZGl0b3Igc3RhdGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZSkgYW5kXG5tYXkgaW5mbHVlbmNlIHRoYXQgc3RhdGUgYW5kIHRoZSB2aWV3IHRoYXQgY29udGFpbnMgaXQuXG4qL1xuY2xhc3MgUGx1Z2luIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwbHVnaW4uXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcGx1Z2luJ3MgW3NwZWMgb2JqZWN0XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuUGx1Z2luU3BlYykuXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgW3Byb3BzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcykgZXhwb3J0ZWQgYnkgdGhpcyBwbHVnaW4uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucHJvcHMgPSB7fTtcbiAgICAgICAgaWYgKHNwZWMucHJvcHMpXG4gICAgICAgICAgICBiaW5kUHJvcHMoc3BlYy5wcm9wcywgdGhpcywgdGhpcy5wcm9wcyk7XG4gICAgICAgIHRoaXMua2V5ID0gc3BlYy5rZXkgPyBzcGVjLmtleS5rZXkgOiBjcmVhdGVLZXkoXCJwbHVnaW5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dHJhY3QgdGhlIHBsdWdpbidzIHN0YXRlIGZpZWxkIGZyb20gYW4gZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgZ2V0U3RhdGUoc3RhdGUpIHsgcmV0dXJuIHN0YXRlW3RoaXMua2V5XTsgfVxufVxuY29uc3Qga2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBjcmVhdGVLZXkobmFtZSkge1xuICAgIGlmIChuYW1lIGluIGtleXMpXG4gICAgICAgIHJldHVybiBuYW1lICsgXCIkXCIgKyArK2tleXNbbmFtZV07XG4gICAga2V5c1tuYW1lXSA9IDA7XG4gICAgcmV0dXJuIG5hbWUgKyBcIiRcIjtcbn1cbi8qKlxuQSBrZXkgaXMgdXNlZCB0byBbdGFnXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuUGx1Z2luU3BlYy5rZXkpIHBsdWdpbnMgaW4gYSB3YXlcbnRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG8gZmluZCB0aGVtLCBnaXZlbiBhbiBlZGl0b3Igc3RhdGUuXG5Bc3NpZ25pbmcgYSBrZXkgZG9lcyBtZWFuIG9ubHkgb25lIHBsdWdpbiBvZiB0aGF0IHR5cGUgY2FuIGJlXG5hY3RpdmUgaW4gYSBzdGF0ZS5cbiovXG5jbGFzcyBQbHVnaW5LZXkge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBsdWdpbiBrZXkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lID0gXCJrZXlcIikgeyB0aGlzLmtleSA9IGNyZWF0ZUtleShuYW1lKTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgYWN0aXZlIHBsdWdpbiB3aXRoIHRoaXMga2V5LCBpZiBhbnksIGZyb20gYW4gZWRpdG9yXG4gICAgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLmNvbmZpZy5wbHVnaW5zQnlLZXlbdGhpcy5rZXldOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwbHVnaW4ncyBzdGF0ZSBmcm9tIGFuIGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIGdldFN0YXRlKHN0YXRlKSB7IHJldHVybiBzdGF0ZVt0aGlzLmtleV07IH1cbn1cblxuZXhwb3J0IHsgQWxsU2VsZWN0aW9uLCBFZGl0b3JTdGF0ZSwgTm9kZVNlbGVjdGlvbiwgUGx1Z2luLCBQbHVnaW5LZXksIFNlbGVjdGlvbiwgU2VsZWN0aW9uUmFuZ2UsIFRleHRTZWxlY3Rpb24sIFRyYW5zYWN0aW9uIH07XG4iLCAiaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiwgTm9kZVNlbGVjdGlvbiwgQWxsU2VsZWN0aW9uLCBTZWxlY3Rpb24gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBET01TZXJpYWxpemVyLCBGcmFnbWVudCwgTWFyaywgU2xpY2UsIERPTVBhcnNlciB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IGRyb3BQb2ludCB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbmNvbnN0IGRvbUluZGV4ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7OyBpbmRleCsrKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn07XG5jb25zdCBwYXJlbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBsZXQgcGFyZW50ID0gbm9kZS5hc3NpZ25lZFNsb3QgfHwgbm9kZS5wYXJlbnROb2RlO1xuICAgIHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09IDExID8gcGFyZW50Lmhvc3QgOiBwYXJlbnQ7XG59O1xubGV0IHJldXNlZFJhbmdlID0gbnVsbDtcbi8vIE5vdGUgdGhhdCB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgc2FtZSByYW5nZSwgYmVjYXVzZSBET00gcmFuZ2Vcbi8vIG9iamVjdHMgYXJlIGV2ZXJ5IGV4cGVuc2l2ZSwgYW5kIGtlZXAgc2xvd2luZyBkb3duIHN1YnNlcXVlbnQgRE9NXG4vLyB1cGRhdGVzLCBmb3Igc29tZSByZWFzb24uXG5jb25zdCB0ZXh0UmFuZ2UgPSBmdW5jdGlvbiAobm9kZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgcmFuZ2UgPSByZXVzZWRSYW5nZSB8fCAocmV1c2VkUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpKTtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgdG8gPT0gbnVsbCA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IHRvKTtcbiAgICByYW5nZS5zZXRTdGFydChub2RlLCBmcm9tIHx8IDApO1xuICAgIHJldHVybiByYW5nZTtcbn07XG4vLyBTY2FucyBmb3J3YXJkIGFuZCBiYWNrd2FyZCB0aHJvdWdoIERPTSBwb3NpdGlvbnMgZXF1aXZhbGVudCB0byB0aGVcbi8vIGdpdmVuIG9uZSB0byBzZWUgaWYgdGhlIHR3byBhcmUgaW4gdGhlIHNhbWUgcGxhY2UgKGkuZS4gYWZ0ZXIgYVxuLy8gdGV4dCBub2RlIHZzIGF0IHRoZSBlbmQgb2YgdGhhdCB0ZXh0IG5vZGUpXG5jb25zdCBpc0VxdWl2YWxlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZikge1xuICAgIHJldHVybiB0YXJnZXROb2RlICYmIChzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAtMSkgfHxcbiAgICAgICAgc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgMSkpO1xufTtcbmNvbnN0IGF0b21FbGVtZW50cyA9IC9eKGltZ3xicnxpbnB1dHx0ZXh0YXJlYXxocikkL2k7XG5mdW5jdGlvbiBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCBkaXIpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlID09IHRhcmdldE5vZGUgJiYgb2ZmID09IHRhcmdldE9mZilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxIHx8IGhhc0Jsb2NrRGVzYyhub2RlKSB8fCBhdG9tRWxlbWVudHMudGVzdChub2RlLm5vZGVOYW1lKSB8fFxuICAgICAgICAgICAgICAgIG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkb21JbmRleChub2RlKSArIChkaXIgPCAwID8gMCA6IDEpO1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2ZmICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZGlyIDwgMCA/IG5vZGVTaXplKG5vZGUpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVTaXplKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGlzT25FZGdlKG5vZGUsIG9mZnNldCwgcGFyZW50KSB7XG4gICAgZm9yIChsZXQgYXRTdGFydCA9IG9mZnNldCA9PSAwLCBhdEVuZCA9IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKTsgYXRTdGFydCB8fCBhdEVuZDspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBpbmRleCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGF0U3RhcnQgPSBhdFN0YXJ0ICYmIGluZGV4ID09IDA7XG4gICAgICAgIGF0RW5kID0gYXRFbmQgJiYgaW5kZXggPT0gbm9kZVNpemUobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQmxvY2tEZXNjKGRvbSkge1xuICAgIGxldCBkZXNjO1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKGRlc2MgPSBjdXIucG1WaWV3RGVzYylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jayAmJiAoZGVzYy5kb20gPT0gZG9tIHx8IGRlc2MuY29udGVudERPTSA9PSBkb20pO1xufVxuLy8gV29yayBhcm91bmQgQ2hyb21lIGlzc3VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzUyM1xuLy8gKGlzQ29sbGFwc2VkIGluYXBwcm9wcmlhdGVseSByZXR1cm5zIHRydWUgaW4gc2hhZG93IGRvbSlcbmNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGZ1bmN0aW9uIChkb21TZWwpIHtcbiAgICByZXR1cm4gZG9tU2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbn07XG5mdW5jdGlvbiBrZXlFdmVudChrZXlDb2RlLCBrZXkpIHtcbiAgICBsZXQgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGV2ZW50LmluaXRFdmVudChcImtleWRvd25cIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZXZlbnQua2V5Q29kZSA9IGtleUNvZGU7XG4gICAgZXZlbnQua2V5ID0gZXZlbnQuY29kZSA9IGtleTtcbiAgICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiBkZWVwQWN0aXZlRWxlbWVudChkb2MpIHtcbiAgICBsZXQgZWx0ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsdCAmJiBlbHQuc2hhZG93Um9vdClcbiAgICAgICAgZWx0ID0gZWx0LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgICByZXR1cm4gZWx0O1xufVxuZnVuY3Rpb24gY2FyZXRGcm9tUG9pbnQoZG9jLCB4LCB5KSB7XG4gICAgaWYgKGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgICAgIHRyeSB7IC8vIEZpcmVmb3ggdGhyb3dzIGZvciB0aGlzIGNhbGwgaW4gaGFyZC10by1wcmVkaWN0IGNpcmN1bXN0YW5jZXMgKCM5OTQpXG4gICAgICAgICAgICBsZXQgcG9zID0gZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHBvcy5vZmZzZXROb2RlLCBvZmZzZXQ6IHBvcy5vZmZzZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgfVxuICAgIGlmIChkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogcmFuZ2Uuc3RhcnRDb250YWluZXIsIG9mZnNldDogcmFuZ2Uuc3RhcnRPZmZzZXQgfTtcbiAgICB9XG59XG5cbmNvbnN0IG5hdiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IG5hdmlnYXRvciA6IG51bGw7XG5jb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogbnVsbDtcbmNvbnN0IGFnZW50ID0gKG5hdiAmJiBuYXYudXNlckFnZW50KSB8fCBcIlwiO1xuY29uc3QgaWVfZWRnZSA9IC9FZGdlXFwvKFxcZCspLy5leGVjKGFnZW50KTtcbmNvbnN0IGllX3VwdG8xMCA9IC9NU0lFIFxcZC8uZXhlYyhhZ2VudCk7XG5jb25zdCBpZV8xMXVwID0gL1RyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKGFnZW50KTtcbmNvbnN0IGllID0gISEoaWVfdXB0bzEwIHx8IGllXzExdXAgfHwgaWVfZWRnZSk7XG5jb25zdCBpZV92ZXJzaW9uID0gaWVfdXB0bzEwID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogaWVfMTF1cCA/ICtpZV8xMXVwWzFdIDogaWVfZWRnZSA/ICtpZV9lZGdlWzFdIDogMDtcbmNvbnN0IGdlY2tvID0gIWllICYmIC9nZWNrb1xcLyhcXGQrKS9pLnRlc3QoYWdlbnQpO1xuZ2Vja28gJiYgKygvRmlyZWZveFxcLyhcXGQrKS8uZXhlYyhhZ2VudCkgfHwgWzAsIDBdKVsxXTtcbmNvbnN0IF9jaHJvbWUgPSAhaWUgJiYgL0Nocm9tZVxcLyhcXGQrKS8uZXhlYyhhZ2VudCk7XG5jb25zdCBjaHJvbWUgPSAhIV9jaHJvbWU7XG5jb25zdCBjaHJvbWVfdmVyc2lvbiA9IF9jaHJvbWUgPyArX2Nocm9tZVsxXSA6IDA7XG5jb25zdCBzYWZhcmkgPSAhaWUgJiYgISFuYXYgJiYgL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdi52ZW5kb3IpO1xuLy8gSXMgdHJ1ZSBmb3IgYm90aCBpT1MgYW5kIGlQYWRPUyBmb3IgY29udmVuaWVuY2VcbmNvbnN0IGlvcyA9IHNhZmFyaSAmJiAoL01vYmlsZVxcL1xcdysvLnRlc3QoYWdlbnQpIHx8ICEhbmF2ICYmIG5hdi5tYXhUb3VjaFBvaW50cyA+IDIpO1xuY29uc3QgbWFjID0gaW9zIHx8IChuYXYgPyAvTWFjLy50ZXN0KG5hdi5wbGF0Zm9ybSkgOiBmYWxzZSk7XG5jb25zdCB3aW5kb3dzID0gbmF2ID8gL1dpbi8udGVzdChuYXYucGxhdGZvcm0pIDogZmFsc2U7XG5jb25zdCBhbmRyb2lkID0gL0FuZHJvaWQgXFxkLy50ZXN0KGFnZW50KTtcbmNvbnN0IHdlYmtpdCA9ICEhZG9jICYmIFwid2Via2l0Rm9udFNtb290aGluZ1wiIGluIGRvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5jb25zdCB3ZWJraXRfdmVyc2lvbiA9IHdlYmtpdCA/ICsoL1xcYkFwcGxlV2ViS2l0XFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwO1xuXG5mdW5jdGlvbiB3aW5kb3dSZWN0KGRvYykge1xuICAgIHJldHVybiB7IGxlZnQ6IDAsIHJpZ2h0OiBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICB0b3A6IDAsIGJvdHRvbTogZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIGdldFNpZGUodmFsdWUsIHNpZGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyB2YWx1ZSA6IHZhbHVlW3NpZGVdO1xufVxuZnVuY3Rpb24gY2xpZW50UmVjdChub2RlKSB7XG4gICAgbGV0IHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIEFkanVzdCBmb3IgZWxlbWVudHMgd2l0aCBzdHlsZSBcInRyYW5zZm9ybTogc2NhbGUoKVwiXG4gICAgbGV0IHNjYWxlWCA9IChyZWN0LndpZHRoIC8gbm9kZS5vZmZzZXRXaWR0aCkgfHwgMTtcbiAgICBsZXQgc2NhbGVZID0gKHJlY3QuaGVpZ2h0IC8gbm9kZS5vZmZzZXRIZWlnaHQpIHx8IDE7XG4gICAgLy8gTWFrZSBzdXJlIHNjcm9sbGJhciB3aWR0aCBpc24ndCBpbmNsdWRlZCBpbiB0aGUgcmVjdGFuZ2xlXG4gICAgcmV0dXJuIHsgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5sZWZ0ICsgbm9kZS5jbGllbnRXaWR0aCAqIHNjYWxlWCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIG5vZGUuY2xpZW50SGVpZ2h0ICogc2NhbGVZIH07XG59XG5mdW5jdGlvbiBzY3JvbGxSZWN0SW50b1ZpZXcodmlldywgcmVjdCwgc3RhcnRET00pIHtcbiAgICBsZXQgc2Nyb2xsVGhyZXNob2xkID0gdmlldy5zb21lUHJvcChcInNjcm9sbFRocmVzaG9sZFwiKSB8fCAwLCBzY3JvbGxNYXJnaW4gPSB2aWV3LnNvbWVQcm9wKFwic2Nyb2xsTWFyZ2luXCIpIHx8IDU7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZm9yIChsZXQgcGFyZW50ID0gc3RhcnRET00gfHwgdmlldy5kb207OyBwYXJlbnQgPSBwYXJlbnROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBlbHQgPSBwYXJlbnQ7XG4gICAgICAgIGxldCBhdFRvcCA9IGVsdCA9PSBkb2MuYm9keTtcbiAgICAgICAgbGV0IGJvdW5kaW5nID0gYXRUb3AgPyB3aW5kb3dSZWN0KGRvYykgOiBjbGllbnRSZWN0KGVsdCk7XG4gICAgICAgIGxldCBtb3ZlWCA9IDAsIG1vdmVZID0gMDtcbiAgICAgICAgaWYgKHJlY3QudG9wIDwgYm91bmRpbmcudG9wICsgZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwidG9wXCIpKVxuICAgICAgICAgICAgbW92ZVkgPSAtKGJvdW5kaW5nLnRvcCAtIHJlY3QudG9wICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwidG9wXCIpKTtcbiAgICAgICAgZWxzZSBpZiAocmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20gLSBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJib3R0b21cIikpXG4gICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3AgPiBib3VuZGluZy5ib3R0b20gLSBib3VuZGluZy50b3BcbiAgICAgICAgICAgICAgICA/IHJlY3QudG9wICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwidG9wXCIpIC0gYm91bmRpbmcudG9wXG4gICAgICAgICAgICAgICAgOiByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcImJvdHRvbVwiKTtcbiAgICAgICAgaWYgKHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQgKyBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJsZWZ0XCIpKVxuICAgICAgICAgICAgbW92ZVggPSAtKGJvdW5kaW5nLmxlZnQgLSByZWN0LmxlZnQgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJsZWZ0XCIpKTtcbiAgICAgICAgZWxzZSBpZiAocmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0IC0gZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwicmlnaHRcIikpXG4gICAgICAgICAgICBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInJpZ2h0XCIpO1xuICAgICAgICBpZiAobW92ZVggfHwgbW92ZVkpIHtcbiAgICAgICAgICAgIGlmIChhdFRvcCkge1xuICAgICAgICAgICAgICAgIGRvYy5kZWZhdWx0Vmlldy5zY3JvbGxCeShtb3ZlWCwgbW92ZVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0WCA9IGVsdC5zY3JvbGxMZWZ0LCBzdGFydFkgPSBlbHQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlWSlcbiAgICAgICAgICAgICAgICAgICAgZWx0LnNjcm9sbFRvcCArPSBtb3ZlWTtcbiAgICAgICAgICAgICAgICBpZiAobW92ZVgpXG4gICAgICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxMZWZ0ICs9IG1vdmVYO1xuICAgICAgICAgICAgICAgIGxldCBkWCA9IGVsdC5zY3JvbGxMZWZ0IC0gc3RhcnRYLCBkWSA9IGVsdC5zY3JvbGxUb3AgLSBzdGFydFk7XG4gICAgICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogcmVjdC5sZWZ0IC0gZFgsIHRvcDogcmVjdC50b3AgLSBkWSwgcmlnaHQ6IHJlY3QucmlnaHQgLSBkWCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIGRZIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0VG9wIHx8IC9eKGZpeGVkfHN0aWNreSkkLy50ZXN0KGdldENvbXB1dGVkU3R5bGUocGFyZW50KS5wb3NpdGlvbikpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG4vLyBTdG9yZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBlZGl0b3IncyBwYXJlbnQgbm9kZXMsIGFsb25nIHdpdGhcbi8vIHRoZSB0b3AgcG9zaXRpb24gb2YgYW4gZWxlbWVudCBuZWFyIHRoZSB0b3Agb2YgdGhlIGVkaXRvciwgd2hpY2hcbi8vIHdpbGwgYmUgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHZpc2libGUgdmlld3BvcnQgcmVtYWlucyBzdGFibGUgZXZlblxuLy8gd2hlbiB0aGUgc2l6ZSBvZiB0aGUgY29udGVudCBhYm92ZSBjaGFuZ2VzLlxuZnVuY3Rpb24gc3RvcmVTY3JvbGxQb3Modmlldykge1xuICAgIGxldCByZWN0ID0gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHN0YXJ0WSA9IE1hdGgubWF4KDAsIHJlY3QudG9wKTtcbiAgICBsZXQgcmVmRE9NLCByZWZUb3A7XG4gICAgZm9yIChsZXQgeCA9IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsIHkgPSBzdGFydFkgKyAxOyB5IDwgTWF0aC5taW4oaW5uZXJIZWlnaHQsIHJlY3QuYm90dG9tKTsgeSArPSA1KSB7XG4gICAgICAgIGxldCBkb20gPSB2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKCFkb20gfHwgZG9tID09IHZpZXcuZG9tIHx8ICF2aWV3LmRvbS5jb250YWlucyhkb20pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBsb2NhbFJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChsb2NhbFJlY3QudG9wID49IHN0YXJ0WSAtIDIwKSB7XG4gICAgICAgICAgICByZWZET00gPSBkb207XG4gICAgICAgICAgICByZWZUb3AgPSBsb2NhbFJlY3QudG9wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgcmVmRE9NOiByZWZET00sIHJlZlRvcDogcmVmVG9wLCBzdGFjazogc2Nyb2xsU3RhY2sodmlldy5kb20pIH07XG59XG5mdW5jdGlvbiBzY3JvbGxTdGFjayhkb20pIHtcbiAgICBsZXQgc3RhY2sgPSBbXSwgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7IGN1ciA9IHBhcmVudE5vZGUoY3VyKSkge1xuICAgICAgICBzdGFjay5wdXNoKHsgZG9tOiBjdXIsIHRvcDogY3VyLnNjcm9sbFRvcCwgbGVmdDogY3VyLnNjcm9sbExlZnQgfSk7XG4gICAgICAgIGlmIChkb20gPT0gZG9jKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBzdGFjaztcbn1cbi8vIFJlc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGVkaXRvcidzIHBhcmVudCBub2RlcyB0byB0aGF0IHdoYXRcbi8vIGl0IHdhcyBiZWZvcmUsIHdoZW4gc3RvcmVTY3JvbGxQb3Mgd2FzIGNhbGxlZC5cbmZ1bmN0aW9uIHJlc2V0U2Nyb2xsUG9zKHsgcmVmRE9NLCByZWZUb3AsIHN0YWNrIH0pIHtcbiAgICBsZXQgbmV3UmVmVG9wID0gcmVmRE9NID8gcmVmRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA6IDA7XG4gICAgcmVzdG9yZVNjcm9sbFN0YWNrKHN0YWNrLCBuZXdSZWZUb3AgPT0gMCA/IDAgOiBuZXdSZWZUb3AgLSByZWZUb3ApO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcm9sbFN0YWNrKHN0YWNrLCBkVG9wKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgeyBkb20sIHRvcCwgbGVmdCB9ID0gc3RhY2tbaV07XG4gICAgICAgIGlmIChkb20uc2Nyb2xsVG9wICE9IHRvcCArIGRUb3ApXG4gICAgICAgICAgICBkb20uc2Nyb2xsVG9wID0gdG9wICsgZFRvcDtcbiAgICAgICAgaWYgKGRvbS5zY3JvbGxMZWZ0ICE9IGxlZnQpXG4gICAgICAgICAgICBkb20uc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgfVxufVxubGV0IHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBudWxsO1xuLy8gRmVhdHVyZS1kZXRlY3RzIHN1cHBvcnQgZm9yIC5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pLCBhbmQgdXNlc1xuLy8gYSBmYWxsYmFjayBrbHVkZ2Ugd2hlbiBub3Qgc3VwcG9ydGVkLlxuZnVuY3Rpb24gZm9jdXNQcmV2ZW50U2Nyb2xsKGRvbSkge1xuICAgIGlmIChkb20uc2V0QWN0aXZlKVxuICAgICAgICByZXR1cm4gZG9tLnNldEFjdGl2ZSgpOyAvLyBpbiBJRVxuICAgIGlmIChwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpO1xuICAgIGxldCBzdG9yZWQgPSBzY3JvbGxTdGFjayhkb20pO1xuICAgIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID09IG51bGwgPyB7XG4gICAgICAgIGdldCBwcmV2ZW50U2Nyb2xsKCkge1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IDogdW5kZWZpbmVkKTtcbiAgICBpZiAoIXByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICByZXN0b3JlU2Nyb2xsU3RhY2soc3RvcmVkLCAwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kT2Zmc2V0SW5Ob2RlKG5vZGUsIGNvb3Jkcykge1xuICAgIGxldCBjbG9zZXN0LCBkeENsb3Nlc3QgPSAyZTgsIGNvb3Jkc0Nsb3Nlc3QsIG9mZnNldCA9IDA7XG4gICAgbGV0IHJvd0JvdCA9IGNvb3Jkcy50b3AsIHJvd1RvcCA9IGNvb3Jkcy50b3A7XG4gICAgbGV0IGZpcnN0QmVsb3csIGNvb3Jkc0JlbG93O1xuICAgIGZvciAobGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkLCBjaGlsZEluZGV4ID0gMDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcsIGNoaWxkSW5kZXgrKykge1xuICAgICAgICBsZXQgcmVjdHM7XG4gICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgcmVjdHMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmVjdHMgPSB0ZXh0UmFuZ2UoY2hpbGQpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKHJlY3QudG9wIDw9IHJvd0JvdCAmJiByZWN0LmJvdHRvbSA+PSByb3dUb3ApIHtcbiAgICAgICAgICAgICAgICByb3dCb3QgPSBNYXRoLm1heChyZWN0LmJvdHRvbSwgcm93Qm90KTtcbiAgICAgICAgICAgICAgICByb3dUb3AgPSBNYXRoLm1pbihyZWN0LnRvcCwgcm93VG9wKTtcbiAgICAgICAgICAgICAgICBsZXQgZHggPSByZWN0LmxlZnQgPiBjb29yZHMubGVmdCA/IHJlY3QubGVmdCAtIGNvb3Jkcy5sZWZ0XG4gICAgICAgICAgICAgICAgICAgIDogcmVjdC5yaWdodCA8IGNvb3Jkcy5sZWZ0ID8gY29vcmRzLmxlZnQgLSByZWN0LnJpZ2h0IDogMDtcbiAgICAgICAgICAgICAgICBpZiAoZHggPCBkeENsb3Nlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBkeENsb3Nlc3QgPSBkeDtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzQ2xvc2VzdCA9IGR4ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMyA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCA/IHJlY3QucmlnaHQgOiByZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGNvb3Jkcy50b3BcbiAgICAgICAgICAgICAgICAgICAgfSA6IGNvb3JkcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEgJiYgZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBjaGlsZEluZGV4ICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QudG9wID4gY29vcmRzLnRvcCAmJiAhZmlyc3RCZWxvdyAmJiByZWN0LmxlZnQgPD0gY29vcmRzLmxlZnQgJiYgcmVjdC5yaWdodCA+PSBjb29yZHMubGVmdCkge1xuICAgICAgICAgICAgICAgIGZpcnN0QmVsb3cgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBjb29yZHNCZWxvdyA9IHsgbGVmdDogTWF0aC5tYXgocmVjdC5sZWZ0LCBNYXRoLm1pbihyZWN0LnJpZ2h0LCBjb29yZHMubGVmdCkpLCB0b3A6IHJlY3QudG9wIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNsb3Nlc3QgJiYgKGNvb3Jkcy5sZWZ0ID49IHJlY3QucmlnaHQgJiYgY29vcmRzLnRvcCA+PSByZWN0LnRvcCB8fFxuICAgICAgICAgICAgICAgIGNvb3Jkcy5sZWZ0ID49IHJlY3QubGVmdCAmJiBjb29yZHMudG9wID49IHJlY3QuYm90dG9tKSlcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBjaGlsZEluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNsb3Nlc3QgJiYgZmlyc3RCZWxvdykge1xuICAgICAgICBjbG9zZXN0ID0gZmlyc3RCZWxvdztcbiAgICAgICAgY29vcmRzQ2xvc2VzdCA9IGNvb3Jkc0JlbG93O1xuICAgICAgICBkeENsb3Nlc3QgPSAwO1xuICAgIH1cbiAgICBpZiAoY2xvc2VzdCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgIHJldHVybiBmaW5kT2Zmc2V0SW5UZXh0KGNsb3Nlc3QsIGNvb3Jkc0Nsb3Nlc3QpO1xuICAgIGlmICghY2xvc2VzdCB8fCAoZHhDbG9zZXN0ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMSkpXG4gICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldCB9O1xuICAgIHJldHVybiBmaW5kT2Zmc2V0SW5Ob2RlKGNsb3Nlc3QsIGNvb3Jkc0Nsb3Nlc3QpO1xufVxuZnVuY3Rpb24gZmluZE9mZnNldEluVGV4dChub2RlLCBjb29yZHMpIHtcbiAgICBsZXQgbGVuID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgaSArIDEpO1xuICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCBpKTtcbiAgICAgICAgbGV0IHJlY3QgPSBzaW5nbGVSZWN0KHJhbmdlLCAxKTtcbiAgICAgICAgaWYgKHJlY3QudG9wID09IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChpblJlY3QoY29vcmRzLCByZWN0KSlcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogaSArIChjb29yZHMubGVmdCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IDApIH07XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogMCB9O1xufVxuZnVuY3Rpb24gaW5SZWN0KGNvb3JkcywgcmVjdCkge1xuICAgIHJldHVybiBjb29yZHMubGVmdCA+PSByZWN0LmxlZnQgLSAxICYmIGNvb3Jkcy5sZWZ0IDw9IHJlY3QucmlnaHQgKyAxICYmXG4gICAgICAgIGNvb3Jkcy50b3AgPj0gcmVjdC50b3AgLSAxICYmIGNvb3Jkcy50b3AgPD0gcmVjdC5ib3R0b20gKyAxO1xufVxuZnVuY3Rpb24gdGFyZ2V0S2x1ZGdlKGRvbSwgY29vcmRzKSB7XG4gICAgbGV0IHBhcmVudCA9IGRvbS5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQgJiYgL15saSQvaS50ZXN0KHBhcmVudC5ub2RlTmFtZSkgJiYgY29vcmRzLmxlZnQgPCBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdClcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICByZXR1cm4gZG9tO1xufVxuZnVuY3Rpb24gcG9zRnJvbUVsZW1lbnQodmlldywgZWx0LCBjb29yZHMpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IGZpbmRPZmZzZXRJbk5vZGUoZWx0LCBjb29yZHMpLCBiaWFzID0gLTE7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiAhbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIGxldCByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgYmlhcyA9IHJlY3QubGVmdCAhPSByZWN0LnJpZ2h0ICYmIGNvb3Jkcy5sZWZ0ID4gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgYmlhcyk7XG59XG5mdW5jdGlvbiBwb3NGcm9tQ2FyZXQodmlldywgbm9kZSwgb2Zmc2V0LCBjb29yZHMpIHtcbiAgICAvLyBCcm93c2VyIChpbiBjYXJldFBvc2l0aW9uL1JhbmdlRnJvbVBvaW50KSB3aWxsIGFncmVzc2l2ZWx5XG4gICAgLy8gbm9ybWFsaXplIHRvd2FyZHMgbmVhcmJ5IGlubGluZSBub2Rlcy4gU2luY2Ugd2UgYXJlIGludGVyZXN0ZWQgaW5cbiAgICAvLyBwb3NpdGlvbnMgYmV0d2VlbiBibG9jayBub2RlcyB0b28sIHdlIGZpcnN0IHdhbGsgdXAgdGhlIGhpZXJhcmNoeVxuICAgIC8vIG9mIG5vZGVzIHRvIHNlZSBpZiB0aGVyZSBhcmUgYmxvY2sgbm9kZXMgdGhhdCB0aGUgY29vcmRpbmF0ZXNcbiAgICAvLyBmYWxsIG91dHNpZGUgb2YuIElmIHNvLCB3ZSB0YWtlIHRoZSBwb3NpdGlvbiBiZWZvcmUvYWZ0ZXIgdGhhdFxuICAgIC8vIGJsb2NrLiBJZiBub3QsIHdlIGNhbGwgYHBvc0Zyb21ET01gIG9uIHRoZSByYXcgbm9kZS9vZmZzZXQuXG4gICAgbGV0IG91dHNpZGVCbG9jayA9IC0xO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGUsIHNhd0Jsb2NrID0gZmFsc2U7Oykge1xuICAgICAgICBpZiAoY3VyID09IHZpZXcuZG9tKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGN1ciwgdHJ1ZSk7XG4gICAgICAgIGlmICghZGVzYylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoZGVzYy5kb20ubm9kZVR5cGUgPT0gMSAmJiAoZGVzYy5ub2RlLmlzQmxvY2sgJiYgZGVzYy5wYXJlbnQgJiYgIXNhd0Jsb2NrIHx8ICFkZXNjLmNvbnRlbnRET00pKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IGRlc2MuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgaWYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50ICYmICFzYXdCbG9jaykge1xuICAgICAgICAgICAgICAgIHNhd0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC5sZWZ0ID4gY29vcmRzLmxlZnQgfHwgcmVjdC50b3AgPiBjb29yZHMudG9wKVxuICAgICAgICAgICAgICAgICAgICBvdXRzaWRlQmxvY2sgPSBkZXNjLnBvc0JlZm9yZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgfHwgcmVjdC5ib3R0b20gPCBjb29yZHMudG9wKVxuICAgICAgICAgICAgICAgICAgICBvdXRzaWRlQmxvY2sgPSBkZXNjLnBvc0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXNjLmNvbnRlbnRET00gJiYgb3V0c2lkZUJsb2NrIDwgMCAmJiAhZGVzYy5ub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBpbnNpZGUgYSBsZWFmLCByZXR1cm4gdGhlIHNpZGUgb2YgdGhlIGxlYWYgY2xvc2VyIHRvIHRoZSBjb29yZHNcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gZGVzYy5ub2RlLmlzQmxvY2sgPyBjb29yZHMudG9wIDwgKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMlxuICAgICAgICAgICAgICAgICAgICA6IGNvb3Jkcy5sZWZ0IDwgKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlID8gZGVzYy5wb3NCZWZvcmUgOiBkZXNjLnBvc0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGRlc2MuZG9tLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBvdXRzaWRlQmxvY2sgPiAtMSA/IG91dHNpZGVCbG9jayA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgLTEpO1xufVxuZnVuY3Rpb24gZWxlbWVudEZyb21Qb2ludChlbGVtZW50LCBjb29yZHMsIGJveCkge1xuICAgIGxldCBsZW4gPSBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGlmIChsZW4gJiYgYm94LnRvcCA8IGJveC5ib3R0b20pIHtcbiAgICAgICAgZm9yIChsZXQgc3RhcnRJID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGVuIC0gMSwgTWF0aC5mbG9vcihsZW4gKiAoY29vcmRzLnRvcCAtIGJveC50b3ApIC8gKGJveC5ib3R0b20gLSBib3gudG9wKSkgLSAyKSksIGkgPSBzdGFydEk7Oykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluUmVjdChjb29yZHMsIHJlY3QpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRGcm9tUG9pbnQoY2hpbGQsIGNvb3JkcywgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpID0gKGkgKyAxKSAlIGxlbikgPT0gc3RhcnRJKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuLy8gR2l2ZW4gYW4geCx5IHBvc2l0aW9uIG9uIHRoZSBlZGl0b3IsIGdldCB0aGUgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LlxuZnVuY3Rpb24gcG9zQXRDb29yZHModmlldywgY29vcmRzKSB7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQsIG5vZGUsIG9mZnNldCA9IDA7XG4gICAgbGV0IGNhcmV0ID0gY2FyZXRGcm9tUG9pbnQoZG9jLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgaWYgKGNhcmV0KVxuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGNhcmV0KTtcbiAgICBsZXQgZWx0ID0gKHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50ID8gdmlldy5yb290IDogZG9jKVxuICAgICAgICAuZWxlbWVudEZyb21Qb2ludChjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgbGV0IHBvcztcbiAgICBpZiAoIWVsdCB8fCAhdmlldy5kb20uY29udGFpbnMoZWx0Lm5vZGVUeXBlICE9IDEgPyBlbHQucGFyZW50Tm9kZSA6IGVsdCkpIHtcbiAgICAgICAgbGV0IGJveCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIWluUmVjdChjb29yZHMsIGJveCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZWx0ID0gZWxlbWVudEZyb21Qb2ludCh2aWV3LmRvbSwgY29vcmRzLCBib3gpO1xuICAgICAgICBpZiAoIWVsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBTYWZhcmkncyBjYXJldFJhbmdlRnJvbVBvaW50IHJldHVybnMgbm9uc2Vuc2Ugd2hlbiBvbiBhIGRyYWdnYWJsZSBlbGVtZW50XG4gICAgaWYgKHNhZmFyaSkge1xuICAgICAgICBmb3IgKGxldCBwID0gZWx0OyBub2RlICYmIHA7IHAgPSBwYXJlbnROb2RlKHApKVxuICAgICAgICAgICAgaWYgKHAuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsdCA9IHRhcmdldEtsdWRnZShlbHQsIGNvb3Jkcyk7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKGdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgLy8gRmlyZWZveCB3aWxsIHNvbWV0aW1lcyByZXR1cm4gb2Zmc2V0cyBpbnRvIDxpbnB1dD4gbm9kZXMsIHdoaWNoXG4gICAgICAgICAgICAvLyBoYXZlIG5vIGFjdHVhbCBjaGlsZHJlbiwgZnJvbSBjYXJldFBvc2l0aW9uRnJvbVBvaW50ICgjOTUzKVxuICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0LCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIEl0J2xsIGFsc28gbW92ZSB0aGUgcmV0dXJuZWQgcG9zaXRpb24gYmVmb3JlIGltYWdlIG5vZGVzLFxuICAgICAgICAgICAgLy8gZXZlbiBpZiB0aG9zZSBhcmUgYmVoaW5kIGl0LlxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLCBib3g7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubm9kZU5hbWUgPT0gXCJJTUdcIiAmJiAoYm94ID0gbmV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkucmlnaHQgPD0gY29vcmRzLmxlZnQgJiZcbiAgICAgICAgICAgICAgICAgICAgYm94LmJvdHRvbSA+IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwcmV2O1xuICAgICAgICAvLyBXaGVuIGNsaWNraW5nIGFib3ZlIHRoZSByaWdodCBzaWRlIG9mIGFuIHVuZWRpdGFibGUgbm9kZSwgQ2hyb21lIHdpbGwgcmVwb3J0IGEgY3Vyc29yIHBvc2l0aW9uIGFmdGVyIHRoYXQgbm9kZS5cbiAgICAgICAgaWYgKHdlYmtpdCAmJiBvZmZzZXQgJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIChwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdKS5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICBwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgJiYgcHJldi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgPj0gY29vcmRzLnRvcClcbiAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAvLyBTdXNwaWNpb3VzbHkgc3BlY2lmaWMga2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGNhcmV0KkZyb21Qb2ludFxuICAgICAgICAvLyBuZXZlciByZXR1cm5pbmcgYSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSAmJiBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgJiYgbm9kZS5sYXN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgY29vcmRzLnRvcCA+IG5vZGUubGFzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSlcbiAgICAgICAgICAgIHBvcyA9IHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgLy8gSWdub3JlIHBvc2l0aW9ucyBkaXJlY3RseSBhZnRlciBhIEJSLCBzaW5jZSBjYXJldCpGcm9tUG9pbnRcbiAgICAgICAgLy8gJ3JvdW5kIHVwJyBwb3NpdGlvbnMgdGhhdCB3b3VsZCBiZSBtb3JlIGFjY3VyYXRlbHkgcGxhY2VkXG4gICAgICAgIC8vIGJlZm9yZSB0aGUgQlIgbm9kZS5cbiAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID09IDAgfHwgbm9kZS5ub2RlVHlwZSAhPSAxIHx8IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5ub2RlTmFtZSAhPSBcIkJSXCIpXG4gICAgICAgICAgICBwb3MgPSBwb3NGcm9tQ2FyZXQodmlldywgbm9kZSwgb2Zmc2V0LCBjb29yZHMpO1xuICAgIH1cbiAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgIHBvcyA9IHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKTtcbiAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhlbHQsIHRydWUpO1xuICAgIHJldHVybiB7IHBvcywgaW5zaWRlOiBkZXNjID8gZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIgOiAtMSB9O1xufVxuZnVuY3Rpb24gbm9uWmVybyhyZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wIDwgcmVjdC5ib3R0b20gfHwgcmVjdC5sZWZ0IDwgcmVjdC5yaWdodDtcbn1cbmZ1bmN0aW9uIHNpbmdsZVJlY3QodGFyZ2V0LCBiaWFzKSB7XG4gICAgbGV0IHJlY3RzID0gdGFyZ2V0LmdldENsaWVudFJlY3RzKCk7XG4gICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICBsZXQgZmlyc3QgPSByZWN0c1tiaWFzIDwgMCA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKG5vblplcm8oZmlyc3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChyZWN0cywgbm9uWmVybykgfHwgdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuY29uc3QgQklESSA9IC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXS87XG4vLyBHaXZlbiBhIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBtb2RlbCwgZ2V0IGEgYm91bmRpbmcgYm94IG9mIHRoZVxuLy8gY2hhcmFjdGVyIGF0IHRoYXQgcG9zaXRpb24sIHJlbGF0aXZlIHRvIHRoZSB3aW5kb3cuXG5mdW5jdGlvbiBjb29yZHNBdFBvcyh2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQsIGF0b20gfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgc2lkZSA8IDAgPyAtMSA6IDEpO1xuICAgIGxldCBzdXBwb3J0RW1wdHlSYW5nZSA9IHdlYmtpdCB8fCBnZWNrbztcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgIC8vIFRoZXNlIGJyb3dzZXJzIHN1cHBvcnQgcXVlcnlpbmcgZW1wdHkgdGV4dCByYW5nZXMuIFByZWZlciB0aGF0IGluXG4gICAgICAgIC8vIGJpZGkgY29udGV4dCBvciB3aGVuIGF0IHRoZSBlbmQgb2YgYSBub2RlLlxuICAgICAgICBpZiAoc3VwcG9ydEVtcHR5UmFuZ2UgJiYgKEJJREkudGVzdChub2RlLm5vZGVWYWx1ZSkgfHwgKHNpZGUgPCAwID8gIW9mZnNldCA6IG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKSkge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCksIHNpZGUpO1xuICAgICAgICAgICAgLy8gRmlyZWZveCByZXR1cm5zIGJhZCByZXN1bHRzICh0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBzcGFjZSlcbiAgICAgICAgICAgIC8vIHdoZW4gcXVlcnlpbmcgYSBwb3NpdGlvbiBkaXJlY3RseSBhZnRlciBsaW5lLWJyb2tlblxuICAgICAgICAgICAgLy8gd2hpdGVzcGFjZS4gRGV0ZWN0IHRoaXMgc2l0dWF0aW9uIGFuZCBhbmQga2x1ZGdlIGFyb3VuZCBpdFxuICAgICAgICAgICAgaWYgKGdlY2tvICYmIG9mZnNldCAmJiAvXFxzLy50ZXN0KG5vZGUubm9kZVZhbHVlW29mZnNldCAtIDFdKSAmJiBvZmZzZXQgPCBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdEJlZm9yZSA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCAtIDEsIG9mZnNldCAtIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3RCZWZvcmUudG9wID09IHJlY3QudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0QWZ0ZXIgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCArIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0QWZ0ZXIudG9wICE9IHJlY3QudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5WKHJlY3RBZnRlciwgcmVjdEFmdGVyLmxlZnQgPCByZWN0QmVmb3JlLmxlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBvZmZzZXQsIHRvID0gb2Zmc2V0LCB0YWtlU2lkZSA9IHNpZGUgPCAwID8gMSA6IC0xO1xuICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmICFvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIHRha2VTaWRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlID49IDAgJiYgb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgICAgICB0YWtlU2lkZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlIDwgMCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8pLCB0YWtlU2lkZSksIHRha2VTaWRlIDwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0ICRkb20gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyAtIChhdG9tIHx8IDApKTtcbiAgICAvLyBSZXR1cm4gYSBob3Jpem9udGFsIGxpbmUgaW4gYmxvY2sgY29udGV4dFxuICAgIGlmICghJGRvbS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYmVmb3JlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBpZiAoYWZ0ZXIubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYWZ0ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0dGVuSChub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzaWRlID49IDApO1xuICAgIH1cbiAgICAvLyBJbmxpbmUsIG5vdCBpbiB0ZXh0IG5vZGUgKHRoaXMgaXMgbm90IEJpZGktc2FmZSlcbiAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gYmVmb3JlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoYmVmb3JlLCBub2RlU2l6ZShiZWZvcmUpIC0gKHN1cHBvcnRFbXB0eVJhbmdlID8gMCA6IDEpKVxuICAgICAgICAgICAgLy8gQlIgbm9kZXMgdGVuZCB0byBvbmx5IHJldHVybiB0aGUgcmVjdGFuZ2xlIGJlZm9yZSB0aGVtLlxuICAgICAgICAgICAgLy8gT25seSB1c2UgdGhlbSBpZiB0aGV5IGFyZSB0aGUgbGFzdCBlbGVtZW50IGluIHRoZWlyIHBhcmVudFxuICAgICAgICAgICAgOiBiZWZvcmUubm9kZVR5cGUgPT0gMSAmJiAoYmVmb3JlLm5vZGVOYW1lICE9IFwiQlJcIiB8fCAhYmVmb3JlLm5leHRTaWJsaW5nKSA/IGJlZm9yZSA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIDEpLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0IDwgbm9kZVNpemUobm9kZSkpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIHdoaWxlIChhZnRlci5wbVZpZXdEZXNjICYmIGFmdGVyLnBtVmlld0Rlc2MuaWdub3JlRm9yQ29vcmRzKVxuICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZztcbiAgICAgICAgbGV0IHRhcmdldCA9ICFhZnRlciA/IG51bGwgOiBhZnRlci5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKGFmdGVyLCAwLCAoc3VwcG9ydEVtcHR5UmFuZ2UgPyAwIDogMSkpXG4gICAgICAgICAgICA6IGFmdGVyLm5vZGVUeXBlID09IDEgPyBhZnRlciA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIC0xKSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIEFsbCBlbHNlIGZhaWxlZCwganVzdCB0cnkgdG8gZ2V0IGEgcmVjdGFuZ2xlIGZvciB0aGUgdGFyZ2V0IG5vZGVcbiAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdChub2RlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2Uobm9kZSkgOiBub2RlLCAtc2lkZSksIHNpZGUgPj0gMCk7XG59XG5mdW5jdGlvbiBmbGF0dGVuVihyZWN0LCBsZWZ0KSB7XG4gICAgaWYgKHJlY3Qud2lkdGggPT0gMClcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgbGV0IHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICByZXR1cm4geyB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QuYm90dG9tLCBsZWZ0OiB4LCByaWdodDogeCB9O1xufVxuZnVuY3Rpb24gZmxhdHRlbkgocmVjdCwgdG9wKSB7XG4gICAgaWYgKHJlY3QuaGVpZ2h0ID09IDApXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIGxldCB5ID0gdG9wID8gcmVjdC50b3AgOiByZWN0LmJvdHRvbTtcbiAgICByZXR1cm4geyB0b3A6IHksIGJvdHRvbTogeSwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCB9O1xufVxuZnVuY3Rpb24gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgZikge1xuICAgIGxldCB2aWV3U3RhdGUgPSB2aWV3LnN0YXRlLCBhY3RpdmUgPSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAodmlld1N0YXRlICE9IHN0YXRlKVxuICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICBpZiAoYWN0aXZlICE9IHZpZXcuZG9tKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmICh2aWV3U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHZpZXdTdGF0ZSk7XG4gICAgICAgIGlmIChhY3RpdmUgIT0gdmlldy5kb20gJiYgYWN0aXZlKVxuICAgICAgICAgICAgYWN0aXZlLmZvY3VzKCk7XG4gICAgfVxufVxuLy8gV2hldGhlciB2ZXJ0aWNhbCBwb3NpdGlvbiBtb3Rpb24gaW4gYSBnaXZlbiBkaXJlY3Rpb25cbi8vIGZyb20gYSBwb3NpdGlvbiB3b3VsZCBsZWF2ZSBhIHRleHQgYmxvY2suXG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja1ZlcnRpY2FsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCAkcG9zID0gZGlyID09IFwidXBcIiA/IHNlbC4kZnJvbSA6IHNlbC4kdG87XG4gICAgcmV0dXJuIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsICgpID0+IHtcbiAgICAgICAgbGV0IHsgbm9kZTogZG9tIH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcygkcG9zLnBvcywgZGlyID09IFwidXBcIiA/IC0xIDogMSk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZWFyZXN0ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGRvbSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIW5lYXJlc3QpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobmVhcmVzdC5ub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICBkb20gPSBuZWFyZXN0LmNvbnRlbnRET00gfHwgbmVhcmVzdC5kb207XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb20gPSBuZWFyZXN0LmRvbS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb29yZHMgPSBjb29yZHNBdFBvcyh2aWV3LCAkcG9zLnBvcywgMSk7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBsZXQgYm94ZXM7XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBib3hlcyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIGJveGVzID0gdGV4dFJhbmdlKGNoaWxkLCAwLCBjaGlsZC5ub2RlVmFsdWUubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYm94LmJvdHRvbSA+IGJveC50b3AgKyAxICYmXG4gICAgICAgICAgICAgICAgICAgIChkaXIgPT0gXCJ1cFwiID8gY29vcmRzLnRvcCAtIGJveC50b3AgPiAoYm94LmJvdHRvbSAtIGNvb3Jkcy50b3ApICogMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBib3guYm90dG9tIC0gY29vcmRzLmJvdHRvbSA+IChjb29yZHMuYm90dG9tIC0gYm94LnRvcCkgKiAyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xufVxuY29uc3QgbWF5YmVSVEwgPSAvW1xcdTA1OTAtXFx1MDhhY10vO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgeyAkaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9ICRoZWFkLnBhcmVudE9mZnNldCwgYXRTdGFydCA9ICFvZmZzZXQsIGF0RW5kID0gb2Zmc2V0ID09ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemU7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgLy8gSWYgdGhlIHRleHRibG9jayBpcyBhbGwgTFRSLCBvciB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnRcbiAgICAvLyBTZWxlY3Rpb24ubW9kaWZ5IChFZGdlKSwgZmFsbCBiYWNrIHRvIGEgcHJpbWl0aXZlIGFwcHJvYWNoXG4gICAgaWYgKCFtYXliZVJUTC50ZXN0KCRoZWFkLnBhcmVudC50ZXh0Q29udGVudCkgfHwgIXNlbC5tb2RpZnkpXG4gICAgICAgIHJldHVybiBkaXIgPT0gXCJsZWZ0XCIgfHwgZGlyID09IFwiYmFja3dhcmRcIiA/IGF0U3RhcnQgOiBhdEVuZDtcbiAgICByZXR1cm4gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgKCkgPT4ge1xuICAgICAgICAvLyBUaGlzIGlzIGEgaHVnZSBoYWNrLCBidXQgYXBwZWFycyB0byBiZSB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gY3VycmVudGx5IGRvOiB1c2UgYFNlbGVjdGlvbi5tb2RpZnlgIHRvIG1vdmUgdGhlIHNlbGVjdGlvbiBieVxuICAgICAgICAvLyBvbmUgY2hhcmFjdGVyLCBhbmQgc2VlIGlmIHRoYXQgbW92ZXMgdGhlIGN1cnNvciBvdXQgb2YgdGhlXG4gICAgICAgIC8vIHRleHRibG9jayAob3IgZG9lc24ndCBtb3ZlIGl0IGF0IGFsbCwgd2hlbiBhdCB0aGUgc3RhcnQvZW5kIG9mXG4gICAgICAgIC8vIHRoZSBkb2N1bWVudCkuXG4gICAgICAgIGxldCB7IGZvY3VzTm9kZTogb2xkTm9kZSwgZm9jdXNPZmZzZXQ6IG9sZE9mZiwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBvbGRCaWRpTGV2ZWwgPSBzZWwuY2FyZXRCaWRpTGV2ZWwgLy8gT25seSBmb3IgRmlyZWZveFxuICAgICAgICA7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGRpciwgXCJjaGFyYWN0ZXJcIik7XG4gICAgICAgIGxldCBwYXJlbnRET00gPSAkaGVhZC5kZXB0aCA/IHZpZXcuZG9jVmlldy5kb21BZnRlclBvcygkaGVhZC5iZWZvcmUoKSkgOiB2aWV3LmRvbTtcbiAgICAgICAgbGV0IHsgZm9jdXNOb2RlOiBuZXdOb2RlLCBmb2N1c09mZnNldDogbmV3T2ZmIH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXdOb2RlICYmICFwYXJlbnRET00uY29udGFpbnMobmV3Tm9kZS5ub2RlVHlwZSA9PSAxID8gbmV3Tm9kZSA6IG5ld05vZGUucGFyZW50Tm9kZSkgfHxcbiAgICAgICAgICAgIChvbGROb2RlID09IG5ld05vZGUgJiYgb2xkT2ZmID09IG5ld09mZik7XG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICBpZiAob2xkTm9kZSAmJiAob2xkTm9kZSAhPSBhbmNob3JOb2RlIHx8IG9sZE9mZiAhPSBhbmNob3JPZmZzZXQpICYmIHNlbC5leHRlbmQpXG4gICAgICAgICAgICAgICAgc2VsLmV4dGVuZChvbGROb2RlLCBvbGRPZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgaWYgKG9sZEJpZGlMZXZlbCAhPSBudWxsKVxuICAgICAgICAgICAgc2VsLmNhcmV0QmlkaUxldmVsID0gb2xkQmlkaUxldmVsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxubGV0IGNhY2hlZFN0YXRlID0gbnVsbDtcbmxldCBjYWNoZWREaXIgPSBudWxsO1xubGV0IGNhY2hlZFJlc3VsdCA9IGZhbHNlO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2sodmlldywgc3RhdGUsIGRpcikge1xuICAgIGlmIChjYWNoZWRTdGF0ZSA9PSBzdGF0ZSAmJiBjYWNoZWREaXIgPT0gZGlyKVxuICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICAgIGNhY2hlZFN0YXRlID0gc3RhdGU7XG4gICAgY2FjaGVkRGlyID0gZGlyO1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQgPSBkaXIgPT0gXCJ1cFwiIHx8IGRpciA9PSBcImRvd25cIlxuICAgICAgICA/IGVuZE9mVGV4dGJsb2NrVmVydGljYWwodmlldywgc3RhdGUsIGRpcilcbiAgICAgICAgOiBlbmRPZlRleHRibG9ja0hvcml6b250YWwodmlldywgc3RhdGUsIGRpcik7XG59XG5cbi8vIFZpZXcgZGVzY3JpcHRpb25zIGFyZSBkYXRhIHN0cnVjdHVyZXMgdGhhdCBkZXNjcmliZSB0aGUgRE9NIHRoYXQgaXNcbi8vIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBlZGl0b3IncyBjb250ZW50LiBUaGV5IGFyZSB1c2VkIGZvcjpcbi8vXG4vLyAtIEluY3JlbWVudGFsIHJlZHJhd2luZyB3aGVuIHRoZSBkb2N1bWVudCBjaGFuZ2VzXG4vL1xuLy8gLSBGaWd1cmluZyBvdXQgd2hhdCBwYXJ0IG9mIHRoZSBkb2N1bWVudCBhIGdpdmVuIERPTSBwb3NpdGlvblxuLy8gICBjb3JyZXNwb25kcyB0b1xuLy9cbi8vIC0gV2lyaW5nIGluIGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIGVkaXRpbmcgaW50ZXJmYWNlIGZvciBhXG4vLyAgIGdpdmVuIG5vZGVcbi8vXG4vLyBUaGV5IGZvcm0gYSBkb3VibHktbGlua2VkIG11dGFibGUgdHJlZSwgc3RhcnRpbmcgYXQgYHZpZXcuZG9jVmlld2AuXG5jb25zdCBOT1RfRElSVFkgPSAwLCBDSElMRF9ESVJUWSA9IDEsIENPTlRFTlRfRElSVFkgPSAyLCBOT0RFX0RJUlRZID0gMztcbi8vIFN1cGVyY2xhc3MgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIGRlc2NyaXB0aW9ucy4gRGVmaW5lcyB0aGVpclxuLy8gYmFzaWMgc3RydWN0dXJlIGFuZCBzaGFyZWQgbWV0aG9kcy5cbmNsYXNzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGNoaWxkcmVuLCBkb20sIFxuICAgIC8vIFRoaXMgaXMgdGhlIG5vZGUgdGhhdCBob2xkcyB0aGUgY2hpbGQgdmlld3MuIEl0IG1heSBiZSBudWxsIGZvclxuICAgIC8vIGRlc2NzIHRoYXQgZG9uJ3QgaGF2ZSBjaGlsZHJlbi5cbiAgICBjb250ZW50RE9NKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBjb250ZW50RE9NO1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAvLyBBbiBleHBhbmRvIHByb3BlcnR5IG9uIHRoZSBET00gbm9kZSBwcm92aWRlcyBhIGxpbmsgYmFjayB0byBpdHNcbiAgICAgICAgLy8gZGVzY3JpcHRpb24uXG4gICAgICAgIGRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICB9XG4gICAgLy8gVXNlZCB0byBjaGVjayB3aGV0aGVyIGEgZ2l2ZW4gZGVzY3JpcHRpb24gY29ycmVzcG9uZHMgdG8gYVxuICAgIC8vIHdpZGdldC9tYXJrL25vZGUuXG4gICAgbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbWF0Y2hlc01hcmsobWFyaykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzSGFjayhub2RlTmFtZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvLyBXaGVuIHBhcnNpbmcgaW4tZWRpdG9yIGNvbnRlbnQgKGluIGRvbWNoYW5nZS5qcyksIHdlIGFsbG93XG4gICAgLy8gZGVzY3JpcHRpb25zIHRvIGRldGVybWluZSB0aGUgcGFyc2UgcnVsZXMgdGhhdCBzaG91bGQgYmUgdXNlZCB0b1xuICAgIC8vIHBhcnNlIHRoZW0uXG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8vIFVzZWQgYnkgdGhlIGVkaXRvcidzIGV2ZW50IGhhbmRsZXIgdG8gaWdub3JlIGV2ZW50cyB0aGF0IGNvbWVcbiAgICAvLyBmcm9tIGNlcnRhaW4gZGVzY3MuXG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIFRoZSBzaXplIG9mIHRoZSBjb250ZW50IHJlcHJlc2VudGVkIGJ5IHRoaXMgZGVzYy5cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBzaXplICs9IHRoaXMuY2hpbGRyZW5baV0uc2l6ZTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8vIEZvciBibG9jayBub2RlcywgdGhpcyByZXByZXNlbnRzIHRoZSBzcGFjZSB0YWtlbiB1cCBieSB0aGVpclxuICAgIC8vIHN0YXJ0L2VuZCB0b2tlbnMuXG4gICAgZ2V0IGJvcmRlcigpIHsgcmV0dXJuIDA7IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuZG9tLnBtVmlld0Rlc2MgPT0gdGhpcylcbiAgICAgICAgICAgIHRoaXMuZG9tLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICBwb3NCZWZvcmVDaGlsZChjaGlsZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gdGhpcy5wb3NBdFN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjdXIgPT0gY2hpbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjdXIuc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcG9zQmVmb3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zQmVmb3JlQ2hpbGQodGhpcyk7XG4gICAgfVxuICAgIGdldCBwb3NBdFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKSArIHRoaXMuYm9yZGVyIDogMDtcbiAgICB9XG4gICAgZ2V0IHBvc0FmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUgKyB0aGlzLnNpemU7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMuc2l6ZSAtIDIgKiB0aGlzLmJvcmRlcjtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIC8vIElmIHRoZSBET00gcG9zaXRpb24gaXMgaW4gdGhlIGNvbnRlbnQsIHVzZSB0aGUgY2hpbGQgZGVzYyBhZnRlclxuICAgICAgICAvLyBpdCB0byBmaWd1cmUgb3V0IGEgcG9zaXRpb24uXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoYmlhcyA8IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQmVmb3JlLCBkZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkb20gPT0gdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21CZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tQmVmb3JlICYmICEoKGRlc2MgPSBkb21CZWZvcmUucG1WaWV3RGVzYykgJiYgZGVzYy5wYXJlbnQgPT0gdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbUJlZm9yZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUJlZm9yZSA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYykgKyBkZXNjLnNpemUgOiB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQWZ0ZXIsIGRlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbUFmdGVyICYmICEoKGRlc2MgPSBkb21BZnRlci5wbVZpZXdEZXNjKSAmJiBkZXNjLnBhcmVudCA9PSB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb21BZnRlci5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQWZ0ZXIgPyB0aGlzLnBvc0JlZm9yZUNoaWxkKGRlc2MpIDogdGhpcy5wb3NBdEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHVzZSB2YXJpb3VzIGhldXJpc3RpY3MsIGZhbGxpbmcgYmFjayBvbiB0aGUgYmlhc1xuICAgICAgICAvLyBwYXJhbWV0ZXIsIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldHVybiB0aGUgcG9zaXRpb24gYXQgdGhlXG4gICAgICAgIC8vIHN0YXJ0IG9yIGF0IHRoZSBlbmQgb2YgdGhpcyB2aWV3IGRlc2MuXG4gICAgICAgIGxldCBhdEVuZDtcbiAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmRvbSAmJiB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIGF0RW5kID0gb2Zmc2V0ID4gZG9tSW5kZXgodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NICE9IHRoaXMuZG9tICYmIHRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSkpIHtcbiAgICAgICAgICAgIGF0RW5kID0gZG9tLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuY29udGVudERPTSkgJiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gMClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSBkb207OyBzZWFyY2ggPSBzZWFyY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdEVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5wcmV2aW91c1NpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXRFbmQgPT0gbnVsbCAmJiBvZmZzZXQgPT0gZG9tLmNoaWxkTm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IGRvbTs7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0RW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2gubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhdEVuZCA9PSBudWxsID8gYmlhcyA+IDAgOiBhdEVuZCkgPyB0aGlzLnBvc0F0RW5kIDogdGhpcy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgICBuZWFyZXN0RGVzYyhkb20sIG9ubHlOb2RlcyA9IGZhbHNlKSB7XG4gICAgICAgIGZvciAobGV0IGZpcnN0ID0gdHJ1ZSwgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZ2V0RGVzYyhjdXIpLCBub2RlRE9NO1xuICAgICAgICAgICAgaWYgKGRlc2MgJiYgKCFvbmx5Tm9kZXMgfHwgZGVzYy5ub2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGRvbSBpcyBvdXRzaWRlIG9mIHRoaXMgZGVzYydzIG5vZGVET00sIGRvbid0IGNvdW50IGl0LlxuICAgICAgICAgICAgICAgIGlmIChmaXJzdCAmJiAobm9kZURPTSA9IGRlc2Mubm9kZURPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlRE9NLm5vZGVUeXBlID09IDEgPyBub2RlRE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpIDogbm9kZURPTSA9PSBkb20pKVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVzYyhkb20pIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICAgICAgZm9yIChsZXQgY3VyID0gZGVzYzsgY3VyOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICAgICAgaWYgKGN1ciA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBkb207IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gdGhpcy5nZXREZXNjKHNjYW4pO1xuICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MubG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGRlc2MgZm9yIHRoZSBub2RlIGFmdGVyIHRoZSBnaXZlbiBwb3MsIGlmIGFueS4gKFdoZW4gYVxuICAgIC8vIHBhcmVudCBub2RlIG92ZXJyb2RlIHJlbmRlcmluZywgdGhlcmUgbWlnaHQgbm90IGJlIG9uZS4pXG4gICAgZGVzY0F0KHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IHBvcyAmJiBlbmQgIT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFjaGlsZC5ib3JkZXIgJiYgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRlc2NBdChwb3MgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvbUZyb21Qb3MocG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5kb20sIG9mZnNldDogMCwgYXRvbTogcG9zICsgMSB9O1xuICAgICAgICAvLyBGaXJzdCBmaW5kIHRoZSBwb3NpdGlvbiBpbiB0aGUgY2hpbGQgYXJyYXlcbiAgICAgICAgbGV0IGkgPSAwLCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBjdXJQb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gY3VyUG9zICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPiBwb3MgfHwgY2hpbGQgaW5zdGFuY2VvZiBUcmFpbGluZ0hhY2tWaWV3RGVzYykge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHBvcyAtIGN1clBvcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1clBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIHBvaW50cyBpbnRvIHRoZSBtaWRkbGUgb2YgYSBjaGlsZCwgY2FsbCB0aHJvdWdoXG4gICAgICAgIGlmIChvZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21Gcm9tUG9zKG9mZnNldCAtIHRoaXMuY2hpbGRyZW5baV0uYm9yZGVyLCBzaWRlKTtcbiAgICAgICAgLy8gR28gYmFjayBpZiB0aGVyZSB3ZXJlIGFueSB6ZXJvLWxlbmd0aCB3aWRnZXRzIHdpdGggc2lkZSA+PSAwIGJlZm9yZSB0aGlzIHBvaW50XG4gICAgICAgIGZvciAobGV0IHByZXY7IGkgJiYgIShwcmV2ID0gdGhpcy5jaGlsZHJlbltpIC0gMV0pLnNpemUgJiYgcHJldiBpbnN0YW5jZW9mIFdpZGdldFZpZXdEZXNjICYmIHByZXYuc2lkZSA+PSAwOyBpLS0pIHsgfVxuICAgICAgICAvLyBTY2FuIHRvd2FyZHMgdGhlIGZpcnN0IHVzZWFibGUgbm9kZVxuICAgICAgICBpZiAoc2lkZSA8PSAwKSB7XG4gICAgICAgICAgICBsZXQgcHJldiwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpLS0sIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gaSA/IHRoaXMuY2hpbGRyZW5baSAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXYgfHwgcHJldi5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXYgJiYgc2lkZSAmJiBlbnRlciAmJiAhcHJldi5ib3JkZXIgJiYgIXByZXYuZG9tQXRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldi5kb21Gcm9tUG9zKHByZXYuc2l6ZSwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogcHJldiA/IGRvbUluZGV4KHByZXYuZG9tKSArIDEgOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV4dCwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpKyssIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy5jaGlsZHJlbltpXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ICYmIGVudGVyICYmICFuZXh0LmJvcmRlciAmJiAhbmV4dC5kb21BdG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbUZyb21Qb3MoMCwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogbmV4dCA/IGRvbUluZGV4KG5leHQuZG9tKSA6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZWQgdG8gZmluZCBhIERPTSByYW5nZSBpbiBhIHNpbmdsZSBwYXJlbnQgZm9yIGEgZ2l2ZW4gY2hhbmdlZFxuICAgIC8vIHJhbmdlLlxuICAgIHBhcnNlUmFuZ2UoZnJvbSwgdG8sIGJhc2UgPSAwKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tLCB0bywgZnJvbU9mZnNldDogMCwgdG9PZmZzZXQ6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICBsZXQgZnJvbU9mZnNldCA9IC0xLCB0b09mZnNldCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSBiYXNlLCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xICYmIGZyb20gPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkQmFzZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBtYXliZSBkZXNjZW5kIG1hcmsgdmlld3MgdG8gcGFyc2UgYSBuYXJyb3dlciByYW5nZT9cbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjaGlsZEJhc2UgJiYgdG8gPD0gZW5kIC0gY2hpbGQuYm9yZGVyICYmIGNoaWxkLm5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00uY29udGFpbnMoY2hpbGQuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5wYXJzZVJhbmdlKGZyb20sIHRvLCBjaGlsZEJhc2UpO1xuICAgICAgICAgICAgICAgIGZyb20gPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLmNoaWxkcmVuW2ogLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYuc2l6ZSAmJiBwcmV2LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSAmJiAhcHJldi5lbXB0eUNoaWxkQXQoMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21PZmZzZXQgPSBkb21JbmRleChwcmV2LmRvbSkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJvbSAtPSBwcmV2LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBmcm9tT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID4gLTEgJiYgKGVuZCA+IHRvIHx8IGkgPT0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgIHRvID0gZW5kO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5zaXplICYmIG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFuZXh0LmVtcHR5Q2hpbGRBdCgtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gZG9tSW5kZXgobmV4dC5kb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG8gKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9PZmZzZXQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgZnJvbSwgdG8sIGZyb21PZmZzZXQsIHRvT2Zmc2V0IH07XG4gICAgfVxuICAgIGVtcHR5Q2hpbGRBdChzaWRlKSB7XG4gICAgICAgIGlmICh0aGlzLmJvcmRlciB8fCAhdGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltzaWRlIDwgMCA/IDAgOiB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gY2hpbGQuc2l6ZSA9PSAwIHx8IGNoaWxkLmVtcHR5Q2hpbGRBdChzaWRlKTtcbiAgICB9XG4gICAgZG9tQWZ0ZXJQb3MocG9zKSB7XG4gICAgICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gdGhpcy5kb21Gcm9tUG9zKHBvcywgMCk7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEgfHwgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYWZ0ZXIgcG9zIFwiICsgcG9zKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgIH1cbiAgICAvLyBWaWV3IGRlc2NzIGFyZSByZXNwb25zaWJsZSBmb3Igc2V0dGluZyBhbnkgc2VsZWN0aW9uIHRoYXQgZmFsbHNcbiAgICAvLyBlbnRpcmVseSBpbnNpZGUgb2YgdGhlbSwgc28gdGhhdCBjdXN0b20gaW1wbGVtZW50YXRpb25zIGNhbiBkb1xuICAgIC8vIGN1c3RvbSB0aGluZ3Mgd2l0aCB0aGUgc2VsZWN0aW9uLiBOb3RlIHRoYXQgdGhpcyBmYWxscyBhcGFydCB3aGVuXG4gICAgLy8gYSBzZWxlY3Rpb24gc3RhcnRzIGluIHN1Y2ggYSBub2RlIGFuZCBlbmRzIGluIGFub3RoZXIsIGluIHdoaWNoXG4gICAgLy8gY2FzZSB3ZSBqdXN0IHVzZSB3aGF0ZXZlciBkb21Gcm9tUG9zIHByb2R1Y2VzIGFzIGEgYmVzdCBlZmZvcnQuXG4gICAgc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGZhbGxzIGVudGlyZWx5IGluIGEgY2hpbGQsIGdpdmUgaXQgdG8gdGhhdCBjaGlsZFxuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKGFuY2hvciwgaGVhZCksIHRvID0gTWF0aC5tYXgoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGZyb20gPiBvZmZzZXQgJiYgdG8gPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNldFNlbGVjdGlvbihhbmNob3IgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIGhlYWQgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIHJvb3QsIGZvcmNlKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5jaG9yRE9NID0gdGhpcy5kb21Gcm9tUG9zKGFuY2hvciwgYW5jaG9yID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGhlYWRET00gPSBoZWFkID09IGFuY2hvciA/IGFuY2hvckRPTSA6IHRoaXMuZG9tRnJvbVBvcyhoZWFkLCBoZWFkID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGRvbVNlbCA9IHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGxldCBicktsdWRnZSA9IGZhbHNlO1xuICAgICAgICAvLyBPbiBGaXJlZm94LCB1c2luZyBTZWxlY3Rpb24uY29sbGFwc2UgdG8gcHV0IHRoZSBjdXJzb3IgYWZ0ZXIgYVxuICAgICAgICAvLyBCUiBub2RlIGZvciBzb21lIHJlYXNvbiBkb2Vzbid0IGFsd2F5cyB3b3JrICgjMTA3MykuIE9uIFNhZmFyaSxcbiAgICAgICAgLy8gdGhlIGN1cnNvciBzb21ldGltZXMgaW5leHBsaWNhYmxlIHZpc3VhbGx5IGxhZ3MgYmVoaW5kIGl0c1xuICAgICAgICAvLyByZXBvcnRlZCBwb3NpdGlvbiBpbiBzdWNoIHNpdHVhdGlvbnMgKCMxMDkyKS5cbiAgICAgICAgaWYgKChnZWNrbyB8fCBzYWZhcmkpICYmIGFuY2hvciA9PSBoZWFkKSB7XG4gICAgICAgICAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IGFuY2hvckRPTTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICBicktsdWRnZSA9ICEhKG9mZnNldCAmJiBub2RlLm5vZGVWYWx1ZVtvZmZzZXQgLSAxXSA9PSBcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAvLyBJc3N1ZSAjMTEyOFxuICAgICAgICAgICAgICAgIGlmIChicktsdWRnZSAmJiBvZmZzZXQgPT0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBhZnRlcjsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFmdGVyID0gc2Nhbi5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZnRlci5ub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvckRPTSA9IGhlYWRET00gPSB7IG5vZGU6IGFmdGVyLnBhcmVudE5vZGUsIG9mZnNldDogZG9tSW5kZXgoYWZ0ZXIpICsgMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlc2MgPSBzY2FuLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJldiA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICBicktsdWRnZSA9IHByZXYgJiYgKHByZXYubm9kZU5hbWUgPT0gXCJCUlwiIHx8IHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyZWZveCBjYW4gYWN0IHN0cmFuZ2VseSB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgaW4gZnJvbnQgb2YgYW5cbiAgICAgICAgLy8gdW5lZGl0YWJsZSBub2RlLiBTZWUgIzExNjMgYW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE3MDk1MzZcbiAgICAgICAgaWYgKGdlY2tvICYmIGRvbVNlbC5mb2N1c05vZGUgJiYgZG9tU2VsLmZvY3VzTm9kZSAhPSBoZWFkRE9NLm5vZGUgJiYgZG9tU2VsLmZvY3VzTm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBkb21TZWwuZm9jdXNOb2RlLmNoaWxkTm9kZXNbZG9tU2VsLmZvY3VzT2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChhZnRlciAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShmb3JjZSB8fCBicktsdWRnZSAmJiBzYWZhcmkpICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0LCBkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBTZWxlY3Rpb24uZXh0ZW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiAnaW52ZXJ0ZWQnIHNlbGVjdGlvblxuICAgICAgICAvLyAob25lIHdoZXJlIHRoZSBmb2N1cyBpcyBiZWZvcmUgdGhlIGFuY2hvciksIGJ1dCBub3QgYWxsXG4gICAgICAgIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxuICAgICAgICBsZXQgZG9tU2VsRXh0ZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKChkb21TZWwuZXh0ZW5kIHx8IGFuY2hvciA9PSBoZWFkKSAmJiAhYnJLbHVkZ2UpIHtcbiAgICAgICAgICAgIGRvbVNlbC5jb2xsYXBzZShhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhbmNob3IgIT0gaGVhZClcbiAgICAgICAgICAgICAgICAgICAgZG9tU2VsLmV4dGVuZChoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBkb21TZWxFeHRlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMgd2l0aCBDaHJvbWUgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhZnRlciBjYWxsaW5nXG4gICAgICAgICAgICAgICAgLy8gY29sbGFwc2UsIGV2ZW4gd2hlbiBpdCBzaG91bGQgYmUgdmFsaWQuIFRoaXMgYXBwZWFycyB0byBiZSBhIGJ1ZywgYnV0XG4gICAgICAgICAgICAgICAgLy8gaXQgaXMgZGlmZmljdWx0IHRvIGlzb2xhdGUuIElmIHRoaXMgaGFwcGVucyBmYWxsYmFjayB0byB0aGUgb2xkIHBhdGhcbiAgICAgICAgICAgICAgICAvLyB3aXRob3V0IHVzaW5nIGV4dGVuZC5cbiAgICAgICAgICAgICAgICAvLyBTaW1pbGFybHksIHRoaXMgY291bGQgY3Jhc2ggb24gU2FmYXJpIGlmIHRoZSBlZGl0b3IgaXMgaGlkZGVuLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSB3YXMgbm8gc2VsZWN0aW9uLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZG9tU2VsRXh0ZW5kZWQpIHtcbiAgICAgICAgICAgIGlmIChhbmNob3IgPiBoZWFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRtcCA9IGFuY2hvckRPTTtcbiAgICAgICAgICAgICAgICBhbmNob3JET00gPSBoZWFkRE9NO1xuICAgICAgICAgICAgICAgIGhlYWRET00gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQpO1xuICAgICAgICAgICAgZG9tU2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgZG9tU2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29udGVudERPTSAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIGdldCBjb250ZW50TG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgIXRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhIHN1YnRyZWUgb2YgdGhlIGVsZW1lbnQgdHJlZSB0aGF0IGhhcyBiZWVuIHRvdWNoZWRcbiAgICAvLyBieSBhIERPTSBjaGFuZ2UsIHNvIHRoYXQgdGhlIG5leHQgdXBkYXRlIHdpbGwgcmVkcmF3IGl0LlxuICAgIG1hcmtEaXJ0eShmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IGVuZCA/IGZyb20gPD0gZW5kICYmIHRvID49IG9mZnNldCA6IGZyb20gPCBlbmQgJiYgdG8gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbnNpZGUgPSBvZmZzZXQgKyBjaGlsZC5ib3JkZXIsIGVuZEluc2lkZSA9IGVuZCAtIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBzdGFydEluc2lkZSAmJiB0byA8PSBlbmRJbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZyb20gPT0gb2Zmc2V0IHx8IHRvID09IGVuZCA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gc3RhcnRJbnNpZGUgJiYgdG8gPT0gZW5kSW5zaWRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2hpbGQuY29udGVudExvc3QgfHwgY2hpbGQuZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQubWFya0RpcnR5KGZyb20gLSBzdGFydEluc2lkZSwgdG8gLSBzdGFydEluc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gY2hpbGQuZG9tID09IGNoaWxkLmNvbnRlbnRET00gJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFjaGlsZC5jaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gQ09OVEVOVF9ESVJUWSA6IE5PREVfRElSVFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgIH1cbiAgICBtYXJrUGFyZW50c0RpcnR5KCkge1xuICAgICAgICBsZXQgbGV2ZWwgPSAxO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdGhpcy5wYXJlbnQ7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudCwgbGV2ZWwrKykge1xuICAgICAgICAgICAgbGV0IGRpcnR5ID0gbGV2ZWwgPT0gMSA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgICAgIGlmIChub2RlLmRpcnR5IDwgZGlydHkpXG4gICAgICAgICAgICAgICAgbm9kZS5kaXJ0eSA9IGRpcnR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaWdub3JlRm9yQ29vcmRzKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8vIEEgd2lkZ2V0IGRlc2MgcmVwcmVzZW50cyBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBpcyBhIERPTSBub2RlXG4vLyBkcmF3biBiZXR3ZWVuIHRoZSBkb2N1bWVudCBub2Rlcy5cbmNsYXNzIFdpZGdldFZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgd2lkZ2V0LCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IHNlbGYsIGRvbSA9IHdpZGdldC50eXBlLnRvRE9NO1xuICAgICAgICBpZiAodHlwZW9mIGRvbSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBkb20gPSBkb20odmlldywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnBhcmVudC5wb3NCZWZvcmVDaGlsZChzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoIXdpZGdldC50eXBlLnNwZWMucmF3KSB7XG4gICAgICAgICAgICBpZiAoZG9tLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSB3cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3Itd2lkZ2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgbnVsbCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgfVxuICAgIG1hdGNoZXNXaWRnZXQod2lkZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB3aWRnZXQudHlwZS5lcSh0aGlzLndpZGdldC50eXBlKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4geyBpZ25vcmU6IHRydWUgfTsgfVxuICAgIHN0b3BFdmVudChldmVudCkge1xuICAgICAgICBsZXQgc3RvcCA9IHRoaXMud2lkZ2V0LnNwZWMuc3RvcEV2ZW50O1xuICAgICAgICByZXR1cm4gc3RvcCA/IHN0b3AoZXZlbnQpIDogZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCIgfHwgdGhpcy53aWRnZXQuc3BlYy5pZ25vcmVTZWxlY3Rpb247XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMud2lkZ2V0LnR5cGUuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IHNpZGUoKSB7IHJldHVybiB0aGlzLndpZGdldC50eXBlLnNpZGU7IH1cbn1cbmNsYXNzIENvbXBvc2l0aW9uVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBkb20sIHRleHRET00sIHRleHQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgdGhpcy50ZXh0RE9NID0gdGV4dERPTTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChkb20gIT0gdGhpcy50ZXh0RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIChvZmZzZXQgPyB0aGlzLnNpemUgOiAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIG9mZnNldDtcbiAgICB9XG4gICAgZG9tRnJvbVBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy50ZXh0RE9NLCBvZmZzZXQ6IHBvcyB9O1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXQpIHtcbiAgICAgICAgcmV0dXJuIG11dC50eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgbXV0LnRhcmdldC5ub2RlVmFsdWUgPT0gbXV0Lm9sZFZhbHVlO1xuICAgIH1cbn1cbi8vIEEgbWFyayBkZXNjIHJlcHJlc2VudHMgYSBtYXJrLiBNYXkgaGF2ZSBtdWx0aXBsZSBjaGlsZHJlbixcbi8vIGRlcGVuZGluZyBvbiBob3cgdGhlIG1hcmsgaXMgc3BsaXQuIE5vdGUgdGhhdCBtYXJrcyBhcmUgZHJhd24gdXNpbmdcbi8vIGEgZml4ZWQgbmVzdGluZyBvcmRlciwgZm9yIHNpbXBsaWNpdHkgYW5kIHByZWRpY3RhYmlsaXR5LCBzbyBpblxuLy8gc29tZSBjYXNlcyB0aGV5IHdpbGwgYmUgc3BsaXQgbW9yZSBvZnRlbiB0aGFuIHdvdWxkIGFwcGVhclxuLy8gbmVjZXNzYXJ5LlxuY2xhc3MgTWFya1ZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbWFyaywgZG9tLCBjb250ZW50RE9NKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50LCBtYXJrLCBpbmxpbmUsIHZpZXcpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW21hcmsudHlwZS5uYW1lXTtcbiAgICAgICAgbGV0IHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG1hcmssIHZpZXcsIGlubGluZSk7XG4gICAgICAgIGlmICghc3BlYyB8fCAhc3BlYy5kb20pXG4gICAgICAgICAgICBzcGVjID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBtYXJrLnR5cGUuc3BlYy50b0RPTShtYXJrLCBpbmxpbmUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrVmlld0Rlc2MocGFyZW50LCBtYXJrLCBzcGVjLmRvbSwgc3BlYy5jb250ZW50RE9NIHx8IHNwZWMuZG9tKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgJiBOT0RFX0RJUlRZKSB8fCB0aGlzLm1hcmsudHlwZS5zcGVjLnJlcGFyc2VJblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHsgbWFyazogdGhpcy5tYXJrLnR5cGUubmFtZSwgYXR0cnM6IHRoaXMubWFyay5hdHRycywgY29udGVudEVsZW1lbnQ6IHRoaXMuY29udGVudERPTSB9O1xuICAgIH1cbiAgICBtYXRjaGVzTWFyayhtYXJrKSB7IHJldHVybiB0aGlzLmRpcnR5ICE9IE5PREVfRElSVFkgJiYgdGhpcy5tYXJrLmVxKG1hcmspOyB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIC8vIE1vdmUgZGlydHkgaW5mbyB0byBuZWFyZXN0IG5vZGUgdmlld1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlICghcGFyZW50Lm5vZGUpXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuZGlydHkgPCB0aGlzLmRpcnR5KVxuICAgICAgICAgICAgICAgIHBhcmVudC5kaXJ0eSA9IHRoaXMuZGlydHk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBjb3B5ID0gTWFya1ZpZXdEZXNjLmNyZWF0ZSh0aGlzLnBhcmVudCwgdGhpcy5tYXJrLCB0cnVlLCB2aWV3KTtcbiAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5jaGlsZHJlbiwgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKHRvIDwgc2l6ZSlcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCB0bywgc2l6ZSwgdmlldyk7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCAwLCBmcm9tLCB2aWV3KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG5vZGVzW2ldLnBhcmVudCA9IGNvcHk7XG4gICAgICAgIGNvcHkuY2hpbGRyZW4gPSBub2RlcztcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxufVxuLy8gTm9kZSB2aWV3IGRlc2NzIGFyZSB0aGUgbWFpbiwgbW9zdCBjb21tb24gdHlwZSBvZiB2aWV3IGRlc2MsIGFuZFxuLy8gY29ycmVzcG9uZCB0byBhbiBhY3R1YWwgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFVubGlrZSBtYXJrIGRlc2NzLFxuLy8gdGhleSBwb3B1bGF0ZSB0aGVpciBjaGlsZCBhcnJheSB0aGVtc2VsdmVzLlxuY2xhc3MgTm9kZVZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgdmlldywgcG9zKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub3V0ZXJEZWNvID0gb3V0ZXJEZWNvO1xuICAgICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgICAgdGhpcy5ub2RlRE9NID0gbm9kZURPTTtcbiAgICB9XG4gICAgLy8gQnkgZGVmYXVsdCwgYSBub2RlIGlzIHJlbmRlcmVkIHVzaW5nIHRoZSBgdG9ET01gIG1ldGhvZCBmcm9tIHRoZVxuICAgIC8vIG5vZGUgdHlwZSBzcGVjLiBCdXQgY2xpZW50IGNvZGUgY2FuIHVzZSB0aGUgYG5vZGVWaWV3c2Agc3BlYyB0b1xuICAgIC8vIHN1cHBseSBhIGN1c3RvbSBub2RlIHZpZXcsIHdoaWNoIGNhbiBpbmZsdWVuY2UgdmFyaW91cyBhc3BlY3RzIG9mXG4gICAgLy8gdGhlIHdheSB0aGUgbm9kZSB3b3Jrcy5cbiAgICAvL1xuICAgIC8vIChVc2luZyBzdWJjbGFzc2luZyBmb3IgdGhpcyB3YXMgaW50ZW50aW9uYWxseSBkZWNpZGVkIGFnYWluc3QsXG4gICAgLy8gc2luY2UgaXQnZCByZXF1aXJlIGV4cG9zaW5nIGEgd2hvbGUgc2xldyBvZiBmaW5pY2t5XG4gICAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscyB0byB0aGUgdXNlciBjb2RlIHRoYXQgdGhleSBwcm9iYWJseSB3aWxsXG4gICAgLy8gbmV2ZXIgbmVlZC4pXG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW25vZGUudHlwZS5uYW1lXSwgZGVzY09iajtcbiAgICAgICAgbGV0IHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG5vZGUsIHZpZXcsICgpID0+IHtcbiAgICAgICAgICAgIC8vIChUaGlzIGlzIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGN1c3RvbSB2aWV3IHRvIGZpbmQgaXRzXG4gICAgICAgICAgICAvLyBvd24gcG9zaXRpb24pXG4gICAgICAgICAgICBpZiAoIWRlc2NPYmopXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIGlmIChkZXNjT2JqLnBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY09iai5wYXJlbnQucG9zQmVmb3JlQ2hpbGQoZGVzY09iaik7XG4gICAgICAgIH0sIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgbGV0IGRvbSA9IHNwZWMgJiYgc3BlYy5kb20sIGNvbnRlbnRET00gPSBzcGVjICYmIHNwZWMuY29udGVudERPTTtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWRvbSlcbiAgICAgICAgICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLnRleHQpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlICE9IDMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZXh0IG11c3QgYmUgcmVuZGVyZWQgYXMgYSBET00gdGV4dCBub2RlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkb20pIHtcbiAgICAgICAgICAgICh7IGRvbSwgY29udGVudERPTSB9ID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBub2RlLnR5cGUuc3BlYy50b0RPTShub2RlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGVudERPTSAmJiAhbm9kZS5pc1RleHQgJiYgZG9tLm5vZGVOYW1lICE9IFwiQlJcIikgeyAvLyBDaHJvbWUgZ2V0cyBjb25mdXNlZCBieSA8YnIgY29udGVudGVkaXRhYmxlPWZhbHNlPlxuICAgICAgICAgICAgaWYgKCFkb20uaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpKVxuICAgICAgICAgICAgICAgIGRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIGRvbS5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlRE9NID0gZG9tO1xuICAgICAgICBkb20gPSBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgbm9kZSk7XG4gICAgICAgIGlmIChzcGVjKVxuICAgICAgICAgICAgcmV0dXJuIGRlc2NPYmogPSBuZXcgQ3VzdG9tTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSB8fCBudWxsLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZS5pc1RleHQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG5vZGVET00sIHZpZXcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00gfHwgbnVsbCwgbm9kZURPTSwgdmlldywgcG9zICsgMSk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgLy8gRXhwZXJpbWVudGFsIGtsdWRnZSB0byBhbGxvdyBvcHQtaW4gcmUtcGFyc2luZyBvZiBub2Rlc1xuICAgICAgICBpZiAodGhpcy5ub2RlLnR5cGUuc3BlYy5yZXBhcnNlSW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIEZJWE1FIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBjYW4gYWx3YXlzIHJldHVybiB0aGUgY3VycmVudFxuICAgICAgICAvLyBhdHRycyBtZWFucyB0aGF0IGlmIHRoZSB1c2VyIHNvbWVob3cgbWFuYWdlcyB0byBjaGFuZ2UgdGhlXG4gICAgICAgIC8vIGF0dHJzIGluIHRoZSBkb20sIHRoYXQgd29uJ3QgYmUgcGlja2VkIHVwLiBOb3QgZW50aXJlbHkgc3VyZVxuICAgICAgICAvLyB3aGV0aGVyIHRoaXMgaXMgYSBwcm9ibGVtXG4gICAgICAgIGxldCBydWxlID0geyBub2RlOiB0aGlzLm5vZGUudHlwZS5uYW1lLCBhdHRyczogdGhpcy5ub2RlLmF0dHJzIH07XG4gICAgICAgIGlmICh0aGlzLm5vZGUudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIpXG4gICAgICAgICAgICBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSA9IFwiZnVsbFwiO1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50ID0gKCkgPT4gdGhpcy5ub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGVudExvc3QpIHtcbiAgICAgICAgICAgIHJ1bGUuY29udGVudEVsZW1lbnQgPSB0aGlzLmNvbnRlbnRET007XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgbGlrZXMgdG8gcmFuZG9tbHkgcmVjcmVhdGUgcGFyZW50IG5vZGVzIHdoZW5cbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIHRoaW5ncy4gV2hlbiB0aGF0IGhhcHBlbnMsIHRoaXMgdHJpZXMgdG8gZmluZCB0aGVcbiAgICAgICAgICAgIC8vIG5ldyBwYXJlbnQuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9tLmNvbnRhaW5zKGNoaWxkLmRvbS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBydWxlLmNvbnRlbnRFbGVtZW50ID0gY2hpbGQuZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcnVsZS5jb250ZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICBydWxlLmdldENvbnRlbnQgPSAoKSA9PiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG4gICAgbWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIG5vZGUuZXEodGhpcy5ub2RlKSAmJlxuICAgICAgICAgICAgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSAmJiBpbm5lckRlY28uZXEodGhpcy5pbm5lckRlY28pO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMubm9kZS5ub2RlU2l6ZTsgfVxuICAgIGdldCBib3JkZXIoKSB7IHJldHVybiB0aGlzLm5vZGUuaXNMZWFmID8gMCA6IDE7IH1cbiAgICAvLyBTeW5jcyBgdGhpcy5jaGlsZHJlbmAgdG8gbWF0Y2ggYHRoaXMubm9kZS5jb250ZW50YCBhbmQgdGhlIGxvY2FsXG4gICAgLy8gZGVjb3JhdGlvbnMsIHBvc3NpYmx5IGludHJvZHVjaW5nIG5lc3RpbmcgZm9yIG1hcmtzLiBUaGVuLCBpbiBhXG4gICAgLy8gc2VwYXJhdGUgc3RlcCwgc3luY3MgdGhlIERPTSBpbnNpZGUgYHRoaXMuY29udGVudERPTWAgdG9cbiAgICAvLyBgdGhpcy5jaGlsZHJlbmAuXG4gICAgdXBkYXRlQ2hpbGRyZW4odmlldywgcG9zKSB7XG4gICAgICAgIGxldCBpbmxpbmUgPSB0aGlzLm5vZGUuaW5saW5lQ29udGVudCwgb2ZmID0gcG9zO1xuICAgICAgICBsZXQgY29tcG9zaXRpb24gPSB2aWV3LmNvbXBvc2luZyA/IHRoaXMubG9jYWxDb21wb3NpdGlvbkluZm8odmlldywgcG9zKSA6IG51bGw7XG4gICAgICAgIGxldCBsb2NhbENvbXBvc2l0aW9uID0gY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ucG9zID4gLTEgPyBjb21wb3NpdGlvbiA6IG51bGw7XG4gICAgICAgIGxldCBjb21wb3NpdGlvbkluQ2hpbGQgPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5wb3MgPCAwO1xuICAgICAgICBsZXQgdXBkYXRlciA9IG5ldyBWaWV3VHJlZVVwZGF0ZXIodGhpcywgbG9jYWxDb21wb3NpdGlvbiAmJiBsb2NhbENvbXBvc2l0aW9uLm5vZGUsIHZpZXcpO1xuICAgICAgICBpdGVyRGVjbyh0aGlzLm5vZGUsIHRoaXMuaW5uZXJEZWNvLCAod2lkZ2V0LCBpLCBpbnNpZGVOb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAod2lkZ2V0LnNwZWMubWFya3MpXG4gICAgICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyh3aWRnZXQuc3BlYy5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHdpZGdldC50eXBlLnNpZGUgPj0gMCAmJiAhaW5zaWRlTm9kZSlcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKGkgPT0gdGhpcy5ub2RlLmNoaWxkQ291bnQgPyBNYXJrLm5vbmUgOiB0aGlzLm5vZGUuY2hpbGQoaSkubWFya3MsIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV4dCBub2RlIGlzIGEgZGVzYyBtYXRjaGluZyB0aGlzIHdpZGdldCwgcmV1c2UgaXQsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaW5zZXJ0IHRoZSB3aWRnZXQgYXMgYSBuZXcgdmlldyBkZXNjLlxuICAgICAgICAgICAgdXBkYXRlci5wbGFjZVdpZGdldCh3aWRnZXQsIHZpZXcsIG9mZik7XG4gICAgICAgIH0sIChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpID0+IHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgd3JhcHBpbmcgbWFyayBkZXNjcyBtYXRjaCB0aGUgbm9kZSdzIG1hcmtzLlxuICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhjaGlsZC5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIC8vIFRyeSBzZXZlcmFsIHN0cmF0ZWdpZXMgZm9yIGRyYXdpbmcgdGhpcyBub2RlXG4gICAgICAgICAgICBsZXQgY29tcEluZGV4O1xuICAgICAgICAgICAgaWYgKHVwZGF0ZXIuZmluZE5vZGVNYXRjaChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb3NpdGlvbkluQ2hpbGQgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+IG9mZiAmJlxuICAgICAgICAgICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIDwgb2ZmICsgY2hpbGQubm9kZVNpemUgJiZcbiAgICAgICAgICAgICAgICAoY29tcEluZGV4ID0gdXBkYXRlci5maW5kSW5kZXhXaXRoQ2hpbGQoY29tcG9zaXRpb24ubm9kZSkpID4gLTEgJiZcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnVwZGF0ZU5vZGVBdChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGNvbXBJbmRleCwgdmlldykpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHVwZGF0ZXIudXBkYXRlTmV4dE5vZGUoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBpLCBvZmYpKSA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgYXMgYSBuZXcgdmlld1xuICAgICAgICAgICAgICAgIHVwZGF0ZXIuYWRkTm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIG9mZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEcm9wIGFsbCByZW1haW5pbmcgZGVzY3MgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoW10sIGlubGluZSwgdmlldyk7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICB1cGRhdGVyLmFkZFRleHRibG9ja0hhY2tzKCk7XG4gICAgICAgIHVwZGF0ZXIuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgLy8gU3luYyB0aGUgRE9NIGlmIGFueXRoaW5nIGNoYW5nZWRcbiAgICAgICAgaWYgKHVwZGF0ZXIuY2hhbmdlZCB8fCB0aGlzLmRpcnR5ID09IENPTlRFTlRfRElSVFkpIHtcbiAgICAgICAgICAgIC8vIE1heSBoYXZlIHRvIHByb3RlY3QgZm9jdXNlZCBET00gZnJvbSBiZWluZyBjaGFuZ2VkIGlmIGEgY29tcG9zaXRpb24gaXMgYWN0aXZlXG4gICAgICAgICAgICBpZiAobG9jYWxDb21wb3NpdGlvbilcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIGxvY2FsQ29tcG9zaXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3ModGhpcy5jb250ZW50RE9NLCB0aGlzLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGlmIChpb3MpXG4gICAgICAgICAgICAgICAgaW9zSGFja3ModGhpcy5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2FsQ29tcG9zaXRpb25JbmZvKHZpZXcsIHBvcykge1xuICAgICAgICAvLyBPbmx5IGRvIHNvbWV0aGluZyBpZiBib3RoIHRoZSBzZWxlY3Rpb24gYW5kIGEgZm9jdXNlZCB0ZXh0IG5vZGVcbiAgICAgICAgLy8gYXJlIGluc2lkZSBvZiB0aGlzIG5vZGVcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHx8IGZyb20gPCBwb3MgfHwgdG8gPiBwb3MgKyB0aGlzLm5vZGUuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCB0ZXh0Tm9kZSA9IG5lYXJieVRleHROb2RlKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgIGlmICghdGV4dE5vZGUgfHwgIXRoaXMuZG9tLmNvbnRhaW5zKHRleHROb2RlLnBhcmVudE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgdGV4dCBpbiB0aGUgZm9jdXNlZCBub2RlIGluIHRoZSBub2RlLCBzdG9wIGlmIGl0J3Mgbm90XG4gICAgICAgICAgICAvLyB0aGVyZSAobWF5IGhhdmUgYmVlbiBtb2RpZmllZCB0aHJvdWdoIG90aGVyIG1lYW5zLCBpbiB3aGljaFxuICAgICAgICAgICAgLy8gY2FzZSBpdCBzaG91bGQgb3ZlcndyaXR0ZW4pXG4gICAgICAgICAgICBsZXQgdGV4dCA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIGxldCB0ZXh0UG9zID0gZmluZFRleHRJbkZyYWdtZW50KHRoaXMubm9kZS5jb250ZW50LCB0ZXh0LCBmcm9tIC0gcG9zLCB0byAtIHBvcyk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFBvcyA8IDAgPyBudWxsIDogeyBub2RlOiB0ZXh0Tm9kZSwgcG9zOiB0ZXh0UG9zLCB0ZXh0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0ZXh0Tm9kZSwgcG9zOiAtMSwgdGV4dDogXCJcIiB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIHsgbm9kZSwgcG9zLCB0ZXh0IH0pIHtcbiAgICAgICAgLy8gVGhlIG5vZGUgaXMgYWxyZWFkeSBwYXJ0IG9mIGEgbG9jYWwgdmlldyBkZXNjLCBsZWF2ZSBpdCB0aGVyZVxuICAgICAgICBpZiAodGhpcy5nZXREZXNjKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb21wb3NpdGlvbiB2aWV3IGZvciB0aGUgb3JwaGFuZWQgbm9kZXNcbiAgICAgICAgbGV0IHRvcE5vZGUgPSBub2RlO1xuICAgICAgICBmb3IgKDs7IHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmICh0b3BOb2RlLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgd2hpbGUgKHRvcE5vZGUucHJldmlvdXNTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b3BOb2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICB3aGlsZSAodG9wTm9kZS5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICBpZiAodG9wTm9kZS5wbVZpZXdEZXNjKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVzYyA9IG5ldyBDb21wb3NpdGlvblZpZXdEZXNjKHRoaXMsIHRvcE5vZGUsIG5vZGUsIHRleHQpO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMucHVzaChkZXNjKTtcbiAgICAgICAgLy8gUGF0Y2ggdXAgdGhpcy5jaGlsZHJlbiB0byBjb250YWluIHRoZSBjb21wb3NpdGlvbiB2aWV3XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSByZXBsYWNlTm9kZXModGhpcy5jaGlsZHJlbiwgcG9zLCBwb3MgKyB0ZXh0Lmxlbmd0aCwgdmlldywgZGVzYyk7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgZGVzYyBtdXN0IGJlIHVwZGF0ZWQgdG8gbWF0Y2ggdGhlIGdpdmVuIG5vZGUgZGVjb3JhdGlvbixcbiAgICAvLyBkbyBzbyBhbmQgcmV0dXJuIHRydWUuXG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkgfHxcbiAgICAgICAgICAgICFub2RlLnNhbWVNYXJrdXAodGhpcy5ub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB1cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4odmlldywgdGhpcy5wb3NBdFN0YXJ0KTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICB9XG4gICAgdXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbykge1xuICAgICAgICBpZiAoc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG5lZWRzV3JhcCA9IHRoaXMubm9kZURPTS5ub2RlVHlwZSAhPSAxO1xuICAgICAgICBsZXQgb2xkRE9NID0gdGhpcy5kb207XG4gICAgICAgIHRoaXMuZG9tID0gcGF0Y2hPdXRlckRlY28odGhpcy5kb20sIHRoaXMubm9kZURPTSwgY29tcHV0ZU91dGVyRGVjbyh0aGlzLm91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApLCBjb21wdXRlT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tICE9IG9sZERPTSkge1xuICAgICAgICAgICAgb2xkRE9NLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dGVyRGVjbyA9IG91dGVyRGVjbztcbiAgICB9XG4gICAgLy8gTWFyayB0aGlzIG5vZGUgYXMgYmVpbmcgdGhlIHNlbGVjdGVkIG5vZGUuXG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZURPTS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgdGhpcy5kb20uZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHNlbGVjdGVkIG5vZGUgbWFya2luZyBmcm9tIHRoaXMgbm9kZS5cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVET00ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlXCIpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0aGlzLm5vZGUuaXNBdG9tOyB9XG59XG4vLyBDcmVhdGUgYSB2aWV3IGRlc2MgZm9yIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQgbm9kZSwgdG8gYmUgZXhwb3J0ZWRcbi8vIGFuZCB1c2VkIGJ5IHRoZSB2aWV3IGNsYXNzLlxuZnVuY3Rpb24gZG9jVmlld0Rlc2MoZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCB2aWV3KSB7XG4gICAgYXBwbHlPdXRlckRlY28oZG9tLCBvdXRlckRlY28sIGRvYyk7XG4gICAgbGV0IGRvY1ZpZXcgPSBuZXcgTm9kZVZpZXdEZXNjKHVuZGVmaW5lZCwgZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBkb20sIGRvbSwgdmlldywgMCk7XG4gICAgaWYgKGRvY1ZpZXcuY29udGVudERPTSlcbiAgICAgICAgZG9jVmlldy51cGRhdGVDaGlsZHJlbih2aWV3LCAwKTtcbiAgICByZXR1cm4gZG9jVmlldztcbn1cbmNsYXNzIFRleHRWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBub2RlRE9NLCB2aWV3KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbnVsbCwgbm9kZURPTSwgdmlldywgMCk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgbGV0IHNraXAgPSB0aGlzLm5vZGVET00ucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKHNraXAgJiYgc2tpcCAhPSB0aGlzLmRvbSAmJiAhc2tpcC5wbUlzRGVjbylcbiAgICAgICAgICAgIHNraXAgPSBza2lwLnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiB7IHNraXA6IChza2lwIHx8IHRydWUpIH07XG4gICAgfVxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8ICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSAmJiAhdGhpcy5pblBhcmVudCgpKSB8fFxuICAgICAgICAgICAgIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZIHx8IG5vZGUudGV4dCAhPSB0aGlzLm5vZGUudGV4dCkgJiYgbm9kZS50ZXh0ICE9IHRoaXMubm9kZURPTS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5ub2RlVmFsdWUgPSBub2RlLnRleHQ7XG4gICAgICAgICAgICBpZiAodmlldy50cmFja1dyaXRlcyA9PSB0aGlzLm5vZGVET00pXG4gICAgICAgICAgICAgICAgdmlldy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluUGFyZW50KCkge1xuICAgICAgICBsZXQgcGFyZW50RE9NID0gdGhpcy5wYXJlbnQuY29udGVudERPTTtcbiAgICAgICAgZm9yIChsZXQgbiA9IHRoaXMubm9kZURPTTsgbjsgbiA9IG4ucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIGlmIChuID09IHBhcmVudERPTSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLm5vZGVET00sIG9mZnNldDogcG9zIH07XG4gICAgfVxuICAgIGxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcykge1xuICAgICAgICBpZiAoZG9tID09IHRoaXMubm9kZURPTSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyBNYXRoLm1pbihvZmZzZXQsIHRoaXMubm9kZS50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzdXBlci5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gbXV0YXRpb24udHlwZSAhPSBcImNoYXJhY3RlckRhdGFcIiAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlLmN1dChmcm9tLCB0byksIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHRoaXMucGFyZW50LCBub2RlLCB0aGlzLm91dGVyRGVjbywgdGhpcy5pbm5lckRlY28sIGRvbSwgZG9tLCB2aWV3KTtcbiAgICB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIGlmICh0aGlzLmRvbSAhPSB0aGlzLm5vZGVET00gJiYgKGZyb20gPT0gMCB8fCB0byA9PSB0aGlzLm5vZGVET00ubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiBmYWxzZTsgfVxufVxuLy8gQSBkdW1teSBkZXNjIHVzZWQgdG8gdGFnIHRyYWlsaW5nIEJSIG9yIElNRyBub2RlcyBjcmVhdGVkIHRvIHdvcmtcbi8vIGFyb3VuZCBjb250ZW50RWRpdGFibGUgdGVycmlibGVuZXNzLlxuY2xhc3MgVHJhaWxpbmdIYWNrVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4geyBpZ25vcmU6IHRydWUgfTsgfVxuICAgIG1hdGNoZXNIYWNrKG5vZGVOYW1lKSB7IHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB0aGlzLmRvbS5ub2RlTmFtZSA9PSBub2RlTmFtZTsgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBpZ25vcmVGb3JDb29yZHMoKSB7IHJldHVybiB0aGlzLmRvbS5ub2RlTmFtZSA9PSBcIklNR1wiOyB9XG59XG4vLyBBIHNlcGFyYXRlIHN1YmNsYXNzIGlzIHVzZWQgZm9yIGN1c3RvbWl6ZWQgbm9kZSB2aWV3cywgc28gdGhhdCB0aGVcbi8vIGV4dHJhIGNoZWNrcyBvbmx5IGhhdmUgdG8gYmUgbWFkZSBmb3Igbm9kZXMgdGhhdCBhcmUgYWN0dWFsbHlcbi8vIGN1c3RvbWl6ZWQuXG5jbGFzcyBDdXN0b21Ob2RlVmlld0Rlc2MgZXh0ZW5kcyBOb2RlVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgc3BlYywgdmlldywgcG9zKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgdmlldywgcG9zKTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9XG4gICAgLy8gQSBjdXN0b20gYHVwZGF0ZWAgbWV0aG9kIGdldHMgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHVwZGF0ZSBnb2VzXG4gICAgLy8gdGhyb3VnaC4gSWYgaXQgZG9lcywgYW5kIHRoZXJlJ3MgYSBgY29udGVudERPTWAgbm9kZSwgb3VyIGxvZ2ljXG4gICAgLy8gdXBkYXRlcyB0aGUgY2hpbGRyZW4uXG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNwZWMudXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zcGVjLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZW50RE9NICYmICFub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5zcGVjLnNlbGVjdE5vZGUgPyB0aGlzLnNwZWMuc2VsZWN0Tm9kZSgpIDogc3VwZXIuc2VsZWN0Tm9kZSgpO1xuICAgIH1cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYy5kZXNlbGVjdE5vZGUgPyB0aGlzLnNwZWMuZGVzZWxlY3ROb2RlKCkgOiBzdXBlci5kZXNlbGVjdE5vZGUoKTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zcGVjLnNldFNlbGVjdGlvbiA/IHRoaXMuc3BlYy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290KVxuICAgICAgICAgICAgOiBzdXBlci5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290LCBmb3JjZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWMuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuc3BlYy5kZXN0cm95KCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMuc3RvcEV2ZW50ID8gdGhpcy5zcGVjLnN0b3BFdmVudChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbiA/IHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbikgOiBzdXBlci5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgfVxufVxuLy8gU3luYyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUgd2l0aCB0aGUgbm9kZXMgYXNzb2NpYXRlZFxuLy8gd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgdmlldyBkZXNjcywgcmVjdXJzaW5nIGludG8gbWFyayBkZXNjc1xuLy8gYmVjYXVzZSB0aGlzIHNob3VsZCBzeW5jIHRoZSBzdWJ0cmVlIGZvciBhIHdob2xlIG5vZGUgYXQgYSB0aW1lLlxuZnVuY3Rpb24gcmVuZGVyRGVzY3MocGFyZW50RE9NLCBkZXNjcywgdmlldykge1xuICAgIGxldCBkb20gPSBwYXJlbnRET00uZmlyc3RDaGlsZCwgd3JpdHRlbiA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkZXNjc1tpXSwgY2hpbGRET00gPSBkZXNjLmRvbTtcbiAgICAgICAgaWYgKGNoaWxkRE9NLnBhcmVudE5vZGUgPT0gcGFyZW50RE9NKSB7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRET00gIT0gZG9tKSB7XG4gICAgICAgICAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgcGFyZW50RE9NLmluc2VydEJlZm9yZShjaGlsZERPTSwgZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzYyBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGRvbSA/IGRvbS5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnRET00ubGFzdENoaWxkO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3MoZGVzYy5jb250ZW50RE9NLCBkZXNjLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGRvbSA9IHBvcyA/IHBvcy5uZXh0U2libGluZyA6IHBhcmVudERPTS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgfVxuICAgIGlmICh3cml0dGVuICYmIHZpZXcudHJhY2tXcml0ZXMgPT0gcGFyZW50RE9NKVxuICAgICAgICB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDtcbn1cbmNvbnN0IE91dGVyRGVjb0xldmVsID0gZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gICAgaWYgKG5vZGVOYW1lKVxuICAgICAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG59O1xuT3V0ZXJEZWNvTGV2ZWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IG5vRGVjbyA9IFtuZXcgT3V0ZXJEZWNvTGV2ZWxdO1xuZnVuY3Rpb24gY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIG5vZGUsIG5lZWRzV3JhcCkge1xuICAgIGlmIChvdXRlckRlY28ubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBub0RlY287XG4gICAgbGV0IHRvcCA9IG5lZWRzV3JhcCA/IG5vRGVjb1swXSA6IG5ldyBPdXRlckRlY29MZXZlbCwgcmVzdWx0ID0gW3RvcF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRlckRlY28ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGF0dHJzID0gb3V0ZXJEZWNvW2ldLnR5cGUuYXR0cnM7XG4gICAgICAgIGlmICghYXR0cnMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGF0dHJzLm5vZGVOYW1lKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKGF0dHJzLm5vZGVOYW1lKSk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChuZWVkc1dyYXAgJiYgcmVzdWx0Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRvcCA9IG5ldyBPdXRlckRlY29MZXZlbChub2RlLmlzSW5saW5lID8gXCJzcGFuXCIgOiBcImRpdlwiKSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIpXG4gICAgICAgICAgICAgICAgdG9wLmNsYXNzID0gKHRvcC5jbGFzcyA/IHRvcC5jbGFzcyArIFwiIFwiIDogXCJcIikgKyB2YWw7XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICB0b3Auc3R5bGUgPSAodG9wLnN0eWxlID8gdG9wLnN0eWxlICsgXCI7XCIgOiBcIlwiKSArIHZhbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgIHRvcFtuYW1lXSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGF0Y2hPdXRlckRlY28ob3V0ZXJET00sIG5vZGVET00sIHByZXZDb21wdXRlZCwgY3VyQ29tcHV0ZWQpIHtcbiAgICAvLyBTaG9ydGN1dCBmb3IgdHJpdmlhbCBjYXNlXG4gICAgaWYgKHByZXZDb21wdXRlZCA9PSBub0RlY28gJiYgY3VyQ29tcHV0ZWQgPT0gbm9EZWNvKVxuICAgICAgICByZXR1cm4gbm9kZURPTTtcbiAgICBsZXQgY3VyRE9NID0gbm9kZURPTTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ckNvbXB1dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkZWNvID0gY3VyQ29tcHV0ZWRbaV0sIHByZXYgPSBwcmV2Q29tcHV0ZWRbaV07XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50O1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi5ub2RlTmFtZSA9PSBkZWNvLm5vZGVOYW1lICYmIGN1ckRPTSAhPSBvdXRlckRPTSAmJlxuICAgICAgICAgICAgICAgIChwYXJlbnQgPSBjdXJET00ucGFyZW50Tm9kZSkgJiYgcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gZGVjby5ub2RlTmFtZSkge1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGVjby5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50LnBtSXNEZWNvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3VyRE9NKTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9EZWNvWzBdO1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXRjaEF0dHJpYnV0ZXMoY3VyRE9NLCBwcmV2IHx8IG5vRGVjb1swXSwgZGVjbyk7XG4gICAgfVxuICAgIHJldHVybiBjdXJET007XG59XG5mdW5jdGlvbiBwYXRjaEF0dHJpYnV0ZXMoZG9tLCBwcmV2LCBjdXIpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiAhKG5hbWUgaW4gY3VyKSlcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBjdXIpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiBjdXJbbmFtZV0gIT0gcHJldltuYW1lXSlcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgY3VyW25hbWVdKTtcbiAgICBpZiAocHJldi5jbGFzcyAhPSBjdXIuY2xhc3MpIHtcbiAgICAgICAgbGV0IHByZXZMaXN0ID0gcHJldi5jbGFzcyA/IHByZXYuY2xhc3Muc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBsZXQgY3VyTGlzdCA9IGN1ci5jbGFzcyA/IGN1ci5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY3VyTGlzdC5pbmRleE9mKHByZXZMaXN0W2ldKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NMaXN0LnJlbW92ZShwcmV2TGlzdFtpXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyTGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChwcmV2TGlzdC5pbmRleE9mKGN1ckxpc3RbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKGN1ckxpc3RbaV0pO1xuICAgICAgICBpZiAoZG9tLmNsYXNzTGlzdC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICB9XG4gICAgaWYgKHByZXYuc3R5bGUgIT0gY3VyLnN0eWxlKSB7XG4gICAgICAgIGlmIChwcmV2LnN0eWxlKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IC9cXHMqKFtcXHdcXC1cXHhhMS1cXHVmZmZmXSspXFxzKjooPzpcIig/OlxcXFwufFteXCJdKSpcInwnKD86XFxcXC58W14nXSkqJ3xcXCguKj9cXCl8W147XSkqL2csIG07XG4gICAgICAgICAgICB3aGlsZSAobSA9IHByb3AuZXhlYyhwcmV2LnN0eWxlKSlcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUucmVtb3ZlUHJvcGVydHkobVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5zdHlsZSlcbiAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ICs9IGN1ci5zdHlsZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseU91dGVyRGVjbyhkb20sIGRlY28sIG5vZGUpIHtcbiAgICByZXR1cm4gcGF0Y2hPdXRlckRlY28oZG9tLCBkb20sIG5vRGVjbywgY29tcHV0ZU91dGVyRGVjbyhkZWNvLCBub2RlLCBkb20ubm9kZVR5cGUgIT0gMSkpO1xufVxuZnVuY3Rpb24gc2FtZU91dGVyRGVjbyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0udHlwZS5lcShiW2ldLnR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gUmVtb3ZlIGEgRE9NIG5vZGUgYW5kIHJldHVybiBpdHMgbmV4dCBzaWJsaW5nLlxuZnVuY3Rpb24gcm0oZG9tKSB7XG4gICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbi8vIEhlbHBlciBjbGFzcyBmb3IgaW5jcmVtZW50YWxseSB1cGRhdGluZyBhIHRyZWUgb2YgbWFyayBkZXNjcyBhbmRcbi8vIHRoZSB3aWRnZXQgYW5kIG5vZGUgZGVzY3MgaW5zaWRlIG9mIHRoZW0uXG5jbGFzcyBWaWV3VHJlZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRvcCwgbG9jaywgdmlldykge1xuICAgICAgICB0aGlzLmxvY2sgPSBsb2NrO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAvLyBJbmRleCBpbnRvIGB0aGlzLnRvcGAncyBjaGlsZCBhcnJheSwgcmVwcmVzZW50cyB0aGUgY3VycmVudFxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAvLyBXaGVuIGVudGVyaW5nIGEgbWFyaywgdGhlIGN1cnJlbnQgdG9wIGFuZCBpbmRleCBhcmUgcHVzaGVkXG4gICAgICAgIC8vIG9udG8gdGhpcy5cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciBhbnl0aGluZyB3YXMgY2hhbmdlZFxuICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMucHJlTWF0Y2ggPSBwcmVNYXRjaCh0b3Aubm9kZS5jb250ZW50LCB0b3ApO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFuZCByZW1vdmUgdGhlIGNoaWxkcmVuIGJldHdlZW4gdGhlIGdpdmVuIGluZGljZXMgaW5cbiAgICAvLyBgdGhpcy50b3BgLlxuICAgIGRlc3Ryb3lCZXR3ZWVuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbltpXS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFsbCByZW1haW5pbmcgY2hpbGRyZW4gaW4gYHRoaXMudG9wYC5cbiAgICBkZXN0cm95UmVzdCgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTeW5jIHRoZSBjdXJyZW50IHN0YWNrIG9mIG1hcmsgZGVzY3Mgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2ZcbiAgICAvLyBtYXJrcywgcmV1c2luZyBleGlzdGluZyBtYXJrIGRlc2NzIHdoZW4gcG9zc2libGUuXG4gICAgc3luY1RvTWFya3MobWFya3MsIGlubGluZSwgdmlldykge1xuICAgICAgICBsZXQga2VlcCA9IDAsIGRlcHRoID0gdGhpcy5zdGFjay5sZW5ndGggPj4gMTtcbiAgICAgICAgbGV0IG1heEtlZXAgPSBNYXRoLm1pbihkZXB0aCwgbWFya3MubGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBtYXhLZWVwICYmXG4gICAgICAgICAgICAoa2VlcCA9PSBkZXB0aCAtIDEgPyB0aGlzLnRvcCA6IHRoaXMuc3RhY2tbKGtlZXAgKyAxKSA8PCAxXSlcbiAgICAgICAgICAgICAgICAubWF0Y2hlc01hcmsobWFya3Nba2VlcF0pICYmIG1hcmtzW2tlZXBdLnR5cGUuc3BlYy5zcGFubmluZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICBrZWVwKys7XG4gICAgICAgIHdoaWxlIChrZWVwIDwgZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgICAgIHRoaXMudG9wLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChkZXB0aCA8IG1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMudG9wLCB0aGlzLmluZGV4ICsgMSk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgTWF0aC5taW4odGhpcy5pbmRleCArIDMsIHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubWF0Y2hlc01hcmsobWFya3NbZGVwdGhdKSAmJiAhdGhpcy5pc0xvY2tlZChuZXh0LmRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFya0Rlc2MgPSBNYXJrVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBtYXJrc1tkZXB0aF0sIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgsIDAsIG1hcmtEZXNjKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcCA9IG1hcmtEZXNjO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSBub2RlIGRlc2MgbWF0Y2hpbmcgdGhlIGdpdmVuIGRhdGEuIFNraXAgb3ZlciBpdCBhbmRcbiAgICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHN1Y2Nlc3NmdWwuXG4gICAgZmluZE5vZGVNYXRjaChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gLTEsIHRhcmdldERlc2M7XG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLnByZU1hdGNoLmluZGV4ICYmXG4gICAgICAgICAgICAodGFyZ2V0RGVzYyA9IHRoaXMucHJlTWF0Y2gubWF0Y2hlc1tpbmRleCAtIHRoaXMucHJlTWF0Y2guaW5kZXhdKS5wYXJlbnQgPT0gdGhpcy50b3AgJiZcbiAgICAgICAgICAgIHRhcmdldERlc2MubWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRoaXMudG9wLmNoaWxkcmVuLmluZGV4T2YodGFyZ2V0RGVzYywgdGhpcy5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleCwgZSA9IE1hdGgubWluKHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCwgaSArIDUpOyBpIDwgZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSAmJiAhdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHVwZGF0ZU5vZGVBdChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgsIHZpZXcpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGQuZGlydHkgPT0gTk9ERV9ESVJUWSAmJiBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSlcbiAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgaWYgKCFjaGlsZC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGluZGV4KTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZmluZEluZGV4V2l0aENoaWxkKGRvbU5vZGUpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgIGxldCBkZXNjID0gZG9tTm9kZS5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkZXNjKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b3AuY2hpbGRyZW5baV0gPT0gZGVzYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbU5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIHVwZGF0ZSB0aGUgbmV4dCBub2RlLCBpZiBhbnksIHRvIHRoZSBnaXZlbiBkYXRhLiBDaGVja3NcbiAgICAvLyBwcmUtbWF0Y2hlcyB0byBhdm9pZCBvdmVyd3JpdGluZyBub2RlcyB0aGF0IGNvdWxkIHN0aWxsIGJlIHVzZWQuXG4gICAgdXBkYXRlTmV4dE5vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGluZGV4LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXg7IGkgPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgTm9kZVZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZU1hdGNoID0gdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmdldChuZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAocHJlTWF0Y2ggIT0gbnVsbCAmJiBwcmVNYXRjaCAhPSBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0RE9NID0gbmV4dC5kb20sIHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2FuJ3QgdXBkYXRlIGlmIG5leHRET00gaXMgb3IgY29udGFpbnMgdGhpcy5sb2NrLCBleGNlcHQgaWZcbiAgICAgICAgICAgICAgICAvLyBpdCdzIGEgdGV4dCBub2RlIHdob3NlIGNvbnRlbnQgYWxyZWFkeSBtYXRjaGVzIHRoZSBuZXcgdGV4dFxuICAgICAgICAgICAgICAgIC8vIGFuZCB3aG9zZSBkZWNvcmF0aW9ucyBtYXRjaCB0aGUgbmV3IG9uZXMuXG4gICAgICAgICAgICAgICAgbGV0IGxvY2tlZCA9IHRoaXMuaXNMb2NrZWQobmV4dERPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGUgJiYgbmV4dC5ub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGVET00ubm9kZVZhbHVlID09IG5vZGUudGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCBuZXh0Lm91dGVyRGVjbykpO1xuICAgICAgICAgICAgICAgIGlmICghbG9ja2VkICYmIG5leHQudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5kb20gIT0gbmV4dERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFsb2NrZWQgJiYgKHVwZGF0ZWQgPSB0aGlzLnJlY3JlYXRlV3JhcHBlcihuZXh0LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQudXBkYXRlQ2hpbGRyZW4odmlldywgcG9zICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gV2hlbiBhIG5vZGUgd2l0aCBjb250ZW50IGlzIHJlcGxhY2VkIGJ5IGEgZGlmZmVyZW50IG5vZGUgd2l0aFxuICAgIC8vIGlkZW50aWNhbCBjb250ZW50LCBtb3ZlIG92ZXIgaXRzIGNoaWxkcmVuLlxuICAgIHJlY3JlYXRlV3JhcHBlcihuZXh0LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSB7XG4gICAgICAgIGlmIChuZXh0LmRpcnR5IHx8IG5vZGUuaXNBdG9tIHx8ICFuZXh0LmNoaWxkcmVuLmxlbmd0aCB8fFxuICAgICAgICAgICAgIW5leHQubm9kZS5jb250ZW50LmVxKG5vZGUuY29udGVudCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHdyYXBwZXIgPSBOb2RlVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKTtcbiAgICAgICAgaWYgKHdyYXBwZXIuY29udGVudERPTSkge1xuICAgICAgICAgICAgd3JhcHBlci5jaGlsZHJlbiA9IG5leHQuY2hpbGRyZW47XG4gICAgICAgICAgICBuZXh0LmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjaCBvZiB3cmFwcGVyLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoLnBhcmVudCA9IHdyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICAvLyBJbnNlcnQgdGhlIG5vZGUgYXMgYSBuZXdseSBjcmVhdGVkIG5vZGUgZGVzYy5cbiAgICBhZGROb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGRlc2MgPSBOb2RlVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKTtcbiAgICAgICAgaWYgKGRlc2MuY29udGVudERPTSlcbiAgICAgICAgICAgIGRlc2MudXBkYXRlQ2hpbGRyZW4odmlldywgcG9zICsgMSk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4KyssIDAsIGRlc2MpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwbGFjZVdpZGdldCh3aWRnZXQsIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuaW5kZXggPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGggPyB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XSA6IG51bGw7XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQubWF0Y2hlc1dpZGdldCh3aWRnZXQpICYmXG4gICAgICAgICAgICAod2lkZ2V0ID09IG5leHQud2lkZ2V0IHx8ICFuZXh0LndpZGdldC50eXBlLnRvRE9NLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IG5ldyBXaWRnZXRWaWV3RGVzYyh0aGlzLnRvcCwgd2lkZ2V0LCB2aWV3LCBwb3MpO1xuICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgZGVzYyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBhIHRleHRibG9jayBsb29rcyBhbmQgYmVoYXZlcyBjb3JyZWN0bHkgaW5cbiAgICAvLyBjb250ZW50RWRpdGFibGUuXG4gICAgYWRkVGV4dGJsb2NrSGFja3MoKSB7XG4gICAgICAgIGxldCBsYXN0Q2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4IC0gMV0sIHBhcmVudCA9IHRoaXMudG9wO1xuICAgICAgICB3aGlsZSAobGFzdENoaWxkIGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBsYXN0Q2hpbGQ7XG4gICAgICAgICAgICBsYXN0Q2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5bcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGFzdENoaWxkIHx8IC8vIEVtcHR5IHRleHRibG9ja1xuICAgICAgICAgICAgIShsYXN0Q2hpbGQgaW5zdGFuY2VvZiBUZXh0Vmlld0Rlc2MpIHx8XG4gICAgICAgICAgICAvXFxuJC8udGVzdChsYXN0Q2hpbGQubm9kZS50ZXh0KSB8fFxuICAgICAgICAgICAgKHRoaXMudmlldy5yZXF1aXJlc0dlY2tvSGFja05vZGUgJiYgL1xccyQvLnRlc3QobGFzdENoaWxkLm5vZGUudGV4dCkpKSB7XG4gICAgICAgICAgICAvLyBBdm9pZCBidWdzIGluIFNhZmFyaSdzIGN1cnNvciBkcmF3aW5nICgjMTE2NSkgYW5kIENocm9tZSdzIG1vdXNlIHNlbGVjdGlvbiAoIzExNTIpXG4gICAgICAgICAgICBpZiAoKHNhZmFyaSB8fCBjaHJvbWUpICYmIGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQuZG9tLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRIYWNrTm9kZShcIklNR1wiLCBwYXJlbnQpO1xuICAgICAgICAgICAgdGhpcy5hZGRIYWNrTm9kZShcIkJSXCIsIHRoaXMudG9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRIYWNrTm9kZShub2RlTmFtZSwgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AgJiYgdGhpcy5pbmRleCA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGggJiYgcGFyZW50LmNoaWxkcmVuW3RoaXMuaW5kZXhdLm1hdGNoZXNIYWNrKG5vZGVOYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09IFwiSU1HXCIpIHtcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICAgICAgICAgICAgICBkb20uYWx0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3ItdHJhaWxpbmdCcmVha1wiO1xuICAgICAgICAgICAgbGV0IGhhY2sgPSBuZXcgVHJhaWxpbmdIYWNrVmlld0Rlc2ModGhpcy50b3AsIFtdLCBkb20sIG51bGwpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCAhPSB0aGlzLnRvcClcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChoYWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgaGFjayk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzTG9ja2VkKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jayAmJiAobm9kZSA9PSB0aGlzLmxvY2sgfHwgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUuY29udGFpbnModGhpcy5sb2NrLnBhcmVudE5vZGUpKTtcbiAgICB9XG59XG4vLyBJdGVyYXRlIGZyb20gdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnQgYW5kIGFycmF5IG9mIGRlc2NzIHRvIGZpbmRcbi8vIGRpcmVjdGx5IG1hdGNoaW5nIG9uZXMsIGluIG9yZGVyIHRvIGF2b2lkIG92ZXJlYWdlcmx5IHJldXNpbmcgdGhvc2Vcbi8vIGZvciBvdGhlciBub2Rlcy4gUmV0dXJucyB0aGUgZnJhZ21lbnQgaW5kZXggb2YgdGhlIGZpcnN0IG5vZGUgdGhhdFxuLy8gaXMgcGFydCBvZiB0aGUgc2VxdWVuY2Ugb2YgbWF0Y2hlZCBub2RlcyBhdCB0aGUgZW5kIG9mIHRoZVxuLy8gZnJhZ21lbnQuXG5mdW5jdGlvbiBwcmVNYXRjaChmcmFnLCBwYXJlbnREZXNjKSB7XG4gICAgbGV0IGN1ckRlc2MgPSBwYXJlbnREZXNjLCBkZXNjSSA9IGN1ckRlc2MuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGxldCBmSSA9IGZyYWcuY2hpbGRDb3VudCwgbWF0Y2hlZCA9IG5ldyBNYXAsIG1hdGNoZXMgPSBbXTtcbiAgICBvdXRlcjogd2hpbGUgKGZJID4gMCkge1xuICAgICAgICBsZXQgZGVzYztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKGRlc2NJKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjdXJEZXNjLmNoaWxkcmVuW2Rlc2NJIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyRGVzYyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NJID0gbmV4dC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXNjID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZGVzY0ktLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyRGVzYyA9PSBwYXJlbnREZXNjKSB7XG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgIGRlc2NJID0gY3VyRGVzYy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjdXJEZXNjKTtcbiAgICAgICAgICAgICAgICBjdXJEZXNjID0gY3VyRGVzYy5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGUgPSBkZXNjLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAobm9kZSAhPSBmcmFnLmNoaWxkKGZJIC0gMSkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLS1mSTtcbiAgICAgICAgbWF0Y2hlZC5zZXQoZGVzYywgZkkpO1xuICAgICAgICBtYXRjaGVzLnB1c2goZGVzYyk7XG4gICAgfVxuICAgIHJldHVybiB7IGluZGV4OiBmSSwgbWF0Y2hlZCwgbWF0Y2hlczogbWF0Y2hlcy5yZXZlcnNlKCkgfTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVTaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYS50eXBlLnNpZGUgLSBiLnR5cGUuc2lkZTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gYWJzdHJhY3RzIGl0ZXJhdGluZyBvdmVyIHRoZSBub2RlcyBhbmQgZGVjb3JhdGlvbnMgaW5cbi8vIGEgZnJhZ21lbnQuIENhbGxzIGBvbk5vZGVgIGZvciBlYWNoIG5vZGUsIHdpdGggaXRzIGxvY2FsIGFuZCBjaGlsZFxuLy8gZGVjb3JhdGlvbnMuIFNwbGl0cyB0ZXh0IG5vZGVzIHdoZW4gdGhlcmUgaXMgYSBkZWNvcmF0aW9uIHN0YXJ0aW5nXG4vLyBvciBlbmRpbmcgaW5zaWRlIG9mIHRoZW0uIENhbGxzIGBvbldpZGdldGAgZm9yIGVhY2ggd2lkZ2V0LlxuZnVuY3Rpb24gaXRlckRlY28ocGFyZW50LCBkZWNvLCBvbldpZGdldCwgb25Ob2RlKSB7XG4gICAgbGV0IGxvY2FscyA9IGRlY28ubG9jYWxzKHBhcmVudCksIG9mZnNldCA9IDA7XG4gICAgLy8gU2ltcGxlLCBjaGVhcCB2YXJpYW50IGZvciB3aGVuIHRoZXJlIGFyZSBubyBsb2NhbCBkZWNvcmF0aW9uc1xuICAgIGlmIChsb2NhbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaSk7XG4gICAgICAgICAgICBvbk5vZGUoY2hpbGQsIGxvY2FscywgZGVjby5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKSwgaSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZGVjb0luZGV4ID0gMCwgYWN0aXZlID0gW10sIHJlc3ROb2RlID0gbnVsbDtcbiAgICBmb3IgKGxldCBwYXJlbnRJbmRleCA9IDA7Oykge1xuICAgICAgICBsZXQgd2lkZ2V0LCB3aWRnZXRzO1xuICAgICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA9PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbG9jYWxzW2RlY29JbmRleCsrXTtcbiAgICAgICAgICAgIGlmIChuZXh0LndpZGdldCkge1xuICAgICAgICAgICAgICAgIGlmICghd2lkZ2V0KVxuICAgICAgICAgICAgICAgICAgICB3aWRnZXQgPSBuZXh0O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKHdpZGdldHMgfHwgKHdpZGdldHMgPSBbd2lkZ2V0XSkpLnB1c2gobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZGdldCkge1xuICAgICAgICAgICAgaWYgKHdpZGdldHMpIHtcbiAgICAgICAgICAgICAgICB3aWRnZXRzLnNvcnQoY29tcGFyZVNpZGUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkZ2V0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgb25XaWRnZXQod2lkZ2V0c1tpXSwgcGFyZW50SW5kZXgsICEhcmVzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25XaWRnZXQod2lkZ2V0LCBwYXJlbnRJbmRleCwgISFyZXN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoaWxkLCBpbmRleDtcbiAgICAgICAgaWYgKHJlc3ROb2RlKSB7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY2hpbGQgPSByZXN0Tm9kZTtcbiAgICAgICAgICAgIHJlc3ROb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnRJbmRleCA8IHBhcmVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgICAgICAgY2hpbGQgPSBwYXJlbnQuY2hpbGQocGFyZW50SW5kZXgrKyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChhY3RpdmVbaV0udG8gPD0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgIGFjdGl2ZS5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0uZnJvbSA8PSBvZmZzZXQgJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPiBvZmZzZXQpXG4gICAgICAgICAgICBhY3RpdmUucHVzaChsb2NhbHNbZGVjb0luZGV4KytdKTtcbiAgICAgICAgbGV0IGVuZCA9IG9mZnNldCArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgICAgICBsZXQgY3V0QXQgPSBlbmQ7XG4gICAgICAgICAgICBpZiAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS5mcm9tIDwgY3V0QXQpXG4gICAgICAgICAgICAgICAgY3V0QXQgPSBsb2NhbHNbZGVjb0luZGV4XS5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVtpXS50byA8IGN1dEF0KVxuICAgICAgICAgICAgICAgICAgICBjdXRBdCA9IGFjdGl2ZVtpXS50bztcbiAgICAgICAgICAgIGlmIChjdXRBdCA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHJlc3ROb2RlID0gY2hpbGQuY3V0KGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dCgwLCBjdXRBdCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgZW5kID0gY3V0QXQ7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvIDwgZW5kKVxuICAgICAgICAgICAgICAgIGRlY29JbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRlckRlY28gPSBjaGlsZC5pc0lubGluZSAmJiAhY2hpbGQuaXNMZWFmID8gYWN0aXZlLmZpbHRlcihkID0+ICFkLmlubGluZSkgOiBhY3RpdmUuc2xpY2UoKTtcbiAgICAgICAgb25Ob2RlKGNoaWxkLCBvdXRlckRlY28sIGRlY28uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCksIGluZGV4KTtcbiAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbn1cbi8vIExpc3QgbWFya2VycyBpbiBNb2JpbGUgU2FmYXJpIHdpbGwgbXlzdGVyaW91c2x5IGRpc2FwcGVhclxuLy8gc29tZXRpbWVzLiBUaGlzIHdvcmtzIGFyb3VuZCB0aGF0LlxuZnVuY3Rpb24gaW9zSGFja3MoZG9tKSB7XG4gICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIlVMXCIgfHwgZG9tLm5vZGVOYW1lID09IFwiT0xcIikge1xuICAgICAgICBsZXQgb2xkQ1NTID0gZG9tLnN0eWxlLmNzc1RleHQ7XG4gICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTICsgXCI7IGxpc3Qtc3R5bGU6IHNxdWFyZSAhaW1wb3J0YW50XCI7XG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSkubGlzdFN0eWxlO1xuICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcbiAgICB9XG59XG5mdW5jdGlvbiBuZWFyYnlUZXh0Tm9kZShub2RlLCBvZmZzZXQpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IG9mZnNldCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBvZmZzZXQgPSBub2RlU2l6ZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gRmluZCBhIHBpZWNlIG9mIHRleHQgaW4gYW4gaW5saW5lIGZyYWdtZW50LCBvdmVybGFwcGluZyBmcm9tLXRvXG5mdW5jdGlvbiBmaW5kVGV4dEluRnJhZ21lbnQoZnJhZywgdGV4dCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IGZyYWcuY2hpbGRDb3VudCAmJiBwb3MgPD0gdG87KSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZyYWcuY2hpbGQoaSsrKSwgY2hpbGRTdGFydCA9IHBvcztcbiAgICAgICAgcG9zICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBpZiAoIWNoaWxkLmlzVGV4dClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgc3RyID0gY2hpbGQudGV4dDtcbiAgICAgICAgd2hpbGUgKGkgPCBmcmFnLmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZnJhZy5jaGlsZChpKyspO1xuICAgICAgICAgICAgcG9zICs9IG5leHQubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoIW5leHQuaXNUZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RyICs9IG5leHQudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IGZyb20pIHtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdG8gJiYgc3RyLnNsaWNlKHRvIC0gdGV4dC5sZW5ndGggLSBjaGlsZFN0YXJ0LCB0byAtIGNoaWxkU3RhcnQpID09IHRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvIC0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBjaGlsZFN0YXJ0IDwgdG8gPyBzdHIubGFzdEluZGV4T2YodGV4dCwgdG8gLSBjaGlsZFN0YXJ0IC0gMSkgOiAtMTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA+PSAwICYmIGZvdW5kICsgdGV4dC5sZW5ndGggKyBjaGlsZFN0YXJ0ID49IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkU3RhcnQgKyBmb3VuZDtcbiAgICAgICAgICAgIGlmIChmcm9tID09IHRvICYmIHN0ci5sZW5ndGggPj0gKHRvICsgdGV4dC5sZW5ndGgpIC0gY2hpbGRTdGFydCAmJlxuICAgICAgICAgICAgICAgIHN0ci5zbGljZSh0byAtIGNoaWxkU3RhcnQsIHRvIC0gY2hpbGRTdGFydCArIHRleHQubGVuZ3RoKSA9PSB0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0bztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vLyBSZXBsYWNlIHJhbmdlIGZyb20tdG8gaW4gYW4gYXJyYXkgb2YgdmlldyBkZXNjcyB3aXRoIHJlcGxhY2VtZW50XG4vLyAobWF5IGJlIG51bGwgdG8ganVzdCBkZWxldGUpLiBUaGlzIGdvZXMgdmVyeSBtdWNoIGFnYWluc3QgdGhlIGdyYWluXG4vLyBvZiB0aGUgcmVzdCBvZiB0aGlzIGNvZGUsIHdoaWNoIHRlbmRzIHRvIGNyZWF0ZSBub2RlcyB3aXRoIHRoZVxuLy8gcmlnaHQgc2hhcGUgaW4gb25lIGdvLCByYXRoZXIgdGhhbiBtZXNzaW5nIHdpdGggdGhlbSBhZnRlclxuLy8gY3JlYXRpb24sIGJ1dCBpcyBuZWNlc3NhcnkgaW4gdGhlIGNvbXBvc2l0aW9uIGhhY2suXG5mdW5jdGlvbiByZXBsYWNlTm9kZXMobm9kZXMsIGZyb20sIHRvLCB2aWV3LCByZXBsYWNlbWVudCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IG5vZGVzW2ldLCBzdGFydCA9IG9mZiwgZW5kID0gb2ZmICs9IGNoaWxkLnNpemU7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZC5zbGljZSgwLCBmcm9tIC0gc3RhcnQsIHZpZXcpKTtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZC5zbGljZSh0byAtIHN0YXJ0LCBjaGlsZC5zaXplLCB2aWV3KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbURPTSh2aWV3LCBvcmlnaW4gPSBudWxsKSB7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSwgZG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgaWYgKCFkb21TZWwuZm9jdXNOb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbmVhcmVzdERlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tU2VsLmZvY3VzTm9kZSksIGluV2lkZ2V0ID0gbmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2Muc2l6ZSA9PSAwO1xuICAgIGxldCBoZWFkID0gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCAxKTtcbiAgICBpZiAoaGVhZCA8IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCAkaGVhZCA9IGRvYy5yZXNvbHZlKGhlYWQpLCAkYW5jaG9yLCBzZWxlY3Rpb247XG4gICAgaWYgKHNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpKSB7XG4gICAgICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICAgICAgd2hpbGUgKG5lYXJlc3REZXNjICYmICFuZWFyZXN0RGVzYy5ub2RlKVxuICAgICAgICAgICAgbmVhcmVzdERlc2MgPSBuZWFyZXN0RGVzYy5wYXJlbnQ7XG4gICAgICAgIGxldCBuZWFyZXN0RGVzY05vZGUgPSBuZWFyZXN0RGVzYy5ub2RlO1xuICAgICAgICBpZiAobmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2NOb2RlLmlzQXRvbSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShuZWFyZXN0RGVzY05vZGUpICYmIG5lYXJlc3REZXNjLnBhcmVudFxuICAgICAgICAgICAgJiYgIShuZWFyZXN0RGVzY05vZGUuaXNJbmxpbmUgJiYgaXNPbkVkZ2UoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCBuZWFyZXN0RGVzYy5kb20pKSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IG5lYXJlc3REZXNjLnBvc0JlZm9yZTtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IG5ldyBOb2RlU2VsZWN0aW9uKGhlYWQgPT0gcG9zID8gJGhlYWQgOiBkb2MucmVzb2x2ZShwb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGFuY2hvciA9IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0LCAxKTtcbiAgICAgICAgaWYgKGFuY2hvciA8IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgJGFuY2hvciA9IGRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgfVxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBiaWFzID0gb3JpZ2luID09IFwicG9pbnRlclwiIHx8ICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5oZWFkIDwgJGhlYWQucG9zICYmICFpbldpZGdldCkgPyAxIDogLTE7XG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbkJldHdlZW4odmlldywgJGFuY2hvciwgJGhlYWQsIGJpYXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSB7XG4gICAgcmV0dXJuIHZpZXcuZWRpdGFibGUgPyB2aWV3Lmhhc0ZvY3VzKCkgOlxuICAgICAgICBoYXNTZWxlY3Rpb24odmlldykgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNvbnRhaW5zKHZpZXcuZG9tKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblRvRE9NKHZpZXcsIGZvcmNlID0gZmFsc2UpIHtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgc3luY05vZGVTZWxlY3Rpb24odmlldywgc2VsKTtcbiAgICBpZiAoIWVkaXRvck93bnNTZWxlY3Rpb24odmlldykpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBUaGUgZGVsYXllZCBkcmFnIHNlbGVjdGlvbiBjYXVzZXMgaXNzdWVzIHdpdGggQ2VsbCBTZWxlY3Rpb25zXG4gICAgLy8gaW4gU2FmYXJpLiBBbmQgdGhlIGRyYWcgc2VsZWN0aW9uIGRlbGF5IGlzIHRvIHdvcmthcm9uZCBpc3N1ZXNcbiAgICAvLyB3aGljaCBvbmx5IHByZXNlbnQgaW4gQ2hyb21lLlxuICAgIGlmICghZm9yY2UgJiYgdmlldy5pbnB1dC5tb3VzZURvd24gJiYgdmlldy5pbnB1dC5tb3VzZURvd24uYWxsb3dEZWZhdWx0ICYmIGNocm9tZSkge1xuICAgICAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpLCBjdXJTZWwgPSB2aWV3LmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgIGlmIChkb21TZWwuYW5jaG9yTm9kZSAmJiBjdXJTZWwuYW5jaG9yTm9kZSAmJlxuICAgICAgICAgICAgaXNFcXVpdmFsZW50UG9zaXRpb24oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQsIGN1clNlbC5hbmNob3JOb2RlLCBjdXJTZWwuYW5jaG9yT2Zmc2V0KSkge1xuICAgICAgICAgICAgdmlldy5pbnB1dC5tb3VzZURvd24uZGVsYXllZFNlbGVjdGlvblN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LmRvbU9ic2VydmVyLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKSB7XG4gICAgICAgIHNlbGVjdEN1cnNvcldyYXBwZXIodmlldyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgeyBhbmNob3IsIGhlYWQgfSA9IHNlbCwgcmVzZXRFZGl0YWJsZUZyb20sIHJlc2V0RWRpdGFibGVUbztcbiAgICAgICAgaWYgKGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlICYmICEoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmICghc2VsLiRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGVGcm9tID0gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgc2VsLmZyb20pO1xuICAgICAgICAgICAgaWYgKCFzZWwuZW1wdHkgJiYgIXNlbC4kZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlVG8gPSB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBzZWwudG8pO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcuZG9jVmlldy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCB2aWV3LnJvb3QsIGZvcmNlKTtcbiAgICAgICAgaWYgKGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlKSB7XG4gICAgICAgICAgICBpZiAocmVzZXRFZGl0YWJsZUZyb20pXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZShyZXNldEVkaXRhYmxlRnJvbSk7XG4gICAgICAgICAgICBpZiAocmVzZXRFZGl0YWJsZVRvKVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGUocmVzZXRFZGl0YWJsZVRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsLnZpc2libGUpIHtcbiAgICAgICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICAgICAgICBpZiAoXCJvbnNlbGVjdGlvbmNoYW5nZVwiIGluIGRvY3VtZW50KVxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzT25TZWxlY3Rpb25DaGFuZ2Uodmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmNvbm5lY3RTZWxlY3Rpb24oKTtcbn1cbi8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBXZWJraXQgbm90IGFsbG93aW5nIGEgc2VsZWN0aW9uIHRvIHN0YXJ0L2VuZFxuLy8gYmV0d2VlbiBub24tZWRpdGFibGUgYmxvY2sgbm9kZXMuIFdlIGJyaWVmbHkgbWFrZSBzb21ldGhpbmdcbi8vIGVkaXRhYmxlLCBzZXQgdGhlIHNlbGVjdGlvbiwgdGhlbiBzZXQgaXQgdW5lZGl0YWJsZSBhZ2Fpbi5cbmNvbnN0IGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlID0gc2FmYXJpIHx8IGNocm9tZSAmJiBjaHJvbWVfdmVyc2lvbiA8IDYzO1xuZnVuY3Rpb24gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgcG9zKSB7XG4gICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIDApO1xuICAgIGxldCBhZnRlciA9IG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPyBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSA6IG51bGw7XG4gICAgbGV0IGJlZm9yZSA9IG9mZnNldCA/IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXSA6IG51bGw7XG4gICAgaWYgKHNhZmFyaSAmJiBhZnRlciAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYWZ0ZXIpO1xuICAgIGlmICgoIWFmdGVyIHx8IGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmXG4gICAgICAgICghYmVmb3JlIHx8IGJlZm9yZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSkge1xuICAgICAgICBpZiAoYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYWZ0ZXIpO1xuICAgICAgICBlbHNlIGlmIChiZWZvcmUpXG4gICAgICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYmVmb3JlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRFZGl0YWJsZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBcInRydWVcIjtcbiAgICBpZiAoc2FmYXJpICYmIGVsZW1lbnQuZHJhZ2dhYmxlKSB7XG4gICAgICAgIGVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiByZXNldEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICBpZiAoZWxlbWVudC53YXNEcmFnZ2FibGUpIHtcbiAgICAgICAgZWxlbWVudC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICBlbGVtZW50Lndhc0RyYWdnYWJsZSA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NPblNlbGVjdGlvbkNoYW5nZSh2aWV3KSB7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQpO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBkb21TZWwuYW5jaG9yTm9kZSwgb2Zmc2V0ID0gZG9tU2VsLmFuY2hvck9mZnNldDtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICE9IG5vZGUgfHwgZG9tU2VsLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCksIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IHZpZXcuY3Vyc29yV3JhcHBlci5kb20sIGltZyA9IG5vZGUubm9kZU5hbWUgPT0gXCJJTUdcIjtcbiAgICBpZiAoaW1nKVxuICAgICAgICByYW5nZS5zZXRFbmQobm9kZS5wYXJlbnROb2RlLCBkb21JbmRleChub2RlKSArIDEpO1xuICAgIGVsc2VcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIDApO1xuICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICBkb21TZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgZG9tU2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAvLyBLbHVkZ2UgdG8ga2lsbCAnY29udHJvbCBzZWxlY3Rpb24nIGluIElFMTEgd2hlbiBzZWxlY3RpbmcgYW5cbiAgICAvLyBpbnZpc2libGUgY3Vyc29yIHdyYXBwZXIsIHNpbmNlIHRoYXQgd291bGQgcmVzdWx0IGluIHRob3NlIHdlaXJkXG4gICAgLy8gcmVzaXplIGhhbmRsZXMgYW5kIGEgc2VsZWN0aW9uIHRoYXQgY29uc2lkZXJzIHRoZSBhYnNvbHV0ZWx5XG4gICAgLy8gcG9zaXRpb25lZCB3cmFwcGVyLCByYXRoZXIgdGhhbiB0aGUgcm9vdCBlZGl0YWJsZSBub2RlLCB0aGVcbiAgICAvLyBmb2N1c2VkIGVsZW1lbnQuXG4gICAgaWYgKCFpbWcgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUgJiYgaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSkge1xuICAgICAgICBub2RlLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN5bmNOb2RlU2VsZWN0aW9uKHZpZXcsIHNlbCkge1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3LmRlc2NBdChzZWwuZnJvbSk7XG4gICAgICAgIGlmIChkZXNjICE9IHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MpIHtcbiAgICAgICAgICAgIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KTtcbiAgICAgICAgICAgIGlmIChkZXNjKVxuICAgICAgICAgICAgICAgIGRlc2Muc2VsZWN0Tm9kZSgpO1xuICAgICAgICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IGRlc2M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KTtcbiAgICB9XG59XG4vLyBDbGVhciBhbGwgRE9NIHN0YXRlZnVsbmVzcyBvZiB0aGUgbGFzdCBub2RlIHNlbGVjdGlvbi5cbmZ1bmN0aW9uIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KSB7XG4gICAgaWYgKHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MpIHtcbiAgICAgICAgaWYgKHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MucGFyZW50KVxuICAgICAgICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYy5kZXNlbGVjdE5vZGUoKTtcbiAgICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRhbmNob3IsICRoZWFkLCBiaWFzKSB7XG4gICAgcmV0dXJuIHZpZXcuc29tZVByb3AoXCJjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuXCIsIGYgPT4gZih2aWV3LCAkYW5jaG9yLCAkaGVhZCkpXG4gICAgICAgIHx8IFRleHRTZWxlY3Rpb24uYmV0d2VlbigkYW5jaG9yLCAkaGVhZCwgYmlhcyk7XG59XG5mdW5jdGlvbiBoYXNGb2N1c0FuZFNlbGVjdGlvbih2aWV3KSB7XG4gICAgaWYgKHZpZXcuZWRpdGFibGUgJiYgIXZpZXcuaGFzRm9jdXMoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBoYXNTZWxlY3Rpb24odmlldyk7XG59XG5mdW5jdGlvbiBoYXNTZWxlY3Rpb24odmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgaWYgKCFzZWwuYW5jaG9yTm9kZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZpcmVmb3ggd2lsbCByYWlzZSAncGVybWlzc2lvbiBkZW5pZWQnIGVycm9ycyB3aGVuIGFjY2Vzc2luZ1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIG9mIGBzZWwuYW5jaG9yTm9kZWAgd2hlbiBpdCdzIGluIGEgZ2VuZXJhdGVkIENTU1xuICAgICAgICAvLyBlbGVtZW50LlxuICAgICAgICByZXR1cm4gdmlldy5kb20uY29udGFpbnMoc2VsLmFuY2hvck5vZGUubm9kZVR5cGUgPT0gMyA/IHNlbC5hbmNob3JOb2RlLnBhcmVudE5vZGUgOiBzZWwuYW5jaG9yTm9kZSkgJiZcbiAgICAgICAgICAgICh2aWV3LmVkaXRhYmxlIHx8IHZpZXcuZG9tLmNvbnRhaW5zKHNlbC5mb2N1c05vZGUubm9kZVR5cGUgPT0gMyA/IHNlbC5mb2N1c05vZGUucGFyZW50Tm9kZSA6IHNlbC5mb2N1c05vZGUpKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFuY2hvckluUmlnaHRQbGFjZSh2aWV3KSB7XG4gICAgbGV0IGFuY2hvckRPTSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciwgMCk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICByZXR1cm4gaXNFcXVpdmFsZW50UG9zaXRpb24oYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbn1cblxuZnVuY3Rpb24gbW92ZVNlbGVjdGlvbkJsb2NrKHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgeyAkYW5jaG9yLCAkaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCAkc2lkZSA9IGRpciA+IDAgPyAkYW5jaG9yLm1heCgkaGVhZCkgOiAkYW5jaG9yLm1pbigkaGVhZCk7XG4gICAgbGV0ICRzdGFydCA9ICEkc2lkZS5wYXJlbnQuaW5saW5lQ29udGVudCA/ICRzaWRlIDogJHNpZGUuZGVwdGggPyBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHNpZGUuYWZ0ZXIoKSA6ICRzaWRlLmJlZm9yZSgpKSA6IG51bGw7XG4gICAgcmV0dXJuICRzdGFydCAmJiBTZWxlY3Rpb24uZmluZEZyb20oJHN0YXJ0LCBkaXIpO1xufVxuZnVuY3Rpb24gYXBwbHkodmlldywgc2VsKSB7XG4gICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xuICAgICAgICBpZiAobW9kcy5pbmRleE9mKFwic1wiKSA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgeyAkaGVhZCB9ID0gc2VsLCBub2RlID0gJGhlYWQudGV4dE9mZnNldCA/IG51bGwgOiBkaXIgPCAwID8gJGhlYWQubm9kZUJlZm9yZSA6ICRoZWFkLm5vZGVBZnRlcjtcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCBub2RlLmlzVGV4dCB8fCAhbm9kZS5pc0xlYWYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0ICRuZXdIZWFkID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgkaGVhZC5wb3MgKyBub2RlLm5vZGVTaXplICogKGRpciA8IDAgPyAtMSA6IDEpKTtcbiAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgVGV4dFNlbGVjdGlvbihzZWwuJGFuY2hvciwgJG5ld0hlYWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghc2VsLmVtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmlldy5lbmRPZlRleHRibG9jayhkaXIgPiAwID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIpKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgICAgICAgaWYgKG5leHQgJiYgKG5leHQgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShtYWMgJiYgbW9kcy5pbmRleE9mKFwibVwiKSA+IC0xKSkge1xuICAgICAgICAgICAgbGV0ICRoZWFkID0gc2VsLiRoZWFkLCBub2RlID0gJGhlYWQudGV4dE9mZnNldCA/IG51bGwgOiBkaXIgPCAwID8gJGhlYWQubm9kZUJlZm9yZSA6ICRoZWFkLm5vZGVBZnRlciwgZGVzYztcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCBub2RlLmlzVGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbm9kZVBvcyA9IGRpciA8IDAgPyAkaGVhZC5wb3MgLSBub2RlLm5vZGVTaXplIDogJGhlYWQucG9zO1xuICAgICAgICAgICAgaWYgKCEobm9kZS5pc0F0b20gfHwgKGRlc2MgPSB2aWV3LmRvY1ZpZXcuZGVzY0F0KG5vZGVQb3MpKSAmJiAhZGVzYy5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IE5vZGVTZWxlY3Rpb24oZGlyIDwgMCA/IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoJGhlYWQucG9zIC0gbm9kZS5ub2RlU2l6ZSkgOiAkaGVhZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod2Via2l0KSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIGFuZCBTYWZhcmkgd2lsbCBpbnRyb2R1Y2UgZXh0cmEgcG9pbnRsZXNzIGN1cnNvclxuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9ucyBhcm91bmQgaW5saW5lIHVuZWRpdGFibGUgbm9kZXMsIHNvIHdlIGhhdmUgdG9cbiAgICAgICAgICAgICAgICAvLyB0YWtlIG92ZXIgYW5kIG1vdmUgdGhlIGN1cnNvciBwYXN0IHRoZW0gKCM5MzcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZGlyIDwgMCA/IG5vZGVQb3MgOiBub2RlUG9zICsgbm9kZS5ub2RlU2l6ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbC5ub2RlLmlzSW5saW5lKSB7XG4gICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgVGV4dFNlbGVjdGlvbihkaXIgPiAwID8gc2VsLiR0byA6IHNlbC4kZnJvbSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV4dCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBub2RlTGVuKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGlzSWdub3JhYmxlKGRvbSwgZGlyKSB7XG4gICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICByZXR1cm4gZGVzYyAmJiBkZXNjLnNpemUgPT0gMCAmJiAoZGlyIDwgMCB8fCBkb20ubmV4dFNpYmxpbmcgfHwgZG9tLm5vZGVOYW1lICE9IFwiQlJcIik7XG59XG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcikge1xuICAgIHJldHVybiBkaXIgPCAwID8gc2tpcElnbm9yZWROb2Rlc0JlZm9yZSh2aWV3KSA6IHNraXBJZ25vcmVkTm9kZXNBZnRlcih2aWV3KTtcbn1cbi8vIE1ha2Ugc3VyZSB0aGUgY3Vyc29yIGlzbid0IGRpcmVjdGx5IGFmdGVyIG9uZSBvciBtb3JlIGlnbm9yZWRcbi8vIG5vZGVzLCB3aGljaCB3aWxsIGNvbmZ1c2UgdGhlIGJyb3dzZXIncyBjdXJzb3IgbW90aW9uIGxvZ2ljLlxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlc0JlZm9yZSh2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbW92ZU5vZGUsIG1vdmVPZmZzZXQsIGZvcmNlID0gZmFsc2U7XG4gICAgLy8gR2Vja28gd2lsbCBkbyBvZGQgdGhpbmdzIHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBkaXJlY3RseSBpbiBmcm9udFxuICAgIC8vIG9mIGEgbm9uLWVkaXRhYmxlIG5vZGUsIHNvIGluIHRoYXQgY2FzZSwgbW92ZSBpdCBpbnRvIHRoZSBuZXh0XG4gICAgLy8gbm9kZSBpZiBwb3NzaWJsZS4gSXNzdWUgcHJvc2VtaXJyb3IvcHJvc2VtaXJyb3IjODMyLlxuICAgIGlmIChnZWNrbyAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZUxlbihub2RlKSAmJiBpc0lnbm9yYWJsZShub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSwgLTEpKVxuICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJZ25vcmFibGUoYmVmb3JlLCAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gLS1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Jsb2NrTm9kZShub2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgd2hpbGUgKHByZXYgJiYgaXNJZ25vcmFibGUocHJldiwgLTEpKSB7XG4gICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IGRvbUluZGV4KHByZXYpO1xuICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2LnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gcHJldjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBub2RlTGVuKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmb3JjZSlcbiAgICAgICAgc2V0U2VsRm9jdXModmlldywgbm9kZSwgb2Zmc2V0KTtcbiAgICBlbHNlIGlmIChtb3ZlTm9kZSlcbiAgICAgICAgc2V0U2VsRm9jdXModmlldywgbW92ZU5vZGUsIG1vdmVPZmZzZXQpO1xufVxuLy8gTWFrZSBzdXJlIHRoZSBjdXJzb3IgaXNuJ3QgZGlyZWN0bHkgYmVmb3JlIG9uZSBvciBtb3JlIGlnbm9yZWRcbi8vIG5vZGVzLlxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlc0FmdGVyKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBsZW4gPSBub2RlTGVuKG5vZGUpO1xuICAgIGxldCBtb3ZlTm9kZSwgbW92ZU9mZnNldDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChpc0lnbm9yYWJsZShhZnRlciwgMSkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9ICsrb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICYmIGlzSWdub3JhYmxlKG5leHQsIDEpKSB7XG4gICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBuZXh0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IGRvbUluZGV4KG5leHQpICsgMTtcbiAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGxlbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1vdmVOb2RlKVxuICAgICAgICBzZXRTZWxGb2N1cyh2aWV3LCBtb3ZlTm9kZSwgbW92ZU9mZnNldCk7XG59XG5mdW5jdGlvbiBpc0Jsb2NrTm9kZShkb20pIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jaztcbn1cbmZ1bmN0aW9uIHRleHROb2RlQWZ0ZXIobm9kZSwgb2Zmc2V0KSB7XG4gICAgd2hpbGUgKG5vZGUgJiYgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgIWhhc0Jsb2NrRGVzYyhub2RlKSkge1xuICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKSArIDE7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHdoaWxlIChub2RlICYmIG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG5leHQgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAxICYmIG5leHQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUJlZm9yZShub2RlLCBvZmZzZXQpIHtcbiAgICB3aGlsZSAobm9kZSAmJiAhb2Zmc2V0ICYmICFoYXNCbG9ja0Rlc2Mobm9kZSkpIHtcbiAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHdoaWxlIChub2RlICYmIG9mZnNldCkge1xuICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAxICYmIG5leHQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgb2Zmc2V0ID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRTZWxGb2N1cyh2aWV3LCBub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAzKSB7XG4gICAgICAgIGxldCBiZWZvcmUsIGFmdGVyO1xuICAgICAgICBpZiAoYWZ0ZXIgPSB0ZXh0Tm9kZUFmdGVyKG5vZGUsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBhZnRlcjtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmVmb3JlID0gdGV4dE5vZGVCZWZvcmUobm9kZSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgIG9mZnNldCA9IGJlZm9yZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICAgIGlmIChzZWxlY3Rpb25Db2xsYXBzZWQoc2VsKSkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWwuZXh0ZW5kKSB7XG4gICAgICAgIHNlbC5leHRlbmQobm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldztcbiAgICAvLyBJZiBubyBzdGF0ZSB1cGRhdGUgZW5kcyB1cCBoYXBwZW5pbmcsIHJlc2V0IHRoZSBzZWxlY3Rpb24uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlID09IHN0YXRlKVxuICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gZmluZERpcmVjdGlvbih2aWV3LCBwb3MpIHtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoIShjaHJvbWUgfHwgd2luZG93cykgJiYgJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBsZXQgY29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICBpZiAocG9zID4gJHBvcy5zdGFydCgpKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gdmlldy5jb29yZHNBdFBvcyhwb3MgLSAxKTtcbiAgICAgICAgICAgIGxldCBtaWQgPSAoYmVmb3JlLnRvcCArIGJlZm9yZS5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgIGlmIChtaWQgPiBjb29yZHMudG9wICYmIG1pZCA8IGNvb3Jkcy5ib3R0b20gJiYgTWF0aC5hYnMoYmVmb3JlLmxlZnQgLSBjb29yZHMubGVmdCkgPiAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBiZWZvcmUubGVmdCA8IGNvb3Jkcy5sZWZ0ID8gXCJsdHJcIiA6IFwicnRsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA8ICRwb3MuZW5kKCkpIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IHZpZXcuY29vcmRzQXRQb3MocG9zICsgMSk7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGFmdGVyLnRvcCArIGFmdGVyLmJvdHRvbSkgLyAyO1xuICAgICAgICAgICAgaWYgKG1pZCA+IGNvb3Jkcy50b3AgJiYgbWlkIDwgY29vcmRzLmJvdHRvbSAmJiBNYXRoLmFicyhhZnRlci5sZWZ0IC0gY29vcmRzLmxlZnQpID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXIubGVmdCA+IGNvb3Jkcy5sZWZ0ID8gXCJsdHJcIiA6IFwicnRsXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSh2aWV3LmRvbSkuZGlyZWN0aW9uO1xuICAgIHJldHVybiBjb21wdXRlZCA9PSBcInJ0bFwiID8gXCJydGxcIiA6IFwibHRyXCI7XG59XG4vLyBDaGVjayB3aGV0aGVyIHZlcnRpY2FsIHNlbGVjdGlvbiBtb3Rpb24gd291bGQgaW52b2x2ZSBub2RlXG4vLyBzZWxlY3Rpb25zLiBJZiBzbywgYXBwbHkgaXQgKGlmIG5vdCwgdGhlIHJlc3VsdCBpcyBsZWZ0IHRvIHRoZVxuLy8gYnJvd3NlcilcbmZ1bmN0aW9uIHNlbGVjdFZlcnRpY2FsbHkodmlldywgZGlyLCBtb2RzKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmICFzZWwuZW1wdHkgfHwgbW9kcy5pbmRleE9mKFwic1wiKSA+IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG1hYyAmJiBtb2RzLmluZGV4T2YoXCJtXCIpID4gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzZWw7XG4gICAgaWYgKCEkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCB2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA8IDAgPyBcInVwXCIgOiBcImRvd25cIikpIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICAgICAgaWYgKG5leHQgJiYgKG5leHQgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICB9XG4gICAgaWYgKCEkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBsZXQgc2lkZSA9IGRpciA8IDAgPyAkZnJvbSA6ICR0bztcbiAgICAgICAgbGV0IGJleW9uZCA9IHNlbCBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbiA/IFNlbGVjdGlvbi5uZWFyKHNpZGUsIGRpcikgOiBTZWxlY3Rpb24uZmluZEZyb20oc2lkZSwgZGlyKTtcbiAgICAgICAgcmV0dXJuIGJleW9uZCA/IGFwcGx5KHZpZXcsIGJleW9uZCkgOiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgZGlyKSB7XG4gICAgaWYgKCEodmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IHsgJGhlYWQsICRhbmNob3IsIGVtcHR5IH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodmlldy5lbmRPZlRleHRibG9jayhkaXIgPiAwID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgbmV4dE5vZGUgPSAhJGhlYWQudGV4dE9mZnNldCAmJiAoZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXIpO1xuICAgIGlmIChuZXh0Tm9kZSAmJiAhbmV4dE5vZGUuaXNUZXh0KSB7XG4gICAgICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgdHIuZGVsZXRlKCRoZWFkLnBvcyAtIG5leHROb2RlLm5vZGVTaXplLCAkaGVhZC5wb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ci5kZWxldGUoJGhlYWQucG9zLCAkaGVhZC5wb3MgKyBuZXh0Tm9kZS5ub2RlU2l6ZSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3dpdGNoRWRpdGFibGUodmlldywgbm9kZSwgc3RhdGUpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICBub2RlLmNvbnRlbnRFZGl0YWJsZSA9IHN0YXRlO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbn1cbi8vIElzc3VlICM4NjcgLyAjMTA5MCAvIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTkwMzgyMVxuLy8gSW4gd2hpY2ggU2FmYXJpIChhbmQgYXQgc29tZSBwb2ludCBpbiB0aGUgcGFzdCwgQ2hyb21lKSBkb2VzIHJlYWxseVxuLy8gd3JvbmcgdGhpbmdzIHdoZW4gdGhlIGRvd24gYXJyb3cgaXMgcHJlc3NlZCB3aGVuIHRoZSBjdXJzb3IgaXNcbi8vIGRpcmVjdGx5IGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jayBhbmQgaGFzIGFuIHVuZWRpdGFibGUgbm9kZVxuLy8gYWZ0ZXIgaXRcbmZ1bmN0aW9uIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB7XG4gICAgaWYgKCFzYWZhcmkgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGhlYWQucGFyZW50T2Zmc2V0ID4gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBpZiAoZm9jdXNOb2RlICYmIGZvY3VzTm9kZS5ub2RlVHlwZSA9PSAxICYmIGZvY3VzT2Zmc2V0ID09IDAgJiZcbiAgICAgICAgZm9jdXNOb2RlLmZpcnN0Q2hpbGQgJiYgZm9jdXNOb2RlLmZpcnN0Q2hpbGQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikge1xuICAgICAgICBsZXQgY2hpbGQgPSBmb2N1c05vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgc3dpdGNoRWRpdGFibGUodmlldywgY2hpbGQsIFwidHJ1ZVwiKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzd2l0Y2hFZGl0YWJsZSh2aWV3LCBjaGlsZCwgXCJmYWxzZVwiKSwgMjApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBBIGJhY2tkcm9wIGtleSBtYXBwaW5nIHVzZWQgdG8gbWFrZSBzdXJlIHdlIGFsd2F5cyBzdXBwcmVzcyBrZXlzXG4vLyB0aGF0IGhhdmUgYSBkYW5nZXJvdXMgZGVmYXVsdCBlZmZlY3QsIGV2ZW4gaWYgdGhlIGNvbW1hbmRzIHRoZXkgYXJlXG4vLyBib3VuZCB0byByZXR1cm4gZmFsc2UsIGFuZCB0byBtYWtlIHN1cmUgdGhhdCBjdXJzb3ItbW90aW9uIGtleXNcbi8vIGZpbmQgYSBjdXJzb3IgKGFzIG9wcG9zZWQgdG8gYSBub2RlIHNlbGVjdGlvbikgd2hlbiBwcmVzc2VkLiBGb3Jcbi8vIGN1cnNvci1tb3Rpb24ga2V5cywgdGhlIGNvZGUgaW4gdGhlIGhhbmRsZXJzIGFsc28gdGFrZXMgY2FyZSBvZlxuLy8gYmxvY2sgc2VsZWN0aW9ucy5cbmZ1bmN0aW9uIGdldE1vZHMoZXZlbnQpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwiY1wiO1xuICAgIGlmIChldmVudC5tZXRhS2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJtXCI7XG4gICAgaWYgKGV2ZW50LmFsdEtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwiYVwiO1xuICAgIGlmIChldmVudC5zaGlmdEtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwic1wiO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjYXB0dXJlS2V5RG93bih2aWV3LCBldmVudCkge1xuICAgIGxldCBjb2RlID0gZXZlbnQua2V5Q29kZSwgbW9kcyA9IGdldE1vZHMoZXZlbnQpO1xuICAgIGlmIChjb2RlID09IDggfHwgKG1hYyAmJiBjb2RlID09IDcyICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIEJhY2tzcGFjZSwgQ3RybC1oIG9uIE1hY1xuICAgICAgICByZXR1cm4gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgLTEpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgLTEpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoY29kZSA9PSA0NiAmJiAhZXZlbnQuc2hpZnRLZXkpIHx8IChtYWMgJiYgY29kZSA9PSA2OCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBEZWxldGUsIEN0cmwtZCBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIDEpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMTMgfHwgY29kZSA9PSAyNykgeyAvLyBFbnRlciwgRXNjXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDM3IHx8IChtYWMgJiYgY29kZSA9PSA2NiAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBMZWZ0IGFycm93LCBDdHJsLWIgb24gTWFjXG4gICAgICAgIGxldCBkaXIgPSBjb2RlID09IDM3ID8gKGZpbmREaXJlY3Rpb24odmlldywgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSkgPT0gXCJsdHJcIiA/IC0xIDogMSkgOiAtMTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCBkaXIsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgZGlyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAzOSB8fCAobWFjICYmIGNvZGUgPT0gNzAgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gUmlnaHQgYXJyb3csIEN0cmwtZiBvbiBNYWNcbiAgICAgICAgbGV0IGRpciA9IGNvZGUgPT0gMzkgPyAoZmluZERpcmVjdGlvbih2aWV3LCB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tKSA9PSBcImx0clwiID8gMSA6IC0xKSA6IDE7XG4gICAgICAgIHJldHVybiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMzggfHwgKG1hYyAmJiBjb2RlID09IDgwICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIFVwIGFycm93LCBDdHJsLXAgb24gTWFjXG4gICAgICAgIHJldHVybiBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIC0xLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIC0xKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSA0MCB8fCAobWFjICYmIGNvZGUgPT0gNzggJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gRG93biBhcnJvdywgQ3RybC1uIG9uIE1hY1xuICAgICAgICByZXR1cm4gc2FmYXJpRG93bkFycm93QnVnKHZpZXcpIHx8IHNlbGVjdFZlcnRpY2FsbHkodmlldywgMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAxKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobW9kcyA9PSAobWFjID8gXCJtXCIgOiBcImNcIikgJiZcbiAgICAgICAgKGNvZGUgPT0gNjYgfHwgY29kZSA9PSA3MyB8fCBjb2RlID09IDg5IHx8IGNvZGUgPT0gOTApKSB7IC8vIE1vZC1bYml5el1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIHNsaWNlKSB7XG4gICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybUNvcGllZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3KTsgfSk7XG4gICAgbGV0IGNvbnRleHQgPSBbXSwgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHNsaWNlO1xuICAgIHdoaWxlIChvcGVuU3RhcnQgPiAxICYmIG9wZW5FbmQgPiAxICYmIGNvbnRlbnQuY2hpbGRDb3VudCA9PSAxICYmIGNvbnRlbnQuZmlyc3RDaGlsZC5jaGlsZENvdW50ID09IDEpIHtcbiAgICAgICAgb3BlblN0YXJ0LS07XG4gICAgICAgIG9wZW5FbmQtLTtcbiAgICAgICAgbGV0IG5vZGUgPSBjb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGNvbnRleHQucHVzaChub2RlLnR5cGUubmFtZSwgbm9kZS5hdHRycyAhPSBub2RlLnR5cGUuZGVmYXVsdEF0dHJzID8gbm9kZS5hdHRycyA6IG51bGwpO1xuICAgICAgICBjb250ZW50ID0gbm9kZS5jb250ZW50O1xuICAgIH1cbiAgICBsZXQgc2VyaWFsaXplciA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRTZXJpYWxpemVyXCIpIHx8IERPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gICAgbGV0IGRvYyA9IGRldGFjaGVkRG9jKCksIHdyYXAgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB3cmFwLmFwcGVuZENoaWxkKHNlcmlhbGl6ZXIuc2VyaWFsaXplRnJhZ21lbnQoY29udGVudCwgeyBkb2N1bWVudDogZG9jIH0pKTtcbiAgICBsZXQgZmlyc3RDaGlsZCA9IHdyYXAuZmlyc3RDaGlsZCwgbmVlZHNXcmFwLCB3cmFwcGVycyA9IDA7XG4gICAgd2hpbGUgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAxICYmIChuZWVkc1dyYXAgPSB3cmFwTWFwW2ZpcnN0Q2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBuZWVkc1dyYXAubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB3cmFwcGVyID0gZG9jLmNyZWF0ZUVsZW1lbnQobmVlZHNXcmFwW2ldKTtcbiAgICAgICAgICAgIHdoaWxlICh3cmFwLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZCh3cmFwLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgIHdyYXBwZXJzKys7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RDaGlsZCA9IHdyYXAuZmlyc3RDaGlsZDtcbiAgICB9XG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICBmaXJzdENoaWxkLnNldEF0dHJpYnV0ZShcImRhdGEtcG0tc2xpY2VcIiwgYCR7b3BlblN0YXJ0fSAke29wZW5FbmR9JHt3cmFwcGVycyA/IGAgLSR7d3JhcHBlcnN9YCA6IFwiXCJ9ICR7SlNPTi5zdHJpbmdpZnkoY29udGV4dCl9YCk7XG4gICAgbGV0IHRleHQgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXJcIiwgZiA9PiBmKHNsaWNlLCB2aWV3KSkgfHxcbiAgICAgICAgc2xpY2UuY29udGVudC50ZXh0QmV0d2VlbigwLCBzbGljZS5jb250ZW50LnNpemUsIFwiXFxuXFxuXCIpO1xuICAgIHJldHVybiB7IGRvbTogd3JhcCwgdGV4dCB9O1xufVxuLy8gUmVhZCBhIHNsaWNlIG9mIGNvbnRlbnQgZnJvbSB0aGUgY2xpcGJvYXJkIChvciBkcm9wIGRhdGEpLlxuZnVuY3Rpb24gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIHRleHQsIGh0bWwsIHBsYWluVGV4dCwgJGNvbnRleHQpIHtcbiAgICBsZXQgaW5Db2RlID0gJGNvbnRleHQucGFyZW50LnR5cGUuc3BlYy5jb2RlO1xuICAgIGxldCBkb20sIHNsaWNlO1xuICAgIGlmICghaHRtbCAmJiAhdGV4dClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGFzVGV4dCA9IHRleHQgJiYgKHBsYWluVGV4dCB8fCBpbkNvZGUgfHwgIWh0bWwpO1xuICAgIGlmIChhc1RleHQpIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFRleHRcIiwgZiA9PiB7IHRleHQgPSBmKHRleHQsIGluQ29kZSB8fCBwbGFpblRleHQsIHZpZXcpOyB9KTtcbiAgICAgICAgaWYgKGluQ29kZSlcbiAgICAgICAgICAgIHJldHVybiB0ZXh0ID8gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odmlldy5zdGF0ZS5zY2hlbWEudGV4dCh0ZXh0LnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIikpKSwgMCwgMCkgOiBTbGljZS5lbXB0eTtcbiAgICAgICAgbGV0IHBhcnNlZCA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRUZXh0UGFyc2VyXCIsIGYgPT4gZih0ZXh0LCAkY29udGV4dCwgcGxhaW5UZXh0LCB2aWV3KSk7XG4gICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgIHNsaWNlID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1hcmtzID0gJGNvbnRleHQubWFya3MoKTtcbiAgICAgICAgICAgIGxldCB7IHNjaGVtYSB9ID0gdmlldy5zdGF0ZSwgc2VyaWFsaXplciA9IERPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYShzY2hlbWEpO1xuICAgICAgICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRleHQuc3BsaXQoLyg/Olxcclxcbj98XFxuKSsvKS5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcCA9IGRvbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrKVxuICAgICAgICAgICAgICAgICAgICBwLmFwcGVuZENoaWxkKHNlcmlhbGl6ZXIuc2VyaWFsaXplTm9kZShzY2hlbWEudGV4dChibG9jaywgbWFya3MpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZEhUTUxcIiwgZiA9PiB7IGh0bWwgPSBmKGh0bWwsIHZpZXcpOyB9KTtcbiAgICAgICAgZG9tID0gcmVhZEhUTUwoaHRtbCk7XG4gICAgICAgIGlmICh3ZWJraXQpXG4gICAgICAgICAgICByZXN0b3JlUmVwbGFjZWRTcGFjZXMoZG9tKTtcbiAgICB9XG4gICAgbGV0IGNvbnRleHROb2RlID0gZG9tICYmIGRvbS5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtcG0tc2xpY2VdXCIpO1xuICAgIGxldCBzbGljZURhdGEgPSBjb250ZXh0Tm9kZSAmJiAvXihcXGQrKSAoXFxkKykoPzogLShcXGQrKSk/ICguKikvLmV4ZWMoY29udGV4dE5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1wbS1zbGljZVwiKSB8fCBcIlwiKTtcbiAgICBpZiAoc2xpY2VEYXRhICYmIHNsaWNlRGF0YVszXSlcbiAgICAgICAgZm9yIChsZXQgaSA9ICtzbGljZURhdGFbM107IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IGRvbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkb20gPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIGlmICghc2xpY2UpIHtcbiAgICAgICAgbGV0IHBhcnNlciA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRQYXJzZXJcIikgfHwgdmlldy5zb21lUHJvcChcImRvbVBhcnNlclwiKSB8fCBET01QYXJzZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gICAgICAgIHNsaWNlID0gcGFyc2VyLnBhcnNlU2xpY2UoZG9tLCB7XG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICEhKGFzVGV4dCB8fCBzbGljZURhdGEpLFxuICAgICAgICAgICAgY29udGV4dDogJGNvbnRleHQsXG4gICAgICAgICAgICBydWxlRnJvbU5vZGUoZG9tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgIWRvbS5uZXh0U2libGluZyAmJlxuICAgICAgICAgICAgICAgICAgICBkb20ucGFyZW50Tm9kZSAmJiAhaW5saW5lUGFyZW50cy50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2xpY2VEYXRhKSB7XG4gICAgICAgIHNsaWNlID0gYWRkQ29udGV4dChjbG9zZVNsaWNlKHNsaWNlLCArc2xpY2VEYXRhWzFdLCArc2xpY2VEYXRhWzJdKSwgc2xpY2VEYXRhWzRdKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIEhUTUwgd2Fzbid0IGNyZWF0ZWQgYnkgUHJvc2VNaXJyb3IuIE1ha2Ugc3VyZSB0b3AtbGV2ZWwgc2libGluZ3MgYXJlIGNvaGVyZW50XG4gICAgICAgIHNsaWNlID0gU2xpY2UubWF4T3Blbihub3JtYWxpemVTaWJsaW5ncyhzbGljZS5jb250ZW50LCAkY29udGV4dCksIHRydWUpO1xuICAgICAgICBpZiAoc2xpY2Uub3BlblN0YXJ0IHx8IHNsaWNlLm9wZW5FbmQpIHtcbiAgICAgICAgICAgIGxldCBvcGVuU3RhcnQgPSAwLCBvcGVuRW5kID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQ7IG9wZW5TdGFydCA8IHNsaWNlLm9wZW5TdGFydCAmJiAhbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nOyBvcGVuU3RhcnQrKywgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZCkgeyB9XG4gICAgICAgICAgICBmb3IgKGxldCBub2RlID0gc2xpY2UuY29udGVudC5sYXN0Q2hpbGQ7IG9wZW5FbmQgPCBzbGljZS5vcGVuRW5kICYmICFub2RlLnR5cGUuc3BlYy5pc29sYXRpbmc7IG9wZW5FbmQrKywgbm9kZSA9IG5vZGUubGFzdENoaWxkKSB7IH1cbiAgICAgICAgICAgIHNsaWNlID0gY2xvc2VTbGljZShzbGljZSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkXCIsIGYgPT4geyBzbGljZSA9IGYoc2xpY2UsIHZpZXcpOyB9KTtcbiAgICByZXR1cm4gc2xpY2U7XG59XG5jb25zdCBpbmxpbmVQYXJlbnRzID0gL14oYXxhYmJyfGFjcm9ueW18YnxjaXRlfGNvZGV8ZGVsfGVtfGl8aW5zfGtiZHxsYWJlbHxvdXRwdXR8cXxydWJ5fHN8c2FtcHxzcGFufHN0cm9uZ3xzdWJ8c3VwfHRpbWV8dXx0dHx2YXIpJC9pO1xuLy8gVGFrZXMgYSBzbGljZSBwYXJzZWQgd2l0aCBwYXJzZVNsaWNlLCB3aGljaCBtZWFucyB0aGVyZSBoYXNuJ3QgYmVlblxuLy8gYW55IGNvbnRlbnQtZXhwcmVzc2lvbiBjaGVja2luZyBkb25lIG9uIHRoZSB0b3Agbm9kZXMsIHRyaWVzIHRvXG4vLyBmaW5kIGEgcGFyZW50IG5vZGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dCB0aGF0IG1pZ2h0IGZpdCB0aGUgbm9kZXMsXG4vLyBhbmQgaWYgc3VjY2Vzc2Z1bCwgcmVidWlsZHMgdGhlIHNsaWNlIHNvIHRoYXQgaXQgZml0cyBpbnRvIHRoYXQgcGFyZW50LlxuLy9cbi8vIFRoaXMgYWRkcmVzc2VzIHRoZSBwcm9ibGVtIHRoYXQgVHJhbnNmb3JtLnJlcGxhY2UgZXhwZWN0cyBhXG4vLyBjb2hlcmVudCBzbGljZSwgYW5kIHdpbGwgZmFpbCB0byBwbGFjZSBhIHNldCBvZiBzaWJsaW5ncyB0aGF0IGRvbid0XG4vLyBmaXQgYW55d2hlcmUgaW4gdGhlIHNjaGVtYS5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpYmxpbmdzKGZyYWdtZW50LCAkY29udGV4dCkge1xuICAgIGlmIChmcmFnbWVudC5jaGlsZENvdW50IDwgMilcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIGZvciAobGV0IGQgPSAkY29udGV4dC5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRjb250ZXh0Lm5vZGUoZCk7XG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgkY29udGV4dC5pbmRleChkKSk7XG4gICAgICAgIGxldCBsYXN0V3JhcCwgcmVzdWx0ID0gW107XG4gICAgICAgIGZyYWdtZW50LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgd3JhcCA9IG1hdGNoLmZpbmRXcmFwcGluZyhub2RlLnR5cGUpLCBpbkxhc3Q7XG4gICAgICAgICAgICBpZiAoIXdyYXApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaW5MYXN0ID0gcmVzdWx0Lmxlbmd0aCAmJiBsYXN0V3JhcC5sZW5ndGggJiYgYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCAwKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBpbkxhc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IGNsb3NlUmlnaHQocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgbGFzdFdyYXAubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcHBlZCA9IHdpdGhXcmFwcGVycyhub2RlLCB3cmFwKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh3cmFwcGVkKTtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoLm1hdGNoVHlwZSh3cmFwcGVkLnR5cGUpO1xuICAgICAgICAgICAgICAgIGxhc3RXcmFwID0gd3JhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiB3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCwgZnJvbSA9IDApIHtcbiAgICBmb3IgKGxldCBpID0gd3JhcC5sZW5ndGggLSAxOyBpID49IGZyb207IGktLSlcbiAgICAgICAgbm9kZSA9IHdyYXBbaV0uY3JlYXRlKG51bGwsIEZyYWdtZW50LmZyb20obm9kZSkpO1xuICAgIHJldHVybiBub2RlO1xufVxuLy8gVXNlZCB0byBncm91cCBhZGphY2VudCBub2RlcyB3cmFwcGVkIGluIHNpbWlsYXIgcGFyZW50cyBieVxuLy8gbm9ybWFsaXplU2libGluZ3MgaW50byB0aGUgc2FtZSBwYXJlbnQgbm9kZVxuZnVuY3Rpb24gYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCBzaWJsaW5nLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA8IHdyYXAubGVuZ3RoICYmIGRlcHRoIDwgbGFzdFdyYXAubGVuZ3RoICYmIHdyYXBbZGVwdGhdID09IGxhc3RXcmFwW2RlcHRoXSkge1xuICAgICAgICBsZXQgaW5uZXIgPSBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHNpYmxpbmcubGFzdENoaWxkLCBkZXB0aCArIDEpO1xuICAgICAgICBpZiAoaW5uZXIpXG4gICAgICAgICAgICByZXR1cm4gc2libGluZy5jb3B5KHNpYmxpbmcuY29udGVudC5yZXBsYWNlQ2hpbGQoc2libGluZy5jaGlsZENvdW50IC0gMSwgaW5uZXIpKTtcbiAgICAgICAgbGV0IG1hdGNoID0gc2libGluZy5jb250ZW50TWF0Y2hBdChzaWJsaW5nLmNoaWxkQ291bnQpO1xuICAgICAgICBpZiAobWF0Y2gubWF0Y2hUeXBlKGRlcHRoID09IHdyYXAubGVuZ3RoIC0gMSA/IG5vZGUudHlwZSA6IHdyYXBbZGVwdGggKyAxXSkpXG4gICAgICAgICAgICByZXR1cm4gc2libGluZy5jb3B5KHNpYmxpbmcuY29udGVudC5hcHBlbmQoRnJhZ21lbnQuZnJvbSh3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCwgZGVwdGggKyAxKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zZVJpZ2h0KG5vZGUsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09IDApXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIGxldCBmcmFnbWVudCA9IG5vZGUuY29udGVudC5yZXBsYWNlQ2hpbGQobm9kZS5jaGlsZENvdW50IC0gMSwgY2xvc2VSaWdodChub2RlLmxhc3RDaGlsZCwgZGVwdGggLSAxKSk7XG4gICAgbGV0IGZpbGwgPSBub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG5vZGUuY29weShmcmFnbWVudC5hcHBlbmQoZmlsbCkpO1xufVxuZnVuY3Rpb24gY2xvc2VSYW5nZShmcmFnbWVudCwgc2lkZSwgZnJvbSwgdG8sIGRlcHRoLCBvcGVuRW5kKSB7XG4gICAgbGV0IG5vZGUgPSBzaWRlIDwgMCA/IGZyYWdtZW50LmZpcnN0Q2hpbGQgOiBmcmFnbWVudC5sYXN0Q2hpbGQsIGlubmVyID0gbm9kZS5jb250ZW50O1xuICAgIGlmIChmcmFnbWVudC5jaGlsZENvdW50ID4gMSlcbiAgICAgICAgb3BlbkVuZCA9IDA7XG4gICAgaWYgKGRlcHRoIDwgdG8gLSAxKVxuICAgICAgICBpbm5lciA9IGNsb3NlUmFuZ2UoaW5uZXIsIHNpZGUsIGZyb20sIHRvLCBkZXB0aCArIDEsIG9wZW5FbmQpO1xuICAgIGlmIChkZXB0aCA+PSBmcm9tKVxuICAgICAgICBpbm5lciA9IHNpZGUgPCAwID8gbm9kZS5jb250ZW50TWF0Y2hBdCgwKS5maWxsQmVmb3JlKGlubmVyLCBvcGVuRW5kIDw9IGRlcHRoKS5hcHBlbmQoaW5uZXIpXG4gICAgICAgICAgICA6IGlubmVyLmFwcGVuZChub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoc2lkZSA8IDAgPyAwIDogZnJhZ21lbnQuY2hpbGRDb3VudCAtIDEsIG5vZGUuY29weShpbm5lcikpO1xufVxuZnVuY3Rpb24gY2xvc2VTbGljZShzbGljZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgaWYgKG9wZW5TdGFydCA8IHNsaWNlLm9wZW5TdGFydClcbiAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoY2xvc2VSYW5nZShzbGljZS5jb250ZW50LCAtMSwgb3BlblN0YXJ0LCBzbGljZS5vcGVuU3RhcnQsIDAsIHNsaWNlLm9wZW5FbmQpLCBvcGVuU3RhcnQsIHNsaWNlLm9wZW5FbmQpO1xuICAgIGlmIChvcGVuRW5kIDwgc2xpY2Uub3BlbkVuZClcbiAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoY2xvc2VSYW5nZShzbGljZS5jb250ZW50LCAxLCBvcGVuRW5kLCBzbGljZS5vcGVuRW5kLCAwLCAwKSwgc2xpY2Uub3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICByZXR1cm4gc2xpY2U7XG59XG4vLyBUcmljayBmcm9tIGpRdWVyeSAtLSBzb21lIGVsZW1lbnRzIG11c3QgYmUgd3JhcHBlZCBpbiBvdGhlclxuLy8gZWxlbWVudHMgZm9yIGlubmVySFRNTCB0byB3b3JrLiBJLmUuIGlmIHlvdSBkbyBgZGl2LmlubmVySFRNTCA9XG4vLyBcIjx0ZD4uLjwvdGQ+XCJgIHRoZSB0YWJsZSBjZWxscyBhcmUgaWdub3JlZC5cbmNvbnN0IHdyYXBNYXAgPSB7XG4gICAgdGhlYWQ6IFtcInRhYmxlXCJdLFxuICAgIHRib2R5OiBbXCJ0YWJsZVwiXSxcbiAgICB0Zm9vdDogW1widGFibGVcIl0sXG4gICAgY2FwdGlvbjogW1widGFibGVcIl0sXG4gICAgY29sZ3JvdXA6IFtcInRhYmxlXCJdLFxuICAgIGNvbDogW1widGFibGVcIiwgXCJjb2xncm91cFwiXSxcbiAgICB0cjogW1widGFibGVcIiwgXCJ0Ym9keVwiXSxcbiAgICB0ZDogW1widGFibGVcIiwgXCJ0Ym9keVwiLCBcInRyXCJdLFxuICAgIHRoOiBbXCJ0YWJsZVwiLCBcInRib2R5XCIsIFwidHJcIl1cbn07XG5sZXQgX2RldGFjaGVkRG9jID0gbnVsbDtcbmZ1bmN0aW9uIGRldGFjaGVkRG9jKCkge1xuICAgIHJldHVybiBfZGV0YWNoZWREb2MgfHwgKF9kZXRhY2hlZERvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcInRpdGxlXCIpKTtcbn1cbmZ1bmN0aW9uIHJlYWRIVE1MKGh0bWwpIHtcbiAgICBsZXQgbWV0YXMgPSAvXihcXHMqPG1ldGEgW14+XSo+KSovLmV4ZWMoaHRtbCk7XG4gICAgaWYgKG1ldGFzKVxuICAgICAgICBodG1sID0gaHRtbC5zbGljZShtZXRhc1swXS5sZW5ndGgpO1xuICAgIGxldCBlbHQgPSBkZXRhY2hlZERvYygpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbGV0IGZpcnN0VGFnID0gLzwoW2Etel1bXj5cXHNdKykvaS5leGVjKGh0bWwpLCB3cmFwO1xuICAgIGlmICh3cmFwID0gZmlyc3RUYWcgJiYgd3JhcE1hcFtmaXJzdFRhZ1sxXS50b0xvd2VyQ2FzZSgpXSlcbiAgICAgICAgaHRtbCA9IHdyYXAubWFwKG4gPT4gXCI8XCIgKyBuICsgXCI+XCIpLmpvaW4oXCJcIikgKyBodG1sICsgd3JhcC5tYXAobiA9PiBcIjwvXCIgKyBuICsgXCI+XCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgIGVsdC5pbm5lckhUTUwgPSBodG1sO1xuICAgIGlmICh3cmFwKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBlbHQgPSBlbHQucXVlcnlTZWxlY3Rvcih3cmFwW2ldKSB8fCBlbHQ7XG4gICAgcmV0dXJuIGVsdDtcbn1cbi8vIFdlYmtpdCBicm93c2VycyBkbyBzb21lIGhhcmQtdG8tcHJlZGljdCByZXBsYWNlbWVudCBvZiByZWd1bGFyXG4vLyBzcGFjZXMgd2l0aCBub24tYnJlYWtpbmcgc3BhY2VzIHdoZW4gcHV0dGluZyBjb250ZW50IG9uIHRoZVxuLy8gY2xpcGJvYXJkLiBUaGlzIHRyaWVzIHRvIGNvbnZlcnQgc3VjaCBub24tYnJlYWtpbmcgc3BhY2VzICh3aGljaFxuLy8gd2lsbCBiZSB3cmFwcGVkIGluIGEgcGxhaW4gc3BhbiBvbiBDaHJvbWUsIGEgc3BhbiB3aXRoIGNsYXNzXG4vLyBBcHBsZS1jb252ZXJ0ZWQtc3BhY2Ugb24gU2FmYXJpKSBiYWNrIHRvIHJlZ3VsYXIgc3BhY2VzLlxuZnVuY3Rpb24gcmVzdG9yZVJlcGxhY2VkU3BhY2VzKGRvbSkge1xuICAgIGxldCBub2RlcyA9IGRvbS5xdWVyeVNlbGVjdG9yQWxsKGNocm9tZSA/IFwic3Bhbjpub3QoW2NsYXNzXSk6bm90KFtzdHlsZV0pXCIgOiBcInNwYW4uQXBwbGUtY29udmVydGVkLXNwYWNlXCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBub2RlLnRleHRDb250ZW50ID09IFwiXFx1MDBhMFwiICYmIG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIgXCIpLCBub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRDb250ZXh0KHNsaWNlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgbGV0IHNjaGVtYSA9IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZC50eXBlLnNjaGVtYSwgYXJyYXk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXJyYXkgPSBKU09OLnBhcnNlKGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgfVxuICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gc2xpY2U7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIGxldCB0eXBlID0gc2NoZW1hLm5vZGVzW2FycmF5W2ldXTtcbiAgICAgICAgaWYgKCF0eXBlIHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGFycmF5W2kgKyAxXSwgY29udGVudCkpO1xuICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgb3BlbkVuZCsrO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbi8vIEEgY29sbGVjdGlvbiBvZiBET00gZXZlbnRzIHRoYXQgb2NjdXIgd2l0aGluIHRoZSBlZGl0b3IsIGFuZCBjYWxsYmFjayBmdW5jdGlvbnNcbi8vIHRvIGludm9rZSB3aGVuIHRoZSBldmVudCBmaXJlcy5cbmNvbnN0IGhhbmRsZXJzID0ge307XG5jb25zdCBlZGl0SGFuZGxlcnMgPSB7fTtcbmNvbnN0IHBhc3NpdmVIYW5kbGVycyA9IHsgdG91Y2hzdGFydDogdHJ1ZSwgdG91Y2htb3ZlOiB0cnVlIH07XG5jbGFzcyBJbnB1dFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaGlmdEtleSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vdXNlRG93biA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdENsaWNrID0geyB0aW1lOiAwLCB4OiAwLCB5OiAwLCB0eXBlOiBcIlwiIH07XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHRoaXMubGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdEZvY3VzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2ggPSAwO1xuICAgICAgICB0aGlzLmxhc3RBbmRyb2lkRGVsZXRlID0gMDtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wb3NpbmdUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA9IC0yZTg7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25JRCA9IDE7XG4gICAgICAgIC8vIFNldCB0byBhIGNvbXBvc2l0aW9uIElEIHdoZW4gdGhlcmUgYXJlIHBlbmRpbmcgY2hhbmdlcyBhdCBjb21wb3NpdGlvbmVuZFxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSAwO1xuICAgICAgICB0aGlzLmRvbUNoYW5nZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5oaWRlU2VsZWN0aW9uR3VhcmQgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRJbnB1dCh2aWV3KSB7XG4gICAgZm9yIChsZXQgZXZlbnQgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1tldmVudF0gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudEJlbG9uZ3NUb1ZpZXcodmlldywgZXZlbnQpICYmICFydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSAmJlxuICAgICAgICAgICAgICAgICh2aWV3LmVkaXRhYmxlIHx8ICEoZXZlbnQudHlwZSBpbiBlZGl0SGFuZGxlcnMpKSlcbiAgICAgICAgICAgICAgICBoYW5kbGVyKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgfSwgcGFzc2l2ZUhhbmRsZXJzW2V2ZW50XSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLy8gT24gU2FmYXJpLCBmb3IgcmVhc29ucyBiZXlvbmQgbXkgdW5kZXJzdGFuZGluZywgYWRkaW5nIGFuIGlucHV0XG4gICAgLy8gZXZlbnQgaGFuZGxlciBtYWtlcyBhbiBpc3N1ZSB3aGVyZSB0aGUgY29tcG9zaXRpb24gdmFuaXNoZXMgd2hlblxuICAgIC8vIHlvdSBwcmVzcyBlbnRlciBnbyBhd2F5LlxuICAgIGlmIChzYWZhcmkpXG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoKSA9PiBudWxsKTtcbiAgICBlbnN1cmVMaXN0ZW5lcnModmlldyk7XG59XG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgb3JpZ2luKSB7XG4gICAgdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICAgIHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvblRpbWUgPSBEYXRlLm5vdygpO1xufVxuZnVuY3Rpb24gZGVzdHJveUlucHV0KHZpZXcpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICBmb3IgKGxldCB0eXBlIGluIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVycylcbiAgICAgICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0pO1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQpO1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCk7XG59XG5mdW5jdGlvbiBlbnN1cmVMaXN0ZW5lcnModmlldykge1xuICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVET01FdmVudHNcIiwgY3VycmVudEhhbmRsZXJzID0+IHtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBjdXJyZW50SGFuZGxlcnMpXG4gICAgICAgICAgICBpZiAoIXZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSlcbiAgICAgICAgICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSA9IGV2ZW50ID0+IHJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpIHtcbiAgICByZXR1cm4gdmlldy5zb21lUHJvcChcImhhbmRsZURPTUV2ZW50c1wiLCBoYW5kbGVycyA9PiB7XG4gICAgICAgIGxldCBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnQudHlwZV07XG4gICAgICAgIHJldHVybiBoYW5kbGVyID8gaGFuZGxlcih2aWV3LCBldmVudCkgfHwgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9WaWV3KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5idWJibGVzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5vZGUgPSBldmVudC50YXJnZXQ7IG5vZGUgIT0gdmlldy5kb207IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlID09IDExIHx8XG4gICAgICAgICAgICAobm9kZS5wbVZpZXdEZXNjICYmIG5vZGUucG1WaWV3RGVzYy5zdG9wRXZlbnQoZXZlbnQpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIXJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpICYmIGhhbmRsZXJzW2V2ZW50LnR5cGVdICYmXG4gICAgICAgICh2aWV3LmVkaXRhYmxlIHx8ICEoZXZlbnQudHlwZSBpbiBlZGl0SGFuZGxlcnMpKSlcbiAgICAgICAgaGFuZGxlcnNbZXZlbnQudHlwZV0odmlldywgZXZlbnQpO1xufVxuZWRpdEhhbmRsZXJzLmtleWRvd24gPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBldmVudC5rZXlDb2RlID09IDE2IHx8IGV2ZW50LnNoaWZ0S2V5O1xuICAgIGlmIChpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAvLyBTdXBwcmVzcyBlbnRlciBrZXkgZXZlbnRzIG9uIENocm9tZSBBbmRyb2lkLCBiZWNhdXNlIHRob3NlIHRlbmRcbiAgICAvLyB0byBiZSBwYXJ0IG9mIGEgY29uZnVzZWQgc2VxdWVuY2Ugb2YgY29tcG9zaXRpb24gZXZlbnRzIGZpcmVkLFxuICAgIC8vIGFuZCBoYW5kbGluZyB0aGVtIGVhZ2VybHkgdGVuZHMgdG8gY29ycnVwdCB0aGUgaW5wdXQuXG4gICAgaWYgKGFuZHJvaWQgJiYgY2hyb21lICYmIGV2ZW50LmtleUNvZGUgPT0gMTMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSAhPSAyMjkpXG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgIC8vIE9uIGlPUywgaWYgd2UgcHJldmVudERlZmF1bHQgZW50ZXIga2V5IHByZXNzZXMsIHRoZSB2aXJ0dWFsXG4gICAgLy8ga2V5Ym9hcmQgZ2V0cyBjb25mdXNlZC4gU28gdGhlIGhhY2sgaGVyZSBpcyB0byBzZXQgYSBmbGFnIHRoYXRcbiAgICAvLyBtYWtlcyB0aGUgRE9NIGNoYW5nZSBjb2RlIHJlY29nbml6ZSB0aGF0IHdoYXQganVzdCBoYXBwZW5zIHNob3VsZFxuICAgIC8vIGJlIHJlcGxhY2VkIGJ5IHdoYXRldmVyIHRoZSBFbnRlciBrZXkgaGFuZGxlcnMgZG8uXG4gICAgaWYgKGlvcyAmJiBldmVudC5rZXlDb2RlID09IDEzICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gbm93O1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXQubGFzdElPU0VudGVyID09IG5vdykge1xuICAgICAgICAgICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSkpO1xuICAgICAgICAgICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGV2ZW50KSkgfHwgY2FwdHVyZUtleURvd24odmlldywgZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJrZXlcIik7XG4gICAgfVxufTtcbmVkaXRIYW5kbGVycy5rZXl1cCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09IDE2KVxuICAgICAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZmFsc2U7XG59O1xuZWRpdEhhbmRsZXJzLmtleXByZXNzID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBpZiAoaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkgfHwgIWV2ZW50LmNoYXJDb2RlIHx8XG4gICAgICAgIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSB8fCBtYWMgJiYgZXZlbnQubWV0YUtleSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5UHJlc3NcIiwgZiA9PiBmKHZpZXcsIGV2ZW50KSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikgfHwgIXNlbC4kZnJvbS5zYW1lUGFyZW50KHNlbC4kdG8pKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSk7XG4gICAgICAgIGlmICghL1tcXHJcXG5dLy50ZXN0KHRleHQpICYmICF2aWV3LnNvbWVQcm9wKFwiaGFuZGxlVGV4dElucHV0XCIsIGYgPT4gZih2aWV3LCBzZWwuJGZyb20ucG9zLCBzZWwuJHRvLnBvcywgdGV4dCkpKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmluc2VydFRleHQodGV4dCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGV2ZW50Q29vcmRzKGV2ZW50KSB7IHJldHVybiB7IGxlZnQ6IGV2ZW50LmNsaWVudFgsIHRvcDogZXZlbnQuY2xpZW50WSB9OyB9XG5mdW5jdGlvbiBpc05lYXIoZXZlbnQsIGNsaWNrKSB7XG4gICAgbGV0IGR4ID0gY2xpY2sueCAtIGV2ZW50LmNsaWVudFgsIGR5ID0gY2xpY2sueSAtIGV2ZW50LmNsaWVudFk7XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5IDwgMTAwO1xufVxuZnVuY3Rpb24gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBwcm9wTmFtZSwgcG9zLCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgaWYgKGluc2lkZSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShpbnNpZGUpO1xuICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoICsgMTsgaSA+IDA7IGktLSkge1xuICAgICAgICBpZiAodmlldy5zb21lUHJvcChwcm9wTmFtZSwgZiA9PiBpID4gJHBvcy5kZXB0aCA/IGYodmlldywgcG9zLCAkcG9zLm5vZGVBZnRlciwgJHBvcy5iZWZvcmUoaSksIGV2ZW50LCB0cnVlKVxuICAgICAgICAgICAgOiBmKHZpZXcsIHBvcywgJHBvcy5ub2RlKGkpLCAkcG9zLmJlZm9yZShpKSwgZXZlbnQsIGZhbHNlKSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKHZpZXcsIHNlbGVjdGlvbiwgb3JpZ2luKSB7XG4gICAgaWYgKCF2aWV3LmZvY3VzZWQpXG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpXG4gICAgICAgIHRyLnNldE1ldGEoXCJwb2ludGVyXCIsIHRydWUpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xufVxuZnVuY3Rpb24gc2VsZWN0Q2xpY2tlZExlYWYodmlldywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShpbnNpZGUpLCBub2RlID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS5pc0F0b20gJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RDbGlja2VkTm9kZSh2aWV3LCBpbnNpZGUpIHtcbiAgICBpZiAoaW5zaWRlID09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLCBzZWxlY3RlZE5vZGUsIHNlbGVjdEF0O1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKVxuICAgICAgICBzZWxlY3RlZE5vZGUgPSBzZWwubm9kZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBpID4gJHBvcy5kZXB0aCA/ICRwb3Mubm9kZUFmdGVyIDogJHBvcy5ub2RlKGkpO1xuICAgICAgICBpZiAoTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgc2VsLiRmcm9tLmRlcHRoID4gMCAmJlxuICAgICAgICAgICAgICAgIGkgPj0gc2VsLiRmcm9tLmRlcHRoICYmICRwb3MuYmVmb3JlKHNlbC4kZnJvbS5kZXB0aCArIDEpID09IHNlbC4kZnJvbS5wb3MpXG4gICAgICAgICAgICAgICAgc2VsZWN0QXQgPSAkcG9zLmJlZm9yZShzZWwuJGZyb20uZGVwdGgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlbGVjdEF0ID0gJHBvcy5iZWZvcmUoaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0QXQgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHNlbGVjdEF0KSwgXCJwb2ludGVyXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVTaW5nbGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQsIHNlbGVjdE5vZGUpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlQ2xpY2tcIiwgZiA9PiBmKHZpZXcsIHBvcywgZXZlbnQpKSB8fFxuICAgICAgICAoc2VsZWN0Tm9kZSA/IHNlbGVjdENsaWNrZWROb2RlKHZpZXcsIGluc2lkZSkgOiBzZWxlY3RDbGlja2VkTGVhZih2aWV3LCBpbnNpZGUpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZURvdWJsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlRG91YmxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVEb3VibGVDbGlja1wiLCBmID0+IGYodmlldywgcG9zLCBldmVudCkpO1xufVxuZnVuY3Rpb24gaGFuZGxlVHJpcGxlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVUcmlwbGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZVRyaXBsZUNsaWNrXCIsIGYgPT4gZih2aWV3LCBwb3MsIGV2ZW50KSkgfHxcbiAgICAgICAgZGVmYXVsdFRyaXBsZUNsaWNrKHZpZXcsIGluc2lkZSwgZXZlbnQpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFRyaXBsZUNsaWNrKHZpZXcsIGluc2lkZSwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgaWYgKGluc2lkZSA9PSAtMSkge1xuICAgICAgICBpZiAoZG9jLmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIDAsIGRvYy5jb250ZW50LnNpemUpLCBcInBvaW50ZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBpID4gJHBvcy5kZXB0aCA/ICRwb3Mubm9kZUFmdGVyIDogJHBvcy5ub2RlKGkpO1xuICAgICAgICBsZXQgbm9kZVBvcyA9ICRwb3MuYmVmb3JlKGkpO1xuICAgICAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgbm9kZVBvcyArIDEsIG5vZGVQb3MgKyAxICsgbm9kZS5jb250ZW50LnNpemUpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIGVsc2UgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIE5vZGVTZWxlY3Rpb24uY3JlYXRlKGRvYywgbm9kZVBvcyksIFwicG9pbnRlclwiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcmNlRE9NRmx1c2godmlldykge1xuICAgIHJldHVybiBlbmRDb21wb3NpdGlvbih2aWV3KTtcbn1cbmNvbnN0IHNlbGVjdE5vZGVNb2RpZmllciA9IG1hYyA/IFwibWV0YUtleVwiIDogXCJjdHJsS2V5XCI7XG5oYW5kbGVycy5tb3VzZWRvd24gPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBldmVudC5zaGlmdEtleTtcbiAgICBsZXQgZmx1c2hlZCA9IGZvcmNlRE9NRmx1c2godmlldyk7XG4gICAgbGV0IG5vdyA9IERhdGUubm93KCksIHR5cGUgPSBcInNpbmdsZUNsaWNrXCI7XG4gICAgaWYgKG5vdyAtIHZpZXcuaW5wdXQubGFzdENsaWNrLnRpbWUgPCA1MDAgJiYgaXNOZWFyKGV2ZW50LCB2aWV3LmlucHV0Lmxhc3RDbGljaykgJiYgIWV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl0pIHtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXQubGFzdENsaWNrLnR5cGUgPT0gXCJzaW5nbGVDbGlja1wiKVxuICAgICAgICAgICAgdHlwZSA9IFwiZG91YmxlQ2xpY2tcIjtcbiAgICAgICAgZWxzZSBpZiAodmlldy5pbnB1dC5sYXN0Q2xpY2sudHlwZSA9PSBcImRvdWJsZUNsaWNrXCIpXG4gICAgICAgICAgICB0eXBlID0gXCJ0cmlwbGVDbGlja1wiO1xuICAgIH1cbiAgICB2aWV3LmlucHV0Lmxhc3RDbGljayA9IHsgdGltZTogbm93LCB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZLCB0eXBlIH07XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBpZiAoIXBvcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlID09IFwic2luZ2xlQ2xpY2tcIikge1xuICAgICAgICBpZiAodmlldy5pbnB1dC5tb3VzZURvd24pXG4gICAgICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93bi5kb25lKCk7XG4gICAgICAgIHZpZXcuaW5wdXQubW91c2VEb3duID0gbmV3IE1vdXNlRG93bih2aWV3LCBwb3MsIGV2ZW50LCAhIWZsdXNoZWQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgodHlwZSA9PSBcImRvdWJsZUNsaWNrXCIgPyBoYW5kbGVEb3VibGVDbGljayA6IGhhbmRsZVRyaXBsZUNsaWNrKSh2aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG4gICAgfVxufTtcbmNsYXNzIE1vdXNlRG93biB7XG4gICAgY29uc3RydWN0b3IodmlldywgcG9zLCBldmVudCwgZmx1c2hlZCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLmZsdXNoZWQgPSBmbHVzaGVkO1xuICAgICAgICB0aGlzLmRlbGF5ZWRTZWxlY3Rpb25TeW5jID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWlnaHREcmFnID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFydERvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgICAgICB0aGlzLnNlbGVjdE5vZGUgPSAhIWV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl07XG4gICAgICAgIHRoaXMuYWxsb3dEZWZhdWx0ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIGxldCB0YXJnZXROb2RlLCB0YXJnZXRQb3M7XG4gICAgICAgIGlmIChwb3MuaW5zaWRlID4gLTEpIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSB2aWV3LnN0YXRlLmRvYy5ub2RlQXQocG9zLmluc2lkZSk7XG4gICAgICAgICAgICB0YXJnZXRQb3MgPSBwb3MuaW5zaWRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcy5wb3MpO1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9ICRwb3MucGFyZW50O1xuICAgICAgICAgICAgdGFyZ2V0UG9zID0gJHBvcy5kZXB0aCA/ICRwb3MuYmVmb3JlKCkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGZsdXNoZWQgPyBudWxsIDogZXZlbnQudGFyZ2V0O1xuICAgICAgICBjb25zdCB0YXJnZXREZXNjID0gdGFyZ2V0ID8gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKHRhcmdldCwgdHJ1ZSkgOiBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldERlc2MgPyB0YXJnZXREZXNjLmRvbSA6IG51bGw7XG4gICAgICAgIGxldCB7IHNlbGVjdGlvbiB9ID0gdmlldy5zdGF0ZTtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PSAwICYmXG4gICAgICAgICAgICB0YXJnZXROb2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUgJiYgdGFyZ2V0Tm9kZS50eXBlLnNwZWMuc2VsZWN0YWJsZSAhPT0gZmFsc2UgfHxcbiAgICAgICAgICAgIHNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmZyb20gPD0gdGFyZ2V0UG9zICYmIHNlbGVjdGlvbi50byA+IHRhcmdldFBvcylcbiAgICAgICAgICAgIHRoaXMubWlnaHREcmFnID0ge1xuICAgICAgICAgICAgICAgIG5vZGU6IHRhcmdldE5vZGUsXG4gICAgICAgICAgICAgICAgcG9zOiB0YXJnZXRQb3MsXG4gICAgICAgICAgICAgICAgYWRkQXR0cjogISEodGhpcy50YXJnZXQgJiYgIXRoaXMudGFyZ2V0LmRyYWdnYWJsZSksXG4gICAgICAgICAgICAgICAgc2V0VW5lZGl0YWJsZTogISEodGhpcy50YXJnZXQgJiYgZ2Vja28gJiYgIXRoaXMudGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCAmJiB0aGlzLm1pZ2h0RHJhZyAmJiAodGhpcy5taWdodERyYWcuYWRkQXR0ciB8fCB0aGlzLm1pZ2h0RHJhZy5zZXRVbmVkaXRhYmxlKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyKVxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy5pbnB1dC5tb3VzZURvd24gPT0gdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnNldEF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiLCBcImZhbHNlXCIpO1xuICAgICAgICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwID0gdGhpcy51cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlID0gdGhpcy5tb3ZlLmJpbmQodGhpcykpO1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xuICAgIH1cbiAgICBkb25lKCkge1xuICAgICAgICB0aGlzLnZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwKTtcbiAgICAgICAgdGhpcy52aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUpO1xuICAgICAgICBpZiAodGhpcy5taWdodERyYWcgJiYgdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cilcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIik7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWxheWVkU2VsZWN0aW9uU3luYylcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2VsZWN0aW9uVG9ET00odGhpcy52aWV3KSk7XG4gICAgICAgIHRoaXMudmlldy5pbnB1dC5tb3VzZURvd24gPSBudWxsO1xuICAgIH1cbiAgICB1cChldmVudCkge1xuICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5kb2MgIT0gdGhpcy5zdGFydERvYylcbiAgICAgICAgICAgIHBvcyA9IHRoaXMudmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgICAgICB0aGlzLnVwZGF0ZUFsbG93RGVmYXVsdChldmVudCk7XG4gICAgICAgIGlmICh0aGlzLmFsbG93RGVmYXVsdCB8fCAhcG9zKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFuZGxlU2luZ2xlQ2xpY2sodGhpcy52aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCwgdGhpcy5zZWxlY3ROb2RlKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5idXR0b24gPT0gMCAmJlxuICAgICAgICAgICAgKHRoaXMuZmx1c2hlZCB8fFxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBpZ25vcmVzIGNsaWNrcyBvbiBkcmFnZ2FibGUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAoc2FmYXJpICYmIHRoaXMubWlnaHREcmFnICYmICF0aGlzLm1pZ2h0RHJhZy5ub2RlLmlzQXRvbSkgfHxcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBzb21ldGltZXMgdHJlYXQgYSBub2RlIHNlbGVjdGlvbiBhcyBhXG4gICAgICAgICAgICAgICAgLy8gY3Vyc29yLCBidXQgc3RpbGwgcmVwb3J0IHRoYXQgdGhlIG5vZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGFza2VkIHRocm91Z2ggZ2V0U2VsZWN0aW9uLiBZb3UnbGwgdGhlbiBnZXQgYVxuICAgICAgICAgICAgICAgIC8vIHNpdHVhdGlvbiB3aGVyZSBjbGlja2luZyBhdCB0aGUgcG9pbnQgd2hlcmUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIChoaWRkZW4pIGN1cnNvciBpcyBkb2Vzbid0IGNoYW5nZSB0aGUgc2VsZWN0aW9uLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB0aHVzIGRvZXNuJ3QgZ2V0IGEgcmVhY3Rpb24gZnJvbSBQcm9zZU1pcnJvci4gVGhpc1xuICAgICAgICAgICAgICAgIC8vIHdvcmtzIGFyb3VuZCB0aGF0LlxuICAgICAgICAgICAgICAgIChjaHJvbWUgJiYgIXRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihNYXRoLmFicyhwb3MucG9zIC0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tKSwgTWF0aC5hYnMocG9zLnBvcyAtIHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24udG8pKSA8PSAyKSkpIHtcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih0aGlzLnZpZXcsIFNlbGVjdGlvbi5uZWFyKHRoaXMudmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MucG9zKSksIFwicG9pbnRlclwiKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZShldmVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUFsbG93RGVmYXVsdChldmVudCk7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbnMgPT0gMClcbiAgICAgICAgICAgIHRoaXMuZG9uZSgpO1xuICAgIH1cbiAgICB1cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93RGVmYXVsdCAmJiAoTWF0aC5hYnModGhpcy5ldmVudC54IC0gZXZlbnQuY2xpZW50WCkgPiA0IHx8XG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmV2ZW50LnkgLSBldmVudC5jbGllbnRZKSA+IDQpKVxuICAgICAgICAgICAgdGhpcy5hbGxvd0RlZmF1bHQgPSB0cnVlO1xuICAgIH1cbn1cbmhhbmRsZXJzLnRvdWNoc3RhcnQgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RUb3VjaCA9IERhdGUubm93KCk7XG4gICAgZm9yY2VET01GbHVzaCh2aWV3KTtcbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xufTtcbmhhbmRsZXJzLnRvdWNobW92ZSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXQubGFzdFRvdWNoID0gRGF0ZS5ub3coKTtcbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xufTtcbmhhbmRsZXJzLmNvbnRleHRtZW51ID0gdmlldyA9PiBmb3JjZURPTUZsdXNoKHZpZXcpO1xuZnVuY3Rpb24gaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gU2VlIGh0dHBzOi8vd3d3LnN0dW0uZGUvMjAxNi8wNi8yNC9oYW5kbGluZy1pbWUtZXZlbnRzLWluLWphdmFzY3JpcHQvLlxuICAgIC8vIE9uIEphcGFuZXNlIGlucHV0IG1ldGhvZCBlZGl0b3JzIChJTUVzKSwgdGhlIEVudGVyIGtleSBpcyB1c2VkIHRvIGNvbmZpcm0gY2hhcmFjdGVyXG4gICAgLy8gc2VsZWN0aW9uLiBPbiBTYWZhcmksIHdoZW4gRW50ZXIgaXMgcHJlc3NlZCwgY29tcG9zaXRpb25lbmQgYW5kIGtleWRvd24gZXZlbnRzIGFyZVxuICAgIC8vIGVtaXR0ZWQuIFRoZSBrZXlkb3duIGV2ZW50IHRyaWdnZXJzIG5ld2xpbmUgaW5zZXJ0aW9uLCB3aGljaCB3ZSBkb24ndCB3YW50LlxuICAgIC8vIFRoaXMgbWV0aG9kIHJldHVybnMgdHJ1ZSBpZiB0aGUga2V5ZG93biBldmVudCBzaG91bGQgYmUgaWdub3JlZC5cbiAgICAvLyBXZSBvbmx5IGlnbm9yZSBpdCBvbmNlLCBhcyBwcmVzc2luZyBFbnRlciBhIHNlY29uZCB0aW1lICpzaG91bGQqIGluc2VydCBhIG5ld2xpbmUuXG4gICAgLy8gRnVydGhlcm1vcmUsIHRoZSBrZXlkb3duIGV2ZW50IHRpbWVzdGFtcCBtdXN0IGJlIGNsb3NlIHRvIHRoZSBjb21wb3NpdGlvbkVuZGVkQXQgdGltZXN0YW1wLlxuICAgIC8vIFRoaXMgZ3VhcmRzIGFnYWluc3QgdGhlIGNhc2Ugd2hlcmUgY29tcG9zaXRpb25lbmQgaXMgdHJpZ2dlcmVkIHdpdGhvdXQgdGhlIGtleWJvYXJkXG4gICAgLy8gKGUuZy4gY2hhcmFjdGVyIGNvbmZpcm1hdGlvbiBtYXkgYmUgZG9uZSB3aXRoIHRoZSBtb3VzZSksIGFuZCBrZXlkb3duIGlzIHRyaWdnZXJlZFxuICAgIC8vIGFmdGVyd2FyZHMtIHdlIHdvdWxkbid0IHdhbnQgdG8gaWdub3JlIHRoZSBrZXlkb3duIGV2ZW50IGluIHRoaXMgY2FzZS5cbiAgICBpZiAoc2FmYXJpICYmIE1hdGguYWJzKGV2ZW50LnRpbWVTdGFtcCAtIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0KSA8IDUwMCkge1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCA9IC0yZTg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBEcm9wIGFjdGl2ZSBjb21wb3NpdGlvbiBhZnRlciA1IHNlY29uZHMgb2YgaW5hY3Rpdml0eSBvbiBBbmRyb2lkXG5jb25zdCB0aW1lb3V0Q29tcG9zaXRpb24gPSBhbmRyb2lkID8gNTAwMCA6IC0xO1xuZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9uc3RhcnQgPSBlZGl0SGFuZGxlcnMuY29tcG9zaXRpb251cGRhdGUgPSB2aWV3ID0+IHtcbiAgICBpZiAoIXZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2goKTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsICRwb3MgPSBzdGF0ZS5zZWxlY3Rpb24uJGZyb207XG4gICAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiZcbiAgICAgICAgICAgIChzdGF0ZS5zdG9yZWRNYXJrcyB8fFxuICAgICAgICAgICAgICAgICghJHBvcy50ZXh0T2Zmc2V0ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICRwb3Mubm9kZUJlZm9yZS5tYXJrcy5zb21lKG0gPT4gbS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSkpKSkge1xuICAgICAgICAgICAgLy8gTmVlZCB0byB3cmFwIHRoZSBjdXJzb3IgaW4gbWFyayBub2RlcyBkaWZmZXJlbnQgZnJvbSB0aGUgb25lcyBpbiB0aGUgRE9NIGNvbnRleHRcbiAgICAgICAgICAgIHZpZXcubWFya0N1cnNvciA9IHZpZXcuc3RhdGUuc3RvcmVkTWFya3MgfHwgJHBvcy5tYXJrcygpO1xuICAgICAgICAgICAgZW5kQ29tcG9zaXRpb24odmlldywgdHJ1ZSk7XG4gICAgICAgICAgICB2aWV3Lm1hcmtDdXJzb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kQ29tcG9zaXRpb24odmlldyk7XG4gICAgICAgICAgICAvLyBJbiBmaXJlZm94LCBpZiB0aGUgY3Vyc29yIGlzIGFmdGVyIGJ1dCBvdXRzaWRlIGEgbWFya2VkIG5vZGUsXG4gICAgICAgICAgICAvLyB0aGUgaW5zZXJ0ZWQgdGV4dCB3b24ndCBpbmhlcml0IHRoZSBtYXJrcy4gU28gdGhpcyBtb3ZlcyBpdFxuICAgICAgICAgICAgLy8gaW5zaWRlIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgIGlmIChnZWNrbyAmJiBzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgJHBvcy5wYXJlbnRPZmZzZXQgJiYgISRwb3MudGV4dE9mZnNldCAmJiAkcG9zLm5vZGVCZWZvcmUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0OyBub2RlICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgIT0gMDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IG9mZnNldCA8IDAgPyBub2RlLmxhc3RDaGlsZCA6IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRvbVNlbGVjdGlvbigpLmNvbGxhcHNlKGJlZm9yZSwgYmVmb3JlLm5vZGVWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBzY2hlZHVsZUNvbXBvc2VFbmQodmlldywgdGltZW91dENvbXBvc2l0aW9uKTtcbn07XG5lZGl0SGFuZGxlcnMuY29tcG9zaXRpb25lbmQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSBldmVudC50aW1lU3RhbXA7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyA9IHZpZXcuZG9tT2JzZXJ2ZXIucGVuZGluZ1JlY29yZHMoKS5sZW5ndGggPyB2aWV3LmlucHV0LmNvbXBvc2l0aW9uSUQgOiAwO1xuICAgICAgICBpZiAodmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzKVxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB2aWV3LmRvbU9ic2VydmVyLmZsdXNoKCkpO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uSUQrKztcbiAgICAgICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIDIwKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIGRlbGF5KSB7XG4gICAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCk7XG4gICAgaWYgKGRlbGF5ID4gLTEpXG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gZW5kQ29tcG9zaXRpb24odmlldyksIGRlbGF5KTtcbn1cbmZ1bmN0aW9uIGNsZWFyQ29tcG9zaXRpb24odmlldykge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCA9IHRpbWVzdGFtcEZyb21DdXN0b21FdmVudCgpO1xuICAgIH1cbiAgICB3aGlsZSAodmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLmxlbmd0aCA+IDApXG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2Rlcy5wb3AoKS5tYXJrUGFyZW50c0RpcnR5KCk7XG59XG5mdW5jdGlvbiB0aW1lc3RhbXBGcm9tQ3VzdG9tRXZlbnQoKSB7XG4gICAgbGV0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBldmVudC5pbml0RXZlbnQoXCJldmVudFwiLCB0cnVlLCB0cnVlKTtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wO1xufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBlbmRDb21wb3NpdGlvbih2aWV3LCBmb3JjZVVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKGFuZHJvaWQgJiYgdmlldy5kb21PYnNlcnZlci5mbHVzaGluZ1Nvb24gPj0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgIGNsZWFyQ29tcG9zaXRpb24odmlldyk7XG4gICAgaWYgKGZvcmNlVXBkYXRlIHx8IHZpZXcuZG9jVmlldyAmJiB2aWV3LmRvY1ZpZXcuZGlydHkpIHtcbiAgICAgICAgbGV0IHNlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldyk7XG4gICAgICAgIGlmIChzZWwgJiYgIXNlbC5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHZpZXcuc3RhdGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2FwdHVyZUNvcHkodmlldywgZG9tKSB7XG4gICAgLy8gVGhlIGV4dHJhIHdyYXBwZXIgaXMgc29tZWhvdyBuZWNlc3Nhcnkgb24gSUUvRWRnZSB0byBwcmV2ZW50IHRoZVxuICAgIC8vIGNvbnRlbnQgZnJvbSBiZWluZyBtYW5nbGVkIHdoZW4gaXQgaXMgcHV0IG9udG8gdGhlIGNsaXBib2FyZFxuICAgIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB3cmFwID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICB3cmFwLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgd3JhcC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKCksIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoZG9tKTtcbiAgICAvLyBEb25lIGJlY2F1c2UgSUUgd2lsbCBmaXJlIGEgc2VsZWN0aW9uY2hhbmdlIG1vdmluZyB0aGUgc2VsZWN0aW9uXG4gICAgLy8gdG8gaXRzIHN0YXJ0IHdoZW4gcmVtb3ZlQWxsUmFuZ2VzIGlzIGNhbGxlZCBhbmQgdGhlIGVkaXRvciBzdGlsbFxuICAgIC8vIGhhcyBmb2N1cyAod2hpY2ggd2lsbCBtZXNzIHVwIHRoZSBlZGl0b3IncyBzZWxlY3Rpb24gc3RhdGUpLlxuICAgIHZpZXcuZG9tLmJsdXIoKTtcbiAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHdyYXAucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIHdyYXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3cmFwKTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH0sIDUwKTtcbn1cbi8vIFRoaXMgaXMgdmVyeSBjcnVkZSwgYnV0IHVuZm9ydHVuYXRlbHkgYm90aCB0aGVzZSBicm93c2VycyBfcHJldGVuZF9cbi8vIHRoYXQgdGhleSBoYXZlIGEgY2xpcGJvYXJkIEFQSVx1MjAxNGFsbCB0aGUgb2JqZWN0cyBhbmQgbWV0aG9kcyBhcmVcbi8vIHRoZXJlLCB0aGV5IGp1c3QgZG9uJ3Qgd29yaywgYW5kIHRoZXkgYXJlIGhhcmQgdG8gdGVzdC5cbmNvbnN0IGJyb2tlbkNsaXBib2FyZEFQSSA9IChpZSAmJiBpZV92ZXJzaW9uIDwgMTUpIHx8XG4gICAgKGlvcyAmJiB3ZWJraXRfdmVyc2lvbiA8IDYwNCk7XG5oYW5kbGVycy5jb3B5ID0gZWRpdEhhbmRsZXJzLmN1dCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLCBjdXQgPSBldmVudC50eXBlID09IFwiY3V0XCI7XG4gICAgaWYgKHNlbC5lbXB0eSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIElFIGFuZCBFZGdlJ3MgY2xpcGJvYXJkIGludGVyZmFjZSBpcyBjb21wbGV0ZWx5IGJyb2tlblxuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgbGV0IHNsaWNlID0gc2VsLmNvbnRlbnQoKSwgeyBkb20sIHRleHQgfSA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9odG1sXCIsIGRvbS5pbm5lckhUTUwpO1xuICAgICAgICBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZUNvcHkodmlldywgZG9tKTtcbiAgICB9XG4gICAgaWYgKGN1dClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpLnNjcm9sbEludG9WaWV3KCkuc2V0TWV0YShcInVpRXZlbnRcIiwgXCJjdXRcIikpO1xufTtcbmZ1bmN0aW9uIHNsaWNlU2luZ2xlTm9kZShzbGljZSkge1xuICAgIHJldHVybiBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDEgPyBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQgOiBudWxsO1xufVxuZnVuY3Rpb24gY2FwdHVyZVBhc3RlKHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCF2aWV3LmRvbS5wYXJlbnROb2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHBsYWluVGV4dCA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlO1xuICAgIGxldCB0YXJnZXQgPSB2aWV3LmRvbS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGxhaW5UZXh0ID8gXCJ0ZXh0YXJlYVwiIDogXCJkaXZcIikpO1xuICAgIGlmICghcGxhaW5UZXh0KVxuICAgICAgICB0YXJnZXQuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCI7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIGxldCBwbGFpbiA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgJiYgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSAhPSA0NTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICBpZiAodGFyZ2V0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuICAgICAgICBpZiAocGxhaW5UZXh0KVxuICAgICAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudmFsdWUsIG51bGwsIHBsYWluLCBldmVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnRleHRDb250ZW50LCB0YXJnZXQuaW5uZXJIVE1MLCBwbGFpbiwgZXZlbnQpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGRvUGFzdGUodmlldywgdGV4dCwgaHRtbCwgcHJlZmVyUGxhaW4sIGV2ZW50KSB7XG4gICAgbGV0IHNsaWNlID0gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIHRleHQsIGh0bWwsIHByZWZlclBsYWluLCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbSk7XG4gICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVQYXN0ZVwiLCBmID0+IGYodmlldywgZXZlbnQsIHNsaWNlIHx8IFNsaWNlLmVtcHR5KSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghc2xpY2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2luZ2xlTm9kZSA9IHNsaWNlU2luZ2xlTm9kZShzbGljZSk7XG4gICAgbGV0IHRyID0gc2luZ2xlTm9kZVxuICAgICAgICA/IHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbldpdGgoc2luZ2xlTm9kZSwgcHJlZmVyUGxhaW4pXG4gICAgICAgIDogdmlldy5zdGF0ZS50ci5yZXBsYWNlU2VsZWN0aW9uKHNsaWNlKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkuc2V0TWV0YShcInBhc3RlXCIsIHRydWUpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwicGFzdGVcIikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VGV4dChjbGlwYm9hcmREYXRhKSB7XG4gICAgbGV0IHRleHQgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpIHx8IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgaWYgKHRleHQpXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIGxldCB1cmlzID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dC91cmktbGlzdFwiKTtcbiAgICByZXR1cm4gdXJpcyA/IHVyaXMucmVwbGFjZSgvXFxyP1xcbi9nLCBcIiBcIikgOiBcIlwiO1xufVxuZWRpdEhhbmRsZXJzLnBhc3RlID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICAvLyBIYW5kbGluZyBwYXN0ZSBmcm9tIEphdmFTY3JpcHQgZHVyaW5nIGNvbXBvc2l0aW9uIGlzIHZlcnkgcG9vcmx5XG4gICAgLy8gaGFuZGxlZCBieSBicm93c2Vycywgc28gYXMgYSBkb2RneSBidXQgcHJlZmVyYWJsZSBrbHVkZ2UsIHdlIGp1c3RcbiAgICAvLyBsZXQgdGhlIGJyb3dzZXIgZG8gaXRzIG5hdGl2ZSB0aGluZyB0aGVyZSwgZXhjZXB0IG9uIEFuZHJvaWQsXG4gICAgLy8gd2hlcmUgdGhlIGVkaXRvciBpcyBhbG1vc3QgYWx3YXlzIGNvbXBvc2luZy5cbiAgICBpZiAodmlldy5jb21wb3NpbmcgJiYgIWFuZHJvaWQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGxldCBwbGFpbiA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgJiYgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSAhPSA0NTtcbiAgICBpZiAoZGF0YSAmJiBkb1Bhc3RlKHZpZXcsIGdldFRleHQoZGF0YSksIGRhdGEuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgcGxhaW4sIGV2ZW50KSlcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBlbHNlXG4gICAgICAgIGNhcHR1cmVQYXN0ZSh2aWV3LCBldmVudCk7XG59O1xuY2xhc3MgRHJhZ2dpbmcge1xuICAgIGNvbnN0cnVjdG9yKHNsaWNlLCBtb3ZlLCBub2RlKSB7XG4gICAgICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgICAgICAgdGhpcy5tb3ZlID0gbW92ZTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG59XG5jb25zdCBkcmFnQ29weU1vZGlmaWVyID0gbWFjID8gXCJhbHRLZXlcIiA6IFwiY3RybEtleVwiO1xuaGFuZGxlcnMuZHJhZ3N0YXJ0ID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBsZXQgbW91c2VEb3duID0gdmlldy5pbnB1dC5tb3VzZURvd247XG4gICAgaWYgKG1vdXNlRG93bilcbiAgICAgICAgbW91c2VEb3duLmRvbmUoKTtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcG9zID0gc2VsLmVtcHR5ID8gbnVsbCA6IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBsZXQgbm9kZTtcbiAgICBpZiAocG9zICYmIHBvcy5wb3MgPj0gc2VsLmZyb20gJiYgcG9zLnBvcyA8PSAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiA/IHNlbC50byAtIDEgOiBzZWwudG8pKSA7XG4gICAgZWxzZSBpZiAobW91c2VEb3duICYmIG1vdXNlRG93bi5taWdodERyYWcpIHtcbiAgICAgICAgbm9kZSA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBtb3VzZURvd24ubWlnaHREcmFnLnBvcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhldmVudC50YXJnZXQsIHRydWUpO1xuICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSAmJiBkZXNjICE9IHZpZXcuZG9jVmlldylcbiAgICAgICAgICAgIG5vZGUgPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgZGVzYy5wb3NCZWZvcmUpO1xuICAgIH1cbiAgICBsZXQgc2xpY2UgPSAobm9kZSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbikuY29udGVudCgpLCB7IGRvbSwgdGV4dCB9ID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIHNsaWNlKTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoYnJva2VuQ2xpcGJvYXJkQVBJID8gXCJUZXh0XCIgOiBcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yL2lzc3Vlcy8xMTU2XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcImNvcHlNb3ZlXCI7XG4gICAgaWYgKCFicm9rZW5DbGlwYm9hcmRBUEkpXG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB2aWV3LmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKHNsaWNlLCAhZXZlbnRbZHJhZ0NvcHlNb2RpZmllcl0sIG5vZGUpO1xufTtcbmhhbmRsZXJzLmRyYWdlbmQgPSB2aWV3ID0+IHtcbiAgICBsZXQgZHJhZ2dpbmcgPSB2aWV3LmRyYWdnaW5nO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXcuZHJhZ2dpbmcgPT0gZHJhZ2dpbmcpXG4gICAgICAgICAgICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcbiAgICB9LCA1MCk7XG59O1xuZWRpdEhhbmRsZXJzLmRyYWdvdmVyID0gZWRpdEhhbmRsZXJzLmRyYWdlbnRlciA9IChfLCBlKSA9PiBlLnByZXZlbnREZWZhdWx0KCk7XG5lZGl0SGFuZGxlcnMuZHJvcCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IGRyYWdnaW5nID0gdmlldy5kcmFnZ2luZztcbiAgICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBldmVudFBvcyA9IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBpZiAoIWV2ZW50UG9zKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0ICRtb3VzZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZXZlbnRQb3MucG9zKTtcbiAgICBsZXQgc2xpY2UgPSBkcmFnZ2luZyAmJiBkcmFnZ2luZy5zbGljZTtcbiAgICBpZiAoc2xpY2UpIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3KTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCBnZXRUZXh0KGV2ZW50LmRhdGFUcmFuc2ZlciksIGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgZmFsc2UsICRtb3VzZSk7XG4gICAgfVxuICAgIGxldCBtb3ZlID0gISEoZHJhZ2dpbmcgJiYgIWV2ZW50W2RyYWdDb3B5TW9kaWZpZXJdKTtcbiAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZURyb3BcIiwgZiA9PiBmKHZpZXcsIGV2ZW50LCBzbGljZSB8fCBTbGljZS5lbXB0eSwgbW92ZSkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzbGljZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IGluc2VydFBvcyA9IHNsaWNlID8gZHJvcFBvaW50KHZpZXcuc3RhdGUuZG9jLCAkbW91c2UucG9zLCBzbGljZSkgOiAkbW91c2UucG9zO1xuICAgIGlmIChpbnNlcnRQb3MgPT0gbnVsbClcbiAgICAgICAgaW5zZXJ0UG9zID0gJG1vdXNlLnBvcztcbiAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgIGlmIChtb3ZlKSB7XG4gICAgICAgIGxldCB7IG5vZGUgfSA9IGRyYWdnaW5nO1xuICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgIG5vZGUucmVwbGFjZSh0cik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBsZXQgcG9zID0gdHIubWFwcGluZy5tYXAoaW5zZXJ0UG9zKTtcbiAgICBsZXQgaXNOb2RlID0gc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uub3BlbkVuZCA9PSAwICYmIHNsaWNlLmNvbnRlbnQuY2hpbGRDb3VudCA9PSAxO1xuICAgIGxldCBiZWZvcmVJbnNlcnQgPSB0ci5kb2M7XG4gICAgaWYgKGlzTm9kZSlcbiAgICAgICAgdHIucmVwbGFjZVJhbmdlV2l0aChwb3MsIHBvcywgc2xpY2UuY29udGVudC5maXJzdENoaWxkKTtcbiAgICBlbHNlXG4gICAgICAgIHRyLnJlcGxhY2VSYW5nZShwb3MsIHBvcywgc2xpY2UpO1xuICAgIGlmICh0ci5kb2MuZXEoYmVmb3JlSW5zZXJ0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCAkcG9zID0gdHIuZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoaXNOb2RlICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCkgJiZcbiAgICAgICAgJHBvcy5ub2RlQWZ0ZXIgJiYgJHBvcy5ub2RlQWZ0ZXIuc2FtZU1hcmt1cChzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihuZXcgTm9kZVNlbGVjdGlvbigkcG9zKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgZW5kID0gdHIubWFwcGluZy5tYXAoaW5zZXJ0UG9zKTtcbiAgICAgICAgdHIubWFwcGluZy5tYXBzW3RyLm1hcHBpbmcubWFwcy5sZW5ndGggLSAxXS5mb3JFYWNoKChfZnJvbSwgX3RvLCBfbmV3RnJvbSwgbmV3VG8pID0+IGVuZCA9IG5ld1RvKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbkJldHdlZW4odmlldywgJHBvcywgdHIuZG9jLnJlc29sdmUoZW5kKSkpO1xuICAgIH1cbiAgICB2aWV3LmZvY3VzKCk7XG4gICAgdmlldy5kaXNwYXRjaCh0ci5zZXRNZXRhKFwidWlFdmVudFwiLCBcImRyb3BcIikpO1xufTtcbmhhbmRsZXJzLmZvY3VzID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dC5sYXN0Rm9jdXMgPSBEYXRlLm5vdygpO1xuICAgIGlmICghdmlldy5mb2N1c2VkKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3ItZm9jdXNlZFwiKTtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB2aWV3LmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmRvY1ZpZXcgJiYgdmlldy5oYXNGb2N1cygpICYmICF2aWV3LmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uZXEodmlldy5kb21TZWxlY3Rpb25SYW5nZSgpKSlcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgfSwgMjApO1xuICAgIH1cbn07XG5oYW5kbGVycy5ibHVyID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBpZiAodmlldy5mb2N1c2VkKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItZm9jdXNlZFwiKTtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICBpZiAoZXZlbnQucmVsYXRlZFRhcmdldCAmJiB2aWV3LmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgICB2aWV3LmZvY3VzZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuaGFuZGxlcnMuYmVmb3JlaW5wdXQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIC8vIFdlIHNob3VsZCBwcm9iYWJseSBkbyBtb3JlIHdpdGggYmVmb3JlaW5wdXQgZXZlbnRzLCBidXQgc3VwcG9ydFxuICAgIC8vIGlzIHNvIHNwb3R0eSB0aGF0IEknbSBzdGlsbCB3YWl0aW5nIHRvIHNlZSB3aGVyZSB0aGV5IGFyZSBnb2luZy5cbiAgICAvLyBWZXJ5IHNwZWNpZmljIGhhY2sgdG8gZGVhbCB3aXRoIGJhY2tzcGFjZSBzb21ldGltZXMgZmFpbGluZyBvblxuICAgIC8vIENocm9tZSBBbmRyb2lkIHdoZW4gYWZ0ZXIgYW4gdW5lZGl0YWJsZSBub2RlLlxuICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCAmJiBldmVudC5pbnB1dFR5cGUgPT0gXCJkZWxldGVDb250ZW50QmFja3dhcmRcIikge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZsdXNoU29vbigpO1xuICAgICAgICBsZXQgeyBkb21DaGFuZ2VDb3VudCB9ID0gdmlldy5pbnB1dDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dC5kb21DaGFuZ2VDb3VudCAhPSBkb21DaGFuZ2VDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEV2ZW50IGFscmVhZHkgaGFkIHNvbWUgZWZmZWN0XG4gICAgICAgICAgICAvLyBUaGlzIGJ1ZyB0ZW5kcyB0byBjbG9zZSB0aGUgdmlydHVhbCBrZXlib2FyZCwgc28gd2UgcmVmb2N1c1xuICAgICAgICAgICAgdmlldy5kb20uYmx1cigpO1xuICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCg4LCBcIkJhY2tzcGFjZVwiKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB7ICRjdXJzb3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgLy8gQ3J1ZGUgYXBwcm94aW1hdGlvbiBvZiBiYWNrc3BhY2UgYmVoYXZpb3Igd2hlbiBubyBjb21tYW5kIGhhbmRsZWQgaXRcbiAgICAgICAgICAgIGlmICgkY3Vyc29yICYmICRjdXJzb3IucG9zID4gMClcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuZGVsZXRlKCRjdXJzb3IucG9zIC0gMSwgJGN1cnNvci5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9LCA1MCk7XG4gICAgfVxufTtcbi8vIE1ha2Ugc3VyZSBhbGwgaGFuZGxlcnMgZ2V0IHJlZ2lzdGVyZWRcbmZvciAobGV0IHByb3AgaW4gZWRpdEhhbmRsZXJzKVxuICAgIGhhbmRsZXJzW3Byb3BdID0gZWRpdEhhbmRsZXJzW3Byb3BdO1xuXG5mdW5jdGlvbiBjb21wYXJlT2JqcyhhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChsZXQgcCBpbiBhKVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBwIGluIGIpXG4gICAgICAgIGlmICghKHAgaW4gYSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jbGFzcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih0b0RPTSwgc3BlYykge1xuICAgICAgICB0aGlzLnRvRE9NID0gdG9ET007XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWMgfHwgbm9TcGVjO1xuICAgICAgICB0aGlzLnNpZGUgPSB0aGlzLnNwZWMuc2lkZSB8fCAwO1xuICAgIH1cbiAgICBtYXAobWFwcGluZywgc3Bhbiwgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgbGV0IHsgcG9zLCBkZWxldGVkIH0gPSBtYXBwaW5nLm1hcFJlc3VsdChzcGFuLmZyb20gKyBvbGRPZmZzZXQsIHRoaXMuc2lkZSA8IDAgPyAtMSA6IDEpO1xuICAgICAgICByZXR1cm4gZGVsZXRlZCA/IG51bGwgOiBuZXcgRGVjb3JhdGlvbihwb3MgLSBvZmZzZXQsIHBvcyAtIG9mZnNldCwgdGhpcyk7XG4gICAgfVxuICAgIHZhbGlkKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBXaWRnZXRUeXBlICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuc3BlYy5rZXkgJiYgdGhpcy5zcGVjLmtleSA9PSBvdGhlci5zcGVjLmtleSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvRE9NID09IG90aGVyLnRvRE9NICYmIGNvbXBhcmVPYmpzKHRoaXMuc3BlYywgb3RoZXIuc3BlYykpKTtcbiAgICB9XG4gICAgZGVzdHJveShub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWMuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuc3BlYy5kZXN0cm95KG5vZGUpO1xuICAgIH1cbn1cbmNsYXNzIElubGluZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwKHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zcGVjLmluY2x1c2l2ZVN0YXJ0ID8gLTEgOiAxKSAtIG9mZnNldDtcbiAgICAgICAgbGV0IHRvID0gbWFwcGluZy5tYXAoc3Bhbi50byArIG9sZE9mZnNldCwgdGhpcy5zcGVjLmluY2x1c2l2ZUVuZCA/IDEgOiAtMSkgLSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBmcm9tID49IHRvID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQoXywgc3BhbikgeyByZXR1cm4gc3Bhbi5mcm9tIDwgc3Bhbi50bzsgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBJbmxpbmVUeXBlICYmIGNvbXBhcmVPYmpzKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVPYmpzKHRoaXMuc3BlYywgb3RoZXIuc3BlYykpO1xuICAgIH1cbiAgICBzdGF0aWMgaXMoc3BhbikgeyByZXR1cm4gc3Bhbi50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZTsgfVxuICAgIGRlc3Ryb3koKSB7IH1cbn1cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihhdHRycywgc3BlYykge1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWMgfHwgbm9TcGVjO1xuICAgIH1cbiAgICBtYXAobWFwcGluZywgc3Bhbiwgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdChzcGFuLmZyb20gKyBvbGRPZmZzZXQsIDEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4udG8gKyBvbGRPZmZzZXQsIC0xKTtcbiAgICAgICAgaWYgKHRvLmRlbGV0ZWQgfHwgdG8ucG9zIDw9IGZyb20ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLnBvcyAtIG9mZnNldCwgdG8ucG9zIC0gb2Zmc2V0LCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQobm9kZSwgc3Bhbikge1xuICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHNwYW4uZnJvbSksIGNoaWxkO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID09IHNwYW4uZnJvbSAmJiAhKGNoaWxkID0gbm9kZS5jaGlsZChpbmRleCkpLmlzVGV4dCAmJiBvZmZzZXQgKyBjaGlsZC5ub2RlU2l6ZSA9PSBzcGFuLnRvO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKG90aGVyIGluc3RhbmNlb2YgTm9kZVR5cGUgJiYgY29tcGFyZU9ianModGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7IH1cbn1cbi8qKlxuRGVjb3JhdGlvbiBvYmplY3RzIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgdmlldyB0aHJvdWdoIHRoZVxuW2BkZWNvcmF0aW9uc2AgcHJvcF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMuZGVjb3JhdGlvbnMpLiBUaGV5IGNvbWUgaW5cbnNldmVyYWwgdmFyaWFudHNcdTIwMTRzZWUgdGhlIHN0YXRpYyBtZW1iZXJzIG9mIHRoaXMgY2xhc3MgZm9yIGRldGFpbHMuXG4qL1xuY2xhc3MgRGVjb3JhdGlvbiB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGRlY29yYXRpb24uXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uLiBXaWxsIGJlIHRoZSBzYW1lIGFzIGBmcm9tYCBmb3IgW3dpZGdldFxuICAgIGRlY29yYXRpb25zXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uXndpZGdldCkuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0eXBlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb3B5KGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgdGhpcy50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlcShvdGhlciwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLmVxKG90aGVyLnR5cGUpICYmIHRoaXMuZnJvbSArIG9mZnNldCA9PSBvdGhlci5mcm9tICYmIHRoaXMudG8gKyBvZmZzZXQgPT0gb3RoZXIudG87XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUubWFwKG1hcHBpbmcsIHRoaXMsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlcyBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBpcyBhIERPTSBub2RlIHRoYXQncyBzaG93biBpblxuICAgIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91XG4gICAgZGVsYXkgcmVuZGVyaW5nIHRoZSB3aWRnZXQgYnkgcGFzc2luZyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICAgIGNhbGxlZCB3aGVuIHRoZSB3aWRnZXQgaXMgYWN0dWFsbHkgZHJhd24gaW4gYSB2aWV3LCBidXQgeW91IGNhblxuICAgIGFsc28gZGlyZWN0bHkgcGFzcyBhIERPTSBub2RlLiBgZ2V0UG9zYCBjYW4gYmUgdXNlZCB0byBmaW5kIHRoZVxuICAgIHdpZGdldCdzIGN1cnJlbnQgZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgd2lkZ2V0KHBvcywgdG9ET00sIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKHBvcywgcG9zLCBuZXcgV2lkZ2V0VHlwZSh0b0RPTSwgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGFuIGlubGluZSBkZWNvcmF0aW9uLCB3aGljaCBhZGRzIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIHRvXG4gICAgZWFjaCBpbmxpbmUgbm9kZSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC5cbiAgICAqL1xuICAgIHN0YXRpYyBpbmxpbmUoZnJvbSwgdG8sIGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IElubGluZVR5cGUoYXR0cnMsIHNwZWMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlcyBhIG5vZGUgZGVjb3JhdGlvbi4gYGZyb21gIGFuZCBgdG9gIHNob3VsZCBwb2ludCBwcmVjaXNlbHlcbiAgICBiZWZvcmUgYW5kIGFmdGVyIGEgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFRoYXQgbm9kZSwgYW5kIG9ubHkgdGhhdFxuICAgIG5vZGUsIHdpbGwgcmVjZWl2ZSB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBub2RlKGZyb20sIHRvLCBhdHRycywgc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIG5ldyBOb2RlVHlwZShhdHRycywgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3BlYyBwcm92aWRlZCB3aGVuIGNyZWF0aW5nIHRoaXMgZGVjb3JhdGlvbi4gQ2FuIGJlIHVzZWZ1bFxuICAgIGlmIHlvdSd2ZSBzdG9yZWQgZXh0cmEgaW5mb3JtYXRpb24gaW4gdGhhdCBvYmplY3QuXG4gICAgKi9cbiAgICBnZXQgc3BlYygpIHsgcmV0dXJuIHRoaXMudHlwZS5zcGVjOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaW5saW5lKCkgeyByZXR1cm4gdGhpcy50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHdpZGdldCgpIHsgcmV0dXJuIHRoaXMudHlwZSBpbnN0YW5jZW9mIFdpZGdldFR5cGU7IH1cbn1cbmNvbnN0IG5vbmUgPSBbXSwgbm9TcGVjID0ge307XG4vKipcbkEgY29sbGVjdGlvbiBvZiBbZGVjb3JhdGlvbnNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb24pLCBvcmdhbml6ZWQgaW4gc3VjaFxuYSB3YXkgdGhhdCB0aGUgZHJhd2luZyBhbGdvcml0aG0gY2FuIGVmZmljaWVudGx5IHVzZSBhbmQgY29tcGFyZVxudGhlbS4gVGhpcyBpcyBhIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVcdTIwMTRpdCBpcyBub3QgbW9kaWZpZWQsXG51cGRhdGVzIGNyZWF0ZSBhIG5ldyB2YWx1ZS5cbiovXG5jbGFzcyBEZWNvcmF0aW9uU2V0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsLCBjaGlsZHJlbikge1xuICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWwubGVuZ3RoID8gbG9jYWwgOiBub25lO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoID8gY2hpbGRyZW4gOiBub25lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgZGVjb3JhdGlvbnMsIHVzaW5nIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuXG4gICAgZG9jdW1lbnQuIFRoaXMgd2lsbCBjb25zdW1lIChtb2RpZnkpIHRoZSBgZGVjb3JhdGlvbnNgIGFycmF5LCBzb1xuICAgIHlvdSBtdXN0IG1ha2UgYSBjb3B5IGlmIHlvdSB3YW50IG5lZWQgdG8gcHJlc2VydmUgdGhhdC5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZG9jLCBkZWNvcmF0aW9ucykge1xuICAgICAgICByZXR1cm4gZGVjb3JhdGlvbnMubGVuZ3RoID8gYnVpbGRUcmVlKGRlY29yYXRpb25zLCBkb2MsIDAsIG5vU3BlYykgOiBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhbGwgZGVjb3JhdGlvbnMgaW4gdGhpcyBzZXQgd2hpY2ggdG91Y2ggdGhlIGdpdmVuIHJhbmdlXG4gICAgKGluY2x1ZGluZyBkZWNvcmF0aW9ucyB0aGF0IHN0YXJ0IG9yIGVuZCBkaXJlY3RseSBhdCB0aGVcbiAgICBib3VuZGFyaWVzKSBhbmQgbWF0Y2ggdGhlIGdpdmVuIHByZWRpY2F0ZSBvbiB0aGVpciBzcGVjLiBXaGVuXG4gICAgYHN0YXJ0YCBhbmQgYGVuZGAgYXJlIG9taXR0ZWQsIGFsbCBkZWNvcmF0aW9ucyBpbiB0aGUgc2V0IGFyZVxuICAgIGNvbnNpZGVyZWQuIFdoZW4gYHByZWRpY2F0ZWAgaXNuJ3QgZ2l2ZW4sIGFsbCBkZWNvcmF0aW9ucyBhcmVcbiAgICBhc3N1bWVkIHRvIG1hdGNoLlxuICAgICovXG4gICAgZmluZChzdGFydCwgZW5kLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZpbmRJbm5lcihzdGFydCA9PSBudWxsID8gMCA6IHN0YXJ0LCBlbmQgPT0gbnVsbCA/IDFlOSA6IGVuZCwgcmVzdWx0LCAwLCBwcmVkaWNhdGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmaW5kSW5uZXIoc3RhcnQsIGVuZCwgcmVzdWx0LCBvZmZzZXQsIHByZWRpY2F0ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gdGhpcy5sb2NhbFtpXTtcbiAgICAgICAgICAgIGlmIChzcGFuLmZyb20gPD0gZW5kICYmIHNwYW4udG8gPj0gc3RhcnQgJiYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKHNwYW4uc3BlYykpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYW4uY29weShzcGFuLmZyb20gKyBvZmZzZXQsIHNwYW4udG8gKyBvZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldIDwgZW5kICYmIHRoaXMuY2hpbGRyZW5baSArIDFdID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRPZmYgPSB0aGlzLmNoaWxkcmVuW2ldICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2kgKyAyXS5maW5kSW5uZXIoc3RhcnQgLSBjaGlsZE9mZiwgZW5kIC0gY2hpbGRPZmYsIHJlc3VsdCwgb2Zmc2V0ICsgY2hpbGRPZmYsIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoZSBzZXQgb2YgZGVjb3JhdGlvbnMgaW4gcmVzcG9uc2UgdG8gYSBjaGFuZ2UgaW4gdGhlXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBtYXAobWFwcGluZywgZG9jLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzID09IGVtcHR5IHx8IG1hcHBpbmcubWFwcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBJbm5lcihtYXBwaW5nLCBkb2MsIDAsIDAsIG9wdGlvbnMgfHwgbm9TcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXBJbm5lcihtYXBwaW5nLCBub2RlLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucykge1xuICAgICAgICBsZXQgbmV3TG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHRoaXMubG9jYWxbaV0ubWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQgJiYgbWFwcGVkLnR5cGUudmFsaWQobm9kZSwgbWFwcGVkKSlcbiAgICAgICAgICAgICAgICAobmV3TG9jYWwgfHwgKG5ld0xvY2FsID0gW10pKS5wdXNoKG1hcHBlZCk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uUmVtb3ZlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZW1vdmUodGhpcy5sb2NhbFtpXS5zcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbWFwQ2hpbGRyZW4odGhpcy5jaGlsZHJlbiwgbmV3TG9jYWwgfHwgW10sIG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ld0xvY2FsID8gbmV3IERlY29yYXRpb25TZXQobmV3TG9jYWwuc29ydChieVBvcyksIG5vbmUpIDogZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbnMgdG8gdGhlIG9uZXMgaW4gdGhlIHNldCxcbiAgICBwcm9kdWNpbmcgYSBuZXcgc2V0LiBDb25zdW1lcyB0aGUgYGRlY29yYXRpb25zYCBhcnJheS4gTmVlZHNcbiAgICBhY2Nlc3MgdG8gdGhlIGN1cnJlbnQgZG9jdW1lbnQgdG8gY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSB0cmVlXG4gICAgc3RydWN0dXJlLlxuICAgICovXG4gICAgYWRkKGRvYywgZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgaWYgKCFkZWNvcmF0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoZG9jLCBkZWNvcmF0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZElubmVyKGRvYywgZGVjb3JhdGlvbnMsIDApO1xuICAgIH1cbiAgICBhZGRJbm5lcihkb2MsIGRlY29yYXRpb25zLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuLCBjaGlsZEluZGV4ID0gMDtcbiAgICAgICAgZG9jLmZvckVhY2goKGNoaWxkTm9kZSwgY2hpbGRPZmZzZXQpID0+IHtcbiAgICAgICAgICAgIGxldCBiYXNlT2Zmc2V0ID0gY2hpbGRPZmZzZXQgKyBvZmZzZXQsIGZvdW5kO1xuICAgICAgICAgICAgaWYgKCEoZm91bmQgPSB0YWtlU3BhbnNGb3JOb2RlKGRlY29yYXRpb25zLCBjaGlsZE5vZGUsIGJhc2VPZmZzZXQpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkSW5kZXggPCBjaGlsZHJlbi5sZW5ndGggJiYgY2hpbGRyZW5bY2hpbGRJbmRleF0gPCBjaGlsZE9mZnNldClcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4ICs9IDM7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5bY2hpbGRJbmRleF0gPT0gY2hpbGRPZmZzZXQpXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5bY2hpbGRJbmRleCArIDJdID0gY2hpbGRyZW5bY2hpbGRJbmRleCArIDJdLmFkZElubmVyKGNoaWxkTm9kZSwgZm91bmQsIGJhc2VPZmZzZXQgKyAxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoY2hpbGRJbmRleCwgMCwgY2hpbGRPZmZzZXQsIGNoaWxkT2Zmc2V0ICsgY2hpbGROb2RlLm5vZGVTaXplLCBidWlsZFRyZWUoZm91bmQsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCArIDEsIG5vU3BlYykpO1xuICAgICAgICAgICAgY2hpbGRJbmRleCArPSAzO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxvY2FsID0gbW92ZVNwYW5zKGNoaWxkSW5kZXggPyB3aXRob3V0TnVsbHMoZGVjb3JhdGlvbnMpIDogZGVjb3JhdGlvbnMsIC1vZmZzZXQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFsb2NhbFtpXS50eXBlLnZhbGlkKGRvYywgbG9jYWxbaV0pKVxuICAgICAgICAgICAgICAgIGxvY2FsLnNwbGljZShpLS0sIDEpO1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb25TZXQobG9jYWwubGVuZ3RoID8gdGhpcy5sb2NhbC5jb25jYXQobG9jYWwpLnNvcnQoYnlQb3MpIDogdGhpcy5sb2NhbCwgY2hpbGRyZW4gfHwgdGhpcy5jaGlsZHJlbik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzZXQgdGhhdCBjb250YWlucyB0aGUgZGVjb3JhdGlvbnMgaW4gdGhpcyBzZXQsIG1pbnVzXG4gICAgdGhlIG9uZXMgaW4gdGhlIGdpdmVuIGFycmF5LlxuICAgICovXG4gICAgcmVtb3ZlKGRlY29yYXRpb25zKSB7XG4gICAgICAgIGlmIChkZWNvcmF0aW9ucy5sZW5ndGggPT0gMCB8fCB0aGlzID09IGVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUlubmVyKGRlY29yYXRpb25zLCAwKTtcbiAgICB9XG4gICAgcmVtb3ZlSW5uZXIoZGVjb3JhdGlvbnMsIG9mZnNldCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLCBsb2NhbCA9IHRoaXMubG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZDtcbiAgICAgICAgICAgIGxldCBmcm9tID0gY2hpbGRyZW5baV0gKyBvZmZzZXQsIHRvID0gY2hpbGRyZW5baSArIDFdICsgb2Zmc2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIHNwYW47IGogPCBkZWNvcmF0aW9ucy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAoc3BhbiA9IGRlY29yYXRpb25zW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGFuLmZyb20gPiBmcm9tICYmIHNwYW4udG8gPCB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb3JhdGlvbnNbal0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZvdW5kIHx8IChmb3VuZCA9IFtdKSkucHVzaChzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4gPT0gdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgICAgIGxldCByZW1vdmVkID0gY2hpbGRyZW5baSArIDJdLnJlbW92ZUlubmVyKGZvdW5kLCBmcm9tICsgMSk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZCAhPSBlbXB0eSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAyXSA9IHJlbW92ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMyk7XG4gICAgICAgICAgICAgICAgaSAtPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbC5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgc3BhbjsgaSA8IGRlY29yYXRpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChzcGFuID0gZGVjb3JhdGlvbnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb2NhbC5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFtqXS5lcShzcGFuLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsID09IHRoaXMubG9jYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsID0gdGhpcy5sb2NhbC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsLnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuID09IHRoaXMuY2hpbGRyZW4gJiYgbG9jYWwgPT0gdGhpcy5sb2NhbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbG9jYWwubGVuZ3RoIHx8IGNoaWxkcmVuLmxlbmd0aCA/IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLCBjaGlsZHJlbikgOiBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmb3JDaGlsZChvZmZzZXQsIG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuZW1wdHk7XG4gICAgICAgIGxldCBjaGlsZCwgbG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldID49IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldID09IG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2kgKyAyXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gb2Zmc2V0ICsgMSwgZW5kID0gc3RhcnQgKyBub2RlLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZGVjID0gdGhpcy5sb2NhbFtpXTtcbiAgICAgICAgICAgIGlmIChkZWMuZnJvbSA8IGVuZCAmJiBkZWMudG8gPiBzdGFydCAmJiAoZGVjLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlKSkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoc3RhcnQsIGRlYy5mcm9tKSAtIHN0YXJ0LCB0byA9IE1hdGgubWluKGVuZCwgZGVjLnRvKSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgdG8pXG4gICAgICAgICAgICAgICAgICAgIChsb2NhbCB8fCAobG9jYWwgPSBbXSkpLnB1c2goZGVjLmNvcHkoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgIGxldCBsb2NhbFNldCA9IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLnNvcnQoYnlQb3MpLCBub25lKTtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCA/IG5ldyBEZWNvcmF0aW9uR3JvdXAoW2xvY2FsU2V0LCBjaGlsZF0pIDogbG9jYWxTZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09IG90aGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCkgfHxcbiAgICAgICAgICAgIHRoaXMubG9jYWwubGVuZ3RoICE9IG90aGVyLmxvY2FsLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggIT0gb3RoZXIuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9jYWxbaV0uZXEob3RoZXIubG9jYWxbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gIT0gb3RoZXIuY2hpbGRyZW5baV0gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2kgKyAxXSAhPSBvdGhlci5jaGlsZHJlbltpICsgMV0gfHxcbiAgICAgICAgICAgICAgICAhdGhpcy5jaGlsZHJlbltpICsgMl0uZXEob3RoZXIuY2hpbGRyZW5baSArIDJdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGxvY2Fscyhub2RlKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVPdmVybGFwKHRoaXMubG9jYWxzSW5uZXIobm9kZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGxvY2Fsc0lubmVyKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gbm9uZTtcbiAgICAgICAgaWYgKG5vZGUuaW5saW5lQ29udGVudCB8fCAhdGhpcy5sb2NhbC5zb21lKElubGluZVR5cGUuaXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWw7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLmxvY2FsW2ldLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmxvY2FsW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBkZWNvcmF0aW9ucy5cbiovXG5EZWNvcmF0aW9uU2V0LmVtcHR5ID0gbmV3IERlY29yYXRpb25TZXQoW10sIFtdKTtcbi8qKlxuQGludGVybmFsXG4qL1xuRGVjb3JhdGlvblNldC5yZW1vdmVPdmVybGFwID0gcmVtb3ZlT3ZlcmxhcDtcbmNvbnN0IGVtcHR5ID0gRGVjb3JhdGlvblNldC5lbXB0eTtcbi8vIEFuIGFic3RyYWN0aW9uIHRoYXQgYWxsb3dzIHRoZSBjb2RlIGRlYWxpbmcgd2l0aCBkZWNvcmF0aW9ucyB0b1xuLy8gdHJlYXQgbXVsdGlwbGUgRGVjb3JhdGlvblNldCBvYmplY3RzIGFzIGlmIGl0IHdlcmUgYSBzaW5nbGUgb2JqZWN0XG4vLyB3aXRoIChhIHN1YnNldCBvZikgdGhlIHNhbWUgaW50ZXJmYWNlLlxuY2xhc3MgRGVjb3JhdGlvbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihtZW1iZXJzKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IG1lbWJlcnM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBkb2MpIHtcbiAgICAgICAgY29uc3QgbWFwcGVkRGVjb3MgPSB0aGlzLm1lbWJlcnMubWFwKG1lbWJlciA9PiBtZW1iZXIubWFwKG1hcHBpbmcsIGRvYywgbm9TcGVjKSk7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShtYXBwZWREZWNvcyk7XG4gICAgfVxuICAgIGZvckNoaWxkKG9mZnNldCwgY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLmlzTGVhZilcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuICAgICAgICBsZXQgZm91bmQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLm1lbWJlcnNbaV0uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IGVtcHR5KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIERlY29yYXRpb25Hcm91cClcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGZvdW5kLmNvbmNhdChyZXN1bHQubWVtYmVycyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm91bmQucHVzaChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShmb3VuZCk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgRGVjb3JhdGlvbkdyb3VwKSB8fFxuICAgICAgICAgICAgb3RoZXIubWVtYmVycy5sZW5ndGggIT0gdGhpcy5tZW1iZXJzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMubWVtYmVyc1tpXS5lcShvdGhlci5tZW1iZXJzW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsb2NhbHMobm9kZSkge1xuICAgICAgICBsZXQgcmVzdWx0LCBzb3J0ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxvY2FscyA9IHRoaXMubWVtYmVyc1tpXS5sb2NhbHNJbm5lcihub2RlKTtcbiAgICAgICAgICAgIGlmICghbG9jYWxzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbG9jYWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbG9jYWxzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsb2NhbHNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgPyByZW1vdmVPdmVybGFwKHNvcnRlZCA/IHJlc3VsdCA6IHJlc3VsdC5zb3J0KGJ5UG9zKSkgOiBub25lO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBncm91cCBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIGRlY29yYXRpb24gc2V0cywgb3IgcmV0dXJuXG4gICAgLy8gYSBzaW5nbGUgc2V0IHdoZW4gcG9zc2libGUuXG4gICAgc3RhdGljIGZyb20obWVtYmVycykge1xuICAgICAgICBzd2l0Y2ggKG1lbWJlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBlbXB0eTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG1lbWJlcnNbMF07XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gbmV3IERlY29yYXRpb25Hcm91cChtZW1iZXJzLmV2ZXJ5KG0gPT4gbSBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQpID8gbWVtYmVycyA6XG4gICAgICAgICAgICAgICAgbWVtYmVycy5yZWR1Y2UoKHIsIG0pID0+IHIuY29uY2F0KG0gaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0ID8gbSA6IG0ubWVtYmVycyksIFtdKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXBDaGlsZHJlbihvbGRDaGlsZHJlbiwgbmV3TG9jYWwsIG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gb2xkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgICAvLyBNYXJrIHRoZSBjaGlsZHJlbiB0aGF0IGFyZSBkaXJlY3RseSB0b3VjaGVkIGJ5IGNoYW5nZXMsIGFuZFxuICAgIC8vIG1vdmUgdGhvc2UgdGhhdCBhcmUgYWZ0ZXIgdGhlIGNoYW5nZXMuXG4gICAgZm9yIChsZXQgaSA9IDAsIGJhc2VPZmZzZXQgPSBvbGRPZmZzZXQ7IGkgPCBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG1vdmVkID0gMDtcbiAgICAgICAgbWFwcGluZy5tYXBzW2ldLmZvckVhY2goKG9sZFN0YXJ0LCBvbGRFbmQsIG5ld1N0YXJ0LCBuZXdFbmQpID0+IHtcbiAgICAgICAgICAgIGxldCBkU2l6ZSA9IChuZXdFbmQgLSBuZXdTdGFydCkgLSAob2xkRW5kIC0gb2xkU3RhcnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBjaGlsZHJlbltpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA8IDAgfHwgb2xkU3RhcnQgPiBlbmQgKyBiYXNlT2Zmc2V0IC0gbW92ZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGNoaWxkcmVuW2ldICsgYmFzZU9mZnNldCAtIG1vdmVkO1xuICAgICAgICAgICAgICAgIGlmIChvbGRFbmQgPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gb2xkU3RhcnQgPD0gc3RhcnQgPyAtMiA6IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRTdGFydCA+PSBiYXNlT2Zmc2V0ICYmIGRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldICs9IGRTaXplO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gKz0gZFNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW92ZWQgKz0gZFNpemU7XG4gICAgICAgIH0pO1xuICAgICAgICBiYXNlT2Zmc2V0ID0gbWFwcGluZy5tYXBzW2ldLm1hcChiYXNlT2Zmc2V0LCAtMSk7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGNoaWxkIG5vZGVzIHRoYXQgc3RpbGwgY29ycmVzcG9uZCB0byBhIHNpbmdsZSBub2RlLFxuICAgIC8vIHJlY3Vyc2l2ZWx5IGNhbGwgbWFwSW5uZXIgb24gdGhlbSBhbmQgdXBkYXRlIHRoZWlyIHBvc2l0aW9ucy5cbiAgICBsZXQgbXVzdFJlYnVpbGQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdIDwgMCkgeyAvLyBUb3VjaGVkIG5vZGVzXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdID09IC0yKSB7XG4gICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IC0xO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcChvbGRDaGlsZHJlbltpXSArIG9sZE9mZnNldCksIGZyb21Mb2NhbCA9IGZyb20gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoZnJvbUxvY2FsIDwgMCB8fCBmcm9tTG9jYWwgPj0gbm9kZS5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNdXN0IHJlYWQgb2xkQ2hpbGRyZW4gYmVjYXVzZSBjaGlsZHJlbiB3YXMgdGFnZ2VkIHdpdGggLTFcbiAgICAgICAgICAgIGxldCB0byA9IG1hcHBpbmcubWFwKG9sZENoaWxkcmVuW2kgKyAxXSArIG9sZE9mZnNldCwgLTEpLCB0b0xvY2FsID0gdG8gLSBvZmZzZXQ7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0OiBjaGlsZE9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChmcm9tTG9jYWwpO1xuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IG5vZGUubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkT2Zmc2V0ID09IGZyb21Mb2NhbCAmJiBjaGlsZE9mZnNldCArIGNoaWxkTm9kZS5ub2RlU2l6ZSA9PSB0b0xvY2FsKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcHBlZCA9IGNoaWxkcmVuW2kgKyAyXVxuICAgICAgICAgICAgICAgICAgICAubWFwSW5uZXIobWFwcGluZywgY2hpbGROb2RlLCBmcm9tICsgMSwgb2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkICE9IGVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldID0gZnJvbUxvY2FsO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSB0b0xvY2FsO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMl0gPSBtYXBwZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIC8vIFJlbWFpbmluZyBjaGlsZHJlbiBtdXN0IGJlIGNvbGxlY3RlZCBhbmQgcmVidWlsdCBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdHJ1Y3R1cmVcbiAgICBpZiAobXVzdFJlYnVpbGQpIHtcbiAgICAgICAgbGV0IGRlY29yYXRpb25zID0gbWFwQW5kR2F0aGVyUmVtYWluaW5nRGVjb3JhdGlvbnMoY2hpbGRyZW4sIG9sZENoaWxkcmVuLCBuZXdMb2NhbCwgbWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgICAgICBsZXQgYnVpbHQgPSBidWlsZFRyZWUoZGVjb3JhdGlvbnMsIG5vZGUsIDAsIG9wdGlvbnMpO1xuICAgICAgICBuZXdMb2NhbCA9IGJ1aWx0LmxvY2FsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA8IDApIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMyk7XG4gICAgICAgICAgICAgICAgaSAtPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBidWlsdC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWlsdC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuW2pdIDwgZnJvbSlcbiAgICAgICAgICAgICAgICBqICs9IDM7XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMCwgYnVpbHQuY2hpbGRyZW5baV0sIGJ1aWx0LmNoaWxkcmVuW2kgKyAxXSwgYnVpbHQuY2hpbGRyZW5baSArIDJdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IERlY29yYXRpb25TZXQobmV3TG9jYWwuc29ydChieVBvcyksIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIG1vdmVTcGFucyhzcGFucywgb2Zmc2V0KSB7XG4gICAgaWYgKCFvZmZzZXQgfHwgIXNwYW5zLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHNwYW5zO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzcGFuID0gc3BhbnNbaV07XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBEZWNvcmF0aW9uKHNwYW4uZnJvbSArIG9mZnNldCwgc3Bhbi50byArIG9mZnNldCwgc3Bhbi50eXBlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXBBbmRHYXRoZXJSZW1haW5pbmdEZWNvcmF0aW9ucyhjaGlsZHJlbiwgb2xkQ2hpbGRyZW4sIGRlY29yYXRpb25zLCBtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucykge1xuICAgIC8vIEdhdGhlciBhbGwgZGVjb3JhdGlvbnMgZnJvbSB0aGUgcmVtYWluaW5nIG1hcmtlZCBjaGlsZHJlblxuICAgIGZ1bmN0aW9uIGdhdGhlcihzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHNldC5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZClcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcHBlZCk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uUmVtb3ZlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZW1vdmUoc2V0LmxvY2FsW2ldLnNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0LmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgZ2F0aGVyKHNldC5jaGlsZHJlbltpICsgMl0sIHNldC5jaGlsZHJlbltpXSArIG9sZE9mZnNldCArIDEpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdID09IC0xKVxuICAgICAgICAgICAgZ2F0aGVyKGNoaWxkcmVuW2kgKyAyXSwgb2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxKTtcbiAgICByZXR1cm4gZGVjb3JhdGlvbnM7XG59XG5mdW5jdGlvbiB0YWtlU3BhbnNGb3JOb2RlKHNwYW5zLCBub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBlbmQgPSBvZmZzZXQgKyBub2RlLm5vZGVTaXplLCBmb3VuZCA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDAsIHNwYW47IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKHNwYW4gPSBzcGFuc1tpXSkgJiYgc3Bhbi5mcm9tID4gb2Zmc2V0ICYmIHNwYW4udG8gPCBlbmQpIHtcbiAgICAgICAgICAgIChmb3VuZCB8fCAoZm91bmQgPSBbXSkpLnB1c2goc3Bhbik7XG4gICAgICAgICAgICBzcGFuc1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gd2l0aG91dE51bGxzKGFycmF5KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChhcnJheVtpXSAhPSBudWxsKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBCdWlsZCB1cCBhIHRyZWUgdGhhdCBjb3JyZXNwb25kcyB0byBhIHNldCBvZiBkZWNvcmF0aW9ucy4gYG9mZnNldGBcbi8vIGlzIGEgYmFzZSBvZmZzZXQgdGhhdCBzaG91bGQgYmUgc3VidHJhY3RlZCBmcm9tIHRoZSBgZnJvbWAgYW5kIGB0b2Bcbi8vIHBvc2l0aW9ucyBpbiB0aGUgc3BhbnMgKHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBhbGxvY2F0ZSBuZXcgc3BhbnNcbi8vIGZvciByZWN1cnNpdmUgY2FsbHMpLlxuZnVuY3Rpb24gYnVpbGRUcmVlKHNwYW5zLCBub2RlLCBvZmZzZXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBbXSwgaGFzTnVsbHMgPSBmYWxzZTtcbiAgICBub2RlLmZvckVhY2goKGNoaWxkTm9kZSwgbG9jYWxTdGFydCkgPT4ge1xuICAgICAgICBsZXQgZm91bmQgPSB0YWtlU3BhbnNGb3JOb2RlKHNwYW5zLCBjaGlsZE5vZGUsIGxvY2FsU3RhcnQgKyBvZmZzZXQpO1xuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIGhhc051bGxzID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBzdWJ0cmVlID0gYnVpbGRUcmVlKGZvdW5kLCBjaGlsZE5vZGUsIG9mZnNldCArIGxvY2FsU3RhcnQgKyAxLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzdWJ0cmVlICE9IGVtcHR5KVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobG9jYWxTdGFydCwgbG9jYWxTdGFydCArIGNoaWxkTm9kZS5ub2RlU2l6ZSwgc3VidHJlZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgbG9jYWxzID0gbW92ZVNwYW5zKGhhc051bGxzID8gd2l0aG91dE51bGxzKHNwYW5zKSA6IHNwYW5zLCAtb2Zmc2V0KS5zb3J0KGJ5UG9zKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2Fscy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFsb2NhbHNbaV0udHlwZS52YWxpZChub2RlLCBsb2NhbHNbaV0pKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vblJlbW92ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVtb3ZlKGxvY2Fsc1tpXS5zcGVjKTtcbiAgICAgICAgICAgIGxvY2Fscy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBsb2NhbHMubGVuZ3RoIHx8IGNoaWxkcmVuLmxlbmd0aCA/IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FscywgY2hpbGRyZW4pIDogZW1wdHk7XG59XG4vLyBVc2VkIHRvIHNvcnQgZGVjb3JhdGlvbnMgc28gdGhhdCBvbmVzIHdpdGggYSBsb3cgc3RhcnQgcG9zaXRpb25cbi8vIGNvbWUgZmlyc3QsIGFuZCB3aXRoaW4gYSBzZXQgd2l0aCB0aGUgc2FtZSBzdGFydCBwb3NpdGlvbiwgdGhvc2Vcbi8vIHdpdGggYW4gc21hbGxlciBlbmQgcG9zaXRpb24gY29tZSBmaXJzdC5cbmZ1bmN0aW9uIGJ5UG9zKGEsIGIpIHtcbiAgICByZXR1cm4gYS5mcm9tIC0gYi5mcm9tIHx8IGEudG8gLSBiLnRvO1xufVxuLy8gU2NhbiBhIHNvcnRlZCBhcnJheSBvZiBkZWNvcmF0aW9ucyBmb3IgcGFydGlhbGx5IG92ZXJsYXBwaW5nIHNwYW5zLFxuLy8gYW5kIHNwbGl0IHRob3NlIHNvIHRoYXQgb25seSBmdWxseSBvdmVybGFwcGluZyBzcGFucyBhcmUgbGVmdCAodG9cbi8vIG1ha2Ugc3Vic2VxdWVudCByZW5kZXJpbmcgZWFzaWVyKS4gV2lsbCByZXR1cm4gdGhlIGlucHV0IGFycmF5IGlmXG4vLyBubyBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgc3BhbnMgYXJlIGZvdW5kICh0aGUgY29tbW9uIGNhc2UpLlxuZnVuY3Rpb24gcmVtb3ZlT3ZlcmxhcChzcGFucykge1xuICAgIGxldCB3b3JraW5nID0gc3BhbnM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JraW5nLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBsZXQgc3BhbiA9IHdvcmtpbmdbaV07XG4gICAgICAgIGlmIChzcGFuLmZyb20gIT0gc3Bhbi50bylcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHdvcmtpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHdvcmtpbmdbal07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA9PSBzcGFuLmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQudG8gIT0gc3Bhbi50bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcgPT0gc3BhbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IHNwYW5zLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb2xsb3dlZCBieSBhIHBhcnRpYWxseSBvdmVybGFwcGluZyBsYXJnZXIgc3Bhbi4gU3BsaXQgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Bhbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdbal0gPSBuZXh0LmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEFoZWFkKHdvcmtpbmcsIGogKyAxLCBuZXh0LmNvcHkoc3Bhbi50bywgbmV4dC50bykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA8IHNwYW4udG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBzcGFucy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGVuZCBvZiB0aGlzIG9uZSBvdmVybGFwcyB3aXRoIGEgc3Vic2VxdWVudCBzcGFuLiBTcGxpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBvbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nW2ldID0gc3Bhbi5jb3B5KHNwYW4uZnJvbSwgbmV4dC5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEFoZWFkKHdvcmtpbmcsIGosIHNwYW4uY29weShuZXh0LmZyb20sIHNwYW4udG8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3b3JraW5nO1xufVxuZnVuY3Rpb24gaW5zZXJ0QWhlYWQoYXJyYXksIGksIGRlY28pIHtcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCAmJiBieVBvcyhkZWNvLCBhcnJheVtpXSkgPiAwKVxuICAgICAgICBpKys7XG4gICAgYXJyYXkuc3BsaWNlKGksIDAsIGRlY28pO1xufVxuLy8gR2V0IHRoZSBkZWNvcmF0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgcHJvcHMgb2YgYSB2aWV3LlxuZnVuY3Rpb24gdmlld0RlY29yYXRpb25zKHZpZXcpIHtcbiAgICBsZXQgZm91bmQgPSBbXTtcbiAgICB2aWV3LnNvbWVQcm9wKFwiZGVjb3JhdGlvbnNcIiwgZiA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSBmKHZpZXcuc3RhdGUpO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdCAhPSBlbXB0eSlcbiAgICAgICAgICAgIGZvdW5kLnB1c2gocmVzdWx0KTtcbiAgICB9KTtcbiAgICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKVxuICAgICAgICBmb3VuZC5wdXNoKERlY29yYXRpb25TZXQuY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBbdmlldy5jdXJzb3JXcmFwcGVyLmRlY29dKSk7XG4gICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKTtcbn1cblxuY29uc3Qgb2JzZXJ2ZU9wdGlvbnMgPSB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlLFxuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZVxufTtcbi8vIElFMTEgaGFzIHZlcnkgYnJva2VuIG11dGF0aW9uIG9ic2VydmVycywgc28gd2UgYWxzbyBsaXN0ZW4gdG8gRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXG5jb25zdCB1c2VDaGFyRGF0YSA9IGllICYmIGllX3ZlcnNpb24gPD0gMTE7XG5jbGFzcyBTZWxlY3Rpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgc2V0KHNlbCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSBzZWwuYW5jaG9yT2Zmc2V0O1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IHNlbC5mb2N1c05vZGU7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgfVxuICAgIGVxKHNlbCkge1xuICAgICAgICByZXR1cm4gc2VsLmFuY2hvck5vZGUgPT0gdGhpcy5hbmNob3JOb2RlICYmIHNlbC5hbmNob3JPZmZzZXQgPT0gdGhpcy5hbmNob3JPZmZzZXQgJiZcbiAgICAgICAgICAgIHNlbC5mb2N1c05vZGUgPT0gdGhpcy5mb2N1c05vZGUgJiYgc2VsLmZvY3VzT2Zmc2V0ID09IHRoaXMuZm9jdXNPZmZzZXQ7XG4gICAgfVxufVxuY2xhc3MgRE9NT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGhhbmRsZURPTUNoYW5nZSkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmhhbmRsZURPTUNoYW5nZSA9IGhhbmRsZURPTUNoYW5nZTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IC0xO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvblN0YXRlO1xuICAgICAgICB0aGlzLm9uQ2hhckRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgJiZcbiAgICAgICAgICAgIG5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0YXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICAvLyBJRTExIHdpbGwgc29tZXRpbWVzIChvbiBiYWNrc3BhY2luZyBvdXQgYSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgLy8gdGV4dCBub2RlIGFmdGVyIGEgQlIgbm9kZSkgY2FsbCB0aGUgb2JzZXJ2ZXIgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmUgYWN0dWFsbHkgdXBkYXRpbmcgdGhlIERPTSwgd2hpY2ggd2lsbCBjYXVzZVxuICAgICAgICAgICAgICAgIC8vIFByb3NlTWlycm9yIHRvIG1pc3MgdGhlIGNoYW5nZSAoc2VlICM5MzApXG4gICAgICAgICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgbXV0YXRpb25zLnNvbWUobSA9PiBtLnR5cGUgPT0gXCJjaGlsZExpc3RcIiAmJiBtLnJlbW92ZWROb2Rlcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgbS50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiICYmIG0ub2xkVmFsdWUubGVuZ3RoID4gbS50YXJnZXQubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhckRhdGEgPSBlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goeyB0YXJnZXQ6IGUudGFyZ2V0LCB0eXBlOiBcImNoYXJhY3RlckRhdGFcIiwgb2xkVmFsdWU6IGUucHJldlZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGZsdXNoU29vbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmx1c2hpbmdTb29uIDwgMClcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdTb29uID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmZsdXNoaW5nU29vbiA9IC0xOyB0aGlzLmZsdXNoKCk7IH0sIDIwKTtcbiAgICB9XG4gICAgZm9yY2VGbHVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmx1c2hpbmdTb29uID4gLTEpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5mbHVzaGluZ1Nvb24pO1xuICAgICAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnZpZXcuZG9tLCBvYnNlcnZlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub25DaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmNvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGxldCB0YWtlID0gdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICAgICAgaWYgKHRha2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWtlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2godGFrZVtpXSk7XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGhpcy5mbHVzaCgpLCAyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbkNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBjb25uZWN0U2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLm93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdFNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIHN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcygpIHtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gZmFsc2UsIDUwKTtcbiAgICB9XG4gICAgb25TZWxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgICAgIGlmICghaGFzRm9jdXNBbmRTZWxlY3Rpb24odGhpcy52aWV3KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzKVxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvblRvRE9NKHRoaXMudmlldyk7XG4gICAgICAgIC8vIERlbGV0aW9ucyBvbiBJRTExIGZpcmUgdGhlaXIgZXZlbnRzIGluIHRoZSB3cm9uZyBvcmRlciwgZ2l2aW5nXG4gICAgICAgIC8vIHVzIGEgc2VsZWN0aW9uIGNoYW5nZSBldmVudCBiZWZvcmUgdGhlIERPTSBjaGFuZ2VzIGFyZVxuICAgICAgICAvLyByZXBvcnRlZC5cbiAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgIXRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBzZWwgPSB0aGlzLnZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgICAgIC8vIFNlbGVjdGlvbi5pc0NvbGxhcHNlZCBpc24ndCByZWxpYWJsZSBvbiBJRVxuICAgICAgICAgICAgaWYgKHNlbC5mb2N1c05vZGUgJiYgaXNFcXVpdmFsZW50UG9zaXRpb24oc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICBzZXRDdXJTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQodGhpcy52aWV3LmRvbVNlbGVjdGlvblJhbmdlKCkpO1xuICAgIH1cbiAgICBpZ25vcmVTZWxlY3Rpb25DaGFuZ2Uoc2VsKSB7XG4gICAgICAgIGlmICghc2VsLmZvY3VzTm9kZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgYW5jZXN0b3JzID0gbmV3IFNldCwgY29udGFpbmVyO1xuICAgICAgICBmb3IgKGxldCBzY2FuID0gc2VsLmZvY3VzTm9kZTsgc2Nhbjsgc2NhbiA9IHBhcmVudE5vZGUoc2NhbikpXG4gICAgICAgICAgICBhbmNlc3RvcnMuYWRkKHNjYW4pO1xuICAgICAgICBmb3IgKGxldCBzY2FuID0gc2VsLmFuY2hvck5vZGU7IHNjYW47IHNjYW4gPSBwYXJlbnROb2RlKHNjYW4pKVxuICAgICAgICAgICAgaWYgKGFuY2VzdG9ycy5oYXMoc2NhbikpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBzY2FuO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgZGVzYyA9IGNvbnRhaW5lciAmJiB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhjb250YWluZXIpO1xuICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLmlnbm9yZU11dGF0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6IFwic2VsZWN0aW9uXCIsXG4gICAgICAgICAgICB0YXJnZXQ6IGNvbnRhaW5lci5ub2RlVHlwZSA9PSAzID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXJcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwZW5kaW5nUmVjb3JkcygpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIpXG4gICAgICAgICAgICBmb3IgKGxldCBtdXQgb2YgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKVxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZTtcbiAgICB9XG4gICAgZmx1c2goKSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGlmICghdmlldy5kb2NWaWV3IHx8IHRoaXMuZmx1c2hpbmdTb29uID4gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBtdXRhdGlvbnMgPSB0aGlzLnBlbmRpbmdSZWNvcmRzKCk7XG4gICAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgbmV3U2VsID0gIXRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzICYmICF0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZXEoc2VsKSAmJiBoYXNGb2N1c0FuZFNlbGVjdGlvbih2aWV3KSAmJiAhdGhpcy5pZ25vcmVTZWxlY3Rpb25DaGFuZ2Uoc2VsKTtcbiAgICAgICAgbGV0IGZyb20gPSAtMSwgdG8gPSAtMSwgdHlwZU92ZXIgPSBmYWxzZSwgYWRkZWQgPSBbXTtcbiAgICAgICAgaWYgKHZpZXcuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucmVnaXN0ZXJNdXRhdGlvbihtdXRhdGlvbnNbaV0sIGFkZGVkKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBmcm9tIDwgMCA/IHJlc3VsdC5mcm9tIDogTWF0aC5taW4ocmVzdWx0LmZyb20sIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICB0byA9IHRvIDwgMCA/IHJlc3VsdC50byA6IE1hdGgubWF4KHJlc3VsdC50bywgdG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnR5cGVPdmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZU92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2Vja28gJiYgYWRkZWQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGV0IGJycyA9IGFkZGVkLmZpbHRlcihuID0+IG4ubm9kZU5hbWUgPT0gXCJCUlwiKTtcbiAgICAgICAgICAgIGlmIChicnMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICBsZXQgYSA9IGJyc1swXSwgYiA9IGJyc1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoYS5wYXJlbnROb2RlICYmIGEucGFyZW50Tm9kZS5wYXJlbnROb2RlID09IGIucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGEucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlYWRTZWwgPSBudWxsO1xuICAgICAgICAvLyBJZiBpdCBsb29rcyBsaWtlIHRoZSBicm93c2VyIGhhcyByZXNldCB0aGUgc2VsZWN0aW9uIHRvIHRoZVxuICAgICAgICAvLyBzdGFydCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgZm9jdXMsIHJlc3RvcmUgdGhlIHNlbGVjdGlvbiBmcm9tXG4gICAgICAgIC8vIHRoZSBzdGF0ZVxuICAgICAgICBpZiAoZnJvbSA8IDAgJiYgbmV3U2VsICYmIHZpZXcuaW5wdXQubGFzdEZvY3VzID4gRGF0ZS5ub3coKSAtIDIwMCAmJlxuICAgICAgICAgICAgTWF0aC5tYXgodmlldy5pbnB1dC5sYXN0VG91Y2gsIHZpZXcuaW5wdXQubGFzdENsaWNrLnRpbWUpIDwgRGF0ZS5ub3coKSAtIDMwMCAmJlxuICAgICAgICAgICAgc2VsZWN0aW9uQ29sbGFwc2VkKHNlbCkgJiYgKHJlYWRTZWwgPSBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcpKSAmJlxuICAgICAgICAgICAgcmVhZFNlbC5lcShTZWxlY3Rpb24ubmVhcih2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKDApLCAxKSkpIHtcbiAgICAgICAgICAgIHZpZXcuaW5wdXQubGFzdEZvY3VzID0gMDtcbiAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uLnNldChzZWwpO1xuICAgICAgICAgICAgdmlldy5zY3JvbGxUb1NlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZyb20gPiAtMSB8fCBuZXdTZWwpIHtcbiAgICAgICAgICAgIGlmIChmcm9tID4gLTEpIHtcbiAgICAgICAgICAgICAgICB2aWV3LmRvY1ZpZXcubWFya0RpcnR5KGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICBjaGVja0NTUyh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRE9NQ2hhbmdlKGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpO1xuICAgICAgICAgICAgaWYgKHZpZXcuZG9jVmlldyAmJiB2aWV3LmRvY1ZpZXcuZGlydHkpXG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGVTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZXEoc2VsKSlcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQoc2VsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3Rlck11dGF0aW9uKG11dCwgYWRkZWQpIHtcbiAgICAgICAgLy8gSWdub3JlIG11dGF0aW9ucyBpbnNpZGUgbm9kZXMgdGhhdCB3ZXJlIGFscmVhZHkgbm90ZWQgYXMgaW5zZXJ0ZWRcbiAgICAgICAgaWYgKGFkZGVkLmluZGV4T2YobXV0LnRhcmdldCkgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZGVzYyA9IHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKG11dC50YXJnZXQpO1xuICAgICAgICBpZiAobXV0LnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIgJiZcbiAgICAgICAgICAgIChkZXNjID09IHRoaXMudmlldy5kb2NWaWV3IHx8IG11dC5hdHRyaWJ1dGVOYW1lID09IFwiY29udGVudGVkaXRhYmxlXCIgfHxcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IHNvbWV0aW1lcyBmaXJlcyBzcHVyaW91cyBldmVudHMgZm9yIG51bGwvZW1wdHkgc3R5bGVzXG4gICAgICAgICAgICAgICAgKG11dC5hdHRyaWJ1dGVOYW1lID09IFwic3R5bGVcIiAmJiAhbXV0Lm9sZFZhbHVlICYmICFtdXQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpKSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCFkZXNjIHx8IGRlc2MuaWdub3JlTXV0YXRpb24obXV0KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAobXV0LnR5cGUgPT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXQuYWRkZWROb2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBhZGRlZC5wdXNoKG11dC5hZGRlZE5vZGVzW2ldKTtcbiAgICAgICAgICAgIGlmIChkZXNjLmNvbnRlbnRET00gJiYgZGVzYy5jb250ZW50RE9NICE9IGRlc2MuZG9tICYmICFkZXNjLmNvbnRlbnRET00uY29udGFpbnMobXV0LnRhcmdldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGVzYy5wb3NCZWZvcmUsIHRvOiBkZXNjLnBvc0FmdGVyIH07XG4gICAgICAgICAgICBsZXQgcHJldiA9IG11dC5wcmV2aW91c1NpYmxpbmcsIG5leHQgPSBtdXQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBtdXQuYWRkZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBJRTExIGdpdmVzIHVzIGluY29ycmVjdCBuZXh0L3ByZXYgc2libGluZ3MgZm9yIHNvbWVcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnRpb25zLCBzbyBpZiB0aGVyZSBhcmUgYWRkZWQgbm9kZXMsIHJlY29tcHV0ZSB0aG9zZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgcHJldmlvdXNTaWJsaW5nLCBuZXh0U2libGluZyB9ID0gbXV0LmFkZGVkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldmlvdXNTaWJsaW5nIHx8IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobXV0LmFkZGVkTm9kZXMsIHByZXZpb3VzU2libGluZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IHByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0U2libGluZyB8fCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG11dC5hZGRlZE5vZGVzLCBuZXh0U2libGluZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmcm9tT2Zmc2V0ID0gcHJldiAmJiBwcmV2LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldFxuICAgICAgICAgICAgICAgID8gZG9tSW5kZXgocHJldikgKyAxIDogMDtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgZnJvbU9mZnNldCwgLTEpO1xuICAgICAgICAgICAgbGV0IHRvT2Zmc2V0ID0gbmV4dCAmJiBuZXh0LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldFxuICAgICAgICAgICAgICAgID8gZG9tSW5kZXgobmV4dCkgOiBtdXQudGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHRvID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgdG9PZmZzZXQsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtdXQudHlwZSA9PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIsIHRvOiBkZXNjLnBvc0F0RW5kICsgZGVzYy5ib3JkZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gXCJjaGFyYWN0ZXJEYXRhXCJcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogZGVzYy5wb3NBdFN0YXJ0LFxuICAgICAgICAgICAgICAgIHRvOiBkZXNjLnBvc0F0RW5kLFxuICAgICAgICAgICAgICAgIC8vIEFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgZm9yIGEgdGV4dCBjaGFuZ2UgdGhhdCBkaWRuJ3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgLy8gYW55IHRleHQuIE1hcmsgdGhlIGRvbSBjaGFuZ2UgdG8gZmFsbCBiYWNrIHRvIGFzc3VtaW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbGVjdGlvbiB3YXMgdHlwZWQgb3ZlciB3aXRoIGFuIGlkZW50aWNhbCB2YWx1ZSBpZiBpdCBjYW4ndFxuICAgICAgICAgICAgICAgIC8vIGZpbmQgYW5vdGhlciBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgdHlwZU92ZXI6IG11dC50YXJnZXQubm9kZVZhbHVlID09IG11dC5vbGRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBjc3NDaGVja2VkID0gbmV3IFdlYWtNYXAoKTtcbmxldCBjc3NDaGVja1dhcm5lZCA9IGZhbHNlO1xuZnVuY3Rpb24gY2hlY2tDU1Modmlldykge1xuICAgIGlmIChjc3NDaGVja2VkLmhhcyh2aWV3KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNzc0NoZWNrZWQuc2V0KHZpZXcsIG51bGwpO1xuICAgIGlmIChbJ25vcm1hbCcsICdub3dyYXAnLCAncHJlLWxpbmUnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUodmlldy5kb20pLndoaXRlU3BhY2UpICE9PSAtMSkge1xuICAgICAgICB2aWV3LnJlcXVpcmVzR2Vja29IYWNrTm9kZSA9IGdlY2tvO1xuICAgICAgICBpZiAoY3NzQ2hlY2tXYXJuZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGVbXCJ3YXJuXCJdKFwiUHJvc2VNaXJyb3IgZXhwZWN0cyB0aGUgQ1NTIHdoaXRlLXNwYWNlIHByb3BlcnR5IHRvIGJlIHNldCwgcHJlZmVyYWJseSB0byAncHJlLXdyYXAnLiBJdCBpcyByZWNvbW1lbmRlZCB0byBsb2FkIHN0eWxlL3Byb3NlbWlycm9yLmNzcyBmcm9tIHRoZSBwcm9zZW1pcnJvci12aWV3IHBhY2thZ2UuXCIpO1xuICAgICAgICBjc3NDaGVja1dhcm5lZCA9IHRydWU7XG4gICAgfVxufVxuLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSBTZWxlY3Rpb24vc2hhZG93IERPTSBidWdcbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvNDE0IGZpeFxuZnVuY3Rpb24gc2FmYXJpU2hhZG93U2VsZWN0aW9uUmFuZ2Uodmlldykge1xuICAgIGxldCBmb3VuZDtcbiAgICBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBmb3VuZCA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpWzBdO1xuICAgIH1cbiAgICAvLyBCZWNhdXNlIFNhZmFyaSAoYXQgbGVhc3QgaW4gMjAxOC0yMDIyKSBkb2Vzbid0IHByb3ZpZGUgcmVndWxhclxuICAgIC8vIGFjY2VzcyB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSBhIHNoYWRvd1Jvb3QsIHdlIGhhdmUgdG8gcGVyZm9ybSBhXG4gICAgLy8gcmlkaWN1bG91cyBoYWNrIHRvIGdldCBhdCBpdFx1MjAxNHVzaW5nIGBleGVjQ29tbWFuZGAgdG8gdHJpZ2dlciBhXG4gICAgLy8gYGJlZm9yZUlucHV0YCBldmVudCBzbyB0aGF0IHdlIGNhbiByZWFkIHRoZSB0YXJnZXQgcmFuZ2UgZnJvbSB0aGVcbiAgICAvLyBldmVudC5cbiAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJpbmRlbnRcIik7XG4gICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIGxldCBhbmNob3JOb2RlID0gZm91bmQuc3RhcnRDb250YWluZXIsIGFuY2hvck9mZnNldCA9IGZvdW5kLnN0YXJ0T2Zmc2V0O1xuICAgIGxldCBmb2N1c05vZGUgPSBmb3VuZC5lbmRDb250YWluZXIsIGZvY3VzT2Zmc2V0ID0gZm91bmQuZW5kT2Zmc2V0O1xuICAgIGxldCBjdXJyZW50QW5jaG9yID0gdmlldy5kb21BdFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IpO1xuICAgIC8vIFNpbmNlIHN1Y2ggYSByYW5nZSBkb2Vzbid0IGRpc3Rpbmd1aXNoIGJldHdlZW4gYW5jaG9yIGFuZCBoZWFkLFxuICAgIC8vIHVzZSBhIGhldXJpc3RpYyB0aGF0IGZsaXBzIGl0IGFyb3VuZCBpZiBpdHMgZW5kIG1hdGNoZXMgdGhlXG4gICAgLy8gY3VycmVudCBhbmNob3IuXG4gICAgaWYgKGlzRXF1aXZhbGVudFBvc2l0aW9uKGN1cnJlbnRBbmNob3Iubm9kZSwgY3VycmVudEFuY2hvci5vZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKVxuICAgICAgICBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSA9IFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0LCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdO1xuICAgIHJldHVybiB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9O1xufVxuXG4vLyBOb3RlIHRoYXQgYWxsIHJlZmVyZW5jaW5nIGFuZCBwYXJzaW5nIGlzIGRvbmUgd2l0aCB0aGVcbi8vIHN0YXJ0LW9mLW9wZXJhdGlvbiBzZWxlY3Rpb24gYW5kIGRvY3VtZW50LCBzaW5jZSB0aGF0J3MgdGhlIG9uZVxuLy8gdGhhdCB0aGUgRE9NIHJlcHJlc2VudHMuIElmIGFueSBjaGFuZ2VzIGNhbWUgaW4gaW4gdGhlIG1lYW50aW1lLFxuLy8gdGhlIG1vZGlmaWNhdGlvbiBpcyBtYXBwZWQgb3ZlciB0aG9zZSBiZWZvcmUgaXQgaXMgYXBwbGllZCwgaW5cbi8vIHJlYWRET01DaGFuZ2UuXG5mdW5jdGlvbiBwYXJzZUJldHdlZW4odmlldywgZnJvbV8sIHRvXykge1xuICAgIGxldCB7IG5vZGU6IHBhcmVudCwgZnJvbU9mZnNldCwgdG9PZmZzZXQsIGZyb20sIHRvIH0gPSB2aWV3LmRvY1ZpZXcucGFyc2VSYW5nZShmcm9tXywgdG9fKTtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBmaW5kO1xuICAgIGxldCBhbmNob3IgPSBkb21TZWwuYW5jaG9yTm9kZTtcbiAgICBpZiAoYW5jaG9yICYmIHZpZXcuZG9tLmNvbnRhaW5zKGFuY2hvci5ub2RlVHlwZSA9PSAxID8gYW5jaG9yIDogYW5jaG9yLnBhcmVudE5vZGUpKSB7XG4gICAgICAgIGZpbmQgPSBbeyBub2RlOiBhbmNob3IsIG9mZnNldDogZG9tU2VsLmFuY2hvck9mZnNldCB9XTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb25Db2xsYXBzZWQoZG9tU2VsKSlcbiAgICAgICAgICAgIGZpbmQucHVzaCh7IG5vZGU6IGRvbVNlbC5mb2N1c05vZGUsIG9mZnNldDogZG9tU2VsLmZvY3VzT2Zmc2V0IH0pO1xuICAgIH1cbiAgICAvLyBXb3JrIGFyb3VuZCBpc3N1ZSBpbiBDaHJvbWUgd2hlcmUgYmFja3NwYWNpbmcgc29tZXRpbWVzIHJlcGxhY2VzXG4gICAgLy8gdGhlIGRlbGV0ZWQgY29udGVudCB3aXRoIGEgcmFuZG9tIEJSIG5vZGUgKGlzc3VlcyAjNzk5LCAjODMxKVxuICAgIGlmIChjaHJvbWUgJiYgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gOCkge1xuICAgICAgICBmb3IgKGxldCBvZmYgPSB0b09mZnNldDsgb2ZmID4gZnJvbU9mZnNldDsgb2ZmLS0pIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gcGFyZW50LmNoaWxkTm9kZXNbb2ZmIC0gMV0sIGRlc2MgPSBub2RlLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgIWRlc2MpIHtcbiAgICAgICAgICAgICAgICB0b09mZnNldCA9IG9mZjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCBkZXNjLnNpemUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXJ0RG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgbGV0IHBhcnNlciA9IHZpZXcuc29tZVByb3AoXCJkb21QYXJzZXJcIikgfHwgRE9NUGFyc2VyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgIGxldCAkZnJvbSA9IHN0YXJ0RG9jLnJlc29sdmUoZnJvbSk7XG4gICAgbGV0IHNlbCA9IG51bGwsIGRvYyA9IHBhcnNlci5wYXJzZShwYXJlbnQsIHtcbiAgICAgICAgdG9wTm9kZTogJGZyb20ucGFyZW50LFxuICAgICAgICB0b3BNYXRjaDogJGZyb20ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4KCkpLFxuICAgICAgICB0b3BPcGVuOiB0cnVlLFxuICAgICAgICBmcm9tOiBmcm9tT2Zmc2V0LFxuICAgICAgICB0bzogdG9PZmZzZXQsXG4gICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJGZyb20ucGFyZW50LnR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiID8gXCJmdWxsXCIgOiB0cnVlLFxuICAgICAgICBmaW5kUG9zaXRpb25zOiBmaW5kLFxuICAgICAgICBydWxlRnJvbU5vZGUsXG4gICAgICAgIGNvbnRleHQ6ICRmcm9tXG4gICAgfSk7XG4gICAgaWYgKGZpbmQgJiYgZmluZFswXS5wb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgYW5jaG9yID0gZmluZFswXS5wb3MsIGhlYWQgPSBmaW5kWzFdICYmIGZpbmRbMV0ucG9zO1xuICAgICAgICBpZiAoaGVhZCA9PSBudWxsKVxuICAgICAgICAgICAgaGVhZCA9IGFuY2hvcjtcbiAgICAgICAgc2VsID0geyBhbmNob3I6IGFuY2hvciArIGZyb20sIGhlYWQ6IGhlYWQgKyBmcm9tIH07XG4gICAgfVxuICAgIHJldHVybiB7IGRvYywgc2VsLCBmcm9tLCB0byB9O1xufVxuZnVuY3Rpb24gcnVsZUZyb21Ob2RlKGRvbSkge1xuICAgIGxldCBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gICAgaWYgKGRlc2MpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MucGFyc2VSdWxlKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgLy8gU2FmYXJpIHJlcGxhY2VzIHRoZSBsaXN0IGl0ZW0gb3IgdGFibGUgY2VsbCB3aXRoIGEgQlJcbiAgICAgICAgLy8gZGlyZWN0bHkgaW4gdGhlIGxpc3Qgbm9kZSAoPyEpIGlmIHlvdSBkZWxldGUgdGhlIGxhc3RcbiAgICAgICAgLy8gY2hhcmFjdGVyIGluIGEgbGlzdCBpdGVtIG9yIHRhYmxlIGNlbGwgKCM3MDgsICM4NjIpXG4gICAgICAgIGlmIChzYWZhcmkgJiYgL14odWx8b2wpJC9pLnRlc3QoZG9tLnBhcmVudE5vZGUubm9kZU5hbWUpKSB7XG4gICAgICAgICAgICBsZXQgc2tpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBza2lwLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKSk7XG4gICAgICAgICAgICByZXR1cm4geyBza2lwIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9tLnBhcmVudE5vZGUubGFzdENoaWxkID09IGRvbSB8fCBzYWZhcmkgJiYgL14odHJ8dGFibGUpJC9pLnRlc3QoZG9tLnBhcmVudE5vZGUubm9kZU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpZ25vcmU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkb20ubm9kZU5hbWUgPT0gXCJJTUdcIiAmJiBkb20uZ2V0QXR0cmlidXRlKFwibWFyay1wbGFjZWhvbGRlclwiKSkge1xuICAgICAgICByZXR1cm4geyBpZ25vcmU6IHRydWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBpc0lubGluZSA9IC9eKGF8YWJicnxhY3JvbnltfGJ8YmRbaW9dfGJpZ3xicnxidXR0b258Y2l0ZXxjb2RlfGRhdGEobGlzdCk/fGRlbHxkZm58ZW18aXxpbnN8a2JkfGxhYmVsfG1hcHxtYXJrfG1ldGVyfG91dHB1dHxxfHJ1Ynl8c3xzYW1wfHNtYWxsfHNwYW58c3Ryb25nfHN1W2JwXXx0aW1lfHV8dHR8dmFyKSQvaTtcbmZ1bmN0aW9uIHJlYWRET01DaGFuZ2UodmlldywgZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZE5vZGVzKSB7XG4gICAgbGV0IGNvbXBvc2l0aW9uSUQgPSB2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgfHwgKHZpZXcuY29tcG9zaW5nID8gdmlldy5pbnB1dC5jb21wb3NpdGlvbklEIDogMCk7XG4gICAgdmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzID0gMDtcbiAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgbGV0IG9yaWdpbiA9IHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvblRpbWUgPiBEYXRlLm5vdygpIC0gNTAgPyB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25PcmlnaW4gOiBudWxsO1xuICAgICAgICBsZXQgbmV3U2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3LCBvcmlnaW4pO1xuICAgICAgICBpZiAobmV3U2VsICYmICF2aWV3LnN0YXRlLnNlbGVjdGlvbi5lcShuZXdTZWwpKSB7XG4gICAgICAgICAgICBpZiAoY2hyb21lICYmIGFuZHJvaWQgJiZcbiAgICAgICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09PSAxMyAmJiBEYXRlLm5vdygpIC0gMTAwIDwgdmlldy5pbnB1dC5sYXN0S2V5Q29kZVRpbWUgJiZcbiAgICAgICAgICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXdTZWwpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbiA9PSBcInBvaW50ZXJcIilcbiAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwicG9pbnRlclwiLCB0cnVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWdpbiA9PSBcImtleVwiKVxuICAgICAgICAgICAgICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiY29tcG9zaXRpb25cIiwgY29tcG9zaXRpb25JRCk7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCAkYmVmb3JlID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICBsZXQgc2hhcmVkID0gJGJlZm9yZS5zaGFyZWREZXB0aCh0byk7XG4gICAgZnJvbSA9ICRiZWZvcmUuYmVmb3JlKHNoYXJlZCArIDEpO1xuICAgIHRvID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSh0bykuYWZ0ZXIoc2hhcmVkICsgMSk7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBwYXJzZSA9IHBhcnNlQmV0d2Vlbih2aWV3LCBmcm9tLCB0byk7XG4gICAgbGV0IGRvYyA9IHZpZXcuc3RhdGUuZG9jLCBjb21wYXJlID0gZG9jLnNsaWNlKHBhcnNlLmZyb20sIHBhcnNlLnRvKTtcbiAgICBsZXQgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlO1xuICAgIC8vIFByZWZlciBhbmNob3JpbmcgdG8gZW5kIHdoZW4gQmFja3NwYWNlIGlzIHByZXNzZWRcbiAgICBpZiAodmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gOCAmJiBEYXRlLm5vdygpIC0gMTAwIDwgdmlldy5pbnB1dC5sYXN0S2V5Q29kZVRpbWUpIHtcbiAgICAgICAgcHJlZmVycmVkUG9zID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG87XG4gICAgICAgIHByZWZlcnJlZFNpZGUgPSBcImVuZFwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJlZmVycmVkUG9zID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbTtcbiAgICAgICAgcHJlZmVycmVkU2lkZSA9IFwic3RhcnRcIjtcbiAgICB9XG4gICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9IG51bGw7XG4gICAgbGV0IGNoYW5nZSA9IGZpbmREaWZmKGNvbXBhcmUuY29udGVudCwgcGFyc2UuZG9jLmNvbnRlbnQsIHBhcnNlLmZyb20sIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSk7XG4gICAgaWYgKChpb3MgJiYgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPiBEYXRlLm5vdygpIC0gMjI1IHx8IGFuZHJvaWQpICYmXG4gICAgICAgIGFkZGVkTm9kZXMuc29tZShuID0+IG4ubm9kZVR5cGUgPT0gMSAmJiAhaXNJbmxpbmUudGVzdChuLm5vZGVOYW1lKSkgJiZcbiAgICAgICAgKCFjaGFuZ2UgfHwgY2hhbmdlLmVuZEEgPj0gY2hhbmdlLmVuZEIpICYmXG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSkpKSB7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICBpZiAodHlwZU92ZXIgJiYgc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiAhc2VsLmVtcHR5ICYmIHNlbC4kaGVhZC5zYW1lUGFyZW50KHNlbC4kYW5jaG9yKSAmJlxuICAgICAgICAgICAgIXZpZXcuY29tcG9zaW5nICYmICEocGFyc2Uuc2VsICYmIHBhcnNlLnNlbC5hbmNob3IgIT0gcGFyc2Uuc2VsLmhlYWQpKSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSB7IHN0YXJ0OiBzZWwuZnJvbSwgZW5kQTogc2VsLnRvLCBlbmRCOiBzZWwudG8gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwYXJzZS5zZWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsID0gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCB2aWV3LnN0YXRlLmRvYywgcGFyc2Uuc2VsKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsICYmICFzZWwuZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb3NpdGlvbklEKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hyb21lIHNvbWV0aW1lcyBsZWF2ZXMgdGhlIGN1cnNvciBiZWZvcmUgdGhlIGluc2VydGVkIHRleHQgd2hlblxuICAgIC8vIGNvbXBvc2luZyBhZnRlciBhIGN1cnNvciB3cmFwcGVyLiBUaGlzIG1vdmVzIGl0IGZvcndhcmQuXG4gICAgaWYgKGNocm9tZSAmJiB2aWV3LmN1cnNvcldyYXBwZXIgJiYgcGFyc2Uuc2VsICYmIHBhcnNlLnNlbC5hbmNob3IgPT0gdmlldy5jdXJzb3JXcmFwcGVyLmRlY28uZnJvbSAmJlxuICAgICAgICBwYXJzZS5zZWwuaGVhZCA9PSBwYXJzZS5zZWwuYW5jaG9yKSB7XG4gICAgICAgIGxldCBzaXplID0gY2hhbmdlLmVuZEIgLSBjaGFuZ2Uuc3RhcnQ7XG4gICAgICAgIHBhcnNlLnNlbCA9IHsgYW5jaG9yOiBwYXJzZS5zZWwuYW5jaG9yICsgc2l6ZSwgaGVhZDogcGFyc2Uuc2VsLmFuY2hvciArIHNpemUgfTtcbiAgICB9XG4gICAgdmlldy5pbnB1dC5kb21DaGFuZ2VDb3VudCsrO1xuICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBvdmVyd3JpdGluZyBhIHNlbGVjdGlvbiBieSB0eXBpbmcgbWF0Y2hlc1xuICAgIC8vIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIHNlbGVjdGVkIGNvbnRlbnQsIGNyZWF0aW5nIGEgY2hhbmdlXG4gICAgLy8gdGhhdCdzIHNtYWxsZXIgdGhhbiB3aGF0IHdhcyBhY3R1YWxseSBvdmVyd3JpdHRlbi5cbiAgICBpZiAodmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvICYmXG4gICAgICAgIGNoYW5nZS5zdGFydCA9PSBjaGFuZ2UuZW5kQiAmJlxuICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKGNoYW5nZS5zdGFydCA+IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gJiYgY2hhbmdlLnN0YXJ0IDw9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gKyAyICYmXG4gICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tID49IHBhcnNlLmZyb20pIHtcbiAgICAgICAgICAgIGNoYW5nZS5zdGFydCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLmVuZEEgPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJiBjaGFuZ2UuZW5kQSA+PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAtIDIgJiZcbiAgICAgICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIDw9IHBhcnNlLnRvKSB7XG4gICAgICAgICAgICBjaGFuZ2UuZW5kQiArPSAodmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gLSBjaGFuZ2UuZW5kQSk7XG4gICAgICAgICAgICBjaGFuZ2UuZW5kQSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElFMTEgd2lsbCBpbnNlcnQgYSBub24tYnJlYWtpbmcgc3BhY2UgX2FoZWFkXyBvZiB0aGUgc3BhY2UgYWZ0ZXJcbiAgICAvLyB0aGUgY3Vyc29yIHNwYWNlIHdoZW4gYWRkaW5nIGEgc3BhY2UgYmVmb3JlIGFub3RoZXIgc3BhY2UuIFdoZW5cbiAgICAvLyB0aGF0IGhhcHBlbmVkLCBhZGp1c3QgdGhlIGNoYW5nZSB0byBjb3ZlciB0aGUgc3BhY2UgaW5zdGVhZC5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBjaGFuZ2UuZW5kQiA9PSBjaGFuZ2Uuc3RhcnQgKyAxICYmXG4gICAgICAgIGNoYW5nZS5lbmRBID09IGNoYW5nZS5zdGFydCAmJiBjaGFuZ2Uuc3RhcnQgPiBwYXJzZS5mcm9tICYmXG4gICAgICAgIHBhcnNlLmRvYy50ZXh0QmV0d2VlbihjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tIC0gMSwgY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSArIDEpID09IFwiIFxcdTAwYTBcIikge1xuICAgICAgICBjaGFuZ2Uuc3RhcnQtLTtcbiAgICAgICAgY2hhbmdlLmVuZEEtLTtcbiAgICAgICAgY2hhbmdlLmVuZEItLTtcbiAgICB9XG4gICAgbGV0ICRmcm9tID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20pO1xuICAgIGxldCAkdG8gPSBwYXJzZS5kb2MucmVzb2x2ZU5vQ2FjaGUoY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKTtcbiAgICBsZXQgJGZyb21BID0gZG9jLnJlc29sdmUoY2hhbmdlLnN0YXJ0KTtcbiAgICBsZXQgaW5saW5lQ2hhbmdlID0gJGZyb20uc2FtZVBhcmVudCgkdG8pICYmICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50ICYmICRmcm9tQS5lbmQoKSA+PSBjaGFuZ2UuZW5kQTtcbiAgICBsZXQgbmV4dFNlbDtcbiAgICAvLyBJZiB0aGlzIGxvb2tzIGxpa2UgdGhlIGVmZmVjdCBvZiBwcmVzc2luZyBFbnRlciAob3Igd2FzIHJlY29yZGVkXG4gICAgLy8gYXMgYmVpbmcgYW4gaU9TIGVudGVyIHByZXNzKSwganVzdCBkaXNwYXRjaCBhbiBFbnRlciBrZXkgaW5zdGVhZC5cbiAgICBpZiAoKChpb3MgJiYgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPiBEYXRlLm5vdygpIC0gMjI1ICYmXG4gICAgICAgICghaW5saW5lQ2hhbmdlIHx8IGFkZGVkTm9kZXMuc29tZShuID0+IG4ubm9kZU5hbWUgPT0gXCJESVZcIiB8fCBuLm5vZGVOYW1lID09IFwiUFwiKSkpIHx8XG4gICAgICAgICghaW5saW5lQ2hhbmdlICYmICRmcm9tLnBvcyA8IHBhcnNlLmRvYy5jb250ZW50LnNpemUgJiYgISRmcm9tLnNhbWVQYXJlbnQoJHRvKSAmJlxuICAgICAgICAgICAgKG5leHRTZWwgPSBTZWxlY3Rpb24uZmluZEZyb20ocGFyc2UuZG9jLnJlc29sdmUoJGZyb20ucG9zICsgMSksIDEsIHRydWUpKSAmJlxuICAgICAgICAgICAgbmV4dFNlbC5oZWFkID09ICR0by5wb3MpKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSkge1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU2FtZSBmb3IgYmFja3NwYWNlXG4gICAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciA+IGNoYW5nZS5zdGFydCAmJlxuICAgICAgICBsb29rc0xpa2VKb2luKGRvYywgY2hhbmdlLnN0YXJ0LCBjaGFuZ2UuZW5kQSwgJGZyb20sICR0bykgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKSkpIHtcbiAgICAgICAgaWYgKGFuZHJvaWQgJiYgY2hyb21lKVxuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKTsgLy8gIzgyMFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENocm9tZSBBbmRyb2lkIHdpbGwgb2NjYXNpb25hbGx5LCBkdXJpbmcgY29tcG9zaXRpb24sIGRlbGV0ZSB0aGVcbiAgICAvLyBlbnRpcmUgY29tcG9zaXRpb24gYW5kIHRoZW4gaW1tZWRpYXRlbHkgaW5zZXJ0IGl0IGFnYWluLiBUaGlzIGlzXG4gICAgLy8gdXNlZCB0byBkZXRlY3QgdGhhdCBzaXR1YXRpb24uXG4gICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmIGNoYW5nZS5lbmRCID09IGNoYW5nZS5zdGFydClcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0QW5kcm9pZERlbGV0ZSA9IERhdGUubm93KCk7XG4gICAgLy8gVGhpcyB0cmllcyB0byBkZXRlY3QgQW5kcm9pZCB2aXJ0dWFsIGtleWJvYXJkXG4gICAgLy8gZW50ZXItYW5kLXBpY2stc3VnZ2VzdGlvbiBhY3Rpb24uIFRoYXQgc29tZXRpbWVzIChzZWUgaXNzdWVcbiAgICAvLyAjMTA1OSkgZmlyc3QgZmlyZXMgYSBET00gbXV0YXRpb24sIGJlZm9yZSBtb3ZpbmcgdGhlIHNlbGVjdGlvbiB0b1xuICAgIC8vIHRoZSBuZXdseSBjcmVhdGVkIGJsb2NrLiBBbmQgdGhlbiwgYmVjYXVzZSBQcm9zZU1pcnJvciBjbGVhbnMgdXBcbiAgICAvLyB0aGUgRE9NIHNlbGVjdGlvbiwgaXQgZ2l2ZXMgdXAgbW92aW5nIHRoZSBzZWxlY3Rpb24gZW50aXJlbHksXG4gICAgLy8gbGVhdmluZyB0aGUgY3Vyc29yIGluIHRoZSB3cm9uZyBwbGFjZS4gV2hlbiB0aGF0IGhhcHBlbnMsIHdlIGRyb3BcbiAgICAvLyB0aGUgbmV3IHBhcmFncmFwaCBmcm9tIHRoZSBpbml0aWFsIGNoYW5nZSwgYW5kIGZpcmUgYSBzaW11bGF0ZWRcbiAgICAvLyBlbnRlciBrZXkgYWZ0ZXJ3YXJkcy5cbiAgICBpZiAoYW5kcm9pZCAmJiAhaW5saW5lQ2hhbmdlICYmICRmcm9tLnN0YXJ0KCkgIT0gJHRvLnN0YXJ0KCkgJiYgJHRvLnBhcmVudE9mZnNldCA9PSAwICYmICRmcm9tLmRlcHRoID09ICR0by5kZXB0aCAmJlxuICAgICAgICBwYXJzZS5zZWwgJiYgcGFyc2Uuc2VsLmFuY2hvciA9PSBwYXJzZS5zZWwuaGVhZCAmJiBwYXJzZS5zZWwuaGVhZCA9PSBjaGFuZ2UuZW5kQSkge1xuICAgICAgICBjaGFuZ2UuZW5kQiAtPSAyO1xuICAgICAgICAkdG8gPSBwYXJzZS5kb2MucmVzb2x2ZU5vQ2FjaGUoY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSk7IH0pO1xuICAgICAgICB9LCAyMCk7XG4gICAgfVxuICAgIGxldCBjaEZyb20gPSBjaGFuZ2Uuc3RhcnQsIGNoVG8gPSBjaGFuZ2UuZW5kQTtcbiAgICBsZXQgdHIsIHN0b3JlZE1hcmtzLCBtYXJrQ2hhbmdlO1xuICAgIGlmIChpbmxpbmVDaGFuZ2UpIHtcbiAgICAgICAgaWYgKCRmcm9tLnBvcyA9PSAkdG8ucG9zKSB7IC8vIERlbGV0aW9uXG4gICAgICAgICAgICAvLyBJRTExIHNvbWV0aW1lcyB3ZWlyZGx5IG1vdmVzIHRoZSBET00gc2VsZWN0aW9uIGFyb3VuZCBhZnRlclxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgb3V0IHRoZSBmaXJzdCBlbGVtZW50IGluIGEgdGV4dGJsb2NrXG4gICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiAkZnJvbS5wYXJlbnRPZmZzZXQgPT0gMCkge1xuICAgICAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZWxlY3Rpb25Ub0RPTSh2aWV3KSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLmRlbGV0ZShjaEZyb20sIGNoVG8pO1xuICAgICAgICAgICAgc3RvcmVkTWFya3MgPSBkb2MucmVzb2x2ZShjaGFuZ2Uuc3RhcnQpLm1hcmtzQWNyb3NzKGRvYy5yZXNvbHZlKGNoYW5nZS5lbmRBKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIC8vIEFkZGluZyBvciByZW1vdmluZyBhIG1hcmtcbiAgICAgICAgY2hhbmdlLmVuZEEgPT0gY2hhbmdlLmVuZEIgJiZcbiAgICAgICAgICAgIChtYXJrQ2hhbmdlID0gaXNNYXJrQ2hhbmdlKCRmcm9tLnBhcmVudC5jb250ZW50LmN1dCgkZnJvbS5wYXJlbnRPZmZzZXQsICR0by5wYXJlbnRPZmZzZXQpLCAkZnJvbUEucGFyZW50LmNvbnRlbnQuY3V0KCRmcm9tQS5wYXJlbnRPZmZzZXQsIGNoYW5nZS5lbmRBIC0gJGZyb21BLnN0YXJ0KCkpKSkpIHtcbiAgICAgICAgICAgIHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICAgICAgICAgIGlmIChtYXJrQ2hhbmdlLnR5cGUgPT0gXCJhZGRcIilcbiAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGNoRnJvbSwgY2hUbywgbWFya0NoYW5nZS5tYXJrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0ci5yZW1vdmVNYXJrKGNoRnJvbSwgY2hUbywgbWFya0NoYW5nZS5tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgkZnJvbS5wYXJlbnQuY2hpbGQoJGZyb20uaW5kZXgoKSkuaXNUZXh0ICYmICRmcm9tLmluZGV4KCkgPT0gJHRvLmluZGV4KCkgLSAoJHRvLnRleHRPZmZzZXQgPyAwIDogMSkpIHtcbiAgICAgICAgICAgIC8vIEJvdGggcG9zaXRpb25zIGluIHRoZSBzYW1lIHRleHQgbm9kZSAtLSBzaW1wbHkgaW5zZXJ0IHRleHRcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gJGZyb20ucGFyZW50LnRleHRCZXR3ZWVuKCRmcm9tLnBhcmVudE9mZnNldCwgJHRvLnBhcmVudE9mZnNldCk7XG4gICAgICAgICAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmID0+IGYodmlldywgY2hGcm9tLCBjaFRvLCB0ZXh0KSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLmluc2VydFRleHQodGV4dCwgY2hGcm9tLCBjaFRvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRyKVxuICAgICAgICB0ciA9IHZpZXcuc3RhdGUudHIucmVwbGFjZShjaEZyb20sIGNoVG8sIHBhcnNlLmRvYy5zbGljZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tLCBjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pKTtcbiAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgIGxldCBzZWwgPSByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIHRyLmRvYywgcGFyc2Uuc2VsKTtcbiAgICAgICAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBzb21ldGltZXMsIGR1cmluZyBjb21wb3NpdGlvbiwgcmVwb3J0IHRoZVxuICAgICAgICAvLyBzZWxlY3Rpb24gaW4gdGhlIHdyb25nIHBsYWNlLiBJZiBpdCBsb29rcyBsaWtlIHRoYXQgaXNcbiAgICAgICAgLy8gaGFwcGVuaW5nLCBkb24ndCB1cGRhdGUgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgLy8gRWRnZSBqdXN0IGRvZXNuJ3QgbW92ZSB0aGUgY3Vyc29yIGZvcndhcmQgd2hlbiB5b3Ugc3RhcnQgdHlwaW5nXG4gICAgICAgIC8vIGluIGFuIGVtcHR5IGJsb2NrIG9yIGJldHdlZW4gYnIgbm9kZXMuXG4gICAgICAgIGlmIChzZWwgJiYgIShjaHJvbWUgJiYgYW5kcm9pZCAmJiB2aWV3LmNvbXBvc2luZyAmJiBzZWwuZW1wdHkgJiZcbiAgICAgICAgICAgIChjaGFuZ2Uuc3RhcnQgIT0gY2hhbmdlLmVuZEIgfHwgdmlldy5pbnB1dC5sYXN0QW5kcm9pZERlbGV0ZSA8IERhdGUubm93KCkgLSAxMDApICYmXG4gICAgICAgICAgICAoc2VsLmhlYWQgPT0gY2hGcm9tIHx8IHNlbC5oZWFkID09IHRyLm1hcHBpbmcubWFwKGNoVG8pIC0gMSkgfHxcbiAgICAgICAgICAgIGllICYmIHNlbC5lbXB0eSAmJiBzZWwuaGVhZCA9PSBjaEZyb20pKVxuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbCk7XG4gICAgfVxuICAgIGlmIChzdG9yZWRNYXJrcylcbiAgICAgICAgdHIuZW5zdXJlTWFya3Moc3RvcmVkTWFya3MpO1xuICAgIGlmIChjb21wb3NpdGlvbklEKVxuICAgICAgICB0ci5zZXRNZXRhKFwiY29tcG9zaXRpb25cIiwgY29tcG9zaXRpb25JRCk7XG4gICAgdmlldy5kaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTZWxlY3Rpb24odmlldywgZG9jLCBwYXJzZWRTZWwpIHtcbiAgICBpZiAoTWF0aC5tYXgocGFyc2VkU2VsLmFuY2hvciwgcGFyc2VkU2VsLmhlYWQpID4gZG9jLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHNlbGVjdGlvbkJldHdlZW4odmlldywgZG9jLnJlc29sdmUocGFyc2VkU2VsLmFuY2hvciksIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5oZWFkKSk7XG59XG4vLyBHaXZlbiB0d28gc2FtZS1sZW5ndGgsIG5vbi1lbXB0eSBmcmFnbWVudHMgb2YgaW5saW5lIGNvbnRlbnQsXG4vLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgZmlyc3QgY291bGQgYmUgY3JlYXRlZCBmcm9tIHRoZSBzZWNvbmQgYnlcbi8vIHJlbW92aW5nIG9yIGFkZGluZyBhIHNpbmdsZSBtYXJrIHR5cGUuXG5mdW5jdGlvbiBpc01hcmtDaGFuZ2UoY3VyLCBwcmV2KSB7XG4gICAgbGV0IGN1ck1hcmtzID0gY3VyLmZpcnN0Q2hpbGQubWFya3MsIHByZXZNYXJrcyA9IHByZXYuZmlyc3RDaGlsZC5tYXJrcztcbiAgICBsZXQgYWRkZWQgPSBjdXJNYXJrcywgcmVtb3ZlZCA9IHByZXZNYXJrcywgdHlwZSwgbWFyaywgdXBkYXRlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldk1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICBhZGRlZCA9IHByZXZNYXJrc1tpXS5yZW1vdmVGcm9tU2V0KGFkZGVkKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ck1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICByZW1vdmVkID0gY3VyTWFya3NbaV0ucmVtb3ZlRnJvbVNldChyZW1vdmVkKTtcbiAgICBpZiAoYWRkZWQubGVuZ3RoID09IDEgJiYgcmVtb3ZlZC5sZW5ndGggPT0gMCkge1xuICAgICAgICBtYXJrID0gYWRkZWRbMF07XG4gICAgICAgIHR5cGUgPSBcImFkZFwiO1xuICAgICAgICB1cGRhdGUgPSAobm9kZSkgPT4gbm9kZS5tYXJrKG1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhZGRlZC5sZW5ndGggPT0gMCAmJiByZW1vdmVkLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIG1hcmsgPSByZW1vdmVkWzBdO1xuICAgICAgICB0eXBlID0gXCJyZW1vdmVcIjtcbiAgICAgICAgdXBkYXRlID0gKG5vZGUpID0+IG5vZGUubWFyayhtYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCB1cGRhdGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgdXBkYXRlZC5wdXNoKHVwZGF0ZShwcmV2LmNoaWxkKGkpKSk7XG4gICAgaWYgKEZyYWdtZW50LmZyb20odXBkYXRlZCkuZXEoY3VyKSlcbiAgICAgICAgcmV0dXJuIHsgbWFyaywgdHlwZSB9O1xufVxuZnVuY3Rpb24gbG9va3NMaWtlSm9pbihvbGQsIHN0YXJ0LCBlbmQsICRuZXdTdGFydCwgJG5ld0VuZCkge1xuICAgIGlmICghJG5ld1N0YXJ0LnBhcmVudC5pc1RleHRibG9jayB8fFxuICAgICAgICAvLyBUaGUgY29udGVudCBtdXN0IGhhdmUgc2hydW5rXG4gICAgICAgIGVuZCAtIHN0YXJ0IDw9ICRuZXdFbmQucG9zIC0gJG5ld1N0YXJ0LnBvcyB8fFxuICAgICAgICAvLyBuZXdFbmQgbXVzdCBwb2ludCBkaXJlY3RseSBhdCBvciBhZnRlciB0aGUgZW5kIG9mIHRoZSBibG9jayB0aGF0IG5ld1N0YXJ0IHBvaW50cyBpbnRvXG4gICAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV3U3RhcnQsIHRydWUsIGZhbHNlKSA8ICRuZXdFbmQucG9zKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRzdGFydCA9IG9sZC5yZXNvbHZlKHN0YXJ0KTtcbiAgICAvLyBTdGFydCBtdXN0IGJlIGF0IHRoZSBlbmQgb2YgYSBibG9ja1xuICAgIGlmICgkc3RhcnQucGFyZW50T2Zmc2V0IDwgJHN0YXJ0LnBhcmVudC5jb250ZW50LnNpemUgfHwgISRzdGFydC5wYXJlbnQuaXNUZXh0YmxvY2spXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJG5leHQgPSBvbGQucmVzb2x2ZShza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJHN0YXJ0LCB0cnVlLCB0cnVlKSk7XG4gICAgLy8gVGhlIG5leHQgdGV4dGJsb2NrIG11c3Qgc3RhcnQgYmVmb3JlIGVuZCBhbmQgZW5kIG5lYXIgaXRcbiAgICBpZiAoISRuZXh0LnBhcmVudC5pc1RleHRibG9jayB8fCAkbmV4dC5wb3MgPiBlbmQgfHxcbiAgICAgICAgc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRuZXh0LCB0cnVlLCBmYWxzZSkgPCBlbmQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBUaGUgZnJhZ21lbnRzIGFmdGVyIHRoZSBqb2luIHBvaW50IG11c3QgbWF0Y2hcbiAgICByZXR1cm4gJG5ld1N0YXJ0LnBhcmVudC5jb250ZW50LmN1dCgkbmV3U3RhcnQucGFyZW50T2Zmc2V0KS5lcSgkbmV4dC5wYXJlbnQuY29udGVudCk7XG59XG5mdW5jdGlvbiBza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJHBvcywgZnJvbUVuZCwgbWF5T3Blbikge1xuICAgIGxldCBkZXB0aCA9ICRwb3MuZGVwdGgsIGVuZCA9IGZyb21FbmQgPyAkcG9zLmVuZCgpIDogJHBvcy5wb3M7XG4gICAgd2hpbGUgKGRlcHRoID4gMCAmJiAoZnJvbUVuZCB8fCAkcG9zLmluZGV4QWZ0ZXIoZGVwdGgpID09ICRwb3Mubm9kZShkZXB0aCkuY2hpbGRDb3VudCkpIHtcbiAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgZW5kKys7XG4gICAgICAgIGZyb21FbmQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG1heU9wZW4pIHtcbiAgICAgICAgbGV0IG5leHQgPSAkcG9zLm5vZGUoZGVwdGgpLm1heWJlQ2hpbGQoJHBvcy5pbmRleEFmdGVyKGRlcHRoKSk7XG4gICAgICAgIHdoaWxlIChuZXh0ICYmICFuZXh0LmlzTGVhZikge1xuICAgICAgICAgICAgbmV4dCA9IG5leHQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmQ7XG59XG5mdW5jdGlvbiBmaW5kRGlmZihhLCBiLCBwb3MsIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSkge1xuICAgIGxldCBzdGFydCA9IGEuZmluZERpZmZTdGFydChiLCBwb3MpO1xuICAgIGlmIChzdGFydCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgeyBhOiBlbmRBLCBiOiBlbmRCIH0gPSBhLmZpbmREaWZmRW5kKGIsIHBvcyArIGEuc2l6ZSwgcG9zICsgYi5zaXplKTtcbiAgICBpZiAocHJlZmVycmVkU2lkZSA9PSBcImVuZFwiKSB7XG4gICAgICAgIGxldCBhZGp1c3QgPSBNYXRoLm1heCgwLCBzdGFydCAtIE1hdGgubWluKGVuZEEsIGVuZEIpKTtcbiAgICAgICAgcHJlZmVycmVkUG9zIC09IGVuZEEgKyBhZGp1c3QgLSBzdGFydDtcbiAgICB9XG4gICAgaWYgKGVuZEEgPCBzdGFydCAmJiBhLnNpemUgPCBiLnNpemUpIHtcbiAgICAgICAgbGV0IG1vdmUgPSBwcmVmZXJyZWRQb3MgPD0gc3RhcnQgJiYgcHJlZmVycmVkUG9zID49IGVuZEEgPyBzdGFydCAtIHByZWZlcnJlZFBvcyA6IDA7XG4gICAgICAgIHN0YXJ0IC09IG1vdmU7XG4gICAgICAgIGlmIChzdGFydCAmJiBzdGFydCA8IGIuc2l6ZSAmJiBpc1N1cnJvZ2F0ZVBhaXIoYi50ZXh0QmV0d2VlbihzdGFydCAtIDEsIHN0YXJ0ICsgMSkpKVxuICAgICAgICAgICAgc3RhcnQgKz0gbW92ZSA/IDEgOiAtMTtcbiAgICAgICAgZW5kQiA9IHN0YXJ0ICsgKGVuZEIgLSBlbmRBKTtcbiAgICAgICAgZW5kQSA9IHN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIGlmIChlbmRCIDwgc3RhcnQpIHtcbiAgICAgICAgbGV0IG1vdmUgPSBwcmVmZXJyZWRQb3MgPD0gc3RhcnQgJiYgcHJlZmVycmVkUG9zID49IGVuZEIgPyBzdGFydCAtIHByZWZlcnJlZFBvcyA6IDA7XG4gICAgICAgIHN0YXJ0IC09IG1vdmU7XG4gICAgICAgIGlmIChzdGFydCAmJiBzdGFydCA8IGEuc2l6ZSAmJiBpc1N1cnJvZ2F0ZVBhaXIoYS50ZXh0QmV0d2VlbihzdGFydCAtIDEsIHN0YXJ0ICsgMSkpKVxuICAgICAgICAgICAgc3RhcnQgKz0gbW92ZSA/IDEgOiAtMTtcbiAgICAgICAgZW5kQSA9IHN0YXJ0ICsgKGVuZEEgLSBlbmRCKTtcbiAgICAgICAgZW5kQiA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydCwgZW5kQSwgZW5kQiB9O1xufVxuZnVuY3Rpb24gaXNTdXJyb2dhdGVQYWlyKHN0cikge1xuICAgIGlmIChzdHIubGVuZ3RoICE9IDIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYSA9IHN0ci5jaGFyQ29kZUF0KDApLCBiID0gc3RyLmNoYXJDb2RlQXQoMSk7XG4gICAgcmV0dXJuIGEgPj0gMHhEQzAwICYmIGEgPD0gMHhERkZGICYmIGIgPj0gMHhEODAwICYmIGIgPD0gMHhEQkZGO1xufVxuXG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fc2VyaWFsaXplRm9yQ2xpcGJvYXJkID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkO1xuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX3BhcnNlRnJvbUNsaXBib2FyZCA9IHBhcnNlRnJvbUNsaXBib2FyZDtcbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX19lbmRDb21wb3NpdGlvbiA9IGVuZENvbXBvc2l0aW9uO1xuLyoqXG5BbiBlZGl0b3IgdmlldyBtYW5hZ2VzIHRoZSBET00gc3RydWN0dXJlIHRoYXQgcmVwcmVzZW50cyBhblxuZWRpdGFibGUgZG9jdW1lbnQuIEl0cyBzdGF0ZSBhbmQgYmVoYXZpb3IgYXJlIGRldGVybWluZWQgYnkgaXRzXG5bcHJvcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRpcmVjdEVkaXRvclByb3BzKS5cbiovXG5jbGFzcyBFZGl0b3JWaWV3IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB2aWV3LiBgcGxhY2VgIG1heSBiZSBhIERPTSBub2RlIHRoYXQgdGhlIGVkaXRvciBzaG91bGRcbiAgICBiZSBhcHBlbmRlZCB0bywgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcGxhY2UgaXQgaW50byB0aGUgZG9jdW1lbnQsXG4gICAgb3IgYW4gb2JqZWN0IHdob3NlIGBtb3VudGAgcHJvcGVydHkgaG9sZHMgdGhlIG5vZGUgdG8gdXNlIGFzIHRoZVxuICAgIGRvY3VtZW50IGNvbnRhaW5lci4gSWYgaXQgaXMgYG51bGxgLCB0aGUgZWRpdG9yIHdpbGwgbm90IGJlXG4gICAgYWRkZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IocGxhY2UsIHByb3BzKSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgS2x1ZGdlIHVzZWQgdG8gd29yayBhcm91bmQgYSBDaHJvbWUgYnVnIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyYWNrV3JpdGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnNvcldyYXBwZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnB1dCA9IG5ldyBJbnB1dFN0YXRlO1xuICAgICAgICB0aGlzLnByZXZEaXJlY3RQbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMucGx1Z2luVmlld3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEhvbGRzIGB0cnVlYCB3aGVuIGEgaGFjayBub2RlIGlzIG5lZWRlZCBpbiBGaXJlZm94IHRvIHByZXZlbnQgdGhlXG4gICAgICAgIFtzcGFjZSBpcyBlYXRlbiBpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yL2lzc3Vlcy82NTEpXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlcXVpcmVzR2Vja29IYWNrTm9kZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgV2hlbiBlZGl0b3IgY29udGVudCBpcyBiZWluZyBkcmFnZ2VkLCB0aGlzIG9iamVjdCBjb250YWluc1xuICAgICAgICBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZHJhZ2dlZCBzbGljZSBhbmQgd2hldGhlciBpdCBpcyBiZWluZ1xuICAgICAgICBjb3BpZWQgb3IgbW92ZWQuIEF0IGFueSBvdGhlciB0aW1lLCBpdCBpcyBudWxsLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHByb3BzLnN0YXRlO1xuICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMgPSBwcm9wcy5wbHVnaW5zIHx8IFtdO1xuICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMuZm9yRWFjaChjaGVja1N0YXRlQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kb20gPSAocGxhY2UgJiYgcGxhY2UubW91bnQpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmIChwbGFjZSkge1xuICAgICAgICAgICAgaWYgKHBsYWNlLmFwcGVuZENoaWxkKVxuICAgICAgICAgICAgICAgIHBsYWNlLmFwcGVuZENoaWxkKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwbGFjZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgcGxhY2UodGhpcy5kb20pO1xuICAgICAgICAgICAgZWxzZSBpZiAocGxhY2UubW91bnQpXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRhYmxlID0gZ2V0RWRpdGFibGUodGhpcyk7XG4gICAgICAgIHVwZGF0ZUN1cnNvcldyYXBwZXIodGhpcyk7XG4gICAgICAgIHRoaXMubm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IGRvY1ZpZXdEZXNjKHRoaXMuc3RhdGUuZG9jLCBjb21wdXRlRG9jRGVjbyh0aGlzKSwgdmlld0RlY29yYXRpb25zKHRoaXMpLCB0aGlzLmRvbSwgdGhpcyk7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIgPSBuZXcgRE9NT2JzZXJ2ZXIodGhpcywgKGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpID0+IHJlYWRET01DaGFuZ2UodGhpcywgZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZCkpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIGluaXRJbnB1dCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5WaWV3cygpO1xuICAgIH1cbiAgICAvKipcbiAgICBIb2xkcyBgdHJ1ZWAgd2hlbiBhXG4gICAgW2NvbXBvc2l0aW9uXShodHRwczovL3czYy5naXRodWIuaW8vdWlldmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50cylcbiAgICBpcyBhY3RpdmUuXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaW5nKCkgeyByZXR1cm4gdGhpcy5pbnB1dC5jb21wb3Npbmc7IH1cbiAgICAvKipcbiAgICBUaGUgdmlldydzIGN1cnJlbnQgW3Byb3BzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcykuXG4gICAgKi9cbiAgICBnZXQgcHJvcHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9wcy5zdGF0ZSAhPSB0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRoaXMuX3Byb3BzO1xuICAgICAgICAgICAgdGhpcy5fcHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJldilcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9wc1tuYW1lXSA9IHByZXZbbmFtZV07XG4gICAgICAgICAgICB0aGlzLl9wcm9wcy5zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHZpZXcncyBwcm9wcy4gV2lsbCBpbW1lZGlhdGVseSBjYXVzZSBhbiB1cGRhdGUgdG9cbiAgICB0aGUgRE9NLlxuICAgICovXG4gICAgdXBkYXRlKHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wcy5oYW5kbGVET01FdmVudHMgIT0gdGhpcy5fcHJvcHMuaGFuZGxlRE9NRXZlbnRzKVxuICAgICAgICAgICAgZW5zdXJlTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBsZXQgcHJldlByb3BzID0gdGhpcy5fcHJvcHM7XG4gICAgICAgIHRoaXMuX3Byb3BzID0gcHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICBwcm9wcy5wbHVnaW5zLmZvckVhY2goY2hlY2tTdGF0ZUNvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMgPSBwcm9wcy5wbHVnaW5zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVJbm5lcihwcm9wcy5zdGF0ZSwgcHJldlByb3BzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3IGJ5IHVwZGF0aW5nIGV4aXN0aW5nIHByb3BzIG9iamVjdCB3aXRoIHRoZSBvYmplY3RcbiAgICBnaXZlbiBhcyBhcmd1bWVudC4gRXF1aXZhbGVudCB0byBgdmlldy51cGRhdGUoT2JqZWN0LmFzc2lnbih7fSxcbiAgICB2aWV3LnByb3BzLCBwcm9wcykpYC5cbiAgICAqL1xuICAgIHNldFByb3BzKHByb3BzKSB7XG4gICAgICAgIGxldCB1cGRhdGVkID0ge307XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5fcHJvcHMpXG4gICAgICAgICAgICB1cGRhdGVkW25hbWVdID0gdGhpcy5fcHJvcHNbbmFtZV07XG4gICAgICAgIHVwZGF0ZWQuc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByb3BzKVxuICAgICAgICAgICAgdXBkYXRlZFtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgICB0aGlzLnVwZGF0ZSh1cGRhdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSBlZGl0b3IncyBgc3RhdGVgIHByb3AsIHdpdGhvdXQgdG91Y2hpbmcgYW55IG9mIHRoZVxuICAgIG90aGVyIHByb3BzLlxuICAgICovXG4gICAgdXBkYXRlU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUlubmVyKHN0YXRlLCB0aGlzLl9wcm9wcyk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlSW5uZXIoc3RhdGUsIHByZXZQcm9wcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBwcmV2ID0gdGhpcy5zdGF0ZSwgcmVkcmF3ID0gZmFsc2UsIHVwZGF0ZVNlbCA9IGZhbHNlO1xuICAgICAgICAvLyBXaGVuIHN0b3JlZCBtYXJrcyBhcmUgYWRkZWQsIHN0b3AgY29tcG9zaXRpb24sIHNvIHRoYXQgdGhleSBjYW5cbiAgICAgICAgLy8gYmUgZGlzcGxheWVkLlxuICAgICAgICBpZiAoc3RhdGUuc3RvcmVkTWFya3MgJiYgdGhpcy5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgIGNsZWFyQ29tcG9zaXRpb24odGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVTZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgbGV0IHBsdWdpbnNDaGFuZ2VkID0gcHJldi5wbHVnaW5zICE9IHN0YXRlLnBsdWdpbnMgfHwgdGhpcy5fcHJvcHMucGx1Z2lucyAhPSBwcmV2UHJvcHMucGx1Z2lucztcbiAgICAgICAgaWYgKHBsdWdpbnNDaGFuZ2VkIHx8IHRoaXMuX3Byb3BzLnBsdWdpbnMgIT0gcHJldlByb3BzLnBsdWdpbnMgfHwgdGhpcy5fcHJvcHMubm9kZVZpZXdzICE9IHByZXZQcm9wcy5ub2RlVmlld3MpIHtcbiAgICAgICAgICAgIGxldCBub2RlVmlld3MgPSBidWlsZE5vZGVWaWV3cyh0aGlzKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkTm9kZVZpZXdzKG5vZGVWaWV3cywgdGhpcy5ub2RlVmlld3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlVmlld3MgPSBub2RlVmlld3M7XG4gICAgICAgICAgICAgICAgcmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGx1Z2luc0NoYW5nZWQgfHwgcHJldlByb3BzLmhhbmRsZURPTUV2ZW50cyAhPSB0aGlzLl9wcm9wcy5oYW5kbGVET01FdmVudHMpIHtcbiAgICAgICAgICAgIGVuc3VyZUxpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRhYmxlID0gZ2V0RWRpdGFibGUodGhpcyk7XG4gICAgICAgIHVwZGF0ZUN1cnNvcldyYXBwZXIodGhpcyk7XG4gICAgICAgIGxldCBpbm5lckRlY28gPSB2aWV3RGVjb3JhdGlvbnModGhpcyksIG91dGVyRGVjbyA9IGNvbXB1dGVEb2NEZWNvKHRoaXMpO1xuICAgICAgICBsZXQgc2Nyb2xsID0gcHJldi5wbHVnaW5zICE9IHN0YXRlLnBsdWdpbnMgJiYgIXByZXYuZG9jLmVxKHN0YXRlLmRvYykgPyBcInJlc2V0XCJcbiAgICAgICAgICAgIDogc3RhdGUuc2Nyb2xsVG9TZWxlY3Rpb24gPiBwcmV2LnNjcm9sbFRvU2VsZWN0aW9uID8gXCJ0byBzZWxlY3Rpb25cIiA6IFwicHJlc2VydmVcIjtcbiAgICAgICAgbGV0IHVwZGF0ZURvYyA9IHJlZHJhdyB8fCAhdGhpcy5kb2NWaWV3Lm1hdGNoZXNOb2RlKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgICBpZiAodXBkYXRlRG9jIHx8ICFzdGF0ZS5zZWxlY3Rpb24uZXEocHJldi5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgdXBkYXRlU2VsID0gdHJ1ZTtcbiAgICAgICAgbGV0IG9sZFNjcm9sbFBvcyA9IHNjcm9sbCA9PSBcInByZXNlcnZlXCIgJiYgdXBkYXRlU2VsICYmIHRoaXMuZG9tLnN0eWxlLm92ZXJmbG93QW5jaG9yID09IG51bGwgJiYgc3RvcmVTY3JvbGxQb3ModGhpcyk7XG4gICAgICAgIGlmICh1cGRhdGVTZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgLy8gV29yayBhcm91bmQgYW4gaXNzdWUgaW4gQ2hyb21lLCBJRSwgYW5kIEVkZ2Ugd2hlcmUgY2hhbmdpbmdcbiAgICAgICAgICAgIC8vIHRoZSBET00gYXJvdW5kIGFuIGFjdGl2ZSBzZWxlY3Rpb24gcHV0cyBpdCBpbnRvIGEgYnJva2VuXG4gICAgICAgICAgICAvLyBzdGF0ZSB3aGVyZSB0aGUgdGhpbmcgdGhlIHVzZXIgc2VlcyBkaWZmZXJzIGZyb20gdGhlXG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gcmVwb3J0ZWQgYnkgdGhlIFNlbGVjdGlvbiBvYmplY3QgKCM3MTAsICM5NzMsXG4gICAgICAgICAgICAvLyAjMTAxMSwgIzEwMTMsICMxMDM1KS5cbiAgICAgICAgICAgIGxldCBmb3JjZVNlbFVwZGF0ZSA9IHVwZGF0ZURvYyAmJiAoaWUgfHwgY2hyb21lKSAmJiAhdGhpcy5jb21wb3NpbmcgJiZcbiAgICAgICAgICAgICAgICAhcHJldi5zZWxlY3Rpb24uZW1wdHkgJiYgIXN0YXRlLnNlbGVjdGlvbi5lbXB0eSAmJiBzZWxlY3Rpb25Db250ZXh0Q2hhbmdlZChwcmV2LnNlbGVjdGlvbiwgc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVEb2MpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbm9kZSB0aGF0IHRoZSBzZWxlY3Rpb24gcG9pbnRzIGludG8gaXMgd3JpdHRlbiB0byxcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgc29tZXRpbWVzIHN0YXJ0cyBtaXNyZXBvcnRpbmcgdGhlIHNlbGVjdGlvbiwgc28gdGhpc1xuICAgICAgICAgICAgICAgIC8vIHRyYWNrcyB0aGF0IGFuZCBmb3JjZXMgYSBzZWxlY3Rpb24gcmVzZXQgd2hlbiBvdXIgdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gZGlkIHdyaXRlIHRvIHRoZSBub2RlLlxuICAgICAgICAgICAgICAgIGxldCBjaHJvbWVLbHVkZ2UgPSBjaHJvbWUgPyAodGhpcy50cmFja1dyaXRlcyA9IHRoaXMuZG9tU2VsZWN0aW9uUmFuZ2UoKS5mb2N1c05vZGUpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVkcmF3IHx8ICF0aGlzLmRvY1ZpZXcudXBkYXRlKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVPdXRlckRlY28oW10pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcgPSBkb2NWaWV3RGVzYyhzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB0aGlzLmRvbSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaHJvbWVLbHVkZ2UgJiYgIXRoaXMudHJhY2tXcml0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlU2VsVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGZvciBhbiBpc3N1ZSB3aGVyZSBhbiB1cGRhdGUgYXJyaXZpbmcgcmlnaHQgYmV0d2VlblxuICAgICAgICAgICAgLy8gYSBET00gc2VsZWN0aW9uIGNoYW5nZSBhbmQgdGhlIFwic2VsZWN0aW9uY2hhbmdlXCIgZXZlbnQgZm9yIGl0XG4gICAgICAgICAgICAvLyBjYW4gY2F1c2UgYSBzcHVyaW91cyBET00gc2VsZWN0aW9uIHVwZGF0ZSwgZGlzcnVwdGluZyBtb3VzZVxuICAgICAgICAgICAgLy8gZHJhZyBzZWxlY3Rpb24uXG4gICAgICAgICAgICBpZiAoZm9yY2VTZWxVcGRhdGUgfHxcbiAgICAgICAgICAgICAgICAhKHRoaXMuaW5wdXQubW91c2VEb3duICYmIHRoaXMuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5lcSh0aGlzLmRvbVNlbGVjdGlvblJhbmdlKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvckluUmlnaHRQbGFjZSh0aGlzKSkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh0aGlzLCBmb3JjZVNlbFVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzeW5jTm9kZVNlbGVjdGlvbih0aGlzLCBzdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5WaWV3cyhwcmV2KTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmRyYWdnaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZSkgJiYgIXByZXYuZG9jLmVxKHN0YXRlLmRvYykpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURyYWdnZWROb2RlKHRoaXMuZHJhZ2dpbmcsIHByZXYpO1xuICAgICAgICBpZiAoc2Nyb2xsID09IFwicmVzZXRcIikge1xuICAgICAgICAgICAgdGhpcy5kb20uc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY3JvbGwgPT0gXCJ0byBzZWxlY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb1NlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZFNjcm9sbFBvcykge1xuICAgICAgICAgICAgcmVzZXRTY3JvbGxQb3Mob2xkU2Nyb2xsUG9zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNjcm9sbFRvU2VsZWN0aW9uKCkge1xuICAgICAgICBsZXQgc3RhcnRET00gPSB0aGlzLmRvbVNlbGVjdGlvblJhbmdlKCkuZm9jdXNOb2RlO1xuICAgICAgICBpZiAodGhpcy5zb21lUHJvcChcImhhbmRsZVNjcm9sbFRvU2VsZWN0aW9uXCIsIGYgPT4gZih0aGlzKSkpIDtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5kb2NWaWV3LmRvbUFmdGVyUG9zKHRoaXMuc3RhdGUuc2VsZWN0aW9uLmZyb20pO1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLCB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHN0YXJ0RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLCB0aGlzLmNvb3Jkc0F0UG9zKHRoaXMuc3RhdGUuc2VsZWN0aW9uLmhlYWQsIDEpLCBzdGFydERPTSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveVBsdWdpblZpZXdzKCkge1xuICAgICAgICBsZXQgdmlldztcbiAgICAgICAgd2hpbGUgKHZpZXcgPSB0aGlzLnBsdWdpblZpZXdzLnBvcCgpKVxuICAgICAgICAgICAgaWYgKHZpZXcuZGVzdHJveSlcbiAgICAgICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdXBkYXRlUGx1Z2luVmlld3MocHJldlN0YXRlKSB7XG4gICAgICAgIGlmICghcHJldlN0YXRlIHx8IHByZXZTdGF0ZS5wbHVnaW5zICE9IHRoaXMuc3RhdGUucGx1Z2lucyB8fCB0aGlzLmRpcmVjdFBsdWdpbnMgIT0gdGhpcy5wcmV2RGlyZWN0UGx1Z2lucykge1xuICAgICAgICAgICAgdGhpcy5wcmV2RGlyZWN0UGx1Z2lucyA9IHRoaXMuZGlyZWN0UGx1Z2lucztcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVBsdWdpblZpZXdzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmRpcmVjdFBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLnZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luVmlld3MucHVzaChwbHVnaW4uc3BlYy52aWV3KHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuc3RhdGUucGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMudmlldylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5WaWV3cy5wdXNoKHBsdWdpbi5zcGVjLnZpZXcodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpblZpZXdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpblZpZXcgPSB0aGlzLnBsdWdpblZpZXdzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5WaWV3LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luVmlldy51cGRhdGUodGhpcywgcHJldlN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVEcmFnZ2VkTm9kZShkcmFnZ2luZywgcHJldikge1xuICAgICAgICBsZXQgc2VsID0gZHJhZ2dpbmcubm9kZSwgZm91bmQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZG9jLm5vZGVBdChzZWwuZnJvbSkgPT0gc2VsLm5vZGUpIHtcbiAgICAgICAgICAgIGZvdW5kID0gc2VsLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbW92ZWRQb3MgPSBzZWwuZnJvbSArICh0aGlzLnN0YXRlLmRvYy5jb250ZW50LnNpemUgLSBwcmV2LmRvYy5jb250ZW50LnNpemUpO1xuICAgICAgICAgICAgbGV0IG1vdmVkID0gbW92ZWRQb3MgPiAwICYmIHRoaXMuc3RhdGUuZG9jLm5vZGVBdChtb3ZlZFBvcyk7XG4gICAgICAgICAgICBpZiAobW92ZWQgPT0gc2VsLm5vZGUpXG4gICAgICAgICAgICAgICAgZm91bmQgPSBtb3ZlZFBvcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKGRyYWdnaW5nLnNsaWNlLCBkcmFnZ2luZy5tb3ZlLCBmb3VuZCA8IDAgPyB1bmRlZmluZWQgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0aGlzLnN0YXRlLmRvYywgZm91bmQpKTtcbiAgICB9XG4gICAgc29tZVByb3AocHJvcE5hbWUsIGYpIHtcbiAgICAgICAgbGV0IHByb3AgPSB0aGlzLl9wcm9wcyAmJiB0aGlzLl9wcm9wc1twcm9wTmFtZV0sIHZhbHVlO1xuICAgICAgICBpZiAocHJvcCAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3ApIDogcHJvcCkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kaXJlY3RQbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXS5wcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICBpZiAocHJvcCAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3ApIDogcHJvcCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwbHVnaW5zID0gdGhpcy5zdGF0ZS5wbHVnaW5zO1xuICAgICAgICBpZiAocGx1Z2lucylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wID0gcGx1Z2luc1tpXS5wcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhlIHZpZXcgaGFzIGZvY3VzLlxuICAgICovXG4gICAgaGFzRm9jdXMoKSB7XG4gICAgICAgIC8vIFdvcmsgYXJvdW5kIElFIG5vdCBoYW5kbGluZyBmb2N1cyBjb3JyZWN0bHkgaWYgcmVzaXplIGhhbmRsZXMgYXJlIHNob3duLlxuICAgICAgICAvLyBJZiB0aGUgY3Vyc29yIGlzIGluc2lkZSBhbiBlbGVtZW50IHdpdGggcmVzaXplIGhhbmRsZXMsIGFjdGl2ZUVsZW1lbnRcbiAgICAgICAgLy8gd2lsbCBiZSB0aGF0IGVsZW1lbnQgaW5zdGVhZCBvZiB0aGlzLmRvbS5cbiAgICAgICAgaWYgKGllKSB7XG4gICAgICAgICAgICAvLyBJZiBhY3RpdmVFbGVtZW50IGlzIHdpdGhpbiB0aGlzLmRvbSwgYW5kIHRoZXJlIGFyZSBubyBvdGhlciBlbGVtZW50c1xuICAgICAgICAgICAgLy8gc2V0dGluZyBgY29udGVudGVkaXRhYmxlYCB0byBmYWxzZSBpbiBiZXR3ZWVuLCB0cmVhdCBpdCBhcyBmb2N1c2VkLlxuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChub2RlID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8ICF0aGlzLmRvbS5jb250YWlucyhub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAmJiB0aGlzLmRvbSAhPSBub2RlICYmIHRoaXMuZG9tLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09ICdmYWxzZScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBGb2N1cyB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICBpZiAodGhpcy5lZGl0YWJsZSlcbiAgICAgICAgICAgIGZvY3VzUHJldmVudFNjcm9sbCh0aGlzLmRvbSk7XG4gICAgICAgIHNlbGVjdGlvblRvRE9NKHRoaXMpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZG9jdW1lbnQgcm9vdCBpbiB3aGljaCB0aGUgZWRpdG9yIGV4aXN0cy4gVGhpcyB3aWxsXG4gICAgdXN1YWxseSBiZSB0aGUgdG9wLWxldmVsIGBkb2N1bWVudGAsIGJ1dCBtaWdodCBiZSBhIFtzaGFkb3dcbiAgICBET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1dlYl9Db21wb25lbnRzL1NoYWRvd19ET00pXG4gICAgcm9vdCBpZiB0aGUgZWRpdG9yIGlzIGluc2lkZSBvbmUuXG4gICAgKi9cbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX3Jvb3Q7XG4gICAgICAgIGlmIChjYWNoZWQgPT0gbnVsbClcbiAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IHRoaXMuZG9tLnBhcmVudE5vZGU7IHNlYXJjaDsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VhcmNoLm5vZGVUeXBlID09IDkgfHwgKHNlYXJjaC5ub2RlVHlwZSA9PSAxMSAmJiBzZWFyY2guaG9zdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWFyY2guZ2V0U2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHNlYXJjaCkuZ2V0U2VsZWN0aW9uID0gKCkgPT4gc2VhcmNoLm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290ID0gc2VhcmNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlZCB8fCBkb2N1bWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hlbiBhbiBleGlzdGluZyBlZGl0b3IgdmlldyBpcyBtb3ZlZCB0byBhIG5ldyBkb2N1bWVudCBvclxuICAgIHNoYWRvdyB0cmVlLCBjYWxsIHRoaXMgdG8gbWFrZSBpdCByZWNvbXB1dGUgaXRzIHJvb3QuXG4gICAgKi9cbiAgICB1cGRhdGVSb290KCkge1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYSBwYWlyIG9mIHZpZXdwb3J0IGNvb3JkaW5hdGVzLCByZXR1cm4gdGhlIGRvY3VtZW50XG4gICAgcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byB0aGVtLiBNYXkgcmV0dXJuIG51bGwgaWYgdGhlIGdpdmVuXG4gICAgY29vcmRpbmF0ZXMgYXJlbid0IGluc2lkZSBvZiB0aGUgZWRpdG9yLiBXaGVuIGFuIG9iamVjdCBpc1xuICAgIHJldHVybmVkLCBpdHMgYHBvc2AgcHJvcGVydHkgaXMgdGhlIHBvc2l0aW9uIG5lYXJlc3QgdG8gdGhlXG4gICAgY29vcmRpbmF0ZXMsIGFuZCBpdHMgYGluc2lkZWAgcHJvcGVydHkgaG9sZHMgdGhlIHBvc2l0aW9uIG9mIHRoZVxuICAgIGlubmVyIG5vZGUgdGhhdCB0aGUgcG9zaXRpb24gZmFsbHMgaW5zaWRlIG9mLCBvciAtMSBpZiBpdCBpcyBhdFxuICAgIHRoZSB0b3AgbGV2ZWwsIG5vdCBpbiBhbnkgbm9kZS5cbiAgICAqL1xuICAgIHBvc0F0Q29vcmRzKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gcG9zQXRDb29yZHModGhpcywgY29vcmRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgdmlld3BvcnQgcmVjdGFuZ2xlIGF0IGEgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgYGxlZnRgIGFuZCBgcmlnaHRgIHdpbGwgYmUgdGhlIHNhbWUgbnVtYmVyLCBhcyB0aGlzIHJldHVybnMgYVxuICAgIGZsYXQgY3Vyc29yLWlzaCByZWN0YW5nbGUuIElmIHRoZSBwb3NpdGlvbiBpcyBiZXR3ZWVuIHR3byB0aGluZ3NcbiAgICB0aGF0IGFyZW4ndCBkaXJlY3RseSBhZGphY2VudCwgYHNpZGVgIGRldGVybWluZXMgd2hpY2ggZWxlbWVudFxuICAgIGlzIHVzZWQuIFdoZW4gPCAwLCB0aGUgZWxlbWVudCBiZWZvcmUgdGhlIHBvc2l0aW9uIGlzIHVzZWQsXG4gICAgb3RoZXJ3aXNlIHRoZSBlbGVtZW50IGFmdGVyLlxuICAgICovXG4gICAgY29vcmRzQXRQb3MocG9zLCBzaWRlID0gMSkge1xuICAgICAgICByZXR1cm4gY29vcmRzQXRQb3ModGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgRE9NIHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIGRvY3VtZW50XG4gICAgcG9zaXRpb24uIFdoZW4gYHNpZGVgIGlzIG5lZ2F0aXZlLCBmaW5kIHRoZSBwb3NpdGlvbiBhcyBjbG9zZSBhc1xuICAgIHBvc3NpYmxlIHRvIHRoZSBjb250ZW50IGJlZm9yZSB0aGUgcG9zaXRpb24uIFdoZW4gcG9zaXRpdmUsXG4gICAgcHJlZmVyIHBvc2l0aW9ucyBjbG9zZSB0byB0aGUgY29udGVudCBhZnRlciB0aGUgcG9zaXRpb24uIFdoZW5cbiAgICB6ZXJvLCBwcmVmZXIgYXMgc2hhbGxvdyBhIHBvc2l0aW9uIGFzIHBvc3NpYmxlLlxuICAgIFxuICAgIE5vdGUgdGhhdCB5b3Ugc2hvdWxkICoqbm90KiogbXV0YXRlIHRoZSBlZGl0b3IncyBpbnRlcm5hbCBET00sXG4gICAgb25seSBpbnNwZWN0IGl0IChhbmQgZXZlbiB0aGF0IGlzIHVzdWFsbHkgbm90IG5lY2Vzc2FyeSkuXG4gICAgKi9cbiAgICBkb21BdFBvcyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gbm9kZSB0aGF0IHJlcHJlc2VudHMgdGhlIGRvY3VtZW50IG5vZGUgYWZ0ZXIgdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb24uIE1heSByZXR1cm4gYG51bGxgIHdoZW4gdGhlIHBvc2l0aW9uIGRvZXNuJ3QgcG9pbnRcbiAgICBpbiBmcm9udCBvZiBhIG5vZGUgb3IgaWYgdGhlIG5vZGUgaXMgaW5zaWRlIGFuIG9wYXF1ZSBub2RlIHZpZXcuXG4gICAgXG4gICAgVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBhYmxlIHRvIGNhbGwgdGhpbmdzIGxpa2VcbiAgICBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBvbiB0aGF0IERPTSBub2RlLiBEbyAqKm5vdCoqIG11dGF0ZSB0aGVcbiAgICBlZGl0b3IgRE9NIGRpcmVjdGx5LCBvciBhZGQgc3R5bGluZyB0aGlzIHdheSwgc2luY2UgdGhhdCB3aWxsIGJlXG4gICAgaW1tZWRpYXRlbHkgb3ZlcnJpZGVuIGJ5IHRoZSBlZGl0b3IgYXMgaXQgcmVkcmF3cyB0aGUgbm9kZS5cbiAgICAqL1xuICAgIG5vZGVET00ocG9zKSB7XG4gICAgICAgIGxldCBkZXNjID0gdGhpcy5kb2NWaWV3LmRlc2NBdChwb3MpO1xuICAgICAgICByZXR1cm4gZGVzYyA/IGRlc2Mubm9kZURPTSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBnaXZlbiBET01cbiAgICBwb3NpdGlvbi4gKFdoZW5ldmVyIHBvc3NpYmxlLCBpdCBpcyBwcmVmZXJhYmxlIHRvIGluc3BlY3QgdGhlXG4gICAgZG9jdW1lbnQgc3RydWN0dXJlIGRpcmVjdGx5LCByYXRoZXIgdGhhbiBwb2tpbmcgYXJvdW5kIGluIHRoZVxuICAgIERPTSwgYnV0IHNvbWV0aW1lc1x1MjAxNGZvciBleGFtcGxlIHdoZW4gaW50ZXJwcmV0aW5nIGFuIGV2ZW50XG4gICAgdGFyZ2V0XHUyMDE0eW91IGRvbid0IGhhdmUgYSBjaG9pY2UuKVxuICAgIFxuICAgIFRoZSBgYmlhc2AgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIGluZmx1ZW5jZSB3aGljaCBzaWRlIG9mIGEgRE9NXG4gICAgbm9kZSB0byB1c2Ugd2hlbiB0aGUgcG9zaXRpb24gaXMgaW5zaWRlIGEgbGVhZiBub2RlLlxuICAgICovXG4gICAgcG9zQXRET00obm9kZSwgb2Zmc2V0LCBiaWFzID0gLTEpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgYmlhcyk7XG4gICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRE9NIHBvc2l0aW9uIG5vdCBpbnNpZGUgdGhlIGVkaXRvclwiKTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBvdXQgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2sgd2hlblxuICAgIG1vdmluZyBpbiBhIGdpdmVuIGRpcmVjdGlvbi4gV2hlbiwgZm9yIGV4YW1wbGUsIGdpdmVuIGBcImxlZnRcImAsXG4gICAgaXQgd2lsbCByZXR1cm4gdHJ1ZSBpZiBtb3ZpbmcgbGVmdCBmcm9tIHRoZSBjdXJyZW50IGN1cnNvclxuICAgIHBvc2l0aW9uIHdvdWxkIGxlYXZlIHRoYXQgcG9zaXRpb24ncyBwYXJlbnQgdGV4dGJsb2NrLiBXaWxsIGFwcGx5XG4gICAgdG8gdGhlIHZpZXcncyBjdXJyZW50IHN0YXRlIGJ5IGRlZmF1bHQsIGJ1dCBpdCBpcyBwb3NzaWJsZSB0b1xuICAgIHBhc3MgYSBkaWZmZXJlbnQgc3RhdGUuXG4gICAgKi9cbiAgICBlbmRPZlRleHRibG9jayhkaXIsIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBlbmRPZlRleHRibG9jayh0aGlzLCBzdGF0ZSB8fCB0aGlzLnN0YXRlLCBkaXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gdGhlIGVkaXRvcidzIHBhc3RlIGxvZ2ljIHdpdGggdGhlIGdpdmVuIEhUTUwgc3RyaW5nLiBUaGVcbiAgICBgZXZlbnRgLCBpZiBnaXZlbiwgd2lsbCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgW2BoYW5kbGVQYXN0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzLmhhbmRsZVBhc3RlKSBob29rLlxuICAgICovXG4gICAgcGFzdGVIVE1MKGh0bWwsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkb1Bhc3RlKHRoaXMsIFwiXCIsIGh0bWwsIGZhbHNlLCBldmVudCB8fCBuZXcgQ2xpcGJvYXJkRXZlbnQoXCJwYXN0ZVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJ1biB0aGUgZWRpdG9yJ3MgcGFzdGUgbG9naWMgd2l0aCB0aGUgZ2l2ZW4gcGxhaW4tdGV4dCBpbnB1dC5cbiAgICAqL1xuICAgIHBhc3RlVGV4dCh0ZXh0LCBldmVudCkge1xuICAgICAgICByZXR1cm4gZG9QYXN0ZSh0aGlzLCB0ZXh0LCBudWxsLCB0cnVlLCBldmVudCB8fCBuZXcgQ2xpcGJvYXJkRXZlbnQoXCJwYXN0ZVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZXMgdGhlIGVkaXRvciBmcm9tIHRoZSBET00gYW5kIGRlc3Ryb3lzIGFsbCBbbm9kZVxuICAgIHZpZXdzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5Ob2RlVmlldykuXG4gICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAoIXRoaXMuZG9jVmlldylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZGVzdHJveUlucHV0KHRoaXMpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lQbHVnaW5WaWV3cygpO1xuICAgICAgICBpZiAodGhpcy5tb3VudGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlKHRoaXMuc3RhdGUuZG9jLCBbXSwgdmlld0RlY29yYXRpb25zKHRoaXMpLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvY1ZpZXcuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGlzIGlzIHRydWUgd2hlbiB0aGUgdmlldyBoYXMgYmVlblxuICAgIFtkZXN0cm95ZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGVzdHJveSkgKGFuZCB0aHVzIHNob3VsZCBub3QgYmVcbiAgICB1c2VkIGFueW1vcmUpLlxuICAgICovXG4gICAgZ2V0IGlzRGVzdHJveWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3ID09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFVzZWQgZm9yIHRlc3RpbmcuXG4gICAgKi9cbiAgICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGlzcGF0Y2ggYSB0cmFuc2FjdGlvbi4gV2lsbCBjYWxsXG4gICAgW2BkaXNwYXRjaFRyYW5zYWN0aW9uYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRGlyZWN0RWRpdG9yUHJvcHMuZGlzcGF0Y2hUcmFuc2FjdGlvbilcbiAgICB3aGVuIGdpdmVuLCBhbmQgb3RoZXJ3aXNlIGRlZmF1bHRzIHRvIGFwcGx5aW5nIHRoZSB0cmFuc2FjdGlvbiB0b1xuICAgIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBjYWxsaW5nXG4gICAgW2B1cGRhdGVTdGF0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudXBkYXRlU3RhdGUpIHdpdGggdGhlIHJlc3VsdC5cbiAgICBUaGlzIG1ldGhvZCBpcyBib3VuZCB0byB0aGUgdmlldyBpbnN0YW5jZSwgc28gdGhhdCBpdCBjYW4gYmVcbiAgICBlYXNpbHkgcGFzc2VkIGFyb3VuZC5cbiAgICAqL1xuICAgIGRpc3BhdGNoKHRyKSB7XG4gICAgICAgIGxldCBkaXNwYXRjaFRyYW5zYWN0aW9uID0gdGhpcy5fcHJvcHMuZGlzcGF0Y2hUcmFuc2FjdGlvbjtcbiAgICAgICAgaWYgKGRpc3BhdGNoVHJhbnNhY3Rpb24pXG4gICAgICAgICAgICBkaXNwYXRjaFRyYW5zYWN0aW9uLmNhbGwodGhpcywgdHIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHRoaXMuc3RhdGUuYXBwbHkodHIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21TZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHNhZmFyaSAmJiB0aGlzLnJvb3Qubm9kZVR5cGUgPT09IDExICYmIGRlZXBBY3RpdmVFbGVtZW50KHRoaXMuZG9tLm93bmVyRG9jdW1lbnQpID09IHRoaXMuZG9tXG4gICAgICAgICAgICA/IHNhZmFyaVNoYWRvd1NlbGVjdGlvblJhbmdlKHRoaXMpIDogdGhpcy5kb21TZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21TZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZURvY0RlY28odmlldykge1xuICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgYXR0cnMuY2xhc3MgPSBcIlByb3NlTWlycm9yXCI7XG4gICAgYXR0cnMuY29udGVudGVkaXRhYmxlID0gU3RyaW5nKHZpZXcuZWRpdGFibGUpO1xuICAgIHZpZXcuc29tZVByb3AoXCJhdHRyaWJ1dGVzXCIsIHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKHZpZXcuc3RhdGUpO1xuICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICBmb3IgKGxldCBhdHRyIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIgPT0gXCJjbGFzc1wiKVxuICAgICAgICAgICAgICAgICAgICBhdHRycy5jbGFzcyArPSBcIiBcIiArIHZhbHVlW2F0dHJdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0dHIgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgICAgICBhdHRycy5zdHlsZSA9IChhdHRycy5zdHlsZSA/IGF0dHJzLnN0eWxlICsgXCI7XCIgOiBcIlwiKSArIHZhbHVlW2F0dHJdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdHRyc1thdHRyXSAmJiBhdHRyICE9IFwiY29udGVudGVkaXRhYmxlXCIgJiYgYXR0ciAhPSBcIm5vZGVOYW1lXCIpXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzW2F0dHJdID0gU3RyaW5nKHZhbHVlW2F0dHJdKTtcbiAgICAgICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWF0dHJzLnRyYW5zbGF0ZSlcbiAgICAgICAgYXR0cnMudHJhbnNsYXRlID0gXCJub1wiO1xuICAgIHJldHVybiBbRGVjb3JhdGlvbi5ub2RlKDAsIHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSwgYXR0cnMpXTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUN1cnNvcldyYXBwZXIodmlldykge1xuICAgIGlmICh2aWV3Lm1hcmtDdXJzb3IpIHtcbiAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgIGRvbS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLXNlcGFyYXRvclwiO1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwibWFyay1wbGFjZWhvbGRlclwiLCBcInRydWVcIik7XG4gICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJhbHRcIiwgXCJcIik7XG4gICAgICAgIHZpZXcuY3Vyc29yV3JhcHBlciA9IHsgZG9tLCBkZWNvOiBEZWNvcmF0aW9uLndpZGdldCh2aWV3LnN0YXRlLnNlbGVjdGlvbi5oZWFkLCBkb20sIHsgcmF3OiB0cnVlLCBtYXJrczogdmlldy5tYXJrQ3Vyc29yIH0pIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmN1cnNvcldyYXBwZXIgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVkaXRhYmxlKHZpZXcpIHtcbiAgICByZXR1cm4gIXZpZXcuc29tZVByb3AoXCJlZGl0YWJsZVwiLCB2YWx1ZSA9PiB2YWx1ZSh2aWV3LnN0YXRlKSA9PT0gZmFsc2UpO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uQ29udGV4dENoYW5nZWQoc2VsMSwgc2VsMikge1xuICAgIGxldCBkZXB0aCA9IE1hdGgubWluKHNlbDEuJGFuY2hvci5zaGFyZWREZXB0aChzZWwxLmhlYWQpLCBzZWwyLiRhbmNob3Iuc2hhcmVkRGVwdGgoc2VsMi5oZWFkKSk7XG4gICAgcmV0dXJuIHNlbDEuJGFuY2hvci5zdGFydChkZXB0aCkgIT0gc2VsMi4kYW5jaG9yLnN0YXJ0KGRlcHRoKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTm9kZVZpZXdzKHZpZXcpIHtcbiAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmdW5jdGlvbiBhZGQob2JqKSB7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBwcm9wKSlcbiAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgfVxuICAgIHZpZXcuc29tZVByb3AoXCJub2RlVmlld3NcIiwgYWRkKTtcbiAgICB2aWV3LnNvbWVQcm9wKFwibWFya1ZpZXdzXCIsIGFkZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNoYW5nZWROb2RlVmlld3MoYSwgYikge1xuICAgIGxldCBuQSA9IDAsIG5CID0gMDtcbiAgICBmb3IgKGxldCBwcm9wIGluIGEpIHtcbiAgICAgICAgaWYgKGFbcHJvcF0gIT0gYltwcm9wXSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBuQSsrO1xuICAgIH1cbiAgICBmb3IgKGxldCBfIGluIGIpXG4gICAgICAgIG5CKys7XG4gICAgcmV0dXJuIG5BICE9IG5CO1xufVxuZnVuY3Rpb24gY2hlY2tTdGF0ZUNvbXBvbmVudChwbHVnaW4pIHtcbiAgICBpZiAocGx1Z2luLnNwZWMuc3RhdGUgfHwgcGx1Z2luLnNwZWMuZmlsdGVyVHJhbnNhY3Rpb24gfHwgcGx1Z2luLnNwZWMuYXBwZW5kVHJhbnNhY3Rpb24pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUGx1Z2lucyBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIHZpZXcgbXVzdCBub3QgaGF2ZSBhIHN0YXRlIGNvbXBvbmVudFwiKTtcbn1cblxuZXhwb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCwgRWRpdG9yVmlldywgX19lbmRDb21wb3NpdGlvbiwgX19wYXJzZUZyb21DbGlwYm9hcmQsIF9fc2VyaWFsaXplRm9yQ2xpcGJvYXJkIH07XG4iLCAiZXhwb3J0IHZhciBiYXNlID0ge1xuICA4OiBcIkJhY2tzcGFjZVwiLFxuICA5OiBcIlRhYlwiLFxuICAxMDogXCJFbnRlclwiLFxuICAxMjogXCJOdW1Mb2NrXCIsXG4gIDEzOiBcIkVudGVyXCIsXG4gIDE2OiBcIlNoaWZ0XCIsXG4gIDE3OiBcIkNvbnRyb2xcIixcbiAgMTg6IFwiQWx0XCIsXG4gIDIwOiBcIkNhcHNMb2NrXCIsXG4gIDI3OiBcIkVzY2FwZVwiLFxuICAzMjogXCIgXCIsXG4gIDMzOiBcIlBhZ2VVcFwiLFxuICAzNDogXCJQYWdlRG93blwiLFxuICAzNTogXCJFbmRcIixcbiAgMzY6IFwiSG9tZVwiLFxuICAzNzogXCJBcnJvd0xlZnRcIixcbiAgMzg6IFwiQXJyb3dVcFwiLFxuICAzOTogXCJBcnJvd1JpZ2h0XCIsXG4gIDQwOiBcIkFycm93RG93blwiLFxuICA0NDogXCJQcmludFNjcmVlblwiLFxuICA0NTogXCJJbnNlcnRcIixcbiAgNDY6IFwiRGVsZXRlXCIsXG4gIDU5OiBcIjtcIixcbiAgNjE6IFwiPVwiLFxuICA5MTogXCJNZXRhXCIsXG4gIDkyOiBcIk1ldGFcIixcbiAgMTA2OiBcIipcIixcbiAgMTA3OiBcIitcIixcbiAgMTA4OiBcIixcIixcbiAgMTA5OiBcIi1cIixcbiAgMTEwOiBcIi5cIixcbiAgMTExOiBcIi9cIixcbiAgMTQ0OiBcIk51bUxvY2tcIixcbiAgMTQ1OiBcIlNjcm9sbExvY2tcIixcbiAgMTYwOiBcIlNoaWZ0XCIsXG4gIDE2MTogXCJTaGlmdFwiLFxuICAxNjI6IFwiQ29udHJvbFwiLFxuICAxNjM6IFwiQ29udHJvbFwiLFxuICAxNjQ6IFwiQWx0XCIsXG4gIDE2NTogXCJBbHRcIixcbiAgMTczOiBcIi1cIixcbiAgMTg2OiBcIjtcIixcbiAgMTg3OiBcIj1cIixcbiAgMTg4OiBcIixcIixcbiAgMTg5OiBcIi1cIixcbiAgMTkwOiBcIi5cIixcbiAgMTkxOiBcIi9cIixcbiAgMTkyOiBcImBcIixcbiAgMjE5OiBcIltcIixcbiAgMjIwOiBcIlxcXFxcIixcbiAgMjIxOiBcIl1cIixcbiAgMjIyOiBcIidcIlxufVxuXG5leHBvcnQgdmFyIHNoaWZ0ID0ge1xuICA0ODogXCIpXCIsXG4gIDQ5OiBcIiFcIixcbiAgNTA6IFwiQFwiLFxuICA1MTogXCIjXCIsXG4gIDUyOiBcIiRcIixcbiAgNTM6IFwiJVwiLFxuICA1NDogXCJeXCIsXG4gIDU1OiBcIiZcIixcbiAgNTY6IFwiKlwiLFxuICA1NzogXCIoXCIsXG4gIDU5OiBcIjpcIixcbiAgNjE6IFwiK1wiLFxuICAxNzM6IFwiX1wiLFxuICAxODY6IFwiOlwiLFxuICAxODc6IFwiK1wiLFxuICAxODg6IFwiPFwiLFxuICAxODk6IFwiX1wiLFxuICAxOTA6IFwiPlwiLFxuICAxOTE6IFwiP1wiLFxuICAxOTI6IFwiflwiLFxuICAyMTk6IFwie1wiLFxuICAyMjA6IFwifFwiLFxuICAyMjE6IFwifVwiLFxuICAyMjI6IFwiXFxcIlwiXG59XG5cbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG52YXIgaWUgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgXFxkfFRyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpXG5cbi8vIEZpbGwgaW4gdGhlIGRpZ2l0IGtleXNcbmZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykgYmFzZVs0OCArIGldID0gYmFzZVs5NiArIGldID0gU3RyaW5nKGkpXG5cbi8vIFRoZSBmdW5jdGlvbiBrZXlzXG5mb3IgKHZhciBpID0gMTsgaSA8PSAyNDsgaSsrKSBiYXNlW2kgKyAxMTFdID0gXCJGXCIgKyBpXG5cbi8vIEFuZCB0aGUgYWxwaGFiZXRpYyBrZXlzXG5mb3IgKHZhciBpID0gNjU7IGkgPD0gOTA7IGkrKykge1xuICBiYXNlW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgMzIpXG4gIHNoaWZ0W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxufVxuXG4vLyBGb3IgZWFjaCBjb2RlIHRoYXQgZG9lc24ndCBoYXZlIGEgc2hpZnQtZXF1aXZhbGVudCwgY29weSB0aGUgYmFzZSBuYW1lXG5mb3IgKHZhciBjb2RlIGluIGJhc2UpIGlmICghc2hpZnQuaGFzT3duUHJvcGVydHkoY29kZSkpIHNoaWZ0W2NvZGVdID0gYmFzZVtjb2RlXVxuXG5leHBvcnQgZnVuY3Rpb24ga2V5TmFtZShldmVudCkge1xuICAvLyBPbiBtYWNPUywga2V5cyBoZWxkIHdpdGggU2hpZnQgYW5kIENtZCBkb24ndCByZWZsZWN0IHRoZSBlZmZlY3Qgb2YgU2hpZnQgaW4gYC5rZXlgLlxuICAvLyBPbiBJRSwgc2hpZnQgZWZmZWN0IGlzIG5ldmVyIGluY2x1ZGVkIGluIGAua2V5YC5cbiAgdmFyIGlnbm9yZUtleSA9IG1hYyAmJiBldmVudC5tZXRhS2V5ICYmIGV2ZW50LnNoaWZ0S2V5ICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgfHxcbiAgICAgIGllICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSAmJiBldmVudC5rZXkubGVuZ3RoID09IDEgfHxcbiAgICAgIGV2ZW50LmtleSA9PSBcIlVuaWRlbnRpZmllZFwiXG4gIHZhciBuYW1lID0gKCFpZ25vcmVLZXkgJiYgZXZlbnQua2V5KSB8fFxuICAgIChldmVudC5zaGlmdEtleSA/IHNoaWZ0IDogYmFzZSlbZXZlbnQua2V5Q29kZV0gfHxcbiAgICBldmVudC5rZXkgfHwgXCJVbmlkZW50aWZpZWRcIlxuICAvLyBFZGdlIHNvbWV0aW1lcyBwcm9kdWNlcyB3cm9uZyBuYW1lcyAoSXNzdWUgIzMpXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiXG4gIGlmIChuYW1lID09IFwiRGVsXCIpIG5hbWUgPSBcIkRlbGV0ZVwiXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzg4NjA1NzEvXG4gIGlmIChuYW1lID09IFwiTGVmdFwiKSBuYW1lID0gXCJBcnJvd0xlZnRcIlxuICBpZiAobmFtZSA9PSBcIlVwXCIpIG5hbWUgPSBcIkFycm93VXBcIlxuICBpZiAobmFtZSA9PSBcIlJpZ2h0XCIpIG5hbWUgPSBcIkFycm93UmlnaHRcIlxuICBpZiAobmFtZSA9PSBcIkRvd25cIikgbmFtZSA9IFwiQXJyb3dEb3duXCJcbiAgcmV0dXJuIG5hbWVcbn1cbiIsICJpbXBvcnQgeyBrZXlOYW1lLCBiYXNlIH0gZnJvbSAndzNjLWtleW5hbWUnO1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG5jb25zdCBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyAvTWFjfGlQKGhvbmV8W29hXWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgOiBmYWxzZTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZSkge1xuICAgIGxldCBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pLCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAocmVzdWx0ID09IFwiU3BhY2VcIilcbiAgICAgICAgcmVzdWx0ID0gXCIgXCI7XG4gICAgbGV0IGFsdCwgY3RybCwgc2hpZnQsIG1ldGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbGV0IG1vZCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBzaGlmdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgaWYgKG1hYylcbiAgICAgICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXCIgKyBtb2QpO1xuICAgIH1cbiAgICBpZiAoYWx0KVxuICAgICAgICByZXN1bHQgPSBcIkFsdC1cIiArIHJlc3VsdDtcbiAgICBpZiAoY3RybClcbiAgICAgICAgcmVzdWx0ID0gXCJDdHJsLVwiICsgcmVzdWx0O1xuICAgIGlmIChtZXRhKVxuICAgICAgICByZXN1bHQgPSBcIk1ldGEtXCIgKyByZXN1bHQ7XG4gICAgaWYgKHNoaWZ0KVxuICAgICAgICByZXN1bHQgPSBcIlNoaWZ0LVwiICsgcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemUobWFwKSB7XG4gICAgbGV0IGNvcHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICBjb3B5W25vcm1hbGl6ZUtleU5hbWUocHJvcCldID0gbWFwW3Byb3BdO1xuICAgIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBzaGlmdCA9IHRydWUpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KVxuICAgICAgICBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5jdHJsS2V5KVxuICAgICAgICBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgbmFtZSA9IFwiTWV0YS1cIiArIG5hbWU7XG4gICAgaWYgKHNoaWZ0ICYmIGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG59XG4vKipcbkNyZWF0ZSBhIGtleW1hcCBwbHVnaW4gZm9yIHRoZSBnaXZlbiBzZXQgb2YgYmluZGluZ3MuXG5cbkJpbmRpbmdzIHNob3VsZCBtYXAga2V5IG5hbWVzIHRvIFtjb21tYW5kXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMpLXN0eWxlXG5mdW5jdGlvbnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYChFZGl0b3JTdGF0ZSwgZGlzcGF0Y2gsXG5FZGl0b3JWaWV3KWAgYXJndW1lbnRzLCBhbmQgc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gdGhleSd2ZSBoYW5kbGVkXG50aGUga2V5LiBOb3RlIHRoYXQgdGhlIHZpZXcgYXJndW1lbnQgaXNuJ3QgcGFydCBvZiB0aGUgY29tbWFuZFxucHJvdG9jb2wsIGJ1dCBjYW4gYmUgdXNlZCBhcyBhbiBlc2NhcGUgaGF0Y2ggaWYgYSBiaW5kaW5nIG5lZWRzIHRvXG5kaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZSBVSS5cblxuS2V5IG5hbWVzIG1heSBiZSBzdHJpbmdzIGxpa2UgYFwiU2hpZnQtQ3RybC1FbnRlclwiYFx1MjAxNGEga2V5XG5pZGVudGlmaWVyIHByZWZpeGVkIHdpdGggemVybyBvciBtb3JlIG1vZGlmaWVycy4gS2V5IGlkZW50aWZpZXJzXG5hcmUgYmFzZWQgb24gdGhlIHN0cmluZ3MgdGhhdCBjYW4gYXBwZWFyIGluXG5bYEtleUV2ZW50LmtleWBdKGh0dHBzOmRldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkpLlxuVXNlIGxvd2VyY2FzZSBsZXR0ZXJzIHRvIHJlZmVyIHRvIGxldHRlciBrZXlzIChvciB1cHBlcmNhc2UgbGV0dGVyc1xuaWYgeW91IHdhbnQgc2hpZnQgdG8gYmUgaGVsZCkuIFlvdSBtYXkgdXNlIGBcIlNwYWNlXCJgIGFzIGFuIGFsaWFzXG5mb3IgdGhlIGBcIiBcImAgbmFtZS5cblxuTW9kaWZpZXJzIGNhbiBiZSBnaXZlbiBpbiBhbnkgb3JkZXIuIGBTaGlmdC1gIChvciBgcy1gKSwgYEFsdC1gIChvclxuYGEtYCksIGBDdHJsLWAgKG9yIGBjLWAgb3IgYENvbnRyb2wtYCkgYW5kIGBDbWQtYCAob3IgYG0tYCBvclxuYE1ldGEtYCkgYXJlIHJlY29nbml6ZWQuIEZvciBjaGFyYWN0ZXJzIHRoYXQgYXJlIGNyZWF0ZWQgYnkgaG9sZGluZ1xuc2hpZnQsIHRoZSBgU2hpZnQtYCBwcmVmaXggaXMgaW1wbGllZCwgYW5kIHNob3VsZCBub3QgYmUgYWRkZWRcbmV4cGxpY2l0bHkuXG5cbllvdSBjYW4gdXNlIGBNb2QtYCBhcyBhIHNob3J0aGFuZCBmb3IgYENtZC1gIG9uIE1hYyBhbmQgYEN0cmwtYCBvblxub3RoZXIgcGxhdGZvcm1zLlxuXG5Zb3UgY2FuIGFkZCBtdWx0aXBsZSBrZXltYXAgcGx1Z2lucyB0byBhbiBlZGl0b3IuIFRoZSBvcmRlciBpblxud2hpY2ggdGhleSBhcHBlYXIgZGV0ZXJtaW5lcyB0aGVpciBwcmVjZWRlbmNlICh0aGUgb25lcyBlYXJseSBpblxudGhlIGFycmF5IGdldCB0byBkaXNwYXRjaCBmaXJzdCkuXG4qL1xuZnVuY3Rpb24ga2V5bWFwKGJpbmRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oeyBwcm9wczogeyBoYW5kbGVLZXlEb3duOiBrZXlkb3duSGFuZGxlcihiaW5kaW5ncykgfSB9KTtcbn1cbi8qKlxuR2l2ZW4gYSBzZXQgb2YgYmluZGluZ3MgKHVzaW5nIHRoZSBzYW1lIGZvcm1hdCBhc1xuW2BrZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8ja2V5bWFwLmtleW1hcCkpLCByZXR1cm4gYSBba2V5ZG93blxuaGFuZGxlcl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMuaGFuZGxlS2V5RG93bikgdGhhdCBoYW5kbGVzIHRoZW0uXG4qL1xuZnVuY3Rpb24ga2V5ZG93bkhhbmRsZXIoYmluZGluZ3MpIHtcbiAgICBsZXQgbWFwID0gbm9ybWFsaXplKGJpbmRpbmdzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZpZXcsIGV2ZW50KSB7XG4gICAgICAgIGxldCBuYW1lID0ga2V5TmFtZShldmVudCksIGJhc2VOYW1lLCBkaXJlY3QgPSBtYXBbbW9kaWZpZXJzKG5hbWUsIGV2ZW50KV07XG4gICAgICAgIGlmIChkaXJlY3QgJiYgZGlyZWN0KHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIEEgY2hhcmFjdGVyIGtleVxuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT0gMSAmJiBuYW1lICE9IFwiIFwiKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHRoZSBuYW1lIHdhcyBhbHJlYWR5IG1vZGlmaWVkIGJ5IHNoaWZ0LCB0cnkgbG9va2luZ1xuICAgICAgICAgICAgICAgIC8vIGl0IHVwIHdpdGhvdXQgaXRzIHNoaWZ0IG1vZGlmaWVyXG4gICAgICAgICAgICAgICAgbGV0IG5vU2hpZnQgPSBtYXBbbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBmYWxzZSldO1xuICAgICAgICAgICAgICAgIGlmIChub1NoaWZ0ICYmIG5vU2hpZnQodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBuYW1lLmNoYXJDb2RlQXQoMCkgPiAxMjcpICYmXG4gICAgICAgICAgICAgICAgKGJhc2VOYW1lID0gYmFzZVtldmVudC5rZXlDb2RlXSkgJiYgYmFzZU5hbWUgIT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIFRyeSBmYWxsaW5nIGJhY2sgdG8gdGhlIGtleUNvZGUgd2hlbiB0aGVyZSdzIGEgbW9kaWZpZXJcbiAgICAgICAgICAgICAgICAvLyBhY3RpdmUgb3IgdGhlIGNoYXJhY3RlciBwcm9kdWNlZCBpc24ndCBBU0NJSSwgYW5kIG91ciB0YWJsZVxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y2VzIGEgZGlmZmVyZW50IG5hbWUgZnJvbSB0aGUgdGhlIGtleUNvZGUuIFNlZSAjNjY4LFxuICAgICAgICAgICAgICAgIC8vICMxMDYwXG4gICAgICAgICAgICAgICAgbGV0IGZyb21Db2RlID0gbWFwW21vZGlmaWVycyhiYXNlTmFtZSwgZXZlbnQpXTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUNvZGUgJiYgZnJvbUNvZGUodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBrZXlkb3duSGFuZGxlciwga2V5bWFwIH07XG4iLCAiaW1wb3J0IHsgbGlmdFRhcmdldCwgcmVwbGFjZVN0ZXAsIFJlcGxhY2VTdGVwLCBjYW5Kb2luLCBqb2luUG9pbnQsIGNhblNwbGl0LCBSZXBsYWNlQXJvdW5kU3RlcCwgZmluZFdyYXBwaW5nIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IFNsaWNlLCBGcmFnbWVudCB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24sIFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiwgQWxsU2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBpZiB0aGVyZSBpcyBvbmUuXG4qL1xuY29uc3QgZGVsZXRlU2VsZWN0aW9uID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldykge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImJhY2t3YXJkXCIsIHN0YXRlKVxuICAgICAgICA6ICRjdXJzb3IucGFyZW50T2Zmc2V0ID4gMCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAkY3Vyc29yO1xufVxuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2ssIHRyeSB0b1xucmVkdWNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoYXQgYmxvY2sgYW5kIHRoZSBvbmUgYmVmb3JlIGl0XHUyMDE0aWZcbnRoZXJlJ3MgYSBibG9jayBkaXJlY3RseSBiZWZvcmUgaXQgdGhhdCBjYW4gYmUgam9pbmVkLCBqb2luIHRoZW0uXG5JZiBub3QsIHRyeSB0byBtb3ZlIHRoZSBzZWxlY3RlZCBibG9jayBjbG9zZXIgdG8gdGhlIG5leHQgb25lIGluXG50aGUgZG9jdW1lbnQgc3RydWN0dXJlIGJ5IGxpZnRpbmcgaXQgb3V0IG9mIGl0cyBwYXJlbnQgb3IgbW92aW5nIGl0XG5pbnRvIGEgcGFyZW50IG9mIHRoZSBwcmV2aW91cyBibG9jay4gV2lsbCB1c2UgdGhlIHZpZXcgZm9yIGFjY3VyYXRlXG4oYmlkaS1hd2FyZSkgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbiovXG5jb25zdCBqb2luQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEJlZm9yZSgkY3Vyc29yKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSB0aGlzLCB0cnkgdG8gbGlmdFxuICAgIGlmICghJGN1dCkge1xuICAgICAgICBsZXQgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmU7XG4gICAgLy8gQXBwbHkgdGhlIGpvaW5pbmcgYWxnb3JpdGhtXG4gICAgaWYgKCFiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZyAmJiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIElmIHRoZSBub2RlIGJlbG93IGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBhYm92ZSBpc1xuICAgIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBiZWxvdyBhbmQgc2VsZWN0IHRoZSBvbmUgYWJvdmUuXG4gICAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmXG4gICAgICAgICh0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpIHx8IE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGJlZm9yZSkpKSB7XG4gICAgICAgIGxldCBkZWxTdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCksIFNsaWNlLmVtcHR5KTtcbiAgICAgICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24odGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSA/IFNlbGVjdGlvbi5maW5kRnJvbSh0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcywgLTEpKSwgLTEpXG4gICAgICAgICAgICAgICAgICAgIDogTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIG5vZGUgYmVmb3JlIGlzIGFuIGF0b20sIGRlbGV0ZSBpdFxuICAgIGlmIChiZWZvcmUuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkY3V0LnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5BIG1vcmUgbGltaXRlZCBmb3JtIG9mIFtgam9pbkJhY2t3YXJkYF0oJGNvbW1hbmRzLmpvaW5CYWNrd2FyZClcbnRoYXQgb25seSB0cmllcyB0byBqb2luIHRoZSBjdXJyZW50IHRleHRibG9jayB0byB0aGUgb25lIGJlZm9yZVxuaXQsIGlmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuKi9cbmNvbnN0IGpvaW5UZXh0YmxvY2tCYWNrd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRjdXJzb3IpO1xuICAgIHJldHVybiAkY3V0ID8gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSA6IGZhbHNlO1xufTtcbi8qKlxuQSBtb3JlIGxpbWl0ZWQgZm9ybSBvZiBbYGpvaW5Gb3J3YXJkYF0oJGNvbW1hbmRzLmpvaW5Gb3J3YXJkKVxudGhhdCBvbmx5IHRyaWVzIHRvIGpvaW4gdGhlIGN1cnJlbnQgdGV4dGJsb2NrIHRvIHRoZSBvbmUgYWZ0ZXJcbml0LCBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2suXG4qL1xuY29uc3Qgam9pblRleHRibG9ja0ZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRBZnRlcigkY3Vyc29yKTtcbiAgICByZXR1cm4gJGN1dCA/IGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLCBiZWZvcmVUZXh0ID0gYmVmb3JlLCBiZWZvcmVQb3MgPSAkY3V0LnBvcyAtIDE7XG4gICAgZm9yICg7ICFiZWZvcmVUZXh0LmlzVGV4dGJsb2NrOyBiZWZvcmVQb3MtLSkge1xuICAgICAgICBpZiAoYmVmb3JlVGV4dC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSBiZWZvcmVUZXh0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYmVmb3JlVGV4dCA9IGNoaWxkO1xuICAgIH1cbiAgICBsZXQgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlciwgYWZ0ZXJUZXh0ID0gYWZ0ZXIsIGFmdGVyUG9zID0gJGN1dC5wb3MgKyAxO1xuICAgIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclBvcysrKSB7XG4gICAgICAgIGlmIChhZnRlclRleHQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gYWZ0ZXJUZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGFmdGVyVGV4dCA9IGNoaWxkO1xuICAgIH1cbiAgICBsZXQgc3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgYmVmb3JlUG9zLCBhZnRlclBvcywgU2xpY2UuZW1wdHkpO1xuICAgIGlmICghc3RlcCB8fCBzdGVwLmZyb20gIT0gYmVmb3JlUG9zIHx8XG4gICAgICAgIHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCAmJiBzdGVwLnNsaWNlLnNpemUgPj0gYWZ0ZXJQb3MgLSBiZWZvcmVQb3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChzdGVwKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgYmVmb3JlUG9zKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRleHRibG9ja0F0KG5vZGUsIHNpZGUsIG9ubHkgPSBmYWxzZSkge1xuICAgIGZvciAobGV0IHNjYW4gPSBub2RlOyBzY2FuOyBzY2FuID0gKHNpZGUgPT0gXCJzdGFydFwiID8gc2Nhbi5maXJzdENoaWxkIDogc2Nhbi5sYXN0Q2hpbGQpKSB7XG4gICAgICAgIGlmIChzY2FuLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvbmx5ICYmIHNjYW4uY2hpbGRDb3VudCAhPSAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLCBzZWxlY3RcbnRoZSBub2RlIGJlZm9yZSB0aGF0IHRleHRibG9jaywgaWYgcG9zc2libGUuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbmJvdW5kIHRvIGtleXMgbGlrZSBiYWNrc3BhY2UsIGFmdGVyXG5bYGpvaW5CYWNrd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luQmFja3dhcmQpIG9yIG90aGVyIGRlbGV0aW5nXG5jb21tYW5kcywgYXMgYSBmYWxsLWJhY2sgYmVoYXZpb3Igd2hlbiB0aGUgc2NoZW1hIGRvZXNuJ3QgYWxsb3dcbmRlbGV0aW9uIGF0IHRoZSBzZWxlY3RlZCBwb2ludC5cbiovXG5jb25zdCBzZWxlY3ROb2RlQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb24sICRjdXQgPSAkaGVhZDtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiYmFja3dhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0ID4gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGhlYWQpO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQmVmb3JlO1xuICAgIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsICRjdXQucG9zIC0gbm9kZS5ub2RlU2l6ZSkpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGZpbmRDdXRCZWZvcmUoJHBvcykge1xuICAgIGlmICghJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKCRwb3MuaW5kZXgoaSkgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKCRwb3MuYmVmb3JlKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGkpLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpIHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKVxuICAgICAgICA6ICRjdXJzb3IucGFyZW50T2Zmc2V0IDwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuICRjdXJzb3I7XG59XG4vKipcbklmIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiBhXG50ZXh0YmxvY2ssIHRyeSB0byByZWR1Y2Ugb3IgcmVtb3ZlIHRoZSBib3VuZGFyeSBiZXR3ZWVuIHRoYXQgYmxvY2tcbmFuZCB0aGUgb25lIGFmdGVyIGl0LCBlaXRoZXIgYnkgam9pbmluZyB0aGVtIG9yIGJ5IG1vdmluZyB0aGUgb3RoZXJcbmJsb2NrIGNsb3NlciB0byB0aGlzIG9uZSBpbiB0aGUgdHJlZSBzdHJ1Y3R1cmUuIFdpbGwgdXNlIHRoZSB2aWV3XG5mb3IgYWNjdXJhdGUgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbiovXG5jb25zdCBqb2luRm9yd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEFmdGVyKCRjdXJzb3IpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIG5vZGUgYWZ0ZXIgdGhpcywgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gICAgaWYgKCEkY3V0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXI7XG4gICAgLy8gVHJ5IHRoZSBqb2luaW5nIGFsZ29yaXRobVxuICAgIGlmIChkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIElmIHRoZSBub2RlIGFib3ZlIGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBiZWxvdyBpc1xuICAgIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBhYm92ZSBhbmQgc2VsZWN0IHRoZSBvbmUgYmVsb3cuXG4gICAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmXG4gICAgICAgICh0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSB8fCBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShhZnRlcikpKSB7XG4gICAgICAgIGxldCBkZWxTdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCksIFNsaWNlLmVtcHR5KTtcbiAgICAgICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24odGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIikgPyBTZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSwgMSlcbiAgICAgICAgICAgICAgICAgICAgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIG5leHQgbm9kZSBpcyBhbiBhdG9tLCBkZWxldGUgaXRcbiAgICBpZiAoYWZ0ZXIuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jaywgc2VsZWN0XG50aGUgbm9kZSBjb21pbmcgYWZ0ZXIgdGhhdCB0ZXh0YmxvY2ssIGlmIHBvc3NpYmxlLiBUaGlzIGlzIGludGVuZGVkXG50byBiZSBib3VuZCB0byBrZXlzIGxpa2UgZGVsZXRlLCBhZnRlclxuW2Bqb2luRm9yd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luRm9yd2FyZCkgYW5kIHNpbWlsYXIgZGVsZXRpbmdcbmNvbW1hbmRzLCB0byBwcm92aWRlIGEgZmFsbC1iYWNrIGJlaGF2aW9yIHdoZW4gdGhlIHNjaGVtYSBkb2Vzbid0XG5hbGxvdyBkZWxldGlvbiBhdCB0aGUgc2VsZWN0ZWQgcG9pbnQuXG4qL1xuY29uc3Qgc2VsZWN0Tm9kZUZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb24sICRjdXQgPSAkaGVhZDtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiZm9yd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPCAkaGVhZC5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAkY3V0ID0gZmluZEN1dEFmdGVyKCRoZWFkKTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSAkY3V0ICYmICRjdXQubm9kZUFmdGVyO1xuICAgIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsICRjdXQucG9zKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZmluZEN1dEFmdGVyKCRwb3MpIHtcbiAgICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLm5vZGUoaSk7XG4gICAgICAgICAgICBpZiAoJHBvcy5pbmRleChpKSArIDEgPCBwYXJlbnQuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZSgkcG9zLmFmdGVyKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuSm9pbiB0aGUgc2VsZWN0ZWQgYmxvY2sgb3IsIGlmIHRoZXJlIGlzIGEgdGV4dCBzZWxlY3Rpb24sIHRoZVxuY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGUgc2VsZWN0aW9uIHRoYXQgY2FuIGJlIGpvaW5lZCwgd2l0aFxudGhlIHNpYmxpbmcgYWJvdmUgaXQuXG4qL1xuY29uc3Qgam9pblVwID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIG5vZGVTZWwgPSBzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uLCBwb2ludDtcbiAgICBpZiAobm9kZVNlbCkge1xuICAgICAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIWNhbkpvaW4oc3RhdGUuZG9jLCBzZWwuZnJvbSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvaW50ID0gc2VsLmZyb207XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC5mcm9tLCAtMSk7XG4gICAgICAgIGlmIChwb2ludCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuam9pbihwb2ludCk7XG4gICAgICAgIGlmIChub2RlU2VsKVxuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9pbnQgLSBzdGF0ZS5kb2MucmVzb2x2ZShwb2ludCkubm9kZUJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Kb2luIHRoZSBzZWxlY3RlZCBibG9jaywgb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgdGhlIHNlbGVjdGlvblxudGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoIHRoZSBzaWJsaW5nIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGpvaW5Eb3duID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIHBvaW50O1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC50bykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvaW50ID0gc2VsLnRvO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwudG8sIDEpO1xuICAgICAgICBpZiAocG9pbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5qb2luKHBvaW50KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkxpZnQgdGhlIHNlbGVjdGVkIGJsb2NrLCBvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGVcbnNlbGVjdGlvbiB0aGF0IGNhbiBiZSBsaWZ0ZWQsIG91dCBvZiBpdHMgcGFyZW50IG5vZGUuXG4qL1xuY29uc3QgbGlmdCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aG9zZSB0eXBlIGhhcyBhIHRydXRoeVxuW2Bjb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCByZXBsYWNlIHRoZVxuc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lIGNoYXJhY3Rlci5cbiovXG5jb25zdCBuZXdsaW5lSW5Db2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmluc2VydFRleHQoXCJcXG5cIikuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2gpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCB7IHR5cGUgfSA9IG1hdGNoLmVkZ2UoaSk7XG4gICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSlcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aXRoIGEgdHJ1dGh5XG5bYGNvZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29kZSkgcHJvcGVydHkgaW4gaXRzIHNwZWMsIGNyZWF0ZSBhXG5kZWZhdWx0IGJsb2NrIGFmdGVyIHRoZSBjb2RlIGJsb2NrLCBhbmQgbW92ZSB0aGUgY3Vyc29yIHRoZXJlLlxuKi9cbmNvbnN0IGV4aXRDb2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYWJvdmUgPSAkaGVhZC5ub2RlKC0xKSwgYWZ0ZXIgPSAkaGVhZC5pbmRleEFmdGVyKC0xKSwgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KGFib3ZlLmNvbnRlbnRNYXRjaEF0KGFmdGVyKSk7XG4gICAgaWYgKCF0eXBlIHx8ICFhYm92ZS5jYW5SZXBsYWNlV2l0aChhZnRlciwgYWZ0ZXIsIHR5cGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBwb3MgPSAkaGVhZC5hZnRlcigpLCB0ciA9IHN0YXRlLnRyLnJlcGxhY2VXaXRoKHBvcywgcG9zLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShwb3MpLCAxKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIGEgYmxvY2sgbm9kZSBpcyBzZWxlY3RlZCwgY3JlYXRlIGFuIGVtcHR5IHBhcmFncmFwaCBiZWZvcmUgKGlmXG5pdCBpcyBpdHMgcGFyZW50J3MgZmlyc3QgY2hpbGQpIG9yIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGNyZWF0ZVBhcmFncmFwaE5lYXIgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgeyAkZnJvbSwgJHRvIH0gPSBzZWw7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbiB8fCAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KCR0by5wYXJlbnQuY29udGVudE1hdGNoQXQoJHRvLmluZGV4QWZ0ZXIoKSkpO1xuICAgIGlmICghdHlwZSB8fCAhdHlwZS5pc1RleHRibG9jaylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgc2lkZSA9ICghJGZyb20ucGFyZW50T2Zmc2V0ICYmICR0by5pbmRleCgpIDwgJHRvLnBhcmVudC5jaGlsZENvdW50ID8gJGZyb20gOiAkdG8pLnBvcztcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuaW5zZXJ0KHNpZGUsIHR5cGUuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgc2lkZSArIDEpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgdGhlIGN1cnNvciBpcyBpbiBhbiBlbXB0eSB0ZXh0YmxvY2sgdGhhdCBjYW4gYmUgbGlmdGVkLCBsaWZ0IHRoZVxuYmxvY2suXG4qL1xuY29uc3QgbGlmdEVtcHR5QmxvY2sgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoJGN1cnNvci5kZXB0aCA+IDEgJiYgJGN1cnNvci5hZnRlcigpICE9ICRjdXJzb3IuZW5kKC0xKSkge1xuICAgICAgICBsZXQgYmVmb3JlID0gJGN1cnNvci5iZWZvcmUoKTtcbiAgICAgICAgaWYgKGNhblNwbGl0KHN0YXRlLmRvYywgYmVmb3JlKSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNwbGl0KGJlZm9yZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ3JlYXRlIGEgdmFyaWFudCBvZiBbYHNwbGl0QmxvY2tgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRCbG9jaykgdGhhdCB1c2VzXG5hIGN1c3RvbSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgdGhlIG5ld2x5IHNwbGl0IG9mZiBibG9jay5cbiovXG5mdW5jdGlvbiBzcGxpdEJsb2NrQXMoc3BsaXROb2RlKSB7XG4gICAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzdGF0ZS5zZWxlY3Rpb24ubm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgICBpZiAoISRmcm9tLnBhcmVudE9mZnNldCB8fCAhY2FuU3BsaXQoc3RhdGUuZG9jLCAkZnJvbS5wb3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zcGxpdCgkZnJvbS5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkZnJvbS5wYXJlbnQuaXNCbG9jaylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgYXRFbmQgPSAkdG8ucGFyZW50T2Zmc2V0ID09ICR0by5wYXJlbnQuY29udGVudC5zaXplO1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiB8fCBzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBsZXQgZGVmbHQgPSAkZnJvbS5kZXB0aCA9PSAwID8gbnVsbCA6IGRlZmF1bHRCbG9ja0F0KCRmcm9tLm5vZGUoLTEpLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoLTEpKSk7XG4gICAgICAgICAgICBsZXQgc3BsaXRUeXBlID0gc3BsaXROb2RlICYmIHNwbGl0Tm9kZSgkdG8ucGFyZW50LCBhdEVuZCk7XG4gICAgICAgICAgICBsZXQgdHlwZXMgPSBzcGxpdFR5cGUgPyBbc3BsaXRUeXBlXSA6IGF0RW5kICYmIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgY2FuID0gY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gICAgICAgICAgICBpZiAoIXR5cGVzICYmICFjYW4gJiYgY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCBkZWZsdCA/IFt7IHR5cGU6IGRlZmx0IH1dIDogdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIGlmIChkZWZsdClcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMgPSBbeyB0eXBlOiBkZWZsdCB9XTtcbiAgICAgICAgICAgICAgICBjYW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbikge1xuICAgICAgICAgICAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWF0RW5kICYmICEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJGZyb20ucGFyZW50LnR5cGUgIT0gZGVmbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLCAkZmlyc3QgPSB0ci5kb2MucmVzb2x2ZShmaXJzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZsdCAmJiAkZnJvbS5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkZmlyc3QuaW5kZXgoKSwgJGZpcnN0LmluZGV4KCkgKyAxLCBkZWZsdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgZGVmbHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblNwbGl0IHRoZSBwYXJlbnQgYmxvY2sgb2YgdGhlIHNlbGVjdGlvbi4gSWYgdGhlIHNlbGVjdGlvbiBpcyBhIHRleHRcbnNlbGVjdGlvbiwgYWxzbyBkZWxldGUgaXRzIGNvbnRlbnQuXG4qL1xuY29uc3Qgc3BsaXRCbG9jayA9IHNwbGl0QmxvY2tBcygpO1xuLyoqXG5BY3RzIGxpa2UgW2BzcGxpdEJsb2NrYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLnNwbGl0QmxvY2spLCBidXQgd2l0aG91dFxucmVzZXR0aW5nIHRoZSBzZXQgb2YgYWN0aXZlIG1hcmtzIGF0IHRoZSBjdXJzb3IuXG4qL1xuY29uc3Qgc3BsaXRCbG9ja0tlZXBNYXJrcyA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICByZXR1cm4gc3BsaXRCbG9jayhzdGF0ZSwgZGlzcGF0Y2ggJiYgKHRyID0+IHtcbiAgICAgICAgbGV0IG1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgfHwgKHN0YXRlLnNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgICAgICAgaWYgKG1hcmtzKVxuICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MobWFya3MpO1xuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgfSkpO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBub2RlIHdyYXBwaW5nIHRoZSBjdXJyZW50IHNlbGVjdGlvbiwgaWZcbmFueS4gKFdpbGwgbm90IHNlbGVjdCB0aGUgZG9jdW1lbnQgbm9kZS4pXG4qL1xuY29uc3Qgc2VsZWN0UGFyZW50Tm9kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbiwgcG9zO1xuICAgIGxldCBzYW1lID0gJGZyb20uc2hhcmVkRGVwdGgodG8pO1xuICAgIGlmIChzYW1lID09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBwb3MgPSAkZnJvbS5iZWZvcmUoc2FtZSk7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCBwb3MpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIHdob2xlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdEFsbCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgQWxsU2VsZWN0aW9uKHN0YXRlLmRvYykpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBqb2luTWF5YmVDbGVhcihzdGF0ZSwgJHBvcywgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlLCBhZnRlciA9ICRwb3Mubm9kZUFmdGVyLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICBpZiAoIWJlZm9yZSB8fCAhYWZ0ZXIgfHwgIWJlZm9yZS50eXBlLmNvbXBhdGlibGVDb250ZW50KGFmdGVyLnR5cGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFiZWZvcmUuY29udGVudC5zaXplICYmICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXggLSAxLCBpbmRleCkpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRwb3MucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkcG9zLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoISRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSkgfHwgIShhZnRlci5pc1RleHRibG9jayB8fCBjYW5Kb2luKHN0YXRlLmRvYywgJHBvcy5wb3MpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHJcbiAgICAgICAgICAgIC5jbGVhckluY29tcGF0aWJsZSgkcG9zLnBvcywgYmVmb3JlLnR5cGUsIGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpXG4gICAgICAgICAgICAuam9pbigkcG9zLnBvcylcbiAgICAgICAgICAgIC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlciwgY29ubiwgbWF0Y2g7XG4gICAgaWYgKGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoam9pbk1heWJlQ2xlYXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGNhbkRlbEFmdGVyID0gJGN1dC5wYXJlbnQuY2FuUmVwbGFjZSgkY3V0LmluZGV4KCksICRjdXQuaW5kZXgoKSArIDEpO1xuICAgIGlmIChjYW5EZWxBZnRlciAmJlxuICAgICAgICAoY29ubiA9IChtYXRjaCA9IGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpLmZpbmRXcmFwcGluZyhhZnRlci50eXBlKSkgJiZcbiAgICAgICAgbWF0Y2gubWF0Y2hUeXBlKGNvbm5bMF0gfHwgYWZ0ZXIudHlwZSkudmFsaWRFbmQpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSwgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbm4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oY29ubltpXS5jcmVhdGUobnVsbCwgd3JhcCkpO1xuICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oYmVmb3JlLmNvcHkod3JhcCkpO1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSAxLCBlbmQsICRjdXQucG9zLCBlbmQsIG5ldyBTbGljZSh3cmFwLCAxLCAwKSwgY29ubi5sZW5ndGgsIHRydWUpKTtcbiAgICAgICAgICAgIGxldCBqb2luQXQgPSBlbmQgKyAyICogY29ubi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY2FuSm9pbih0ci5kb2MsIGpvaW5BdCkpXG4gICAgICAgICAgICAgICAgdHIuam9pbihqb2luQXQpO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBzZWxBZnRlciA9IFNlbGVjdGlvbi5maW5kRnJvbSgkY3V0LCAxKTtcbiAgICBsZXQgcmFuZ2UgPSBzZWxBZnRlciAmJiBzZWxBZnRlci4kZnJvbS5ibG9ja1JhbmdlKHNlbEFmdGVyLiR0byksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQgPj0gJGN1dC5kZXB0aCkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNhbkRlbEFmdGVyICYmIHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIsIHRydWUpICYmIHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikpIHtcbiAgICAgICAgbGV0IGF0ID0gYmVmb3JlLCB3cmFwID0gW107XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHdyYXAucHVzaChhdCk7XG4gICAgICAgICAgICBpZiAoYXQuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBhdCA9IGF0Lmxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWZ0ZXJUZXh0ID0gYWZ0ZXIsIGFmdGVyRGVwdGggPSAxO1xuICAgICAgICBmb3IgKDsgIWFmdGVyVGV4dC5pc1RleHRibG9jazsgYWZ0ZXJUZXh0ID0gYWZ0ZXJUZXh0LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBhZnRlckRlcHRoKys7XG4gICAgICAgIGlmIChhdC5jYW5SZXBsYWNlKGF0LmNoaWxkQ291bnQsIGF0LmNoaWxkQ291bnQsIGFmdGVyVGV4dC5jb250ZW50KSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB3cmFwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBGcmFnbWVudC5mcm9tKHdyYXBbaV0uY29weShlbmQpKTtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkY3V0LnBvcyAtIHdyYXAubGVuZ3RoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLCAkY3V0LnBvcyArIGFmdGVyRGVwdGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUgLSBhZnRlckRlcHRoLCBuZXcgU2xpY2UoZW5kLCB3cmFwLmxlbmd0aCwgMCksIDAsIHRydWUpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdFRleHRibG9ja1NpZGUoc2lkZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sICRwb3MgPSBzaWRlIDwgMCA/IHNlbC4kZnJvbSA6IHNlbC4kdG87XG4gICAgICAgIGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7XG4gICAgICAgIHdoaWxlICgkcG9zLm5vZGUoZGVwdGgpLmlzSW5saW5lKSB7XG4gICAgICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkcG9zLm5vZGUoZGVwdGgpLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCBzaWRlIDwgMCA/ICRwb3Muc3RhcnQoZGVwdGgpIDogJHBvcy5lbmQoZGVwdGgpKSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5Nb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBzdGFydCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4qL1xuY29uc3Qgc2VsZWN0VGV4dGJsb2NrU3RhcnQgPSBzZWxlY3RUZXh0YmxvY2tTaWRlKC0xKTtcbi8qKlxuTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgZW5kIG9mIGN1cnJlbnQgdGV4dCBibG9jay5cbiovXG5jb25zdCBzZWxlY3RUZXh0YmxvY2tFbmQgPSBzZWxlY3RUZXh0YmxvY2tTaWRlKDEpO1xuLy8gUGFyYW1ldGVyaXplZCBjb21tYW5kc1xuLyoqXG5XcmFwIHRoZSBzZWxlY3Rpb24gaW4gYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIHdpdGggdGhlIGdpdmVuXG5hdHRyaWJ1dGVzLlxuKi9cbmZ1bmN0aW9uIHdyYXBJbihub2RlVHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIHdyYXBwaW5nID0gcmFuZ2UgJiYgZmluZFdyYXBwaW5nKHJhbmdlLCBub2RlVHlwZSwgYXR0cnMpO1xuICAgICAgICBpZiAoIXdyYXBwaW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci53cmFwKHJhbmdlLCB3cmFwcGluZykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblJldHVybnMgYSBjb21tYW5kIHRoYXQgdHJpZXMgdG8gc2V0IHRoZSBzZWxlY3RlZCB0ZXh0YmxvY2tzIHRvIHRoZVxuZ2l2ZW4gbm9kZSB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4qL1xuZnVuY3Rpb24gc2V0QmxvY2tUeXBlKG5vZGVUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgYXBwbGljYWJsZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoICYmICFhcHBsaWNhYmxlOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7ICRmcm9tOiB7IHBvczogZnJvbSB9LCAkdG86IHsgcG9zOiB0byB9IH0gPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzW2ldO1xuICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhcHBsaWNhYmxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmlzVGV4dGJsb2NrIHx8IG5vZGUuaGFzTWFya3VwKG5vZGVUeXBlLCBhdHRycykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09IG5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGljYWJsZSA9ICRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIG5vZGVUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFwcGxpY2FibGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyAkZnJvbTogeyBwb3M6IGZyb20gfSwgJHRvOiB7IHBvczogdG8gfSB9ID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICB0ci5zZXRCbG9ja1R5cGUoZnJvbSwgdG8sIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFya0FwcGxpZXMoZG9jLCByYW5nZXMsIHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgIGxldCBjYW4gPSAkZnJvbS5kZXB0aCA9PSAwID8gZG9jLmlubGluZUNvbnRlbnQgJiYgZG9jLnR5cGUuYWxsb3dzTWFya1R5cGUodHlwZSkgOiBmYWxzZTtcbiAgICAgICAgZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYW4gPSBub2RlLmlubGluZUNvbnRlbnQgJiYgbm9kZS50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNhbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB0b2dnbGVzIHRoZSBnaXZlbiBtYXJrIHdpdGggdGhlXG5naXZlbiBhdHRyaWJ1dGVzLiBXaWxsIHJldHVybiBgZmFsc2VgIHdoZW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5kb2Vzbid0IHN1cHBvcnQgdGhhdCBtYXJrLiBUaGlzIHdpbGwgcmVtb3ZlIHRoZSBtYXJrIGlmIGFueSBtYXJrc1xub2YgdGhhdCB0eXBlIGV4aXN0IGluIHRoZSBzZWxlY3Rpb24sIG9yIGFkZCBpdCBvdGhlcndpc2UuIElmIHRoZVxuc2VsZWN0aW9uIGlzIGVtcHR5LCB0aGlzIGFwcGxpZXMgdG8gdGhlIFtzdG9yZWRcbm1hcmtzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuc3RvcmVkTWFya3MpIGluc3RlYWQgb2YgYSByYW5nZSBvZiB0aGVcbmRvY3VtZW50LlxuKi9cbmZ1bmN0aW9uIHRvZ2dsZU1hcmsobWFya1R5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7IGVtcHR5LCAkY3Vyc29yLCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKChlbXB0eSAmJiAhJGN1cnNvcikgfHwgIW1hcmtBcHBsaWVzKHN0YXRlLmRvYywgcmFuZ2VzLCBtYXJrVHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUuaXNJblNldChzdGF0ZS5zdG9yZWRNYXJrcyB8fCAkY3Vyc29yLm1hcmtzKCkpKVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5hZGRTdG9yZWRNYXJrKG1hcmtUeXBlLmNyZWF0ZShhdHRycykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBoYXMgPSBmYWxzZSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgIWhhcyAmJiBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaGFzID0gc3RhdGUuZG9jLnJhbmdlSGFzTWFyaygkZnJvbS5wb3MsICR0by5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5yZW1vdmVNYXJrKCRmcm9tLnBvcywgJHRvLnBvcywgbWFya1R5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSAkZnJvbS5wb3MsIHRvID0gJHRvLnBvcywgc3RhcnQgPSAkZnJvbS5ub2RlQWZ0ZXIsIGVuZCA9ICR0by5ub2RlQmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlU3RhcnQgPSBzdGFydCAmJiBzdGFydC5pc1RleHQgPyAvXlxccyovLmV4ZWMoc3RhcnQudGV4dClbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUVuZCA9IGVuZCAmJiBlbmQuaXNUZXh0ID8gL1xccyokLy5leGVjKGVuZC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gKyBzcGFjZVN0YXJ0IDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHNwYWNlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gLT0gc3BhY2VFbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGZyb20sIHRvLCBtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgaXNKb2luYWJsZSkge1xuICAgIHJldHVybiAodHIpID0+IHtcbiAgICAgICAgaWYgKCF0ci5pc0dlbmVyaWMpXG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2godHIpO1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHIubWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gdHIubWFwcGluZy5tYXBzW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYW5nZXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgcmFuZ2VzW2pdID0gbWFwLm1hcChyYW5nZXNbal0pO1xuICAgICAgICAgICAgbWFwLmZvckVhY2goKF9zLCBfZSwgZnJvbSwgdG8pID0+IHJhbmdlcy5wdXNoKGZyb20sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBqb2luYWJsZSBwb2ludHMgZXhpc3QgaW5zaWRlIHRob3NlIHJhbmdlcyxcbiAgICAgICAgLy8gYnkgY2hlY2tpbmcgYWxsIG5vZGUgYm91bmRhcmllcyBpbiB0aGVpciBwYXJlbnQgbm9kZXMuXG4gICAgICAgIGxldCBqb2luYWJsZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbaV0sIHRvID0gcmFuZ2VzW2kgKyAxXTtcbiAgICAgICAgICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCBkZXB0aCA9ICRmcm9tLnNoYXJlZERlcHRoKHRvKSwgcGFyZW50ID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9ICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpLCBwb3MgPSAkZnJvbS5hZnRlcihkZXB0aCArIDEpOyBwb3MgPD0gdG87ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICYmIGpvaW5hYmxlLmluZGV4T2YocG9zKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gcGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUudHlwZSA9PSBhZnRlci50eXBlICYmIGlzSm9pbmFibGUoYmVmb3JlLCBhZnRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luYWJsZS5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBhZnRlci5ub2RlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKb2luIHRoZSBqb2luYWJsZSBwb2ludHNcbiAgICAgICAgam9pbmFibGUuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICBmb3IgKGxldCBpID0gam9pbmFibGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChjYW5Kb2luKHRyLmRvYywgam9pbmFibGVbaV0pKVxuICAgICAgICAgICAgICAgIHRyLmpvaW4oam9pbmFibGVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9O1xufVxuLyoqXG5XcmFwIGEgY29tbWFuZCBzbyB0aGF0LCB3aGVuIGl0IHByb2R1Y2VzIGEgdHJhbnNmb3JtIHRoYXQgY2F1c2VzXG50d28gam9pbmFibGUgbm9kZXMgdG8gZW5kIHVwIG5leHQgdG8gZWFjaCBvdGhlciwgdGhvc2UgYXJlIGpvaW5lZC5cbk5vZGVzIGFyZSBjb25zaWRlcmVkIGpvaW5hYmxlIHdoZW4gdGhleSBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmRcbndoZW4gdGhlIGBpc0pvaW5hYmxlYCBwcmVkaWNhdGUgcmV0dXJucyB0cnVlIGZvciB0aGVtIG9yLCBpZiBhblxuYXJyYXkgb2Ygc3RyaW5ncyB3YXMgcGFzc2VkLCBpZiB0aGVpciBub2RlIHR5cGUgbmFtZSBpcyBpbiB0aGF0XG5hcnJheS5cbiovXG5mdW5jdGlvbiBhdXRvSm9pbihjb21tYW5kLCBpc0pvaW5hYmxlKSB7XG4gICAgbGV0IGNhbkpvaW4gPSBBcnJheS5pc0FycmF5KGlzSm9pbmFibGUpID8gKG5vZGUpID0+IGlzSm9pbmFibGUuaW5kZXhPZihub2RlLnR5cGUubmFtZSkgPiAtMVxuICAgICAgICA6IGlzSm9pbmFibGU7XG4gICAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IGNvbW1hbmQoc3RhdGUsIGRpc3BhdGNoICYmIHdyYXBEaXNwYXRjaEZvckpvaW4oZGlzcGF0Y2gsIGNhbkpvaW4pLCB2aWV3KTtcbn1cbi8qKlxuQ29tYmluZSBhIG51bWJlciBvZiBjb21tYW5kIGZ1bmN0aW9ucyBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uICh3aGljaFxuY2FsbHMgdGhlbSBvbmUgYnkgb25lIHVudGlsIG9uZSByZXR1cm5zIHRydWUpLlxuKi9cbmZ1bmN0aW9uIGNoYWluQ29tbWFuZHMoLi4uY29tbWFuZHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNvbW1hbmRzW2ldKHN0YXRlLCBkaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxubGV0IGJhY2tzcGFjZSA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luQmFja3dhcmQsIHNlbGVjdE5vZGVCYWNrd2FyZCk7XG5sZXQgZGVsID0gY2hhaW5Db21tYW5kcyhkZWxldGVTZWxlY3Rpb24sIGpvaW5Gb3J3YXJkLCBzZWxlY3ROb2RlRm9yd2FyZCk7XG4vKipcbkEgYmFzaWMga2V5bWFwIGNvbnRhaW5pbmcgYmluZGluZ3Mgbm90IHNwZWNpZmljIHRvIGFueSBzY2hlbWEuXG5CaW5kcyB0aGUgZm9sbG93aW5nIGtleXMgKHdoZW4gbXVsdGlwbGUgY29tbWFuZHMgYXJlIGxpc3RlZCwgdGhleVxuYXJlIGNoYWluZWQgd2l0aCBbYGNoYWluQ29tbWFuZHNgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuY2hhaW5Db21tYW5kcykpOlxuXG4qICoqRW50ZXIqKiB0byBgbmV3bGluZUluQ29kZWAsIGBjcmVhdGVQYXJhZ3JhcGhOZWFyYCwgYGxpZnRFbXB0eUJsb2NrYCwgYHNwbGl0QmxvY2tgXG4qICoqTW9kLUVudGVyKiogdG8gYGV4aXRDb2RlYFxuKiAqKkJhY2tzcGFjZSoqIGFuZCAqKk1vZC1CYWNrc3BhY2UqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5CYWNrd2FyZGAsIGBzZWxlY3ROb2RlQmFja3dhcmRgXG4qICoqRGVsZXRlKiogYW5kICoqTW9kLURlbGV0ZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkZvcndhcmRgLCBgc2VsZWN0Tm9kZUZvcndhcmRgXG4qICoqTW9kLURlbGV0ZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkZvcndhcmRgLCBgc2VsZWN0Tm9kZUZvcndhcmRgXG4qICoqTW9kLWEqKiB0byBgc2VsZWN0QWxsYFxuKi9cbmNvbnN0IHBjQmFzZUtleW1hcCA9IHtcbiAgICBcIkVudGVyXCI6IGNoYWluQ29tbWFuZHMobmV3bGluZUluQ29kZSwgY3JlYXRlUGFyYWdyYXBoTmVhciwgbGlmdEVtcHR5QmxvY2ssIHNwbGl0QmxvY2spLFxuICAgIFwiTW9kLUVudGVyXCI6IGV4aXRDb2RlLFxuICAgIFwiQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIk1vZC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICAgIFwiU2hpZnQtQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIkRlbGV0ZVwiOiBkZWwsXG4gICAgXCJNb2QtRGVsZXRlXCI6IGRlbCxcbiAgICBcIk1vZC1hXCI6IHNlbGVjdEFsbFxufTtcbi8qKlxuQSBjb3B5IG9mIGBwY0Jhc2VLZXltYXBgIHRoYXQgYWxzbyBiaW5kcyAqKkN0cmwtaCoqIGxpa2UgQmFja3NwYWNlLFxuKipDdHJsLWQqKiBsaWtlIERlbGV0ZSwgKipBbHQtQmFja3NwYWNlKiogbGlrZSBDdHJsLUJhY2tzcGFjZSwgYW5kXG4qKkN0cmwtQWx0LUJhY2tzcGFjZSoqLCAqKkFsdC1EZWxldGUqKiwgYW5kICoqQWx0LWQqKiBsaWtlXG5DdHJsLURlbGV0ZS5cbiovXG5jb25zdCBtYWNCYXNlS2V5bWFwID0ge1xuICAgIFwiQ3RybC1oXCI6IHBjQmFzZUtleW1hcFtcIkJhY2tzcGFjZVwiXSxcbiAgICBcIkFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLUJhY2tzcGFjZVwiXSxcbiAgICBcIkN0cmwtZFwiOiBwY0Jhc2VLZXltYXBbXCJEZWxldGVcIl0sXG4gICAgXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkFsdC1EZWxldGVcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkFsdC1kXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJDdHJsLWFcIjogc2VsZWN0VGV4dGJsb2NrU3RhcnQsXG4gICAgXCJDdHJsLWVcIjogc2VsZWN0VGV4dGJsb2NrRW5kXG59O1xuZm9yIChsZXQga2V5IGluIHBjQmFzZUtleW1hcClcbiAgICBtYWNCYXNlS2V5bWFwW2tleV0gPSBwY0Jhc2VLZXltYXBba2V5XTtcbmNvbnN0IG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IC9NYWN8aVAoaG9uZXxbb2FdZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICA6IHR5cGVvZiBvcyAhPSBcInVuZGVmaW5lZFwiICYmIG9zLnBsYXRmb3JtID8gb3MucGxhdGZvcm0oKSA9PSBcImRhcndpblwiIDogZmFsc2U7XG4vKipcbkRlcGVuZGluZyBvbiB0aGUgZGV0ZWN0ZWQgcGxhdGZvcm0sIHRoaXMgd2lsbCBob2xkXG5bYHBjQmFzZWtleW1hcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5wY0Jhc2VLZXltYXApIG9yXG5bYG1hY0Jhc2VLZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMubWFjQmFzZUtleW1hcCkuXG4qL1xuY29uc3QgYmFzZUtleW1hcCA9IG1hYyA/IG1hY0Jhc2VLZXltYXAgOiBwY0Jhc2VLZXltYXA7XG5cbmV4cG9ydCB7IGF1dG9Kb2luLCBiYXNlS2V5bWFwLCBjaGFpbkNvbW1hbmRzLCBjcmVhdGVQYXJhZ3JhcGhOZWFyLCBkZWxldGVTZWxlY3Rpb24sIGV4aXRDb2RlLCBqb2luQmFja3dhcmQsIGpvaW5Eb3duLCBqb2luRm9yd2FyZCwgam9pblRleHRibG9ja0JhY2t3YXJkLCBqb2luVGV4dGJsb2NrRm9yd2FyZCwgam9pblVwLCBsaWZ0LCBsaWZ0RW1wdHlCbG9jaywgbWFjQmFzZUtleW1hcCwgbmV3bGluZUluQ29kZSwgcGNCYXNlS2V5bWFwLCBzZWxlY3RBbGwsIHNlbGVjdE5vZGVCYWNrd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQsIHNlbGVjdFBhcmVudE5vZGUsIHNlbGVjdFRleHRibG9ja0VuZCwgc2VsZWN0VGV4dGJsb2NrU3RhcnQsIHNldEJsb2NrVHlwZSwgc3BsaXRCbG9jaywgc3BsaXRCbG9ja0FzLCBzcGxpdEJsb2NrS2VlcE1hcmtzLCB0b2dnbGVNYXJrLCB3cmFwSW4gfTtcbiIsICJpbXBvcnQgeyBmaW5kV3JhcHBpbmcsIFJlcGxhY2VBcm91bmRTdGVwLCBjYW5TcGxpdCwgbGlmdFRhcmdldCwgY2FuSm9pbiB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBOb2RlUmFuZ2UsIEZyYWdtZW50LCBTbGljZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuY29uc3Qgb2xET00gPSBbXCJvbFwiLCAwXSwgdWxET00gPSBbXCJ1bFwiLCAwXSwgbGlET00gPSBbXCJsaVwiLCAwXTtcbi8qKlxuQW4gb3JkZXJlZCBsaXN0IFtub2RlIHNwZWNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYykuIEhhcyBhIHNpbmdsZVxuYXR0cmlidXRlLCBgb3JkZXJgLCB3aGljaCBkZXRlcm1pbmVzIHRoZSBudW1iZXIgYXQgd2hpY2ggdGhlIGxpc3RcbnN0YXJ0cyBjb3VudGluZywgYW5kIGRlZmF1bHRzIHRvIDEuIFJlcHJlc2VudGVkIGFzIGFuIGA8b2w+YFxuZWxlbWVudC5cbiovXG5jb25zdCBvcmRlcmVkTGlzdCA9IHtcbiAgICBhdHRyczogeyBvcmRlcjogeyBkZWZhdWx0OiAxIH0gfSxcbiAgICBwYXJzZURPTTogW3sgdGFnOiBcIm9sXCIsIGdldEF0dHJzKGRvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG9yZGVyOiBkb20uaGFzQXR0cmlidXRlKFwic3RhcnRcIikgPyArZG9tLmdldEF0dHJpYnV0ZShcInN0YXJ0XCIpIDogMSB9O1xuICAgICAgICAgICAgfSB9XSxcbiAgICB0b0RPTShub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmF0dHJzLm9yZGVyID09IDEgPyBvbERPTSA6IFtcIm9sXCIsIHsgc3RhcnQ6IG5vZGUuYXR0cnMub3JkZXIgfSwgMF07XG4gICAgfVxufTtcbi8qKlxuQSBidWxsZXQgbGlzdCBub2RlIHNwZWMsIHJlcHJlc2VudGVkIGluIHRoZSBET00gYXMgYDx1bD5gLlxuKi9cbmNvbnN0IGJ1bGxldExpc3QgPSB7XG4gICAgcGFyc2VET006IFt7IHRhZzogXCJ1bFwiIH1dLFxuICAgIHRvRE9NKCkgeyByZXR1cm4gdWxET007IH1cbn07XG4vKipcbkEgbGlzdCBpdGVtIChgPGxpPmApIHNwZWMuXG4qL1xuY29uc3QgbGlzdEl0ZW0gPSB7XG4gICAgcGFyc2VET006IFt7IHRhZzogXCJsaVwiIH1dLFxuICAgIHRvRE9NKCkgeyByZXR1cm4gbGlET007IH0sXG4gICAgZGVmaW5pbmc6IHRydWVcbn07XG5mdW5jdGlvbiBhZGQob2JqLCBwcm9wcykge1xuICAgIGxldCBjb3B5ID0ge307XG4gICAgZm9yIChsZXQgcHJvcCBpbiBvYmopXG4gICAgICAgIGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcylcbiAgICAgICAgY29weVtwcm9wXSA9IHByb3BzW3Byb3BdO1xuICAgIHJldHVybiBjb3B5O1xufVxuLyoqXG5Db252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgYWRkaW5nIGxpc3QtcmVsYXRlZCBub2RlIHR5cGVzIHRvIGEgbWFwXG5zcGVjaWZ5aW5nIHRoZSBub2RlcyBmb3IgYSBzY2hlbWEuIEFkZHNcbltgb3JkZXJlZExpc3RgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc2NoZW1hLWxpc3Qub3JkZXJlZExpc3QpIGFzIGBcIm9yZGVyZWRfbGlzdFwiYCxcbltgYnVsbGV0TGlzdGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzY2hlbWEtbGlzdC5idWxsZXRMaXN0KSBhcyBgXCJidWxsZXRfbGlzdFwiYCwgYW5kXG5bYGxpc3RJdGVtYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3NjaGVtYS1saXN0Lmxpc3RJdGVtKSBhcyBgXCJsaXN0X2l0ZW1cImAuXG5cbmBpdGVtQ29udGVudGAgZGV0ZXJtaW5lcyB0aGUgY29udGVudCBleHByZXNzaW9uIGZvciB0aGUgbGlzdCBpdGVtcy5cbklmIHlvdSB3YW50IHRoZSBjb21tYW5kcyBkZWZpbmVkIGluIHRoaXMgbW9kdWxlIHRvIGFwcGx5IHRvIHlvdXJcbmxpc3Qgc3RydWN0dXJlLCBpdCBzaG91bGQgaGF2ZSBhIHNoYXBlIGxpa2UgYFwicGFyYWdyYXBoIGJsb2NrKlwiYCBvclxuYFwicGFyYWdyYXBoIChvcmRlcmVkX2xpc3QgfCBidWxsZXRfbGlzdCkqXCJgLiBgbGlzdEdyb3VwYCBjYW4gYmVcbmdpdmVuIHRvIGFzc2lnbiBhIGdyb3VwIG5hbWUgdG8gdGhlIGxpc3Qgbm9kZSB0eXBlcywgZm9yIGV4YW1wbGVcbmBcImJsb2NrXCJgLlxuKi9cbmZ1bmN0aW9uIGFkZExpc3ROb2Rlcyhub2RlcywgaXRlbUNvbnRlbnQsIGxpc3RHcm91cCkge1xuICAgIHJldHVybiBub2Rlcy5hcHBlbmQoe1xuICAgICAgICBvcmRlcmVkX2xpc3Q6IGFkZChvcmRlcmVkTGlzdCwgeyBjb250ZW50OiBcImxpc3RfaXRlbStcIiwgZ3JvdXA6IGxpc3RHcm91cCB9KSxcbiAgICAgICAgYnVsbGV0X2xpc3Q6IGFkZChidWxsZXRMaXN0LCB7IGNvbnRlbnQ6IFwibGlzdF9pdGVtK1wiLCBncm91cDogbGlzdEdyb3VwIH0pLFxuICAgICAgICBsaXN0X2l0ZW06IGFkZChsaXN0SXRlbSwgeyBjb250ZW50OiBpdGVtQ29udGVudCB9KVxuICAgIH0pO1xufVxuLyoqXG5SZXR1cm5zIGEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHdyYXBzIHRoZSBzZWxlY3Rpb24gaW4gYSBsaXN0IHdpdGhcbnRoZSBnaXZlbiB0eXBlIGFuIGF0dHJpYnV0ZXMuIElmIGBkaXNwYXRjaGAgaXMgbnVsbCwgb25seSByZXR1cm4gYVxudmFsdWUgdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIGlzIHBvc3NpYmxlLCBidXQgZG9uJ3QgYWN0dWFsbHlcbnBlcmZvcm0gdGhlIGNoYW5nZS5cbiovXG5mdW5jdGlvbiB3cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSwgZG9Kb2luID0gZmFsc2UsIG91dGVyUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gVGhpcyBpcyBhdCB0aGUgdG9wIG9mIGFuIGV4aXN0aW5nIGxpc3QgaXRlbVxuICAgICAgICBpZiAocmFuZ2UuZGVwdGggPj0gMiAmJiAkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZS5jb21wYXRpYmxlQ29udGVudChsaXN0VHlwZSkgJiYgcmFuZ2Uuc3RhcnRJbmRleCA9PSAwKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGlzIGlzIHRoZSB0b3Agb2YgdGhlIGxpc3RcbiAgICAgICAgICAgIGlmICgkZnJvbS5pbmRleChyYW5nZS5kZXB0aCAtIDEpID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0ICRpbnNlcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShyYW5nZS5zdGFydCAtIDIpO1xuICAgICAgICAgICAgb3V0ZXJSYW5nZSA9IG5ldyBOb2RlUmFuZ2UoJGluc2VydCwgJGluc2VydCwgcmFuZ2UuZGVwdGgpO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVuZEluZGV4IDwgcmFuZ2UucGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKCRmcm9tLCBzdGF0ZS5kb2MucmVzb2x2ZSgkdG8uZW5kKHJhbmdlLmRlcHRoKSksIHJhbmdlLmRlcHRoKTtcbiAgICAgICAgICAgIGRvSm9pbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdyYXAgPSBmaW5kV3JhcHBpbmcob3V0ZXJSYW5nZSwgbGlzdFR5cGUsIGF0dHJzLCByYW5nZSk7XG4gICAgICAgIGlmICghd3JhcClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goZG9XcmFwSW5MaXN0KHN0YXRlLnRyLCByYW5nZSwgd3JhcCwgZG9Kb2luLCBsaXN0VHlwZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBkb1dyYXBJbkxpc3QodHIsIHJhbmdlLCB3cmFwcGVycywgam9pbkJlZm9yZSwgbGlzdFR5cGUpIHtcbiAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGkgPSB3cmFwcGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20od3JhcHBlcnNbaV0udHlwZS5jcmVhdGUod3JhcHBlcnNbaV0uYXR0cnMsIGNvbnRlbnQpKTtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChyYW5nZS5zdGFydCAtIChqb2luQmVmb3JlID8gMiA6IDApLCByYW5nZS5lbmQsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIG5ldyBTbGljZShjb250ZW50LCAwLCAwKSwgd3JhcHBlcnMubGVuZ3RoLCB0cnVlKSk7XG4gICAgbGV0IGZvdW5kID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXBwZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAod3JhcHBlcnNbaV0udHlwZSA9PSBsaXN0VHlwZSlcbiAgICAgICAgICAgIGZvdW5kID0gaSArIDE7XG4gICAgbGV0IHNwbGl0RGVwdGggPSB3cmFwcGVycy5sZW5ndGggLSBmb3VuZDtcbiAgICBsZXQgc3BsaXRQb3MgPSByYW5nZS5zdGFydCArIHdyYXBwZXJzLmxlbmd0aCAtIChqb2luQmVmb3JlID8gMiA6IDApLCBwYXJlbnQgPSByYW5nZS5wYXJlbnQ7XG4gICAgZm9yIChsZXQgaSA9IHJhbmdlLnN0YXJ0SW5kZXgsIGUgPSByYW5nZS5lbmRJbmRleCwgZmlyc3QgPSB0cnVlOyBpIDwgZTsgaSsrLCBmaXJzdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghZmlyc3QgJiYgY2FuU3BsaXQodHIuZG9jLCBzcGxpdFBvcywgc3BsaXREZXB0aCkpIHtcbiAgICAgICAgICAgIHRyLnNwbGl0KHNwbGl0UG9zLCBzcGxpdERlcHRoKTtcbiAgICAgICAgICAgIHNwbGl0UG9zICs9IDIgKiBzcGxpdERlcHRoO1xuICAgICAgICB9XG4gICAgICAgIHNwbGl0UG9zICs9IHBhcmVudC5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRyO1xufVxuLyoqXG5CdWlsZCBhIGNvbW1hbmQgdGhhdCBzcGxpdHMgYSBub24tZW1wdHkgdGV4dGJsb2NrIGF0IHRoZSB0b3AgbGV2ZWxcbm9mIGEgbGlzdCBpdGVtIGJ5IGFsc28gc3BsaXR0aW5nIHRoYXQgbGlzdCBpdGVtLlxuKi9cbmZ1bmN0aW9uIHNwbGl0TGlzdEl0ZW0oaXRlbVR5cGUsIGl0ZW1BdHRycykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8sIG5vZGUgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKChub2RlICYmIG5vZGUuaXNCbG9jaykgfHwgJGZyb20uZGVwdGggPCAyIHx8ICEkZnJvbS5zYW1lUGFyZW50KCR0bykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBncmFuZFBhcmVudCA9ICRmcm9tLm5vZGUoLTEpO1xuICAgICAgICBpZiAoZ3JhbmRQYXJlbnQudHlwZSAhPSBpdGVtVHlwZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCRmcm9tLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJiAkZnJvbS5ub2RlKC0xKS5jaGlsZENvdW50ID09ICRmcm9tLmluZGV4QWZ0ZXIoLTEpKSB7XG4gICAgICAgICAgICAvLyBJbiBhbiBlbXB0eSBibG9jay4gSWYgdGhpcyBpcyBhIG5lc3RlZCBsaXN0LCB0aGUgd3JhcHBpbmdcbiAgICAgICAgICAgIC8vIGxpc3QgaXRlbSBzaG91bGQgYmUgc3BsaXQuIE90aGVyd2lzZSwgYmFpbCBvdXQgYW5kIGxldCBuZXh0XG4gICAgICAgICAgICAvLyBjb21tYW5kIGhhbmRsZSBsaWZ0aW5nLlxuICAgICAgICAgICAgaWYgKCRmcm9tLmRlcHRoID09IDMgfHwgJGZyb20ubm9kZSgtMykudHlwZSAhPSBpdGVtVHlwZSB8fFxuICAgICAgICAgICAgICAgICRmcm9tLmluZGV4KC0yKSAhPSAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50IC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgICAgIGxldCBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogMztcbiAgICAgICAgICAgICAgICAvLyBCdWlsZCBhIGZyYWdtZW50IGNvbnRhaW5pbmcgZW1wdHkgdmVyc2lvbnMgb2YgdGhlIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIC8vIGZyb20gdGhlIG91dGVyIGxpc3QgaXRlbSB0byB0aGUgcGFyZW50IG5vZGUgb2YgdGhlIGN1cnNvclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCAtIGRlcHRoQmVmb3JlOyBkID49ICRmcm9tLmRlcHRoIC0gMzsgZC0tKVxuICAgICAgICAgICAgICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkod3JhcCkpO1xuICAgICAgICAgICAgICAgIGxldCBkZXB0aEFmdGVyID0gJGZyb20uaW5kZXhBZnRlcigtMSkgPCAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50ID8gMVxuICAgICAgICAgICAgICAgICAgICA6ICRmcm9tLmluZGV4QWZ0ZXIoLTIpIDwgJGZyb20ubm9kZSgtMykuY2hpbGRDb3VudCA/IDIgOiAzO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIHNlY29uZCBsaXN0IGl0ZW0gd2l0aCBhbiBlbXB0eSBkZWZhdWx0IHN0YXJ0IG5vZGVcbiAgICAgICAgICAgICAgICB3cmFwID0gd3JhcC5hcHBlbmQoRnJhZ21lbnQuZnJvbShpdGVtVHlwZS5jcmVhdGVBbmRGaWxsKCkpKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSAkZnJvbS5iZWZvcmUoJGZyb20uZGVwdGggLSAoZGVwdGhCZWZvcmUgLSAxKSk7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIucmVwbGFjZShzdGFydCwgJGZyb20uYWZ0ZXIoLWRlcHRoQWZ0ZXIpLCBuZXcgU2xpY2Uod3JhcCwgNCAtIGRlcHRoQmVmb3JlLCAwKSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IC0xO1xuICAgICAgICAgICAgICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oc3RhcnQsIHRyLmRvYy5jb250ZW50LnNpemUsIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pc1RleHRibG9jayAmJiBub2RlLmNvbnRlbnQuc2l6ZSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShzZWwpKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFR5cGUgPSAkdG8ucG9zID09ICRmcm9tLmVuZCgpID8gZ3JhbmRQYXJlbnQuY29udGVudE1hdGNoQXQoMCkuZGVmYXVsdFR5cGUgOiBudWxsO1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5kZWxldGUoJGZyb20ucG9zLCAkdG8ucG9zKTtcbiAgICAgICAgbGV0IHR5cGVzID0gbmV4dFR5cGUgPyBbaXRlbUF0dHJzID8geyB0eXBlOiBpdGVtVHlwZSwgYXR0cnM6IGl0ZW1BdHRycyB9IDogbnVsbCwgeyB0eXBlOiBuZXh0VHlwZSB9XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFjYW5TcGxpdCh0ci5kb2MsICRmcm9tLnBvcywgMiwgdHlwZXMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zcGxpdCgkZnJvbS5wb3MsIDIsIHR5cGVzKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29tbWFuZCB0byBsaWZ0IHRoZSBsaXN0IGl0ZW0gYXJvdW5kIHRoZSBzZWxlY3Rpb24gdXAgaW50b1xuYSB3cmFwcGluZyBsaXN0LlxuKi9cbmZ1bmN0aW9uIGxpZnRMaXN0SXRlbShpdGVtVHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8sIG5vZGUgPT4gbm9kZS5jaGlsZENvdW50ID4gMCAmJiBub2RlLmZpcnN0Q2hpbGQudHlwZSA9PSBpdGVtVHlwZSk7XG4gICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZGlzcGF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCRmcm9tLm5vZGUocmFuZ2UuZGVwdGggLSAxKS50eXBlID09IGl0ZW1UeXBlKSAvLyBJbnNpZGUgYSBwYXJlbnQgbGlzdFxuICAgICAgICAgICAgcmV0dXJuIGxpZnRUb091dGVyTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIGl0ZW1UeXBlLCByYW5nZSk7XG4gICAgICAgIGVsc2UgLy8gT3V0ZXIgbGlzdCBub2RlXG4gICAgICAgICAgICByZXR1cm4gbGlmdE91dE9mTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIHJhbmdlKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbGlmdFRvT3V0ZXJMaXN0KHN0YXRlLCBkaXNwYXRjaCwgaXRlbVR5cGUsIHJhbmdlKSB7XG4gICAgbGV0IHRyID0gc3RhdGUudHIsIGVuZCA9IHJhbmdlLmVuZCwgZW5kT2ZMaXN0ID0gcmFuZ2UuJHRvLmVuZChyYW5nZS5kZXB0aCk7XG4gICAgaWYgKGVuZCA8IGVuZE9mTGlzdCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgc2libGluZ3MgYWZ0ZXIgdGhlIGxpZnRlZCBpdGVtcywgd2hpY2ggbXVzdCBiZWNvbWVcbiAgICAgICAgLy8gY2hpbGRyZW4gb2YgdGhlIGxhc3QgaXRlbVxuICAgICAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChlbmQgLSAxLCBlbmRPZkxpc3QsIGVuZCwgZW5kT2ZMaXN0LCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShpdGVtVHlwZS5jcmVhdGUobnVsbCwgcmFuZ2UucGFyZW50LmNvcHkoKSkpLCAxLCAwKSwgMSwgdHJ1ZSkpO1xuICAgICAgICByYW5nZSA9IG5ldyBOb2RlUmFuZ2UodHIuZG9jLnJlc29sdmUocmFuZ2UuJGZyb20ucG9zKSwgdHIuZG9jLnJlc29sdmUoZW5kT2ZMaXN0KSwgcmFuZ2UuZGVwdGgpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0ci5saWZ0KHJhbmdlLCB0YXJnZXQpO1xuICAgIGxldCBhZnRlciA9IHRyLm1hcHBpbmcubWFwKGVuZCwgLTEpIC0gMTtcbiAgICBpZiAoY2FuSm9pbih0ci5kb2MsIGFmdGVyKSlcbiAgICAgICAgdHIuam9pbihhZnRlcik7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBsaWZ0T3V0T2ZMaXN0KHN0YXRlLCBkaXNwYXRjaCwgcmFuZ2UpIHtcbiAgICBsZXQgdHIgPSBzdGF0ZS50ciwgbGlzdCA9IHJhbmdlLnBhcmVudDtcbiAgICAvLyBNZXJnZSB0aGUgbGlzdCBpdGVtcyBpbnRvIGEgc2luZ2xlIGJpZyBpdGVtXG4gICAgZm9yIChsZXQgcG9zID0gcmFuZ2UuZW5kLCBpID0gcmFuZ2UuZW5kSW5kZXggLSAxLCBlID0gcmFuZ2Uuc3RhcnRJbmRleDsgaSA+IGU7IGktLSkge1xuICAgICAgICBwb3MgLT0gbGlzdC5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgICAgdHIuZGVsZXRlKHBvcyAtIDEsIHBvcyArIDEpO1xuICAgIH1cbiAgICBsZXQgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2Uuc3RhcnQpLCBpdGVtID0gJHN0YXJ0Lm5vZGVBZnRlcjtcbiAgICBpZiAodHIubWFwcGluZy5tYXAocmFuZ2UuZW5kKSAhPSByYW5nZS5zdGFydCArICRzdGFydC5ub2RlQWZ0ZXIubm9kZVNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYXRTdGFydCA9IHJhbmdlLnN0YXJ0SW5kZXggPT0gMCwgYXRFbmQgPSByYW5nZS5lbmRJbmRleCA9PSBsaXN0LmNoaWxkQ291bnQ7XG4gICAgbGV0IHBhcmVudCA9ICRzdGFydC5ub2RlKC0xKSwgaW5kZXhCZWZvcmUgPSAkc3RhcnQuaW5kZXgoLTEpO1xuICAgIGlmICghcGFyZW50LmNhblJlcGxhY2UoaW5kZXhCZWZvcmUgKyAoYXRTdGFydCA/IDAgOiAxKSwgaW5kZXhCZWZvcmUgKyAxLCBpdGVtLmNvbnRlbnQuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QpKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc3RhcnQgPSAkc3RhcnQucG9zLCBlbmQgPSBzdGFydCArIGl0ZW0ubm9kZVNpemU7XG4gICAgLy8gU3RyaXAgb2ZmIHRoZSBzdXJyb3VuZGluZyBsaXN0LiBBdCB0aGUgc2lkZXMgd2hlcmUgd2UncmUgbm90IGF0XG4gICAgLy8gdGhlIGVuZCBvZiB0aGUgbGlzdCwgdGhlIGV4aXN0aW5nIGxpc3QgaXMgY2xvc2VkLiBBdCBzaWRlcyB3aGVyZVxuICAgIC8vIHRoaXMgaXMgdGhlIGVuZCwgaXQgaXMgb3ZlcndyaXR0ZW4gdG8gaXRzIGVuZC5cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCAtIChhdFN0YXJ0ID8gMSA6IDApLCBlbmQgKyAoYXRFbmQgPyAxIDogMCksIHN0YXJ0ICsgMSwgZW5kIC0gMSwgbmV3IFNsaWNlKChhdFN0YXJ0ID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKVxuICAgICAgICAuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKSwgYXRTdGFydCA/IDAgOiAxLCBhdEVuZCA/IDAgOiAxKSwgYXRTdGFydCA/IDAgOiAxKSk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgdG8gc2luayB0aGUgbGlzdCBpdGVtIGFyb3VuZCB0aGUgc2VsZWN0aW9uIGRvd25cbmludG8gYW4gaW5uZXIgbGlzdC5cbiovXG5mdW5jdGlvbiBzaW5rTGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBub2RlID0+IG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGUpO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXg7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBwYXJlbnQgPSByYW5nZS5wYXJlbnQsIG5vZGVCZWZvcmUgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCAtIDEpO1xuICAgICAgICBpZiAobm9kZUJlZm9yZS50eXBlICE9IGl0ZW1UeXBlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBuZXN0ZWRCZWZvcmUgPSBub2RlQmVmb3JlLmxhc3RDaGlsZCAmJiBub2RlQmVmb3JlLmxhc3RDaGlsZC50eXBlID09IHBhcmVudC50eXBlO1xuICAgICAgICAgICAgbGV0IGlubmVyID0gRnJhZ21lbnQuZnJvbShuZXN0ZWRCZWZvcmUgPyBpdGVtVHlwZS5jcmVhdGUoKSA6IG51bGwpO1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlKG51bGwsIEZyYWdtZW50LmZyb20ocGFyZW50LnR5cGUuY3JlYXRlKG51bGwsIGlubmVyKSkpKSwgbmVzdGVkQmVmb3JlID8gMyA6IDEsIDApO1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHJhbmdlLnN0YXJ0LCBhZnRlciA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKGJlZm9yZSAtIChuZXN0ZWRCZWZvcmUgPyAzIDogMSksIGFmdGVyLCBiZWZvcmUsIGFmdGVyLCBzbGljZSwgMSwgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IGFkZExpc3ROb2RlcywgYnVsbGV0TGlzdCwgbGlmdExpc3RJdGVtLCBsaXN0SXRlbSwgb3JkZXJlZExpc3QsIHNpbmtMaXN0SXRlbSwgc3BsaXRMaXN0SXRlbSwgd3JhcEluTGlzdCB9O1xuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVTdGF0ZShjb25maWc6IHtcbiAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZVxufSk6IEVkaXRvclN0YXRlIHtcbiAgY29uc3QgeyBzdGF0ZSwgdHJhbnNhY3Rpb24gfSA9IGNvbmZpZ1xuICBsZXQgeyBzZWxlY3Rpb24gfSA9IHRyYW5zYWN0aW9uXG4gIGxldCB7IGRvYyB9ID0gdHJhbnNhY3Rpb25cbiAgbGV0IHsgc3RvcmVkTWFya3MgfSA9IHRyYW5zYWN0aW9uXG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBhcHBseTogc3RhdGUuYXBwbHkuYmluZChzdGF0ZSksXG4gICAgYXBwbHlUcmFuc2FjdGlvbjogc3RhdGUuYXBwbHlUcmFuc2FjdGlvbi5iaW5kKHN0YXRlKSxcbiAgICBwbHVnaW5zOiBzdGF0ZS5wbHVnaW5zLFxuICAgIHNjaGVtYTogc3RhdGUuc2NoZW1hLFxuICAgIHJlY29uZmlndXJlOiBzdGF0ZS5yZWNvbmZpZ3VyZS5iaW5kKHN0YXRlKSxcbiAgICB0b0pTT046IHN0YXRlLnRvSlNPTi5iaW5kKHN0YXRlKSxcbiAgICBnZXQgc3RvcmVkTWFya3MoKSB7XG4gICAgICByZXR1cm4gc3RvcmVkTWFya3NcbiAgICB9LFxuICAgIGdldCBzZWxlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uXG4gICAgfSxcbiAgICBnZXQgZG9jKCkge1xuICAgICAgcmV0dXJuIGRvY1xuICAgIH0sXG4gICAgZ2V0IHRyKCkge1xuICAgICAgc2VsZWN0aW9uID0gdHJhbnNhY3Rpb24uc2VsZWN0aW9uXG4gICAgICBkb2MgPSB0cmFuc2FjdGlvbi5kb2NcbiAgICAgIHN0b3JlZE1hcmtzID0gdHJhbnNhY3Rpb24uc3RvcmVkTWFya3NcblxuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uXG4gICAgfSxcbiAgfVxufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgY3JlYXRlQ2hhaW5hYmxlU3RhdGUgfSBmcm9tICcuL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUuanMnXG5pbXBvcnQge1xuICBBbnlDb21tYW5kcywgQ2FuQ29tbWFuZHMsIENoYWluZWRDb21tYW5kcywgQ29tbWFuZFByb3BzLCBTaW5nbGVDb21tYW5kcyxcbn0gZnJvbSAnLi90eXBlcy5qcydcblxuZXhwb3J0IGNsYXNzIENvbW1hbmRNYW5hZ2VyIHtcbiAgZWRpdG9yOiBFZGl0b3JcblxuICByYXdDb21tYW5kczogQW55Q29tbWFuZHNcblxuICBjdXN0b21TdGF0ZT86IEVkaXRvclN0YXRlXG5cbiAgY29uc3RydWN0b3IocHJvcHM6IHsgZWRpdG9yOiBFZGl0b3I7IHN0YXRlPzogRWRpdG9yU3RhdGUgfSkge1xuICAgIHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yXG4gICAgdGhpcy5yYXdDb21tYW5kcyA9IHRoaXMuZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuY29tbWFuZHNcbiAgICB0aGlzLmN1c3RvbVN0YXRlID0gcHJvcHMuc3RhdGVcbiAgfVxuXG4gIGdldCBoYXNDdXN0b21TdGF0ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLmN1c3RvbVN0YXRlXG4gIH1cblxuICBnZXQgc3RhdGUoKTogRWRpdG9yU3RhdGUge1xuICAgIHJldHVybiB0aGlzLmN1c3RvbVN0YXRlIHx8IHRoaXMuZWRpdG9yLnN0YXRlXG4gIH1cblxuICBnZXQgY29tbWFuZHMoKTogU2luZ2xlQ29tbWFuZHMge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXNcbiAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvclxuICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlXG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIpXG5cbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmRdKSA9PiB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY29tbWFuZCguLi5hcmdzKShwcm9wcylcblxuICAgICAgICAgIGlmICghdHIuZ2V0TWV0YSgncHJldmVudERpc3BhdGNoJykgJiYgIXRoaXMuaGFzQ3VzdG9tU3RhdGUpIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW25hbWUsIG1ldGhvZF1cbiAgICAgIH0pLFxuICAgICkgYXMgdW5rbm93biBhcyBTaW5nbGVDb21tYW5kc1xuICB9XG5cbiAgZ2V0IGNoYWluKCk6ICgpID0+IENoYWluZWRDb21tYW5kcyB7XG4gICAgcmV0dXJuICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4oKVxuICB9XG5cbiAgZ2V0IGNhbigpOiAoKSA9PiBDYW5Db21tYW5kcyB7XG4gICAgcmV0dXJuICgpID0+IHRoaXMuY3JlYXRlQ2FuKClcbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVDaGFpbihzdGFydFRyPzogVHJhbnNhY3Rpb24sIHNob3VsZERpc3BhdGNoID0gdHJ1ZSk6IENoYWluZWRDb21tYW5kcyB7XG4gICAgY29uc3QgeyByYXdDb21tYW5kcywgZWRpdG9yLCBzdGF0ZSB9ID0gdGhpc1xuICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yXG4gICAgY29uc3QgY2FsbGJhY2tzOiBib29sZWFuW10gPSBbXVxuICAgIGNvbnN0IGhhc1N0YXJ0VHJhbnNhY3Rpb24gPSAhIXN0YXJ0VHJcbiAgICBjb25zdCB0ciA9IHN0YXJ0VHIgfHwgc3RhdGUudHJcblxuICAgIGNvbnN0IHJ1biA9ICgpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgIWhhc1N0YXJ0VHJhbnNhY3Rpb25cbiAgICAgICAgJiYgc2hvdWxkRGlzcGF0Y2hcbiAgICAgICAgJiYgIXRyLmdldE1ldGEoJ3ByZXZlbnREaXNwYXRjaCcpXG4gICAgICAgICYmICF0aGlzLmhhc0N1c3RvbVN0YXRlXG4gICAgICApIHtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cilcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbGxiYWNrcy5ldmVyeShjYWxsYmFjayA9PiBjYWxsYmFjayA9PT0gdHJ1ZSlcbiAgICB9XG5cbiAgICBjb25zdCBjaGFpbiA9IHtcbiAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmRdKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hhaW5lZENvbW1hbmQgPSAoLi4uYXJnczogbmV2ZXJbXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIsIHNob3VsZERpc3BhdGNoKVxuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKVxuXG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjaylcblxuICAgICAgICAgICAgcmV0dXJuIGNoYWluXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFtuYW1lLCBjaGFpbmVkQ29tbWFuZF1cbiAgICAgICAgfSksXG4gICAgICApLFxuICAgICAgcnVuLFxuICAgIH0gYXMgdW5rbm93biBhcyBDaGFpbmVkQ29tbWFuZHNcblxuICAgIHJldHVybiBjaGFpblxuICB9XG5cbiAgcHVibGljIGNyZWF0ZUNhbihzdGFydFRyPzogVHJhbnNhY3Rpb24pOiBDYW5Db21tYW5kcyB7XG4gICAgY29uc3QgeyByYXdDb21tYW5kcywgc3RhdGUgfSA9IHRoaXNcbiAgICBjb25zdCBkaXNwYXRjaCA9IGZhbHNlXG4gICAgY29uc3QgdHIgPSBzdGFydFRyIHx8IHN0YXRlLnRyXG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIsIGRpc3BhdGNoKVxuICAgIGNvbnN0IGZvcm1hdHRlZENvbW1hbmRzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmRdKSA9PiB7XG4gICAgICAgIHJldHVybiBbbmFtZSwgKC4uLmFyZ3M6IG5ldmVyW10pID0+IGNvbW1hbmQoLi4uYXJncykoeyAuLi5wcm9wcywgZGlzcGF0Y2g6IHVuZGVmaW5lZCB9KV1cbiAgICAgIH0pLFxuICAgICkgYXMgdW5rbm93biBhcyBTaW5nbGVDb21tYW5kc1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZvcm1hdHRlZENvbW1hbmRzLFxuICAgICAgY2hhaW46ICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4odHIsIGRpc3BhdGNoKSxcbiAgICB9IGFzIENhbkNvbW1hbmRzXG4gIH1cblxuICBwdWJsaWMgYnVpbGRQcm9wcyh0cjogVHJhbnNhY3Rpb24sIHNob3VsZERpc3BhdGNoID0gdHJ1ZSk6IENvbW1hbmRQcm9wcyB7XG4gICAgY29uc3QgeyByYXdDb21tYW5kcywgZWRpdG9yLCBzdGF0ZSB9ID0gdGhpc1xuICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yXG5cbiAgICBjb25zdCBwcm9wczogQ29tbWFuZFByb3BzID0ge1xuICAgICAgdHIsXG4gICAgICBlZGl0b3IsXG4gICAgICB2aWV3LFxuICAgICAgc3RhdGU6IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHRyYW5zYWN0aW9uOiB0cixcbiAgICAgIH0pLFxuICAgICAgZGlzcGF0Y2g6IHNob3VsZERpc3BhdGNoID8gKCkgPT4gdW5kZWZpbmVkIDogdW5kZWZpbmVkLFxuICAgICAgY2hhaW46ICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4odHIsIHNob3VsZERpc3BhdGNoKSxcbiAgICAgIGNhbjogKCkgPT4gdGhpcy5jcmVhdGVDYW4odHIpLFxuICAgICAgZ2V0IGNvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtuYW1lLCAoLi4uYXJnczogbmV2ZXJbXSkgPT4gY29tbWFuZCguLi5hcmdzKShwcm9wcyldXG4gICAgICAgICAgfSksXG4gICAgICAgICkgYXMgdW5rbm93biBhcyBTaW5nbGVDb21tYW5kc1xuICAgICAgfSxcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHNcbiAgfVxufVxuIiwgInR5cGUgU3RyaW5nS2V5T2Y8VD4gPSBFeHRyYWN0PGtleW9mIFQsIHN0cmluZz5cbnR5cGUgQ2FsbGJhY2tUeXBlPFxuICBUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PixcbiAgRXZlbnROYW1lIGV4dGVuZHMgU3RyaW5nS2V5T2Y8VD4sXG4+ID0gVFtFdmVudE5hbWVdIGV4dGVuZHMgYW55W10gPyBUW0V2ZW50TmFtZV0gOiBbVFtFdmVudE5hbWVdXVxudHlwZSBDYWxsYmFja0Z1bmN0aW9uPFxuICBUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PixcbiAgRXZlbnROYW1lIGV4dGVuZHMgU3RyaW5nS2V5T2Y8VD4sXG4+ID0gKC4uLnByb3BzOiBDYWxsYmFja1R5cGU8VCwgRXZlbnROYW1lPikgPT4gYW55XG5cbmV4cG9ydCBjbGFzcyBFdmVudEVtaXR0ZXI8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4+IHtcblxuICBwcml2YXRlIGNhbGxiYWNrczogeyBba2V5OiBzdHJpbmddOiBGdW5jdGlvbltdIH0gPSB7fVxuXG4gIHB1YmxpYyBvbjxFdmVudE5hbWUgZXh0ZW5kcyBTdHJpbmdLZXlPZjxUPj4oZXZlbnQ6IEV2ZW50TmFtZSwgZm46IENhbGxiYWNrRnVuY3Rpb248VCwgRXZlbnROYW1lPik6IHRoaXMge1xuICAgIGlmICghdGhpcy5jYWxsYmFja3NbZXZlbnRdKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0gPSBbXVxuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XS5wdXNoKGZuKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByb3RlY3RlZCBlbWl0PEV2ZW50TmFtZSBleHRlbmRzIFN0cmluZ0tleU9mPFQ+PihldmVudDogRXZlbnROYW1lLCAuLi5hcmdzOiBDYWxsYmFja1R5cGU8VCwgRXZlbnROYW1lPik6IHRoaXMge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XVxuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncykpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHB1YmxpYyBvZmY8RXZlbnROYW1lIGV4dGVuZHMgU3RyaW5nS2V5T2Y8VD4+KGV2ZW50OiBFdmVudE5hbWUsIGZuPzogQ2FsbGJhY2tGdW5jdGlvbjxULCBFdmVudE5hbWU+KTogdGhpcyB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3NbZXZlbnRdXG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gY2FsbGJhY2tzLmZpbHRlcihjYWxsYmFjayA9PiBjYWxsYmFjayAhPT0gZm4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja3NbZXZlbnRdXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByb3RlY3RlZCByZW1vdmVBbGxMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fVxuICB9XG59XG4iLCAiaW1wb3J0IHsgQW55RXh0ZW5zaW9uLCBNYXliZVRoaXNQYXJhbWV0ZXJUeXBlLCBSZW1vdmVUaGlzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHRlbnNpb25GaWVsZDxUID0gYW55PihcbiAgZXh0ZW5zaW9uOiBBbnlFeHRlbnNpb24sXG4gIGZpZWxkOiBzdHJpbmcsXG4gIGNvbnRleHQ/OiBPbWl0PE1heWJlVGhpc1BhcmFtZXRlclR5cGU8VD4sICdwYXJlbnQnPixcbik6IFJlbW92ZVRoaXM8VD4ge1xuXG4gIGlmIChleHRlbnNpb24uY29uZmlnW2ZpZWxkXSA9PT0gdW5kZWZpbmVkICYmIGV4dGVuc2lvbi5wYXJlbnQpIHtcbiAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLnBhcmVudCwgZmllbGQsIGNvbnRleHQpXG4gIH1cblxuICBpZiAodHlwZW9mIGV4dGVuc2lvbi5jb25maWdbZmllbGRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb24uY29uZmlnW2ZpZWxkXS5iaW5kKHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBwYXJlbnQ6IGV4dGVuc2lvbi5wYXJlbnRcbiAgICAgICAgPyBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24ucGFyZW50LCBmaWVsZCwgY29udGV4dClcbiAgICAgICAgOiBudWxsLFxuICAgIH0pXG5cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJldHVybiBleHRlbnNpb24uY29uZmlnW2ZpZWxkXVxufVxuIiwgImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcbmltcG9ydCB7IE1hcmsgfSBmcm9tICcuLi9NYXJrLmpzJ1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4uL05vZGUuanMnXG5pbXBvcnQgeyBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucykge1xuICBjb25zdCBiYXNlRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMuZmlsdGVyKGV4dGVuc2lvbiA9PiBleHRlbnNpb24udHlwZSA9PT0gJ2V4dGVuc2lvbicpIGFzIEV4dGVuc2lvbltdXG4gIGNvbnN0IG5vZGVFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi50eXBlID09PSAnbm9kZScpIGFzIE5vZGVbXVxuICBjb25zdCBtYXJrRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMuZmlsdGVyKGV4dGVuc2lvbiA9PiBleHRlbnNpb24udHlwZSA9PT0gJ21hcmsnKSBhcyBNYXJrW11cblxuICByZXR1cm4ge1xuICAgIGJhc2VFeHRlbnNpb25zLFxuICAgIG5vZGVFeHRlbnNpb25zLFxuICAgIG1hcmtFeHRlbnNpb25zLFxuICB9XG59XG4iLCAiaW1wb3J0IHsgTWFya0NvbmZpZywgTm9kZUNvbmZpZyB9IGZyb20gJy4uL2luZGV4LmpzJ1xuaW1wb3J0IHtcbiAgQW55Q29uZmlnLFxuICBBdHRyaWJ1dGUsXG4gIEF0dHJpYnV0ZXMsXG4gIEV4dGVuc2lvbkF0dHJpYnV0ZSxcbiAgRXh0ZW5zaW9ucyxcbiAgR2xvYmFsQXR0cmlidXRlcyxcbn0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBzcGxpdEV4dGVuc2lvbnMgfSBmcm9tICcuL3NwbGl0RXh0ZW5zaW9ucy5qcydcblxuLyoqXG4gKiBHZXQgYSBsaXN0IG9mIGFsbCBleHRlbnNpb24gYXR0cmlidXRlcyBkZWZpbmVkIGluIGBhZGRBdHRyaWJ1dGVgIGFuZCBgYWRkR2xvYmFsQXR0cmlidXRlYC5cbiAqIEBwYXJhbSBleHRlbnNpb25zIExpc3Qgb2YgZXh0ZW5zaW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSB7XG4gIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXM6IEV4dGVuc2lvbkF0dHJpYnV0ZVtdID0gW11cbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKVxuICBjb25zdCBub2RlQW5kTWFya0V4dGVuc2lvbnMgPSBbLi4ubm9kZUV4dGVuc2lvbnMsIC4uLm1hcmtFeHRlbnNpb25zXVxuICBjb25zdCBkZWZhdWx0QXR0cmlidXRlOiBSZXF1aXJlZDxBdHRyaWJ1dGU+ID0ge1xuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgcmVuZGVyZWQ6IHRydWUsXG4gICAgcmVuZGVySFRNTDogbnVsbCxcbiAgICBwYXJzZUhUTUw6IG51bGwsXG4gICAga2VlcE9uU3BsaXQ6IHRydWUsXG4gICAgaXNSZXF1aXJlZDogZmFsc2UsXG4gIH1cblxuICBleHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgIH1cblxuICAgIGNvbnN0IGFkZEdsb2JhbEF0dHJpYnV0ZXMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZEdsb2JhbEF0dHJpYnV0ZXMnXT4oXG4gICAgICBleHRlbnNpb24sXG4gICAgICAnYWRkR2xvYmFsQXR0cmlidXRlcycsXG4gICAgICBjb250ZXh0LFxuICAgIClcblxuICAgIGlmICghYWRkR2xvYmFsQXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGBhcyBHbG9iYWxBdHRyaWJ1dGVzYFxuICAgIGNvbnN0IGdsb2JhbEF0dHJpYnV0ZXMgPSBhZGRHbG9iYWxBdHRyaWJ1dGVzKCkgYXMgR2xvYmFsQXR0cmlidXRlc1xuXG4gICAgZ2xvYmFsQXR0cmlidXRlcy5mb3JFYWNoKGdsb2JhbEF0dHJpYnV0ZSA9PiB7XG4gICAgICBnbG9iYWxBdHRyaWJ1dGUudHlwZXMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgT2JqZWN0XG4gICAgICAgICAgLmVudHJpZXMoZ2xvYmFsQXR0cmlidXRlLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgLmZvckVhY2goKFtuYW1lLCBhdHRyaWJ1dGVdKSA9PiB7XG4gICAgICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGU6IHtcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlLFxuICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxuICBub2RlQW5kTWFya0V4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgfVxuXG4gICAgY29uc3QgYWRkQXR0cmlidXRlcyA9IGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2FkZEF0dHJpYnV0ZXMnXSB8IE1hcmtDb25maWdbJ2FkZEF0dHJpYnV0ZXMnXT4oXG4gICAgICBleHRlbnNpb24sXG4gICAgICAnYWRkQXR0cmlidXRlcycsXG4gICAgICBjb250ZXh0LFxuICAgIClcblxuICAgIGlmICghYWRkQXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGBhcyBBdHRyaWJ1dGVzYFxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhZGRBdHRyaWJ1dGVzKCkgYXMgQXR0cmlidXRlc1xuXG4gICAgT2JqZWN0XG4gICAgICAuZW50cmllcyhhdHRyaWJ1dGVzKVxuICAgICAgLmZvckVhY2goKFtuYW1lLCBhdHRyaWJ1dGVdKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lcmdlZEF0dHIgPSB7XG4gICAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZSxcbiAgICAgICAgICAuLi5hdHRyaWJ1dGUsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1lcmdlZEF0dHI/LmRlZmF1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBtZXJnZWRBdHRyLmRlZmF1bHQgPSBtZXJnZWRBdHRyLmRlZmF1bHQoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lcmdlZEF0dHI/LmlzUmVxdWlyZWQgJiYgbWVyZ2VkQXR0cj8uZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVsZXRlIG1lcmdlZEF0dHIuZGVmYXVsdFxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGF0dHJpYnV0ZTogbWVyZ2VkQXR0cixcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZXNcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVUeXBlKG5hbWVPclR5cGU6IHN0cmluZyB8IE5vZGVUeXBlLCBzY2hlbWE6IFNjaGVtYSk6IE5vZGVUeXBlIHtcbiAgaWYgKHR5cGVvZiBuYW1lT3JUeXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmICghc2NoZW1hLm5vZGVzW25hbWVPclR5cGVdKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYFRoZXJlIGlzIG5vIG5vZGUgdHlwZSBuYW1lZCAnJHtuYW1lT3JUeXBlfScuIE1heWJlIHlvdSBmb3Jnb3QgdG8gYWRkIHRoZSBleHRlbnNpb24/YCxcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gc2NoZW1hLm5vZGVzW25hbWVPclR5cGVdXG4gIH1cblxuICByZXR1cm4gbmFtZU9yVHlwZVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBtZXJnZUF0dHJpYnV0ZXMoLi4ub2JqZWN0czogUmVjb3JkPHN0cmluZywgYW55PltdKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIHJldHVybiBvYmplY3RzXG4gICAgLmZpbHRlcihpdGVtID0+ICEhaXRlbSlcbiAgICAucmVkdWNlKChpdGVtcywgaXRlbSkgPT4ge1xuICAgICAgY29uc3QgbWVyZ2VkQXR0cmlidXRlcyA9IHsgLi4uaXRlbXMgfVxuXG4gICAgICBPYmplY3QuZW50cmllcyhpdGVtKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgY29uc3QgZXhpc3RzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldXG5cbiAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZVxuXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWVDbGFzc2VzOiBzdHJpbmdbXSA9IHZhbHVlID8gdmFsdWUuc3BsaXQoJyAnKSA6IFtdXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdDbGFzc2VzOiBzdHJpbmdbXSA9IG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA/IG1lcmdlZEF0dHJpYnV0ZXNba2V5XS5zcGxpdCgnICcpIDogW11cblxuICAgICAgICAgIGNvbnN0IGluc2VydENsYXNzZXMgPSB2YWx1ZUNsYXNzZXMuZmlsdGVyKFxuICAgICAgICAgICAgdmFsdWVDbGFzcyA9PiAhZXhpc3RpbmdDbGFzc2VzLmluY2x1ZGVzKHZhbHVlQ2xhc3MpLFxuICAgICAgICAgIClcblxuICAgICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IFsuLi5leGlzdGluZ0NsYXNzZXMsIC4uLmluc2VydENsYXNzZXNdLmpvaW4oJyAnKVxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IFttZXJnZWRBdHRyaWJ1dGVzW2tleV0sIHZhbHVlXS5qb2luKCc7ICcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIG1lcmdlZEF0dHJpYnV0ZXNcbiAgICB9LCB7fSlcbn1cbiIsICJpbXBvcnQgeyBNYXJrLCBOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRXh0ZW5zaW9uQXR0cmlidXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICcuLi91dGlsaXRpZXMvbWVyZ2VBdHRyaWJ1dGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKFxuICBub2RlT3JNYXJrOiBOb2RlIHwgTWFyayxcbiAgZXh0ZW5zaW9uQXR0cmlidXRlczogRXh0ZW5zaW9uQXR0cmlidXRlW10sXG4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZXNcbiAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS5hdHRyaWJ1dGUucmVuZGVyZWQpXG4gICAgLm1hcChpdGVtID0+IHtcbiAgICAgIGlmICghaXRlbS5hdHRyaWJ1dGUucmVuZGVySFRNTCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFtpdGVtLm5hbWVdOiBub2RlT3JNYXJrLmF0dHJzW2l0ZW0ubmFtZV0sXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW0uYXR0cmlidXRlLnJlbmRlckhUTUwobm9kZU9yTWFyay5hdHRycykgfHwge31cbiAgICB9KVxuICAgIC5yZWR1Y2UoKGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSkgPT4gbWVyZ2VBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSksIHt9KVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBGdW5jdGlvbiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbn1cbiIsICJpbXBvcnQgeyBNYXliZVJldHVyblR5cGUgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL2lzRnVuY3Rpb24uanMnXG5cbi8qKlxuICogT3B0aW9uYWxseSBjYWxscyBgdmFsdWVgIGFzIGEgZnVuY3Rpb24uXG4gKiBPdGhlcndpc2UgaXQgaXMgcmV0dXJuZWQgZGlyZWN0bHkuXG4gKiBAcGFyYW0gdmFsdWUgRnVuY3Rpb24gb3IgYW55IHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQgT3B0aW9uYWwgY29udGV4dCB0byBiaW5kIHRvIGZ1bmN0aW9uLlxuICogQHBhcmFtIHByb3BzIE9wdGlvbmFsIHByb3BzIHRvIHBhc3MgdG8gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxsT3JSZXR1cm48VD4odmFsdWU6IFQsIGNvbnRleHQ6IGFueSA9IHVuZGVmaW5lZCwgLi4ucHJvcHM6IGFueVtdKTogTWF5YmVSZXR1cm5UeXBlPFQ+IHtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5iaW5kKGNvbnRleHQpKC4uLnByb3BzKVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSguLi5wcm9wcylcbiAgfVxuXG4gIHJldHVybiB2YWx1ZSBhcyBNYXliZVJldHVyblR5cGU8VD5cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNFbXB0eU9iamVjdCh2YWx1ZSA9IHt9KTogYm9vbGVhbiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Rcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZTogYW55KTogYW55IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGlmICh2YWx1ZS5tYXRjaCgvXlsrLV0/KD86XFxkKlxcLik/XFxkKyQvKSkge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT09ICd0cnVlJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxufVxuIiwgImltcG9ydCB7IFBhcnNlUnVsZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEV4dGVuc2lvbkF0dHJpYnV0ZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZnJvbVN0cmluZyB9IGZyb20gJy4uL3V0aWxpdGllcy9mcm9tU3RyaW5nLmpzJ1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gbWVyZ2VzIGV4dGVuc2lvbiBhdHRyaWJ1dGVzIGludG8gcGFyc2VydWxlIGF0dHJpYnV0ZXMgKGBhdHRyc2Agb3IgYGdldEF0dHJzYCkuXG4gKiBDYW5jZWxzIHdoZW4gYGdldEF0dHJzYCByZXR1cm5lZCBgZmFsc2VgLlxuICogQHBhcmFtIHBhcnNlUnVsZSBQcm9zZU1pcnJvciBQYXJzZVJ1bGVcbiAqIEBwYXJhbSBleHRlbnNpb25BdHRyaWJ1dGVzIExpc3Qgb2YgYXR0cmlidXRlcyB0byBpbmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZShcbiAgcGFyc2VSdWxlOiBQYXJzZVJ1bGUsXG4gIGV4dGVuc2lvbkF0dHJpYnV0ZXM6IEV4dGVuc2lvbkF0dHJpYnV0ZVtdLFxuKTogUGFyc2VSdWxlIHtcbiAgaWYgKHBhcnNlUnVsZS5zdHlsZSkge1xuICAgIHJldHVybiBwYXJzZVJ1bGVcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ucGFyc2VSdWxlLFxuICAgIGdldEF0dHJzOiBub2RlID0+IHtcbiAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBwYXJzZVJ1bGUuZ2V0QXR0cnMgPyBwYXJzZVJ1bGUuZ2V0QXR0cnMobm9kZSkgOiBwYXJzZVJ1bGUuYXR0cnNcblxuICAgICAgaWYgKG9sZEF0dHJpYnV0ZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gZXh0ZW5zaW9uQXR0cmlidXRlcy5yZWR1Y2UoKGl0ZW1zLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXRlbS5hdHRyaWJ1dGUucGFyc2VIVE1MXG4gICAgICAgICAgPyBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUwobm9kZSBhcyBIVE1MRWxlbWVudClcbiAgICAgICAgICA6IGZyb21TdHJpbmcoKG5vZGUgYXMgSFRNTEVsZW1lbnQpLmdldEF0dHJpYnV0ZShpdGVtLm5hbWUpKVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW1zXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLml0ZW1zLFxuICAgICAgICAgIFtpdGVtLm5hbWVdOiB2YWx1ZSxcbiAgICAgICAgfVxuICAgICAgfSwge30pXG5cbiAgICAgIHJldHVybiB7IC4uLm9sZEF0dHJpYnV0ZXMsIC4uLm5ld0F0dHJpYnV0ZXMgfVxuICAgIH0sXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBNYXJrU3BlYywgTm9kZVNwZWMsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEVkaXRvciwgTWFya0NvbmZpZywgTm9kZUNvbmZpZyB9IGZyb20gJy4uL2luZGV4LmpzJ1xuaW1wb3J0IHsgQW55Q29uZmlnLCBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgaXNFbXB0eU9iamVjdCB9IGZyb20gJy4uL3V0aWxpdGllcy9pc0VtcHR5T2JqZWN0LmpzJ1xuaW1wb3J0IHsgZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zIH0gZnJvbSAnLi9nZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMgfSBmcm9tICcuL2dldFJlbmRlcmVkQXR0cmlidXRlcy5qcydcbmltcG9ydCB7IGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZSB9IGZyb20gJy4vaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlLmpzJ1xuaW1wb3J0IHsgc3BsaXRFeHRlbnNpb25zIH0gZnJvbSAnLi9zcGxpdEV4dGVuc2lvbnMuanMnXG5cbmZ1bmN0aW9uIGNsZWFuVXBTY2hlbWFJdGVtPFQ+KGRhdGE6IFQpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgT2JqZWN0LmVudHJpZXMoZGF0YSkuZmlsdGVyKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdhdHRycycgJiYgaXNFbXB0eU9iamVjdCh2YWx1ZSBhcyB7fSB8IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkXG4gICAgfSksXG4gICkgYXMgVFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucywgZWRpdG9yPzogRWRpdG9yKTogU2NoZW1hIHtcbiAgY29uc3QgYWxsQXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zKVxuICBjb25zdCB7IG5vZGVFeHRlbnNpb25zLCBtYXJrRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpXG4gIGNvbnN0IHRvcE5vZGUgPSBub2RlRXh0ZW5zaW9ucy5maW5kKGV4dGVuc2lvbiA9PiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICd0b3BOb2RlJykpPy5uYW1lXG5cbiAgY29uc3Qgbm9kZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgbm9kZUV4dGVuc2lvbnMubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gYWxsQXR0cmlidXRlcy5maWx0ZXIoXG4gICAgICAgIGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUsXG4gICAgICApXG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICBlZGl0b3IsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dHJhTm9kZUZpZWxkcyA9IGV4dGVuc2lvbnMucmVkdWNlKChmaWVsZHMsIGUpID0+IHtcbiAgICAgICAgY29uc3QgZXh0ZW5kTm9kZVNjaGVtYSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snZXh0ZW5kTm9kZVNjaGVtYSddPihcbiAgICAgICAgICBlLFxuICAgICAgICAgICdleHRlbmROb2RlU2NoZW1hJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgLi4uKGV4dGVuZE5vZGVTY2hlbWEgPyBleHRlbmROb2RlU2NoZW1hKGV4dGVuc2lvbikgOiB7fSksXG4gICAgICAgIH1cbiAgICAgIH0sIHt9KVxuXG4gICAgICBjb25zdCBzY2hlbWE6IE5vZGVTcGVjID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xuICAgICAgICAuLi5leHRyYU5vZGVGaWVsZHMsXG4gICAgICAgIGNvbnRlbnQ6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydjb250ZW50J10+KGV4dGVuc2lvbiwgJ2NvbnRlbnQnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgbWFya3M6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydtYXJrcyddPihleHRlbnNpb24sICdtYXJrcycsIGNvbnRleHQpKSxcbiAgICAgICAgZ3JvdXA6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydncm91cCddPihleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKSxcbiAgICAgICAgaW5saW5lOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snaW5saW5lJ10+KGV4dGVuc2lvbiwgJ2lubGluZScsIGNvbnRleHQpKSxcbiAgICAgICAgYXRvbTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2F0b20nXT4oZXh0ZW5zaW9uLCAnYXRvbScsIGNvbnRleHQpKSxcbiAgICAgICAgc2VsZWN0YWJsZTogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ3NlbGVjdGFibGUnXT4oZXh0ZW5zaW9uLCAnc2VsZWN0YWJsZScsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBkcmFnZ2FibGU6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydkcmFnZ2FibGUnXT4oZXh0ZW5zaW9uLCAnZHJhZ2dhYmxlJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGNvZGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydjb2RlJ10+KGV4dGVuc2lvbiwgJ2NvZGUnLCBjb250ZXh0KSksXG4gICAgICAgIGRlZmluaW5nOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snZGVmaW5pbmcnXT4oZXh0ZW5zaW9uLCAnZGVmaW5pbmcnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgaXNvbGF0aW5nOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snaXNvbGF0aW5nJ10+KGV4dGVuc2lvbiwgJ2lzb2xhdGluZycsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKGV4dGVuc2lvbkF0dHJpYnV0ZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbkF0dHJpYnV0ZS5uYW1lLCB7IGRlZmF1bHQ6IGV4dGVuc2lvbkF0dHJpYnV0ZT8uYXR0cmlidXRlPy5kZWZhdWx0IH1dXG4gICAgICAgICAgfSksXG4gICAgICAgICksXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBwYXJzZUhUTUwgPSBjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ3BhcnNlSFRNTCddPihleHRlbnNpb24sICdwYXJzZUhUTUwnLCBjb250ZXh0KSxcbiAgICAgIClcblxuICAgICAgaWYgKHBhcnNlSFRNTCkge1xuICAgICAgICBzY2hlbWEucGFyc2VET00gPSBwYXJzZUhUTUwubWFwKHBhcnNlUnVsZSA9PiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ3JlbmRlckhUTUwnXT4oXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgJ3JlbmRlckhUTUwnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAocmVuZGVySFRNTCkge1xuICAgICAgICBzY2hlbWEudG9ET00gPSBub2RlID0+IHJlbmRlckhUTUwoe1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVuZGVyVGV4dCA9IGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ3JlbmRlclRleHQnXT4oXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgJ3JlbmRlclRleHQnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAocmVuZGVyVGV4dCkge1xuICAgICAgICBzY2hlbWEudG9UZXh0ID0gcmVuZGVyVGV4dFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBzY2hlbWFdXG4gICAgfSksXG4gIClcblxuICBjb25zdCBtYXJrcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBtYXJrRXh0ZW5zaW9ucy5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLmZpbHRlcihcbiAgICAgICAgYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSxcbiAgICAgIClcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgIGVkaXRvcixcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXh0cmFNYXJrRmllbGRzID0gZXh0ZW5zaW9ucy5yZWR1Y2UoKGZpZWxkcywgZSkgPT4ge1xuICAgICAgICBjb25zdCBleHRlbmRNYXJrU2NoZW1hID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydleHRlbmRNYXJrU2NoZW1hJ10+KFxuICAgICAgICAgIGUsXG4gICAgICAgICAgJ2V4dGVuZE1hcmtTY2hlbWEnLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAuLi4oZXh0ZW5kTWFya1NjaGVtYSA/IGV4dGVuZE1hcmtTY2hlbWEoZXh0ZW5zaW9uKSA6IHt9KSxcbiAgICAgICAgfVxuICAgICAgfSwge30pXG5cbiAgICAgIGNvbnN0IHNjaGVtYTogTWFya1NwZWMgPSBjbGVhblVwU2NoZW1hSXRlbSh7XG4gICAgICAgIC4uLmV4dHJhTWFya0ZpZWxkcyxcbiAgICAgICAgaW5jbHVzaXZlOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1snaW5jbHVzaXZlJ10+KGV4dGVuc2lvbiwgJ2luY2x1c2l2ZScsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBleGNsdWRlczogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ2V4Y2x1ZGVzJ10+KGV4dGVuc2lvbiwgJ2V4Y2x1ZGVzJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGdyb3VwOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1snZ3JvdXAnXT4oZXh0ZW5zaW9uLCAnZ3JvdXAnLCBjb250ZXh0KSksXG4gICAgICAgIHNwYW5uaW5nOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1snc3Bhbm5pbmcnXT4oZXh0ZW5zaW9uLCAnc3Bhbm5pbmcnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgY29kZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ2NvZGUnXT4oZXh0ZW5zaW9uLCAnY29kZScsIGNvbnRleHQpKSxcbiAgICAgICAgYXR0cnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLm1hcChleHRlbnNpb25BdHRyaWJ1dGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25BdHRyaWJ1dGUubmFtZSwgeyBkZWZhdWx0OiBleHRlbnNpb25BdHRyaWJ1dGU/LmF0dHJpYnV0ZT8uZGVmYXVsdCB9XVxuICAgICAgICAgIH0pLFxuICAgICAgICApLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgcGFyc2VIVE1MID0gY2FsbE9yUmV0dXJuKFxuICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydwYXJzZUhUTUwnXT4oZXh0ZW5zaW9uLCAncGFyc2VIVE1MJywgY29udGV4dCksXG4gICAgICApXG5cbiAgICAgIGlmIChwYXJzZUhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChwYXJzZVJ1bGUgPT4gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcykpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlbmRlckhUTUwgPSBnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydyZW5kZXJIVE1MJ10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdyZW5kZXJIVE1MJyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnRvRE9NID0gbWFyayA9PiByZW5kZXJIVE1MKHtcbiAgICAgICAgICBtYXJrLFxuICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobWFyaywgZXh0ZW5zaW9uQXR0cmlidXRlcyksXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV1cbiAgICB9KSxcbiAgKVxuXG4gIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICB0b3BOb2RlLFxuICAgIG5vZGVzLFxuICAgIG1hcmtzLFxuICB9KVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlLCBOb2RlVHlwZSwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYVR5cGVCeU5hbWUobmFtZTogc3RyaW5nLCBzY2hlbWE6IFNjaGVtYSk6IE5vZGVUeXBlIHwgTWFya1R5cGUgfCBudWxsIHtcbiAgcmV0dXJuIHNjaGVtYS5ub2Rlc1tuYW1lXSB8fCBzY2hlbWEubWFya3NbbmFtZV0gfHwgbnVsbFxufVxuIiwgImltcG9ydCB7IEFueUV4dGVuc2lvbiwgRW5hYmxlUnVsZXMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbjogQW55RXh0ZW5zaW9uLCBlbmFibGVkOiBFbmFibGVSdWxlcyk6IGJvb2xlYW4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShlbmFibGVkKSkge1xuICAgIHJldHVybiBlbmFibGVkLnNvbWUoZW5hYmxlZEV4dGVuc2lvbiA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gdHlwZW9mIGVuYWJsZWRFeHRlbnNpb24gPT09ICdzdHJpbmcnXG4gICAgICAgID8gZW5hYmxlZEV4dGVuc2lvblxuICAgICAgICA6IGVuYWJsZWRFeHRlbnNpb24ubmFtZVxuXG4gICAgICByZXR1cm4gbmFtZSA9PT0gZXh0ZW5zaW9uLm5hbWVcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGVuYWJsZWRcbn1cbiIsICJpbXBvcnQgeyBSZXNvbHZlZFBvcyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBjb25zdCBnZXRUZXh0Q29udGVudEZyb21Ob2RlcyA9ICgkZnJvbTogUmVzb2x2ZWRQb3MsIG1heE1hdGNoID0gNTAwKSA9PiB7XG4gIGxldCB0ZXh0QmVmb3JlID0gJydcblxuICBjb25zdCBzbGljZUVuZFBvcyA9ICRmcm9tLnBhcmVudE9mZnNldFxuXG4gICRmcm9tLnBhcmVudC5ub2Rlc0JldHdlZW4oXG4gICAgTWF0aC5tYXgoMCwgc2xpY2VFbmRQb3MgLSBtYXhNYXRjaCksXG4gICAgc2xpY2VFbmRQb3MsXG4gICAgKG5vZGUsIHBvcywgcGFyZW50LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY2h1bmsgPSBub2RlLnR5cGUuc3BlYy50b1RleHQ/Lih7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIHBvcyxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBpbmRleCxcbiAgICAgIH0pXG4gICAgICAgIHx8IG5vZGUudGV4dENvbnRlbnRcbiAgICAgICAgfHwgJyVsZWFmJSdcblxuICAgICAgdGV4dEJlZm9yZSArPSBjaHVuay5zbGljZSgwLCBNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIHBvcykpXG4gICAgfSxcbiAgKVxuXG4gIHJldHVybiB0ZXh0QmVmb3JlXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBSZWdFeHAge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSwgUGx1Z2luLCBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgQ29tbWFuZE1hbmFnZXIgfSBmcm9tICcuL0NvbW1hbmRNYW5hZ2VyLmpzJ1xuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBjcmVhdGVDaGFpbmFibGVTdGF0ZSB9IGZyb20gJy4vaGVscGVycy9jcmVhdGVDaGFpbmFibGVTdGF0ZS5qcydcbmltcG9ydCB7IGdldFRleHRDb250ZW50RnJvbU5vZGVzIH0gZnJvbSAnLi9oZWxwZXJzL2dldFRleHRDb250ZW50RnJvbU5vZGVzLmpzJ1xuaW1wb3J0IHtcbiAgQ2FuQ29tbWFuZHMsXG4gIENoYWluZWRDb21tYW5kcyxcbiAgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5LFxuICBSYW5nZSxcbiAgU2luZ2xlQ29tbWFuZHMsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc1JlZ0V4cCB9IGZyb20gJy4vdXRpbGl0aWVzL2lzUmVnRXhwLmpzJ1xuXG5leHBvcnQgdHlwZSBJbnB1dFJ1bGVNYXRjaCA9IHtcbiAgaW5kZXg6IG51bWJlclxuICB0ZXh0OiBzdHJpbmdcbiAgcmVwbGFjZVdpdGg/OiBzdHJpbmdcbiAgbWF0Y2g/OiBSZWdFeHBNYXRjaEFycmF5XG4gIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG59XG5cbmV4cG9ydCB0eXBlIElucHV0UnVsZUZpbmRlciA9IFJlZ0V4cCB8ICgodGV4dDogc3RyaW5nKSA9PiBJbnB1dFJ1bGVNYXRjaCB8IG51bGwpXG5cbmV4cG9ydCBjbGFzcyBJbnB1dFJ1bGUge1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXJcblxuICBoYW5kbGVyOiAocHJvcHM6IHtcbiAgICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgICByYW5nZTogUmFuZ2VcbiAgICBtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5XG4gICAgY29tbWFuZHM6IFNpbmdsZUNvbW1hbmRzXG4gICAgY2hhaW46ICgpID0+IENoYWluZWRDb21tYW5kc1xuICAgIGNhbjogKCkgPT4gQ2FuQ29tbWFuZHNcbiAgfSkgPT4gdm9pZCB8IG51bGxcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IHtcbiAgICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXJcbiAgICBoYW5kbGVyOiAocHJvcHM6IHtcbiAgICAgIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICAgICAgcmFuZ2U6IFJhbmdlXG4gICAgICBtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5XG4gICAgICBjb21tYW5kczogU2luZ2xlQ29tbWFuZHNcbiAgICAgIGNoYWluOiAoKSA9PiBDaGFpbmVkQ29tbWFuZHNcbiAgICAgIGNhbjogKCkgPT4gQ2FuQ29tbWFuZHNcbiAgICB9KSA9PiB2b2lkIHwgbnVsbFxuICB9KSB7XG4gICAgdGhpcy5maW5kID0gY29uZmlnLmZpbmRcbiAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlclxuICB9XG59XG5cbmNvbnN0IGlucHV0UnVsZU1hdGNoZXJIYW5kbGVyID0gKFxuICB0ZXh0OiBzdHJpbmcsXG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlcixcbik6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB8IG51bGwgPT4ge1xuICBpZiAoaXNSZWdFeHAoZmluZCkpIHtcbiAgICByZXR1cm4gZmluZC5leGVjKHRleHQpXG4gIH1cblxuICBjb25zdCBpbnB1dFJ1bGVNYXRjaCA9IGZpbmQodGV4dClcblxuICBpZiAoIWlucHV0UnVsZU1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5ID0gW2lucHV0UnVsZU1hdGNoLnRleHRdXG5cbiAgcmVzdWx0LmluZGV4ID0gaW5wdXRSdWxlTWF0Y2guaW5kZXhcbiAgcmVzdWx0LmlucHV0ID0gdGV4dFxuICByZXN1bHQuZGF0YSA9IGlucHV0UnVsZU1hdGNoLmRhdGFcblxuICBpZiAoaW5wdXRSdWxlTWF0Y2gucmVwbGFjZVdpdGgpIHtcbiAgICBpZiAoIWlucHV0UnVsZU1hdGNoLnRleHQuaW5jbHVkZXMoaW5wdXRSdWxlTWF0Y2gucmVwbGFjZVdpdGgpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdbdGlwdGFwIHdhcm5dOiBcImlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoXCIgbXVzdCBiZSBwYXJ0IG9mIFwiaW5wdXRSdWxlTWF0Y2gudGV4dFwiLicsXG4gICAgICApXG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2goaW5wdXRSdWxlTWF0Y2gucmVwbGFjZVdpdGgpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHJ1bihjb25maWc6IHtcbiAgZWRpdG9yOiBFZGl0b3JcbiAgZnJvbTogbnVtYmVyXG4gIHRvOiBudW1iZXJcbiAgdGV4dDogc3RyaW5nXG4gIHJ1bGVzOiBJbnB1dFJ1bGVbXVxuICBwbHVnaW46IFBsdWdpblxufSk6IGJvb2xlYW4ge1xuICBjb25zdCB7XG4gICAgZWRpdG9yLCBmcm9tLCB0bywgdGV4dCwgcnVsZXMsIHBsdWdpbixcbiAgfSA9IGNvbmZpZ1xuICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvclxuXG4gIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgJGZyb20gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGZyb20pXG5cbiAgaWYgKFxuICAgIC8vIGNoZWNrIGZvciBjb2RlIG5vZGVcbiAgICAkZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGVcbiAgICAvLyBjaGVjayBmb3IgY29kZSBtYXJrXG4gICAgfHwgISEoJGZyb20ubm9kZUJlZm9yZSB8fCAkZnJvbS5ub2RlQWZ0ZXIpPy5tYXJrcy5maW5kKG1hcmsgPT4gbWFyay50eXBlLnNwZWMuY29kZSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBsZXQgbWF0Y2hlZCA9IGZhbHNlXG5cbiAgY29uc3QgdGV4dEJlZm9yZSA9IGdldFRleHRDb250ZW50RnJvbU5vZGVzKCRmcm9tKSArIHRleHRcblxuICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaCA9IGlucHV0UnVsZU1hdGNoZXJIYW5kbGVyKHRleHRCZWZvcmUsIHJ1bGUuZmluZClcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRyID0gdmlldy5zdGF0ZS50clxuICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgc3RhdGU6IHZpZXcuc3RhdGUsXG4gICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgfSlcbiAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgIGZyb206IGZyb20gLSAobWF0Y2hbMF0ubGVuZ3RoIC0gdGV4dC5sZW5ndGgpLFxuICAgICAgdG8sXG4gICAgfVxuXG4gICAgY29uc3QgeyBjb21tYW5kcywgY2hhaW4sIGNhbiB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgIGVkaXRvcixcbiAgICAgIHN0YXRlLFxuICAgIH0pXG5cbiAgICBjb25zdCBoYW5kbGVyID0gcnVsZS5oYW5kbGVyKHtcbiAgICAgIHN0YXRlLFxuICAgICAgcmFuZ2UsXG4gICAgICBtYXRjaCxcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgY2hhaW4sXG4gICAgICBjYW4sXG4gICAgfSlcblxuICAgIC8vIHN0b3AgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXNcbiAgICBpZiAoaGFuZGxlciA9PT0gbnVsbCB8fCAhdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBzdG9yZSB0cmFuc2Zvcm0gYXMgbWV0YSBkYXRhXG4gICAgLy8gc28gd2UgY2FuIHVuZG8gaW5wdXQgcnVsZXMgd2l0aGluIHRoZSBgdW5kb0lucHV0UnVsZXNgIGNvbW1hbmRcbiAgICB0ci5zZXRNZXRhKHBsdWdpbiwge1xuICAgICAgdHJhbnNmb3JtOiB0cixcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICAgIHRleHQsXG4gICAgfSlcblxuICAgIHZpZXcuZGlzcGF0Y2godHIpXG4gICAgbWF0Y2hlZCA9IHRydWVcbiAgfSlcblxuICByZXR1cm4gbWF0Y2hlZFxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnB1dCBydWxlcyBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgaXQgd2lsbCBjYXVzZSB0ZXh0XG4gKiBpbnB1dCB0aGF0IG1hdGNoZXMgYW55IG9mIHRoZSBnaXZlbiBydWxlcyB0byB0cmlnZ2VyIHRoZSBydWxl4oCZc1xuICogYWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5wdXRSdWxlc1BsdWdpbihwcm9wczogeyBlZGl0b3I6IEVkaXRvcjsgcnVsZXM6IElucHV0UnVsZVtdIH0pOiBQbHVnaW4ge1xuICBjb25zdCB7IGVkaXRvciwgcnVsZXMgfSA9IHByb3BzXG4gIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xuICAgIHN0YXRlOiB7XG4gICAgICBpbml0KCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfSxcbiAgICAgIGFwcGx5KHRyLCBwcmV2KSB7XG4gICAgICAgIGNvbnN0IHN0b3JlZCA9IHRyLmdldE1ldGEocGx1Z2luKVxuXG4gICAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgICByZXR1cm4gc3RvcmVkXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHIuc2VsZWN0aW9uU2V0IHx8IHRyLmRvY0NoYW5nZWQgPyBudWxsIDogcHJldlxuICAgICAgfSxcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcbiAgICAgIGhhbmRsZVRleHRJbnB1dCh2aWV3LCBmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICByZXR1cm4gcnVuKHtcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgICB0byxcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgfSlcbiAgICAgIH0sXG5cbiAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICBjb21wb3NpdGlvbmVuZDogdmlldyA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7ICRjdXJzb3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uIGFzIFRleHRTZWxlY3Rpb25cblxuICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgICAgICAgcnVuKHtcbiAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgZnJvbTogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICAgICAgdG86ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0sXG4gICAgICB9LFxuXG4gICAgICAvLyBhZGQgc3VwcG9ydCBmb3IgaW5wdXQgcnVsZXMgdG8gdHJpZ2dlciBvbiBlbnRlclxuICAgICAgLy8gdGhpcyBpcyB1c2VmdWwgZm9yIGV4YW1wbGUgZm9yIGNvZGUgYmxvY2tzXG4gICAgICBoYW5kbGVLZXlEb3duKHZpZXcsIGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXkgIT09ICdFbnRlcicpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvblxuXG4gICAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgICAgcmV0dXJuIHJ1bih7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBmcm9tOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgIHRvOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgIHRleHQ6ICdcXG4nLFxuICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSxcbiAgICB9LFxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlzSW5wdXRSdWxlczogdHJ1ZSxcbiAgfSkgYXMgUGx1Z2luXG5cbiAgcmV0dXJuIHBsdWdpblxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih2YWx1ZTogYW55KTogdmFsdWUgaXMgbnVtYmVyIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSwgUGx1Z2luIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgQ29tbWFuZE1hbmFnZXIgfSBmcm9tICcuL0NvbW1hbmRNYW5hZ2VyLmpzJ1xuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBjcmVhdGVDaGFpbmFibGVTdGF0ZSB9IGZyb20gJy4vaGVscGVycy9jcmVhdGVDaGFpbmFibGVTdGF0ZS5qcydcbmltcG9ydCB7XG4gIENhbkNvbW1hbmRzLFxuICBDaGFpbmVkQ29tbWFuZHMsXG4gIEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSxcbiAgUmFuZ2UsXG4gIFNpbmdsZUNvbW1hbmRzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICcuL3V0aWxpdGllcy9pc051bWJlci5qcydcbmltcG9ydCB7IGlzUmVnRXhwIH0gZnJvbSAnLi91dGlsaXRpZXMvaXNSZWdFeHAuanMnXG5cbmV4cG9ydCB0eXBlIFBhc3RlUnVsZU1hdGNoID0ge1xuICBpbmRleDogbnVtYmVyXG4gIHRleHQ6IHN0cmluZ1xuICByZXBsYWNlV2l0aD86IHN0cmluZ1xuICBtYXRjaD86IFJlZ0V4cE1hdGNoQXJyYXlcbiAgZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuZXhwb3J0IHR5cGUgUGFzdGVSdWxlRmluZGVyID0gUmVnRXhwIHwgKCh0ZXh0OiBzdHJpbmcsIGV2ZW50PzogQ2xpcGJvYXJkRXZlbnQpID0+IFBhc3RlUnVsZU1hdGNoW10gfCBudWxsIHwgdW5kZWZpbmVkKVxuXG5leHBvcnQgY2xhc3MgUGFzdGVSdWxlIHtcbiAgZmluZDogUGFzdGVSdWxlRmluZGVyXG5cbiAgaGFuZGxlcjogKHByb3BzOiB7XG4gICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgcmFuZ2U6IFJhbmdlXG4gICAgbWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheVxuICAgIGNvbW1hbmRzOiBTaW5nbGVDb21tYW5kc1xuICAgIGNoYWluOiAoKSA9PiBDaGFpbmVkQ29tbWFuZHNcbiAgICBjYW46ICgpID0+IENhbkNvbW1hbmRzXG4gICAgcGFzdGVFdmVudDogQ2xpcGJvYXJkRXZlbnRcbiAgICBkcm9wRXZlbnQ6IERyYWdFdmVudFxuICB9KSA9PiB2b2lkIHwgbnVsbFxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzoge1xuICAgIGZpbmQ6IFBhc3RlUnVsZUZpbmRlclxuICAgIGhhbmRsZXI6IChwcm9wczoge1xuICAgICAgY2FuOiAoKSA9PiBDYW5Db21tYW5kc1xuICAgICAgY2hhaW46ICgpID0+IENoYWluZWRDb21tYW5kc1xuICAgICAgY29tbWFuZHM6IFNpbmdsZUNvbW1hbmRzXG4gICAgICBkcm9wRXZlbnQ6IERyYWdFdmVudFxuICAgICAgbWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheVxuICAgICAgcGFzdGVFdmVudDogQ2xpcGJvYXJkRXZlbnRcbiAgICAgIHJhbmdlOiBSYW5nZVxuICAgICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgfSkgPT4gdm9pZCB8IG51bGxcbiAgfSkge1xuICAgIHRoaXMuZmluZCA9IGNvbmZpZy5maW5kXG4gICAgdGhpcy5oYW5kbGVyID0gY29uZmlnLmhhbmRsZXJcbiAgfVxufVxuXG5jb25zdCBwYXN0ZVJ1bGVNYXRjaGVySGFuZGxlciA9IChcbiAgdGV4dDogc3RyaW5nLFxuICBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXIsXG4gIGV2ZW50PzogQ2xpcGJvYXJkRXZlbnQsXG4pOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXlbXSA9PiB7XG4gIGlmIChpc1JlZ0V4cChmaW5kKSkge1xuICAgIHJldHVybiBbLi4udGV4dC5tYXRjaEFsbChmaW5kKV1cbiAgfVxuXG4gIGNvbnN0IG1hdGNoZXMgPSBmaW5kKHRleHQsIGV2ZW50KVxuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXMubWFwKHBhc3RlUnVsZU1hdGNoID0+IHtcbiAgICBjb25zdCByZXN1bHQ6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSA9IFtwYXN0ZVJ1bGVNYXRjaC50ZXh0XVxuXG4gICAgcmVzdWx0LmluZGV4ID0gcGFzdGVSdWxlTWF0Y2guaW5kZXhcbiAgICByZXN1bHQuaW5wdXQgPSB0ZXh0XG4gICAgcmVzdWx0LmRhdGEgPSBwYXN0ZVJ1bGVNYXRjaC5kYXRhXG5cbiAgICBpZiAocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpIHtcbiAgICAgIGlmICghcGFzdGVSdWxlTWF0Y2gudGV4dC5pbmNsdWRlcyhwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdbdGlwdGFwIHdhcm5dOiBcInBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoXCIgbXVzdCBiZSBwYXJ0IG9mIFwicGFzdGVSdWxlTWF0Y2gudGV4dFwiLicsXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnB1c2gocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KVxufVxuXG5mdW5jdGlvbiBydW4oY29uZmlnOiB7XG4gIGVkaXRvcjogRWRpdG9yXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICBmcm9tOiBudW1iZXJcbiAgdG86IG51bWJlclxuICBydWxlOiBQYXN0ZVJ1bGVcbiAgcGFzdGVFdmVudDogQ2xpcGJvYXJkRXZlbnRcbiAgZHJvcEV2ZW50OiBEcmFnRXZlbnRcbn0pOiBib29sZWFuIHtcbiAgY29uc3Qge1xuICAgIGVkaXRvciwgc3RhdGUsIGZyb20sIHRvLCBydWxlLCBwYXN0ZUV2ZW50LCBkcm9wRXZlbnQsXG4gIH0gPSBjb25maWdcblxuICBjb25zdCB7IGNvbW1hbmRzLCBjaGFpbiwgY2FuIH0gPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgIGVkaXRvcixcbiAgICBzdGF0ZSxcbiAgfSlcblxuICBjb25zdCBoYW5kbGVyczogKHZvaWQgfCBudWxsKVtdID0gW11cblxuICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgaWYgKCFub2RlLmlzVGV4dGJsb2NrIHx8IG5vZGUudHlwZS5zcGVjLmNvZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcylcbiAgICBjb25zdCByZXNvbHZlZFRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUuY29udGVudC5zaXplKVxuICAgIGNvbnN0IHRleHRUb01hdGNoID0gbm9kZS50ZXh0QmV0d2VlbihyZXNvbHZlZEZyb20gLSBwb3MsIHJlc29sdmVkVG8gLSBwb3MsIHVuZGVmaW5lZCwgJ1xcdWZmZmMnKVxuXG4gICAgY29uc3QgbWF0Y2hlcyA9IHBhc3RlUnVsZU1hdGNoZXJIYW5kbGVyKHRleHRUb01hdGNoLCBydWxlLmZpbmQsIHBhc3RlRXZlbnQpXG5cbiAgICBtYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXJ0ID0gcmVzb2x2ZWRGcm9tICsgbWF0Y2guaW5kZXggKyAxXG4gICAgICBjb25zdCBlbmQgPSBzdGFydCArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICAgIGZyb206IHN0YXRlLnRyLm1hcHBpbmcubWFwKHN0YXJ0KSxcbiAgICAgICAgdG86IHN0YXRlLnRyLm1hcHBpbmcubWFwKGVuZCksXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcmFuZ2UsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgY2hhaW4sXG4gICAgICAgIGNhbixcbiAgICAgICAgcGFzdGVFdmVudCxcbiAgICAgICAgZHJvcEV2ZW50LFxuICAgICAgfSlcblxuICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKVxuICAgIH0pXG4gIH0pXG5cbiAgY29uc3Qgc3VjY2VzcyA9IGhhbmRsZXJzLmV2ZXJ5KGhhbmRsZXIgPT4gaGFuZGxlciAhPT0gbnVsbClcblxuICByZXR1cm4gc3VjY2Vzc1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBwYXN0ZSBydWxlcyBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgaXQgd2lsbCBjYXVzZSBwYXN0ZWRcbiAqIHRleHQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZeKAmXNcbiAqIGFjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhc3RlUnVsZXNQbHVnaW4ocHJvcHM6IHsgZWRpdG9yOiBFZGl0b3I7IHJ1bGVzOiBQYXN0ZVJ1bGVbXSB9KTogUGx1Z2luW10ge1xuICBjb25zdCB7IGVkaXRvciwgcnVsZXMgfSA9IHByb3BzXG4gIGxldCBkcmFnU291cmNlRWxlbWVudDogRWxlbWVudCB8IG51bGwgPSBudWxsXG4gIGxldCBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlXG4gIGxldCBpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3IgPSBmYWxzZVxuICBsZXQgcGFzdGVFdmVudCA9IG5ldyBDbGlwYm9hcmRFdmVudCgncGFzdGUnKVxuICBsZXQgZHJvcEV2ZW50ID0gbmV3IERyYWdFdmVudCgnZHJvcCcpXG5cbiAgY29uc3QgcGx1Z2lucyA9IHJ1bGVzLm1hcChydWxlID0+IHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAvLyB3ZSByZWdpc3RlciBhIGdsb2JhbCBkcmFnIGhhbmRsZXIgdG8gdHJhY2sgdGhlIGN1cnJlbnQgZHJhZyBzb3VyY2UgZWxlbWVudFxuICAgICAgdmlldyh2aWV3KSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZURyYWdzdGFydCA9IChldmVudDogRHJhZ0V2ZW50KSA9PiB7XG4gICAgICAgICAgZHJhZ1NvdXJjZUVsZW1lbnQgPSB2aWV3LmRvbS5wYXJlbnRFbGVtZW50Py5jb250YWlucyhldmVudC50YXJnZXQgYXMgRWxlbWVudClcbiAgICAgICAgICAgID8gdmlldy5kb20ucGFyZW50RWxlbWVudFxuICAgICAgICAgICAgOiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ3N0YXJ0KVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnc3RhcnQpXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgZHJvcDogKHZpZXcsIGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yID0gZHJhZ1NvdXJjZUVsZW1lbnQgPT09IHZpZXcuZG9tLnBhcmVudEVsZW1lbnRcbiAgICAgICAgICAgIGRyb3BFdmVudCA9IGV2ZW50IGFzIERyYWdFdmVudFxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcGFzdGU6IChfdmlldywgZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBodG1sID0gKGV2ZW50IGFzIENsaXBib2FyZEV2ZW50KS5jbGlwYm9hcmREYXRhPy5nZXREYXRhKCd0ZXh0L2h0bWwnKVxuXG4gICAgICAgICAgICBwYXN0ZUV2ZW50ID0gZXZlbnQgYXMgQ2xpcGJvYXJkRXZlbnRcblxuICAgICAgICAgICAgaXNQYXN0ZWRGcm9tUHJvc2VNaXJyb3IgPSAhIWh0bWw/LmluY2x1ZGVzKCdkYXRhLXBtLXNsaWNlJylcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG5cbiAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbnNbMF1cbiAgICAgICAgY29uc3QgaXNQYXN0ZSA9IHRyYW5zYWN0aW9uLmdldE1ldGEoJ3VpRXZlbnQnKSA9PT0gJ3Bhc3RlJyAmJiAhaXNQYXN0ZWRGcm9tUHJvc2VNaXJyb3JcbiAgICAgICAgY29uc3QgaXNEcm9wID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgndWlFdmVudCcpID09PSAnZHJvcCcgJiYgIWlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvclxuXG4gICAgICAgIGlmICghaXNQYXN0ZSAmJiAhaXNEcm9wKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9wIGlmIHRoZXJlIGlzIG5vIGNoYW5nZWQgcmFuZ2VcbiAgICAgICAgY29uc3QgZnJvbSA9IG9sZFN0YXRlLmRvYy5jb250ZW50LmZpbmREaWZmU3RhcnQoc3RhdGUuZG9jLmNvbnRlbnQpXG4gICAgICAgIGNvbnN0IHRvID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZFbmQoc3RhdGUuZG9jLmNvbnRlbnQpXG5cbiAgICAgICAgaWYgKCFpc051bWJlcihmcm9tKSB8fCAhdG8gfHwgZnJvbSA9PT0gdG8uYikge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYnVpbGQgYSBjaGFpbmFibGUgc3RhdGVcbiAgICAgICAgLy8gc28gd2UgY2FuIHVzZSBhIHNpbmdsZSB0cmFuc2FjdGlvbiBmb3IgYWxsIHBhc3RlIHJ1bGVzXG4gICAgICAgIGNvbnN0IHRyID0gc3RhdGUudHJcbiAgICAgICAgY29uc3QgY2hhaW5hYmxlU3RhdGUgPSBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBydW4oe1xuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICBzdGF0ZTogY2hhaW5hYmxlU3RhdGUsXG4gICAgICAgICAgZnJvbTogTWF0aC5tYXgoZnJvbSAtIDEsIDApLFxuICAgICAgICAgIHRvOiB0by5iIC0gMSxcbiAgICAgICAgICBydWxlLFxuICAgICAgICAgIHBhc3RlRXZlbnQsXG4gICAgICAgICAgZHJvcEV2ZW50LFxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIHN0b3AgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXNcbiAgICAgICAgaWYgKCFoYW5kbGVyIHx8ICF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGRyb3BFdmVudCA9IG5ldyBEcmFnRXZlbnQoJ2Ryb3AnKVxuICAgICAgICBwYXN0ZUV2ZW50ID0gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScpXG5cbiAgICAgICAgcmV0dXJuIHRyXG4gICAgICB9LFxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHBsdWdpbnNcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZmluZER1cGxpY2F0ZXMoaXRlbXM6IGFueVtdKTogYW55W10ge1xuICBjb25zdCBmaWx0ZXJlZCA9IGl0ZW1zLmZpbHRlcigoZWwsIGluZGV4KSA9PiBpdGVtcy5pbmRleE9mKGVsKSAhPT0gaW5kZXgpXG5cbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGZpbHRlcmVkKV1cbn1cbiIsICJpbXBvcnQgeyBrZXltYXAgfSBmcm9tICdAdGlwdGFwL3BtL2tleW1hcCdcbmltcG9ydCB7IE5vZGUgYXMgUHJvc2VtaXJyb3JOb2RlLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IERlY29yYXRpb24sIEVkaXRvclZpZXcgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5cbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zIH0gZnJvbSAnLi9oZWxwZXJzL2dldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucy5qcydcbmltcG9ydCB7IGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnLi9oZWxwZXJzL2dldEV4dGVuc2lvbkZpZWxkLmpzJ1xuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMgfSBmcm9tICcuL2hlbHBlcnMvZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMgfSBmcm9tICcuL2hlbHBlcnMvZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlQnlOYW1lIH0gZnJvbSAnLi9oZWxwZXJzL2dldFNjaGVtYVR5cGVCeU5hbWUuanMnXG5pbXBvcnQgeyBpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZCB9IGZyb20gJy4vaGVscGVycy9pc0V4dGVuc2lvblJ1bGVzRW5hYmxlZC5qcydcbmltcG9ydCB7IHNwbGl0RXh0ZW5zaW9ucyB9IGZyb20gJy4vaGVscGVycy9zcGxpdEV4dGVuc2lvbnMuanMnXG5pbXBvcnQgeyBNYXJrLCBOb2RlQ29uZmlnIH0gZnJvbSAnLi9pbmRleC5qcydcbmltcG9ydCB7IGlucHV0UnVsZXNQbHVnaW4gfSBmcm9tICcuL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IHBhc3RlUnVsZXNQbHVnaW4gfSBmcm9tICcuL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7IEFueUNvbmZpZywgRXh0ZW5zaW9ucywgUmF3Q29tbWFuZHMgfSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgZmluZER1cGxpY2F0ZXMgfSBmcm9tICcuL3V0aWxpdGllcy9maW5kRHVwbGljYXRlcy5qcydcblxuZXhwb3J0IGNsYXNzIEV4dGVuc2lvbk1hbmFnZXIge1xuICBlZGl0b3I6IEVkaXRvclxuXG4gIHNjaGVtYTogU2NoZW1hXG5cbiAgZXh0ZW5zaW9uczogRXh0ZW5zaW9uc1xuXG4gIHNwbGl0dGFibGVNYXJrczogc3RyaW5nW10gPSBbXVxuXG4gIGNvbnN0cnVjdG9yKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMsIGVkaXRvcjogRWRpdG9yKSB7XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnJlc29sdmUoZXh0ZW5zaW9ucylcbiAgICB0aGlzLnNjaGVtYSA9IGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucywgZWRpdG9yKVxuXG4gICAgdGhpcy5leHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IHtcbiAgICAgIC8vIHN0b3JlIGV4dGVuc2lvbiBzdG9yYWdlIGluIGVkaXRvclxuICAgICAgdGhpcy5lZGl0b3IuZXh0ZW5zaW9uU3RvcmFnZVtleHRlbnNpb24ubmFtZV0gPSBleHRlbnNpb24uc3RvcmFnZVxuXG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICB9XG5cbiAgICAgIGlmIChleHRlbnNpb24udHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgICAgIGNvbnN0IGtlZXBPblNwbGl0ID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2tlZXBPblNwbGl0JywgY29udGV4dCkpID8/IHRydWVcblxuICAgICAgICBpZiAoa2VlcE9uU3BsaXQpIHtcbiAgICAgICAgICB0aGlzLnNwbGl0dGFibGVNYXJrcy5wdXNoKGV4dGVuc2lvbi5uYW1lKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uQmVmb3JlQ3JlYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkJlZm9yZUNyZWF0ZSddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAnb25CZWZvcmVDcmVhdGUnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAob25CZWZvcmVDcmVhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2JlZm9yZUNyZWF0ZScsIG9uQmVmb3JlQ3JlYXRlKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvbkNyZWF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25DcmVhdGUnXT4oZXh0ZW5zaW9uLCAnb25DcmVhdGUnLCBjb250ZXh0KVxuXG4gICAgICBpZiAob25DcmVhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2NyZWF0ZScsIG9uQ3JlYXRlKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvblVwZGF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25VcGRhdGUnXT4oZXh0ZW5zaW9uLCAnb25VcGRhdGUnLCBjb250ZXh0KVxuXG4gICAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3VwZGF0ZScsIG9uVXBkYXRlKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvblNlbGVjdGlvblVwZGF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25TZWxlY3Rpb25VcGRhdGUnXT4oXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgJ29uU2VsZWN0aW9uVXBkYXRlJyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKG9uU2VsZWN0aW9uVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdzZWxlY3Rpb25VcGRhdGUnLCBvblNlbGVjdGlvblVwZGF0ZSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25UcmFuc2FjdGlvbiA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25UcmFuc2FjdGlvbiddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAnb25UcmFuc2FjdGlvbicsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICAgIGlmIChvblRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCd0cmFuc2FjdGlvbicsIG9uVHJhbnNhY3Rpb24pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uRm9jdXMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uRm9jdXMnXT4oZXh0ZW5zaW9uLCAnb25Gb2N1cycsIGNvbnRleHQpXG5cbiAgICAgIGlmIChvbkZvY3VzKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdmb2N1cycsIG9uRm9jdXMpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uQmx1ciA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25CbHVyJ10+KGV4dGVuc2lvbiwgJ29uQmx1cicsIGNvbnRleHQpXG5cbiAgICAgIGlmIChvbkJsdXIpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2JsdXInLCBvbkJsdXIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uRGVzdHJveSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25EZXN0cm95J10+KGV4dGVuc2lvbiwgJ29uRGVzdHJveScsIGNvbnRleHQpXG5cbiAgICAgIGlmIChvbkRlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2Rlc3Ryb3knLCBvbkRlc3Ryb3kpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHN0YXRpYyByZXNvbHZlKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBFeHRlbnNpb25zIHtcbiAgICBjb25zdCByZXNvbHZlZEV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnNvcnQoRXh0ZW5zaW9uTWFuYWdlci5mbGF0dGVuKGV4dGVuc2lvbnMpKVxuICAgIGNvbnN0IGR1cGxpY2F0ZWROYW1lcyA9IGZpbmREdXBsaWNhdGVzKHJlc29sdmVkRXh0ZW5zaW9ucy5tYXAoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi5uYW1lKSlcblxuICAgIGlmIChkdXBsaWNhdGVkTmFtZXMubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBEdXBsaWNhdGUgZXh0ZW5zaW9uIG5hbWVzIGZvdW5kOiBbJHtkdXBsaWNhdGVkTmFtZXNcbiAgICAgICAgICAubWFwKGl0ZW0gPT4gYCcke2l0ZW19J2ApXG4gICAgICAgICAgLmpvaW4oJywgJyl9XS4gVGhpcyBjYW4gbGVhZCB0byBpc3N1ZXMuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzb2x2ZWRFeHRlbnNpb25zXG4gIH1cblxuICBzdGF0aWMgZmxhdHRlbihleHRlbnNpb25zOiBFeHRlbnNpb25zKTogRXh0ZW5zaW9ucyB7XG4gICAgcmV0dXJuIChcbiAgICAgIGV4dGVuc2lvbnNcbiAgICAgICAgLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYWRkRXh0ZW5zaW9ucyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkRXh0ZW5zaW9ucyddPihcbiAgICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAgICdhZGRFeHRlbnNpb25zJyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgaWYgKGFkZEV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLCAuLi50aGlzLmZsYXR0ZW4oYWRkRXh0ZW5zaW9ucygpKV1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uXG4gICAgICAgIH0pXG4gICAgICAgIC8vIGBJbmZpbml0eWAgd2lsbCBicmVhayBUeXBlU2NyaXB0IHNvIHdlIHNldCBhIG51bWJlciB0aGF0IGlzIHByb2JhYmx5IGhpZ2ggZW5vdWdoXG4gICAgICAgIC5mbGF0KDEwKVxuICAgIClcbiAgfVxuXG4gIHN0YXRpYyBzb3J0KGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBFeHRlbnNpb25zIHtcbiAgICBjb25zdCBkZWZhdWx0UHJpb3JpdHkgPSAxMDBcblxuICAgIHJldHVybiBleHRlbnNpb25zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IHByaW9yaXR5QSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1sncHJpb3JpdHknXT4oYSwgJ3ByaW9yaXR5JykgfHwgZGVmYXVsdFByaW9yaXR5XG4gICAgICBjb25zdCBwcmlvcml0eUIgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ3ByaW9yaXR5J10+KGIsICdwcmlvcml0eScpIHx8IGRlZmF1bHRQcmlvcml0eVxuXG4gICAgICBpZiAocHJpb3JpdHlBID4gcHJpb3JpdHlCKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuXG4gICAgICBpZiAocHJpb3JpdHlBIDwgcHJpb3JpdHlCKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwXG4gICAgfSlcbiAgfVxuXG4gIGdldCBjb21tYW5kcygpOiBSYXdDb21tYW5kcyB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5yZWR1Y2UoKGNvbW1hbmRzLCBleHRlbnNpb24pID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWRkQ29tbWFuZHMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZENvbW1hbmRzJ10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdhZGRDb21tYW5kcycsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICAgIGlmICghYWRkQ29tbWFuZHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNvbW1hbmRzLFxuICAgICAgICAuLi5hZGRDb21tYW5kcygpLFxuICAgICAgfVxuICAgIH0sIHt9IGFzIFJhd0NvbW1hbmRzKVxuICB9XG5cbiAgZ2V0IHBsdWdpbnMoKTogUGx1Z2luW10ge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzXG5cbiAgICAvLyBXaXRoIFByb3NlTWlycm9yLCBmaXJzdCBwbHVnaW5zIHdpdGhpbiBhbiBhcnJheSBhcmUgZXhlY3V0ZWQgZmlyc3QuXG4gICAgLy8gSW4gVGlwdGFwLCB3ZSBwcm92aWRlIHRoZSBhYmlsaXR5IHRvIG92ZXJyaWRlIHBsdWdpbnMsXG4gICAgLy8gc28gaXQgZmVlbHMgbW9yZSBuYXR1cmFsIHRvIHJ1biBwbHVnaW5zIGF0IHRoZSBlbmQgb2YgYW4gYXJyYXkgZmlyc3QuXG4gICAgLy8gVGhhdOKAmXMgd2h5IHdlIGhhdmUgdG8gcmV2ZXJzZSB0aGUgYGV4dGVuc2lvbnNgIGFycmF5IGFuZCBzb3J0IGFnYWluXG4gICAgLy8gYmFzZWQgb24gdGhlIGBwcmlvcml0eWAgb3B0aW9uLlxuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnNvcnQoWy4uLnRoaXMuZXh0ZW5zaW9uc10ucmV2ZXJzZSgpKVxuXG4gICAgY29uc3QgaW5wdXRSdWxlczogYW55W10gPSBbXVxuICAgIGNvbnN0IHBhc3RlUnVsZXM6IGFueVtdID0gW11cblxuICAgIGNvbnN0IGFsbFBsdWdpbnMgPSBleHRlbnNpb25zXG4gICAgICAubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBsdWdpbnM6IFBsdWdpbltdID0gW11cblxuICAgICAgICBjb25zdCBhZGRLZXlib2FyZFNob3J0Y3V0cyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkS2V5Ym9hcmRTaG9ydGN1dHMnXT4oXG4gICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICdhZGRLZXlib2FyZFNob3J0Y3V0cycsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgKVxuXG4gICAgICAgIGxldCBkZWZhdWx0QmluZGluZ3M6IFJlY29yZDxzdHJpbmcsICgpID0+IGJvb2xlYW4+ID0ge31cblxuICAgICAgICAvLyBiaW5kIGV4aXQgaGFuZGxpbmdcbiAgICAgICAgaWYgKGV4dGVuc2lvbi50eXBlID09PSAnbWFyaycgJiYgZXh0ZW5zaW9uLmNvbmZpZy5leGl0YWJsZSkge1xuICAgICAgICAgIGRlZmF1bHRCaW5kaW5ncy5BcnJvd1JpZ2h0ID0gKCkgPT4gTWFyay5oYW5kbGVFeGl0KHsgZWRpdG9yLCBtYXJrOiBleHRlbnNpb24gYXMgTWFyayB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFkZEtleWJvYXJkU2hvcnRjdXRzKSB7XG4gICAgICAgICAgY29uc3QgYmluZGluZ3MgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhhZGRLZXlib2FyZFNob3J0Y3V0cygpKS5tYXAoKFtzaG9ydGN1dCwgbWV0aG9kXSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gW3Nob3J0Y3V0LCAoKSA9PiBtZXRob2QoeyBlZGl0b3IgfSldXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApXG5cbiAgICAgICAgICBkZWZhdWx0QmluZGluZ3MgPSB7IC4uLmRlZmF1bHRCaW5kaW5ncywgLi4uYmluZGluZ3MgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qga2V5TWFwUGx1Z2luID0ga2V5bWFwKGRlZmF1bHRCaW5kaW5ncylcblxuICAgICAgICBwbHVnaW5zLnB1c2goa2V5TWFwUGx1Z2luKVxuXG4gICAgICAgIGNvbnN0IGFkZElucHV0UnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZElucHV0UnVsZXMnXT4oXG4gICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICdhZGRJbnB1dFJ1bGVzJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbiwgZWRpdG9yLm9wdGlvbnMuZW5hYmxlSW5wdXRSdWxlcykgJiYgYWRkSW5wdXRSdWxlcykge1xuICAgICAgICAgIGlucHV0UnVsZXMucHVzaCguLi5hZGRJbnB1dFJ1bGVzKCkpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhZGRQYXN0ZVJ1bGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRQYXN0ZVJ1bGVzJ10+KFxuICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAnYWRkUGFzdGVSdWxlcycsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb24sIGVkaXRvci5vcHRpb25zLmVuYWJsZVBhc3RlUnVsZXMpICYmIGFkZFBhc3RlUnVsZXMpIHtcbiAgICAgICAgICBwYXN0ZVJ1bGVzLnB1c2goLi4uYWRkUGFzdGVSdWxlcygpKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWRkUHJvc2VNaXJyb3JQbHVnaW5zID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRQcm9zZU1pcnJvclBsdWdpbnMnXT4oXG4gICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICdhZGRQcm9zZU1pcnJvclBsdWdpbnMnLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIClcblxuICAgICAgICBpZiAoYWRkUHJvc2VNaXJyb3JQbHVnaW5zKSB7XG4gICAgICAgICAgY29uc3QgcHJvc2VNaXJyb3JQbHVnaW5zID0gYWRkUHJvc2VNaXJyb3JQbHVnaW5zKClcblxuICAgICAgICAgIHBsdWdpbnMucHVzaCguLi5wcm9zZU1pcnJvclBsdWdpbnMpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGx1Z2luc1xuICAgICAgfSlcbiAgICAgIC5mbGF0KClcblxuICAgIHJldHVybiBbXG4gICAgICBpbnB1dFJ1bGVzUGx1Z2luKHtcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBydWxlczogaW5wdXRSdWxlcyxcbiAgICAgIH0pLFxuICAgICAgLi4ucGFzdGVSdWxlc1BsdWdpbih7XG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgcnVsZXM6IHBhc3RlUnVsZXMsXG4gICAgICB9KSxcbiAgICAgIC4uLmFsbFBsdWdpbnMsXG4gICAgXVxuICB9XG5cbiAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyh0aGlzLmV4dGVuc2lvbnMpXG4gIH1cblxuICBnZXQgbm9kZVZpZXdzKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzXG4gICAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucylcblxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBub2RlRXh0ZW5zaW9uc1xuICAgICAgICAuZmlsdGVyKGV4dGVuc2lvbiA9PiAhIWdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZE5vZGVWaWV3JykpXG4gICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLmZpbHRlcihcbiAgICAgICAgICAgIGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICB0eXBlOiBnZXROb2RlVHlwZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhZGROb2RlVmlldyA9IGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2FkZE5vZGVWaWV3J10+KFxuICAgICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICAgJ2FkZE5vZGVWaWV3JyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgaWYgKCFhZGROb2RlVmlldykge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgbm9kZXZpZXcgPSAoXG4gICAgICAgICAgICBub2RlOiBQcm9zZW1pcnJvck5vZGUsXG4gICAgICAgICAgICB2aWV3OiBFZGl0b3JWaWV3LFxuICAgICAgICAgICAgZ2V0UG9zOiAoKCkgPT4gbnVtYmVyKSB8IGJvb2xlYW4sXG4gICAgICAgICAgICBkZWNvcmF0aW9uczogRGVjb3JhdGlvbltdLFxuICAgICAgICAgICkgPT4ge1xuICAgICAgICAgICAgY29uc3QgSFRNTEF0dHJpYnV0ZXMgPSBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcylcblxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVWaWV3KCkoe1xuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIGdldFBvcyxcbiAgICAgICAgICAgICAgZGVjb3JhdGlvbnMsXG4gICAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIG5vZGV2aWV3XVxuICAgICAgICB9KSxcbiAgICApXG4gIH1cbn1cbiIsICIvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tZXNxdWVlYi9pcy13aGF0L2Jsb2IvODhkNmU0Y2E5MmZiMmJhYWI2MDAzYzU0ZTAyZWVkZjRlNzI5ZTVhYi9zcmMvaW5kZXgudHNcblxuZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgaWYgKGdldFR5cGUodmFsdWUpICE9PSAnT2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gT2JqZWN0LnByb3RvdHlwZVxufVxuIiwgImltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICcuL2lzUGxhaW5PYmplY3QuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZURlZXAodGFyZ2V0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBzb3VyY2U6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3Qgb3V0cHV0ID0geyAuLi50YXJnZXQgfVxuXG4gIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dCwgeyBba2V5XTogc291cmNlW2tleV0gfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXRba2V5XSA9IG1lcmdlRGVlcCh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0LCB7IFtrZXldOiBzb3VyY2Vba2V5XSB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBFeHRlbnNpb25Db25maWcgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHsgSW5wdXRSdWxlIH0gZnJvbSAnLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBNYXJrIH0gZnJvbSAnLi9NYXJrLmpzJ1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vTm9kZS5qcydcbmltcG9ydCB7IFBhc3RlUnVsZSB9IGZyb20gJy4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHtcbiAgQW55Q29uZmlnLFxuICBFeHRlbnNpb25zLFxuICBHbG9iYWxBdHRyaWJ1dGVzLFxuICBLZXlib2FyZFNob3J0Y3V0Q29tbWFuZCxcbiAgUGFyZW50Q29uZmlnLFxuICBSYXdDb21tYW5kcyxcbn0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcbmltcG9ydCB7IG1lcmdlRGVlcCB9IGZyb20gJy4vdXRpbGl0aWVzL21lcmdlRGVlcC5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgRXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMgPSBhbnksIFN0b3JhZ2UgPSBhbnk+IHtcbiAgICBba2V5OiBzdHJpbmddOiBhbnlcblxuICAgIC8qKlxuICAgICAqIE5hbWVcbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmdcblxuICAgIC8qKlxuICAgICAqIFByaW9yaXR5XG4gICAgICovXG4gICAgcHJpb3JpdHk/OiBudW1iZXJcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgb3B0aW9uc1xuICAgICAqL1xuICAgIGRlZmF1bHRPcHRpb25zPzogT3B0aW9uc1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBPcHRpb25zXG4gICAgICovXG4gICAgYWRkT3B0aW9ucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIHBhcmVudDogRXhjbHVkZTxQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkT3B0aW9ucyddLCB1bmRlZmluZWQ+XG4gICAgfSkgPT4gT3B0aW9uc1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBTdG9yYWdlXG4gICAgICovXG4gICAgYWRkU3RvcmFnZT86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHBhcmVudDogRXhjbHVkZTxQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkU3RvcmFnZSddLCB1bmRlZmluZWQ+XG4gICAgfSkgPT4gU3RvcmFnZVxuXG4gICAgLyoqXG4gICAgICogR2xvYmFsIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBhZGRHbG9iYWxBdHRyaWJ1dGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkR2xvYmFsQXR0cmlidXRlcyddXG4gICAgfSkgPT4gR2xvYmFsQXR0cmlidXRlcyB8IHt9XG5cbiAgICAvKipcbiAgICAgKiBSYXdcbiAgICAgKi9cbiAgICBhZGRDb21tYW5kcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRDb21tYW5kcyddXG4gICAgfSkgPT4gUGFydGlhbDxSYXdDb21tYW5kcz5cblxuICAgIC8qKlxuICAgICAqIEtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAqL1xuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEtleWJvYXJkU2hvcnRjdXRzJ11cbiAgICB9KSA9PiB7XG4gICAgICBba2V5OiBzdHJpbmddOiBLZXlib2FyZFNob3J0Y3V0Q29tbWFuZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElucHV0IHJ1bGVzXG4gICAgICovXG4gICAgYWRkSW5wdXRSdWxlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRJbnB1dFJ1bGVzJ11cbiAgICB9KSA9PiBJbnB1dFJ1bGVbXVxuXG4gICAgLyoqXG4gICAgICogUGFzdGUgcnVsZXNcbiAgICAgKi9cbiAgICBhZGRQYXN0ZVJ1bGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFBhc3RlUnVsZXMnXVxuICAgIH0pID0+IFBhc3RlUnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBQcm9zZU1pcnJvciBwbHVnaW5zXG4gICAgICovXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFByb3NlTWlycm9yUGx1Z2lucyddXG4gICAgfSkgPT4gUGx1Z2luW11cblxuICAgIC8qKlxuICAgICAqIEV4dGVuc2lvbnNcbiAgICAgKi9cbiAgICBhZGRFeHRlbnNpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkRXh0ZW5zaW9ucyddXG4gICAgfSkgPT4gRXh0ZW5zaW9uc1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIE5vZGUgU2NoZW1hXG4gICAgICovXG4gICAgZXh0ZW5kTm9kZVNjaGVtYT86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydleHRlbmROb2RlU2NoZW1hJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4dGVuc2lvbjogTm9kZSxcbiAgICAgICAgKSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgTWFyayBTY2hlbWFcbiAgICAgKi9cbiAgICBleHRlbmRNYXJrU2NoZW1hPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE1hcmtTY2hlbWEnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBNYXJrLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgbm90IHJlYWR5IHlldC5cbiAgICAgKi9cbiAgICBvbkJlZm9yZUNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJlZm9yZUNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgcmVhZHkuXG4gICAgICovXG4gICAgb25DcmVhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25DcmVhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGVudCBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3Rpb24gaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25TZWxlY3Rpb25VcGRhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25TZWxlY3Rpb25VcGRhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVHJhbnNhY3Rpb24/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uVHJhbnNhY3Rpb24nXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBmb2N1c2VkLlxuICAgICAqL1xuICAgIG9uRm9jdXM/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uRm9jdXMnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzbuKAmXQgZm9jdXNlZCBhbnltb3JlLlxuICAgICAqL1xuICAgIG9uQmx1cj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25CbHVyJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBldmVudDogRm9jdXNFdmVudFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgb25EZXN0cm95PzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uRGVzdHJveSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRXh0ZW5zaW9uPE9wdGlvbnMgPSBhbnksIFN0b3JhZ2UgPSBhbnk+IHtcbiAgdHlwZSA9ICdleHRlbnNpb24nXG5cbiAgbmFtZSA9ICdleHRlbnNpb24nXG5cbiAgcGFyZW50OiBFeHRlbnNpb24gfCBudWxsID0gbnVsbFxuXG4gIGNoaWxkOiBFeHRlbnNpb24gfCBudWxsID0gbnVsbFxuXG4gIG9wdGlvbnM6IE9wdGlvbnNcblxuICBzdG9yYWdlOiBTdG9yYWdlXG5cbiAgY29uZmlnOiBFeHRlbnNpb25Db25maWcgPSB7XG4gICAgbmFtZTogdGhpcy5uYW1lLFxuICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogUGFydGlhbDxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+ID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgLi4uY29uZmlnLFxuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uZmlnLm5hbWVcblxuICAgIGlmIChjb25maWcuZGVmYXVsdE9wdGlvbnMgJiYgT2JqZWN0LmtleXMoY29uZmlnLmRlZmF1bHRPcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke3RoaXMubmFtZX1cIi5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSBgYWRkT3B0aW9uc2AgZmFsbGJhY2tcbiAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0T3B0aW9uc1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmFkZE9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IGNhbGxPclJldHVybihcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRPcHRpb25zJ10+KHRoaXMsICdhZGRPcHRpb25zJywge1xuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgfSksXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KHRoaXMsICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgICkgfHwge31cbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGU8TyA9IGFueSwgUyA9IGFueT4oY29uZmlnOiBQYXJ0aWFsPEV4dGVuc2lvbkNvbmZpZzxPLCBTPj4gPSB7fSkge1xuICAgIHJldHVybiBuZXcgRXh0ZW5zaW9uPE8sIFM+KGNvbmZpZylcbiAgfVxuXG4gIGNvbmZpZ3VyZShvcHRpb25zOiBQYXJ0aWFsPE9wdGlvbnM+ID0ge30pIHtcbiAgICAvLyByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBleHRlbnNpb25cbiAgICAvLyB3aXRoIGRpZmZlcmVudCBjYWxscyBvZiBgY29uZmlndXJlYFxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5kKClcblxuICAgIGV4dGVuc2lvbi5vcHRpb25zID0gbWVyZ2VEZWVwKHRoaXMub3B0aW9ucyBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBvcHRpb25zKSBhcyBPcHRpb25zXG5cbiAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPihleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uXG4gIH1cblxuICBleHRlbmQ8RXh0ZW5kZWRPcHRpb25zID0gT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlID0gU3RvcmFnZT4oXG4gICAgZXh0ZW5kZWRDb25maWc6IFBhcnRpYWw8RXh0ZW5zaW9uQ29uZmlnPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPj4gPSB7fSxcbiAgKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IEV4dGVuc2lvbjxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4oeyAuLi50aGlzLmNvbmZpZywgLi4uZXh0ZW5kZWRDb25maWcgfSlcblxuICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzXG5cbiAgICB0aGlzLmNoaWxkID0gZXh0ZW5zaW9uXG5cbiAgICBleHRlbnNpb24ubmFtZSA9IGV4dGVuZGVkQ29uZmlnLm5hbWUgPyBleHRlbmRlZENvbmZpZy5uYW1lIDogZXh0ZW5zaW9uLnBhcmVudC5uYW1lXG5cbiAgICBpZiAoZXh0ZW5kZWRDb25maWcuZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7ZXh0ZW5zaW9uLm5hbWV9XCIuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICBleHRlbnNpb24ub3B0aW9ucyA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPihleHRlbnNpb24sICdhZGRPcHRpb25zJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIHJldHVybiBleHRlbnNpb25cbiAgfVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgUmFuZ2UsIFRleHRTZXJpYWxpemVyIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0QmV0d2VlbihcbiAgc3RhcnROb2RlOiBQcm9zZU1pcnJvck5vZGUsXG4gIHJhbmdlOiBSYW5nZSxcbiAgb3B0aW9ucz86IHtcbiAgICBibG9ja1NlcGFyYXRvcj86IHN0cmluZ1xuICAgIHRleHRTZXJpYWxpemVycz86IFJlY29yZDxzdHJpbmcsIFRleHRTZXJpYWxpemVyPlxuICB9LFxuKTogc3RyaW5nIHtcbiAgY29uc3QgeyBmcm9tLCB0byB9ID0gcmFuZ2VcbiAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fVxuICBsZXQgdGV4dCA9ICcnXG4gIGxldCBzZXBhcmF0ZWQgPSB0cnVlXG5cbiAgc3RhcnROb2RlLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcywgcGFyZW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHRleHRTZXJpYWxpemVyID0gdGV4dFNlcmlhbGl6ZXJzPy5bbm9kZS50eXBlLm5hbWVdXG5cbiAgICBpZiAodGV4dFNlcmlhbGl6ZXIpIHtcbiAgICAgIGlmIChub2RlLmlzQmxvY2sgJiYgIXNlcGFyYXRlZCkge1xuICAgICAgICB0ZXh0ICs9IGJsb2NrU2VwYXJhdG9yXG4gICAgICAgIHNlcGFyYXRlZCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICB0ZXh0ICs9IHRleHRTZXJpYWxpemVyKHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIHBvcyxcbiAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcmFuZ2UsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgdGV4dCArPSBub2RlPy50ZXh0Py5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcykgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgc2VwYXJhdGVkID0gZmFsc2VcbiAgICB9IGVsc2UgaWYgKG5vZGUuaXNCbG9jayAmJiAhc2VwYXJhdGVkKSB7XG4gICAgICB0ZXh0ICs9IGJsb2NrU2VwYXJhdG9yXG4gICAgICBzZXBhcmF0ZWQgPSB0cnVlXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB0ZXh0XG59XG4iLCAiaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgVGV4dFNlcmlhbGl6ZXIgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hOiBTY2hlbWEpOiBSZWNvcmQ8c3RyaW5nLCBUZXh0U2VyaWFsaXplcj4ge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5ub2RlcylcbiAgICAgIC5maWx0ZXIoKFssIG5vZGVdKSA9PiBub2RlLnNwZWMudG9UZXh0KVxuICAgICAgLm1hcCgoW25hbWUsIG5vZGVdKSA9PiBbbmFtZSwgbm9kZS5zcGVjLnRvVGV4dF0pLFxuICApXG59XG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5pbXBvcnQgeyBnZXRUZXh0QmV0d2VlbiB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0VGV4dEJldHdlZW4uanMnXG5pbXBvcnQgeyBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hIH0gZnJvbSAnLi4vaGVscGVycy9nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hLmpzJ1xuXG5leHBvcnQgY29uc3QgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogJ2NsaXBib2FyZFRleHRTZXJpYWxpemVyJyxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NsaXBib2FyZFRleHRTZXJpYWxpemVyJyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXI6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzXG4gICAgICAgICAgICBjb25zdCB7IHN0YXRlLCBzY2hlbWEgfSA9IGVkaXRvclxuICAgICAgICAgICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBNYXRoLm1pbiguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiRmcm9tLnBvcykpXG4gICAgICAgICAgICBjb25zdCB0byA9IE1hdGgubWF4KC4uLnJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuJHRvLnBvcykpXG4gICAgICAgICAgICBjb25zdCB0ZXh0U2VyaWFsaXplcnMgPSBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHNjaGVtYSlcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0geyBmcm9tLCB0byB9XG5cbiAgICAgICAgICAgIHJldHVybiBnZXRUZXh0QmV0d2Vlbihkb2MsIHJhbmdlLCB7XG4gICAgICAgICAgICAgIHRleHRTZXJpYWxpemVycyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGJsdXI6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBmb2N1cyBmcm9tIHRoZSBlZGl0b3IuXG4gICAgICAgKi9cbiAgICAgIGJsdXI6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBibHVyOiBSYXdDb21tYW5kc1snYmx1ciddID0gKCkgPT4gKHsgZWRpdG9yLCB2aWV3IH0pID0+IHtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBpZiAoIWVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgKHZpZXcuZG9tIGFzIEhUTUxFbGVtZW50KS5ibHVyKClcblxuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIHJlbW92ZSB0aGUgY2FyZXQgb24gYmx1ciBidXQgc2FmYXJpIGRvZXMgbm90LlxuICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzI0MDVcbiAgICAgIHdpbmRvdz8uZ2V0U2VsZWN0aW9uKCk/LnJlbW92ZUFsbFJhbmdlcygpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNsZWFyQ29udGVudDoge1xuICAgICAgLyoqXG4gICAgICAgKiBDbGVhciB0aGUgd2hvbGUgZG9jdW1lbnQuXG4gICAgICAgKi9cbiAgICAgIGNsZWFyQ29udGVudDogKGVtaXRVcGRhdGU/OiBib29sZWFuKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY2xlYXJDb250ZW50OiBSYXdDb21tYW5kc1snY2xlYXJDb250ZW50J10gPSAoZW1pdFVwZGF0ZSA9IGZhbHNlKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gIHJldHVybiBjb21tYW5kcy5zZXRDb250ZW50KCcnLCBlbWl0VXBkYXRlKVxufVxuIiwgImltcG9ydCB7IGxpZnRUYXJnZXQgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNsZWFyTm9kZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogTm9ybWFsaXplIG5vZGVzIHRvIGEgc2ltcGxlIHBhcmFncmFwaC5cbiAgICAgICAqL1xuICAgICAgY2xlYXJOb2RlczogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFyTm9kZXM6IFJhd0NvbW1hbmRzWydjbGVhck5vZGVzJ10gPSAoKSA9PiAoeyBzdGF0ZSwgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb25cblxuICBpZiAoIWRpc3BhdGNoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJhbmdlcy5mb3JFYWNoKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAobm9kZS50eXBlLmlzVGV4dCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBkb2MsIG1hcHBpbmcgfSA9IHRyXG4gICAgICBjb25zdCAkbWFwcGVkRnJvbSA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHBvcykpXG4gICAgICBjb25zdCAkbWFwcGVkVG8gPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplKSlcbiAgICAgIGNvbnN0IG5vZGVSYW5nZSA9ICRtYXBwZWRGcm9tLmJsb2NrUmFuZ2UoJG1hcHBlZFRvKVxuXG4gICAgICBpZiAoIW5vZGVSYW5nZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0TGlmdERlcHRoID0gbGlmdFRhcmdldChub2RlUmFuZ2UpXG5cbiAgICAgIGlmIChub2RlLnR5cGUuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0VHlwZSB9ID0gJG1hcHBlZEZyb20ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCRtYXBwZWRGcm9tLmluZGV4KCkpXG5cbiAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChub2RlUmFuZ2Uuc3RhcnQsIGRlZmF1bHRUeXBlKVxuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0TGlmdERlcHRoIHx8IHRhcmdldExpZnREZXB0aCA9PT0gMCkge1xuICAgICAgICB0ci5saWZ0KG5vZGVSYW5nZSwgdGFyZ2V0TGlmdERlcHRoKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBDb21tYW5kLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY29tbWFuZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWZpbmUgYSBjb21tYW5kIGlubGluZS5cbiAgICAgICAqL1xuICAgICAgY29tbWFuZDogKGZuOiAocHJvcHM6IFBhcmFtZXRlcnM8Q29tbWFuZD5bMF0pID0+IGJvb2xlYW4pID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjb21tYW5kOiBSYXdDb21tYW5kc1snY29tbWFuZCddID0gZm4gPT4gcHJvcHMgPT4ge1xuICByZXR1cm4gZm4ocHJvcHMpXG59XG4iLCAiaW1wb3J0IHsgY3JlYXRlUGFyYWdyYXBoTmVhciBhcyBvcmlnaW5hbENyZWF0ZVBhcmFncmFwaE5lYXIgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY3JlYXRlUGFyYWdyYXBoTmVhcjoge1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgYSBwYXJhZ3JhcGggbmVhcmJ5LlxuICAgICAgICovXG4gICAgICBjcmVhdGVQYXJhZ3JhcGhOZWFyOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYXJhZ3JhcGhOZWFyOiBSYXdDb21tYW5kc1snY3JlYXRlUGFyYWdyYXBoTmVhciddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsQ3JlYXRlUGFyYWdyYXBoTmVhcihzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBjdXQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogQ3V0cyBjb250ZW50IGZyb20gYSByYW5nZSBhbmQgaW5zZXJ0cyBpdCBhdCBhIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICovXG4gICAgICBjdXQ6ICh7IGZyb20sIHRvIH06IHsgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyIH0sIHRhcmdldFBvczogbnVtYmVyKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3V0OiBSYXdDb21tYW5kc1snY3V0J10gPSAob3JpZ2luUmFuZ2UsIHRhcmdldFBvcykgPT4gKHsgZWRpdG9yLCB0ciB9KSA9PiB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvclxuXG4gIGNvbnN0IGNvbnRlbnRTbGljZSA9IHN0YXRlLmRvYy5zbGljZShvcmlnaW5SYW5nZS5mcm9tLCBvcmlnaW5SYW5nZS50bylcblxuICB0ci5kZWxldGVSYW5nZShvcmlnaW5SYW5nZS5mcm9tLCBvcmlnaW5SYW5nZS50bylcbiAgY29uc3QgbmV3UG9zID0gdHIubWFwcGluZy5tYXAodGFyZ2V0UG9zKVxuXG4gIHRyLmluc2VydChuZXdQb3MsIGNvbnRlbnRTbGljZS5jb250ZW50KVxuXG4gIHRyLnNldFNlbGVjdGlvbihuZXcgVGV4dFNlbGVjdGlvbih0ci5kb2MucmVzb2x2ZShuZXdQb3MgLSAxKSkpXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZGVsZXRlQ3VycmVudE5vZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogRGVsZXRlIHRoZSBub2RlIHRoYXQgY3VycmVudGx5IGhhcyB0aGUgc2VsZWN0aW9uIGFuY2hvci5cbiAgICAgICAqL1xuICAgICAgZGVsZXRlQ3VycmVudE5vZGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWxldGVDdXJyZW50Tm9kZTogUmF3Q29tbWFuZHNbJ2RlbGV0ZUN1cnJlbnROb2RlJ10gPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJcbiAgY29uc3QgY3VycmVudE5vZGUgPSBzZWxlY3Rpb24uJGFuY2hvci5ub2RlKClcblxuICAvLyBpZiB0aGVyZSBpcyBjb250ZW50IGluc2lkZSB0aGUgY3VycmVudCBub2RlLCBicmVhayBvdXQgb2YgdGhpcyBjb21tYW5kXG4gIGlmIChjdXJyZW50Tm9kZS5jb250ZW50LnNpemUgPiAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCAkcG9zID0gdHIuc2VsZWN0aW9uLiRhbmNob3JcblxuICBmb3IgKGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGggLT0gMSkge1xuICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoZGVwdGgpXG5cbiAgICBpZiAobm9kZS50eXBlID09PSBjdXJyZW50Tm9kZS50eXBlKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9ICRwb3MuYmVmb3JlKGRlcHRoKVxuICAgICAgICBjb25zdCB0byA9ICRwb3MuYWZ0ZXIoZGVwdGgpXG5cbiAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKS5zY3JvbGxJbnRvVmlldygpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZGVsZXRlTm9kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgYSBub2RlLlxuICAgICAgICovXG4gICAgICBkZWxldGVOb2RlOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWxldGVOb2RlOiBSYXdDb21tYW5kc1snZGVsZXRlTm9kZSddID0gdHlwZU9yTmFtZSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yXG5cbiAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoIC09IDEpIHtcbiAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGRlcHRoKVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gdHlwZSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSAkcG9zLmJlZm9yZShkZXB0aClcbiAgICAgICAgY29uc3QgdG8gPSAkcG9zLmFmdGVyKGRlcHRoKVxuXG4gICAgICAgIHRyLmRlbGV0ZShmcm9tLCB0bykuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7IFJhbmdlLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZGVsZXRlUmFuZ2U6IHtcbiAgICAgIC8qKlxuICAgICAgICogRGVsZXRlIGEgZ2l2ZW4gcmFuZ2UuXG4gICAgICAgKi9cbiAgICAgIGRlbGV0ZVJhbmdlOiAocmFuZ2U6IFJhbmdlKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGVsZXRlUmFuZ2U6IFJhd0NvbW1hbmRzWydkZWxldGVSYW5nZSddID0gcmFuZ2UgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBmcm9tLCB0byB9ID0gcmFuZ2VcblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5kZWxldGUoZnJvbSwgdG8pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IGRlbGV0ZVNlbGVjdGlvbiBhcyBvcmlnaW5hbERlbGV0ZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBkZWxldGVTZWxlY3Rpb246IHtcbiAgICAgIC8qKlxuICAgICAgICogRGVsZXRlIHRoZSBzZWxlY3Rpb24sIGlmIHRoZXJlIGlzIG9uZS5cbiAgICAgICAqL1xuICAgICAgZGVsZXRlU2VsZWN0aW9uOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWxldGVTZWxlY3Rpb246IFJhd0NvbW1hbmRzWydkZWxldGVTZWxlY3Rpb24nXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbERlbGV0ZVNlbGVjdGlvbihzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGVudGVyOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRyaWdnZXIgZW50ZXIuXG4gICAgICAgKi9cbiAgICAgIGVudGVyOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZW50ZXI6IFJhd0NvbW1hbmRzWydlbnRlciddID0gKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICByZXR1cm4gY29tbWFuZHMua2V5Ym9hcmRTaG9ydGN1dCgnRW50ZXInKVxufVxuIiwgImltcG9ydCB7IGV4aXRDb2RlIGFzIG9yaWdpbmFsRXhpdENvZGUgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZXhpdENvZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogRXhpdCBmcm9tIGEgY29kZSBibG9jay5cbiAgICAgICAqL1xuICAgICAgZXhpdENvZGU6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGV4aXRDb2RlOiBSYXdDb21tYW5kc1snZXhpdENvZGUnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEV4aXRDb2RlKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBpc1JlZ0V4cCB9IGZyb20gJy4vaXNSZWdFeHAuanMnXG5cbi8qKlxuICogQ2hlY2sgaWYgb2JqZWN0MSBpbmNsdWRlcyBvYmplY3QyXG4gKiBAcGFyYW0gb2JqZWN0MSBPYmplY3RcbiAqIEBwYXJhbSBvYmplY3QyIE9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0SW5jbHVkZXMoXG4gIG9iamVjdDE6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIG9iamVjdDI6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIG9wdGlvbnM6IHsgc3RyaWN0OiBib29sZWFuIH0gPSB7IHN0cmljdDogdHJ1ZSB9LFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QyKVxuXG4gIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGtleXMuZXZlcnkoa2V5ID0+IHtcbiAgICBpZiAob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QyW2tleV0gPT09IG9iamVjdDFba2V5XVxuICAgIH1cblxuICAgIGlmIChpc1JlZ0V4cChvYmplY3QyW2tleV0pKSB7XG4gICAgICByZXR1cm4gb2JqZWN0MltrZXldLnRlc3Qob2JqZWN0MVtrZXldKVxuICAgIH1cblxuICAgIHJldHVybiBvYmplY3QyW2tleV0gPT09IG9iamVjdDFba2V5XVxuICB9KVxufVxuIiwgImltcG9ydCB7IE1hcmsgYXMgUHJvc2VNaXJyb3JNYXJrLCBNYXJrVHlwZSwgUmVzb2x2ZWRQb3MgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgb2JqZWN0SW5jbHVkZXMgfSBmcm9tICcuLi91dGlsaXRpZXMvb2JqZWN0SW5jbHVkZXMuanMnXG5cbmZ1bmN0aW9uIGZpbmRNYXJrSW5TZXQoXG4gIG1hcmtzOiBQcm9zZU1pcnJvck1hcmtbXSxcbiAgdHlwZTogTWFya1R5cGUsXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSxcbik6IFByb3NlTWlycm9yTWFyayB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBtYXJrcy5maW5kKGl0ZW0gPT4ge1xuICAgIHJldHVybiBpdGVtLnR5cGUgPT09IHR5cGUgJiYgb2JqZWN0SW5jbHVkZXMoaXRlbS5hdHRycywgYXR0cmlidXRlcylcbiAgfSlcbn1cblxuZnVuY3Rpb24gaXNNYXJrSW5TZXQoXG4gIG1hcmtzOiBQcm9zZU1pcnJvck1hcmtbXSxcbiAgdHlwZTogTWFya1R5cGUsXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSxcbik6IGJvb2xlYW4ge1xuICByZXR1cm4gISFmaW5kTWFya0luU2V0KG1hcmtzLCB0eXBlLCBhdHRyaWJ1dGVzKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFya1JhbmdlKFxuICAkcG9zOiBSZXNvbHZlZFBvcyxcbiAgdHlwZTogTWFya1R5cGUsXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSxcbik6IFJhbmdlIHwgdm9pZCB7XG4gIGlmICghJHBvcyB8fCAhdHlwZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IHN0YXJ0ID0gJHBvcy5wYXJlbnQuY2hpbGRBZnRlcigkcG9zLnBhcmVudE9mZnNldClcblxuICBpZiAoJHBvcy5wYXJlbnRPZmZzZXQgPT09IHN0YXJ0Lm9mZnNldCAmJiBzdGFydC5vZmZzZXQgIT09IDApIHtcbiAgICBzdGFydCA9ICRwb3MucGFyZW50LmNoaWxkQmVmb3JlKCRwb3MucGFyZW50T2Zmc2V0KVxuICB9XG5cbiAgaWYgKCFzdGFydC5ub2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBtYXJrID0gZmluZE1hcmtJblNldChbLi4uc3RhcnQubm9kZS5tYXJrc10sIHR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgaWYgKCFtYXJrKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgc3RhcnRJbmRleCA9IHN0YXJ0LmluZGV4XG4gIGxldCBzdGFydFBvcyA9ICRwb3Muc3RhcnQoKSArIHN0YXJ0Lm9mZnNldFxuICBsZXQgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgMVxuICBsZXQgZW5kUG9zID0gc3RhcnRQb3MgKyBzdGFydC5ub2RlLm5vZGVTaXplXG5cbiAgZmluZE1hcmtJblNldChbLi4uc3RhcnQubm9kZS5tYXJrc10sIHR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgd2hpbGUgKHN0YXJ0SW5kZXggPiAwICYmIG1hcmsuaXNJblNldCgkcG9zLnBhcmVudC5jaGlsZChzdGFydEluZGV4IC0gMSkubWFya3MpKSB7XG4gICAgc3RhcnRJbmRleCAtPSAxXG4gICAgc3RhcnRQb3MgLT0gJHBvcy5wYXJlbnQuY2hpbGQoc3RhcnRJbmRleCkubm9kZVNpemVcbiAgfVxuXG4gIHdoaWxlIChcbiAgICBlbmRJbmRleCA8ICRwb3MucGFyZW50LmNoaWxkQ291bnRcbiAgICAmJiBpc01hcmtJblNldChbLi4uJHBvcy5wYXJlbnQuY2hpbGQoZW5kSW5kZXgpLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcylcbiAgKSB7XG4gICAgZW5kUG9zICs9ICRwb3MucGFyZW50LmNoaWxkKGVuZEluZGV4KS5ub2RlU2l6ZVxuICAgIGVuZEluZGV4ICs9IDFcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZnJvbTogc3RhcnRQb3MsXG4gICAgdG86IGVuZFBvcyxcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFya1R5cGUobmFtZU9yVHlwZTogc3RyaW5nIHwgTWFya1R5cGUsIHNjaGVtYTogU2NoZW1hKTogTWFya1R5cGUge1xuICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFzY2hlbWEubWFya3NbbmFtZU9yVHlwZV0pIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgVGhlcmUgaXMgbm8gbWFyayB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gLFxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWEubWFya3NbbmFtZU9yVHlwZV1cbiAgfVxuXG4gIHJldHVybiBuYW1lT3JUeXBlXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGdldE1hcmtSYW5nZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1JhbmdlLmpzJ1xuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGV4dGVuZE1hcmtSYW5nZToge1xuICAgICAgLyoqXG4gICAgICAgKiBFeHRlbmRzIHRoZSB0ZXh0IHNlbGVjdGlvbiB0byB0aGUgY3VycmVudCBtYXJrLlxuICAgICAgICovXG4gICAgICBleHRlbmRNYXJrUmFuZ2U6IChcbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTWFya1R5cGUsXG4gICAgICAgIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBleHRlbmRNYXJrUmFuZ2U6IFJhd0NvbW1hbmRzWydleHRlbmRNYXJrUmFuZ2UnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSB0clxuICBjb25zdCB7ICRmcm9tLCBmcm9tLCB0byB9ID0gc2VsZWN0aW9uXG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJGZyb20sIHR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgICBpZiAocmFuZ2UgJiYgcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvKSB7XG4gICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHJhbmdlLmZyb20sIHJhbmdlLnRvKVxuXG4gICAgICB0ci5zZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgQ29tbWFuZCwgQ29tbWFuZFByb3BzLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZmlyc3Q6IHtcbiAgICAgIC8qKlxuICAgICAgICogUnVucyBvbmUgY29tbWFuZCBhZnRlciB0aGUgb3RoZXIgYW5kIHN0b3BzIGF0IHRoZSBmaXJzdCB3aGljaCByZXR1cm5zIHRydWUuXG4gICAgICAgKi9cbiAgICAgIGZpcnN0OiAoY29tbWFuZHM6IENvbW1hbmRbXSB8ICgocHJvcHM6IENvbW1hbmRQcm9wcykgPT4gQ29tbWFuZFtdKSkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGZpcnN0OiBSYXdDb21tYW5kc1snZmlyc3QnXSA9IGNvbW1hbmRzID0+IHByb3BzID0+IHtcbiAgY29uc3QgaXRlbXMgPSB0eXBlb2YgY29tbWFuZHMgPT09ICdmdW5jdGlvbidcbiAgICA/IGNvbW1hbmRzKHByb3BzKVxuICAgIDogY29tbWFuZHNcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGl0ZW1zW2ldKHByb3BzKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiIsICJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVGV4dFNlbGVjdGlvbih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFRleHRTZWxlY3Rpb24ge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIG1pbk1heCh2YWx1ZSA9IDAsIG1pbiA9IDAsIG1heCA9IDApOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heClcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBGb2N1c1Bvc2l0aW9uIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBtaW5NYXggfSBmcm9tICcuLi91dGlsaXRpZXMvbWluTWF4LmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUZvY3VzUG9zaXRpb24oXG4gIGRvYzogUHJvc2VNaXJyb3JOb2RlLFxuICBwb3NpdGlvbjogRm9jdXNQb3NpdGlvbiA9IG51bGwsXG4pOiBTZWxlY3Rpb24gfCBudWxsIHtcbiAgaWYgKCFwb3NpdGlvbikge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBzZWxlY3Rpb25BdFN0YXJ0ID0gU2VsZWN0aW9uLmF0U3RhcnQoZG9jKVxuICBjb25zdCBzZWxlY3Rpb25BdEVuZCA9IFNlbGVjdGlvbi5hdEVuZChkb2MpXG5cbiAgaWYgKHBvc2l0aW9uID09PSAnc3RhcnQnIHx8IHBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbkF0U3RhcnRcbiAgfVxuXG4gIGlmIChwb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uQXRFbmRcbiAgfVxuXG4gIGNvbnN0IG1pblBvcyA9IHNlbGVjdGlvbkF0U3RhcnQuZnJvbVxuICBjb25zdCBtYXhQb3MgPSBzZWxlY3Rpb25BdEVuZC50b1xuXG4gIGlmIChwb3NpdGlvbiA9PT0gJ2FsbCcpIHtcbiAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5jcmVhdGUoXG4gICAgICBkb2MsXG4gICAgICBtaW5NYXgoMCwgbWluUG9zLCBtYXhQb3MpLFxuICAgICAgbWluTWF4KGRvYy5jb250ZW50LnNpemUsIG1pblBvcywgbWF4UG9zKSxcbiAgICApXG4gIH1cblxuICByZXR1cm4gVGV4dFNlbGVjdGlvbi5jcmVhdGUoXG4gICAgZG9jLFxuICAgIG1pbk1heChwb3NpdGlvbiwgbWluUG9zLCBtYXhQb3MpLFxuICAgIG1pbk1heChwb3NpdGlvbiwgbWluUG9zLCBtYXhQb3MpLFxuICApXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzaU9TKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gW1xuICAgICdpUGFkIFNpbXVsYXRvcicsXG4gICAgJ2lQaG9uZSBTaW11bGF0b3InLFxuICAgICdpUG9kIFNpbXVsYXRvcicsXG4gICAgJ2lQYWQnLFxuICAgICdpUGhvbmUnLFxuICAgICdpUG9kJyxcbiAgXS5pbmNsdWRlcyhuYXZpZ2F0b3IucGxhdGZvcm0pXG4gIC8vIGlQYWQgb24gaU9TIDEzIGRldGVjdGlvblxuICB8fCAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnTWFjJykgJiYgJ29udG91Y2hlbmQnIGluIGRvY3VtZW50KVxufVxuIiwgImltcG9ydCB7IGlzVGV4dFNlbGVjdGlvbiB9IGZyb20gJy4uL2hlbHBlcnMvaXNUZXh0U2VsZWN0aW9uLmpzJ1xuaW1wb3J0IHsgcmVzb2x2ZUZvY3VzUG9zaXRpb24gfSBmcm9tICcuLi9oZWxwZXJzL3Jlc29sdmVGb2N1c1Bvc2l0aW9uLmpzJ1xuaW1wb3J0IHsgRm9jdXNQb3NpdGlvbiwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGlzaU9TIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2lzaU9TLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZm9jdXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogRm9jdXMgdGhlIGVkaXRvciBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICAgKi9cbiAgICAgIGZvY3VzOiAoXG4gICAgICAgIHBvc2l0aW9uPzogRm9jdXNQb3NpdGlvbixcbiAgICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgICBzY3JvbGxJbnRvVmlldz86IGJvb2xlYW4sXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmb2N1czogUmF3Q29tbWFuZHNbJ2ZvY3VzJ10gPSAocG9zaXRpb24gPSBudWxsLCBvcHRpb25zID0ge30pID0+ICh7XG4gIGVkaXRvcixcbiAgdmlldyxcbiAgdHIsXG4gIGRpc3BhdGNoLFxufSkgPT4ge1xuICBvcHRpb25zID0ge1xuICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cblxuICBjb25zdCBkZWxheWVkRm9jdXMgPSAoKSA9PiB7XG4gICAgLy8gZm9jdXMgd2l0aGluIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGJyZWFrcyBmb2N1cyBvbiBpT1NcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIGNhbGwgdGhpc1xuICAgIGlmIChpc2lPUygpKSB7XG4gICAgICAodmlldy5kb20gYXMgSFRNTEVsZW1lbnQpLmZvY3VzKClcbiAgICB9XG5cbiAgICAvLyBGb3IgUmVhY3Qgd2UgaGF2ZSB0byBmb2N1cyBhc3luY2hyb25vdXNseS4gT3RoZXJ3aXNlIHdpbGQgdGhpbmdzIGhhcHBlbi5cbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMTUyMFxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgICB2aWV3LmZvY3VzKClcblxuICAgICAgICBpZiAob3B0aW9ucz8uc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICBlZGl0b3IuY29tbWFuZHMuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGlmICgodmlldy5oYXNGb2N1cygpICYmIHBvc2l0aW9uID09PSBudWxsKSB8fCBwb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gd2UgZG9u4oCZdCB0cnkgdG8gcmVzb2x2ZSBhIE5vZGVTZWxlY3Rpb24gb3IgQ2VsbFNlbGVjdGlvblxuICBpZiAoZGlzcGF0Y2ggJiYgcG9zaXRpb24gPT09IG51bGwgJiYgIWlzVGV4dFNlbGVjdGlvbihlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgIGRlbGF5ZWRGb2N1cygpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIHBhc3MgdGhyb3VnaCB0ci5kb2MgaW5zdGVhZCBvZiBlZGl0b3Iuc3RhdGUuZG9jXG4gIC8vIHNpbmNlIHRyYW5zYWN0aW9ucyBjb3VsZCBjaGFuZ2UgdGhlIGVkaXRvcnMgc3RhdGUgYmVmb3JlIHRoaXMgY29tbWFuZCBoYXMgYmVlbiBydW5cbiAgY29uc3Qgc2VsZWN0aW9uID0gcmVzb2x2ZUZvY3VzUG9zaXRpb24odHIuZG9jLCBwb3NpdGlvbikgfHwgZWRpdG9yLnN0YXRlLnNlbGVjdGlvblxuICBjb25zdCBpc1NhbWVTZWxlY3Rpb24gPSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmVxKHNlbGVjdGlvbilcblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBpZiAoIWlzU2FtZVNlbGVjdGlvbikge1xuICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbilcbiAgICB9XG5cbiAgICAvLyBgdHIuc2V0U2VsZWN0aW9uYCByZXNldHMgdGhlIHN0b3JlZCBtYXJrc1xuICAgIC8vIHNvIHdl4oCZbGwgcmVzdG9yZSB0aGVtIGlmIHRoZSBzZWxlY3Rpb24gaXMgdGhlIHNhbWUgYXMgYmVmb3JlXG4gICAgaWYgKGlzU2FtZVNlbGVjdGlvbiAmJiB0ci5zdG9yZWRNYXJrcykge1xuICAgICAgdHIuc2V0U3RvcmVkTWFya3ModHIuc3RvcmVkTWFya3MpXG4gICAgfVxuXG4gICAgZGVsYXllZEZvY3VzKClcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgQ29tbWFuZFByb3BzLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZm9yRWFjaDoge1xuICAgICAgLyoqXG4gICAgICAgKiBMb29wIHRocm91Z2ggYW4gYXJyYXkgb2YgaXRlbXMuXG4gICAgICAgKi9cbiAgICAgIGZvckVhY2g6IDxUPihcbiAgICAgICAgaXRlbXM6IFRbXSxcbiAgICAgICAgZm46IChcbiAgICAgICAgICBpdGVtOiBULFxuICAgICAgICAgIHByb3BzOiBDb21tYW5kUHJvcHMgJiB7XG4gICAgICAgICAgICBpbmRleDogbnVtYmVyLFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gYm9vbGVhbixcbiAgICAgICkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGZvckVhY2g6IFJhd0NvbW1hbmRzWydmb3JFYWNoJ10gPSAoaXRlbXMsIGZuKSA9PiBwcm9wcyA9PiB7XG4gIHJldHVybiBpdGVtcy5ldmVyeSgoaXRlbSwgaW5kZXgpID0+IGZuKGl0ZW0sIHsgLi4ucHJvcHMsIGluZGV4IH0pKVxufVxuIiwgImltcG9ydCB7IFBhcnNlT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IENvbnRlbnQsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBpbnNlcnRDb250ZW50OiB7XG4gICAgICAvKipcbiAgICAgICAqIEluc2VydCBhIG5vZGUgb3Igc3RyaW5nIG9mIEhUTUwgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgKi9cbiAgICAgIGluc2VydENvbnRlbnQ6IChcbiAgICAgICAgdmFsdWU6IENvbnRlbnQsXG4gICAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgICAgcGFyc2VPcHRpb25zPzogUGFyc2VPcHRpb25zXG4gICAgICAgICAgdXBkYXRlU2VsZWN0aW9uPzogYm9vbGVhblxuICAgICAgICB9LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbnNlcnRDb250ZW50OiBSYXdDb21tYW5kc1snaW5zZXJ0Q29udGVudCddID0gKHZhbHVlLCBvcHRpb25zKSA9PiAoeyB0ciwgY29tbWFuZHMgfSkgPT4ge1xuICByZXR1cm4gY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KFxuICAgIHsgZnJvbTogdHIuc2VsZWN0aW9uLmZyb20sIHRvOiB0ci5zZWxlY3Rpb24udG8gfSxcbiAgICB2YWx1ZSxcbiAgICBvcHRpb25zLFxuICApXG59XG4iLCAiY29uc3QgcmVtb3ZlV2hpdGVzcGFjZXMgPSAobm9kZTogSFRNTEVsZW1lbnQpID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXNcblxuICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cbiAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDMgJiYgY2hpbGQubm9kZVZhbHVlICYmIC9eKFxcblxcc1xcc3xcXG4pJC8udGVzdChjaGlsZC5ub2RlVmFsdWUpKSB7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKVxuICAgIH0gZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIHJlbW92ZVdoaXRlc3BhY2VzKGNoaWxkIGFzIEhUTUxFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50RnJvbVN0cmluZyh2YWx1ZTogc3RyaW5nKTogSFRNTEVsZW1lbnQge1xuICAvLyBhZGQgYSB3cmFwcGVyIHRvIHByZXNlcnZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgY29uc3Qgd3JhcHBlZFZhbHVlID0gYDxib2R5PiR7dmFsdWV9PC9ib2R5PmBcblxuICBjb25zdCBodG1sID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcod3JhcHBlZFZhbHVlLCAndGV4dC9odG1sJykuYm9keVxuXG4gIHJldHVybiByZW1vdmVXaGl0ZXNwYWNlcyhodG1sKVxufVxuIiwgImltcG9ydCB7XG4gIERPTVBhcnNlcixcbiAgRnJhZ21lbnQsXG4gIE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLFxuICBQYXJzZU9wdGlvbnMsXG4gIFNjaGVtYSxcbn0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgQ29udGVudCB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZWxlbWVudEZyb21TdHJpbmcgfSBmcm9tICcuLi91dGlsaXRpZXMvZWxlbWVudEZyb21TdHJpbmcuanMnXG5cbmV4cG9ydCB0eXBlIENyZWF0ZU5vZGVGcm9tQ29udGVudE9wdGlvbnMgPSB7XG4gIHNsaWNlPzogYm9vbGVhblxuICBwYXJzZU9wdGlvbnM/OiBQYXJzZU9wdGlvbnNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5vZGVGcm9tQ29udGVudChcbiAgY29udGVudDogQ29udGVudCxcbiAgc2NoZW1hOiBTY2hlbWEsXG4gIG9wdGlvbnM/OiBDcmVhdGVOb2RlRnJvbUNvbnRlbnRPcHRpb25zLFxuKTogUHJvc2VNaXJyb3JOb2RlIHwgRnJhZ21lbnQge1xuICBvcHRpb25zID0ge1xuICAgIHNsaWNlOiB0cnVlLFxuICAgIHBhcnNlT3B0aW9uczoge30sXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ29iamVjdCcgJiYgY29udGVudCAhPT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50KSAmJiBjb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb21BcnJheShjb250ZW50Lm1hcChpdGVtID0+IHNjaGVtYS5ub2RlRnJvbUpTT04oaXRlbSkpKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2NoZW1hLm5vZGVGcm9tSlNPTihjb250ZW50KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IEludmFsaWQgY29udGVudC4nLCAnUGFzc2VkIHZhbHVlOicsIGNvbnRlbnQsICdFcnJvcjonLCBlcnJvcilcblxuICAgICAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudCgnJywgc2NoZW1hLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBET01QYXJzZXIuZnJvbVNjaGVtYShzY2hlbWEpXG5cbiAgICByZXR1cm4gb3B0aW9ucy5zbGljZVxuICAgICAgPyBwYXJzZXIucGFyc2VTbGljZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpLmNvbnRlbnRcbiAgICAgIDogcGFyc2VyLnBhcnNlKGVsZW1lbnRGcm9tU3RyaW5nKGNvbnRlbnQpLCBvcHRpb25zLnBhcnNlT3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoJycsIHNjaGVtYSwgb3B0aW9ucylcbn1cbiIsICJpbXBvcnQgeyBTZWxlY3Rpb24sIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IFJlcGxhY2VBcm91bmRTdGVwLCBSZXBsYWNlU3RlcCB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci1zdGF0ZS9ibG9iL21hc3Rlci9zcmMvc2VsZWN0aW9uLmpzI0w0NjZcbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0cjogVHJhbnNhY3Rpb24sIHN0YXJ0TGVuOiBudW1iZXIsIGJpYXM6IG51bWJlcikge1xuICBjb25zdCBsYXN0ID0gdHIuc3RlcHMubGVuZ3RoIC0gMVxuXG4gIGlmIChsYXN0IDwgc3RhcnRMZW4pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHN0ZXAgPSB0ci5zdGVwc1tsYXN0XVxuXG4gIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCB8fCBzdGVwIGluc3RhbmNlb2YgUmVwbGFjZUFyb3VuZFN0ZXApKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbbGFzdF1cbiAgbGV0IGVuZCA9IDBcblxuICBtYXAuZm9yRWFjaCgoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSA9PiB7XG4gICAgaWYgKGVuZCA9PT0gMCkge1xuICAgICAgZW5kID0gbmV3VG9cbiAgICB9XG4gIH0pXG5cbiAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKGVuZCksIGJpYXMpKVxufVxuIiwgImltcG9ydCB7IEZyYWdtZW50LCBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgUGFyc2VPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgY3JlYXRlTm9kZUZyb21Db250ZW50IH0gZnJvbSAnLi4vaGVscGVycy9jcmVhdGVOb2RlRnJvbUNvbnRlbnQuanMnXG5pbXBvcnQgeyBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCB9IGZyb20gJy4uL2hlbHBlcnMvc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQuanMnXG5pbXBvcnQgeyBDb250ZW50LCBSYW5nZSwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGluc2VydENvbnRlbnRBdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBJbnNlcnQgYSBub2RlIG9yIHN0cmluZyBvZiBIVE1MIGF0IGEgc3BlY2lmaWMgcG9zaXRpb24uXG4gICAgICAgKi9cbiAgICAgIGluc2VydENvbnRlbnRBdDogKFxuICAgICAgICBwb3NpdGlvbjogbnVtYmVyIHwgUmFuZ2UsXG4gICAgICAgIHZhbHVlOiBDb250ZW50LFxuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIHBhcnNlT3B0aW9ucz86IFBhcnNlT3B0aW9uc1xuICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbj86IGJvb2xlYW5cbiAgICAgICAgfSxcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBpc0ZyYWdtZW50ID0gKG5vZGVPckZyYWdtZW50OiBQcm9zZU1pcnJvck5vZGUgfCBGcmFnbWVudCk6IG5vZGVPckZyYWdtZW50IGlzIEZyYWdtZW50ID0+IHtcbiAgcmV0dXJuIG5vZGVPckZyYWdtZW50LnRvU3RyaW5nKCkuc3RhcnRzV2l0aCgnPCcpXG59XG5cbmV4cG9ydCBjb25zdCBpbnNlcnRDb250ZW50QXQ6IFJhd0NvbW1hbmRzWydpbnNlcnRDb250ZW50QXQnXSA9IChwb3NpdGlvbiwgdmFsdWUsIG9wdGlvbnMpID0+ICh7IHRyLCBkaXNwYXRjaCwgZWRpdG9yIH0pID0+IHtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHBhcnNlT3B0aW9uczoge30sXG4gICAgICB1cGRhdGVTZWxlY3Rpb246IHRydWUsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH1cblxuICAgIGNvbnN0IGNvbnRlbnQgPSBjcmVhdGVOb2RlRnJvbUNvbnRlbnQodmFsdWUsIGVkaXRvci5zY2hlbWEsIHtcbiAgICAgIHBhcnNlT3B0aW9uczoge1xuICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICdmdWxsJyxcbiAgICAgICAgLi4ub3B0aW9ucy5wYXJzZU9wdGlvbnMsXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICAvLyBkb27igJl0IGRpc3BhdGNoIGFuIGVtcHR5IGZyYWdtZW50IGJlY2F1c2UgdGhpcyBjYW4gbGVhZCB0byBzdHJhbmdlIGVycm9yc1xuICAgIGlmIChjb250ZW50LnRvU3RyaW5nKCkgPT09ICc8PicpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgbGV0IHsgZnJvbSwgdG8gfSA9IHR5cGVvZiBwb3NpdGlvbiA9PT0gJ251bWJlcicgPyB7IGZyb206IHBvc2l0aW9uLCB0bzogcG9zaXRpb24gfSA6IHsgZnJvbTogcG9zaXRpb24uZnJvbSwgdG86IHBvc2l0aW9uLnRvIH1cblxuICAgIGxldCBpc09ubHlUZXh0Q29udGVudCA9IHRydWVcbiAgICBsZXQgaXNPbmx5QmxvY2tDb250ZW50ID0gdHJ1ZVxuICAgIGNvbnN0IG5vZGVzID0gaXNGcmFnbWVudChjb250ZW50KSA/IGNvbnRlbnQgOiBbY29udGVudF1cblxuICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAvLyBjaGVjayBpZiBhZGRlZCBub2RlIGlzIHZhbGlkXG4gICAgICBub2RlLmNoZWNrKClcblxuICAgICAgaXNPbmx5VGV4dENvbnRlbnQgPSBpc09ubHlUZXh0Q29udGVudCA/IG5vZGUuaXNUZXh0ICYmIG5vZGUubWFya3MubGVuZ3RoID09PSAwIDogZmFsc2VcblxuICAgICAgaXNPbmx5QmxvY2tDb250ZW50ID0gaXNPbmx5QmxvY2tDb250ZW50ID8gbm9kZS5pc0Jsb2NrIDogZmFsc2VcbiAgICB9KVxuXG4gICAgLy8gY2hlY2sgaWYgd2UgY2FuIHJlcGxhY2UgdGhlIHdyYXBwaW5nIG5vZGUgYnlcbiAgICAvLyB0aGUgbmV3bHkgaW5zZXJ0ZWQgY29udGVudFxuICAgIC8vIGV4YW1wbGU6XG4gICAgLy8gcmVwbGFjZSBhbiBlbXB0eSBwYXJhZ3JhcGggYnkgYW4gaW5zZXJ0ZWQgaW1hZ2VcbiAgICAvLyBpbnN0ZWFkIG9mIGluc2VydGluZyB0aGUgaW1hZ2UgYmVsb3cgdGhlIHBhcmFncmFwaFxuICAgIGlmIChmcm9tID09PSB0byAmJiBpc09ubHlCbG9ja0NvbnRlbnQpIHtcbiAgICAgIGNvbnN0IHsgcGFyZW50IH0gPSB0ci5kb2MucmVzb2x2ZShmcm9tKVxuICAgICAgY29uc3QgaXNFbXB0eVRleHRCbG9jayA9IHBhcmVudC5pc1RleHRibG9jayAmJiAhcGFyZW50LnR5cGUuc3BlYy5jb2RlICYmICFwYXJlbnQuY2hpbGRDb3VudFxuXG4gICAgICBpZiAoaXNFbXB0eVRleHRCbG9jaykge1xuICAgICAgICBmcm9tIC09IDFcbiAgICAgICAgdG8gKz0gMVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgcGxhaW4gdGV4dCB3ZSBoYXZlIHRvIHVzZSBgaW5zZXJ0VGV4dGBcbiAgICAvLyBiZWNhdXNlIHRoaXMgd2lsbCBrZWVwIHRoZSBjdXJyZW50IG1hcmtzXG4gICAgaWYgKGlzT25seVRleHRDb250ZW50KSB7XG4gICAgICAvLyBpZiB2YWx1ZSBpcyBzdHJpbmcsIHdlIGNhbiB1c2UgaXQgZGlyZWN0bHlcbiAgICAgIC8vIG90aGVyd2lzZSBpZiBpdCBpcyBhbiBhcnJheSwgd2UgaGF2ZSB0byBqb2luIGl0XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdHIuaW5zZXJ0VGV4dCh2YWx1ZS5tYXAodiA9PiB2LnRleHQgfHwgJycpLmpvaW4oJycpLCBmcm9tLCB0bylcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhIXZhbHVlICYmICEhdmFsdWUudGV4dCkge1xuICAgICAgICB0ci5pbnNlcnRUZXh0KHZhbHVlLnRleHQsIGZyb20sIHRvKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHIuaW5zZXJ0VGV4dCh2YWx1ZSBhcyBzdHJpbmcsIGZyb20sIHRvKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ci5yZXBsYWNlV2l0aChmcm9tLCB0bywgY29udGVudClcbiAgICB9XG5cbiAgICAvLyBzZXQgY3Vyc29yIGF0IGVuZCBvZiBpbnNlcnRlZCBjb250ZW50XG4gICAgaWYgKG9wdGlvbnMudXBkYXRlU2VsZWN0aW9uKSB7XG4gICAgICBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgdHIuc3RlcHMubGVuZ3RoIC0gMSwgLTEpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQge1xuICBqb2luQmFja3dhcmQgYXMgb3JpZ2luYWxKb2luQmFja3dhcmQsXG4gIGpvaW5Eb3duIGFzIG9yaWdpbmFsSm9pbkRvd24sXG4gIGpvaW5Gb3J3YXJkIGFzIG9yaWdpbmFsSm9pbkZvcndhcmQsXG4gIGpvaW5VcCBhcyBvcmlnaW5hbEpvaW5VcCxcbn0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGpvaW5VcDoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHR3byBub2RlcyBVcC5cbiAgICAgICAqL1xuICAgICAgam9pblVwOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICAgIGpvaW5Eb3duOiB7XG4gICAgICAvKipcbiAgICAgICAqIEpvaW4gdHdvIG5vZGVzIERvd24uXG4gICAgICAgKi9cbiAgICAgIGpvaW5Eb3duOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICAgIGpvaW5CYWNrd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHR3byBub2RlcyBCYWNrd2FyZHMuXG4gICAgICAgKi9cbiAgICAgIGpvaW5CYWNrd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgICBqb2luRm9yd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHR3byBub2RlcyBGb3J3YXJkcy5cbiAgICAgICAqL1xuICAgICAgam9pbkZvcndhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5VcDogUmF3Q29tbWFuZHNbJ2pvaW5VcCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pblVwKHN0YXRlLCBkaXNwYXRjaClcbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5Eb3duOiBSYXdDb21tYW5kc1snam9pbkRvd24nXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5Eb3duKHN0YXRlLCBkaXNwYXRjaClcbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5CYWNrd2FyZDogUmF3Q29tbWFuZHNbJ2pvaW5CYWNrd2FyZCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pbkJhY2t3YXJkKHN0YXRlLCBkaXNwYXRjaClcbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5Gb3J3YXJkOiBSYXdDb21tYW5kc1snam9pbkZvcndhcmQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5Gb3J3YXJkKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBqb2luUG9pbnQgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGpvaW5JdGVtQmFja3dhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gbm9kZXMgRm9yd2FyZHMuXG4gICAgICAgKi9cbiAgICAgIGpvaW5JdGVtQmFja3dhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5JdGVtQmFja3dhcmQ6IFJhd0NvbW1hbmRzWydqb2luSXRlbUJhY2t3YXJkJ10gPSAoKSA9PiAoe1xuICB0ciwgc3RhdGUsIGRpc3BhdGNoLFxufSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgLTEpXG5cbiAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdHIuam9pbihwb2ludCwgMilcblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgZGlzcGF0Y2godHIpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBqb2luUG9pbnQgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGpvaW5JdGVtRm9yd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHR3byBub2RlcyBGb3J3YXJkcy5cbiAgICAgICAqL1xuICAgICAgam9pbkl0ZW1Gb3J3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBqb2luSXRlbUZvcndhcmQ6IFJhd0NvbW1hbmRzWydqb2luSXRlbUZvcndhcmQnXSA9ICgpID0+ICh7XG4gIHN0YXRlLFxuICBkaXNwYXRjaCxcbiAgdHIsXG59KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ucG9zLCArMSlcblxuICAgIGlmIChwb2ludCA9PT0gbnVsbCB8fCBwb2ludCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0ci5qb2luKHBvaW50LCAyKVxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBkaXNwYXRjaCh0cilcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBqb2luVGV4dGJsb2NrQmFja3dhcmQgYXMgb3JpZ2luYWxDb21tYW5kIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGpvaW5UZXh0YmxvY2tCYWNrd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBBIG1vcmUgbGltaXRlZCBmb3JtIG9mIGpvaW5CYWNrd2FyZCB0aGF0IG9ubHkgdHJpZXMgdG8gam9pbiB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gdGhlIG9uZSBiZWZvcmUgaXQsIGlmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuICAgICAgICovXG4gICAgICBqb2luVGV4dGJsb2NrQmFja3dhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5UZXh0YmxvY2tCYWNrd2FyZDogUmF3Q29tbWFuZHNbJ2pvaW5UZXh0YmxvY2tCYWNrd2FyZCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsQ29tbWFuZChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgam9pblRleHRibG9ja0ZvcndhcmQgYXMgb3JpZ2luYWxDb21tYW5kIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGpvaW5UZXh0YmxvY2tGb3J3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbW9yZSBsaW1pdGVkIGZvcm0gb2Ygam9pbkZvcndhcmQgdGhhdCBvbmx5IHRyaWVzIHRvIGpvaW4gdGhlIGN1cnJlbnQgdGV4dGJsb2NrIHRvIHRoZSBvbmUgYWZ0ZXIgaXQsIGlmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jay5cbiAgICAgICAqL1xuICAgICAgam9pblRleHRibG9ja0ZvcndhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5UZXh0YmxvY2tGb3J3YXJkOiBSYXdDb21tYW5kc1snam9pblRleHRibG9ja0ZvcndhcmQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbENvbW1hbmQoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc01hY09TKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxuICAgIDogZmFsc2Vcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNpT1MgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNpT1MuanMnXG5pbXBvcnQgeyBpc01hY09TIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2lzTWFjT1MuanMnXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZTogc3RyaW5nKSB7XG4gIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLylcbiAgbGV0IHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdXG5cbiAgaWYgKHJlc3VsdCA9PT0gJ1NwYWNlJykge1xuICAgIHJlc3VsdCA9ICcgJ1xuICB9XG5cbiAgbGV0IGFsdFxuICBsZXQgY3RybFxuICBsZXQgc2hpZnRcbiAgbGV0IG1ldGFcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgIGNvbnN0IG1vZCA9IHBhcnRzW2ldXG5cbiAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKSB7XG4gICAgICBtZXRhID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKSB7XG4gICAgICBhbHQgPSB0cnVlXG4gICAgfSBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKSB7XG4gICAgICBjdHJsID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpIHtcbiAgICAgIHNoaWZ0ID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoL15tb2QkL2kudGVzdChtb2QpKSB7XG4gICAgICBpZiAoaXNpT1MoKSB8fCBpc01hY09TKCkpIHtcbiAgICAgICAgbWV0YSA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0cmwgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6ICR7bW9kfWApXG4gICAgfVxuICB9XG5cbiAgaWYgKGFsdCkge1xuICAgIHJlc3VsdCA9IGBBbHQtJHtyZXN1bHR9YFxuICB9XG5cbiAgaWYgKGN0cmwpIHtcbiAgICByZXN1bHQgPSBgQ3RybC0ke3Jlc3VsdH1gXG4gIH1cblxuICBpZiAobWV0YSkge1xuICAgIHJlc3VsdCA9IGBNZXRhLSR7cmVzdWx0fWBcbiAgfVxuXG4gIGlmIChzaGlmdCkge1xuICAgIHJlc3VsdCA9IGBTaGlmdC0ke3Jlc3VsdH1gXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBrZXlib2FyZFNob3J0Y3V0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFRyaWdnZXIgYSBrZXlib2FyZCBzaG9ydGN1dC5cbiAgICAgICAqL1xuICAgICAga2V5Ym9hcmRTaG9ydGN1dDogKG5hbWU6IHN0cmluZykgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGtleWJvYXJkU2hvcnRjdXQ6IFJhd0NvbW1hbmRzWydrZXlib2FyZFNob3J0Y3V0J10gPSBuYW1lID0+ICh7XG4gIGVkaXRvcixcbiAgdmlldyxcbiAgdHIsXG4gIGRpc3BhdGNoLFxufSkgPT4ge1xuICBjb25zdCBrZXlzID0gbm9ybWFsaXplS2V5TmFtZShuYW1lKS5zcGxpdCgvLSg/ISQpLylcbiAgY29uc3Qga2V5ID0ga2V5cy5maW5kKGl0ZW0gPT4gIVsnQWx0JywgJ0N0cmwnLCAnTWV0YScsICdTaGlmdCddLmluY2x1ZGVzKGl0ZW0pKVxuICBjb25zdCBldmVudCA9IG5ldyBLZXlib2FyZEV2ZW50KCdrZXlkb3duJywge1xuICAgIGtleToga2V5ID09PSAnU3BhY2UnXG4gICAgICA/ICcgJ1xuICAgICAgOiBrZXksXG4gICAgYWx0S2V5OiBrZXlzLmluY2x1ZGVzKCdBbHQnKSxcbiAgICBjdHJsS2V5OiBrZXlzLmluY2x1ZGVzKCdDdHJsJyksXG4gICAgbWV0YUtleToga2V5cy5pbmNsdWRlcygnTWV0YScpLFxuICAgIHNoaWZ0S2V5OiBrZXlzLmluY2x1ZGVzKCdTaGlmdCcpLFxuICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgfSlcblxuICBjb25zdCBjYXB0dXJlZFRyYW5zYWN0aW9uID0gZWRpdG9yLmNhcHR1cmVUcmFuc2FjdGlvbigoKSA9PiB7XG4gICAgdmlldy5zb21lUHJvcCgnaGFuZGxlS2V5RG93bicsIGYgPT4gZih2aWV3LCBldmVudCkpXG4gIH0pXG5cbiAgY2FwdHVyZWRUcmFuc2FjdGlvbj8uc3RlcHMuZm9yRWFjaChzdGVwID0+IHtcbiAgICBjb25zdCBuZXdTdGVwID0gc3RlcC5tYXAodHIubWFwcGluZylcblxuICAgIGlmIChuZXdTdGVwICYmIGRpc3BhdGNoKSB7XG4gICAgICB0ci5tYXliZVN0ZXAobmV3U3RlcClcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IE5vZGVSYW5nZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgb2JqZWN0SW5jbHVkZXMgfSBmcm9tICcuLi91dGlsaXRpZXMvb2JqZWN0SW5jbHVkZXMuanMnXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4vZ2V0Tm9kZVR5cGUuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVBY3RpdmUoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgdHlwZU9yTmFtZTogTm9kZVR5cGUgfCBzdHJpbmcgfCBudWxsLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30sXG4pOiBib29sZWFuIHtcbiAgY29uc3QgeyBmcm9tLCB0bywgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvblxuICBjb25zdCB0eXBlID0gdHlwZU9yTmFtZSA/IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSkgOiBudWxsXG5cbiAgY29uc3Qgbm9kZVJhbmdlczogTm9kZVJhbmdlW10gPSBbXVxuXG4gIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlbGF0aXZlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcylcbiAgICBjb25zdCByZWxhdGl2ZVRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUubm9kZVNpemUpXG5cbiAgICBub2RlUmFuZ2VzLnB1c2goe1xuICAgICAgbm9kZSxcbiAgICAgIGZyb206IHJlbGF0aXZlRnJvbSxcbiAgICAgIHRvOiByZWxhdGl2ZVRvLFxuICAgIH0pXG4gIH0pXG5cbiAgY29uc3Qgc2VsZWN0aW9uUmFuZ2UgPSB0byAtIGZyb21cbiAgY29uc3QgbWF0Y2hlZE5vZGVSYW5nZXMgPSBub2RlUmFuZ2VzXG4gICAgLmZpbHRlcihub2RlUmFuZ2UgPT4ge1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG5vZGVSYW5nZS5ub2RlLnR5cGUubmFtZVxuICAgIH0pXG4gICAgLmZpbHRlcihub2RlUmFuZ2UgPT4gb2JqZWN0SW5jbHVkZXMobm9kZVJhbmdlLm5vZGUuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSlcblxuICBpZiAoZW1wdHkpIHtcbiAgICByZXR1cm4gISFtYXRjaGVkTm9kZVJhbmdlcy5sZW5ndGhcbiAgfVxuXG4gIGNvbnN0IHJhbmdlID0gbWF0Y2hlZE5vZGVSYW5nZXMucmVkdWNlKChzdW0sIG5vZGVSYW5nZSkgPT4gc3VtICsgbm9kZVJhbmdlLnRvIC0gbm9kZVJhbmdlLmZyb20sIDApXG5cbiAgcmV0dXJuIHJhbmdlID49IHNlbGVjdGlvblJhbmdlXG59XG4iLCAiaW1wb3J0IHsgbGlmdCBhcyBvcmlnaW5hbExpZnQgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBpc05vZGVBY3RpdmUgfSBmcm9tICcuLi9oZWxwZXJzL2lzTm9kZUFjdGl2ZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBsaWZ0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgYW4gZXhpc3Rpbmcgd3JhcC5cbiAgICAgICAqL1xuICAgICAgbGlmdDogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbGlmdDogUmF3Q29tbWFuZHNbJ2xpZnQnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gIGlmICghaXNBY3RpdmUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBvcmlnaW5hbExpZnQoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IGxpZnRFbXB0eUJsb2NrIGFzIG9yaWdpbmFsTGlmdEVtcHR5QmxvY2sgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgbGlmdEVtcHR5QmxvY2s6IHtcbiAgICAgIC8qKlxuICAgICAgICogTGlmdCBibG9jayBpZiBlbXB0eS5cbiAgICAgICAqL1xuICAgICAgbGlmdEVtcHR5QmxvY2s6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBsaWZ0RW1wdHlCbG9jazogUmF3Q29tbWFuZHNbJ2xpZnRFbXB0eUJsb2NrJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxMaWZ0RW1wdHlCbG9jayhzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgbGlmdExpc3RJdGVtIGFzIG9yaWdpbmFsTGlmdExpc3RJdGVtIH0gZnJvbSAnQHRpcHRhcC9wbS9zY2hlbWEtbGlzdCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGxpZnRMaXN0SXRlbToge1xuICAgICAgLyoqXG4gICAgICAgKiBMaWZ0IHRoZSBsaXN0IGl0ZW0gaW50byBhIHdyYXBwaW5nIGxpc3QuXG4gICAgICAgKi9cbiAgICAgIGxpZnRMaXN0SXRlbTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBsaWZ0TGlzdEl0ZW06IFJhd0NvbW1hbmRzWydsaWZ0TGlzdEl0ZW0nXSA9IHR5cGVPck5hbWUgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcblxuICByZXR1cm4gb3JpZ2luYWxMaWZ0TGlzdEl0ZW0odHlwZSkoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IG5ld2xpbmVJbkNvZGUgYXMgb3JpZ2luYWxOZXdsaW5lSW5Db2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIG5ld2xpbmVJbkNvZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogQWRkIGEgbmV3bGluZSBjaGFyYWN0ZXIgaW4gY29kZS5cbiAgICAgICAqL1xuICAgICAgbmV3bGluZUluQ29kZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbmV3bGluZUluQ29kZTogUmF3Q29tbWFuZHNbJ25ld2xpbmVJbkNvZGUnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbE5ld2xpbmVJbkNvZGUoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lOiBzdHJpbmcsIHNjaGVtYTogU2NoZW1hKTogJ25vZGUnIHwgJ21hcmsnIHwgbnVsbCB7XG4gIGlmIChzY2hlbWEubm9kZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gJ25vZGUnXG4gIH1cblxuICBpZiAoc2NoZW1hLm1hcmtzW25hbWVdKSB7XG4gICAgcmV0dXJuICdtYXJrJ1xuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbiIsICIvKipcbiAqIFJlbW92ZSBhIHByb3BlcnR5IG9yIGFuIGFycmF5IG9mIHByb3BlcnRpZXMgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSBvYmogT2JqZWN0XG4gKiBAcGFyYW0ga2V5IEtleSB0byByZW1vdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZVByb3BzKG9iajogUmVjb3JkPHN0cmluZywgYW55PiwgcHJvcE9yUHJvcHM6IHN0cmluZyB8IHN0cmluZ1tdKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IHByb3BzID0gdHlwZW9mIHByb3BPclByb3BzID09PSAnc3RyaW5nJ1xuICAgID8gW3Byb3BPclByb3BzXVxuICAgIDogcHJvcE9yUHJvcHNcblxuICByZXR1cm4gT2JqZWN0XG4gICAgLmtleXMob2JqKVxuICAgIC5yZWR1Y2UoKG5ld09iajogUmVjb3JkPHN0cmluZywgYW55PiwgcHJvcCkgPT4ge1xuICAgICAgaWYgKCFwcm9wcy5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICBuZXdPYmpbcHJvcF0gPSBvYmpbcHJvcF1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld09ialxuICAgIH0sIHt9KVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrVHlwZS5qcydcbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lIH0gZnJvbSAnLi4vaGVscGVycy9nZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBkZWxldGVQcm9wcyB9IGZyb20gJy4uL3V0aWxpdGllcy9kZWxldGVQcm9wcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHJlc2V0QXR0cmlidXRlczoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXNldHMgc29tZSBub2RlIGF0dHJpYnV0ZXMgdG8gdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgKi9cbiAgICAgIHJlc2V0QXR0cmlidXRlczogKFxuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSB8IE1hcmtUeXBlLFxuICAgICAgICBhdHRyaWJ1dGVzOiBzdHJpbmcgfCBzdHJpbmdbXSxcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmVzZXRBdHRyaWJ1dGVzOiBSYXdDb21tYW5kc1sncmVzZXRBdHRyaWJ1dGVzJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcykgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGxldCBub2RlVHlwZTogTm9kZVR5cGUgfCBudWxsID0gbnVsbFxuICBsZXQgbWFya1R5cGU6IE1hcmtUeXBlIHwgbnVsbCA9IG51bGxcblxuICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUoXG4gICAgdHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSxcbiAgICBzdGF0ZS5zY2hlbWEsXG4gIClcblxuICBpZiAoIXNjaGVtYVR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICBub2RlVHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUgYXMgTm9kZVR5cGUsIHN0YXRlLnNjaGVtYSlcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICBtYXJrVHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUgYXMgTWFya1R5cGUsIHN0YXRlLnNjaGVtYSlcbiAgfVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLnNlbGVjdGlvbi5yYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKHJhbmdlLiRmcm9tLnBvcywgcmFuZ2UuJHRvLnBvcywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB1bmRlZmluZWQsIGRlbGV0ZVByb3BzKG5vZGUuYXR0cnMsIGF0dHJpYnV0ZXMpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKG1hcmsgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtUeXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgICAgdHIuYWRkTWFyayhcbiAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgcG9zICsgbm9kZS5ub2RlU2l6ZSxcbiAgICAgICAgICAgICAgICBtYXJrVHlwZS5jcmVhdGUoZGVsZXRlUHJvcHMobWFyay5hdHRycywgYXR0cmlidXRlcykpLFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2Nyb2xsSW50b1ZpZXc6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIHRoZSBzZWxlY3Rpb24gaW50byB2aWV3LlxuICAgICAgICovXG4gICAgICBzY3JvbGxJbnRvVmlldzogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNjcm9sbEludG9WaWV3OiBSYXdDb21tYW5kc1snc2Nyb2xsSW50b1ZpZXcnXSA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLnNjcm9sbEludG9WaWV3KClcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdEFsbDoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZWxlY3QgdGhlIHdob2xlIGRvY3VtZW50LlxuICAgICAgICovXG4gICAgICBzZWxlY3RBbGw6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RBbGw6IFJhd0NvbW1hbmRzWydzZWxlY3RBbGwnXSA9ICgpID0+ICh7IHRyLCBjb21tYW5kcyB9KSA9PiB7XG4gIHJldHVybiBjb21tYW5kcy5zZXRUZXh0U2VsZWN0aW9uKHtcbiAgICBmcm9tOiAwLFxuICAgIHRvOiB0ci5kb2MuY29udGVudC5zaXplLFxuICB9KVxufVxuIiwgImltcG9ydCB7IHNlbGVjdE5vZGVCYWNrd2FyZCBhcyBvcmlnaW5hbFNlbGVjdE5vZGVCYWNrd2FyZCB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3ROb2RlQmFja3dhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0IGEgbm9kZSBiYWNrd2FyZC5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0Tm9kZUJhY2t3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3ROb2RlQmFja3dhcmQ6IFJhd0NvbW1hbmRzWydzZWxlY3ROb2RlQmFja3dhcmQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbFNlbGVjdE5vZGVCYWNrd2FyZChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgc2VsZWN0Tm9kZUZvcndhcmQgYXMgb3JpZ2luYWxTZWxlY3ROb2RlRm9yd2FyZCB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3ROb2RlRm9yd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZWxlY3QgYSBub2RlIGZvcndhcmQuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdE5vZGVGb3J3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3ROb2RlRm9yd2FyZDogUmF3Q29tbWFuZHNbJ3NlbGVjdE5vZGVGb3J3YXJkJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3ROb2RlRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgc2VsZWN0UGFyZW50Tm9kZSBhcyBvcmlnaW5hbFNlbGVjdFBhcmVudE5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0UGFyZW50Tm9kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBTZWxlY3QgdGhlIHBhcmVudCBub2RlLlxuICAgICAgICovXG4gICAgICBzZWxlY3RQYXJlbnROb2RlOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RQYXJlbnROb2RlOiBSYXdDb21tYW5kc1snc2VsZWN0UGFyZW50Tm9kZSddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0UGFyZW50Tm9kZShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiLy8gQHRzLWlnbm9yZVxuLy8gVE9ETzogYWRkIHR5cGVzIHRvIEB0eXBlcy9wcm9zZW1pcnJvci1jb21tYW5kc1xuaW1wb3J0IHsgc2VsZWN0VGV4dGJsb2NrRW5kIGFzIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrRW5kIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdFRleHRibG9ja0VuZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBNb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBlbmQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuICAgICAgICovXG4gICAgICBzZWxlY3RUZXh0YmxvY2tFbmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdFRleHRibG9ja0VuZDogUmF3Q29tbWFuZHNbJ3NlbGVjdFRleHRibG9ja0VuZCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrRW5kKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICIvLyBAdHMtaWdub3JlXG4vLyBUT0RPOiBhZGQgdHlwZXMgdG8gQHR5cGVzL3Byb3NlbWlycm9yLWNvbW1hbmRzXG5pbXBvcnQgeyBzZWxlY3RUZXh0YmxvY2tTdGFydCBhcyBvcmlnaW5hbFNlbGVjdFRleHRibG9ja1N0YXJ0IH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdFRleHRibG9ja1N0YXJ0OiB7XG4gICAgICAvKipcbiAgICAgICAqIE1vdmVzIHRoZSBjdXJzb3IgdG8gdGhlIHN0YXJ0IG9mIGN1cnJlbnQgdGV4dCBibG9jay5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0VGV4dGJsb2NrU3RhcnQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdFRleHRibG9ja1N0YXJ0OiBSYXdDb21tYW5kc1snc2VsZWN0VGV4dGJsb2NrU3RhcnQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbFNlbGVjdFRleHRibG9ja1N0YXJ0KHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgUGFyc2VPcHRpb25zLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBDb250ZW50IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjcmVhdGVOb2RlRnJvbUNvbnRlbnQgfSBmcm9tICcuL2NyZWF0ZU5vZGVGcm9tQ29udGVudC5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50KFxuICBjb250ZW50OiBDb250ZW50LFxuICBzY2hlbWE6IFNjaGVtYSxcbiAgcGFyc2VPcHRpb25zOiBQYXJzZU9wdGlvbnMgPSB7fSxcbik6IFByb3NlTWlycm9yTm9kZSB7XG4gIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoY29udGVudCwgc2NoZW1hLCB7IHNsaWNlOiBmYWxzZSwgcGFyc2VPcHRpb25zIH0pIGFzIFByb3NlTWlycm9yTm9kZVxufVxuIiwgImltcG9ydCB7IFBhcnNlT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGNyZWF0ZURvY3VtZW50IH0gZnJvbSAnLi4vaGVscGVycy9jcmVhdGVEb2N1bWVudC5qcydcbmltcG9ydCB7IENvbnRlbnQsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXRDb250ZW50OiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlcGxhY2UgdGhlIHdob2xlIGRvY3VtZW50IHdpdGggbmV3IGNvbnRlbnQuXG4gICAgICAgKi9cbiAgICAgIHNldENvbnRlbnQ6IChcbiAgICAgICAgY29udGVudDogQ29udGVudCxcbiAgICAgICAgZW1pdFVwZGF0ZT86IGJvb2xlYW4sXG4gICAgICAgIHBhcnNlT3B0aW9ucz86IFBhcnNlT3B0aW9ucyxcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2V0Q29udGVudDogUmF3Q29tbWFuZHNbJ3NldENvbnRlbnQnXSA9IChjb250ZW50LCBlbWl0VXBkYXRlID0gZmFsc2UsIHBhcnNlT3B0aW9ucyA9IHt9KSA9PiAoeyB0ciwgZWRpdG9yLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgZG9jIH0gPSB0clxuICBjb25zdCBkb2N1bWVudCA9IGNyZWF0ZURvY3VtZW50KGNvbnRlbnQsIGVkaXRvci5zY2hlbWEsIHBhcnNlT3B0aW9ucylcblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5yZXBsYWNlV2l0aCgwLCBkb2MuY29udGVudC5zaXplLCBkb2N1bWVudCkuc2V0TWV0YSgncHJldmVudFVwZGF0ZScsICFlbWl0VXBkYXRlKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBNYXJrLCBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi9nZXRNYXJrVHlwZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtBdHRyaWJ1dGVzKFxuICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gIHR5cGVPck5hbWU6IHN0cmluZyB8IE1hcmtUeXBlLFxuKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgZnJvbSwgdG8sIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb25cbiAgY29uc3QgbWFya3M6IE1hcmtbXSA9IFtdXG5cbiAgaWYgKGVtcHR5KSB7XG4gICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzKSB7XG4gICAgICBtYXJrcy5wdXNoKC4uLnN0YXRlLnN0b3JlZE1hcmtzKVxuICAgIH1cblxuICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpXG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgICBtYXJrcy5wdXNoKC4uLm5vZGUubWFya3MpXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IG1hcmsgPSBtYXJrcy5maW5kKG1hcmtJdGVtID0+IG1hcmtJdGVtLnR5cGUubmFtZSA9PT0gdHlwZS5uYW1lKVxuXG4gIGlmICghbWFyaykge1xuICAgIHJldHVybiB7fVxuICB9XG5cbiAgcmV0dXJuIHsgLi4ubWFyay5hdHRycyB9XG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBgVHJhbnNmb3JtYCBiYXNlZCBvbiBhbGwgc3RlcHMgb2YgdGhlIHBhc3NlZCB0cmFuc2FjdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcyhcbiAgb2xkRG9jOiBQcm9zZU1pcnJvck5vZGUsXG4gIHRyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25bXSxcbik6IFRyYW5zZm9ybSB7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0ob2xkRG9jKVxuXG4gIHRyYW5zYWN0aW9ucy5mb3JFYWNoKHRyYW5zYWN0aW9uID0+IHtcbiAgICB0cmFuc2FjdGlvbi5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4ge1xuICAgICAgdHJhbnNmb3JtLnN0ZXAoc3RlcClcbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiB0cmFuc2Zvcm1cbn1cbiIsICJpbXBvcnQgeyBDb250ZW50TWF0Y2gsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRCbG9ja0F0KG1hdGNoOiBDb250ZW50TWF0Y2gpOiBOb2RlVHlwZSB8IG51bGwge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSArPSAxKSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBtYXRjaC5lZGdlKGkpXG5cbiAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpIHtcbiAgICAgIHJldHVybiB0eXBlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IE5vZGVXaXRoUG9zLCBQcmVkaWNhdGUgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRDaGlsZHJlbihub2RlOiBQcm9zZU1pcnJvck5vZGUsIHByZWRpY2F0ZTogUHJlZGljYXRlKTogTm9kZVdpdGhQb3NbXSB7XG4gIGNvbnN0IG5vZGVzV2l0aFBvczogTm9kZVdpdGhQb3NbXSA9IFtdXG5cbiAgbm9kZS5kZXNjZW5kYW50cygoY2hpbGQsIHBvcykgPT4ge1xuICAgIGlmIChwcmVkaWNhdGUoY2hpbGQpKSB7XG4gICAgICBub2Rlc1dpdGhQb3MucHVzaCh7XG4gICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICBwb3MsXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gbm9kZXNXaXRoUG9zXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBOb2RlV2l0aFBvcywgUHJlZGljYXRlLCBSYW5nZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG4vKipcbiAqIFNhbWUgYXMgYGZpbmRDaGlsZHJlbmAgYnV0IHNlYXJjaGVzIG9ubHkgd2l0aGluIGEgYHJhbmdlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRDaGlsZHJlbkluUmFuZ2UoXG4gIG5vZGU6IFByb3NlTWlycm9yTm9kZSxcbiAgcmFuZ2U6IFJhbmdlLFxuICBwcmVkaWNhdGU6IFByZWRpY2F0ZSxcbik6IE5vZGVXaXRoUG9zW10ge1xuICBjb25zdCBub2Rlc1dpdGhQb3M6IE5vZGVXaXRoUG9zW10gPSBbXVxuXG4gIC8vIGlmIChyYW5nZS5mcm9tID09PSByYW5nZS50bykge1xuICAvLyAgIGNvbnN0IG5vZGVBdCA9IG5vZGUubm9kZUF0KHJhbmdlLmZyb20pXG5cbiAgLy8gICBpZiAobm9kZUF0KSB7XG4gIC8vICAgICBub2Rlc1dpdGhQb3MucHVzaCh7XG4gIC8vICAgICAgIG5vZGU6IG5vZGVBdCxcbiAgLy8gICAgICAgcG9zOiByYW5nZS5mcm9tLFxuICAvLyAgICAgfSlcbiAgLy8gICB9XG4gIC8vIH1cblxuICBub2RlLm5vZGVzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgKGNoaWxkLCBwb3MpID0+IHtcbiAgICBpZiAocHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xuICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgcG9zLFxuICAgICAgfSlcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIG5vZGVzV2l0aFBvc1xufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBSZXNvbHZlZFBvcyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IFByZWRpY2F0ZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MoXG4gICRwb3M6IFJlc29sdmVkUG9zLFxuICBwcmVkaWNhdGU6IFByZWRpY2F0ZSxcbik6XG4gIHwge1xuICAgICAgcG9zOiBudW1iZXJcbiAgICAgIHN0YXJ0OiBudW1iZXJcbiAgICAgIGRlcHRoOiBudW1iZXJcbiAgICAgIG5vZGU6IFByb3NlTWlycm9yTm9kZVxuICAgIH1cbiAgfCB1bmRlZmluZWQge1xuICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aDsgaSA+IDA7IGkgLT0gMSkge1xuICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoaSlcblxuICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvczogaSA+IDAgPyAkcG9zLmJlZm9yZShpKSA6IDAsXG4gICAgICAgIHN0YXJ0OiAkcG9zLnN0YXJ0KGkpLFxuICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgbm9kZSxcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBQcmVkaWNhdGUgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zIH0gZnJvbSAnLi9maW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1Bvcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRQYXJlbnROb2RlKHByZWRpY2F0ZTogUHJlZGljYXRlKSB7XG4gIHJldHVybiAoc2VsZWN0aW9uOiBTZWxlY3Rpb24pID0+IGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zKHNlbGVjdGlvbi4kZnJvbSwgcHJlZGljYXRlKVxufVxuIiwgImltcG9ydCB7IERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SFRNTEZyb21GcmFnbWVudChmcmFnbWVudDogRnJhZ21lbnQsIHNjaGVtYTogU2NoZW1hKTogc3RyaW5nIHtcbiAgY29uc3QgZG9jdW1lbnRGcmFnbWVudCA9IERPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYShzY2hlbWEpLnNlcmlhbGl6ZUZyYWdtZW50KGZyYWdtZW50KVxuXG4gIGNvbnN0IHRlbXBvcmFyeURvY3VtZW50ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KClcbiAgY29uc3QgY29udGFpbmVyID0gdGVtcG9yYXJ5RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnRGcmFnbWVudClcblxuICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxufVxuIiwgImltcG9ydCB7IFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4uL0VkaXRvci5qcydcbmltcG9ydCB7IEV4dGVuc2lvbk1hbmFnZXIgfSBmcm9tICcuLi9FeHRlbnNpb25NYW5hZ2VyLmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9ucyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMgfSBmcm9tICcuL2dldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMsIGVkaXRvcj86IEVkaXRvcik6IFNjaGVtYSB7XG4gIGNvbnN0IHJlc29sdmVkRXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIucmVzb2x2ZShleHRlbnNpb25zKVxuXG4gIHJldHVybiBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyhyZXNvbHZlZEV4dGVuc2lvbnMsIGVkaXRvcilcbn1cbiIsICJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRXh0ZW5zaW9ucywgSlNPTkNvbnRlbnQgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldEhUTUxGcm9tRnJhZ21lbnQgfSBmcm9tICcuL2dldEhUTUxGcm9tRnJhZ21lbnQuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWEgfSBmcm9tICcuL2dldFNjaGVtYS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlSFRNTChkb2M6IEpTT05Db250ZW50LCBleHRlbnNpb25zOiBFeHRlbnNpb25zKTogc3RyaW5nIHtcbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpXG4gIGNvbnN0IGNvbnRlbnROb2RlID0gTm9kZS5mcm9tSlNPTihzY2hlbWEsIGRvYylcblxuICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudChjb250ZW50Tm9kZS5jb250ZW50LCBzY2hlbWEpXG59XG4iLCAiaW1wb3J0IHsgRE9NUGFyc2VyIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRXh0ZW5zaW9ucyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZWxlbWVudEZyb21TdHJpbmcgfSBmcm9tICcuLi91dGlsaXRpZXMvZWxlbWVudEZyb21TdHJpbmcuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWEgfSBmcm9tICcuL2dldFNjaGVtYS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlSlNPTihodG1sOiBzdHJpbmcsIGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpXG4gIGNvbnN0IGRvbSA9IGVsZW1lbnRGcm9tU3RyaW5nKGh0bWwpXG5cbiAgcmV0dXJuIERPTVBhcnNlci5mcm9tU2NoZW1hKHNjaGVtYSkucGFyc2UoZG9tKS50b0pTT04oKVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgVGV4dFNlcmlhbGl6ZXIgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldFRleHRCZXR3ZWVuIH0gZnJvbSAnLi9nZXRUZXh0QmV0d2Vlbi5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRleHQoXG4gIG5vZGU6IFByb3NlTWlycm9yTm9kZSxcbiAgb3B0aW9ucz86IHtcbiAgICBibG9ja1NlcGFyYXRvcj86IHN0cmluZ1xuICAgIHRleHRTZXJpYWxpemVycz86IFJlY29yZDxzdHJpbmcsIFRleHRTZXJpYWxpemVyPlxuICB9LFxuKSB7XG4gIGNvbnN0IHJhbmdlID0ge1xuICAgIGZyb206IDAsXG4gICAgdG86IG5vZGUuY29udGVudC5zaXplLFxuICB9XG5cbiAgcmV0dXJuIGdldFRleHRCZXR3ZWVuKG5vZGUsIHJhbmdlLCBvcHRpb25zKVxufVxuIiwgImltcG9ydCB7IE5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb25zLCBKU09OQ29udGVudCwgVGV4dFNlcmlhbGl6ZXIgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldFNjaGVtYSB9IGZyb20gJy4vZ2V0U2NoZW1hLmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dCB9IGZyb20gJy4vZ2V0VGV4dC5qcydcbmltcG9ydCB7IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEgfSBmcm9tICcuL2dldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVRleHQoXG4gIGRvYzogSlNPTkNvbnRlbnQsXG4gIGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMsXG4gIG9wdGlvbnM/OiB7XG4gICAgYmxvY2tTZXBhcmF0b3I/OiBzdHJpbmdcbiAgICB0ZXh0U2VyaWFsaXplcnM/OiBSZWNvcmQ8c3RyaW5nLCBUZXh0U2VyaWFsaXplcj5cbiAgfSxcbik6IHN0cmluZyB7XG4gIGNvbnN0IHsgYmxvY2tTZXBhcmF0b3IgPSAnXFxuXFxuJywgdGV4dFNlcmlhbGl6ZXJzID0ge30gfSA9IG9wdGlvbnMgfHwge31cbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpXG4gIGNvbnN0IGNvbnRlbnROb2RlID0gTm9kZS5mcm9tSlNPTihzY2hlbWEsIGRvYylcblxuICByZXR1cm4gZ2V0VGV4dChjb250ZW50Tm9kZSwge1xuICAgIGJsb2NrU2VwYXJhdG9yLFxuICAgIHRleHRTZXJpYWxpemVyczoge1xuICAgICAgLi4uZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWEpLFxuICAgICAgLi4udGV4dFNlcmlhbGl6ZXJzLFxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgTm9kZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4vZ2V0Tm9kZVR5cGUuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlQXR0cmlidXRlcyhcbiAgc3RhdGU6IEVkaXRvclN0YXRlLFxuICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSxcbik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCB7IGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb25cbiAgY29uc3Qgbm9kZXM6IE5vZGVbXSA9IFtdXG5cbiAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgbm9kZXMucHVzaChub2RlKVxuICB9KVxuXG4gIGNvbnN0IG5vZGUgPSBub2Rlcy5yZXZlcnNlKCkuZmluZChub2RlSXRlbSA9PiBub2RlSXRlbS50eXBlLm5hbWUgPT09IHR5cGUubmFtZSlcblxuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuXG4gIHJldHVybiB7IC4uLm5vZGUuYXR0cnMgfVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGdldE1hcmtBdHRyaWJ1dGVzIH0gZnJvbSAnLi9nZXRNYXJrQXR0cmlidXRlcy5qcydcbmltcG9ydCB7IGdldE5vZGVBdHRyaWJ1dGVzIH0gZnJvbSAnLi9nZXROb2RlQXR0cmlidXRlcy5qcydcbmltcG9ydCB7IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lIH0gZnJvbSAnLi9nZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUgfCBNYXJrVHlwZSxcbik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUoXG4gICAgdHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSxcbiAgICBzdGF0ZS5zY2hlbWEsXG4gIClcblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgcmV0dXJuIGdldE5vZGVBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lIGFzIE5vZGVUeXBlKVxuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdtYXJrJykge1xuICAgIHJldHVybiBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSBhcyBNYXJrVHlwZSlcbiAgfVxuXG4gIHJldHVybiB7fVxufVxuIiwgIi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGVkIHZhbHVlcyB3aXRoaW4gYW4gYXJyYXkuXG4gKiBTdXBwb3J0cyBudW1iZXJzLCBzdHJpbmdzIGFuZCBvYmplY3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlczxUPihhcnJheTogVFtdLCBieSA9IEpTT04uc3RyaW5naWZ5KTogVFtdIHtcbiAgY29uc3Qgc2VlbjogUmVjb3JkPGFueSwgYW55PiA9IHt9XG5cbiAgcmV0dXJuIGFycmF5LmZpbHRlcihpdGVtID0+IHtcbiAgICBjb25zdCBrZXkgPSBieShpdGVtKVxuXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWVuLCBrZXkpXG4gICAgICA/IGZhbHNlXG4gICAgICA6IChzZWVuW2tleV0gPSB0cnVlKVxuICB9KVxufVxuIiwgImltcG9ydCB7IFN0ZXAsIFRyYW5zZm9ybSB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgcmVtb3ZlRHVwbGljYXRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9yZW1vdmVEdXBsaWNhdGVzLmpzJ1xuXG5leHBvcnQgdHlwZSBDaGFuZ2VkUmFuZ2UgPSB7XG4gIG9sZFJhbmdlOiBSYW5nZSxcbiAgbmV3UmFuZ2U6IFJhbmdlLFxufVxuXG4vKipcbiAqIFJlbW92ZXMgZHVwbGljYXRlZCByYW5nZXMgYW5kIHJhbmdlcyB0aGF0IGFyZVxuICogZnVsbHkgY2FwdHVyZWQgYnkgb3RoZXIgcmFuZ2VzLlxuICovXG5mdW5jdGlvbiBzaW1wbGlmeUNoYW5nZWRSYW5nZXMoY2hhbmdlczogQ2hhbmdlZFJhbmdlW10pOiBDaGFuZ2VkUmFuZ2VbXSB7XG4gIGNvbnN0IHVuaXF1ZUNoYW5nZXMgPSByZW1vdmVEdXBsaWNhdGVzKGNoYW5nZXMpXG5cbiAgcmV0dXJuIHVuaXF1ZUNoYW5nZXMubGVuZ3RoID09PSAxXG4gICAgPyB1bmlxdWVDaGFuZ2VzXG4gICAgOiB1bmlxdWVDaGFuZ2VzLmZpbHRlcigoY2hhbmdlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcmVzdCA9IHVuaXF1ZUNoYW5nZXMuZmlsdGVyKChfLCBpKSA9PiBpICE9PSBpbmRleClcblxuICAgICAgcmV0dXJuICFyZXN0LnNvbWUob3RoZXJDaGFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4gY2hhbmdlLm9sZFJhbmdlLmZyb20gPj0gb3RoZXJDaGFuZ2Uub2xkUmFuZ2UuZnJvbVxuICAgICAgICAgICYmIGNoYW5nZS5vbGRSYW5nZS50byA8PSBvdGhlckNoYW5nZS5vbGRSYW5nZS50b1xuICAgICAgICAgICYmIGNoYW5nZS5uZXdSYW5nZS5mcm9tID49IG90aGVyQ2hhbmdlLm5ld1JhbmdlLmZyb21cbiAgICAgICAgICAmJiBjaGFuZ2UubmV3UmFuZ2UudG8gPD0gb3RoZXJDaGFuZ2UubmV3UmFuZ2UudG9cbiAgICAgIH0pXG4gICAgfSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBjaGFuZ2VkIHJhbmdlc1xuICogYmFzZWQgb24gdGhlIGZpcnN0IGFuZCBsYXN0IHN0YXRlIG9mIGFsbCBzdGVwcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENoYW5nZWRSYW5nZXModHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiBDaGFuZ2VkUmFuZ2VbXSB7XG4gIGNvbnN0IHsgbWFwcGluZywgc3RlcHMgfSA9IHRyYW5zZm9ybVxuICBjb25zdCBjaGFuZ2VzOiBDaGFuZ2VkUmFuZ2VbXSA9IFtdXG5cbiAgbWFwcGluZy5tYXBzLmZvckVhY2goKHN0ZXBNYXAsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcmFuZ2VzOiBSYW5nZVtdID0gW11cblxuICAgIC8vIFRoaXMgYWNjb3VudHMgZm9yIHN0ZXAgY2hhbmdlcyB3aGVyZSBubyByYW5nZSB3YXMgYWN0dWFsbHkgYWx0ZXJlZFxuICAgIC8vIGUuZy4gd2hlbiBzZXR0aW5nIGEgbWFyaywgbm9kZSBhdHRyaWJ1dGUsIGV0Yy5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKCFzdGVwTWFwLnJhbmdlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHN0ZXBzW2luZGV4XSBhcyBTdGVwICYge1xuICAgICAgICBmcm9tPzogbnVtYmVyLFxuICAgICAgICB0bz86IG51bWJlcixcbiAgICAgIH1cblxuICAgICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCB8fCB0byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICByYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ZXBNYXAuZm9yRWFjaCgoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByYW5nZXMuZm9yRWFjaCgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICBjb25zdCBuZXdTdGFydCA9IG1hcHBpbmcuc2xpY2UoaW5kZXgpLm1hcChmcm9tLCAtMSlcbiAgICAgIGNvbnN0IG5ld0VuZCA9IG1hcHBpbmcuc2xpY2UoaW5kZXgpLm1hcCh0bylcbiAgICAgIGNvbnN0IG9sZFN0YXJ0ID0gbWFwcGluZy5pbnZlcnQoKS5tYXAobmV3U3RhcnQsIC0xKVxuICAgICAgY29uc3Qgb2xkRW5kID0gbWFwcGluZy5pbnZlcnQoKS5tYXAobmV3RW5kKVxuXG4gICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICBvbGRSYW5nZToge1xuICAgICAgICAgIGZyb206IG9sZFN0YXJ0LFxuICAgICAgICAgIHRvOiBvbGRFbmQsXG4gICAgICAgIH0sXG4gICAgICAgIG5ld1JhbmdlOiB7XG4gICAgICAgICAgZnJvbTogbmV3U3RhcnQsXG4gICAgICAgICAgdG86IG5ld0VuZCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gc2ltcGxpZnlDaGFuZ2VkUmFuZ2VzKGNoYW5nZXMpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBKU09OQ29udGVudCB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5pbnRlcmZhY2UgRGVidWdKU09OQ29udGVudCBleHRlbmRzIEpTT05Db250ZW50IHtcbiAgZnJvbTogbnVtYmVyXG4gIHRvOiBudW1iZXJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlYnVnSlNPTihub2RlOiBQcm9zZU1pcnJvck5vZGUsIHN0YXJ0T2Zmc2V0ID0gMCk6IERlYnVnSlNPTkNvbnRlbnQge1xuICBjb25zdCBpc1RvcE5vZGUgPSBub2RlLnR5cGUgPT09IG5vZGUudHlwZS5zY2hlbWEudG9wTm9kZVR5cGVcbiAgY29uc3QgaW5jcmVtZW50ID0gaXNUb3BOb2RlID8gMCA6IDFcbiAgY29uc3QgZnJvbSA9IHN0YXJ0T2Zmc2V0XG4gIGNvbnN0IHRvID0gZnJvbSArIG5vZGUubm9kZVNpemVcbiAgY29uc3QgbWFya3MgPSBub2RlLm1hcmtzLm1hcChtYXJrID0+IHtcbiAgICBjb25zdCBvdXRwdXQ6IHsgdHlwZTogc3RyaW5nOyBhdHRycz86IFJlY29yZDxzdHJpbmcsIGFueT4gfSA9IHtcbiAgICAgIHR5cGU6IG1hcmsudHlwZS5uYW1lLFxuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhtYXJrLmF0dHJzKS5sZW5ndGgpIHtcbiAgICAgIG91dHB1dC5hdHRycyA9IHsgLi4ubWFyay5hdHRycyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dFxuICB9KVxuICBjb25zdCBhdHRycyA9IHsgLi4ubm9kZS5hdHRycyB9XG4gIGNvbnN0IG91dHB1dDogRGVidWdKU09OQ29udGVudCA9IHtcbiAgICB0eXBlOiBub2RlLnR5cGUubmFtZSxcbiAgICBmcm9tLFxuICAgIHRvLFxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKGF0dHJzKS5sZW5ndGgpIHtcbiAgICBvdXRwdXQuYXR0cnMgPSBhdHRyc1xuICB9XG5cbiAgaWYgKG1hcmtzLmxlbmd0aCkge1xuICAgIG91dHB1dC5tYXJrcyA9IG1hcmtzXG4gIH1cblxuICBpZiAobm9kZS5jb250ZW50LmNoaWxkQ291bnQpIHtcbiAgICBvdXRwdXQuY29udGVudCA9IFtdXG5cbiAgICBub2RlLmZvckVhY2goKGNoaWxkLCBvZmZzZXQpID0+IHtcbiAgICAgIG91dHB1dC5jb250ZW50Py5wdXNoKGdldERlYnVnSlNPTihjaGlsZCwgc3RhcnRPZmZzZXQgKyBvZmZzZXQgKyBpbmNyZW1lbnQpKVxuICAgIH0pXG4gIH1cblxuICBpZiAobm9kZS50ZXh0KSB7XG4gICAgb3V0cHV0LnRleHQgPSBub2RlLnRleHRcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IE1hcmtSYW5nZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZ2V0TWFya1JhbmdlIH0gZnJvbSAnLi9nZXRNYXJrUmFuZ2UuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJrc0JldHdlZW4oZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyLCBkb2M6IFByb3NlTWlycm9yTm9kZSk6IE1hcmtSYW5nZVtdIHtcbiAgY29uc3QgbWFya3M6IE1hcmtSYW5nZVtdID0gW11cblxuICAvLyBnZXQgYWxsIGluY2x1c2l2ZSBtYXJrcyBvbiBlbXB0eSBzZWxlY3Rpb25cbiAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgZG9jXG4gICAgICAucmVzb2x2ZShmcm9tKVxuICAgICAgLm1hcmtzKClcbiAgICAgIC5mb3JFYWNoKG1hcmsgPT4ge1xuICAgICAgICBjb25zdCAkcG9zID0gZG9jLnJlc29sdmUoZnJvbSAtIDEpXG4gICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0TWFya1JhbmdlKCRwb3MsIG1hcmsudHlwZSlcblxuICAgICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICBtYXJrLFxuICAgICAgICAgIC4uLnJhbmdlLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgfSBlbHNlIHtcbiAgICBkb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAoIW5vZGUgfHwgbm9kZT8ubm9kZVNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbWFya3MucHVzaChcbiAgICAgICAgLi4ubm9kZS5tYXJrcy5tYXAobWFyayA9PiAoe1xuICAgICAgICAgIGZyb206IHBvcyxcbiAgICAgICAgICB0bzogcG9zICsgbm9kZS5ub2RlU2l6ZSxcbiAgICAgICAgICBtYXJrLFxuICAgICAgICB9KSksXG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBtYXJrc1xufVxuIiwgImltcG9ydCB7IE5vZGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3Qgbm9kZSBvZiBhIGdpdmVuIHR5cGUgb3IgbmFtZSBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKiBAcGFyYW0gc3RhdGUgVGhlIGVkaXRvciBzdGF0ZS5cbiAqIEBwYXJhbSB0eXBlT3JOYW1lIFRoZSBub2RlIHR5cGUgb3IgbmFtZS5cbiAqIEBwYXJhbSBwb3MgVGhlIHBvc2l0aW9uIHRvIHN0YXJ0IHNlYXJjaGluZyBmcm9tLlxuICogQHBhcmFtIG1heERlcHRoIFRoZSBtYXhpbXVtIGRlcHRoIHRvIHNlYXJjaC5cbiAqIEByZXR1cm5zIFRoZSBub2RlIGFuZCB0aGUgZGVwdGggYXMgYW4gYXJyYXkuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXROb2RlQXRQb3NpdGlvbiA9IChzdGF0ZTogRWRpdG9yU3RhdGUsIHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBwb3M6IG51bWJlciwgbWF4RGVwdGggPSAyMCkgPT4ge1xuICBjb25zdCAkcG9zID0gc3RhdGUuZG9jLnJlc29sdmUocG9zKVxuXG4gIGxldCBjdXJyZW50RGVwdGggPSBtYXhEZXB0aFxuICBsZXQgbm9kZTogTm9kZSB8IG51bGwgPSBudWxsXG5cbiAgd2hpbGUgKGN1cnJlbnREZXB0aCA+IDAgJiYgbm9kZSA9PT0gbnVsbCkge1xuICAgIGNvbnN0IGN1cnJlbnROb2RlID0gJHBvcy5ub2RlKGN1cnJlbnREZXB0aClcblxuICAgIGlmIChjdXJyZW50Tm9kZT8udHlwZS5uYW1lID09PSB0eXBlT3JOYW1lKSB7XG4gICAgICBub2RlID0gY3VycmVudE5vZGVcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudERlcHRoIC09IDFcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW25vZGUsIGN1cnJlbnREZXB0aF0gYXMgW05vZGUgfCBudWxsLCBudW1iZXJdXG59XG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uQXR0cmlidXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoXG4gIGV4dGVuc2lvbkF0dHJpYnV0ZXM6IEV4dGVuc2lvbkF0dHJpYnV0ZVtdLFxuICB0eXBlTmFtZTogc3RyaW5nLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0XG4gICAgLmVudHJpZXMoYXR0cmlidXRlcylcbiAgICAuZmlsdGVyKChbbmFtZV0pID0+IHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZSA9IGV4dGVuc2lvbkF0dHJpYnV0ZXMuZmluZChpdGVtID0+IHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PT0gdHlwZU5hbWUgJiYgaXRlbS5uYW1lID09PSBuYW1lXG4gICAgICB9KVxuXG4gICAgICBpZiAoIWV4dGVuc2lvbkF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZS5hdHRyaWJ1dGUua2VlcE9uU3BsaXRcbiAgICB9KSlcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IE1hcmtSYW5nZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgb2JqZWN0SW5jbHVkZXMgfSBmcm9tICcuLi91dGlsaXRpZXMvb2JqZWN0SW5jbHVkZXMuanMnXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4vZ2V0TWFya1R5cGUuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc01hcmtBY3RpdmUoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgdHlwZU9yTmFtZTogTWFya1R5cGUgfCBzdHJpbmcgfCBudWxsLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30sXG4pOiBib29sZWFuIHtcbiAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzdGF0ZS5zZWxlY3Rpb25cbiAgY29uc3QgdHlwZSA9IHR5cGVPck5hbWUgPyBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpIDogbnVsbFxuXG4gIGlmIChlbXB0eSkge1xuICAgIHJldHVybiAhIShzdGF0ZS5zdG9yZWRNYXJrcyB8fCBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcbiAgICAgIC5maWx0ZXIobWFyayA9PiB7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBtYXJrLnR5cGUubmFtZVxuICAgICAgfSlcbiAgICAgIC5maW5kKG1hcmsgPT4gb2JqZWN0SW5jbHVkZXMobWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKVxuICB9XG5cbiAgbGV0IHNlbGVjdGlvblJhbmdlID0gMFxuICBjb25zdCBtYXJrUmFuZ2VzOiBNYXJrUmFuZ2VbXSA9IFtdXG5cbiAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgY29uc3QgZnJvbSA9ICRmcm9tLnBvc1xuICAgIGNvbnN0IHRvID0gJHRvLnBvc1xuXG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgaWYgKCFub2RlLmlzVGV4dCAmJiAhbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlbGF0aXZlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcylcbiAgICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBNYXRoLm1pbih0bywgcG9zICsgbm9kZS5ub2RlU2l6ZSlcbiAgICAgIGNvbnN0IHJhbmdlID0gcmVsYXRpdmVUbyAtIHJlbGF0aXZlRnJvbVxuXG4gICAgICBzZWxlY3Rpb25SYW5nZSArPSByYW5nZVxuXG4gICAgICBtYXJrUmFuZ2VzLnB1c2goXG4gICAgICAgIC4uLm5vZGUubWFya3MubWFwKG1hcmsgPT4gKHtcbiAgICAgICAgICBtYXJrLFxuICAgICAgICAgIGZyb206IHJlbGF0aXZlRnJvbSxcbiAgICAgICAgICB0bzogcmVsYXRpdmVUbyxcbiAgICAgICAgfSkpLFxuICAgICAgKVxuICAgIH0pXG4gIH0pXG5cbiAgaWYgKHNlbGVjdGlvblJhbmdlID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBjYWxjdWxhdGUgcmFuZ2Ugb2YgbWF0Y2hlZCBtYXJrXG4gIGNvbnN0IG1hdGNoZWRSYW5nZSA9IG1hcmtSYW5nZXNcbiAgICAuZmlsdGVyKG1hcmtSYW5nZSA9PiB7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gbWFya1JhbmdlLm1hcmsudHlwZS5uYW1lXG4gICAgfSlcbiAgICAuZmlsdGVyKG1hcmtSYW5nZSA9PiBvYmplY3RJbmNsdWRlcyhtYXJrUmFuZ2UubWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKVxuICAgIC5yZWR1Y2UoKHN1bSwgbWFya1JhbmdlKSA9PiBzdW0gKyBtYXJrUmFuZ2UudG8gLSBtYXJrUmFuZ2UuZnJvbSwgMClcblxuICAvLyBjYWxjdWxhdGUgcmFuZ2Ugb2YgbWFya3MgdGhhdCBleGNsdWRlcyB0aGUgc2VhcmNoZWQgbWFya1xuICAvLyBmb3IgZXhhbXBsZSBgY29kZWAgZG9lc27igJl0IGFsbG93IGFueSBvdGhlciBtYXJrc1xuICBjb25zdCBleGNsdWRlZFJhbmdlID0gbWFya1Jhbmdlc1xuICAgIC5maWx0ZXIobWFya1JhbmdlID0+IHtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFya1JhbmdlLm1hcmsudHlwZSAhPT0gdHlwZSAmJiBtYXJrUmFuZ2UubWFyay50eXBlLmV4Y2x1ZGVzKHR5cGUpXG4gICAgfSlcbiAgICAucmVkdWNlKChzdW0sIG1hcmtSYW5nZSkgPT4gc3VtICsgbWFya1JhbmdlLnRvIC0gbWFya1JhbmdlLmZyb20sIDApXG5cbiAgLy8gd2Ugb25seSBpbmNsdWRlIHRoZSByZXN1bHQgb2YgYGV4Y2x1ZGVkUmFuZ2VgXG4gIC8vIGlmIHRoZXJlIGlzIGEgbWF0Y2ggYXQgYWxsXG4gIGNvbnN0IHJhbmdlID0gbWF0Y2hlZFJhbmdlID4gMCA/IG1hdGNoZWRSYW5nZSArIGV4Y2x1ZGVkUmFuZ2UgOiBtYXRjaGVkUmFuZ2VcblxuICByZXR1cm4gcmFuZ2UgPj0gc2VsZWN0aW9uUmFuZ2Vcbn1cbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lIH0gZnJvbSAnLi9nZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZS5qcydcbmltcG9ydCB7IGlzTWFya0FjdGl2ZSB9IGZyb20gJy4vaXNNYXJrQWN0aXZlLmpzJ1xuaW1wb3J0IHsgaXNOb2RlQWN0aXZlIH0gZnJvbSAnLi9pc05vZGVBY3RpdmUuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FjdGl2ZShcbiAgc3RhdGU6IEVkaXRvclN0YXRlLFxuICBuYW1lOiBzdHJpbmcgfCBudWxsLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30sXG4pOiBib29sZWFuIHtcbiAgaWYgKCFuYW1lKSB7XG4gICAgcmV0dXJuIGlzTm9kZUFjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcykgfHwgaXNNYXJrQWN0aXZlKHN0YXRlLCBudWxsLCBhdHRyaWJ1dGVzKVxuICB9XG5cbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKG5hbWUsIHN0YXRlLnNjaGVtYSlcblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgcmV0dXJuIGlzTm9kZUFjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcylcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICByZXR1cm4gaXNNYXJrQWN0aXZlKHN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzKVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBmaW5kUGFyZW50Tm9kZSB9IGZyb20gJy4vZmluZFBhcmVudE5vZGUuanMnXG5cbmV4cG9ydCBjb25zdCBpc0F0RW5kT2ZOb2RlID0gKHN0YXRlOiBFZGl0b3JTdGF0ZSwgbm9kZVR5cGU/OiBzdHJpbmcpID0+IHtcbiAgY29uc3QgeyAkZnJvbSwgJHRvLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb25cblxuICBpZiAobm9kZVR5cGUpIHtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUubmFtZSA9PT0gbm9kZVR5cGUpKHN0YXRlLnNlbGVjdGlvbilcblxuICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgJHBhcmVudFBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBhcmVudE5vZGUucG9zICsgMSlcblxuICAgIGlmICgkYW5jaG9yLnBvcyArIDEgPT09ICRwYXJlbnRQb3MuZW5kKCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoJHRvLnBhcmVudE9mZnNldCA8ICR0by5wYXJlbnQubm9kZVNpemUgLSAyIHx8ICRmcm9tLnBvcyAhPT0gJHRvLnBvcykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBjb25zdCBpc0F0U3RhcnRPZk5vZGUgPSAoc3RhdGU6IEVkaXRvclN0YXRlKSA9PiB7XG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uXG5cbiAgaWYgKCRmcm9tLnBhcmVudE9mZnNldCA+IDAgfHwgJGZyb20ucG9zICE9PSAkdG8ucG9zKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnLi4vaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IE5vZGVDb25maWcgfSBmcm9tICcuLi9pbmRleC5qcydcbmltcG9ydCB7IEV4dGVuc2lvbnMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4uL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBzcGxpdEV4dGVuc2lvbnMgfSBmcm9tICcuL3NwbGl0RXh0ZW5zaW9ucy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTGlzdChuYW1lOiBzdHJpbmcsIGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBib29sZWFuIHtcbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpXG4gIGNvbnN0IGV4dGVuc2lvbiA9IG5vZGVFeHRlbnNpb25zLmZpbmQoaXRlbSA9PiBpdGVtLm5hbWUgPT09IG5hbWUpXG5cbiAgaWYgKCFleHRlbnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gIH1cbiAgY29uc3QgZ3JvdXAgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snZ3JvdXAnXT4oZXh0ZW5zaW9uLCAnZ3JvdXAnLCBjb250ZXh0KSlcblxuICBpZiAodHlwZW9mIGdyb3VwICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGdyb3VwLnNwbGl0KCcgJykuaW5jbHVkZXMoJ2xpc3QnKVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZUVtcHR5KG5vZGU6IFByb3NlTWlycm9yTm9kZSk6IGJvb2xlYW4ge1xuICBjb25zdCBkZWZhdWx0Q29udGVudCA9IG5vZGUudHlwZS5jcmVhdGVBbmRGaWxsKCk/LnRvSlNPTigpXG4gIGNvbnN0IGNvbnRlbnQgPSBub2RlLnRvSlNPTigpXG5cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRlZmF1bHRDb250ZW50KSA9PT0gSlNPTi5zdHJpbmdpZnkoY29udGVudClcbn1cbiIsICJpbXBvcnQgeyBOb2RlU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZVNlbGVjdGlvbih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIE5vZGVTZWxlY3Rpb24ge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHsgbWluTWF4IH0gZnJvbSAnLi4vdXRpbGl0aWVzL21pbk1heC5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIHBvc1RvRE9NUmVjdCh2aWV3OiBFZGl0b3JWaWV3LCBmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpOiBET01SZWN0IHtcbiAgY29uc3QgbWluUG9zID0gMFxuICBjb25zdCBtYXhQb3MgPSB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemVcbiAgY29uc3QgcmVzb2x2ZWRGcm9tID0gbWluTWF4KGZyb20sIG1pblBvcywgbWF4UG9zKVxuICBjb25zdCByZXNvbHZlZEVuZCA9IG1pbk1heCh0bywgbWluUG9zLCBtYXhQb3MpXG4gIGNvbnN0IHN0YXJ0ID0gdmlldy5jb29yZHNBdFBvcyhyZXNvbHZlZEZyb20pXG4gIGNvbnN0IGVuZCA9IHZpZXcuY29vcmRzQXRQb3MocmVzb2x2ZWRFbmQsIC0xKVxuICBjb25zdCB0b3AgPSBNYXRoLm1pbihzdGFydC50b3AsIGVuZC50b3ApXG4gIGNvbnN0IGJvdHRvbSA9IE1hdGgubWF4KHN0YXJ0LmJvdHRvbSwgZW5kLmJvdHRvbSlcbiAgY29uc3QgbGVmdCA9IE1hdGgubWluKHN0YXJ0LmxlZnQsIGVuZC5sZWZ0KVxuICBjb25zdCByaWdodCA9IE1hdGgubWF4KHN0YXJ0LnJpZ2h0LCBlbmQucmlnaHQpXG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0XG4gIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcFxuICBjb25zdCB4ID0gbGVmdFxuICBjb25zdCB5ID0gdG9wXG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgdG9wLFxuICAgIGJvdHRvbSxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHksXG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgdG9KU09OOiAoKSA9PiBkYXRhLFxuICB9XG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIFJlc29sdmVkUG9zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEVkaXRvclN0YXRlLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGdldE1hcmtBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrQXR0cmlidXRlcy5qcydcbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrVHlwZS5qcydcbmltcG9ydCB7IGlzVGV4dFNlbGVjdGlvbiB9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0TWFyazoge1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYSBtYXJrIHdpdGggbmV3IGF0dHJpYnV0ZXMuXG4gICAgICAgKi9cbiAgICAgIHNldE1hcms6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBNYXJrVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuU2V0TWFyayhzdGF0ZTogRWRpdG9yU3RhdGUsIHRyOiBUcmFuc2FjdGlvbiwgbmV3TWFya1R5cGU6IE1hcmtUeXBlKSB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICBsZXQgY3Vyc29yOiBSZXNvbHZlZFBvcyB8IG51bGwgPSBudWxsXG5cbiAgaWYgKGlzVGV4dFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY3Vyc29yID0gc2VsZWN0aW9uLiRjdXJzb3JcbiAgfVxuXG4gIGlmIChjdXJzb3IpIHtcbiAgICBjb25zdCBjdXJyZW50TWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyA/PyBjdXJzb3IubWFya3MoKVxuXG4gICAgLy8gVGhlcmUgY2FuIGJlIG5vIGN1cnJlbnQgbWFya3MgdGhhdCBleGNsdWRlIHRoZSBuZXcgbWFya1xuICAgIHJldHVybiAoXG4gICAgICAhIW5ld01hcmtUeXBlLmlzSW5TZXQoY3VycmVudE1hcmtzKVxuICAgICAgfHwgIWN1cnJlbnRNYXJrcy5zb21lKG1hcmsgPT4gbWFyay50eXBlLmV4Y2x1ZGVzKG5ld01hcmtUeXBlKSlcbiAgICApXG4gIH1cblxuICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uXG5cbiAgcmV0dXJuIHJhbmdlcy5zb21lKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIGxldCBzb21lTm9kZVN1cHBvcnRzTWFyayA9ICRmcm9tLmRlcHRoID09PSAwXG4gICAgICA/IHN0YXRlLmRvYy5pbmxpbmVDb250ZW50ICYmIHN0YXRlLmRvYy50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKVxuICAgICAgOiBmYWxzZVxuXG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIChub2RlLCBfcG9zLCBwYXJlbnQpID0+IHtcbiAgICAgIC8vIElmIHdlIGFscmVhZHkgZm91bmQgYSBtYXJrIHRoYXQgd2UgY2FuIGVuYWJsZSwgcmV0dXJuIGZhbHNlIHRvIGJ5cGFzcyB0aGUgcmVtYWluaW5nIHNlYXJjaFxuICAgICAgaWYgKHNvbWVOb2RlU3VwcG9ydHNNYXJrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5pc0lubGluZSkge1xuICAgICAgICBjb25zdCBwYXJlbnRBbGxvd3NNYXJrVHlwZSA9ICFwYXJlbnQgfHwgcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUobmV3TWFya1R5cGUpXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNYXJrc0FsbG93TWFya1R5cGUgPSAhIW5ld01hcmtUeXBlLmlzSW5TZXQobm9kZS5tYXJrcylcbiAgICAgICAgICB8fCAhbm9kZS5tYXJrcy5zb21lKG90aGVyTWFyayA9PiBvdGhlck1hcmsudHlwZS5leGNsdWRlcyhuZXdNYXJrVHlwZSkpXG5cbiAgICAgICAgc29tZU5vZGVTdXBwb3J0c01hcmsgPSBwYXJlbnRBbGxvd3NNYXJrVHlwZSAmJiBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlXG4gICAgICB9XG4gICAgICByZXR1cm4gIXNvbWVOb2RlU3VwcG9ydHNNYXJrXG4gICAgfSlcblxuICAgIHJldHVybiBzb21lTm9kZVN1cHBvcnRzTWFya1xuICB9KVxufVxuZXhwb3J0IGNvbnN0IHNldE1hcms6IFJhd0NvbW1hbmRzWydzZXRNYXJrJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uXG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHR5cGUpXG5cbiAgICAgIHRyLmFkZFN0b3JlZE1hcmsoXG4gICAgICAgIHR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAuLi5vbGRBdHRyaWJ1dGVzLFxuICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICAgIGNvbnN0IGZyb20gPSByYW5nZS4kZnJvbS5wb3NcbiAgICAgICAgY29uc3QgdG8gPSByYW5nZS4kdG8ucG9zXG5cbiAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCBmcm9tKVxuICAgICAgICAgIGNvbnN0IHRyaW1tZWRUbyA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKVxuICAgICAgICAgIGNvbnN0IHNvbWVIYXNNYXJrID0gbm9kZS5tYXJrcy5maW5kKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKVxuXG4gICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYWxyZWFkeSBhIG1hcmsgb2YgdGhpcyB0eXBlXG4gICAgICAgICAgLy8gd2Uga25vdyB0aGF0IHdlIGhhdmUgdG8gbWVyZ2UgaXRzIGF0dHJpYnV0ZXNcbiAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgYWRkIGEgZnJlc2ggbmV3IG1hcmtcbiAgICAgICAgICBpZiAoc29tZUhhc01hcmspIHtcbiAgICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaChtYXJrID0+IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgICB0cmltbWVkRnJvbSxcbiAgICAgICAgICAgICAgICAgIHRyaW1tZWRUbyxcbiAgICAgICAgICAgICAgICAgIHR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubWFyay5hdHRycyxcbiAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHIuYWRkTWFyayh0cmltbWVkRnJvbSwgdHJpbW1lZFRvLCB0eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYW5TZXRNYXJrKHN0YXRlLCB0ciwgdHlwZSlcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0TWV0YToge1xuICAgICAgLyoqXG4gICAgICAgKiBTdG9yZSBhIG1ldGFkYXRhIHByb3BlcnR5IGluIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLlxuICAgICAgICovXG4gICAgICBzZXRNZXRhOiAoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZXRNZXRhOiBSYXdDb21tYW5kc1snc2V0TWV0YSddID0gKGtleSwgdmFsdWUpID0+ICh7IHRyIH0pID0+IHtcbiAgdHIuc2V0TWV0YShrZXksIHZhbHVlKVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgc2V0QmxvY2tUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcbmltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldE5vZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVwbGFjZSBhIGdpdmVuIHJhbmdlIHdpdGggYSBub2RlLlxuICAgICAgICovXG4gICAgICBzZXROb2RlOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZXROb2RlOiBSYXdDb21tYW5kc1snc2V0Tm9kZSddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCBjaGFpbiB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgLy8gVE9ETzogdXNlIGEgZmFsbGJhY2sgbGlrZSBpbnNlcnRDb250ZW50P1xuICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spIHtcbiAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IEN1cnJlbnRseSBcInNldE5vZGUoKVwiIG9ubHkgc3VwcG9ydHMgdGV4dCBibG9jayBub2Rlcy4nKVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gKFxuICAgIGNoYWluKClcbiAgICAvLyB0cnkgdG8gY29udmVydCBub2RlIHRvIGRlZmF1bHQgbm9kZSBpZiBuZWVkZWRcbiAgICAgIC5jb21tYW5kKCh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgY29uc3QgY2FuU2V0QmxvY2sgPSBzZXRCbG9ja1R5cGUodHlwZSwgYXR0cmlidXRlcykoc3RhdGUpXG5cbiAgICAgICAgaWYgKGNhblNldEJsb2NrKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKClcbiAgICAgIH0pXG4gICAgICAuY29tbWFuZCgoeyBzdGF0ZTogdXBkYXRlZFN0YXRlIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHNldEJsb2NrVHlwZSh0eXBlLCBhdHRyaWJ1dGVzKSh1cGRhdGVkU3RhdGUsIGRpc3BhdGNoKVxuICAgICAgfSlcbiAgICAgIC5ydW4oKVxuICApXG59XG4iLCAiaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBtaW5NYXggfSBmcm9tICcuLi91dGlsaXRpZXMvbWluTWF4LmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0Tm9kZVNlbGVjdGlvbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgTm9kZVNlbGVjdGlvbi5cbiAgICAgICAqL1xuICAgICAgc2V0Tm9kZVNlbGVjdGlvbjogKHBvc2l0aW9uOiBudW1iZXIpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldE5vZGVTZWxlY3Rpb246IFJhd0NvbW1hbmRzWydzZXROb2RlU2VsZWN0aW9uJ10gPSBwb3NpdGlvbiA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCB7IGRvYyB9ID0gdHJcbiAgICBjb25zdCBmcm9tID0gbWluTWF4KHBvc2l0aW9uLCAwLCBkb2MuY29udGVudC5zaXplKVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKGRvYywgZnJvbSlcblxuICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBSYW5nZSwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG1pbk1heCB9IGZyb20gJy4uL3V0aWxpdGllcy9taW5NYXguanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXRUZXh0U2VsZWN0aW9uOiB7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBUZXh0U2VsZWN0aW9uLlxuICAgICAgICovXG4gICAgICBzZXRUZXh0U2VsZWN0aW9uOiAocG9zaXRpb246IG51bWJlciB8IFJhbmdlKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZXRUZXh0U2VsZWN0aW9uOiBSYXdDb21tYW5kc1snc2V0VGV4dFNlbGVjdGlvbiddID0gcG9zaXRpb24gPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgeyBkb2MgfSA9IHRyXG4gICAgY29uc3QgeyBmcm9tLCB0byB9ID0gdHlwZW9mIHBvc2l0aW9uID09PSAnbnVtYmVyJyA/IHsgZnJvbTogcG9zaXRpb24sIHRvOiBwb3NpdGlvbiB9IDogcG9zaXRpb25cbiAgICBjb25zdCBtaW5Qb3MgPSBUZXh0U2VsZWN0aW9uLmF0U3RhcnQoZG9jKS5mcm9tXG4gICAgY29uc3QgbWF4UG9zID0gVGV4dFNlbGVjdGlvbi5hdEVuZChkb2MpLnRvXG4gICAgY29uc3QgcmVzb2x2ZWRGcm9tID0gbWluTWF4KGZyb20sIG1pblBvcywgbWF4UG9zKVxuICAgIGNvbnN0IHJlc29sdmVkRW5kID0gbWluTWF4KHRvLCBtaW5Qb3MsIG1heFBvcylcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHJlc29sdmVkRnJvbSwgcmVzb2x2ZWRFbmQpXG5cbiAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBzaW5rTGlzdEl0ZW0gYXMgb3JpZ2luYWxTaW5rTGlzdEl0ZW0gfSBmcm9tICdAdGlwdGFwL3BtL3NjaGVtYS1saXN0J1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2lua0xpc3RJdGVtOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNpbmsgdGhlIGxpc3QgaXRlbSBkb3duIGludG8gYW4gaW5uZXIgbGlzdC5cbiAgICAgICAqL1xuICAgICAgc2lua0xpc3RJdGVtOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNpbmtMaXN0SXRlbTogUmF3Q29tbWFuZHNbJ3NpbmtMaXN0SXRlbSddID0gdHlwZU9yTmFtZSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIHJldHVybiBvcmlnaW5hbFNpbmtMaXN0SXRlbSh0eXBlKShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUsIE5vZGVTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgY2FuU3BsaXQgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgZGVmYXVsdEJsb2NrQXQgfSBmcm9tICcuLi9oZWxwZXJzL2RlZmF1bHRCbG9ja0F0LmpzJ1xuaW1wb3J0IHsgZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vaGVscGVycy9nZXRTcGxpdHRlZEF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5mdW5jdGlvbiBlbnN1cmVNYXJrcyhzdGF0ZTogRWRpdG9yU3RhdGUsIHNwbGl0dGFibGVNYXJrcz86IHN0cmluZ1tdKSB7XG4gIGNvbnN0IG1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgfHwgKHN0YXRlLnNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxuXG4gIGlmIChtYXJrcykge1xuICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3M/LmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSlcblxuICAgIHN0YXRlLnRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpXG4gIH1cbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNwbGl0QmxvY2s6IHtcbiAgICAgIC8qKlxuICAgICAgICogRm9ya3MgYSBuZXcgbm9kZSBmcm9tIGFuIGV4aXN0aW5nIG5vZGUuXG4gICAgICAgKi9cbiAgICAgIHNwbGl0QmxvY2s6IChvcHRpb25zPzogeyBrZWVwTWFya3M/OiBib29sZWFuIH0pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNwbGl0QmxvY2s6IFJhd0NvbW1hbmRzWydzcGxpdEJsb2NrJ10gPSAoeyBrZWVwTWFya3MgPSB0cnVlIH0gPSB7fSkgPT4gKHtcbiAgdHIsIHN0YXRlLCBkaXNwYXRjaCwgZWRpdG9yLFxufSkgPT4ge1xuICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSB0clxuICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHNlbGVjdGlvblxuICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuYXR0cmlidXRlc1xuICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKFxuICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMsXG4gICAgJGZyb20ubm9kZSgpLnR5cGUubmFtZSxcbiAgICAkZnJvbS5ub2RlKCkuYXR0cnMsXG4gIClcblxuICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzZWxlY3Rpb24ubm9kZS5pc0Jsb2NrKSB7XG4gICAgaWYgKCEkZnJvbS5wYXJlbnRPZmZzZXQgfHwgIWNhblNwbGl0KGRvYywgJGZyb20ucG9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBpZiAoa2VlcE1hcmtzKSB7XG4gICAgICAgIGVuc3VyZU1hcmtzKHN0YXRlLCBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5zcGxpdHRhYmxlTWFya3MpXG4gICAgICB9XG5cbiAgICAgIHRyLnNwbGl0KCRmcm9tLnBvcykuc2Nyb2xsSW50b1ZpZXcoKVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoISRmcm9tLnBhcmVudC5pc0Jsb2NrKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCBhdEVuZCA9ICR0by5wYXJlbnRPZmZzZXQgPT09ICR0by5wYXJlbnQuY29udGVudC5zaXplXG5cbiAgICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xuICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKClcbiAgICB9XG5cbiAgICBjb25zdCBkZWZsdCA9ICRmcm9tLmRlcHRoID09PSAwXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiBkZWZhdWx0QmxvY2tBdCgkZnJvbS5ub2RlKC0xKS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKC0xKSkpXG5cbiAgICBsZXQgdHlwZXMgPSBhdEVuZCAmJiBkZWZsdFxuICAgICAgPyBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBkZWZsdCxcbiAgICAgICAgICBhdHRyczogbmV3QXR0cmlidXRlcyxcbiAgICAgICAgfSxcbiAgICAgIF1cbiAgICAgIDogdW5kZWZpbmVkXG5cbiAgICBsZXQgY2FuID0gY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcylcblxuICAgIGlmIChcbiAgICAgICF0eXBlc1xuICAgICAgICAmJiAhY2FuXG4gICAgICAgICYmIGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgZGVmbHQgPyBbeyB0eXBlOiBkZWZsdCB9XSA6IHVuZGVmaW5lZClcbiAgICApIHtcbiAgICAgIGNhbiA9IHRydWVcbiAgICAgIHR5cGVzID0gZGVmbHRcbiAgICAgICAgPyBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogZGVmbHQsXG4gICAgICAgICAgICBhdHRyczogbmV3QXR0cmlidXRlcyxcbiAgICAgICAgICB9LFxuICAgICAgICBdXG4gICAgICAgIDogdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKGNhbikge1xuICAgICAgdHIuc3BsaXQodHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpXG5cbiAgICAgIGlmIChkZWZsdCAmJiAhYXRFbmQgJiYgISRmcm9tLnBhcmVudE9mZnNldCAmJiAkZnJvbS5wYXJlbnQudHlwZSAhPT0gZGVmbHQpIHtcbiAgICAgICAgY29uc3QgZmlyc3QgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSlcbiAgICAgICAgY29uc3QgJGZpcnN0ID0gdHIuZG9jLnJlc29sdmUoZmlyc3QpXG5cbiAgICAgICAgaWYgKCRmcm9tLm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRmaXJzdC5pbmRleCgpLCAkZmlyc3QuaW5kZXgoKSArIDEsIGRlZmx0KSkge1xuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLCBkZWZsdClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZWVwTWFya3MpIHtcbiAgICAgIGVuc3VyZU1hcmtzKHN0YXRlLCBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5zcGxpdHRhYmxlTWFya3MpXG4gICAgfVxuXG4gICAgdHIuc2Nyb2xsSW50b1ZpZXcoKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQge1xuICBGcmFnbWVudCwgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIE5vZGVUeXBlLCBTbGljZSxcbn0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgY2FuU3BsaXQgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vaGVscGVycy9nZXRTcGxpdHRlZEF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc3BsaXRMaXN0SXRlbToge1xuICAgICAgLyoqXG4gICAgICAgKiBTcGxpdHMgb25lIGxpc3QgaXRlbSBpbnRvIHR3byBsaXN0IGl0ZW1zLlxuICAgICAgICovXG4gICAgICBzcGxpdExpc3RJdGVtOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNwbGl0TGlzdEl0ZW06IFJhd0NvbW1hbmRzWydzcGxpdExpc3RJdGVtJ10gPSB0eXBlT3JOYW1lID0+ICh7XG4gIHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGVkaXRvcixcbn0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb25cblxuICAvLyBAdHMtaWdub3JlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGNvbnN0IG5vZGU6IFByb3NlTWlycm9yTm9kZSA9IHN0YXRlLnNlbGVjdGlvbi5ub2RlXG5cbiAgaWYgKChub2RlICYmIG5vZGUuaXNCbG9jaykgfHwgJGZyb20uZGVwdGggPCAyIHx8ICEkZnJvbS5zYW1lUGFyZW50KCR0bykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGdyYW5kUGFyZW50ID0gJGZyb20ubm9kZSgtMSlcblxuICBpZiAoZ3JhbmRQYXJlbnQudHlwZSAhPT0gdHlwZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXNcblxuICBpZiAoJGZyb20ucGFyZW50LmNvbnRlbnQuc2l6ZSA9PT0gMCAmJiAkZnJvbS5ub2RlKC0xKS5jaGlsZENvdW50ID09PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgIC8vIEluIGFuIGVtcHR5IGJsb2NrLiBJZiB0aGlzIGlzIGEgbmVzdGVkIGxpc3QsIHRoZSB3cmFwcGluZ1xuICAgIC8vIGxpc3QgaXRlbSBzaG91bGQgYmUgc3BsaXQuIE90aGVyd2lzZSwgYmFpbCBvdXQgYW5kIGxldCBuZXh0XG4gICAgLy8gY29tbWFuZCBoYW5kbGUgbGlmdGluZy5cbiAgICBpZiAoXG4gICAgICAkZnJvbS5kZXB0aCA9PT0gMlxuICAgICAgICB8fCAkZnJvbS5ub2RlKC0zKS50eXBlICE9PSB0eXBlXG4gICAgICAgIHx8ICRmcm9tLmluZGV4KC0yKSAhPT0gJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCAtIDFcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgbGV0IHdyYXAgPSBGcmFnbWVudC5lbXB0eVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGNvbnN0IGRlcHRoQmVmb3JlID0gJGZyb20uaW5kZXgoLTEpID8gMSA6ICRmcm9tLmluZGV4KC0yKSA/IDIgOiAzXG5cbiAgICAgIC8vIEJ1aWxkIGEgZnJhZ21lbnQgY29udGFpbmluZyBlbXB0eSB2ZXJzaW9ucyBvZiB0aGUgc3RydWN0dXJlXG4gICAgICAvLyBmcm9tIHRoZSBvdXRlciBsaXN0IGl0ZW0gdG8gdGhlIHBhcmVudCBub2RlIG9mIHRoZSBjdXJzb3JcbiAgICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCAtIGRlcHRoQmVmb3JlOyBkID49ICRmcm9tLmRlcHRoIC0gMzsgZCAtPSAxKSB7XG4gICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoZCkuY29weSh3cmFwKSlcbiAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGNvbnN0IGRlcHRoQWZ0ZXIgPSAkZnJvbS5pbmRleEFmdGVyKC0xKSA8ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgPyAxIDogJGZyb20uaW5kZXhBZnRlcigtMikgPCAkZnJvbS5ub2RlKC0zKS5jaGlsZENvdW50ID8gMiA6IDNcblxuICAgICAgLy8gQWRkIGEgc2Vjb25kIGxpc3QgaXRlbSB3aXRoIGFuIGVtcHR5IGRlZmF1bHQgc3RhcnQgbm9kZVxuICAgICAgY29uc3QgbmV3TmV4dFR5cGVBdHRyaWJ1dGVzID0gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKFxuICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLFxuICAgICAgICAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLFxuICAgICAgICAkZnJvbS5ub2RlKCkuYXR0cnMsXG4gICAgICApXG4gICAgICBjb25zdCBuZXh0VHlwZSA9IHR5cGUuY29udGVudE1hdGNoLmRlZmF1bHRUeXBlPy5jcmVhdGVBbmRGaWxsKG5ld05leHRUeXBlQXR0cmlidXRlcykgfHwgdW5kZWZpbmVkXG5cbiAgICAgIHdyYXAgPSB3cmFwLmFwcGVuZChGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlQW5kRmlsbChudWxsLCBuZXh0VHlwZSkgfHwgdW5kZWZpbmVkKSlcblxuICAgICAgY29uc3Qgc3RhcnQgPSAkZnJvbS5iZWZvcmUoJGZyb20uZGVwdGggLSAoZGVwdGhCZWZvcmUgLSAxKSlcblxuICAgICAgdHIucmVwbGFjZShzdGFydCwgJGZyb20uYWZ0ZXIoLWRlcHRoQWZ0ZXIpLCBuZXcgU2xpY2Uod3JhcCwgNCAtIGRlcHRoQmVmb3JlLCAwKSlcblxuICAgICAgbGV0IHNlbCA9IC0xXG5cbiAgICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oc3RhcnQsIHRyLmRvYy5jb250ZW50LnNpemUsIChuLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKHNlbCA+IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobi5pc1RleHRibG9jayAmJiBuLmNvbnRlbnQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHNlbCA9IHBvcyArIDFcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgaWYgKHNlbCA+IC0xKSB7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoc2VsKSkpXG4gICAgICB9XG5cbiAgICAgIHRyLnNjcm9sbEludG9WaWV3KClcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3QgbmV4dFR5cGUgPSAkdG8ucG9zID09PSAkZnJvbS5lbmQoKSA/IGdyYW5kUGFyZW50LmNvbnRlbnRNYXRjaEF0KDApLmRlZmF1bHRUeXBlIDogbnVsbFxuXG4gIGNvbnN0IG5ld1R5cGVBdHRyaWJ1dGVzID0gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKFxuICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMsXG4gICAgZ3JhbmRQYXJlbnQudHlwZS5uYW1lLFxuICAgIGdyYW5kUGFyZW50LmF0dHJzLFxuICApXG4gIGNvbnN0IG5ld05leHRUeXBlQXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhcbiAgICBleHRlbnNpb25BdHRyaWJ1dGVzLFxuICAgICRmcm9tLm5vZGUoKS50eXBlLm5hbWUsXG4gICAgJGZyb20ubm9kZSgpLmF0dHJzLFxuICApXG5cbiAgdHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcylcblxuICBjb25zdCB0eXBlcyA9IG5leHRUeXBlXG4gICAgPyBbXG4gICAgICB7IHR5cGUsIGF0dHJzOiBuZXdUeXBlQXR0cmlidXRlcyB9LFxuICAgICAgeyB0eXBlOiBuZXh0VHlwZSwgYXR0cnM6IG5ld05leHRUeXBlQXR0cmlidXRlcyB9LFxuICAgIF1cbiAgICA6IFt7IHR5cGUsIGF0dHJzOiBuZXdUeXBlQXR0cmlidXRlcyB9XVxuXG4gIGlmICghY2FuU3BsaXQodHIuZG9jLCAkZnJvbS5wb3MsIDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlXG4gICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyXG4gICAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrcyB8fCAoc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG5cbiAgICB0ci5zcGxpdCgkZnJvbS5wb3MsIDIsIHR5cGVzKS5zY3JvbGxJbnRvVmlldygpXG5cbiAgICBpZiAoIW1hcmtzIHx8ICFkaXNwYXRjaCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSlcblxuICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IGNhbkpvaW4gfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgZmluZFBhcmVudE5vZGUgfSBmcm9tICcuLi9oZWxwZXJzL2ZpbmRQYXJlbnROb2RlLmpzJ1xuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgaXNMaXN0IH0gZnJvbSAnLi4vaGVscGVycy9pc0xpc3QuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5jb25zdCBqb2luTGlzdEJhY2t3YXJkcyA9ICh0cjogVHJhbnNhY3Rpb24sIGxpc3RUeXBlOiBOb2RlVHlwZSk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBsaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUgPT09IGxpc3RUeXBlKSh0ci5zZWxlY3Rpb24pXG5cbiAgaWYgKCFsaXN0KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IGJlZm9yZSA9IHRyLmRvYy5yZXNvbHZlKE1hdGgubWF4KDAsIGxpc3QucG9zIC0gMSkpLmJlZm9yZShsaXN0LmRlcHRoKVxuXG4gIGlmIChiZWZvcmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBub2RlQmVmb3JlID0gdHIuZG9jLm5vZGVBdChiZWZvcmUpXG4gIGNvbnN0IGNhbkpvaW5CYWNrd2FyZHMgPSBsaXN0Lm5vZGUudHlwZSA9PT0gbm9kZUJlZm9yZT8udHlwZSAmJiBjYW5Kb2luKHRyLmRvYywgbGlzdC5wb3MpXG5cbiAgaWYgKCFjYW5Kb2luQmFja3dhcmRzKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHRyLmpvaW4obGlzdC5wb3MpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuY29uc3Qgam9pbkxpc3RGb3J3YXJkcyA9ICh0cjogVHJhbnNhY3Rpb24sIGxpc3RUeXBlOiBOb2RlVHlwZSk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBsaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUgPT09IGxpc3RUeXBlKSh0ci5zZWxlY3Rpb24pXG5cbiAgaWYgKCFsaXN0KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IGFmdGVyID0gdHIuZG9jLnJlc29sdmUobGlzdC5zdGFydCkuYWZ0ZXIobGlzdC5kZXB0aClcblxuICBpZiAoYWZ0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBub2RlQWZ0ZXIgPSB0ci5kb2Mubm9kZUF0KGFmdGVyKVxuICBjb25zdCBjYW5Kb2luRm9yd2FyZHMgPSBsaXN0Lm5vZGUudHlwZSA9PT0gbm9kZUFmdGVyPy50eXBlICYmIGNhbkpvaW4odHIuZG9jLCBhZnRlcilcblxuICBpZiAoIWNhbkpvaW5Gb3J3YXJkcykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB0ci5qb2luKGFmdGVyKVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0b2dnbGVMaXN0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBsaXN0IHR5cGVzLlxuICAgICAgICovXG4gICAgICB0b2dnbGVMaXN0OiAobGlzdFR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBpdGVtVHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIGtlZXBNYXJrcz86IGJvb2xlYW4sIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdG9nZ2xlTGlzdDogUmF3Q29tbWFuZHNbJ3RvZ2dsZUxpc3QnXSA9IChsaXN0VHlwZU9yTmFtZSwgaXRlbVR5cGVPck5hbWUsIGtlZXBNYXJrcywgYXR0cmlidXRlcyA9IHt9KSA9PiAoe1xuICBlZGl0b3IsIHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGNoYWluLCBjb21tYW5kcywgY2FuLFxufSkgPT4ge1xuICBjb25zdCB7IGV4dGVuc2lvbnMsIHNwbGl0dGFibGVNYXJrcyB9ID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXJcbiAgY29uc3QgbGlzdFR5cGUgPSBnZXROb2RlVHlwZShsaXN0VHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCBpdGVtVHlwZSA9IGdldE5vZGVUeXBlKGl0ZW1UeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGVcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb25cbiAgY29uc3QgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bylcblxuICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcblxuICBpZiAoIXJhbmdlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBwYXJlbnRMaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBpc0xpc3Qobm9kZS50eXBlLm5hbWUsIGV4dGVuc2lvbnMpKShzZWxlY3Rpb24pXG5cbiAgaWYgKHJhbmdlLmRlcHRoID49IDEgJiYgcGFyZW50TGlzdCAmJiByYW5nZS5kZXB0aCAtIHBhcmVudExpc3QuZGVwdGggPD0gMSkge1xuICAgIC8vIHJlbW92ZSBsaXN0XG4gICAgaWYgKHBhcmVudExpc3Qubm9kZS50eXBlID09PSBsaXN0VHlwZSkge1xuICAgICAgcmV0dXJuIGNvbW1hbmRzLmxpZnRMaXN0SXRlbShpdGVtVHlwZSlcbiAgICB9XG5cbiAgICAvLyBjaGFuZ2UgbGlzdCB0eXBlXG4gICAgaWYgKFxuICAgICAgaXNMaXN0KHBhcmVudExpc3Qubm9kZS50eXBlLm5hbWUsIGV4dGVuc2lvbnMpXG4gICAgICAgICYmIGxpc3RUeXBlLnZhbGlkQ29udGVudChwYXJlbnRMaXN0Lm5vZGUuY29udGVudClcbiAgICAgICAgJiYgZGlzcGF0Y2hcbiAgICApIHtcbiAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgIC5jb21tYW5kKCgpID0+IHtcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBhcmVudExpc3QucG9zLCBsaXN0VHlwZSlcblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0pXG4gICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgICAgLnJ1bigpXG4gICAgfVxuICB9XG4gIGlmICgha2VlcE1hcmtzIHx8ICFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcblxuICAgIHJldHVybiBjaGFpbigpXG4gICAgICAvLyB0cnkgdG8gY29udmVydCBub2RlIHRvIGRlZmF1bHQgbm9kZSBpZiBuZWVkZWRcbiAgICAgIC5jb21tYW5kKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2FuV3JhcEluTGlzdCA9IGNhbigpLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgICAgICAgaWYgKGNhbldyYXBJbkxpc3QpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuICAgICAgfSlcbiAgICAgIC53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgIC5ydW4oKVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICBjaGFpbigpXG4gICAgLy8gdHJ5IHRvIGNvbnZlcnQgbm9kZSB0byBkZWZhdWx0IG5vZGUgaWYgbmVlZGVkXG4gICAgICAuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbldyYXBJbkxpc3QgPSBjYW4oKS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKVxuXG4gICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpXG5cbiAgICAgICAgaWYgKGNhbldyYXBJbkxpc3QpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuICAgICAgfSlcbiAgICAgIC53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgIC5ydW4oKVxuICApXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBpc01hcmtBY3RpdmUgfSBmcm9tICcuLi9oZWxwZXJzL2lzTWFya0FjdGl2ZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0b2dnbGVNYXJrOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIG1hcmsgb24gYW5kIG9mZi5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlTWFyazogKFxuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBNYXJrVHlwZSxcbiAgICAgICAgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUmVtb3ZlcyB0aGUgbWFyayBldmVuIGFjcm9zcyB0aGUgY3VycmVudCBzZWxlY3Rpb24uIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgICAgICovXG4gICAgICAgICAgZXh0ZW5kRW1wdHlNYXJrUmFuZ2U/OiBib29sZWFuXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvZ2dsZU1hcms6IFJhd0NvbW1hbmRzWyd0b2dnbGVNYXJrJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9LCBvcHRpb25zID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gIGNvbnN0IHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgPSBmYWxzZSB9ID0gb3B0aW9uc1xuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCBpc0FjdGl2ZSA9IGlzTWFya0FjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcylcblxuICBpZiAoaXNBY3RpdmUpIHtcbiAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHR5cGUsIHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgfSlcbiAgfVxuXG4gIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHR5cGUsIGF0dHJpYnV0ZXMpXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBpc05vZGVBY3RpdmUgfSBmcm9tICcuLi9oZWxwZXJzL2lzTm9kZUFjdGl2ZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0b2dnbGVOb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIG5vZGUgd2l0aCBhbm90aGVyIG5vZGUuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZU5vZGU6IChcbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsXG4gICAgICAgIHRvZ2dsZVR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLFxuICAgICAgICBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdG9nZ2xlTm9kZTogUmF3Q29tbWFuZHNbJ3RvZ2dsZU5vZGUnXSA9ICh0eXBlT3JOYW1lLCB0b2dnbGVUeXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHRvZ2dsZVR5cGUgPSBnZXROb2RlVHlwZSh0b2dnbGVUeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gIGlmIChpc0FjdGl2ZSkge1xuICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRvZ2dsZVR5cGUpXG4gIH1cblxuICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0eXBlLCBhdHRyaWJ1dGVzKVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgaXNOb2RlQWN0aXZlIH0gZnJvbSAnLi4vaGVscGVycy9pc05vZGVBY3RpdmUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdG9nZ2xlV3JhcDoge1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwcyBub2RlcyBpbiBhbm90aGVyIG5vZGUsIG9yIHJlbW92ZXMgYW4gZXhpc3Rpbmcgd3JhcC5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlV3JhcDogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdG9nZ2xlV3JhcDogUmF3Q29tbWFuZHNbJ3RvZ2dsZVdyYXAnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gIGlmIChpc0FjdGl2ZSkge1xuICAgIHJldHVybiBjb21tYW5kcy5saWZ0KHR5cGUpXG4gIH1cblxuICByZXR1cm4gY29tbWFuZHMud3JhcEluKHR5cGUsIGF0dHJpYnV0ZXMpXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVuZG9JbnB1dFJ1bGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogVW5kbyBhbiBpbnB1dCBydWxlLlxuICAgICAgICovXG4gICAgICB1bmRvSW5wdXRSdWxlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdW5kb0lucHV0UnVsZTogUmF3Q29tbWFuZHNbJ3VuZG9JbnB1dFJ1bGUnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHBsdWdpbnMgPSBzdGF0ZS5wbHVnaW5zXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXVxuICAgIGxldCB1bmRvYWJsZVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGlmIChwbHVnaW4uc3BlYy5pc0lucHV0UnVsZXMgJiYgKHVuZG9hYmxlID0gcGx1Z2luLmdldFN0YXRlKHN0YXRlKSkpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCB0ciA9IHN0YXRlLnRyXG4gICAgICAgIGNvbnN0IHRvVW5kbyA9IHVuZG9hYmxlLnRyYW5zZm9ybVxuXG4gICAgICAgIGZvciAobGV0IGogPSB0b1VuZG8uc3RlcHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqIC09IDEpIHtcbiAgICAgICAgICB0ci5zdGVwKHRvVW5kby5zdGVwc1tqXS5pbnZlcnQodG9VbmRvLmRvY3Nbal0pKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVuZG9hYmxlLnRleHQpIHtcbiAgICAgICAgICBjb25zdCBtYXJrcyA9IHRyLmRvYy5yZXNvbHZlKHVuZG9hYmxlLmZyb20pLm1hcmtzKClcblxuICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvLCBzdGF0ZS5zY2hlbWEudGV4dCh1bmRvYWJsZS50ZXh0LCBtYXJrcykpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVuc2V0QWxsTWFya3M6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIGFsbCBtYXJrcyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIHVuc2V0QWxsTWFya3M6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1bnNldEFsbE1hcmtzOiBSYXdDb21tYW5kc1sndW5zZXRBbGxNYXJrcyddID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uXG5cbiAgaWYgKGVtcHR5KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya1JhbmdlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrUmFuZ2UuanMnXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdW5zZXRNYXJrOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhbGwgbWFya3MgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICovXG4gICAgICB1bnNldE1hcms6IChcbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTWFya1R5cGUsXG4gICAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUmVtb3ZlcyB0aGUgbWFyayBldmVuIGFjcm9zcyB0aGUgY3VycmVudCBzZWxlY3Rpb24uIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgICAgICovXG4gICAgICAgICAgZXh0ZW5kRW1wdHlNYXJrUmFuZ2U/OiBib29sZWFuXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVuc2V0TWFyazogUmF3Q29tbWFuZHNbJ3Vuc2V0TWFyayddID0gKHR5cGVPck5hbWUsIG9wdGlvbnMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgPSBmYWxzZSB9ID0gb3B0aW9uc1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJcbiAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgeyAkZnJvbSwgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uXG5cbiAgaWYgKCFkaXNwYXRjaCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoZW1wdHkgJiYgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UpIHtcbiAgICBsZXQgeyBmcm9tLCB0byB9ID0gc2VsZWN0aW9uXG4gICAgY29uc3QgYXR0cnMgPSAkZnJvbS5tYXJrcygpLmZpbmQobWFyayA9PiBtYXJrLnR5cGUgPT09IHR5cGUpPy5hdHRyc1xuICAgIGNvbnN0IHJhbmdlID0gZ2V0TWFya1JhbmdlKCRmcm9tLCB0eXBlLCBhdHRycylcblxuICAgIGlmIChyYW5nZSkge1xuICAgICAgZnJvbSA9IHJhbmdlLmZyb21cbiAgICAgIHRvID0gcmFuZ2UudG9cbiAgICB9XG5cbiAgICB0ci5yZW1vdmVNYXJrKGZyb20sIHRvLCB0eXBlKVxuICB9IGVsc2Uge1xuICAgIHJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zLCB0eXBlKVxuICAgIH0pXG4gIH1cblxuICB0ci5yZW1vdmVTdG9yZWRNYXJrKHR5cGUpXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdXBkYXRlQXR0cmlidXRlczoge1xuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGUgYXR0cmlidXRlcyBvZiBhIG5vZGUgb3IgbWFyay5cbiAgICAgICAqL1xuICAgICAgdXBkYXRlQXR0cmlidXRlczogKFxuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSB8IE1hcmtUeXBlLFxuICAgICAgICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVBdHRyaWJ1dGVzOiBSYXdDb21tYW5kc1sndXBkYXRlQXR0cmlidXRlcyddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGxldCBub2RlVHlwZTogTm9kZVR5cGUgfCBudWxsID0gbnVsbFxuICBsZXQgbWFya1R5cGU6IE1hcmtUeXBlIHwgbnVsbCA9IG51bGxcblxuICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUoXG4gICAgdHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSxcbiAgICBzdGF0ZS5zY2hlbWEsXG4gIClcblxuICBpZiAoIXNjaGVtYVR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICBub2RlVHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUgYXMgTm9kZVR5cGUsIHN0YXRlLnNjaGVtYSlcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICBtYXJrVHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUgYXMgTWFya1R5cGUsIHN0YXRlLnNjaGVtYSlcbiAgfVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLnNlbGVjdGlvbi5yYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICBjb25zdCBmcm9tID0gcmFuZ2UuJGZyb20ucG9zXG4gICAgICBjb25zdCB0byA9IHJhbmdlLiR0by5wb3NcblxuICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIC4uLm5vZGUuYXR0cnMsXG4gICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFya1R5cGUgJiYgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICBpZiAobWFya1R5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICBjb25zdCB0cmltbWVkRnJvbSA9IE1hdGgubWF4KHBvcywgZnJvbSlcbiAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFRvID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pXG5cbiAgICAgICAgICAgICAgdHIuYWRkTWFyayhcbiAgICAgICAgICAgICAgICB0cmltbWVkRnJvbSxcbiAgICAgICAgICAgICAgICB0cmltbWVkVG8sXG4gICAgICAgICAgICAgICAgbWFya1R5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyB3cmFwSW4gYXMgb3JpZ2luYWxXcmFwSW4gfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgd3JhcEluOiB7XG4gICAgICAvKipcbiAgICAgICAqIFdyYXBzIG5vZGVzIGluIGFub3RoZXIgbm9kZS5cbiAgICAgICAqL1xuICAgICAgd3JhcEluOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3cmFwSW46IFJhd0NvbW1hbmRzWyd3cmFwSW4nXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgcmV0dXJuIG9yaWdpbmFsV3JhcEluKHR5cGUsIGF0dHJpYnV0ZXMpKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyB3cmFwSW5MaXN0IGFzIG9yaWdpbmFsV3JhcEluTGlzdCB9IGZyb20gJ0B0aXB0YXAvcG0vc2NoZW1hLWxpc3QnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB3cmFwSW5MaXN0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFdyYXAgYSBub2RlIGluIGEgbGlzdC5cbiAgICAgICAqL1xuICAgICAgd3JhcEluTGlzdDogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgd3JhcEluTGlzdDogUmF3Q29tbWFuZHNbJ3dyYXBJbkxpc3QnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgcmV0dXJuIG9yaWdpbmFsV3JhcEluTGlzdCh0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0ICogYXMgY29tbWFuZHMgZnJvbSAnLi4vY29tbWFuZHMvaW5kZXguanMnXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5cbmV4cG9ydCAqIGZyb20gJy4uL2NvbW1hbmRzL2luZGV4LmpzJ1xuXG5leHBvcnQgY29uc3QgQ29tbWFuZHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogJ2NvbW1hbmRzJyxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29tbWFuZHMsXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcblxuZXhwb3J0IGNvbnN0IEVkaXRhYmxlID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdlZGl0YWJsZScsXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdlZGl0YWJsZScpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGVkaXRhYmxlOiAoKSA9PiB0aGlzLmVkaXRvci5vcHRpb25zLmVkaXRhYmxlLFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcblxuZXhwb3J0IGNvbnN0IEZvY3VzRXZlbnRzID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdmb2N1c0V2ZW50cycsXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzXG5cbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnZm9jdXNFdmVudHMnKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgIGZvY3VzOiAodmlldywgZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGVkaXRvci5pc0ZvY3VzZWQgPSB0cnVlXG5cbiAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBlZGl0b3Iuc3RhdGUudHJcbiAgICAgICAgICAgICAgICAuc2V0TWV0YSgnZm9jdXMnLCB7IGV2ZW50IH0pXG4gICAgICAgICAgICAgICAgLnNldE1ldGEoJ2FkZFRvSGlzdG9yeScsIGZhbHNlKVxuXG4gICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pXG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmx1cjogKHZpZXcsIGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgICBlZGl0b3IuaXNGb2N1c2VkID0gZmFsc2VcblxuICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGVkaXRvci5zdGF0ZS50clxuICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdibHVyJywgeyBldmVudCB9KVxuICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdhZGRUb0hpc3RvcnknLCBmYWxzZSlcblxuICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKVxuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSwgU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgQ29tbWFuZE1hbmFnZXIgfSBmcm9tICcuLi9Db21tYW5kTWFuYWdlci5qcydcbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcbmltcG9ydCB7IGNyZWF0ZUNoYWluYWJsZVN0YXRlIH0gZnJvbSAnLi4vaGVscGVycy9jcmVhdGVDaGFpbmFibGVTdGF0ZS5qcydcbmltcG9ydCB7IGlzaU9TIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2lzaU9TLmpzJ1xuaW1wb3J0IHsgaXNNYWNPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc01hY09TLmpzJ1xuXG5leHBvcnQgY29uc3QgS2V5bWFwID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdrZXltYXAnLFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIGNvbnN0IGhhbmRsZUJhY2tzcGFjZSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICgpID0+IGNvbW1hbmRzLnVuZG9JbnB1dFJ1bGUoKSxcblxuICAgICAgLy8gbWF5YmUgY29udmVydCBmaXJzdCB0ZXh0IGJsb2NrIG5vZGUgdG8gZGVmYXVsdCBub2RlXG4gICAgICAoKSA9PiBjb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHJcbiAgICAgICAgY29uc3QgeyBlbXB0eSwgJGFuY2hvciB9ID0gc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHsgcG9zLCBwYXJlbnQgfSA9ICRhbmNob3JcbiAgICAgICAgY29uc3QgJHBhcmVudFBvcyA9ICRhbmNob3IucGFyZW50LmlzVGV4dGJsb2NrID8gdHIuZG9jLnJlc29sdmUocG9zIC0gMSkgOiAkYW5jaG9yXG4gICAgICAgIGNvbnN0IHBhcmVudElzSXNvbGF0aW5nID0gJHBhcmVudFBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZ1xuXG4gICAgICAgIGNvbnN0IHBhcmVudFBvcyA9ICRhbmNob3IucG9zIC0gJGFuY2hvci5wYXJlbnRPZmZzZXRcblxuICAgICAgICBjb25zdCBpc0F0U3RhcnQgPSAocGFyZW50SXNJc29sYXRpbmcgJiYgJHBhcmVudFBvcy5wYXJlbnQuY2hpbGRDb3VudCA9PT0gMSlcbiAgICAgICAgICA/IHBhcmVudFBvcyA9PT0gJGFuY2hvci5wb3NcbiAgICAgICAgICA6IFNlbGVjdGlvbi5hdFN0YXJ0KGRvYykuZnJvbSA9PT0gcG9zXG5cbiAgICAgICAgaWYgKCFlbXB0eSB8fCAhaXNBdFN0YXJ0IHx8ICFwYXJlbnQudHlwZS5pc1RleHRibG9jayB8fCBwYXJlbnQudGV4dENvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpXG4gICAgICB9KSxcblxuICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlU2VsZWN0aW9uKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5qb2luQmFja3dhcmQoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLnNlbGVjdE5vZGVCYWNrd2FyZCgpLFxuICAgIF0pXG5cbiAgICBjb25zdCBoYW5kbGVEZWxldGUgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAoKSA9PiBjb21tYW5kcy5kZWxldGVTZWxlY3Rpb24oKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZUN1cnJlbnROb2RlKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5qb2luRm9yd2FyZCgpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuc2VsZWN0Tm9kZUZvcndhcmQoKSxcbiAgICBdKVxuXG4gICAgY29uc3QgaGFuZGxlRW50ZXIgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAoKSA9PiBjb21tYW5kcy5uZXdsaW5lSW5Db2RlKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5jcmVhdGVQYXJhZ3JhcGhOZWFyKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5saWZ0RW1wdHlCbG9jaygpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuc3BsaXRCbG9jaygpLFxuICAgIF0pXG5cbiAgICBjb25zdCBiYXNlS2V5bWFwID0ge1xuICAgICAgRW50ZXI6IGhhbmRsZUVudGVyLFxuICAgICAgJ01vZC1FbnRlcic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmV4aXRDb2RlKCksXG4gICAgICBCYWNrc3BhY2U6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICdNb2QtQmFja3NwYWNlJzogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgJ1NoaWZ0LUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgIERlbGV0ZTogaGFuZGxlRGVsZXRlLFxuICAgICAgJ01vZC1EZWxldGUnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnTW9kLWEnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RBbGwoKSxcbiAgICB9XG5cbiAgICBjb25zdCBwY0tleW1hcCA9IHtcbiAgICAgIC4uLmJhc2VLZXltYXAsXG4gICAgfVxuXG4gICAgY29uc3QgbWFjS2V5bWFwID0ge1xuICAgICAgLi4uYmFzZUtleW1hcCxcbiAgICAgICdDdHJsLWgnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAnQWx0LUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICdDdHJsLWQnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnQ3RybC1BbHQtQmFja3NwYWNlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ0FsdC1EZWxldGUnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnQWx0LWQnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnQ3RybC1hJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrU3RhcnQoKSxcbiAgICAgICdDdHJsLWUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RUZXh0YmxvY2tFbmQoKSxcbiAgICB9XG5cbiAgICBpZiAoaXNpT1MoKSB8fCBpc01hY09TKCkpIHtcbiAgICAgIHJldHVybiBtYWNLZXltYXBcbiAgICB9XG5cbiAgICByZXR1cm4gcGNLZXltYXBcbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIFdpdGggdGhpcyBwbHVnaW4gd2UgY2hlY2sgaWYgdGhlIHdob2xlIGRvY3VtZW50IHdhcyBzZWxlY3RlZCBhbmQgZGVsZXRlZC5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSB3aWxsIGFkZGl0aW9uYWxseSBjYWxsIGBjbGVhck5vZGVzKClgIHRvIGNvbnZlcnQgZS5nLiBhIGhlYWRpbmdcbiAgICAgIC8vIHRvIGEgcGFyYWdyYXBoIGlmIG5lY2Vzc2FyeS5cbiAgICAgIC8vIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gUHJvc2VNaXJyb3IncyBgQWxsU2VsZWN0aW9uYCwgd2hpY2ggZG9lc27igJl0IHdvcmsgd2VsbFxuICAgICAgLy8gd2l0aCBtYW55IG90aGVyIGNvbW1hbmRzLlxuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnY2xlYXJEb2N1bWVudCcpLFxuICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHRyYW5zYWN0aW9ucywgb2xkU3RhdGUsIG5ld1N0YXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZG9jQ2hhbmdlcyA9IHRyYW5zYWN0aW9ucy5zb21lKHRyYW5zYWN0aW9uID0+IHRyYW5zYWN0aW9uLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICAmJiAhb2xkU3RhdGUuZG9jLmVxKG5ld1N0YXRlLmRvYylcblxuICAgICAgICAgIGlmICghZG9jQ2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBlbXB0eSwgZnJvbSwgdG8gfSA9IG9sZFN0YXRlLnNlbGVjdGlvblxuICAgICAgICAgIGNvbnN0IGFsbEZyb20gPSBTZWxlY3Rpb24uYXRTdGFydChvbGRTdGF0ZS5kb2MpLmZyb21cbiAgICAgICAgICBjb25zdCBhbGxFbmQgPSBTZWxlY3Rpb24uYXRFbmQob2xkU3RhdGUuZG9jKS50b1xuICAgICAgICAgIGNvbnN0IGFsbFdhc1NlbGVjdGVkID0gZnJvbSA9PT0gYWxsRnJvbSAmJiB0byA9PT0gYWxsRW5kXG5cbiAgICAgICAgICBpZiAoZW1wdHkgfHwgIWFsbFdhc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpc0VtcHR5ID0gbmV3U3RhdGUuZG9jLnRleHRCZXR3ZWVuKDAsIG5ld1N0YXRlLmRvYy5jb250ZW50LnNpemUsICcgJywgJyAnKS5sZW5ndGggPT09IDBcblxuICAgICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdHIgPSBuZXdTdGF0ZS50clxuICAgICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgY29uc3QgeyBjb21tYW5kcyB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgY29tbWFuZHMuY2xlYXJOb2RlcygpXG5cbiAgICAgICAgICBpZiAoIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRyXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuXG5leHBvcnQgY29uc3QgVGFiaW5kZXggPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogJ3RhYmluZGV4JyxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ3RhYmluZGV4JyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgYXR0cmlidXRlczogdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSA/IHsgdGFiaW5kZXg6ICcwJyB9IDoge30sXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7XG4gIEZyYWdtZW50LCBOb2RlLCBSZXNvbHZlZFBvcyxcbn0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBDb250ZW50LCBSYW5nZSB9IGZyb20gJy4vdHlwZXMuanMnXG5cbmV4cG9ydCBjbGFzcyBOb2RlUG9zIHtcbiAgcHJpdmF0ZSByZXNvbHZlZFBvczogUmVzb2x2ZWRQb3NcblxuICBwcml2YXRlIGlzQmxvY2s6IGJvb2xlYW5cblxuICBwcml2YXRlIGVkaXRvcjogRWRpdG9yXG5cbiAgcHJpdmF0ZSBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm5vZGUudHlwZS5uYW1lXG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwb3M6IFJlc29sdmVkUG9zLCBlZGl0b3I6IEVkaXRvciwgaXNCbG9jayA9IGZhbHNlLCBub2RlOiBOb2RlIHwgbnVsbCA9IG51bGwpIHtcbiAgICB0aGlzLmlzQmxvY2sgPSBpc0Jsb2NrXG4gICAgdGhpcy5yZXNvbHZlZFBvcyA9IHBvc1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGVcbiAgfVxuXG4gIHByaXZhdGUgY3VycmVudE5vZGU6IE5vZGUgfCBudWxsID0gbnVsbFxuXG4gIGdldCBub2RlKCk6IE5vZGUge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnROb2RlIHx8IHRoaXMucmVzb2x2ZWRQb3Mubm9kZSgpXG4gIH1cblxuICBnZXQgZWxlbWVudCgpOiBIVE1MRWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tQXRQb3ModGhpcy5wb3MpLm5vZGUgYXMgSFRNTEVsZW1lbnRcbiAgfVxuXG4gIHB1YmxpYyBhY3R1YWxEZXB0aDogbnVtYmVyIHwgbnVsbCA9IG51bGxcblxuICBnZXQgZGVwdGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5hY3R1YWxEZXB0aCA/PyB0aGlzLnJlc29sdmVkUG9zLmRlcHRoXG4gIH1cblxuICBnZXQgcG9zKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRQb3MucG9zXG4gIH1cblxuICBnZXQgY29udGVudCgpOiBGcmFnbWVudCB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5jb250ZW50XG4gIH1cblxuICBzZXQgY29udGVudChjb250ZW50OiBDb250ZW50KSB7XG4gICAgbGV0IGZyb20gPSB0aGlzLmZyb21cbiAgICBsZXQgdG8gPSB0aGlzLnRvXG5cbiAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICBpZiAodGhpcy5jb250ZW50LnNpemUgPT09IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgWW91IGNhbuKAmXQgc2V0IGNvbnRlbnQgb24gYSBibG9jayBub2RlLiBUcmllZCB0byBzZXQgY29udGVudCBvbiAke3RoaXMubmFtZX0gYXQgJHt0aGlzLnBvc31gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgZnJvbSA9IHRoaXMuZnJvbSArIDFcbiAgICAgIHRvID0gdGhpcy50byAtIDFcbiAgICB9XG5cbiAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5pbnNlcnRDb250ZW50QXQoeyBmcm9tLCB0byB9LCBjb250ZW50KVxuICB9XG5cbiAgZ2V0IGF0dHJpYnV0ZXMoKSA6IHsgW2tleTogc3RyaW5nXTogYW55IH0ge1xuICAgIHJldHVybiB0aGlzLm5vZGUuYXR0cnNcbiAgfVxuXG4gIGdldCB0ZXh0Q29udGVudCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnRcbiAgfVxuXG4gIGdldCBzaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5ub2RlU2l6ZVxuICB9XG5cbiAgZ2V0IGZyb20oKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3NcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFBvcy5zdGFydCh0aGlzLnJlc29sdmVkUG9zLmRlcHRoKVxuICB9XG5cbiAgZ2V0IHJhbmdlKCk6IFJhbmdlIHtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgdG86IHRoaXMudG8sXG4gICAgfVxuICB9XG5cbiAgZ2V0IHRvKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuaXNCbG9jaykge1xuICAgICAgcmV0dXJuIHRoaXMucG9zICsgdGhpcy5zaXplXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRQb3MuZW5kKHRoaXMucmVzb2x2ZWRQb3MuZGVwdGgpICsgKHRoaXMubm9kZS5pc1RleHQgPyAwIDogMSlcbiAgfVxuXG4gIGdldCBwYXJlbnQoKTogTm9kZVBvcyB8IG51bGwge1xuICAgIGlmICh0aGlzLmRlcHRoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudFBvcyA9IHRoaXMucmVzb2x2ZWRQb3Muc3RhcnQodGhpcy5yZXNvbHZlZFBvcy5kZXB0aCAtIDEpXG4gICAgY29uc3QgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUocGFyZW50UG9zKVxuXG4gICAgcmV0dXJuIG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yKVxuICB9XG5cbiAgZ2V0IGJlZm9yZSgpOiBOb2RlUG9zIHwgbnVsbCB7XG4gICAgbGV0ICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMuZnJvbSAtICh0aGlzLmlzQmxvY2sgPyAxIDogMikpXG5cbiAgICBpZiAoJHBvcy5kZXB0aCAhPT0gdGhpcy5kZXB0aCkge1xuICAgICAgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy5mcm9tIC0gMylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE5vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IpXG4gIH1cblxuICBnZXQgYWZ0ZXIoKTogTm9kZVBvcyB8IG51bGwge1xuICAgIGxldCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0aGlzLnRvICsgKHRoaXMuaXNCbG9jayA/IDIgOiAxKSlcblxuICAgIGlmICgkcG9zLmRlcHRoICE9PSB0aGlzLmRlcHRoKSB7XG4gICAgICAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0aGlzLnRvICsgMylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE5vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IpXG4gIH1cblxuICBnZXQgY2hpbGRyZW4oKTogTm9kZVBvc1tdIHtcbiAgICBjb25zdCBjaGlsZHJlbjogTm9kZVBvc1tdID0gW11cblxuICAgIHRoaXMubm9kZS5jb250ZW50LmZvckVhY2goKG5vZGUsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgaXNCbG9jayA9IG5vZGUuaXNCbG9jayAmJiAhbm9kZS5pc1RleHRibG9ja1xuXG4gICAgICBjb25zdCB0YXJnZXRQb3MgPSB0aGlzLnBvcyArIG9mZnNldCArIChpc0Jsb2NrID8gMCA6IDEpXG4gICAgICBjb25zdCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0YXJnZXRQb3MpXG5cbiAgICAgIGlmICghaXNCbG9jayAmJiAkcG9zLmRlcHRoIDw9IHRoaXMuZGVwdGgpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkTm9kZVBvcyA9IG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yLCBpc0Jsb2NrLCBpc0Jsb2NrID8gbm9kZSA6IG51bGwpXG5cbiAgICAgIGlmIChpc0Jsb2NrKSB7XG4gICAgICAgIGNoaWxkTm9kZVBvcy5hY3R1YWxEZXB0aCA9IHRoaXMuZGVwdGggKyAxXG4gICAgICB9XG5cbiAgICAgIGNoaWxkcmVuLnB1c2gobmV3IE5vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IsIGlzQmxvY2ssIGlzQmxvY2sgPyBub2RlIDogbnVsbCkpXG4gICAgfSlcblxuICAgIHJldHVybiBjaGlsZHJlblxuICB9XG5cbiAgZ2V0IGZpcnN0Q2hpbGQoKTogTm9kZVBvcyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdIHx8IG51bGxcbiAgfVxuXG4gIGdldCBsYXN0Q2hpbGQoKTogTm9kZVBvcyB8IG51bGwge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlblxuXG4gICAgcmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdIHx8IG51bGxcbiAgfVxuXG4gIGNsb3Nlc3Qoc2VsZWN0b3I6IHN0cmluZywgYXR0cmlidXRlczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9KTogTm9kZVBvcyB8IG51bGwge1xuICAgIGxldCBub2RlOiBOb2RlUG9zIHwgbnVsbCA9IG51bGxcbiAgICBsZXQgY3VycmVudE5vZGUgPSB0aGlzLnBhcmVudFxuXG4gICAgd2hpbGUgKGN1cnJlbnROb2RlICYmICFub2RlKSB7XG4gICAgICBpZiAoY3VycmVudE5vZGUubm9kZS50eXBlLm5hbWUgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZUF0dHJpYnV0ZXMgPSBjdXJyZW50Tm9kZS5ub2RlLmF0dHJzXG4gICAgICAgICAgY29uc3QgYXR0cktleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKVxuXG4gICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGF0dHJLZXlzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXR0cktleXNbaW5kZXhdXG5cbiAgICAgICAgICAgIGlmIChub2RlQXR0cmlidXRlc1trZXldICE9PSBhdHRyaWJ1dGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IGN1cnJlbnROb2RlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnRcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgcXVlcnlTZWxlY3RvcihzZWxlY3Rvcjogc3RyaW5nLCBhdHRyaWJ1dGVzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge30pOiBOb2RlUG9zIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgYXR0cmlidXRlcywgdHJ1ZSlbMF0gfHwgbnVsbFxuICB9XG5cbiAgcXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcjogc3RyaW5nLCBhdHRyaWJ1dGVzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge30sIGZpcnN0SXRlbU9ubHkgPSBmYWxzZSk6IE5vZGVQb3NbXSB7XG4gICAgbGV0IG5vZGVzOiBOb2RlUG9zW10gPSBbXVxuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5IGZpbmRpbmcgYWxsIG5vZGVzIHdoaWNoIG1hdGNoIHRoZSBzZWxlY3RvciB3aXRoIHRoZSBub2RlIG5hbWVcbiAgICBpZiAodGhpcy5pc0Jsb2NrIHx8ICF0aGlzLmNoaWxkcmVuIHx8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9XG5cbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGRQb3MgPT4ge1xuICAgICAgaWYgKGNoaWxkUG9zLm5vZGUudHlwZS5uYW1lID09PSBzZWxlY3Rvcikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVBdHRyaWJ1dGVzID0gY2hpbGRQb3Mubm9kZS5hdHRyc1xuICAgICAgICAgIGNvbnN0IGF0dHJLZXlzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcylcblxuICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhdHRyS2V5cy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGF0dHJLZXlzW2luZGV4XVxuXG4gICAgICAgICAgICBpZiAobm9kZUF0dHJpYnV0ZXNba2V5XSAhPT0gYXR0cmlidXRlc1trZXldKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVzLnB1c2goY2hpbGRQb3MpXG5cbiAgICAgICAgaWYgKGZpcnN0SXRlbU9ubHkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjaGlsZFBvcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIG5vZGVzXG4gIH1cblxuICBzZXRBdHRyaWJ1dGUoYXR0cmlidXRlczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSkge1xuICAgIGNvbnN0IG9sZFNlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvblxuXG4gICAgdGhpcy5lZGl0b3IuY2hhaW4oKS5zZXRUZXh0U2VsZWN0aW9uKHRoaXMuZnJvbSkudXBkYXRlQXR0cmlidXRlcyh0aGlzLm5vZGUudHlwZS5uYW1lLCBhdHRyaWJ1dGVzKS5zZXRUZXh0U2VsZWN0aW9uKG9sZFNlbGVjdGlvbi5mcm9tKVxuICAgICAgLnJ1bigpXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3Qgc3R5bGUgPSBgLlByb3NlTWlycm9yIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG4uUHJvc2VNaXJyb3Ige1xuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgd2hpdGUtc3BhY2U6IGJyZWFrLXNwYWNlcztcbiAgLXdlYmtpdC1mb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IFwibGlnYVwiIDA7IC8qIHRoZSBhYm92ZSBkb2Vzbid0IHNlZW0gdG8gd29yayBpbiBFZGdlICovXG59XG5cbi5Qcm9zZU1pcnJvciBbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0ge1xuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xufVxuXG4uUHJvc2VNaXJyb3IgW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdIFtjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG4uUHJvc2VNaXJyb3IgcHJlIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG5pbWcuUHJvc2VNaXJyb3Itc2VwYXJhdG9yIHtcbiAgZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7XG4gIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xuICBtYXJnaW46IDAgIWltcG9ydGFudDtcbiAgd2lkdGg6IDFweCAhaW1wb3J0YW50O1xuICBoZWlnaHQ6IDFweCAhaW1wb3J0YW50O1xufVxuXG4uUHJvc2VNaXJyb3ItZ2FwY3Vyc29yIHtcbiAgZGlzcGxheTogbm9uZTtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbWFyZ2luOiAwO1xufVxuXG4uUHJvc2VNaXJyb3ItZ2FwY3Vyc29yOmFmdGVyIHtcbiAgY29udGVudDogXCJcIjtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAtMnB4O1xuICB3aWR0aDogMjBweDtcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIGJsYWNrO1xuICBhbmltYXRpb246IFByb3NlTWlycm9yLWN1cnNvci1ibGluayAxLjFzIHN0ZXBzKDIsIHN0YXJ0KSBpbmZpbml0ZTtcbn1cblxuQGtleWZyYW1lcyBQcm9zZU1pcnJvci1jdXJzb3ItYmxpbmsge1xuICB0byB7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICB9XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICo6OnNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqOjotbW96LXNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqIHtcbiAgY2FyZXQtY29sb3I6IHRyYW5zcGFyZW50O1xufVxuXG4uUHJvc2VNaXJyb3ItZm9jdXNlZCAuUHJvc2VNaXJyb3ItZ2FwY3Vyc29yIHtcbiAgZGlzcGxheTogYmxvY2s7XG59XG5cbi50aXBweS1ib3hbZGF0YS1hbmltYXRpb249ZmFkZV1bZGF0YS1zdGF0ZT1oaWRkZW5dIHtcbiAgb3BhY2l0eTogMFxufWBcbiIsICJleHBvcnQgZnVuY3Rpb24gY3JlYXRlU3R5bGVUYWcoc3R5bGU6IHN0cmluZywgbm9uY2U/OiBzdHJpbmcsIHN1ZmZpeD86IHN0cmluZyk6IEhUTUxTdHlsZUVsZW1lbnQge1xuICBjb25zdCB0aXB0YXBTdHlsZVRhZyA9ICg8SFRNTFN0eWxlRWxlbWVudD5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzdHlsZVtkYXRhLXRpcHRhcC1zdHlsZSR7c3VmZml4ID8gYC0ke3N1ZmZpeH1gIDogJyd9XWApKVxuXG4gIGlmICh0aXB0YXBTdHlsZVRhZyAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0aXB0YXBTdHlsZVRhZ1xuICB9XG5cbiAgY29uc3Qgc3R5bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuXG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpXG4gIH1cblxuICBzdHlsZU5vZGUuc2V0QXR0cmlidXRlKGBkYXRhLXRpcHRhcC1zdHlsZSR7c3VmZml4ID8gYC0ke3N1ZmZpeH1gIDogJyd9YCwgJycpXG4gIHN0eWxlTm9kZS5pbm5lckhUTUwgPSBzdHlsZVxuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHN0eWxlTm9kZSlcblxuICByZXR1cm4gc3R5bGVOb2RlXG59XG4iLCAiaW1wb3J0IHtcbiAgTWFya1R5cGUsIE5vZGVUeXBlLCBTY2hlbWEsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQge1xuICBFZGl0b3JTdGF0ZSwgUGx1Z2luLCBQbHVnaW5LZXksIFRyYW5zYWN0aW9uLFxufSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHsgQ29tbWFuZE1hbmFnZXIgfSBmcm9tICcuL0NvbW1hbmRNYW5hZ2VyLmpzJ1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi9FdmVudEVtaXR0ZXIuanMnXG5pbXBvcnQgeyBFeHRlbnNpb25NYW5hZ2VyIH0gZnJvbSAnLi9FeHRlbnNpb25NYW5hZ2VyLmpzJ1xuaW1wb3J0ICogYXMgZXh0ZW5zaW9ucyBmcm9tICcuL2V4dGVuc2lvbnMvaW5kZXguanMnXG5pbXBvcnQgeyBjcmVhdGVEb2N1bWVudCB9IGZyb20gJy4vaGVscGVycy9jcmVhdGVEb2N1bWVudC5qcydcbmltcG9ydCB7IGdldEF0dHJpYnV0ZXMgfSBmcm9tICcuL2hlbHBlcnMvZ2V0QXR0cmlidXRlcy5qcydcbmltcG9ydCB7IGdldEhUTUxGcm9tRnJhZ21lbnQgfSBmcm9tICcuL2hlbHBlcnMvZ2V0SFRNTEZyb21GcmFnbWVudC5qcydcbmltcG9ydCB7IGdldFRleHQgfSBmcm9tICcuL2hlbHBlcnMvZ2V0VGV4dC5qcydcbmltcG9ydCB7IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEgfSBmcm9tICcuL2hlbHBlcnMvZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYS5qcydcbmltcG9ydCB7IGlzQWN0aXZlIH0gZnJvbSAnLi9oZWxwZXJzL2lzQWN0aXZlLmpzJ1xuaW1wb3J0IHsgaXNOb2RlRW1wdHkgfSBmcm9tICcuL2hlbHBlcnMvaXNOb2RlRW1wdHkuanMnXG5pbXBvcnQgeyByZXNvbHZlRm9jdXNQb3NpdGlvbiB9IGZyb20gJy4vaGVscGVycy9yZXNvbHZlRm9jdXNQb3NpdGlvbi5qcydcbmltcG9ydCB7IE5vZGVQb3MgfSBmcm9tICcuL05vZGVQb3MuanMnXG5pbXBvcnQgeyBzdHlsZSB9IGZyb20gJy4vc3R5bGUuanMnXG5pbXBvcnQge1xuICBDYW5Db21tYW5kcyxcbiAgQ2hhaW5lZENvbW1hbmRzLFxuICBFZGl0b3JFdmVudHMsXG4gIEVkaXRvck9wdGlvbnMsXG4gIEpTT05Db250ZW50LFxuICBTaW5nbGVDb21tYW5kcyxcbiAgVGV4dFNlcmlhbGl6ZXIsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBjcmVhdGVTdHlsZVRhZyB9IGZyb20gJy4vdXRpbGl0aWVzL2NyZWF0ZVN0eWxlVGFnLmpzJ1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vdXRpbGl0aWVzL2lzRnVuY3Rpb24uanMnXG5cbmV4cG9ydCB7IGV4dGVuc2lvbnMgfVxuXG5leHBvcnQgaW50ZXJmYWNlIEhUTUxFbGVtZW50IHtcbiAgZWRpdG9yPzogRWRpdG9yXG59XG5cbmV4cG9ydCBjbGFzcyBFZGl0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXI8RWRpdG9yRXZlbnRzPiB7XG4gIHByaXZhdGUgY29tbWFuZE1hbmFnZXIhOiBDb21tYW5kTWFuYWdlclxuXG4gIHB1YmxpYyBleHRlbnNpb25NYW5hZ2VyITogRXh0ZW5zaW9uTWFuYWdlclxuXG4gIHByaXZhdGUgY3NzITogSFRNTFN0eWxlRWxlbWVudFxuXG4gIHB1YmxpYyBzY2hlbWEhOiBTY2hlbWFcblxuICBwdWJsaWMgdmlldyE6IEVkaXRvclZpZXdcblxuICBwdWJsaWMgaXNGb2N1c2VkID0gZmFsc2VcblxuICBwdWJsaWMgZXh0ZW5zaW9uU3RvcmFnZTogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9XG5cbiAgcHVibGljIG9wdGlvbnM6IEVkaXRvck9wdGlvbnMgPSB7XG4gICAgZWxlbWVudDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgY29udGVudDogJycsXG4gICAgaW5qZWN0Q1NTOiB0cnVlLFxuICAgIGluamVjdE5vbmNlOiB1bmRlZmluZWQsXG4gICAgZXh0ZW5zaW9uczogW10sXG4gICAgYXV0b2ZvY3VzOiBmYWxzZSxcbiAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICBlZGl0b3JQcm9wczoge30sXG4gICAgcGFyc2VPcHRpb25zOiB7fSxcbiAgICBlbmFibGVJbnB1dFJ1bGVzOiB0cnVlLFxuICAgIGVuYWJsZVBhc3RlUnVsZXM6IHRydWUsXG4gICAgZW5hYmxlQ29yZUV4dGVuc2lvbnM6IHRydWUsXG4gICAgb25CZWZvcmVDcmVhdGU6ICgpID0+IG51bGwsXG4gICAgb25DcmVhdGU6ICgpID0+IG51bGwsXG4gICAgb25VcGRhdGU6ICgpID0+IG51bGwsXG4gICAgb25TZWxlY3Rpb25VcGRhdGU6ICgpID0+IG51bGwsXG4gICAgb25UcmFuc2FjdGlvbjogKCkgPT4gbnVsbCxcbiAgICBvbkZvY3VzOiAoKSA9PiBudWxsLFxuICAgIG9uQmx1cjogKCkgPT4gbnVsbCxcbiAgICBvbkRlc3Ryb3k6ICgpID0+IG51bGwsXG4gIH1cblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBQYXJ0aWFsPEVkaXRvck9wdGlvbnM+ID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpXG4gICAgdGhpcy5jcmVhdGVFeHRlbnNpb25NYW5hZ2VyKClcbiAgICB0aGlzLmNyZWF0ZUNvbW1hbmRNYW5hZ2VyKClcbiAgICB0aGlzLmNyZWF0ZVNjaGVtYSgpXG4gICAgdGhpcy5vbignYmVmb3JlQ3JlYXRlJywgdGhpcy5vcHRpb25zLm9uQmVmb3JlQ3JlYXRlKVxuICAgIHRoaXMuZW1pdCgnYmVmb3JlQ3JlYXRlJywgeyBlZGl0b3I6IHRoaXMgfSlcbiAgICB0aGlzLmNyZWF0ZVZpZXcoKVxuICAgIHRoaXMuaW5qZWN0Q1NTKClcbiAgICB0aGlzLm9uKCdjcmVhdGUnLCB0aGlzLm9wdGlvbnMub25DcmVhdGUpXG4gICAgdGhpcy5vbigndXBkYXRlJywgdGhpcy5vcHRpb25zLm9uVXBkYXRlKVxuICAgIHRoaXMub24oJ3NlbGVjdGlvblVwZGF0ZScsIHRoaXMub3B0aW9ucy5vblNlbGVjdGlvblVwZGF0ZSlcbiAgICB0aGlzLm9uKCd0cmFuc2FjdGlvbicsIHRoaXMub3B0aW9ucy5vblRyYW5zYWN0aW9uKVxuICAgIHRoaXMub24oJ2ZvY3VzJywgdGhpcy5vcHRpb25zLm9uRm9jdXMpXG4gICAgdGhpcy5vbignYmx1cicsIHRoaXMub3B0aW9ucy5vbkJsdXIpXG4gICAgdGhpcy5vbignZGVzdHJveScsIHRoaXMub3B0aW9ucy5vbkRlc3Ryb3kpXG5cbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5jb21tYW5kcy5mb2N1cyh0aGlzLm9wdGlvbnMuYXV0b2ZvY3VzKVxuICAgICAgdGhpcy5lbWl0KCdjcmVhdGUnLCB7IGVkaXRvcjogdGhpcyB9KVxuICAgIH0sIDApXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRpdG9yIHN0b3JhZ2UuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0b3JhZ2UoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uU3RvcmFnZVxuICB9XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBvZiBhbGwgcmVnaXN0ZXJlZCBjb21tYW5kcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgY29tbWFuZHMoKTogU2luZ2xlQ29tbWFuZHMge1xuICAgIHJldHVybiB0aGlzLmNvbW1hbmRNYW5hZ2VyLmNvbW1hbmRzXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgY29tbWFuZCBjaGFpbiB0byBjYWxsIG11bHRpcGxlIGNvbW1hbmRzIGF0IG9uY2UuXG4gICAqL1xuICBwdWJsaWMgY2hhaW4oKTogQ2hhaW5lZENvbW1hbmRzIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jaGFpbigpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBjb21tYW5kIG9yIGEgY29tbWFuZCBjaGFpbiBjYW4gYmUgZXhlY3V0ZWQuIFdpdGhvdXQgZXhlY3V0aW5nIGl0LlxuICAgKi9cbiAgcHVibGljIGNhbigpOiBDYW5Db21tYW5kcyB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY2FuKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmplY3QgQ1NTIHN0eWxlcy5cbiAgICovXG4gIHByaXZhdGUgaW5qZWN0Q1NTKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaW5qZWN0Q1NTICYmIGRvY3VtZW50KSB7XG4gICAgICB0aGlzLmNzcyA9IGNyZWF0ZVN0eWxlVGFnKHN0eWxlLCB0aGlzLm9wdGlvbnMuaW5qZWN0Tm9uY2UpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBlZGl0b3Igb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgQSBsaXN0IG9mIG9wdGlvbnNcbiAgICovXG4gIHB1YmxpYyBzZXRPcHRpb25zKG9wdGlvbnM6IFBhcnRpYWw8RWRpdG9yT3B0aW9ucz4gPSB7fSk6IHZvaWQge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnZpZXcgfHwgIXRoaXMuc3RhdGUgfHwgdGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcykge1xuICAgICAgdGhpcy52aWV3LnNldFByb3BzKHRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcylcbiAgICB9XG5cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUodGhpcy5zdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZWRpdGFibGUgc3RhdGUgb2YgdGhlIGVkaXRvci5cbiAgICovXG4gIHB1YmxpYyBzZXRFZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbiwgZW1pdFVwZGF0ZSA9IHRydWUpOiB2b2lkIHtcbiAgICB0aGlzLnNldE9wdGlvbnMoeyBlZGl0YWJsZSB9KVxuXG4gICAgaWYgKGVtaXRVcGRhdGUpIHtcbiAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgeyBlZGl0b3I6IHRoaXMsIHRyYW5zYWN0aW9uOiB0aGlzLnN0YXRlLnRyIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLlxuICAgKi9cbiAgcHVibGljIGdldCBpc0VkaXRhYmxlKCk6IGJvb2xlYW4ge1xuICAgIC8vIHNpbmNlIHBsdWdpbnMgYXJlIGFwcGxpZWQgYWZ0ZXIgY3JlYXRpbmcgdGhlIHZpZXdcbiAgICAvLyBgZWRpdGFibGVgIGlzIGFsd2F5cyBgdHJ1ZWAgZm9yIG9uZSB0aWNrLlxuICAgIC8vIHRoYXTigJlzIHdoeSB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgZm9yIGBvcHRpb25zLmVkaXRhYmxlYFxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZWRpdGFibGUgJiYgdGhpcy52aWV3ICYmIHRoaXMudmlldy5lZGl0YWJsZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkaXRvciBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhdGUoKTogRWRpdG9yU3RhdGUge1xuICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIFByb3NlTWlycm9yIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHBsdWdpbiBBIFByb3NlTWlycm9yIHBsdWdpblxuICAgKiBAcGFyYW0gaGFuZGxlUGx1Z2lucyBDb250cm9sIGhvdyB0byBtZXJnZSB0aGUgcGx1Z2luIGludG8gdGhlIGV4aXN0aW5nIHBsdWdpbnMuXG4gICAqL1xuICBwdWJsaWMgcmVnaXN0ZXJQbHVnaW4oXG4gICAgcGx1Z2luOiBQbHVnaW4sXG4gICAgaGFuZGxlUGx1Z2lucz86IChuZXdQbHVnaW46IFBsdWdpbiwgcGx1Z2luczogUGx1Z2luW10pID0+IFBsdWdpbltdLFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBwbHVnaW5zID0gaXNGdW5jdGlvbihoYW5kbGVQbHVnaW5zKVxuICAgICAgPyBoYW5kbGVQbHVnaW5zKHBsdWdpbiwgWy4uLnRoaXMuc3RhdGUucGx1Z2luc10pXG4gICAgICA6IFsuLi50aGlzLnN0YXRlLnBsdWdpbnMsIHBsdWdpbl1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7IHBsdWdpbnMgfSlcblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGEgUHJvc2VNaXJyb3IgcGx1Z2luLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZU9yUGx1Z2luS2V5IFRoZSBwbHVnaW5zIG5hbWVcbiAgICovXG4gIHB1YmxpYyB1bnJlZ2lzdGVyUGx1Z2luKG5hbWVPclBsdWdpbktleTogc3RyaW5nIHwgUGx1Z2luS2V5KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBuYW1lID0gdHlwZW9mIG5hbWVPclBsdWdpbktleSA9PT0gJ3N0cmluZycgPyBgJHtuYW1lT3JQbHVnaW5LZXl9JGAgOiBuYW1lT3JQbHVnaW5LZXkua2V5XG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoe1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcGx1Z2luczogdGhpcy5zdGF0ZS5wbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gIXBsdWdpbi5rZXkuc3RhcnRzV2l0aChuYW1lKSksXG4gICAgfSlcblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV4dGVuc2lvbiBtYW5hZ2VyLlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCk6IHZvaWQge1xuICAgIGNvbnN0IGNvcmVFeHRlbnNpb25zID0gdGhpcy5vcHRpb25zLmVuYWJsZUNvcmVFeHRlbnNpb25zID8gT2JqZWN0LnZhbHVlcyhleHRlbnNpb25zKSA6IFtdXG4gICAgY29uc3QgYWxsRXh0ZW5zaW9ucyA9IFsuLi5jb3JlRXh0ZW5zaW9ucywgLi4udGhpcy5vcHRpb25zLmV4dGVuc2lvbnNdLmZpbHRlcihleHRlbnNpb24gPT4ge1xuICAgICAgcmV0dXJuIFsnZXh0ZW5zaW9uJywgJ25vZGUnLCAnbWFyayddLmluY2x1ZGVzKGV4dGVuc2lvbj8udHlwZSlcbiAgICB9KVxuXG4gICAgdGhpcy5leHRlbnNpb25NYW5hZ2VyID0gbmV3IEV4dGVuc2lvbk1hbmFnZXIoYWxsRXh0ZW5zaW9ucywgdGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGNvbW1hbmQgbWFuYWdlci5cbiAgICovXG4gIHByaXZhdGUgY3JlYXRlQ29tbWFuZE1hbmFnZXIoKTogdm9pZCB7XG4gICAgdGhpcy5jb21tYW5kTWFuYWdlciA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICBlZGl0b3I6IHRoaXMsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUHJvc2VNaXJyb3Igc2NoZW1hLlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVTY2hlbWEoKTogdm9pZCB7XG4gICAgdGhpcy5zY2hlbWEgPSB0aGlzLmV4dGVuc2lvbk1hbmFnZXIuc2NoZW1hXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHZpZXcuXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZVZpZXcoKTogdm9pZCB7XG4gICAgY29uc3QgZG9jID0gY3JlYXRlRG9jdW1lbnQodGhpcy5vcHRpb25zLmNvbnRlbnQsIHRoaXMuc2NoZW1hLCB0aGlzLm9wdGlvbnMucGFyc2VPcHRpb25zKVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHJlc29sdmVGb2N1c1Bvc2l0aW9uKGRvYywgdGhpcy5vcHRpb25zLmF1dG9mb2N1cylcblxuICAgIHRoaXMudmlldyA9IG5ldyBFZGl0b3JWaWV3KHRoaXMub3B0aW9ucy5lbGVtZW50LCB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMsXG4gICAgICBkaXNwYXRjaFRyYW5zYWN0aW9uOiB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgIHN0YXRlOiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgICAgICBkb2MsXG4gICAgICAgIHNlbGVjdGlvbjogc2VsZWN0aW9uIHx8IHVuZGVmaW5lZCxcbiAgICAgIH0pLFxuICAgIH0pXG5cbiAgICAvLyBgZWRpdG9yLnZpZXdgIGlzIG5vdCB5ZXQgYXZhaWxhYmxlIGF0IHRoaXMgdGltZS5cbiAgICAvLyBUaGVyZWZvcmUgd2Ugd2lsbCBhZGQgYWxsIHBsdWdpbnMgYW5kIG5vZGUgdmlld3MgZGlyZWN0bHkgYWZ0ZXJ3YXJkcy5cbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoe1xuICAgICAgcGx1Z2luczogdGhpcy5leHRlbnNpb25NYW5hZ2VyLnBsdWdpbnMsXG4gICAgfSlcblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShuZXdTdGF0ZSlcblxuICAgIHRoaXMuY3JlYXRlTm9kZVZpZXdzKClcbiAgICB0aGlzLnByZXBlbmRDbGFzcygpXG5cbiAgICAvLyBMZXTigJlzIHN0b3JlIHRoZSBlZGl0b3IgaW5zdGFuY2UgaW4gdGhlIERPTSBlbGVtZW50LlxuICAgIC8vIFNvIHdl4oCZbGwgaGF2ZSBhY2Nlc3MgdG8gaXQgZm9yIHRlc3RzLlxuICAgIGNvbnN0IGRvbSA9IHRoaXMudmlldy5kb20gYXMgSFRNTEVsZW1lbnRcblxuICAgIGRvbS5lZGl0b3IgPSB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbGwgbm9kZSB2aWV3cy5cbiAgICovXG4gIHB1YmxpYyBjcmVhdGVOb2RlVmlld3MoKTogdm9pZCB7XG4gICAgdGhpcy52aWV3LnNldFByb3BzKHtcbiAgICAgIG5vZGVWaWV3czogdGhpcy5leHRlbnNpb25NYW5hZ2VyLm5vZGVWaWV3cyxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFByZXBlbmQgY2xhc3MgbmFtZSB0byBlbGVtZW50LlxuICAgKi9cbiAgcHVibGljIHByZXBlbmRDbGFzcygpOiB2b2lkIHtcbiAgICB0aGlzLnZpZXcuZG9tLmNsYXNzTmFtZSA9IGB0aXB0YXAgJHt0aGlzLnZpZXcuZG9tLmNsYXNzTmFtZX1gXG4gIH1cblxuICBwdWJsaWMgaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IGZhbHNlXG5cbiAgcHJpdmF0ZSBjYXB0dXJlZFRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbiB8IG51bGwgPSBudWxsXG5cbiAgcHVibGljIGNhcHR1cmVUcmFuc2FjdGlvbihmbjogRnVuY3Rpb24pIHtcbiAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSB0cnVlXG4gICAgZm4oKVxuICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IGZhbHNlXG5cbiAgICBjb25zdCB0ciA9IHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvblxuXG4gICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gbnVsbFxuXG4gICAgcmV0dXJuIHRyXG4gIH1cblxuICAvKipcbiAgICogVGhlIGNhbGxiYWNrIG92ZXIgd2hpY2ggdG8gc2VuZCB0cmFuc2FjdGlvbnMgKHN0YXRlIHVwZGF0ZXMpIHByb2R1Y2VkIGJ5IHRoZSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwcml2YXRlIGRpc3BhdGNoVHJhbnNhY3Rpb24odHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uKTogdm9pZCB7XG4gICAgLy8gaWYgdGhlIGVkaXRvciAvIHRoZSB2aWV3IG9mIHRoZSBlZGl0b3Igd2FzIGRlc3Ryb3llZFxuICAgIC8vIHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgbm90IGJlIGRpc3BhdGNoZWQgYXMgdGhlcmUgaXMgbm8gdmlldyBhbnltb3JlLlxuICAgIGlmICh0aGlzLnZpZXcuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24pIHtcbiAgICAgIGlmICghdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uXG5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goc3RlcCA9PiB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24/LnN0ZXAoc3RlcCkpXG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5hcHBseSh0cmFuc2FjdGlvbilcbiAgICBjb25zdCBzZWxlY3Rpb25IYXNDaGFuZ2VkID0gIXRoaXMuc3RhdGUuc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbilcblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSlcbiAgICB0aGlzLmVtaXQoJ3RyYW5zYWN0aW9uJywge1xuICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgfSlcblxuICAgIGlmIChzZWxlY3Rpb25IYXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoJ3NlbGVjdGlvblVwZGF0ZScsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgZm9jdXMgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCdmb2N1cycpXG4gICAgY29uc3QgYmx1ciA9IHRyYW5zYWN0aW9uLmdldE1ldGEoJ2JsdXInKVxuXG4gICAgaWYgKGZvY3VzKSB7XG4gICAgICB0aGlzLmVtaXQoJ2ZvY3VzJywge1xuICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgIGV2ZW50OiBmb2N1cy5ldmVudCxcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChibHVyKSB7XG4gICAgICB0aGlzLmVtaXQoJ2JsdXInLCB7XG4gICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgZXZlbnQ6IGJsdXIuZXZlbnQsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoIXRyYW5zYWN0aW9uLmRvY0NoYW5nZWQgfHwgdHJhbnNhY3Rpb24uZ2V0TWV0YSgncHJldmVudFVwZGF0ZScpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHtcbiAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IGF0dHJpYnV0ZXMgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub2RlIG9yIG1hcmsuXG4gICAqL1xuICBwdWJsaWMgZ2V0QXR0cmlidXRlcyhuYW1lT3JUeXBlOiBzdHJpbmcgfCBOb2RlVHlwZSB8IE1hcmtUeXBlKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gICAgcmV0dXJuIGdldEF0dHJpYnV0ZXModGhpcy5zdGF0ZSwgbmFtZU9yVHlwZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZSBvciBtYXJrIGlzIGFjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgbm9kZSBvciBtYXJrXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIEF0dHJpYnV0ZXMgb2YgdGhlIG5vZGUgb3IgbWFya1xuICAgKi9cbiAgcHVibGljIGlzQWN0aXZlKG5hbWU6IHN0cmluZywgYXR0cmlidXRlcz86IHt9KTogYm9vbGVhblxuICBwdWJsaWMgaXNBY3RpdmUoYXR0cmlidXRlczoge30pOiBib29sZWFuXG4gIHB1YmxpYyBpc0FjdGl2ZShuYW1lT3JBdHRyaWJ1dGVzOiBzdHJpbmcsIGF0dHJpYnV0ZXNPclVuZGVmaW5lZD86IHt9KTogYm9vbGVhbiB7XG4gICAgY29uc3QgbmFtZSA9IHR5cGVvZiBuYW1lT3JBdHRyaWJ1dGVzID09PSAnc3RyaW5nJyA/IG5hbWVPckF0dHJpYnV0ZXMgOiBudWxsXG5cbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gdHlwZW9mIG5hbWVPckF0dHJpYnV0ZXMgPT09ICdzdHJpbmcnID8gYXR0cmlidXRlc09yVW5kZWZpbmVkIDogbmFtZU9yQXR0cmlidXRlc1xuXG4gICAgcmV0dXJuIGlzQWN0aXZlKHRoaXMuc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkb2N1bWVudCBhcyBKU09OLlxuICAgKi9cbiAgcHVibGljIGdldEpTT04oKTogSlNPTkNvbnRlbnQge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmRvYy50b0pTT04oKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSFRNTC5cbiAgICovXG4gIHB1YmxpYyBnZXRIVE1MKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGdldEhUTUxGcm9tRnJhZ21lbnQodGhpcy5zdGF0ZS5kb2MuY29udGVudCwgdGhpcy5zY2hlbWEpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkb2N1bWVudCBhcyB0ZXh0LlxuICAgKi9cbiAgcHVibGljIGdldFRleHQob3B0aW9ucz86IHtcbiAgICBibG9ja1NlcGFyYXRvcj86IHN0cmluZ1xuICAgIHRleHRTZXJpYWxpemVycz86IFJlY29yZDxzdHJpbmcsIFRleHRTZXJpYWxpemVyPlxuICB9KTogc3RyaW5nIHtcbiAgICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9XG5cbiAgICByZXR1cm4gZ2V0VGV4dCh0aGlzLnN0YXRlLmRvYywge1xuICAgICAgYmxvY2tTZXBhcmF0b3IsXG4gICAgICB0ZXh0U2VyaWFsaXplcnM6IHtcbiAgICAgICAgLi4uZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSh0aGlzLnNjaGVtYSksXG4gICAgICAgIC4uLnRleHRTZXJpYWxpemVycyxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGVyZSBpcyBubyBjb250ZW50LlxuICAgKi9cbiAgcHVibGljIGdldCBpc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc05vZGVFbXB0eSh0aGlzLnN0YXRlLmRvYylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGZvciB0aGUgY3VycmVudCBkb2N1bWVudC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHB1YmxpYyBnZXRDaGFyYWN0ZXJDb3VudCgpOiBudW1iZXIge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdbdGlwdGFwIHdhcm5dOiBcImVkaXRvci5nZXRDaGFyYWN0ZXJDb3VudCgpXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImVkaXRvci5zdG9yYWdlLmNoYXJhY3RlckNvdW50LmNoYXJhY3RlcnMoKVwiIGluc3RlYWQuJyxcbiAgICApXG5cbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kb2MuY29udGVudC5zaXplIC0gMlxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIGVkaXRvci5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuZW1pdCgnZGVzdHJveScpXG5cbiAgICBpZiAodGhpcy52aWV3KSB7XG4gICAgICB0aGlzLnZpZXcuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgYWxyZWFkeSBkZXN0cm95ZWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzRGVzdHJveWVkKCk6IGJvb2xlYW4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gIXRoaXMudmlldz8uZG9jVmlld1xuICB9XG5cbiAgcHVibGljICRub2RlKHNlbGVjdG9yOiBzdHJpbmcsIGF0dHJpYnV0ZXM/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogTm9kZVBvcyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLiRkb2M/LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IsIGF0dHJpYnV0ZXMpIHx8IG51bGxcbiAgfVxuXG4gIHB1YmxpYyAkbm9kZXMoc2VsZWN0b3I6IHN0cmluZywgYXR0cmlidXRlcz86IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiBOb2RlUG9zW10gfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy4kZG9jPy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzKSB8fCBudWxsXG4gIH1cblxuICBwdWJsaWMgJHBvcyhwb3M6IG51bWJlcikge1xuICAgIGNvbnN0ICRwb3MgPSB0aGlzLnN0YXRlLmRvYy5yZXNvbHZlKHBvcylcblxuICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzKVxuICB9XG5cbiAgZ2V0ICRkb2MoKSB7XG4gICAgcmV0dXJuIHRoaXMuJHBvcygwKVxuICB9XG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrc0JldHdlZW4gfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtzQmV0d2Vlbi5qcydcbmltcG9ydCB7IElucHV0UnVsZSwgSW5wdXRSdWxlRmluZGVyIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBhZGRzIGEgbWFyayB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrSW5wdXRSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXJcbiAgdHlwZTogTWFya1R5cGVcbiAgZ2V0QXR0cmlidXRlcz86XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgfCAoKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgfCBmYWxzZVxuICAgIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKVxuXG4gICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZVxuICAgICAgY29uc3QgY2FwdHVyZUdyb3VwID0gbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV1cbiAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IG1hdGNoWzBdXG5cbiAgICAgIGlmIChjYXB0dXJlR3JvdXApIHtcbiAgICAgICAgY29uc3Qgc3RhcnRTcGFjZXMgPSBmdWxsTWF0Y2guc2VhcmNoKC9cXFMvKVxuICAgICAgICBjb25zdCB0ZXh0U3RhcnQgPSByYW5nZS5mcm9tICsgZnVsbE1hdGNoLmluZGV4T2YoY2FwdHVyZUdyb3VwKVxuICAgICAgICBjb25zdCB0ZXh0RW5kID0gdGV4dFN0YXJ0ICsgY2FwdHVyZUdyb3VwLmxlbmd0aFxuXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVkTWFya3MgPSBnZXRNYXJrc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHN0YXRlLmRvYylcbiAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgZXhjbHVkZWQgPSBpdGVtLm1hcmsudHlwZS5leGNsdWRlZCBhcyBNYXJrVHlwZVtdXG5cbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlZC5maW5kKHR5cGUgPT4gdHlwZSA9PT0gY29uZmlnLnR5cGUgJiYgdHlwZSAhPT0gaXRlbS5tYXJrLnR5cGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS50byA+IHRleHRTdGFydClcblxuICAgICAgICBpZiAoZXhjbHVkZWRNYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRFbmQgPCByYW5nZS50bykge1xuICAgICAgICAgIHRyLmRlbGV0ZSh0ZXh0RW5kLCByYW5nZS50bylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0U3RhcnQgPiByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgdGV4dFN0YXJ0KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWFya0VuZCA9IHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcyArIGNhcHR1cmVHcm91cC5sZW5ndGhcblxuICAgICAgICB0ci5hZGRNYXJrKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgbWFya0VuZCwgY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMgfHwge30pKVxuXG4gICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsoY29uZmlnLnR5cGUpXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IElucHV0UnVsZSwgSW5wdXRSdWxlRmluZGVyIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBhZGRzIGEgbm9kZSB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub2RlSW5wdXRSdWxlKGNvbmZpZzoge1xuICAvKipcbiAgICogVGhlIHJlZ2V4IHRvIG1hdGNoLlxuICAgKi9cbiAgZmluZDogSW5wdXRSdWxlRmluZGVyXG5cbiAgLyoqXG4gICAqIFRoZSBub2RlIHR5cGUgdG8gYWRkLlxuICAgKi9cbiAgdHlwZTogTm9kZVR5cGVcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBub2RlXG4gICAqIGNhbiBhbHNvIGJlIGFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzPzpcbiAgICB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICB8ICgobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICB8IGZhbHNlXG4gICAgfCBudWxsXG59KSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpIHx8IHt9XG4gICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZVxuICAgICAgY29uc3Qgc3RhcnQgPSByYW5nZS5mcm9tXG4gICAgICBsZXQgZW5kID0gcmFuZ2UudG9cblxuICAgICAgY29uc3QgbmV3Tm9kZSA9IGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKVxuXG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pXG4gICAgICAgIGxldCBtYXRjaFN0YXJ0ID0gc3RhcnQgKyBvZmZzZXRcblxuICAgICAgICBpZiAobWF0Y2hTdGFydCA+IGVuZCkge1xuICAgICAgICAgIG1hdGNoU3RhcnQgPSBlbmRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSBtYXRjaFN0YXJ0ICsgbWF0Y2hbMV0ubGVuZ3RoXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbnNlcnQgbGFzdCB0eXBlZCBjaGFyYWN0ZXJcbiAgICAgICAgY29uc3QgbGFzdENoYXIgPSBtYXRjaFswXVttYXRjaFswXS5sZW5ndGggLSAxXVxuXG4gICAgICAgIHRyLmluc2VydFRleHQobGFzdENoYXIsIHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoIC0gMSlcblxuICAgICAgICAvLyBpbnNlcnQgbm9kZSBmcm9tIGlucHV0IHJ1bGVcbiAgICAgICAgdHIucmVwbGFjZVdpdGgobWF0Y2hTdGFydCwgZW5kLCBuZXdOb2RlKVxuICAgICAgfSBlbHNlIGlmIChtYXRjaFswXSkge1xuICAgICAgICB0ci5pbnNlcnQoc3RhcnQgLSAxLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcykpLmRlbGV0ZShcbiAgICAgICAgICB0ci5tYXBwaW5nLm1hcChzdGFydCksXG4gICAgICAgICAgdHIubWFwcGluZy5tYXAoZW5kKSxcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IElucHV0UnVsZSwgSW5wdXRSdWxlRmluZGVyIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBjaGFuZ2VzIHRoZSB0eXBlIG9mIGEgdGV4dGJsb2NrIHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC4gV2hlbiB1c2luZyBhIHJlZ3VsYXIgZXhwcmVzaW9uIHlvdeKAmWxsXG4gKiBwcm9iYWJseSB3YW50IHRoZSByZWdleHAgdG8gc3RhcnQgd2l0aCBgXmAsIHNvIHRoYXQgdGhlIHBhdHRlcm4gY2FuXG4gKiBvbmx5IG9jY3VyIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlclxuICB0eXBlOiBOb2RlVHlwZVxuICBnZXRBdHRyaWJ1dGVzPzpcbiAgICB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICB8ICgobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICB8IGZhbHNlXG4gICAgfCBudWxsXG59KSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGNvbnN0ICRzdGFydCA9IHN0YXRlLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pXG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fVxuXG4gICAgICBpZiAoISRzdGFydC5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkc3RhcnQuaW5kZXgoLTEpLCAkc3RhcnQuaW5kZXhBZnRlcigtMSksIGNvbmZpZy50eXBlKSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBzdGF0ZS50clxuICAgICAgICAuZGVsZXRlKHJhbmdlLmZyb20sIHJhbmdlLnRvKVxuICAgICAgICAuc2V0QmxvY2tUeXBlKHJhbmdlLmZyb20sIHJhbmdlLmZyb20sIGNvbmZpZy50eXBlLCBhdHRyaWJ1dGVzKVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgSW5wdXRSdWxlLCBJbnB1dFJ1bGVGaW5kZXIgfSBmcm9tICcuLi9JbnB1dFJ1bGUuanMnXG5cbi8qKlxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IHJlcGxhY2VzIHRleHQgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGV4dElucHV0UnVsZShjb25maWc6IHtcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyLFxuICByZXBsYWNlOiBzdHJpbmcsXG59KSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGxldCBpbnNlcnQgPSBjb25maWcucmVwbGFjZVxuICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbVxuICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG9cblxuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKVxuXG4gICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpXG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldFxuXG4gICAgICAgIGNvbnN0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kXG5cbiAgICAgICAgaWYgKGN1dE9mZiA+IDApIHtcbiAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnRcbiAgICAgICAgICBzdGFydCA9IGVuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IGNhbkpvaW4sIGZpbmRXcmFwcGluZyB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUsIElucHV0UnVsZUZpbmRlciB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIGEgdGV4dGJsb2NrIHdoZW4gYVxuICogZ2l2ZW4gc3RyaW5nIGlzIHR5cGVkLiBXaGVuIHVzaW5nIGEgcmVndWxhciBleHByZXNpb24geW914oCZbGxcbiAqIHByb2JhYmx5IHdhbnQgdGhlIHJlZ2V4cCB0byBzdGFydCB3aXRoIGBeYCwgc28gdGhhdCB0aGUgcGF0dGVybiBjYW5cbiAqIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuICpcbiAqIGB0eXBlYCBpcyB0aGUgdHlwZSBvZiBub2RlIHRvIHdyYXAgaW4uXG4gKlxuICogQnkgZGVmYXVsdCwgaWYgdGhlcmXigJlzIGEgbm9kZSB3aXRoIHRoZSBzYW1lIHR5cGUgYWJvdmUgdGhlIG5ld2x5XG4gKiB3cmFwcGVkIG5vZGUsIHRoZSBydWxlIHdpbGwgdHJ5IHRvIGpvaW4gdGhvc2VcbiAqIHR3byBub2Rlcy4gWW91IGNhbiBwYXNzIGEgam9pbiBwcmVkaWNhdGUsIHdoaWNoIHRha2VzIGEgcmVndWxhclxuICogZXhwcmVzc2lvbiBtYXRjaCBhbmQgdGhlIG5vZGUgYmVmb3JlIHRoZSB3cmFwcGVkIG5vZGUsIGFuZCBjYW5cbiAqIHJldHVybiBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciBhIGpvaW4gc2hvdWxkIGhhcHBlbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBwaW5nSW5wdXRSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXIsXG4gIHR5cGU6IE5vZGVUeXBlLFxuICBrZWVwTWFya3M/OiBib29sZWFuLFxuICBrZWVwQXR0cmlidXRlcz86IGJvb2xlYW4sXG4gIGVkaXRvcj86IEVkaXRvclxuICBnZXRBdHRyaWJ1dGVzPzpcbiAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5KSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICB8IGZhbHNlXG4gIHwgbnVsbFxuICAsXG4gIGpvaW5QcmVkaWNhdGU/OiAobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSwgbm9kZTogUHJvc2VNaXJyb3JOb2RlKSA9PiBib29sZWFuLFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHtcbiAgICAgIHN0YXRlLCByYW5nZSwgbWF0Y2gsIGNoYWluLFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpIHx8IHt9XG4gICAgICBjb25zdCB0ciA9IHN0YXRlLnRyLmRlbGV0ZShyYW5nZS5mcm9tLCByYW5nZS50bylcbiAgICAgIGNvbnN0ICRzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pXG4gICAgICBjb25zdCBibG9ja1JhbmdlID0gJHN0YXJ0LmJsb2NrUmFuZ2UoKVxuICAgICAgY29uc3Qgd3JhcHBpbmcgPSBibG9ja1JhbmdlICYmIGZpbmRXcmFwcGluZyhibG9ja1JhbmdlLCBjb25maWcudHlwZSwgYXR0cmlidXRlcylcblxuICAgICAgaWYgKCF3cmFwcGluZykge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICB0ci53cmFwKGJsb2NrUmFuZ2UsIHdyYXBwaW5nKVxuXG4gICAgICBpZiAoY29uZmlnLmtlZXBNYXJrcyAmJiBjb25maWcuZWRpdG9yKSB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGVcbiAgICAgICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGNvbmZpZy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlclxuICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcblxuICAgICAgICBpZiAobWFya3MpIHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSlcblxuICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgLyoqIElmIHRoZSBub2RlVHlwZSBpcyBgYnVsbGV0TGlzdGAgb3IgYG9yZGVyZWRMaXN0YCBzZXQgdGhlIGBub2RlVHlwZWAgYXMgYGxpc3RJdGVtYCAqL1xuICAgICAgICBjb25zdCBub2RlVHlwZSA9IGNvbmZpZy50eXBlLm5hbWUgPT09ICdidWxsZXRMaXN0JyB8fCBjb25maWcudHlwZS5uYW1lID09PSAnb3JkZXJlZExpc3QnID8gJ2xpc3RJdGVtJyA6ICd0YXNrTGlzdCdcblxuICAgICAgICBjaGFpbigpLnVwZGF0ZUF0dHJpYnV0ZXMobm9kZVR5cGUsIGF0dHJpYnV0ZXMpLnJ1bigpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJlZm9yZSA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20gLSAxKS5ub2RlQmVmb3JlXG5cbiAgICAgIGlmIChcbiAgICAgICAgYmVmb3JlXG4gICAgICAgICYmIGJlZm9yZS50eXBlID09PSBjb25maWcudHlwZVxuICAgICAgICAmJiBjYW5Kb2luKHRyLmRvYywgcmFuZ2UuZnJvbSAtIDEpXG4gICAgICAgICYmICghY29uZmlnLmpvaW5QcmVkaWNhdGUgfHwgY29uZmlnLmpvaW5QcmVkaWNhdGUobWF0Y2gsIGJlZm9yZSkpXG4gICAgICApIHtcbiAgICAgICAgdHIuam9pbihyYW5nZS5mcm9tIC0gMSlcbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7XG4gIERPTU91dHB1dFNwZWMsIE1hcmsgYXMgUHJvc2VNaXJyb3JNYXJrLCBNYXJrU3BlYywgTWFya1R5cGUsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IE1hcmtDb25maWcgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHsgSW5wdXRSdWxlIH0gZnJvbSAnLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi9Ob2RlLmpzJ1xuaW1wb3J0IHsgUGFzdGVSdWxlIH0gZnJvbSAnLi9QYXN0ZVJ1bGUuanMnXG5pbXBvcnQge1xuICBBbnlDb25maWcsXG4gIEF0dHJpYnV0ZXMsXG4gIEV4dGVuc2lvbnMsXG4gIEdsb2JhbEF0dHJpYnV0ZXMsXG4gIEtleWJvYXJkU2hvcnRjdXRDb21tYW5kLFxuICBQYXJlbnRDb25maWcsXG4gIFJhd0NvbW1hbmRzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgbWVyZ2VEZWVwIH0gZnJvbSAnLi91dGlsaXRpZXMvbWVyZ2VEZWVwLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgTWFya0NvbmZpZzxPcHRpb25zID0gYW55LCBTdG9yYWdlID0gYW55PiB7XG4gICAgW2tleTogc3RyaW5nXTogYW55XG5cbiAgICAvKipcbiAgICAgKiBOYW1lXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nXG5cbiAgICAvKipcbiAgICAgKiBQcmlvcml0eVxuICAgICAqL1xuICAgIHByaW9yaXR5PzogbnVtYmVyXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBkZWZhdWx0T3B0aW9ucz86IE9wdGlvbnNcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgT3B0aW9uc1xuICAgICAqL1xuICAgIGFkZE9wdGlvbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBwYXJlbnQ6IEV4Y2x1ZGU8UGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRPcHRpb25zJ10sIHVuZGVmaW5lZD5cbiAgICB9KSA9PiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IFN0b3JhZ2VcbiAgICAgKi9cbiAgICBhZGRTdG9yYWdlPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkU3RvcmFnZSddLCB1bmRlZmluZWQ+XG4gICAgfSkgPT4gU3RvcmFnZVxuXG4gICAgLyoqXG4gICAgICogR2xvYmFsIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBhZGRHbG9iYWxBdHRyaWJ1dGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEdsb2JhbEF0dHJpYnV0ZXMnXVxuICAgIH0pID0+IEdsb2JhbEF0dHJpYnV0ZXMgfCB7fVxuXG4gICAgLyoqXG4gICAgICogUmF3XG4gICAgICovXG4gICAgYWRkQ29tbWFuZHM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRDb21tYW5kcyddXG4gICAgfSkgPT4gUGFydGlhbDxSYXdDb21tYW5kcz5cblxuICAgIC8qKlxuICAgICAqIEtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAqL1xuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkS2V5Ym9hcmRTaG9ydGN1dHMnXVxuICAgIH0pID0+IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IEtleWJvYXJkU2hvcnRjdXRDb21tYW5kXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5wdXQgcnVsZXNcbiAgICAgKi9cbiAgICBhZGRJbnB1dFJ1bGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkSW5wdXRSdWxlcyddXG4gICAgfSkgPT4gSW5wdXRSdWxlW11cblxuICAgIC8qKlxuICAgICAqIFBhc3RlIHJ1bGVzXG4gICAgICovXG4gICAgYWRkUGFzdGVSdWxlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFBhc3RlUnVsZXMnXVxuICAgIH0pID0+IFBhc3RlUnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBQcm9zZU1pcnJvciBwbHVnaW5zXG4gICAgICovXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkUHJvc2VNaXJyb3JQbHVnaW5zJ11cbiAgICB9KSA9PiBQbHVnaW5bXVxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5zaW9uc1xuICAgICAqL1xuICAgIGFkZEV4dGVuc2lvbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkRXh0ZW5zaW9ucyddXG4gICAgfSkgPT4gRXh0ZW5zaW9uc1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIE5vZGUgU2NoZW1hXG4gICAgICovXG4gICAgZXh0ZW5kTm9kZVNjaGVtYT86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXh0ZW5kTm9kZVNjaGVtYSddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE5vZGUsXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIE1hcmsgU2NoZW1hXG4gICAgICovXG4gICAgZXh0ZW5kTWFya1NjaGVtYT86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXh0ZW5kTWFya1NjaGVtYSddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE1hcmssXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBub3QgcmVhZHkgeWV0LlxuICAgICAqL1xuICAgIG9uQmVmb3JlQ3JlYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQmVmb3JlQ3JlYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyByZWFkeS5cbiAgICAgKi9cbiAgICBvbkNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZW50IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVXBkYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uVXBkYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGlvbiBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblNlbGVjdGlvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblNlbGVjdGlvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3Igc3RhdGUgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25UcmFuc2FjdGlvbj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblRyYW5zYWN0aW9uJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25cbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgICAgKi9cbiAgICBvbkZvY3VzPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uRm9jdXMnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzbuKAmXQgZm9jdXNlZCBhbnltb3JlLlxuICAgICAqL1xuICAgIG9uQmx1cj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJsdXInXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBvbkRlc3Ryb3k/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25EZXN0cm95J11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogS2VlcCBtYXJrIGFmdGVyIHNwbGl0IG5vZGVcbiAgICAgKi9cbiAgICBrZWVwT25TcGxpdD86IGJvb2xlYW4gfCAoKCkgPT4gYm9vbGVhbilcblxuICAgIC8qKlxuICAgICAqIEluY2x1c2l2ZVxuICAgICAqL1xuICAgIGluY2x1c2l2ZT86XG4gICAgICB8IE1hcmtTcGVjWydpbmNsdXNpdmUnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydpbmNsdXNpdmUnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBNYXJrU3BlY1snaW5jbHVzaXZlJ10pXG5cbiAgICAvKipcbiAgICAgKiBFeGNsdWRlc1xuICAgICAqL1xuICAgIGV4Y2x1ZGVzPzpcbiAgICAgIHwgTWFya1NwZWNbJ2V4Y2x1ZGVzJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXhjbHVkZXMnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBNYXJrU3BlY1snZXhjbHVkZXMnXSlcblxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoaXMgTWFyayBhcyBleGl0YWJsZVxuICAgICAqL1xuICAgIGV4aXRhYmxlPzogYm9vbGVhbiB8ICgoKSA9PiBib29sZWFuKVxuXG4gICAgLyoqXG4gICAgICogR3JvdXBcbiAgICAgKi9cbiAgICBncm91cD86XG4gICAgICB8IE1hcmtTcGVjWydncm91cCddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2dyb3VwJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTWFya1NwZWNbJ2dyb3VwJ10pXG5cbiAgICAvKipcbiAgICAgKiBTcGFubmluZ1xuICAgICAqL1xuICAgIHNwYW5uaW5nPzpcbiAgICAgIHwgTWFya1NwZWNbJ3NwYW5uaW5nJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnc3Bhbm5pbmcnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBNYXJrU3BlY1snc3Bhbm5pbmcnXSlcblxuICAgIC8qKlxuICAgICAqIENvZGVcbiAgICAgKi9cbiAgICBjb2RlPzpcbiAgICAgIHwgYm9vbGVhblxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydjb2RlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gYm9vbGVhbilcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIEhUTUxcbiAgICAgKi9cbiAgICBwYXJzZUhUTUw/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsncGFyc2VIVE1MJ11cbiAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgIH0pID0+IE1hcmtTcGVjWydwYXJzZURPTSddXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgSFRNTFxuICAgICAqL1xuICAgIHJlbmRlckhUTUw/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3JlbmRlckhUTUwnXVxuICAgICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgbWFyazogUHJvc2VNaXJyb3JNYXJrXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gRE9NT3V0cHV0U3BlYylcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlc1xuICAgICAqL1xuICAgIGFkZEF0dHJpYnV0ZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkQXR0cmlidXRlcyddXG4gICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICB9KSA9PiBBdHRyaWJ1dGVzIHwge31cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWFyazxPcHRpb25zID0gYW55LCBTdG9yYWdlID0gYW55PiB7XG4gIHR5cGUgPSAnbWFyaydcblxuICBuYW1lID0gJ21hcmsnXG5cbiAgcGFyZW50OiBNYXJrIHwgbnVsbCA9IG51bGxcblxuICBjaGlsZDogTWFyayB8IG51bGwgPSBudWxsXG5cbiAgb3B0aW9uczogT3B0aW9uc1xuXG4gIHN0b3JhZ2U6IFN0b3JhZ2VcblxuICBjb25maWc6IE1hcmtDb25maWcgPSB7XG4gICAgbmFtZTogdGhpcy5uYW1lLFxuICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogUGFydGlhbDxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PiA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIC4uLmNvbmZpZyxcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lXG5cbiAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5jb25maWcuZGVmYXVsdE9wdGlvbnNcblxuICAgIGlmICh0aGlzLmNvbmZpZy5hZGRPcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPih0aGlzLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPih0aGlzLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApIHx8IHt9XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlPE8gPSBhbnksIFMgPSBhbnk+KGNvbmZpZzogUGFydGlhbDxNYXJrQ29uZmlnPE8sIFM+PiA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrPE8sIFM+KGNvbmZpZylcbiAgfVxuXG4gIGNvbmZpZ3VyZShvcHRpb25zOiBQYXJ0aWFsPE9wdGlvbnM+ID0ge30pIHtcbiAgICAvLyByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBleHRlbnNpb25cbiAgICAvLyB3aXRoIGRpZmZlcmVudCBjYWxscyBvZiBgY29uZmlndXJlYFxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5kKClcblxuICAgIGV4dGVuc2lvbi5vcHRpb25zID0gbWVyZ2VEZWVwKHRoaXMub3B0aW9ucyBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBvcHRpb25zKSBhcyBPcHRpb25zXG5cbiAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPihleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uXG4gIH1cblxuICBleHRlbmQ8RXh0ZW5kZWRPcHRpb25zID0gT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlID0gU3RvcmFnZT4oXG4gICAgZXh0ZW5kZWRDb25maWc6IFBhcnRpYWw8TWFya0NvbmZpZzxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4+ID0ge30sXG4gICkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBNYXJrPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPih7IC4uLnRoaXMuY29uZmlnLCAuLi5leHRlbmRlZENvbmZpZyB9KVxuXG4gICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXNcblxuICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb25cblxuICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWVcblxuICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHtleHRlbnNpb24ubmFtZX1cIi5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRPcHRpb25zJ10+KGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG5cbiAgc3RhdGljIGhhbmRsZUV4aXQoeyBlZGl0b3IsIG1hcmsgfTogeyBlZGl0b3I6IEVkaXRvcjsgbWFyazogTWFyayB9KSB7XG4gICAgY29uc3QgeyB0ciB9ID0gZWRpdG9yLnN0YXRlXG4gICAgY29uc3QgY3VycmVudFBvcyA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uJGZyb21cbiAgICBjb25zdCBpc0F0RW5kID0gY3VycmVudFBvcy5wb3MgPT09IGN1cnJlbnRQb3MuZW5kKClcblxuICAgIGlmIChpc0F0RW5kKSB7XG4gICAgICBjb25zdCBjdXJyZW50TWFya3MgPSBjdXJyZW50UG9zLm1hcmtzKClcbiAgICAgIGNvbnN0IGlzSW5NYXJrID0gISFjdXJyZW50TWFya3MuZmluZChtID0+IG0/LnR5cGUubmFtZSA9PT0gbWFyay5uYW1lKVxuXG4gICAgICBpZiAoIWlzSW5NYXJrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZW1vdmVNYXJrID0gY3VycmVudE1hcmtzLmZpbmQobSA9PiBtPy50eXBlLm5hbWUgPT09IG1hcmsubmFtZSlcblxuICAgICAgaWYgKHJlbW92ZU1hcmspIHtcbiAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhyZW1vdmVNYXJrKVxuICAgICAgfVxuICAgICAgdHIuaW5zZXJ0VGV4dCgnICcsIGN1cnJlbnRQb3MucG9zKVxuXG4gICAgICBlZGl0b3Iudmlldy5kaXNwYXRjaCh0cilcblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIERPTU91dHB1dFNwZWMsIE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBOb2RlU3BlYywgTm9kZVR5cGUsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IE5vZGVDb25maWcgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHsgSW5wdXRSdWxlIH0gZnJvbSAnLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBQYXN0ZVJ1bGUgfSBmcm9tICcuL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7XG4gIEFueUNvbmZpZyxcbiAgQXR0cmlidXRlcyxcbiAgRXh0ZW5zaW9ucyxcbiAgR2xvYmFsQXR0cmlidXRlcyxcbiAgS2V5Ym9hcmRTaG9ydGN1dENvbW1hbmQsXG4gIE5vZGVWaWV3UmVuZGVyZXIsXG4gIFBhcmVudENvbmZpZyxcbiAgUmF3Q29tbWFuZHMsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBtZXJnZURlZXAgfSBmcm9tICcuL3V0aWxpdGllcy9tZXJnZURlZXAuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIE5vZGVDb25maWc8T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICAgIFtrZXk6IHN0cmluZ106IGFueVxuXG4gICAgLyoqXG4gICAgICogTmFtZVxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZ1xuXG4gICAgLyoqXG4gICAgICogUHJpb3JpdHlcbiAgICAgKi9cbiAgICBwcmlvcml0eT86IG51bWJlclxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBvcHRpb25zXG4gICAgICovXG4gICAgZGVmYXVsdE9wdGlvbnM/OiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IE9wdGlvbnNcbiAgICAgKi9cbiAgICBhZGRPcHRpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkT3B0aW9ucyddLCB1bmRlZmluZWQ+XG4gICAgfSkgPT4gT3B0aW9uc1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBTdG9yYWdlXG4gICAgICovXG4gICAgYWRkU3RvcmFnZT86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHBhcmVudDogRXhjbHVkZTxQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFN0b3JhZ2UnXSwgdW5kZWZpbmVkPlxuICAgIH0pID0+IFN0b3JhZ2VcblxuICAgIC8qKlxuICAgICAqIEdsb2JhbCBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgYWRkR2xvYmFsQXR0cmlidXRlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRHbG9iYWxBdHRyaWJ1dGVzJ11cbiAgICB9KSA9PiBHbG9iYWxBdHRyaWJ1dGVzIHwge31cblxuICAgIC8qKlxuICAgICAqIFJhd1xuICAgICAqL1xuICAgIGFkZENvbW1hbmRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkQ29tbWFuZHMnXVxuICAgIH0pID0+IFBhcnRpYWw8UmF3Q29tbWFuZHM+XG5cbiAgICAvKipcbiAgICAgKiBLZXlib2FyZCBzaG9ydGN1dHNcbiAgICAgKi9cbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEtleWJvYXJkU2hvcnRjdXRzJ11cbiAgICB9KSA9PiB7XG4gICAgICBba2V5OiBzdHJpbmddOiBLZXlib2FyZFNob3J0Y3V0Q29tbWFuZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElucHV0IHJ1bGVzXG4gICAgICovXG4gICAgYWRkSW5wdXRSdWxlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZElucHV0UnVsZXMnXVxuICAgIH0pID0+IElucHV0UnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBQYXN0ZSBydWxlc1xuICAgICAqL1xuICAgIGFkZFBhc3RlUnVsZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRQYXN0ZVJ1bGVzJ11cbiAgICB9KSA9PiBQYXN0ZVJ1bGVbXVxuXG4gICAgLyoqXG4gICAgICogUHJvc2VNaXJyb3IgcGx1Z2luc1xuICAgICAqL1xuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFByb3NlTWlycm9yUGx1Z2lucyddXG4gICAgfSkgPT4gUGx1Z2luW11cblxuICAgIC8qKlxuICAgICAqIEV4dGVuc2lvbnNcbiAgICAgKi9cbiAgICBhZGRFeHRlbnNpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEV4dGVuc2lvbnMnXVxuICAgIH0pID0+IEV4dGVuc2lvbnNcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBOb2RlIFNjaGVtYVxuICAgICAqL1xuICAgIGV4dGVuZE5vZGVTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE5vZGVTY2hlbWEnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBOb2RlLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBNYXJrIFNjaGVtYVxuICAgICAqL1xuICAgIGV4dGVuZE1hcmtTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE1hcmtTY2hlbWEnXVxuICAgICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE5vZGUsXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBub3QgcmVhZHkgeWV0LlxuICAgICAqL1xuICAgIG9uQmVmb3JlQ3JlYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQmVmb3JlQ3JlYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyByZWFkeS5cbiAgICAgKi9cbiAgICBvbkNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZW50IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVXBkYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uVXBkYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGlvbiBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblNlbGVjdGlvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblNlbGVjdGlvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3Igc3RhdGUgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25UcmFuc2FjdGlvbj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblRyYW5zYWN0aW9uJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25cbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgICAgKi9cbiAgICBvbkZvY3VzPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uRm9jdXMnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzbuKAmXQgZm9jdXNlZCBhbnltb3JlLlxuICAgICAqL1xuICAgIG9uQmx1cj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJsdXInXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBvbkRlc3Ryb3k/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25EZXN0cm95J11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogTm9kZSBWaWV3XG4gICAgICovXG4gICAgYWRkTm9kZVZpZXc/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkTm9kZVZpZXcnXVxuICAgICAgICB9KSA9PiBOb2RlVmlld1JlbmRlcmVyKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUb3BOb2RlXG4gICAgICovXG4gICAgdG9wTm9kZT86IGJvb2xlYW5cblxuICAgIC8qKlxuICAgICAqIENvbnRlbnRcbiAgICAgKi9cbiAgICBjb250ZW50PzpcbiAgICAgIHwgTm9kZVNwZWNbJ2NvbnRlbnQnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydjb250ZW50J11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2NvbnRlbnQnXSlcblxuICAgIC8qKlxuICAgICAqIE1hcmtzXG4gICAgICovXG4gICAgbWFya3M/OlxuICAgICAgfCBOb2RlU3BlY1snbWFya3MnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydtYXJrcyddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydtYXJrcyddKVxuXG4gICAgLyoqXG4gICAgICogR3JvdXBcbiAgICAgKi9cbiAgICBncm91cD86XG4gICAgICB8IE5vZGVTcGVjWydncm91cCddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2dyb3VwJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2dyb3VwJ10pXG5cbiAgICAvKipcbiAgICAgKiBJbmxpbmVcbiAgICAgKi9cbiAgICBpbmxpbmU/OlxuICAgICAgfCBOb2RlU3BlY1snaW5saW5lJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnaW5saW5lJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2lubGluZSddKVxuXG4gICAgLyoqXG4gICAgICogQXRvbVxuICAgICAqL1xuICAgIGF0b20/OlxuICAgICAgfCBOb2RlU3BlY1snYXRvbSddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2F0b20nXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snYXRvbSddKVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0YWJsZVxuICAgICAqL1xuICAgIHNlbGVjdGFibGU/OlxuICAgICAgfCBOb2RlU3BlY1snc2VsZWN0YWJsZSddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3NlbGVjdGFibGUnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snc2VsZWN0YWJsZSddKVxuXG4gICAgLyoqXG4gICAgICogRHJhZ2dhYmxlXG4gICAgICovXG4gICAgZHJhZ2dhYmxlPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2RyYWdnYWJsZSddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2RyYWdnYWJsZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydkcmFnZ2FibGUnXSlcblxuICAgIC8qKlxuICAgICAqIENvZGVcbiAgICAgKi9cbiAgICBjb2RlPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2NvZGUnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydjb2RlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2NvZGUnXSlcblxuICAgIC8qKlxuICAgICAqIFdoaXRlc3BhY2VcbiAgICAgKi9cbiAgICB3aGl0ZXNwYWNlPzpcbiAgICAgIHwgTm9kZVNwZWNbJ3doaXRlc3BhY2UnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wyd3aGl0ZXNwYWNlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ3doaXRlc3BhY2UnXSlcblxuICAgIC8qKlxuICAgICAqIERlZmluaW5nXG4gICAgICovXG4gICAgZGVmaW5pbmc/OlxuICAgICAgfCBOb2RlU3BlY1snZGVmaW5pbmcnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydkZWZpbmluZyddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydkZWZpbmluZyddKVxuXG4gICAgLyoqXG4gICAgICogSXNvbGF0aW5nXG4gICAgICovXG4gICAgaXNvbGF0aW5nPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2lzb2xhdGluZyddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2lzb2xhdGluZyddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydpc29sYXRpbmcnXSlcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIEhUTUxcbiAgICAgKi9cbiAgICBwYXJzZUhUTUw/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsncGFyc2VIVE1MJ11cbiAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgIH0pID0+IE5vZGVTcGVjWydwYXJzZURPTSddXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgSFRNTFxuICAgICAqL1xuICAgIHJlbmRlckhUTUw/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3JlbmRlckhUTUwnXVxuICAgICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgbm9kZTogUHJvc2VNaXJyb3JOb2RlXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gRE9NT3V0cHV0U3BlYylcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIFRleHRcbiAgICAgKi9cbiAgICByZW5kZXJUZXh0PzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydyZW5kZXJUZXh0J11cbiAgICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIG5vZGU6IFByb3NlTWlycm9yTm9kZVxuICAgICAgICAgICAgcG9zOiBudW1iZXJcbiAgICAgICAgICAgIHBhcmVudDogUHJvc2VNaXJyb3JOb2RlXG4gICAgICAgICAgICBpbmRleDogbnVtYmVyXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiBzdHJpbmcpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEFkZCBBdHRyaWJ1dGVzXG4gICAgICovXG4gICAgYWRkQXR0cmlidXRlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRBdHRyaWJ1dGVzJ11cbiAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgIH0pID0+IEF0dHJpYnV0ZXMgfCB7fVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOb2RlPE9wdGlvbnMgPSBhbnksIFN0b3JhZ2UgPSBhbnk+IHtcbiAgdHlwZSA9ICdub2RlJ1xuXG4gIG5hbWUgPSAnbm9kZSdcblxuICBwYXJlbnQ6IE5vZGUgfCBudWxsID0gbnVsbFxuXG4gIGNoaWxkOiBOb2RlIHwgbnVsbCA9IG51bGxcblxuICBvcHRpb25zOiBPcHRpb25zXG5cbiAgc3RvcmFnZTogU3RvcmFnZVxuXG4gIGNvbmZpZzogTm9kZUNvbmZpZyA9IHtcbiAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxuICB9XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBQYXJ0aWFsPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+ID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgLi4uY29uZmlnLFxuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uZmlnLm5hbWVcblxuICAgIGlmIChjb25maWcuZGVmYXVsdE9wdGlvbnMgJiYgT2JqZWN0LmtleXMoY29uZmlnLmRlZmF1bHRPcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke3RoaXMubmFtZX1cIi5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSBgYWRkT3B0aW9uc2AgZmFsbGJhY2tcbiAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0T3B0aW9uc1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmFkZE9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IGNhbGxPclJldHVybihcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRPcHRpb25zJ10+KHRoaXMsICdhZGRPcHRpb25zJywge1xuICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgfSksXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KHRoaXMsICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgICkgfHwge31cbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGU8TyA9IGFueSwgUyA9IGFueT4oY29uZmlnOiBQYXJ0aWFsPE5vZGVDb25maWc8TywgUz4+ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IE5vZGU8TywgUz4oY29uZmlnKVxuICB9XG5cbiAgY29uZmlndXJlKG9wdGlvbnM6IFBhcnRpYWw8T3B0aW9ucz4gPSB7fSkge1xuICAgIC8vIHJldHVybiBhIG5ldyBpbnN0YW5jZSBzbyB3ZSBjYW4gdXNlIHRoZSBzYW1lIGV4dGVuc2lvblxuICAgIC8vIHdpdGggZGlmZmVyZW50IGNhbGxzIG9mIGBjb25maWd1cmVgXG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5leHRlbmQoKVxuXG4gICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBtZXJnZURlZXAodGhpcy5vcHRpb25zIGFzIFJlY29yZDxzdHJpbmcsIGFueT4sIG9wdGlvbnMpIGFzIE9wdGlvbnNcblxuICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIHJldHVybiBleHRlbnNpb25cbiAgfVxuXG4gIGV4dGVuZDxFeHRlbmRlZE9wdGlvbnMgPSBPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2UgPSBTdG9yYWdlPihcbiAgICBleHRlbmRlZENvbmZpZzogUGFydGlhbDxOb2RlQ29uZmlnPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPj4gPSB7fSxcbiAgKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IE5vZGU8RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+KHsgLi4udGhpcy5jb25maWcsIC4uLmV4dGVuZGVkQ29uZmlnIH0pXG5cbiAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpc1xuXG4gICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvblxuXG4gICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZVxuXG4gICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke2V4dGVuc2lvbi5uYW1lfVwiLmAsXG4gICAgICApXG4gICAgfVxuXG4gICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZE9wdGlvbnMnXT4oZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPihleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uXG4gIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNBbmRyb2lkKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gbmF2aWdhdG9yLnBsYXRmb3JtID09PSAnQW5kcm9pZCcgfHwgL2FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBOb2RlVmlldyBhcyBQcm9zZU1pcnJvck5vZGVWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuXG5pbXBvcnQgeyBFZGl0b3IgYXMgQ29yZUVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vTm9kZS5qcydcbmltcG9ydCB7IERlY29yYXRpb25XaXRoVHlwZSwgTm9kZVZpZXdSZW5kZXJlck9wdGlvbnMsIE5vZGVWaWV3UmVuZGVyZXJQcm9wcyB9IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc0FuZHJvaWQgfSBmcm9tICcuL3V0aWxpdGllcy9pc0FuZHJvaWQuanMnXG5pbXBvcnQgeyBpc2lPUyB9IGZyb20gJy4vdXRpbGl0aWVzL2lzaU9TLmpzJ1xuXG5leHBvcnQgY2xhc3MgTm9kZVZpZXc8XG4gIENvbXBvbmVudCxcbiAgTm9kZUVkaXRvciBleHRlbmRzIENvcmVFZGl0b3IgPSBDb3JlRWRpdG9yLFxuICBPcHRpb25zIGV4dGVuZHMgTm9kZVZpZXdSZW5kZXJlck9wdGlvbnMgPSBOb2RlVmlld1JlbmRlcmVyT3B0aW9ucyxcbj4gaW1wbGVtZW50cyBQcm9zZU1pcnJvck5vZGVWaWV3IHtcbiAgY29tcG9uZW50OiBDb21wb25lbnRcblxuICBlZGl0b3I6IE5vZGVFZGl0b3JcblxuICBvcHRpb25zOiBPcHRpb25zXG5cbiAgZXh0ZW5zaW9uOiBOb2RlXG5cbiAgbm9kZTogUHJvc2VNaXJyb3JOb2RlXG5cbiAgZGVjb3JhdGlvbnM6IERlY29yYXRpb25XaXRoVHlwZVtdXG5cbiAgZ2V0UG9zOiBhbnlcblxuICBpc0RyYWdnaW5nID0gZmFsc2VcblxuICBjb25zdHJ1Y3Rvcihjb21wb25lbnQ6IENvbXBvbmVudCwgcHJvcHM6IE5vZGVWaWV3UmVuZGVyZXJQcm9wcywgb3B0aW9ucz86IFBhcnRpYWw8T3B0aW9ucz4pIHtcbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudFxuICAgIHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yIGFzIE5vZGVFZGl0b3JcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBzdG9wRXZlbnQ6IG51bGwsXG4gICAgICBpZ25vcmVNdXRhdGlvbjogbnVsbCxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSBhcyBPcHRpb25zXG4gICAgdGhpcy5leHRlbnNpb24gPSBwcm9wcy5leHRlbnNpb25cbiAgICB0aGlzLm5vZGUgPSBwcm9wcy5ub2RlXG4gICAgdGhpcy5kZWNvcmF0aW9ucyA9IHByb3BzLmRlY29yYXRpb25zIGFzIERlY29yYXRpb25XaXRoVHlwZVtdXG4gICAgdGhpcy5nZXRQb3MgPSBwcm9wcy5nZXRQb3NcbiAgICB0aGlzLm1vdW50KClcbiAgfVxuXG4gIG1vdW50KCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHJldHVyblxuICB9XG5cbiAgZ2V0IGRvbSgpOiBIVE1MRWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tIGFzIEhUTUxFbGVtZW50XG4gIH1cblxuICBnZXQgY29udGVudERPTSgpOiBIVE1MRWxlbWVudCB8IG51bGwge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBvbkRyYWdTdGFydChldmVudDogRHJhZ0V2ZW50KSB7XG4gICAgY29uc3QgeyB2aWV3IH0gPSB0aGlzLmVkaXRvclxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuXG4gICAgLy8gZ2V0IHRoZSBkcmFnIGhhbmRsZSBlbGVtZW50XG4gICAgLy8gYGNsb3Nlc3RgIGlzIG5vdCBhdmFpbGFibGUgZm9yIHRleHQgbm9kZXMgc28gd2UgbWF5IGhhdmUgdG8gdXNlIGl0cyBwYXJlbnRcbiAgICBjb25zdCBkcmFnSGFuZGxlID0gdGFyZ2V0Lm5vZGVUeXBlID09PSAzXG4gICAgICA/IHRhcmdldC5wYXJlbnRFbGVtZW50Py5jbG9zZXN0KCdbZGF0YS1kcmFnLWhhbmRsZV0nKVxuICAgICAgOiB0YXJnZXQuY2xvc2VzdCgnW2RhdGEtZHJhZy1oYW5kbGVdJylcblxuICAgIGlmICghdGhpcy5kb20gfHwgdGhpcy5jb250ZW50RE9NPy5jb250YWlucyh0YXJnZXQpIHx8ICFkcmFnSGFuZGxlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgeCA9IDBcbiAgICBsZXQgeSA9IDBcblxuICAgIC8vIGNhbGN1bGF0ZSBvZmZzZXQgZm9yIGRyYWcgZWxlbWVudCBpZiB3ZSB1c2UgYSBkaWZmZXJlbnQgZHJhZyBoYW5kbGUgZWxlbWVudFxuICAgIGlmICh0aGlzLmRvbSAhPT0gZHJhZ0hhbmRsZSkge1xuICAgICAgY29uc3QgZG9tQm94ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGNvbnN0IGhhbmRsZUJveCA9IGRyYWdIYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICAgICAgLy8gSW4gUmVhY3QsIHdlIGhhdmUgdG8gZ28gdGhyb3VnaCBuYXRpdmVFdmVudCB0byByZWFjaCBvZmZzZXRYL29mZnNldFkuXG4gICAgICBjb25zdCBvZmZzZXRYID0gZXZlbnQub2Zmc2V0WCA/PyAoZXZlbnQgYXMgYW55KS5uYXRpdmVFdmVudD8ub2Zmc2V0WFxuICAgICAgY29uc3Qgb2Zmc2V0WSA9IGV2ZW50Lm9mZnNldFkgPz8gKGV2ZW50IGFzIGFueSkubmF0aXZlRXZlbnQ/Lm9mZnNldFlcblxuICAgICAgeCA9IGhhbmRsZUJveC54IC0gZG9tQm94LnggKyBvZmZzZXRYXG4gICAgICB5ID0gaGFuZGxlQm94LnkgLSBkb21Cb3gueSArIG9mZnNldFlcbiAgICB9XG5cbiAgICBldmVudC5kYXRhVHJhbnNmZXI/LnNldERyYWdJbWFnZSh0aGlzLmRvbSwgeCwgeSlcblxuICAgIC8vIHdlIG5lZWQgdG8gdGVsbCBQcm9zZU1pcnJvciB0aGF0IHdlIHdhbnQgdG8gbW92ZSB0aGUgd2hvbGUgbm9kZVxuICAgIC8vIHNvIHdlIGNyZWF0ZSBhIE5vZGVTZWxlY3Rpb25cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgdGhpcy5nZXRQb3MoKSlcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbilcblxuICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pXG4gIH1cblxuICBzdG9wRXZlbnQoZXZlbnQ6IEV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc3RvcEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnN0b3BFdmVudCh7IGV2ZW50IH0pXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG4gICAgY29uc3QgaXNJbkVsZW1lbnQgPSB0aGlzLmRvbS5jb250YWlucyh0YXJnZXQpICYmICF0aGlzLmNvbnRlbnRET00/LmNvbnRhaW5zKHRhcmdldClcblxuICAgIC8vIGFueSBldmVudCBmcm9tIGNoaWxkIG5vZGVzIHNob3VsZCBiZSBoYW5kbGVkIGJ5IFByb3NlTWlycm9yXG4gICAgaWYgKCFpc0luRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgaXNEcmFnRXZlbnQgPSBldmVudC50eXBlLnN0YXJ0c1dpdGgoJ2RyYWcnKVxuICAgIGNvbnN0IGlzRHJvcEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2Ryb3AnXG4gICAgY29uc3QgaXNJbnB1dCA9IFsnSU5QVVQnLCAnQlVUVE9OJywgJ1NFTEVDVCcsICdURVhUQVJFQSddLmluY2x1ZGVzKHRhcmdldC50YWdOYW1lKSB8fCB0YXJnZXQuaXNDb250ZW50RWRpdGFibGVcblxuICAgIC8vIGFueSBpbnB1dCBldmVudCB3aXRoaW4gbm9kZSB2aWV3cyBzaG91bGQgYmUgaWdub3JlZCBieSBQcm9zZU1pcnJvclxuICAgIGlmIChpc0lucHV0ICYmICFpc0Ryb3BFdmVudCAmJiAhaXNEcmFnRXZlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgeyBpc0VkaXRhYmxlIH0gPSB0aGlzLmVkaXRvclxuICAgIGNvbnN0IHsgaXNEcmFnZ2luZyB9ID0gdGhpc1xuICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gISF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZVxuICAgIGNvbnN0IGlzU2VsZWN0YWJsZSA9IE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKHRoaXMubm9kZSlcbiAgICBjb25zdCBpc0NvcHlFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdjb3B5J1xuICAgIGNvbnN0IGlzUGFzdGVFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdwYXN0ZSdcbiAgICBjb25zdCBpc0N1dEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2N1dCdcbiAgICBjb25zdCBpc0NsaWNrRXZlbnQgPSBldmVudC50eXBlID09PSAnbW91c2Vkb3duJ1xuXG4gICAgLy8gUHJvc2VNaXJyb3IgdHJpZXMgdG8gZHJhZyBzZWxlY3RhYmxlIG5vZGVzXG4gICAgLy8gZXZlbiBpZiBgZHJhZ2dhYmxlYCBpcyBzZXQgdG8gYGZhbHNlYFxuICAgIC8vIHRoaXMgZml4IHByZXZlbnRzIHRoYXRcbiAgICBpZiAoIWlzRHJhZ2dhYmxlICYmIGlzU2VsZWN0YWJsZSAmJiBpc0RyYWdFdmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIH1cblxuICAgIGlmIChpc0RyYWdnYWJsZSAmJiBpc0RyYWdFdmVudCAmJiAhaXNEcmFnZ2luZykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gd2UgaGF2ZSB0byBzdG9yZSB0aGF0IGRyYWdnaW5nIHN0YXJ0ZWRcbiAgICBpZiAoaXNEcmFnZ2FibGUgJiYgaXNFZGl0YWJsZSAmJiAhaXNEcmFnZ2luZyAmJiBpc0NsaWNrRXZlbnQpIHtcbiAgICAgIGNvbnN0IGRyYWdIYW5kbGUgPSB0YXJnZXQuY2xvc2VzdCgnW2RhdGEtZHJhZy1oYW5kbGVdJylcbiAgICAgIGNvbnN0IGlzVmFsaWREcmFnSGFuZGxlID0gZHJhZ0hhbmRsZSAmJiAodGhpcy5kb20gPT09IGRyYWdIYW5kbGUgfHwgdGhpcy5kb20uY29udGFpbnMoZHJhZ0hhbmRsZSkpXG5cbiAgICAgIGlmIChpc1ZhbGlkRHJhZ0hhbmRsZSkge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlXG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAnZHJhZ2VuZCcsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICAgICApXG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAnZHJvcCcsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICAgICApXG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAnbW91c2V1cCcsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhlc2UgZXZlbnRzIGFyZSBoYW5kbGVkIGJ5IHByb3NlbWlycm9yXG4gICAgaWYgKFxuICAgICAgaXNEcmFnZ2luZ1xuICAgICAgfHwgaXNEcm9wRXZlbnRcbiAgICAgIHx8IGlzQ29weUV2ZW50XG4gICAgICB8fCBpc1Bhc3RlRXZlbnRcbiAgICAgIHx8IGlzQ3V0RXZlbnRcbiAgICAgIHx8IChpc0NsaWNrRXZlbnQgJiYgaXNTZWxlY3RhYmxlKVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uOiBNdXRhdGlvblJlY29yZCB8IHsgdHlwZTogJ3NlbGVjdGlvbic7IHRhcmdldDogRWxlbWVudCB9KSB7XG4gICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmlnbm9yZU11dGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlnbm9yZU11dGF0aW9uKHsgbXV0YXRpb24gfSlcbiAgICB9XG5cbiAgICAvLyBhIGxlYWYvYXRvbSBub2RlIGlzIGxpa2UgYSBibGFjayBib3ggZm9yIFByb3NlTWlycm9yXG4gICAgLy8gYW5kIHNob3VsZCBiZSBmdWxseSBoYW5kbGVkIGJ5IHRoZSBub2RlIHZpZXdcbiAgICBpZiAodGhpcy5ub2RlLmlzTGVhZiB8fCB0aGlzLm5vZGUuaXNBdG9tKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFByb3NlTWlycm9yIHNob3VsZCBoYW5kbGUgYW55IHNlbGVjdGlvbnNcbiAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ3NlbGVjdGlvbicpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIHRyeSB0byBwcmV2ZW50IGEgYnVnIG9uIGlPUyBhbmQgQW5kcm9pZCB0aGF0IHdpbGwgYnJlYWsgbm9kZSB2aWV3cyBvbiBlbnRlclxuICAgIC8vIHRoaXMgaXMgYmVjYXVzZSBQcm9zZU1pcnJvciBjYW7igJl0IHByZXZlbnREaXNwYXRjaCBvbiBlbnRlclxuICAgIC8vIHRoaXMgd2lsbCBsZWFkIHRvIGEgcmUtcmVuZGVyIG9mIHRoZSBub2RlIHZpZXcgb24gZW50ZXJcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMTIxNFxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8yNTM0XG4gICAgaWYgKFxuICAgICAgdGhpcy5kb20uY29udGFpbnMobXV0YXRpb24udGFyZ2V0KVxuICAgICAgJiYgbXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCdcbiAgICAgICYmIChpc2lPUygpIHx8IGlzQW5kcm9pZCgpKVxuICAgICAgJiYgdGhpcy5lZGl0b3IuaXNGb2N1c2VkXG4gICAgKSB7XG4gICAgICBjb25zdCBjaGFuZ2VkTm9kZXMgPSBbXG4gICAgICAgIC4uLkFycmF5LmZyb20obXV0YXRpb24uYWRkZWROb2RlcyksXG4gICAgICAgIC4uLkFycmF5LmZyb20obXV0YXRpb24ucmVtb3ZlZE5vZGVzKSxcbiAgICAgIF0gYXMgSFRNTEVsZW1lbnRbXVxuXG4gICAgICAvLyB3ZeKAmWxsIGNoZWNrIGlmIGV2ZXJ5IGNoYW5nZWQgbm9kZSBpcyBjb250ZW50RWRpdGFibGVcbiAgICAgIC8vIHRvIG1ha2Ugc3VyZSBpdOKAmXMgcHJvYmFibHkgbXV0YXRlZCBieSBQcm9zZU1pcnJvclxuICAgICAgaWYgKGNoYW5nZWROb2Rlcy5ldmVyeShub2RlID0+IG5vZGUuaXNDb250ZW50RWRpdGFibGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdlIHdpbGwgYWxsb3cgbXV0YXRpb24gY29udGVudERPTSB3aXRoIGF0dHJpYnV0ZXNcbiAgICAvLyBzbyB3ZSBjYW4gZm9yIGV4YW1wbGUgYWRkaW5nIGNsYXNzZXMgd2l0aGluIG91ciBub2RlIHZpZXdcbiAgICBpZiAodGhpcy5jb250ZW50RE9NID09PSBtdXRhdGlvbi50YXJnZXQgJiYgbXV0YXRpb24udHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFByb3NlTWlycm9yIHNob3VsZCBoYW5kbGUgYW55IGNoYW5nZXMgd2l0aGluIGNvbnRlbnRET01cbiAgICBpZiAodGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB1cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXM6IHt9KSB7XG4gICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICBjb25zdCBwb3MgPSB0aGlzLmdldFBvcygpXG5cbiAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB1bmRlZmluZWQsIHtcbiAgICAgICAgLi4udGhpcy5ub2RlLmF0dHJzLFxuICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuICB9XG5cbiAgZGVsZXRlTm9kZSgpOiB2b2lkIHtcbiAgICBjb25zdCBmcm9tID0gdGhpcy5nZXRQb3MoKVxuICAgIGNvbnN0IHRvID0gZnJvbSArIHRoaXMubm9kZS5ub2RlU2l6ZVxuXG4gICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuZGVsZXRlUmFuZ2UoeyBmcm9tLCB0byB9KVxuICB9XG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrc0JldHdlZW4gfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtzQmV0d2Vlbi5qcydcbmltcG9ydCB7IFBhc3RlUnVsZSwgUGFzdGVSdWxlRmluZGVyIH0gZnJvbSAnLi4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCBhZGRzIGEgbWFyayB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHBhc3RlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFya1Bhc3RlUnVsZShjb25maWc6IHtcbiAgZmluZDogUGFzdGVSdWxlRmluZGVyXG4gIHR5cGU6IE1hcmtUeXBlXG4gIGdldEF0dHJpYnV0ZXM/OlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5LCBldmVudDogQ2xpcGJvYXJkRXZlbnQpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgfCBmYWxzZVxuICAgIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHtcbiAgICAgIHN0YXRlLCByYW5nZSwgbWF0Y2gsIHBhc3RlRXZlbnQsXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCwgcGFzdGVFdmVudClcblxuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGVcbiAgICAgIGNvbnN0IGNhcHR1cmVHcm91cCA9IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdXG4gICAgICBjb25zdCBmdWxsTWF0Y2ggPSBtYXRjaFswXVxuICAgICAgbGV0IG1hcmtFbmQgPSByYW5nZS50b1xuXG4gICAgICBpZiAoY2FwdHVyZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLylcbiAgICAgICAgY29uc3QgdGV4dFN0YXJ0ID0gcmFuZ2UuZnJvbSArIGZ1bGxNYXRjaC5pbmRleE9mKGNhcHR1cmVHcm91cClcbiAgICAgICAgY29uc3QgdGV4dEVuZCA9IHRleHRTdGFydCArIGNhcHR1cmVHcm91cC5sZW5ndGhcblxuICAgICAgICBjb25zdCBleGNsdWRlZE1hcmtzID0gZ2V0TWFya3NCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCBzdGF0ZS5kb2MpXG4gICAgICAgICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gaXRlbS5tYXJrLnR5cGUuZXhjbHVkZWQgYXMgTWFya1R5cGVbXVxuXG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCh0eXBlID0+IHR5cGUgPT09IGNvbmZpZy50eXBlICYmIHR5cGUgIT09IGl0ZW0ubWFyay50eXBlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0udG8gPiB0ZXh0U3RhcnQpXG5cbiAgICAgICAgaWYgKGV4Y2x1ZGVkTWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0RW5kIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICB0ci5kZWxldGUodGV4dEVuZCwgcmFuZ2UudG8pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dFN0YXJ0ID4gcmFuZ2UuZnJvbSkge1xuICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydClcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtFbmQgPSByYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMgKyBjYXB0dXJlR3JvdXAubGVuZ3RoXG5cbiAgICAgICAgdHIuYWRkTWFyayhyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIG1hcmtFbmQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzIHx8IHt9KSlcblxuICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKGNvbmZpZy50eXBlKVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iLCAiLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjk2OTQ4NlxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUZvclJlZ0V4KHN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJylcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWU6IGFueSk6IHZhbHVlIGlzIHN0cmluZyB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBQYXN0ZVJ1bGUsIFBhc3RlUnVsZUZpbmRlciB9IGZyb20gJy4uL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2luZGV4LmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCBhZGRzIGEgbm9kZSB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHBhc3RlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9kZVBhc3RlUnVsZShjb25maWc6IHtcbiAgZmluZDogUGFzdGVSdWxlRmluZGVyXG4gIHR5cGU6IE5vZGVUeXBlXG4gIGdldEF0dHJpYnV0ZXM/OlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5LCBldmVudDogQ2xpcGJvYXJkRXZlbnQpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgfCBmYWxzZVxuICAgIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcih7XG4gICAgICBtYXRjaCwgY2hhaW4sIHJhbmdlLCBwYXN0ZUV2ZW50LFxuICAgIH0pIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gsIHBhc3RlRXZlbnQpXG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzID09PSBmYWxzZSB8fCBhdHRyaWJ1dGVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaC5pbnB1dCkge1xuICAgICAgICBjaGFpbigpLmRlbGV0ZVJhbmdlKHJhbmdlKS5pbnNlcnRDb250ZW50QXQocmFuZ2UuZnJvbSwge1xuICAgICAgICAgIHR5cGU6IGNvbmZpZy50eXBlLm5hbWUsXG4gICAgICAgICAgYXR0cnM6IGF0dHJpYnV0ZXMsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBQYXN0ZVJ1bGUsIFBhc3RlUnVsZUZpbmRlciB9IGZyb20gJy4uL1Bhc3RlUnVsZS5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgcmVwbGFjZXMgdGV4dCB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHBhc3RlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGV4dFBhc3RlUnVsZShjb25maWc6IHtcbiAgZmluZDogUGFzdGVSdWxlRmluZGVyLFxuICByZXBsYWNlOiBzdHJpbmcsXG59KSB7XG4gIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGxldCBpbnNlcnQgPSBjb25maWcucmVwbGFjZVxuICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbVxuICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG9cblxuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKVxuXG4gICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpXG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldFxuXG4gICAgICAgIGNvbnN0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kXG5cbiAgICAgICAgaWYgKGN1dE9mZiA+IDApIHtcbiAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnRcbiAgICAgICAgICBzdGFydCA9IGVuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYWNrZXJSZXN1bHQge1xuICBwb3NpdGlvbjogbnVtYmVyXG4gIGRlbGV0ZWQ6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIFRyYWNrZXIge1xuICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25cblxuICBjdXJyZW50U3RlcDogbnVtYmVyXG5cbiAgY29uc3RydWN0b3IodHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uXG4gICAgdGhpcy5jdXJyZW50U3RlcCA9IHRoaXMudHJhbnNhY3Rpb24uc3RlcHMubGVuZ3RoXG4gIH1cblxuICBtYXAocG9zaXRpb246IG51bWJlcik6IFRyYWNrZXJSZXN1bHQge1xuICAgIGxldCBkZWxldGVkID0gZmFsc2VcblxuICAgIGNvbnN0IG1hcHBlZFBvc2l0aW9uID0gdGhpcy50cmFuc2FjdGlvbi5zdGVwc1xuICAgICAgLnNsaWNlKHRoaXMuY3VycmVudFN0ZXApXG4gICAgICAucmVkdWNlKChuZXdQb3NpdGlvbiwgc3RlcCkgPT4ge1xuICAgICAgICBjb25zdCBtYXBSZXN1bHQgPSBzdGVwLmdldE1hcCgpLm1hcFJlc3VsdChuZXdQb3NpdGlvbilcblxuICAgICAgICBpZiAobWFwUmVzdWx0LmRlbGV0ZWQpIHtcbiAgICAgICAgICBkZWxldGVkID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcFJlc3VsdC5wb3NcbiAgICAgIH0sIHBvc2l0aW9uKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiBtYXBwZWRQb3NpdGlvbixcbiAgICAgIGRlbGV0ZWQsXG4gICAgfVxuICB9XG59XG4iLCAiZXhwb3J0IHZhciB0b3AgPSAndG9wJztcbmV4cG9ydCB2YXIgYm90dG9tID0gJ2JvdHRvbSc7XG5leHBvcnQgdmFyIHJpZ2h0ID0gJ3JpZ2h0JztcbmV4cG9ydCB2YXIgbGVmdCA9ICdsZWZ0JztcbmV4cG9ydCB2YXIgYXV0byA9ICdhdXRvJztcbmV4cG9ydCB2YXIgYmFzZVBsYWNlbWVudHMgPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcbmV4cG9ydCB2YXIgc3RhcnQgPSAnc3RhcnQnO1xuZXhwb3J0IHZhciBlbmQgPSAnZW5kJztcbmV4cG9ydCB2YXIgY2xpcHBpbmdQYXJlbnRzID0gJ2NsaXBwaW5nUGFyZW50cyc7XG5leHBvcnQgdmFyIHZpZXdwb3J0ID0gJ3ZpZXdwb3J0JztcbmV4cG9ydCB2YXIgcG9wcGVyID0gJ3BvcHBlcic7XG5leHBvcnQgdmFyIHJlZmVyZW5jZSA9ICdyZWZlcmVuY2UnO1xuZXhwb3J0IHZhciB2YXJpYXRpb25QbGFjZW1lbnRzID0gLyojX19QVVJFX18qL2Jhc2VQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7XG5leHBvcnQgdmFyIHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovW10uY29uY2F0KGJhc2VQbGFjZW1lbnRzLCBbYXV0b10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cblxuZXhwb3J0IHZhciBiZWZvcmVSZWFkID0gJ2JlZm9yZVJlYWQnO1xuZXhwb3J0IHZhciByZWFkID0gJ3JlYWQnO1xuZXhwb3J0IHZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcblxuZXhwb3J0IHZhciBiZWZvcmVNYWluID0gJ2JlZm9yZU1haW4nO1xuZXhwb3J0IHZhciBtYWluID0gJ21haW4nO1xuZXhwb3J0IHZhciBhZnRlck1haW4gPSAnYWZ0ZXJNYWluJzsgLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuXG5leHBvcnQgdmFyIGJlZm9yZVdyaXRlID0gJ2JlZm9yZVdyaXRlJztcbmV4cG9ydCB2YXIgd3JpdGUgPSAnd3JpdGUnO1xuZXhwb3J0IHZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xuZXhwb3J0IHZhciBtb2RpZmllclBoYXNlcyA9IFtiZWZvcmVSZWFkLCByZWFkLCBhZnRlclJlYWQsIGJlZm9yZU1haW4sIG1haW4sIGFmdGVyTWFpbiwgYmVmb3JlV3JpdGUsIHdyaXRlLCBhZnRlcldyaXRlXTsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuSFRNTEVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlKSB7XG4gIC8vIElFIDExIGhhcyBubyBTaGFkb3dSb290XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5TaGFkb3dSb290O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5cbmV4cG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNTaGFkb3dSb290IH07IiwgImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXG4vLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcbiAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XG4gICAgLy8gZWZmZWN0aXZlIHdheSB0byBhcHBseSBzdHlsZXMgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cblxuXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXVxufTsiLCAiaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufSIsICJleHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgcm91bmQgPSBNYXRoLnJvdW5kOyIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRVQVN0cmluZygpIHtcbiAgdmFyIHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuXG4gIGlmICh1YURhdGEgIT0gbnVsbCAmJiB1YURhdGEuYnJhbmRzICYmIEFycmF5LmlzQXJyYXkodWFEYXRhLmJyYW5kcykpIHtcbiAgICByZXR1cm4gdWFEYXRhLmJyYW5kcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmJyYW5kICsgXCIvXCIgKyBpdGVtLnZlcnNpb247XG4gICAgfSkuam9pbignICcpO1xuICB9XG5cbiAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG59IiwgImltcG9ydCBnZXRVQVN0cmluZyBmcm9tIFwiLi4vdXRpbHMvdXNlckFnZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG59IiwgImltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tIFwiLi9pc0xheW91dFZpZXdwb3J0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpbmNsdWRlU2NhbGUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xuICAgIHNjYWxlWSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3csXG4gICAgICB2aXN1YWxWaWV3cG9ydCA9IF9yZWYudmlzdWFsVmlld3BvcnQ7XG5cbiAgdmFyIGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgdmFyIHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC8gc2NhbGVYO1xuICB2YXIgeSA9IChjbGllbnRSZWN0LnRvcCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC8gc2NhbGVZO1xuICB2YXIgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGVYO1xuICB2YXIgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsICJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiOyAvLyBSZXR1cm5zIHRoZSBsYXlvdXQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuIExheW91dFxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcblxuICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59IiwgImltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgICAgfSB3aGlsZSAobmV4dCk7XG4gICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICByZXR1cm4gZmFsc2U7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufSIsICJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufSIsICJpbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iLCAiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8ICggLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBpc1RhYmxlRWxlbWVudCBmcm9tIFwiLi9pc1RhYmxlRWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGdldFVBU3RyaW5nIGZyb20gXCIuLi91dGlscy91c2VyQWdlbnQuanNcIjtcblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICB2YXIgaXNJRSA9IC9UcmlkZW50L2kudGVzdChnZXRVQVN0cmluZygpKTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XG59IiwgImltcG9ydCB7IG1heCBhcyBtYXRoTWF4LCBtaW4gYXMgbWF0aE1pbiB9IGZyb20gXCIuL21hdGguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KSB7XG4gIHJldHVybiBtYXRoTWF4KG1pbiwgbWF0aE1pbih2YWx1ZSwgbWF4KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluTWF4Q2xhbXAobWluLCB2YWx1ZSwgbWF4KSB7XG4gIHZhciB2ID0gd2l0aGluKG1pbiwgdmFsdWUsIG1heCk7XG4gIHJldHVybiB2ID4gbWF4ID8gbWF4IDogdjtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufSIsICJpbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VQYWRkaW5nT2JqZWN0KHBhZGRpbmdPYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldEZyZXNoU2lkZU9iamVjdCgpLCBwYWRkaW5nT2JqZWN0KTtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iLCAiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuLi9kb20tdXRpbHMvY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgd2l0aGluIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi4vdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuLi91dGlscy9leHBhbmRUb0hhc2hNYXAuanNcIjtcbmltcG9ydCB7IGxlZnQsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdG9wLCBib3R0b20gfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiBwYWRkaW5nO1xuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcbiAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XG4gIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59IiwgImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bydcbn07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKF9yZWYsIHdpbikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXG4gICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICB2YXJpYXRpb24gPSBfcmVmMi52YXJpYXRpb24sXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzLFxuICAgICAgaXNGaXhlZCA9IF9yZWYyLmlzRml4ZWQ7XG4gIHZhciBfb2Zmc2V0cyR4ID0gb2Zmc2V0cy54LFxuICAgICAgeCA9IF9vZmZzZXRzJHggPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR4LFxuICAgICAgX29mZnNldHMkeSA9IG9mZnNldHMueSxcbiAgICAgIHkgPSBfb2Zmc2V0cyR5ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeTtcblxuICB2YXIgX3JlZjMgPSB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWYzLng7XG4gIHkgPSBfcmVmMy55O1xuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTtcbiAgICAgIHZhciBvZmZzZXRZID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF07XG4gICAgICB5IC09IG9mZnNldFkgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIHZhciBvZmZzZXRYID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgdmFyIF9yZWY0ID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9LCBnZXRXaW5kb3cocG9wcGVyKSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWY0Lng7XG4gIHkgPSBfcmVmNC55O1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY1KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTsiLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn07IiwgInZhciBoYXNoID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsICJ2YXIgaGFzaCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59IiwgImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn0iLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tIFwiLi9pc0xheW91dFZpZXdwb3J0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgdmFyIHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICB2YXIgbGF5b3V0Vmlld3BvcnQgPSBpc0xheW91dFZpZXdwb3J0KCk7XG5cbiAgICBpZiAobGF5b3V0Vmlld3BvcnQgfHwgIWxheW91dFZpZXdwb3J0ICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufSIsICJpbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIHZhciB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5zY3JvbGxXaWR0aCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCk7XG4gIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsICJpbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1Njcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcbiAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1k7XG5cbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCk7XG59IiwgImltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59IiwgImltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSBcIi4vZ2V0U2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cblxuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7XG4gICAgbGVmdDogcmVjdC54LFxuICAgIHRvcDogcmVjdC55LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfSk7XG59IiwgImltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0Vmlld3BvcnRSZWN0IGZyb20gXCIuL2dldFZpZXdwb3J0UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tIFwiLi9nZXREb2N1bWVudFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGZhbHNlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpKSA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn0iLCAiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4vZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0LCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHJlZmVyZW5jZSA9IF9yZWYucmVmZXJlbmNlLFxuICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZWxlbWVudC53aWR0aCAvIDI7XG4gIHZhciBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcbiAgdmFyIG9mZnNldHM7XG5cbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSB0b3A6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGJvdHRvbTpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSByaWdodDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGxlZnQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cblxuICB2YXIgbWFpbkF4aXMgPSBiYXNlUGxhY2VtZW50ID8gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpIDogbnVsbDtcblxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgc3dpdGNoICh2YXJpYXRpb24pIHtcbiAgICAgIGNhc2Ugc3RhcnQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gLSAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGVuZDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSArIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59IiwgImltcG9ydCBnZXRDbGlwcGluZ1JlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4vcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgY2xpcHBpbmdQYXJlbnRzLCByZWZlcmVuY2UsIHBvcHBlciwgYm90dG9tLCB0b3AsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4vZXhwYW5kVG9IYXNoTWFwLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJHN0cmF0ZWd5ID0gX29wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBzdHJhdGVneSA9IF9vcHRpb25zJHN0cmF0ZWd5ID09PSB2b2lkIDAgPyBzdGF0ZS5zdHJhdGVneSA6IF9vcHRpb25zJHN0cmF0ZWd5LFxuICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcbiAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KTtcbiAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn0iLCAiaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHZhcmlhdGlvblBsYWNlbWVudHMsIGJhc2VQbGFjZW1lbnRzLCBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBhbGxQbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICB9KSA6IGJhc2VQbGFjZW1lbnRzO1xuICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59IiwgImltcG9ydCBnZXRPcHBvc2l0ZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgY29tcHV0ZUF1dG9QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyBib3R0b20sIHRvcCwgc3RhcnQsIHJpZ2h0LCBsZWZ0LCBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgaWYgKGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5cbmZ1bmN0aW9uIGZsaXAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgPSBvcHRpb25zLmZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9IG9wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGZsaXBWYXJpYXRpbyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IG9wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzO1xuICB2YXIgcHJlZmVycmVkUGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xuICB2YXIgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBWYXJpYXRpb25zID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocHJlZmVycmVkUGxhY2VtZW50KSk7XG4gIHZhciBwbGFjZW1lbnRzID0gW3ByZWZlcnJlZFBsYWNlbWVudF0uY29uY2F0KGZhbGxiYWNrUGxhY2VtZW50cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0byA/IGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zOiBmbGlwVmFyaWF0aW9ucyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYWxsb3dlZEF1dG9QbGFjZW1lbnRzXG4gICAgfSkgOiBwbGFjZW1lbnQpO1xuICB9LCBbXSk7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGNoZWNrc01hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XG4gIHZhciBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzW2ldO1xuXG4gICAgdmFyIF9iYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIGlzU3RhcnRWYXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gc3RhcnQ7XG4gICAgdmFyIGlzVmVydGljYWwgPSBbdG9wLCBib3R0b21dLmluZGV4T2YoX2Jhc2VQbGFjZW1lbnQpID49IDA7XG4gICAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSk7XG4gICAgdmFyIG1haW5WYXJpYXRpb25TaWRlID0gaXNWZXJ0aWNhbCA/IGlzU3RhcnRWYXJpYXRpb24gPyByaWdodCA6IGxlZnQgOiBpc1N0YXJ0VmFyaWF0aW9uID8gYm90dG9tIDogdG9wO1xuXG4gICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xuICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgfVxuXG4gICAgdmFyIGFsdFZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgdmFyIGNoZWNrcyA9IFtdO1xuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W19iYXNlUGxhY2VtZW50XSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1ttYWluVmFyaWF0aW9uU2lkZV0gPD0gMCwgb3ZlcmZsb3dbYWx0VmFyaWF0aW9uU2lkZV0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgIHJldHVybiBjaGVjaztcbiAgICB9KSkge1xuICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgbWFrZUZhbGxiYWNrQ2hlY2tzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaGVja3NNYXAuc2V0KHBsYWNlbWVudCwgY2hlY2tzKTtcbiAgfVxuXG4gIGlmIChtYWtlRmFsbGJhY2tDaGVja3MpIHtcbiAgICAvLyBgMmAgbWF5IGJlIGRlc2lyZWQgaW4gc29tZSBjYXNlcyBcdTIwMTMgcmVzZWFyY2ggbGF0ZXJcbiAgICB2YXIgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgIHZhciBmaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50cy5maW5kKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcblxuICAgICAgICBpZiAoY2hlY2tzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrcy5zbGljZSgwLCBfaSkuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZml0dGluZ1BsYWNlbWVudCkge1xuICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBmaXR0aW5nUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaSA9IG51bWJlck9mQ2hlY2tzOyBfaSA+IDA7IF9pLS0pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kpO1xuXG4gICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUucGxhY2VtZW50ICE9PSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwID0gdHJ1ZTtcbiAgICBzdGF0ZS5wbGFjZW1lbnQgPSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgc3RhdGUucmVzZXQgPSB0cnVlO1xuICB9XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogZmFsc2VcbiAgfVxufTsiLCAiaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTsiLCAiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XG5cbiAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSkpIDogb2Zmc2V0LFxuICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xuXG4gIHNraWRkaW5nID0gc2tpZGRpbmcgfHwgMDtcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xuICAgIHg6IGRpc3RhbmNlLFxuICAgIHk6IHNraWRkaW5nXG4gIH0gOiB7XG4gICAgeDogc2tpZGRpbmcsXG4gICAgeTogZGlzdGFuY2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XG4gIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcbiAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcbiAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ29mZnNldCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgZm46IG9mZnNldFxufTsiLCAiaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gXCIuLi91dGlscy9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuXG5mdW5jdGlvbiBwb3BwZXJPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIC8vIE9mZnNldHMgYXJlIHRoZSBhY3R1YWwgcG9zaXRpb24gdGhlIHBvcHBlciBuZWVkcyB0byBoYXZlIHRvIGJlXG4gIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBwbGFjZW1lbnQsIGFuZCB3aWxsIGJlIGFkanVzdGVkIGJ5XG4gIC8vIHRoZSBtb2RpZmllcnMgaW4gdGhlIG5leHQgc3RlcFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3BvcHBlck9mZnNldHMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3JlYWQnLFxuICBmbjogcG9wcGVyT2Zmc2V0cyxcbiAgZGF0YToge31cbn07IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufSIsICJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHN0YXJ0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QWx0QXhpcyBmcm9tIFwiLi4vdXRpbHMvZ2V0QWx0QXhpcy5qc1wiO1xuaW1wb3J0IHsgd2l0aGluLCB3aXRoaW5NYXhDbGFtcCB9IGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmltcG9ydCB7IG1pbiBhcyBtYXRoTWluLCBtYXggYXMgbWF0aE1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldFZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogdGV0aGVyT2Zmc2V0VmFsdWUsXG4gICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgdGV0aGVyT2Zmc2V0VmFsdWUpO1xuICB2YXIgb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XSA6IG51bGw7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDtcblxuICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICB2YXIgbWluID0gb2Zmc2V0ICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xuICAgIHZhciBtYXggPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgIHZhciBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudCA/IG1haW5BeGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMCA6IDA7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVttYWluQXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgIHZhciB0ZXRoZXJNYXggPSBvZmZzZXQgKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWF0aE1pbihtaW4sIHRldGhlck1pbikgOiBtaW4sIG9mZnNldCwgdGV0aGVyID8gbWF0aE1heChtYXgsIHRldGhlck1heCkgOiBtYXgpO1xuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xuXG4gICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgdmFyIF9sZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgdmFyIGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XG5cbiAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuXG4gICAgdmFyIF90ZXRoZXJNYXggPSBpc09yaWdpblNpZGUgPyBfb2Zmc2V0ICsgcmVmZXJlbmNlUmVjdFtfbGVuXSArIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzIDogX21heDtcblxuICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbn07IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufSIsICJpbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0SFRNTEVsZW1lbnRTY3JvbGwgZnJvbSBcIi4vZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn0iLCAiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXROb2RlU2Nyb2xsIGZyb20gXCIuL2dldE5vZGVTY3JvbGwuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50U2NhbGVkKGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIHZhciBzY2FsZVkgPSByb3VuZChyZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbn0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50SXNTY2FsZWQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkLCBpc0ZpeGVkKTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59IiwgImltcG9ydCB7IG1vZGlmaWVyUGhhc2VzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk4NzUyNTVcblxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuXG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG5cbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcbiAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLmRhdGEsIGN1cnJlbnQuZGF0YSlcbiAgICB9KSA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICB9KTtcbn0iLCAiaW1wb3J0IGdldENvbXBvc2l0ZVJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBvcmRlck1vZGlmaWVycyBmcm9tIFwiLi91dGlscy9vcmRlck1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCIuL3V0aWxzL2RlYm91bmNlLmpzXCI7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSBcIi4vdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXI6IHBvcHBlclxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH07XG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKHNldE9wdGlvbnNBY3Rpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgc3RhdGUub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBsaXN0U2Nyb2xsUGFyZW50cyhwb3BwZXIpXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICB9KTtcbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSBcdTIwMTMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG5cblxuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QocmVmZXJlbmNlLCBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSwgc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJyksXG4gICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlcilcbiAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcbiAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XG5cbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIFx1MjAxMyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgICAgICBfcmVmJG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZiRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkb3B0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYuZWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cbmV4cG9ydCB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93IH07IiwgImltcG9ydCB7IHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3cgfSBmcm9tIFwiLi9jcmVhdGVQb3BwZXIuanNcIjtcbmltcG9ydCBldmVudExpc3RlbmVycyBmcm9tIFwiLi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanNcIjtcbmltcG9ydCBwb3BwZXJPZmZzZXRzIGZyb20gXCIuL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzXCI7XG5pbXBvcnQgY29tcHV0ZVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qc1wiO1xuaW1wb3J0IGFwcGx5U3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1wiO1xuaW1wb3J0IG9mZnNldCBmcm9tIFwiLi9tb2RpZmllcnMvb2Zmc2V0LmpzXCI7XG5pbXBvcnQgZmxpcCBmcm9tIFwiLi9tb2RpZmllcnMvZmxpcC5qc1wiO1xuaW1wb3J0IHByZXZlbnRPdmVyZmxvdyBmcm9tIFwiLi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgYXJyb3cgZnJvbSBcIi4vbW9kaWZpZXJzL2Fycm93LmpzXCI7XG5pbXBvcnQgaGlkZSBmcm9tIFwiLi9tb2RpZmllcnMvaGlkZS5qc1wiO1xudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMsIGNvbXB1dGVTdHlsZXMsIGFwcGx5U3R5bGVzLCBvZmZzZXQsIGZsaXAsIHByZXZlbnRPdmVyZmxvdywgYXJyb3csIGhpZGVdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIgYXMgY3JlYXRlUG9wcGVyTGl0ZSB9IGZyb20gXCIuL3BvcHBlci1saXRlLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0ICogZnJvbSBcIi4vbW9kaWZpZXJzL2luZGV4LmpzXCI7IiwgImV4cG9ydCBjb25zdCBST1VORF9BUlJPVyA9XG4gICc8c3ZnIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMCA2czEuNzk2LS4wMTMgNC42Ny0zLjYxNUM1Ljg1MS45IDYuOTMuMDA2IDggMGMxLjA3LS4wMDYgMi4xNDguODg3IDMuMzQzIDIuMzg1QzE0LjIzMyA2LjAwNSAxNiA2IDE2IDZIMHpcIj48L3N2Zz4nO1xuXG5leHBvcnQgY29uc3QgQk9YX0NMQVNTID0gYF9fTkFNRVNQQUNFX1BSRUZJWF9fLWJveGA7XG5leHBvcnQgY29uc3QgQ09OVEVOVF9DTEFTUyA9IGBfX05BTUVTUEFDRV9QUkVGSVhfXy1jb250ZW50YDtcbmV4cG9ydCBjb25zdCBCQUNLRFJPUF9DTEFTUyA9IGBfX05BTUVTUEFDRV9QUkVGSVhfXy1iYWNrZHJvcGA7XG5leHBvcnQgY29uc3QgQVJST1dfQ0xBU1MgPSBgX19OQU1FU1BBQ0VfUFJFRklYX18tYXJyb3dgO1xuZXhwb3J0IGNvbnN0IFNWR19BUlJPV19DTEFTUyA9IGBfX05BTUVTUEFDRV9QUkVGSVhfXy1zdmctYXJyb3dgO1xuXG5leHBvcnQgY29uc3QgVE9VQ0hfT1BUSU9OUyA9IHtwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlfTtcblxuZXhwb3J0IGNvbnN0IFRJUFBZX0RFRkFVTFRfQVBQRU5EX1RPID0gKCkgPT4gZG9jdW1lbnQuYm9keTtcbiIsICJpbXBvcnQge0Jhc2VQbGFjZW1lbnQsIFBsYWNlbWVudH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShcbiAgb2JqOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAga2V5OiBzdHJpbmdcbik6IGJvb2xlYW4ge1xuICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUF0SW5kZXhPclJldHVybjxUPihcbiAgdmFsdWU6IFQgfCBbVCB8IG51bGwsIFQgfCBudWxsXSxcbiAgaW5kZXg6IG51bWJlcixcbiAgZGVmYXVsdFZhbHVlOiBUIHwgW1QsIFRdXG4pOiBUIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgdiA9IHZhbHVlW2luZGV4XTtcbiAgICByZXR1cm4gdiA9PSBudWxsXG4gICAgICA/IEFycmF5LmlzQXJyYXkoZGVmYXVsdFZhbHVlKVxuICAgICAgICA/IGRlZmF1bHRWYWx1ZVtpbmRleF1cbiAgICAgICAgOiBkZWZhdWx0VmFsdWVcbiAgICAgIDogdjtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZSh2YWx1ZTogYW55LCB0eXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3Qgc3RyID0ge30udG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIHJldHVybiBzdHIuaW5kZXhPZignW29iamVjdCcpID09PSAwICYmIHN0ci5pbmRleE9mKGAke3R5cGV9XWApID4gLTE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZva2VXaXRoQXJnc09yUmV0dXJuKHZhbHVlOiBhbnksIGFyZ3M6IGFueVtdKTogYW55IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKC4uLmFyZ3MpIDogdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZTxUPihcbiAgZm46IChhcmc6IFQpID0+IHZvaWQsXG4gIG1zOiBudW1iZXJcbik6IChhcmc6IFQpID0+IHZvaWQge1xuICAvLyBBdm9pZCB3cmFwcGluZyBpbiBgc2V0VGltZW91dGAgaWYgbXMgaXMgMCBhbnl3YXlcbiAgaWYgKG1zID09PSAwKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgbGV0IHRpbWVvdXQ6IGFueTtcblxuICByZXR1cm4gKGFyZyk6IHZvaWQgPT4ge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBmbihhcmcpO1xuICAgIH0sIG1zKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVByb3BlcnRpZXM8VD4ob2JqOiBULCBrZXlzOiBzdHJpbmdbXSk6IFBhcnRpYWw8VD4ge1xuICBjb25zdCBjbG9uZSA9IHsuLi5vYmp9O1xuICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlbGV0ZSAoY2xvbmUgYXMgYW55KVtrZXldO1xuICB9KTtcbiAgcmV0dXJuIGNsb25lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRCeVNwYWNlcyh2YWx1ZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoL1xccysvKS5maWx0ZXIoQm9vbGVhbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVUb0FycmF5PFQ+KHZhbHVlOiBUIHwgVFtdKTogVFtdIHtcbiAgcmV0dXJuIChbXSBhcyBUW10pLmNvbmNhdCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwdXNoSWZVbmlxdWU8VD4oYXJyOiBUW10sIHZhbHVlOiBUKTogdm9pZCB7XG4gIGlmIChhcnIuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgYXJyLnB1c2godmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRQeElmTnVtYmVyKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IGAke3ZhbHVlfXB4YCA6IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5pcXVlPFQ+KGFycjogVFtdKTogVFtdIHtcbiAgcmV0dXJuIGFyci5maWx0ZXIoKGl0ZW0sIGluZGV4KSA9PiBhcnIuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TnVtYmVyKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogcGFyc2VGbG9hdCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudDogUGxhY2VtZW50KTogQmFzZVBsYWNlbWVudCB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXSBhcyBCYXNlUGxhY2VtZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlGcm9tKHZhbHVlOiBBcnJheUxpa2U8YW55Pik6IGFueVtdIHtcbiAgcmV0dXJuIFtdLnNsaWNlLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkUHJvcHMoXG4gIG9iajogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbik6IFBhcnRpYWw8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+IHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGlmIChvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAoYWNjIGFzIGFueSlba2V5XSA9IG9ialtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cbiIsICJpbXBvcnQge1JlZmVyZW5jZUVsZW1lbnQsIFRhcmdldHN9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtQb3BwZXJUcmVlRGF0YX0gZnJvbSAnLi90eXBlcy1pbnRlcm5hbCc7XG5pbXBvcnQge2FycmF5RnJvbSwgaXNUeXBlLCBub3JtYWxpemVUb0FycmF5LCBnZXRCYXNlUGxhY2VtZW50fSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGRpdigpOiBIVE1MRGl2RWxlbWVudCB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEVsZW1lbnQgfCBEb2N1bWVudEZyYWdtZW50IHtcbiAgcmV0dXJuIFsnRWxlbWVudCcsICdGcmFnbWVudCddLnNvbWUoKHR5cGUpID0+IGlzVHlwZSh2YWx1ZSwgdHlwZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOb2RlTGlzdCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIE5vZGVMaXN0IHtcbiAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ05vZGVMaXN0Jyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc01vdXNlRXZlbnQodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBNb3VzZUV2ZW50IHtcbiAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ01vdXNlRXZlbnQnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVmZXJlbmNlRWxlbWVudCh2YWx1ZTogYW55KTogdmFsdWUgaXMgUmVmZXJlbmNlRWxlbWVudCB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fdGlwcHkgJiYgdmFsdWUuX3RpcHB5LnJlZmVyZW5jZSA9PT0gdmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJyYXlPZkVsZW1lbnRzKHZhbHVlOiBUYXJnZXRzKTogRWxlbWVudFtdIHtcbiAgaWYgKGlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgfVxuXG4gIGlmIChpc05vZGVMaXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBhcnJheUZyb20odmFsdWUpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5RnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uRHVyYXRpb24oXG4gIGVsczogKEhUTUxEaXZFbGVtZW50IHwgbnVsbClbXSxcbiAgdmFsdWU6IG51bWJlclxuKTogdm9pZCB7XG4gIGVscy5mb3JFYWNoKChlbCkgPT4ge1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gYCR7dmFsdWV9bXNgO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRWaXNpYmlsaXR5U3RhdGUoXG4gIGVsczogKEhUTUxEaXZFbGVtZW50IHwgbnVsbClbXSxcbiAgc3RhdGU6ICd2aXNpYmxlJyB8ICdoaWRkZW4nXG4pOiB2b2lkIHtcbiAgZWxzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnLCBzdGF0ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE93bmVyRG9jdW1lbnQoXG4gIGVsZW1lbnRPckVsZW1lbnRzOiBFbGVtZW50IHwgRWxlbWVudFtdXG4pOiBEb2N1bWVudCB7XG4gIGNvbnN0IFtlbGVtZW50XSA9IG5vcm1hbGl6ZVRvQXJyYXkoZWxlbWVudE9yRWxlbWVudHMpO1xuXG4gIC8vIEVsZW1lbnRzIGNyZWF0ZWQgdmlhIGEgPHRlbXBsYXRlPiBoYXZlIGFuIG93bmVyRG9jdW1lbnQgd2l0aCBubyByZWZlcmVuY2UgdG8gdGhlIGJvZHlcbiAgcmV0dXJuIGVsZW1lbnQ/Lm93bmVyRG9jdW1lbnQ/LmJvZHkgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiBkb2N1bWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ3Vyc29yT3V0c2lkZUludGVyYWN0aXZlQm9yZGVyKFxuICBwb3BwZXJUcmVlRGF0YTogUG9wcGVyVHJlZURhdGFbXSxcbiAgZXZlbnQ6IE1vdXNlRXZlbnRcbik6IGJvb2xlYW4ge1xuICBjb25zdCB7Y2xpZW50WCwgY2xpZW50WX0gPSBldmVudDtcblxuICByZXR1cm4gcG9wcGVyVHJlZURhdGEuZXZlcnkoKHtwb3BwZXJSZWN0LCBwb3BwZXJTdGF0ZSwgcHJvcHN9KSA9PiB7XG4gICAgY29uc3Qge2ludGVyYWN0aXZlQm9yZGVyfSA9IHByb3BzO1xuICAgIGNvbnN0IGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBvcHBlclN0YXRlLnBsYWNlbWVudCk7XG4gICAgY29uc3Qgb2Zmc2V0RGF0YSA9IHBvcHBlclN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0O1xuXG4gICAgaWYgKCFvZmZzZXREYXRhKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0b3BEaXN0YW5jZSA9IGJhc2VQbGFjZW1lbnQgPT09ICdib3R0b20nID8gb2Zmc2V0RGF0YS50b3AhLnkgOiAwO1xuICAgIGNvbnN0IGJvdHRvbURpc3RhbmNlID0gYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcgPyBvZmZzZXREYXRhLmJvdHRvbSEueSA6IDA7XG4gICAgY29uc3QgbGVmdERpc3RhbmNlID0gYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/IG9mZnNldERhdGEubGVmdCEueCA6IDA7XG4gICAgY29uc3QgcmlnaHREaXN0YW5jZSA9IGJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0JyA/IG9mZnNldERhdGEucmlnaHQhLnggOiAwO1xuXG4gICAgY29uc3QgZXhjZWVkc1RvcCA9XG4gICAgICBwb3BwZXJSZWN0LnRvcCAtIGNsaWVudFkgKyB0b3BEaXN0YW5jZSA+IGludGVyYWN0aXZlQm9yZGVyO1xuICAgIGNvbnN0IGV4Y2VlZHNCb3R0b20gPVxuICAgICAgY2xpZW50WSAtIHBvcHBlclJlY3QuYm90dG9tIC0gYm90dG9tRGlzdGFuY2UgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICBjb25zdCBleGNlZWRzTGVmdCA9XG4gICAgICBwb3BwZXJSZWN0LmxlZnQgLSBjbGllbnRYICsgbGVmdERpc3RhbmNlID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgY29uc3QgZXhjZWVkc1JpZ2h0ID1cbiAgICAgIGNsaWVudFggLSBwb3BwZXJSZWN0LnJpZ2h0IC0gcmlnaHREaXN0YW5jZSA+IGludGVyYWN0aXZlQm9yZGVyO1xuXG4gICAgcmV0dXJuIGV4Y2VlZHNUb3AgfHwgZXhjZWVkc0JvdHRvbSB8fCBleGNlZWRzTGVmdCB8fCBleGNlZWRzUmlnaHQ7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKFxuICBib3g6IEhUTUxEaXZFbGVtZW50LFxuICBhY3Rpb246ICdhZGQnIHwgJ3JlbW92ZScsXG4gIGxpc3RlbmVyOiAoZXZlbnQ6IFRyYW5zaXRpb25FdmVudCkgPT4gdm9pZFxuKTogdm9pZCB7XG4gIGNvbnN0IG1ldGhvZCA9IGAke2FjdGlvbn1FdmVudExpc3RlbmVyYCBhc1xuICAgIHwgJ2FkZEV2ZW50TGlzdGVuZXInXG4gICAgfCAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG5cbiAgLy8gc29tZSBicm93c2VycyBhcHBhcmVudGx5IHN1cHBvcnQgYHRyYW5zaXRpb25gICh1bnByZWZpeGVkKSBidXQgb25seSBmaXJlXG4gIC8vIGB3ZWJraXRUcmFuc2l0aW9uRW5kYC4uLlxuICBbJ3RyYW5zaXRpb25lbmQnLCAnd2Via2l0VHJhbnNpdGlvbkVuZCddLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgYm94W21ldGhvZF0oZXZlbnQsIGxpc3RlbmVyIGFzIEV2ZW50TGlzdGVuZXIpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb21wYXJlZCB0byB4eHguY29udGFpbnMsIHRoaXMgZnVuY3Rpb24gd29ya3MgZm9yIGRvbSBzdHJ1Y3R1cmVzIHdpdGggc2hhZG93XG4gKiBkb21cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFjdHVhbENvbnRhaW5zKHBhcmVudDogRWxlbWVudCwgY2hpbGQ6IEVsZW1lbnQpOiBib29sZWFuIHtcbiAgbGV0IHRhcmdldCA9IGNoaWxkO1xuICB3aGlsZSAodGFyZ2V0KSB7XG4gICAgaWYgKHBhcmVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGFyZ2V0ID0gKHRhcmdldC5nZXRSb290Tm9kZT8uKCkgYXMgYW55KT8uaG9zdDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCAiaW1wb3J0IHtUT1VDSF9PUFRJT05TfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge2lzUmVmZXJlbmNlRWxlbWVudH0gZnJvbSAnLi9kb20tdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgY3VycmVudElucHV0ID0ge2lzVG91Y2g6IGZhbHNlfTtcbmxldCBsYXN0TW91c2VNb3ZlVGltZSA9IDA7XG5cbi8qKlxuICogV2hlbiBhIGB0b3VjaHN0YXJ0YCBldmVudCBpcyBmaXJlZCwgaXQncyBhc3N1bWVkIHRoZSB1c2VyIGlzIHVzaW5nIHRvdWNoXG4gKiBpbnB1dC4gV2UnbGwgYmluZCBhIGBtb3VzZW1vdmVgIGV2ZW50IGxpc3RlbmVyIHRvIGxpc3RlbiBmb3IgbW91c2UgaW5wdXQgaW5cbiAqIHRoZSBmdXR1cmUuIFRoaXMgd2F5LCB0aGUgYGlzVG91Y2hgIHByb3BlcnR5IGlzIGZ1bGx5IGR5bmFtaWMgYW5kIHdpbGwgaGFuZGxlXG4gKiBoeWJyaWQgZGV2aWNlcyB0aGF0IHVzZSBhIG1peCBvZiB0b3VjaCArIG1vdXNlIGlucHV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gb25Eb2N1bWVudFRvdWNoU3RhcnQoKTogdm9pZCB7XG4gIGlmIChjdXJyZW50SW5wdXQuaXNUb3VjaCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN1cnJlbnRJbnB1dC5pc1RvdWNoID0gdHJ1ZTtcblxuICBpZiAod2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Eb2N1bWVudE1vdXNlTW92ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXaGVuIHR3byBgbW91c2Vtb3ZlYCBldmVudCBhcmUgZmlyZWQgY29uc2VjdXRpdmVseSB3aXRoaW4gMjBtcywgaXQncyBhc3N1bWVkXG4gKiB0aGUgdXNlciBpcyB1c2luZyBtb3VzZSBpbnB1dCBhZ2Fpbi4gYG1vdXNlbW92ZWAgY2FuIGZpcmUgb24gdG91Y2ggZGV2aWNlcyBhc1xuICogd2VsbCwgYnV0IHZlcnkgcmFyZWx5IHRoYXQgcXVpY2tseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uRG9jdW1lbnRNb3VzZU1vdmUoKTogdm9pZCB7XG4gIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gIGlmIChub3cgLSBsYXN0TW91c2VNb3ZlVGltZSA8IDIwKSB7XG4gICAgY3VycmVudElucHV0LmlzVG91Y2ggPSBmYWxzZTtcblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uRG9jdW1lbnRNb3VzZU1vdmUpO1xuICB9XG5cbiAgbGFzdE1vdXNlTW92ZVRpbWUgPSBub3c7XG59XG5cbi8qKlxuICogV2hlbiBhbiBlbGVtZW50IGlzIGluIGZvY3VzIGFuZCBoYXMgYSB0aXBweSwgbGVhdmluZyB0aGUgdGFiL3dpbmRvdyBhbmRcbiAqIHJldHVybmluZyBjYXVzZXMgaXQgdG8gc2hvdyBhZ2Fpbi4gRm9yIG1vdXNlIHVzZXJzIHRoaXMgaXMgdW5leHBlY3RlZCwgYnV0XG4gKiBmb3Iga2V5Ym9hcmQgdXNlIGl0IG1ha2VzIHNlbnNlLlxuICogVE9ETzogZmluZCBhIGJldHRlciB0ZWNobmlxdWUgdG8gc29sdmUgdGhpcyBwcm9ibGVtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbldpbmRvd0JsdXIoKTogdm9pZCB7XG4gIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGFzIEhUTUxFbGVtZW50IHwgbnVsbDtcblxuICBpZiAoaXNSZWZlcmVuY2VFbGVtZW50KGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBhY3RpdmVFbGVtZW50Ll90aXBweSE7XG5cbiAgICBpZiAoYWN0aXZlRWxlbWVudC5ibHVyICYmICFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kR2xvYmFsRXZlbnRMaXN0ZW5lcnMoKTogdm9pZCB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvbkRvY3VtZW50VG91Y2hTdGFydCwgVE9VQ0hfT1BUSU9OUyk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgb25XaW5kb3dCbHVyKTtcbn1cbiIsICJleHBvcnQgY29uc3QgaXNCcm93c2VyID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuZXhwb3J0IGNvbnN0IGlzSUUxMSA9IGlzQnJvd3NlclxuICA/IC8vIEB0cy1pZ25vcmVcbiAgICAhIXdpbmRvdy5tc0NyeXB0b1xuICA6IGZhbHNlO1xuIiwgImltcG9ydCB7VGFyZ2V0c30gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZW1vcnlMZWFrV2FybmluZyhtZXRob2Q6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHR4dCA9IG1ldGhvZCA9PT0gJ2Rlc3Ryb3knID8gJ24gYWxyZWFkeS0nIDogJyAnO1xuXG4gIHJldHVybiBbXG4gICAgYCR7bWV0aG9kfSgpIHdhcyBjYWxsZWQgb24gYSR7dHh0fWRlc3Ryb3llZCBpbnN0YW5jZS4gVGhpcyBpcyBhIG5vLW9wIGJ1dGAsXG4gICAgJ2luZGljYXRlcyBhIHBvdGVudGlhbCBtZW1vcnkgbGVhay4nLFxuICBdLmpvaW4oJyAnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBzcGFjZXNBbmRUYWJzID0gL1sgXFx0XXsyLH0vZztcbiAgY29uc3QgbGluZVN0YXJ0V2l0aFNwYWNlcyA9IC9eWyBcXHRdKi9nbTtcblxuICByZXR1cm4gdmFsdWVcbiAgICAucmVwbGFjZShzcGFjZXNBbmRUYWJzLCAnICcpXG4gICAgLnJlcGxhY2UobGluZVN0YXJ0V2l0aFNwYWNlcywgJycpXG4gICAgLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGV2TWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gY2xlYW4oYFxuICAlY3RpcHB5LmpzXG5cbiAgJWMke2NsZWFuKG1lc3NhZ2UpfVxuXG4gICVj8J+Rt+KAjSBUaGlzIGlzIGEgZGV2ZWxvcG1lbnQtb25seSBtZXNzYWdlLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvbi5cbiAgYCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIFtcbiAgICBnZXREZXZNZXNzYWdlKG1lc3NhZ2UpLFxuICAgIC8vIHRpdGxlXG4gICAgJ2NvbG9yOiAjMDBDNTg0OyBmb250LXNpemU6IDEuM2VtOyBmb250LXdlaWdodDogYm9sZDsnLFxuICAgIC8vIG1lc3NhZ2VcbiAgICAnbGluZS1oZWlnaHQ6IDEuNScsXG4gICAgLy8gZm9vdGVyXG4gICAgJ2NvbG9yOiAjYTZhMDk1OycsXG4gIF07XG59XG5cbi8vIEFzc3VtZSB3YXJuaW5ncyBhbmQgZXJyb3JzIG5ldmVyIGhhdmUgdGhlIHNhbWUgbWVzc2FnZVxubGV0IHZpc2l0ZWRNZXNzYWdlczogU2V0PHN0cmluZz47XG5pZiAoX19ERVZfXykge1xuICByZXNldFZpc2l0ZWRNZXNzYWdlcygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRWaXNpdGVkTWVzc2FnZXMoKTogdm9pZCB7XG4gIHZpc2l0ZWRNZXNzYWdlcyA9IG5ldyBTZXQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhcm5XaGVuKGNvbmRpdGlvbjogYm9vbGVhbiwgbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmIChjb25kaXRpb24gJiYgIXZpc2l0ZWRNZXNzYWdlcy5oYXMobWVzc2FnZSkpIHtcbiAgICB2aXNpdGVkTWVzc2FnZXMuYWRkKG1lc3NhZ2UpO1xuICAgIGNvbnNvbGUud2FybiguLi5nZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JXaGVuKGNvbmRpdGlvbjogYm9vbGVhbiwgbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmIChjb25kaXRpb24gJiYgIXZpc2l0ZWRNZXNzYWdlcy5oYXMobWVzc2FnZSkpIHtcbiAgICB2aXNpdGVkTWVzc2FnZXMuYWRkKG1lc3NhZ2UpO1xuICAgIGNvbnNvbGUuZXJyb3IoLi4uZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVGFyZ2V0cyh0YXJnZXRzOiBUYXJnZXRzKTogdm9pZCB7XG4gIGNvbnN0IGRpZFBhc3NGYWxzeVZhbHVlID0gIXRhcmdldHM7XG4gIGNvbnN0IGRpZFBhc3NQbGFpbk9iamVjdCA9XG4gICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhcmdldHMpID09PSAnW29iamVjdCBPYmplY3RdJyAmJlxuICAgICEodGFyZ2V0cyBhcyBhbnkpLmFkZEV2ZW50TGlzdGVuZXI7XG5cbiAgZXJyb3JXaGVuKFxuICAgIGRpZFBhc3NGYWxzeVZhbHVlLFxuICAgIFtcbiAgICAgICd0aXBweSgpIHdhcyBwYXNzZWQnLFxuICAgICAgJ2AnICsgU3RyaW5nKHRhcmdldHMpICsgJ2AnLFxuICAgICAgJ2FzIGl0cyB0YXJnZXRzIChmaXJzdCkgYXJndW1lbnQuIFZhbGlkIHR5cGVzIGFyZTogU3RyaW5nLCBFbGVtZW50LCcsXG4gICAgICAnRWxlbWVudFtdLCBvciBOb2RlTGlzdC4nLFxuICAgIF0uam9pbignICcpXG4gICk7XG5cbiAgZXJyb3JXaGVuKFxuICAgIGRpZFBhc3NQbGFpbk9iamVjdCxcbiAgICBbXG4gICAgICAndGlwcHkoKSB3YXMgcGFzc2VkIGEgcGxhaW4gb2JqZWN0IHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWQgYXMgYW4gYXJndW1lbnQnLFxuICAgICAgJ2ZvciB2aXJ0dWFsIHBvc2l0aW9uaW5nLiBVc2UgcHJvcHMuZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCBpbnN0ZWFkLicsXG4gICAgXS5qb2luKCcgJylcbiAgKTtcbn1cbiIsICJpbXBvcnQge0RlZmF1bHRQcm9wcywgUGx1Z2luLCBQcm9wcywgUmVmZXJlbmNlRWxlbWVudCwgVGlwcHl9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgaGFzT3duUHJvcGVydHksXG4gIHJlbW92ZVByb3BlcnRpZXMsXG4gIGludm9rZVdpdGhBcmdzT3JSZXR1cm4sXG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHt3YXJuV2hlbn0gZnJvbSAnLi92YWxpZGF0aW9uJztcbmltcG9ydCB7VElQUFlfREVGQVVMVF9BUFBFTkRfVE99IGZyb20gJy4vY29uc3RhbnRzJztcblxuY29uc3QgcGx1Z2luUHJvcHMgPSB7XG4gIGFuaW1hdGVGaWxsOiBmYWxzZSxcbiAgZm9sbG93Q3Vyc29yOiBmYWxzZSxcbiAgaW5saW5lUG9zaXRpb25pbmc6IGZhbHNlLFxuICBzdGlja3k6IGZhbHNlLFxufTtcblxuY29uc3QgcmVuZGVyUHJvcHMgPSB7XG4gIGFsbG93SFRNTDogZmFsc2UsXG4gIGFuaW1hdGlvbjogJ2ZhZGUnLFxuICBhcnJvdzogdHJ1ZSxcbiAgY29udGVudDogJycsXG4gIGluZXJ0aWE6IGZhbHNlLFxuICBtYXhXaWR0aDogMzUwLFxuICByb2xlOiAndG9vbHRpcCcsXG4gIHRoZW1lOiAnJyxcbiAgekluZGV4OiA5OTk5LFxufTtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRQcm9wczogRGVmYXVsdFByb3BzID0ge1xuICBhcHBlbmRUbzogVElQUFlfREVGQVVMVF9BUFBFTkRfVE8sXG4gIGFyaWE6IHtcbiAgICBjb250ZW50OiAnYXV0bycsXG4gICAgZXhwYW5kZWQ6ICdhdXRvJyxcbiAgfSxcbiAgZGVsYXk6IDAsXG4gIGR1cmF0aW9uOiBbMzAwLCAyNTBdLFxuICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBudWxsLFxuICBoaWRlT25DbGljazogdHJ1ZSxcbiAgaWdub3JlQXR0cmlidXRlczogZmFsc2UsXG4gIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgaW50ZXJhY3RpdmVCb3JkZXI6IDIsXG4gIGludGVyYWN0aXZlRGVib3VuY2U6IDAsXG4gIG1vdmVUcmFuc2l0aW9uOiAnJyxcbiAgb2Zmc2V0OiBbMCwgMTBdLFxuICBvbkFmdGVyVXBkYXRlKCkge30sXG4gIG9uQmVmb3JlVXBkYXRlKCkge30sXG4gIG9uQ3JlYXRlKCkge30sXG4gIG9uRGVzdHJveSgpIHt9LFxuICBvbkhpZGRlbigpIHt9LFxuICBvbkhpZGUoKSB7fSxcbiAgb25Nb3VudCgpIHt9LFxuICBvblNob3coKSB7fSxcbiAgb25TaG93bigpIHt9LFxuICBvblRyaWdnZXIoKSB7fSxcbiAgb25VbnRyaWdnZXIoKSB7fSxcbiAgb25DbGlja091dHNpZGUoKSB7fSxcbiAgcGxhY2VtZW50OiAndG9wJyxcbiAgcGx1Z2luczogW10sXG4gIHBvcHBlck9wdGlvbnM6IHt9LFxuICByZW5kZXI6IG51bGwsXG4gIHNob3dPbkNyZWF0ZTogZmFsc2UsXG4gIHRvdWNoOiB0cnVlLFxuICB0cmlnZ2VyOiAnbW91c2VlbnRlciBmb2N1cycsXG4gIHRyaWdnZXJUYXJnZXQ6IG51bGwsXG4gIC4uLnBsdWdpblByb3BzLFxuICAuLi5yZW5kZXJQcm9wcyxcbn07XG5cbmNvbnN0IGRlZmF1bHRLZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdFByb3BzKTtcblxuZXhwb3J0IGNvbnN0IHNldERlZmF1bHRQcm9wczogVGlwcHlbJ3NldERlZmF1bHRQcm9wcyddID0gKHBhcnRpYWxQcm9wcykgPT4ge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoX19ERVZfXykge1xuICAgIHZhbGlkYXRlUHJvcHMocGFydGlhbFByb3BzLCBbXSk7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocGFydGlhbFByb3BzKSBhcyBBcnJheTxrZXlvZiBEZWZhdWx0UHJvcHM+O1xuICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIChkZWZhdWx0UHJvcHMgYXMgYW55KVtrZXldID0gcGFydGlhbFByb3BzW2tleV07XG4gIH0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEV4dGVuZGVkUGFzc2VkUHJvcHMoXG4gIHBhc3NlZFByb3BzOiBQYXJ0aWFsPFByb3BzPiAmIFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4pOiBQYXJ0aWFsPFByb3BzPiB7XG4gIGNvbnN0IHBsdWdpbnMgPSBwYXNzZWRQcm9wcy5wbHVnaW5zIHx8IFtdO1xuICBjb25zdCBwbHVnaW5Qcm9wcyA9IHBsdWdpbnMucmVkdWNlPFJlY29yZDxzdHJpbmcsIHVua25vd24+PigoYWNjLCBwbHVnaW4pID0+IHtcbiAgICBjb25zdCB7bmFtZSwgZGVmYXVsdFZhbHVlfSA9IHBsdWdpbjtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICBhY2NbbmFtZV0gPVxuICAgICAgICBwYXNzZWRQcm9wc1tuYW1lXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBwYXNzZWRQcm9wc1tuYW1lXVxuICAgICAgICAgIDogKGRlZmF1bHRQcm9wcyBhcyBhbnkpW25hbWVdID8/IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5wYXNzZWRQcm9wcyxcbiAgICAuLi5wbHVnaW5Qcm9wcyxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFBdHRyaWJ1dGVQcm9wcyhcbiAgcmVmZXJlbmNlOiBSZWZlcmVuY2VFbGVtZW50LFxuICBwbHVnaW5zOiBQbHVnaW5bXVxuKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICBjb25zdCBwcm9wS2V5cyA9IHBsdWdpbnNcbiAgICA/IE9iamVjdC5rZXlzKGdldEV4dGVuZGVkUGFzc2VkUHJvcHMoey4uLmRlZmF1bHRQcm9wcywgcGx1Z2luc30pKVxuICAgIDogZGVmYXVsdEtleXM7XG5cbiAgY29uc3QgcHJvcHMgPSBwcm9wS2V5cy5yZWR1Y2UoXG4gICAgKGFjYzogUGFydGlhbDxQcm9wcz4gJiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwga2V5KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZUFzU3RyaW5nID0gKFxuICAgICAgICByZWZlcmVuY2UuZ2V0QXR0cmlidXRlKGBkYXRhLXRpcHB5LSR7a2V5fWApIHx8ICcnXG4gICAgICApLnRyaW0oKTtcblxuICAgICAgaWYgKCF2YWx1ZUFzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgPT09ICdjb250ZW50Jykge1xuICAgICAgICBhY2Nba2V5XSA9IHZhbHVlQXNTdHJpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGFjY1trZXldID0gSlNPTi5wYXJzZSh2YWx1ZUFzU3RyaW5nKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGFjY1trZXldID0gdmFsdWVBc1N0cmluZztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sXG4gICAge31cbiAgKTtcblxuICByZXR1cm4gcHJvcHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBldmFsdWF0ZVByb3BzKFxuICByZWZlcmVuY2U6IFJlZmVyZW5jZUVsZW1lbnQsXG4gIHByb3BzOiBQcm9wc1xuKTogUHJvcHMge1xuICBjb25zdCBvdXQgPSB7XG4gICAgLi4ucHJvcHMsXG4gICAgY29udGVudDogaW52b2tlV2l0aEFyZ3NPclJldHVybihwcm9wcy5jb250ZW50LCBbcmVmZXJlbmNlXSksXG4gICAgLi4uKHByb3BzLmlnbm9yZUF0dHJpYnV0ZXNcbiAgICAgID8ge31cbiAgICAgIDogZ2V0RGF0YUF0dHJpYnV0ZVByb3BzKHJlZmVyZW5jZSwgcHJvcHMucGx1Z2lucykpLFxuICB9O1xuXG4gIG91dC5hcmlhID0ge1xuICAgIC4uLmRlZmF1bHRQcm9wcy5hcmlhLFxuICAgIC4uLm91dC5hcmlhLFxuICB9O1xuXG4gIG91dC5hcmlhID0ge1xuICAgIGV4cGFuZGVkOlxuICAgICAgb3V0LmFyaWEuZXhwYW5kZWQgPT09ICdhdXRvJyA/IHByb3BzLmludGVyYWN0aXZlIDogb3V0LmFyaWEuZXhwYW5kZWQsXG4gICAgY29udGVudDpcbiAgICAgIG91dC5hcmlhLmNvbnRlbnQgPT09ICdhdXRvJ1xuICAgICAgICA/IHByb3BzLmludGVyYWN0aXZlXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiAnZGVzY3JpYmVkYnknXG4gICAgICAgIDogb3V0LmFyaWEuY29udGVudCxcbiAgfTtcblxuICByZXR1cm4gb3V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhcbiAgcGFydGlhbFByb3BzOiBQYXJ0aWFsPFByb3BzPiA9IHt9LFxuICBwbHVnaW5zOiBQbHVnaW5bXSA9IFtdXG4pOiB2b2lkIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHBhcnRpYWxQcm9wcykgYXMgQXJyYXk8a2V5b2YgUHJvcHM+O1xuICBrZXlzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBjb25zdCBub25QbHVnaW5Qcm9wcyA9IHJlbW92ZVByb3BlcnRpZXMoXG4gICAgICBkZWZhdWx0UHJvcHMsXG4gICAgICBPYmplY3Qua2V5cyhwbHVnaW5Qcm9wcylcbiAgICApO1xuXG4gICAgbGV0IGRpZFBhc3NVbmtub3duUHJvcCA9ICFoYXNPd25Qcm9wZXJ0eShub25QbHVnaW5Qcm9wcywgcHJvcCk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgcHJvcCBleGlzdHMgaW4gYHBsdWdpbnNgXG4gICAgaWYgKGRpZFBhc3NVbmtub3duUHJvcCkge1xuICAgICAgZGlkUGFzc1Vua25vd25Qcm9wID1cbiAgICAgICAgcGx1Z2lucy5maWx0ZXIoKHBsdWdpbikgPT4gcGx1Z2luLm5hbWUgPT09IHByb3ApLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICB3YXJuV2hlbihcbiAgICAgIGRpZFBhc3NVbmtub3duUHJvcCxcbiAgICAgIFtcbiAgICAgICAgYFxcYCR7cHJvcH1cXGBgLFxuICAgICAgICBcImlzIG5vdCBhIHZhbGlkIHByb3AuIFlvdSBtYXkgaGF2ZSBzcGVsbGVkIGl0IGluY29ycmVjdGx5LCBvciBpZiBpdCdzXCIsXG4gICAgICAgICdhIHBsdWdpbiwgZm9yZ290IHRvIHBhc3MgaXQgaW4gYW4gYXJyYXkgYXMgcHJvcHMucGx1Z2lucy4nLFxuICAgICAgICAnXFxuXFxuJyxcbiAgICAgICAgJ0FsbCBwcm9wczogaHR0cHM6Ly9hdG9taWtzLmdpdGh1Yi5pby90aXBweWpzL3Y2L2FsbC1wcm9wcy9cXG4nLFxuICAgICAgICAnUGx1Z2luczogaHR0cHM6Ly9hdG9taWtzLmdpdGh1Yi5pby90aXBweWpzL3Y2L3BsdWdpbnMvJyxcbiAgICAgIF0uam9pbignICcpXG4gICAgKTtcbiAgfSk7XG59XG4iLCAiaW1wb3J0IHtcbiAgQVJST1dfQ0xBU1MsXG4gIEJBQ0tEUk9QX0NMQVNTLFxuICBCT1hfQ0xBU1MsXG4gIENPTlRFTlRfQ0xBU1MsXG4gIFNWR19BUlJPV19DTEFTUyxcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtkaXYsIGlzRWxlbWVudH0gZnJvbSAnLi9kb20tdXRpbHMnO1xuaW1wb3J0IHtJbnN0YW5jZSwgUG9wcGVyRWxlbWVudCwgUHJvcHN9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtQb3BwZXJDaGlsZHJlbn0gZnJvbSAnLi90eXBlcy1pbnRlcm5hbCc7XG5pbXBvcnQge2FycmF5RnJvbX0gZnJvbSAnLi91dGlscyc7XG5cbi8vIEZpcmVmb3ggZXh0ZW5zaW9ucyBkb24ndCBhbGxvdyAuaW5uZXJIVE1MID0gXCIuLi5cIiBwcm9wZXJ0eS4gVGhpcyB0cmlja3MgaXQuXG5jb25zdCBpbm5lckhUTUwgPSAoKTogJ2lubmVySFRNTCcgPT4gJ2lubmVySFRNTCc7XG5cbmZ1bmN0aW9uIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKGVsZW1lbnQ6IEVsZW1lbnQsIGh0bWw6IHN0cmluZyk6IHZvaWQge1xuICBlbGVtZW50W2lubmVySFRNTCgpXSA9IGh0bWw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycm93RWxlbWVudCh2YWx1ZTogUHJvcHNbJ2Fycm93J10pOiBIVE1MRGl2RWxlbWVudCB7XG4gIGNvbnN0IGFycm93ID0gZGl2KCk7XG5cbiAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgYXJyb3cuY2xhc3NOYW1lID0gQVJST1dfQ0xBU1M7XG4gIH0gZWxzZSB7XG4gICAgYXJyb3cuY2xhc3NOYW1lID0gU1ZHX0FSUk9XX0NMQVNTO1xuXG4gICAgaWYgKGlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgIGFycm93LmFwcGVuZENoaWxkKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwoYXJyb3csIHZhbHVlIGFzIHN0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFycm93O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29udGVudChjb250ZW50OiBIVE1MRGl2RWxlbWVudCwgcHJvcHM6IFByb3BzKTogdm9pZCB7XG4gIGlmIChpc0VsZW1lbnQocHJvcHMuY29udGVudCkpIHtcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTChjb250ZW50LCAnJyk7XG4gICAgY29udGVudC5hcHBlbmRDaGlsZChwcm9wcy5jb250ZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuY29udGVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9wcy5hbGxvd0hUTUwpIHtcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKGNvbnRlbnQsIHByb3BzLmNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50LnRleHRDb250ZW50ID0gcHJvcHMuY29udGVudDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENoaWxkcmVuKHBvcHBlcjogUG9wcGVyRWxlbWVudCk6IFBvcHBlckNoaWxkcmVuIHtcbiAgY29uc3QgYm94ID0gcG9wcGVyLmZpcnN0RWxlbWVudENoaWxkIGFzIEhUTUxEaXZFbGVtZW50O1xuICBjb25zdCBib3hDaGlsZHJlbiA9IGFycmF5RnJvbShib3guY2hpbGRyZW4pO1xuXG4gIHJldHVybiB7XG4gICAgYm94LFxuICAgIGNvbnRlbnQ6IGJveENoaWxkcmVuLmZpbmQoKG5vZGUpID0+IG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKENPTlRFTlRfQ0xBU1MpKSxcbiAgICBhcnJvdzogYm94Q2hpbGRyZW4uZmluZChcbiAgICAgIChub2RlKSA9PlxuICAgICAgICBub2RlLmNsYXNzTGlzdC5jb250YWlucyhBUlJPV19DTEFTUykgfHxcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoU1ZHX0FSUk9XX0NMQVNTKVxuICAgICksXG4gICAgYmFja2Ryb3A6IGJveENoaWxkcmVuLmZpbmQoKG5vZGUpID0+XG4gICAgICBub2RlLmNsYXNzTGlzdC5jb250YWlucyhCQUNLRFJPUF9DTEFTUylcbiAgICApLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKFxuICBpbnN0YW5jZTogSW5zdGFuY2Vcbik6IHtcbiAgcG9wcGVyOiBQb3BwZXJFbGVtZW50O1xuICBvblVwZGF0ZT86IChwcmV2UHJvcHM6IFByb3BzLCBuZXh0UHJvcHM6IFByb3BzKSA9PiB2b2lkO1xufSB7XG4gIGNvbnN0IHBvcHBlciA9IGRpdigpO1xuXG4gIGNvbnN0IGJveCA9IGRpdigpO1xuICBib3guY2xhc3NOYW1lID0gQk9YX0NMQVNTO1xuICBib3guc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywgJ2hpZGRlbicpO1xuICBib3guc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuXG4gIGNvbnN0IGNvbnRlbnQgPSBkaXYoKTtcbiAgY29udGVudC5jbGFzc05hbWUgPSBDT05URU5UX0NMQVNTO1xuICBjb250ZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdoaWRkZW4nKTtcblxuICBzZXRDb250ZW50KGNvbnRlbnQsIGluc3RhbmNlLnByb3BzKTtcblxuICBwb3BwZXIuYXBwZW5kQ2hpbGQoYm94KTtcbiAgYm94LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuXG4gIG9uVXBkYXRlKGluc3RhbmNlLnByb3BzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgZnVuY3Rpb24gb25VcGRhdGUocHJldlByb3BzOiBQcm9wcywgbmV4dFByb3BzOiBQcm9wcyk6IHZvaWQge1xuICAgIGNvbnN0IHtib3gsIGNvbnRlbnQsIGFycm93fSA9IGdldENoaWxkcmVuKHBvcHBlcik7XG5cbiAgICBpZiAobmV4dFByb3BzLnRoZW1lKSB7XG4gICAgICBib3guc2V0QXR0cmlidXRlKCdkYXRhLXRoZW1lJywgbmV4dFByb3BzLnRoZW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS10aGVtZScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV4dFByb3BzLmFuaW1hdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0aW9uJywgbmV4dFByb3BzLmFuaW1hdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRQcm9wcy5pbmVydGlhKSB7XG4gICAgICBib3guc2V0QXR0cmlidXRlKCdkYXRhLWluZXJ0aWEnLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtaW5lcnRpYScpO1xuICAgIH1cblxuICAgIGJveC5zdHlsZS5tYXhXaWR0aCA9XG4gICAgICB0eXBlb2YgbmV4dFByb3BzLm1heFdpZHRoID09PSAnbnVtYmVyJ1xuICAgICAgICA/IGAke25leHRQcm9wcy5tYXhXaWR0aH1weGBcbiAgICAgICAgOiBuZXh0UHJvcHMubWF4V2lkdGg7XG5cbiAgICBpZiAobmV4dFByb3BzLnJvbGUpIHtcbiAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCBuZXh0UHJvcHMucm9sZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBwcmV2UHJvcHMuY29udGVudCAhPT0gbmV4dFByb3BzLmNvbnRlbnQgfHxcbiAgICAgIHByZXZQcm9wcy5hbGxvd0hUTUwgIT09IG5leHRQcm9wcy5hbGxvd0hUTUxcbiAgICApIHtcbiAgICAgIHNldENvbnRlbnQoY29udGVudCwgaW5zdGFuY2UucHJvcHMpO1xuICAgIH1cblxuICAgIGlmIChuZXh0UHJvcHMuYXJyb3cpIHtcbiAgICAgIGlmICghYXJyb3cpIHtcbiAgICAgICAgYm94LmFwcGVuZENoaWxkKGNyZWF0ZUFycm93RWxlbWVudChuZXh0UHJvcHMuYXJyb3cpKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldlByb3BzLmFycm93ICE9PSBuZXh0UHJvcHMuYXJyb3cpIHtcbiAgICAgICAgYm94LnJlbW92ZUNoaWxkKGFycm93KTtcbiAgICAgICAgYm94LmFwcGVuZENoaWxkKGNyZWF0ZUFycm93RWxlbWVudChuZXh0UHJvcHMuYXJyb3cpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFycm93KSB7XG4gICAgICBib3gucmVtb3ZlQ2hpbGQoYXJyb3chKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvcHBlcixcbiAgICBvblVwZGF0ZSxcbiAgfTtcbn1cblxuLy8gUnVudGltZSBjaGVjayB0byBpZGVudGlmeSBpZiB0aGUgcmVuZGVyIGZ1bmN0aW9uIGlzIHRoZSBkZWZhdWx0IG9uZTsgdGhpc1xuLy8gd2F5IHdlIGNhbiBhcHBseSBkZWZhdWx0IENTUyB0cmFuc2l0aW9ucyBsb2dpYyBhbmQgaXQgY2FuIGJlIHRyZWUtc2hha2VuIGF3YXlcbnJlbmRlci4kJHRpcHB5ID0gdHJ1ZTtcbiIsICJpbXBvcnQge2NyZWF0ZVBvcHBlciwgU3RyaWN0TW9kaWZpZXJzLCBNb2RpZmllcn0gZnJvbSAnQHBvcHBlcmpzL2NvcmUnO1xuaW1wb3J0IHtjdXJyZW50SW5wdXR9IGZyb20gJy4vYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzJztcbmltcG9ydCB7aXNJRTExfSBmcm9tICcuL2Jyb3dzZXInO1xuaW1wb3J0IHtUSVBQWV9ERUZBVUxUX0FQUEVORF9UTywgVE9VQ0hfT1BUSU9OU30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtcbiAgYWN0dWFsQ29udGFpbnMsXG4gIGRpdixcbiAgZ2V0T3duZXJEb2N1bWVudCxcbiAgaXNDdXJzb3JPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIsXG4gIGlzTW91c2VFdmVudCxcbiAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uLFxuICBzZXRWaXNpYmlsaXR5U3RhdGUsXG4gIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcixcbn0gZnJvbSAnLi9kb20tdXRpbHMnO1xuaW1wb3J0IHtkZWZhdWx0UHJvcHMsIGV2YWx1YXRlUHJvcHMsIGdldEV4dGVuZGVkUGFzc2VkUHJvcHN9IGZyb20gJy4vcHJvcHMnO1xuaW1wb3J0IHtnZXRDaGlsZHJlbn0gZnJvbSAnLi90ZW1wbGF0ZSc7XG5pbXBvcnQge1xuICBDb250ZW50LFxuICBJbnN0YW5jZSxcbiAgTGlmZWN5Y2xlSG9va3MsXG4gIFBvcHBlckVsZW1lbnQsXG4gIFByb3BzLFxuICBSZWZlcmVuY2VFbGVtZW50LFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7TGlzdGVuZXJPYmplY3QsIFBvcHBlclRyZWVEYXRhLCBQb3BwZXJDaGlsZHJlbn0gZnJvbSAnLi90eXBlcy1pbnRlcm5hbCc7XG5pbXBvcnQge1xuICBhcnJheUZyb20sXG4gIGRlYm91bmNlLFxuICBnZXRWYWx1ZUF0SW5kZXhPclJldHVybixcbiAgaW52b2tlV2l0aEFyZ3NPclJldHVybixcbiAgbm9ybWFsaXplVG9BcnJheSxcbiAgcHVzaElmVW5pcXVlLFxuICBzcGxpdEJ5U3BhY2VzLFxuICB1bmlxdWUsXG4gIHJlbW92ZVVuZGVmaW5lZFByb3BzLFxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7Y3JlYXRlTWVtb3J5TGVha1dhcm5pbmcsIGVycm9yV2hlbiwgd2FybldoZW59IGZyb20gJy4vdmFsaWRhdGlvbic7XG5cbmxldCBpZENvdW50ZXIgPSAxO1xubGV0IG1vdXNlTW92ZUxpc3RlbmVyczogKChldmVudDogTW91c2VFdmVudCkgPT4gdm9pZClbXSA9IFtdO1xuXG4vLyBVc2VkIGJ5IGBoaWRlQWxsKClgXG5leHBvcnQgbGV0IG1vdW50ZWRJbnN0YW5jZXM6IEluc3RhbmNlW10gPSBbXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlVGlwcHkoXG4gIHJlZmVyZW5jZTogUmVmZXJlbmNlRWxlbWVudCxcbiAgcGFzc2VkUHJvcHM6IFBhcnRpYWw8UHJvcHM+XG4pOiBJbnN0YW5jZSB7XG4gIGNvbnN0IHByb3BzID0gZXZhbHVhdGVQcm9wcyhyZWZlcmVuY2UsIHtcbiAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgLi4uZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wcyhyZW1vdmVVbmRlZmluZWRQcm9wcyhwYXNzZWRQcm9wcykpLFxuICB9KTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8g8J+UkiBQcml2YXRlIG1lbWJlcnNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGxldCBzaG93VGltZW91dDogYW55O1xuICBsZXQgaGlkZVRpbWVvdXQ6IGFueTtcbiAgbGV0IHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lOiBudW1iZXI7XG4gIGxldCBpc1Zpc2libGVGcm9tQ2xpY2sgPSBmYWxzZTtcbiAgbGV0IGRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duID0gZmFsc2U7XG4gIGxldCBkaWRUb3VjaE1vdmUgPSBmYWxzZTtcbiAgbGV0IGlnbm9yZU9uRmlyc3RVcGRhdGUgPSBmYWxzZTtcbiAgbGV0IGxhc3RUcmlnZ2VyRXZlbnQ6IEV2ZW50IHwgdW5kZWZpbmVkO1xuICBsZXQgY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lcjogKGV2ZW50OiBUcmFuc2l0aW9uRXZlbnQpID0+IHZvaWQ7XG4gIGxldCBvbkZpcnN0VXBkYXRlOiAoKSA9PiB2b2lkO1xuICBsZXQgbGlzdGVuZXJzOiBMaXN0ZW5lck9iamVjdFtdID0gW107XG4gIGxldCBkZWJvdW5jZWRPbk1vdXNlTW92ZSA9IGRlYm91bmNlKG9uTW91c2VNb3ZlLCBwcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlKTtcbiAgbGV0IGN1cnJlbnRUYXJnZXQ6IEVsZW1lbnQ7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCflJEgUHVibGljIG1lbWJlcnNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IGlkID0gaWRDb3VudGVyKys7XG4gIGNvbnN0IHBvcHBlckluc3RhbmNlID0gbnVsbDtcbiAgY29uc3QgcGx1Z2lucyA9IHVuaXF1ZShwcm9wcy5wbHVnaW5zKTtcblxuICBjb25zdCBzdGF0ZSA9IHtcbiAgICAvLyBJcyB0aGUgaW5zdGFuY2UgY3VycmVudGx5IGVuYWJsZWQ/XG4gICAgaXNFbmFibGVkOiB0cnVlLFxuICAgIC8vIElzIHRoZSB0aXBweSBjdXJyZW50bHkgc2hvd2luZyBhbmQgbm90IHRyYW5zaXRpb25pbmcgb3V0P1xuICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgLy8gSGFzIHRoZSBpbnN0YW5jZSBiZWVuIGRlc3Ryb3llZD9cbiAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgLy8gSXMgdGhlIHRpcHB5IGN1cnJlbnRseSBtb3VudGVkIHRvIHRoZSBET00/XG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICAvLyBIYXMgdGhlIHRpcHB5IGZpbmlzaGVkIHRyYW5zaXRpb25pbmcgaW4/XG4gICAgaXNTaG93bjogZmFsc2UsXG4gIH07XG5cbiAgY29uc3QgaW5zdGFuY2U6IEluc3RhbmNlID0ge1xuICAgIC8vIHByb3BlcnRpZXNcbiAgICBpZCxcbiAgICByZWZlcmVuY2UsXG4gICAgcG9wcGVyOiBkaXYoKSxcbiAgICBwb3BwZXJJbnN0YW5jZSxcbiAgICBwcm9wcyxcbiAgICBzdGF0ZSxcbiAgICBwbHVnaW5zLFxuICAgIC8vIG1ldGhvZHNcbiAgICBjbGVhckRlbGF5VGltZW91dHMsXG4gICAgc2V0UHJvcHMsXG4gICAgc2V0Q29udGVudCxcbiAgICBzaG93LFxuICAgIGhpZGUsXG4gICAgaGlkZVdpdGhJbnRlcmFjdGl2aXR5LFxuICAgIGVuYWJsZSxcbiAgICBkaXNhYmxlLFxuICAgIHVubW91bnQsXG4gICAgZGVzdHJveSxcbiAgfTtcblxuICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSB3aHkgdGhpcyBlYXJseSByZXR1cm4gY2F1c2VzIGEgVERaIGVycm9yIGluIHRoZSB0ZXN0cyDigJRcbiAgLy8gaXQgZG9lc24ndCBzZWVtIHRvIGhhcHBlbiBpbiB0aGUgYnJvd3NlclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFwcm9wcy5yZW5kZXIpIHtcbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgZXJyb3JXaGVuKHRydWUsICdyZW5kZXIoKSBmdW5jdGlvbiBoYXMgbm90IGJlZW4gc3VwcGxpZWQuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEluaXRpYWwgbXV0YXRpb25zXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCB7cG9wcGVyLCBvblVwZGF0ZX0gPSBwcm9wcy5yZW5kZXIoaW5zdGFuY2UpO1xuXG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ2RhdGEtX19OQU1FU1BBQ0VfUFJFRklYX18tcm9vdCcsICcnKTtcbiAgcG9wcGVyLmlkID0gYF9fTkFNRVNQQUNFX1BSRUZJWF9fLSR7aW5zdGFuY2UuaWR9YDtcblxuICBpbnN0YW5jZS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJlZmVyZW5jZS5fdGlwcHkgPSBpbnN0YW5jZTtcbiAgcG9wcGVyLl90aXBweSA9IGluc3RhbmNlO1xuXG4gIGNvbnN0IHBsdWdpbnNIb29rcyA9IHBsdWdpbnMubWFwKChwbHVnaW4pID0+IHBsdWdpbi5mbihpbnN0YW5jZSkpO1xuICBjb25zdCBoYXNBcmlhRXhwYW5kZWQgPSByZWZlcmVuY2UuaGFzQXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyk7XG5cbiAgYWRkTGlzdGVuZXJzKCk7XG4gIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuICBoYW5kbGVTdHlsZXMoKTtcblxuICBpbnZva2VIb29rKCdvbkNyZWF0ZScsIFtpbnN0YW5jZV0pO1xuXG4gIGlmIChwcm9wcy5zaG93T25DcmVhdGUpIHtcbiAgICBzY2hlZHVsZVNob3coKTtcbiAgfVxuXG4gIC8vIFByZXZlbnQgYSB0aXBweSB3aXRoIGEgZGVsYXkgZnJvbSBoaWRpbmcgaWYgdGhlIGN1cnNvciBsZWZ0IHRoZW4gcmV0dXJuZWRcbiAgLy8gYmVmb3JlIGl0IHN0YXJ0ZWQgaGlkaW5nXG4gIHBvcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJiBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuICAgIH1cbiAgfSk7XG5cbiAgcG9wcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgaWYgKFxuICAgICAgaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiZcbiAgICAgIGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignbW91c2VlbnRlcicpID49IDBcbiAgICApIHtcbiAgICAgIGdldERvY3VtZW50KCkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyDwn5SSIFByaXZhdGUgbWV0aG9kc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZFRvdWNoU2V0dGluZ3MoKTogW3N0cmluZyB8IGJvb2xlYW4sIG51bWJlcl0ge1xuICAgIGNvbnN0IHt0b3VjaH0gPSBpbnN0YW5jZS5wcm9wcztcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0b3VjaCkgPyB0b3VjaCA6IFt0b3VjaCwgMF07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJc0N1c3RvbVRvdWNoQmVoYXZpb3IoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzKClbMF0gPT09ICdob2xkJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElzRGVmYXVsdFJlbmRlckZuKCk6IGJvb2xlYW4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gISFpbnN0YW5jZS5wcm9wcy5yZW5kZXI/LiQkdGlwcHk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXJyZW50VGFyZ2V0KCk6IEVsZW1lbnQge1xuICAgIHJldHVybiBjdXJyZW50VGFyZ2V0IHx8IHJlZmVyZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERvY3VtZW50KCk6IERvY3VtZW50IHtcbiAgICBjb25zdCBwYXJlbnQgPSBnZXRDdXJyZW50VGFyZ2V0KCkucGFyZW50Tm9kZSBhcyBFbGVtZW50O1xuICAgIHJldHVybiBwYXJlbnQgPyBnZXRPd25lckRvY3VtZW50KHBhcmVudCkgOiBkb2N1bWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCk6IFBvcHBlckNoaWxkcmVuIHtcbiAgICByZXR1cm4gZ2V0Q2hpbGRyZW4ocG9wcGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERlbGF5KGlzU2hvdzogYm9vbGVhbik6IG51bWJlciB7XG4gICAgLy8gRm9yIHRvdWNoIG9yIGtleWJvYXJkIGlucHV0LCBmb3JjZSBgMGAgZGVsYXkgZm9yIFVYIHJlYXNvbnNcbiAgICAvLyBBbHNvIGlmIHRoZSBpbnN0YW5jZSBpcyBtb3VudGVkIGJ1dCBub3QgdmlzaWJsZSAodHJhbnNpdGlvbmluZyBvdXQpLFxuICAgIC8vIGlnbm9yZSBkZWxheVxuICAgIGlmIChcbiAgICAgIChpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgJiYgIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkgfHxcbiAgICAgIGN1cnJlbnRJbnB1dC5pc1RvdWNoIHx8XG4gICAgICAobGFzdFRyaWdnZXJFdmVudCAmJiBsYXN0VHJpZ2dlckV2ZW50LnR5cGUgPT09ICdmb2N1cycpXG4gICAgKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4oXG4gICAgICBpbnN0YW5jZS5wcm9wcy5kZWxheSxcbiAgICAgIGlzU2hvdyA/IDAgOiAxLFxuICAgICAgZGVmYXVsdFByb3BzLmRlbGF5XG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0eWxlcyhmcm9tSGlkZSA9IGZhbHNlKTogdm9pZCB7XG4gICAgcG9wcGVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPVxuICAgICAgaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgIWZyb21IaWRlID8gJycgOiAnbm9uZSc7XG4gICAgcG9wcGVyLnN0eWxlLnpJbmRleCA9IGAke2luc3RhbmNlLnByb3BzLnpJbmRleH1gO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSG9vayhcbiAgICBob29rOiBrZXlvZiBMaWZlY3ljbGVIb29rcyxcbiAgICBhcmdzOiBbSW5zdGFuY2UsIGFueT9dLFxuICAgIHNob3VsZEludm9rZVByb3BzSG9vayA9IHRydWVcbiAgKTogdm9pZCB7XG4gICAgcGx1Z2luc0hvb2tzLmZvckVhY2goKHBsdWdpbkhvb2tzKSA9PiB7XG4gICAgICBpZiAocGx1Z2luSG9va3NbaG9va10pIHtcbiAgICAgICAgcGx1Z2luSG9va3NbaG9va10hKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHNob3VsZEludm9rZVByb3BzSG9vaykge1xuICAgICAgaW5zdGFuY2UucHJvcHNbaG9va10oLi4uYXJncyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQXJpYUNvbnRlbnRBdHRyaWJ1dGUoKTogdm9pZCB7XG4gICAgY29uc3Qge2FyaWF9ID0gaW5zdGFuY2UucHJvcHM7XG5cbiAgICBpZiAoIWFyaWEuY29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHIgPSBgYXJpYS0ke2FyaWEuY29udGVudH1gO1xuICAgIGNvbnN0IGlkID0gcG9wcGVyLmlkO1xuICAgIGNvbnN0IG5vZGVzID0gbm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG5cbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyKTtcblxuICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCBjdXJyZW50VmFsdWUgPyBgJHtjdXJyZW50VmFsdWV9ICR7aWR9YCA6IGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IGN1cnJlbnRWYWx1ZSAmJiBjdXJyZW50VmFsdWUucmVwbGFjZShpZCwgJycpLnRyaW0oKTtcblxuICAgICAgICBpZiAobmV4dFZhbHVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgbmV4dFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk6IHZvaWQge1xuICAgIGlmIChoYXNBcmlhRXhwYW5kZWQgfHwgIWluc3RhbmNlLnByb3BzLmFyaWEuZXhwYW5kZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlcyA9IG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpO1xuXG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFxuICAgICAgICAgICdhcmlhLWV4cGFuZGVkJyxcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiYgbm9kZSA9PT0gZ2V0Q3VycmVudFRhcmdldCgpXG4gICAgICAgICAgICA/ICd0cnVlJ1xuICAgICAgICAgICAgOiAnZmFsc2UnXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgZ2V0RG9jdW1lbnQoKS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSk7XG4gICAgbW91c2VNb3ZlTGlzdGVuZXJzID0gbW91c2VNb3ZlTGlzdGVuZXJzLmZpbHRlcihcbiAgICAgIChsaXN0ZW5lcikgPT4gbGlzdGVuZXIgIT09IGRlYm91bmNlZE9uTW91c2VNb3ZlXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRG9jdW1lbnRQcmVzcyhldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpOiB2b2lkIHtcbiAgICAvLyBNb3ZlZCBmaW5nZXIgdG8gc2Nyb2xsIGluc3RlYWQgb2YgYW4gaW50ZW50aW9uYWwgdGFwIG91dHNpZGVcbiAgICBpZiAoY3VycmVudElucHV0LmlzVG91Y2gpIHtcbiAgICAgIGlmIChkaWRUb3VjaE1vdmUgfHwgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFjdHVhbFRhcmdldCA9XG4gICAgICAoZXZlbnQuY29tcG9zZWRQYXRoICYmIGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdKSB8fCBldmVudC50YXJnZXQ7XG5cbiAgICAvLyBDbGlja2VkIG9uIGludGVyYWN0aXZlIHBvcHBlclxuICAgIGlmIChcbiAgICAgIGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmXG4gICAgICBhY3R1YWxDb250YWlucyhwb3BwZXIsIGFjdHVhbFRhcmdldCBhcyBFbGVtZW50KVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsaWNrZWQgb24gdGhlIGV2ZW50IGxpc3RlbmVycyB0YXJnZXRcbiAgICBpZiAoXG4gICAgICBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKS5zb21lKChlbCkgPT5cbiAgICAgICAgYWN0dWFsQ29udGFpbnMoZWwsIGFjdHVhbFRhcmdldCBhcyBFbGVtZW50KVxuICAgICAgKVxuICAgICkge1xuICAgICAgaWYgKGN1cnJlbnRJbnB1dC5pc1RvdWNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiZcbiAgICAgICAgaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdjbGljaycpID49IDBcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGludm9rZUhvb2soJ29uQ2xpY2tPdXRzaWRlJywgW2luc3RhbmNlLCBldmVudF0pO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5oaWRlT25DbGljayA9PT0gdHJ1ZSkge1xuICAgICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG4gICAgICBpbnN0YW5jZS5oaWRlKCk7XG5cbiAgICAgIC8vIGBtb3VzZWRvd25gIGV2ZW50IGlzIGZpcmVkIHJpZ2h0IGJlZm9yZSBgZm9jdXNgIGlmIHByZXNzaW5nIHRoZVxuICAgICAgLy8gY3VycmVudFRhcmdldC4gVGhpcyBsZXRzIGEgdGlwcHkgd2l0aCBgZm9jdXNgIHRyaWdnZXIga25vdyB0aGF0IGl0XG4gICAgICAvLyBzaG91bGQgbm90IHNob3dcbiAgICAgIGRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRoZSBsaXN0ZW5lciBnZXRzIGFkZGVkIGluIGBzY2hlZHVsZVNob3coKWAsIGJ1dCB0aGlzIG1heSBiZSBoaWRpbmcgaXRcbiAgICAgIC8vIGJlZm9yZSBpdCBzaG93cywgYW5kIGhpZGUoKSdzIGVhcmx5IGJhaWwtb3V0IGJlaGF2aW9yIGNhbiBwcmV2ZW50IGl0XG4gICAgICAvLyBmcm9tIGJlaW5nIGNsZWFuZWQgdXBcbiAgICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIHJlbW92ZURvY3VtZW50UHJlc3MoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoTW92ZSgpOiB2b2lkIHtcbiAgICBkaWRUb3VjaE1vdmUgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KCk6IHZvaWQge1xuICAgIGRpZFRvdWNoTW92ZSA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRG9jdW1lbnRQcmVzcygpOiB2b2lkIHtcbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudCgpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbkRvY3VtZW50UHJlc3MsIHRydWUpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uRG9jdW1lbnRQcmVzcywgVE9VQ0hfT1BUSU9OUyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIFRPVUNIX09QVElPTlMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgVE9VQ0hfT1BUSU9OUyk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVEb2N1bWVudFByZXNzKCk6IHZvaWQge1xuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KCk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uRG9jdW1lbnRQcmVzcywgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Eb2N1bWVudFByZXNzLCBUT1VDSF9PUFRJT05TKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgVE9VQ0hfT1BUSU9OUyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBUT1VDSF9PUFRJT05TKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbmVkT3V0KGR1cmF0aW9uOiBudW1iZXIsIGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgb25UcmFuc2l0aW9uRW5kKGR1cmF0aW9uLCAoKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgICFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiZcbiAgICAgICAgcG9wcGVyLnBhcmVudE5vZGUgJiZcbiAgICAgICAgcG9wcGVyLnBhcmVudE5vZGUuY29udGFpbnMocG9wcGVyKVxuICAgICAgKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zaXRpb25lZEluKGR1cmF0aW9uOiBudW1iZXIsIGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgb25UcmFuc2l0aW9uRW5kKGR1cmF0aW9uLCBjYWxsYmFjayk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQoZHVyYXRpb246IG51bWJlciwgY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBjb25zdCBib3ggPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpLmJveDtcblxuICAgIGZ1bmN0aW9uIGxpc3RlbmVyKGV2ZW50OiBUcmFuc2l0aW9uRXZlbnQpOiB2b2lkIHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGJveCkge1xuICAgICAgICB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIoYm94LCAncmVtb3ZlJywgbGlzdGVuZXIpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1ha2UgY2FsbGJhY2sgc3luY2hyb25vdXMgaWYgZHVyYXRpb24gaXMgMFxuICAgIC8vIGB0cmFuc2l0aW9uZW5kYCB3b24ndCBmaXJlIG90aGVyd2lzZVxuICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKGJveCwgJ3JlbW92ZScsIGN1cnJlbnRUcmFuc2l0aW9uRW5kTGlzdGVuZXIpO1xuICAgIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcihib3gsICdhZGQnLCBsaXN0ZW5lcik7XG5cbiAgICBjdXJyZW50VHJhbnNpdGlvbkVuZExpc3RlbmVyID0gbGlzdGVuZXI7XG4gIH1cblxuICBmdW5jdGlvbiBvbihcbiAgICBldmVudFR5cGU6IHN0cmluZyxcbiAgICBoYW5kbGVyOiBFdmVudExpc3RlbmVyLFxuICAgIG9wdGlvbnM6IGJvb2xlYW4gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IGZhbHNlXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IG5vZGVzID0gbm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICBsaXN0ZW5lcnMucHVzaCh7bm9kZSwgZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgaWYgKGdldElzQ3VzdG9tVG91Y2hCZWhhdmlvcigpKSB7XG4gICAgICBvbigndG91Y2hzdGFydCcsIG9uVHJpZ2dlciwge3Bhc3NpdmU6IHRydWV9KTtcbiAgICAgIG9uKCd0b3VjaGVuZCcsIG9uTW91c2VMZWF2ZSBhcyBFdmVudExpc3RlbmVyLCB7cGFzc2l2ZTogdHJ1ZX0pO1xuICAgIH1cblxuICAgIHNwbGl0QnlTcGFjZXMoaW5zdGFuY2UucHJvcHMudHJpZ2dlcikuZm9yRWFjaCgoZXZlbnRUeXBlKSA9PiB7XG4gICAgICBpZiAoZXZlbnRUeXBlID09PSAnbWFudWFsJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9uKGV2ZW50VHlwZSwgb25UcmlnZ2VyKTtcblxuICAgICAgc3dpdGNoIChldmVudFR5cGUpIHtcbiAgICAgICAgY2FzZSAnbW91c2VlbnRlcic6XG4gICAgICAgICAgb24oJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUgYXMgRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgICAgICBvbihpc0lFMTEgPyAnZm9jdXNvdXQnIDogJ2JsdXInLCBvbkJsdXJPckZvY3VzT3V0IGFzIEV2ZW50TGlzdGVuZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgICAgICBvbignZm9jdXNvdXQnLCBvbkJsdXJPckZvY3VzT3V0IGFzIEV2ZW50TGlzdGVuZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKCh7bm9kZSwgZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zfTogTGlzdGVuZXJPYmplY3QpID0+IHtcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIGxpc3RlbmVycyA9IFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmlnZ2VyKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgIGxldCBzaG91bGRTY2hlZHVsZUNsaWNrSGlkZSA9IGZhbHNlO1xuXG4gICAgaWYgKFxuICAgICAgIWluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZCB8fFxuICAgICAgaXNFdmVudExpc3RlbmVyU3RvcHBlZChldmVudCkgfHxcbiAgICAgIGRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgd2FzRm9jdXNlZCA9IGxhc3RUcmlnZ2VyRXZlbnQ/LnR5cGUgPT09ICdmb2N1cyc7XG5cbiAgICBsYXN0VHJpZ2dlckV2ZW50ID0gZXZlbnQ7XG4gICAgY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgYXMgRWxlbWVudDtcblxuICAgIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiYgaXNNb3VzZUV2ZW50KGV2ZW50KSkge1xuICAgICAgLy8gSWYgc2Nyb2xsaW5nLCBgbW91c2VlbnRlcmAgZXZlbnRzIGNhbiBiZSBmaXJlZCBpZiB0aGUgY3Vyc29yIGxhbmRzXG4gICAgICAvLyBvdmVyIGEgbmV3IHRhcmdldCwgYnV0IGBtb3VzZW1vdmVgIGV2ZW50cyBkb24ndCBnZXQgZmlyZWQuIFRoaXNcbiAgICAgIC8vIGNhdXNlcyBpbnRlcmFjdGl2ZSB0b29sdGlwcyB0byBnZXQgc3R1Y2sgb3BlbiB1bnRpbCB0aGUgY3Vyc29yIGlzXG4gICAgICAvLyBtb3ZlZFxuICAgICAgbW91c2VNb3ZlTGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihldmVudCkpO1xuICAgIH1cblxuICAgIC8vIFRvZ2dsZSBzaG93L2hpZGUgd2hlbiBjbGlja2luZyBjbGljay10cmlnZ2VyZWQgdG9vbHRpcHNcbiAgICBpZiAoXG4gICAgICBldmVudC50eXBlID09PSAnY2xpY2snICYmXG4gICAgICAoaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdtb3VzZWVudGVyJykgPCAwIHx8XG4gICAgICAgIGlzVmlzaWJsZUZyb21DbGljaykgJiZcbiAgICAgIGluc3RhbmNlLnByb3BzLmhpZGVPbkNsaWNrICE9PSBmYWxzZSAmJlxuICAgICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlXG4gICAgKSB7XG4gICAgICBzaG91bGRTY2hlZHVsZUNsaWNrSGlkZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlU2hvdyhldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgIGlzVmlzaWJsZUZyb21DbGljayA9ICFzaG91bGRTY2hlZHVsZUNsaWNrSGlkZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkU2NoZWR1bGVDbGlja0hpZGUgJiYgIXdhc0ZvY3VzZWQpIHtcbiAgICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgTm9kZTtcbiAgICBjb25zdCBpc0N1cnNvck92ZXJSZWZlcmVuY2VPclBvcHBlciA9XG4gICAgICBnZXRDdXJyZW50VGFyZ2V0KCkuY29udGFpbnModGFyZ2V0KSB8fCBwb3BwZXIuY29udGFpbnModGFyZ2V0KTtcblxuICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJyAmJiBpc0N1cnNvck92ZXJSZWZlcmVuY2VPclBvcHBlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBvcHBlclRyZWVEYXRhID0gZ2V0TmVzdGVkUG9wcGVyVHJlZSgpXG4gICAgICAuY29uY2F0KHBvcHBlcilcbiAgICAgIC5tYXAoKHBvcHBlcikgPT4ge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHBvcHBlci5fdGlwcHkhO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGluc3RhbmNlLnBvcHBlckluc3RhbmNlPy5zdGF0ZTtcblxuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9wcGVyUmVjdDogcG9wcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgcG9wcGVyU3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoQm9vbGVhbikgYXMgUG9wcGVyVHJlZURhdGFbXTtcblxuICAgIGlmIChpc0N1cnNvck91dHNpZGVJbnRlcmFjdGl2ZUJvcmRlcihwb3BwZXJUcmVlRGF0YSwgZXZlbnQpKSB7XG4gICAgICBjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycygpO1xuICAgICAgc2NoZWR1bGVIaWRlKGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBzaG91bGRCYWlsID1cbiAgICAgIGlzRXZlbnRMaXN0ZW5lclN0b3BwZWQoZXZlbnQpIHx8XG4gICAgICAoaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdjbGljaycpID49IDAgJiYgaXNWaXNpYmxlRnJvbUNsaWNrKTtcblxuICAgIGlmIChzaG91bGRCYWlsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICBpbnN0YW5jZS5oaWRlV2l0aEludGVyYWN0aXZpdHkoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkJsdXJPckZvY3VzT3V0KGV2ZW50OiBGb2N1c0V2ZW50KTogdm9pZCB7XG4gICAgaWYgKFxuICAgICAgaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdmb2N1c2luJykgPCAwICYmXG4gICAgICBldmVudC50YXJnZXQgIT09IGdldEN1cnJlbnRUYXJnZXQoKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGZvY3VzIHdhcyBtb3ZlZCB0byB3aXRoaW4gdGhlIHBvcHBlclxuICAgIGlmIChcbiAgICAgIGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmXG4gICAgICBldmVudC5yZWxhdGVkVGFyZ2V0ICYmXG4gICAgICBwb3BwZXIuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCBhcyBFbGVtZW50KVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0V2ZW50TGlzdGVuZXJTdG9wcGVkKGV2ZW50OiBFdmVudCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBjdXJyZW50SW5wdXQuaXNUb3VjaFxuICAgICAgPyBnZXRJc0N1c3RvbVRvdWNoQmVoYXZpb3IoKSAhPT0gZXZlbnQudHlwZS5pbmRleE9mKCd0b3VjaCcpID49IDBcbiAgICAgIDogZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQb3BwZXJJbnN0YW5jZSgpOiB2b2lkIHtcbiAgICBkZXN0cm95UG9wcGVySW5zdGFuY2UoKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIHBvcHBlck9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBvZmZzZXQsXG4gICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgICAgbW92ZVRyYW5zaXRpb24sXG4gICAgfSA9IGluc3RhbmNlLnByb3BzO1xuXG4gICAgY29uc3QgYXJyb3cgPSBnZXRJc0RlZmF1bHRSZW5kZXJGbigpID8gZ2V0Q2hpbGRyZW4ocG9wcGVyKS5hcnJvdyA6IG51bGw7XG5cbiAgICBjb25zdCBjb21wdXRlZFJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZUNsaWVudFJlY3RcbiAgICAgID8ge1xuICAgICAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICAgICAgICBjb250ZXh0RWxlbWVudDpcbiAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3QuY29udGV4dEVsZW1lbnQgfHwgZ2V0Q3VycmVudFRhcmdldCgpLFxuICAgICAgICB9XG4gICAgICA6IHJlZmVyZW5jZTtcblxuICAgIGNvbnN0IHRpcHB5TW9kaWZpZXI6IE1vZGlmaWVyPCckJHRpcHB5JywgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+ID0ge1xuICAgICAgbmFtZTogJyQkdGlwcHknLFxuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICAgICAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddLFxuICAgICAgZm4oe3N0YXRlfSkge1xuICAgICAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgICAgIGNvbnN0IHtib3h9ID0gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKTtcblxuICAgICAgICAgIFsncGxhY2VtZW50JywgJ3JlZmVyZW5jZS1oaWRkZW4nLCAnZXNjYXBlZCddLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgICAgICAgIGlmIChhdHRyID09PSAncGxhY2VtZW50Jykge1xuICAgICAgICAgICAgICBib3guc2V0QXR0cmlidXRlKCdkYXRhLXBsYWNlbWVudCcsIHN0YXRlLnBsYWNlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuYXR0cmlidXRlcy5wb3BwZXJbYGRhdGEtcG9wcGVyLSR7YXR0cn1gXSkge1xuICAgICAgICAgICAgICAgIGJveC5zZXRBdHRyaWJ1dGUoYGRhdGEtJHthdHRyfWAsICcnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib3gucmVtb3ZlQXR0cmlidXRlKGBkYXRhLSR7YXR0cn1gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgdHlwZSBUaXBweU1vZGlmaWVyID0gTW9kaWZpZXI8JyQkdGlwcHknLCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj47XG4gICAgdHlwZSBFeHRlbmRlZE1vZGlmaWVycyA9IFN0cmljdE1vZGlmaWVycyB8IFBhcnRpYWw8VGlwcHlNb2RpZmllcj47XG5cbiAgICBjb25zdCBtb2RpZmllcnM6IEFycmF5PEV4dGVuZGVkTW9kaWZpZXJzPiA9IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgIHRvcDogMixcbiAgICAgICAgICAgIGJvdHRvbTogMixcbiAgICAgICAgICAgIGxlZnQ6IDUsXG4gICAgICAgICAgICByaWdodDogNSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2ZsaXAnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgcGFkZGluZzogNSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGFkYXB0aXZlOiAhbW92ZVRyYW5zaXRpb24sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgdGlwcHlNb2RpZmllcixcbiAgICBdO1xuXG4gICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkgJiYgYXJyb3cpIHtcbiAgICAgIG1vZGlmaWVycy5wdXNoKHtcbiAgICAgICAgbmFtZTogJ2Fycm93JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGVsZW1lbnQ6IGFycm93LFxuICAgICAgICAgIHBhZGRpbmc6IDMsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2RpZmllcnMucHVzaCguLi4ocG9wcGVyT3B0aW9ucz8ubW9kaWZpZXJzIHx8IFtdKSk7XG5cbiAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSA9IGNyZWF0ZVBvcHBlcjxFeHRlbmRlZE1vZGlmaWVycz4oXG4gICAgICBjb21wdXRlZFJlZmVyZW5jZSxcbiAgICAgIHBvcHBlcixcbiAgICAgIHtcbiAgICAgICAgLi4ucG9wcGVyT3B0aW9ucyxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBvbkZpcnN0VXBkYXRlLFxuICAgICAgICBtb2RpZmllcnMsXG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3lQb3BwZXJJbnN0YW5jZSgpOiB2b2lkIHtcbiAgICBpZiAoaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudCgpOiB2b2lkIHtcbiAgICBjb25zdCB7YXBwZW5kVG99ID0gaW5zdGFuY2UucHJvcHM7XG5cbiAgICBsZXQgcGFyZW50Tm9kZTogYW55O1xuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UnbGwgYXBwZW5kIHRoZSBwb3BwZXIgdG8gdGhlIHRyaWdnZXJUYXJnZXRzJ3MgcGFyZW50Tm9kZSBzb1xuICAgIC8vIGl0J3MgZGlyZWN0bHkgYWZ0ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50IHNvIHRoZSBlbGVtZW50cyBpbnNpZGUgdGhlXG4gICAgLy8gdGlwcHkgY2FuIGJlIHRhYmJlZCB0b1xuICAgIC8vIElmIHRoZXJlIGFyZSBjbGlwcGluZyBpc3N1ZXMsIHRoZSB1c2VyIGNhbiBzcGVjaWZ5IGEgZGlmZmVyZW50IGFwcGVuZFRvXG4gICAgLy8gYW5kIGVuc3VyZSBmb2N1cyBtYW5hZ2VtZW50IGlzIGhhbmRsZWQgY29ycmVjdGx5IG1hbnVhbGx5XG4gICAgY29uc3Qgbm9kZSA9IGdldEN1cnJlbnRUYXJnZXQoKTtcblxuICAgIGlmIChcbiAgICAgIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJiBhcHBlbmRUbyA9PT0gVElQUFlfREVGQVVMVF9BUFBFTkRfVE8pIHx8XG4gICAgICBhcHBlbmRUbyA9PT0gJ3BhcmVudCdcbiAgICApIHtcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudE5vZGUgPSBpbnZva2VXaXRoQXJnc09yUmV0dXJuKGFwcGVuZFRvLCBbbm9kZV0pO1xuICAgIH1cblxuICAgIC8vIFRoZSBwb3BwZXIgZWxlbWVudCBuZWVkcyB0byBleGlzdCBvbiB0aGUgRE9NIGJlZm9yZSBpdHMgcG9zaXRpb24gY2FuIGJlXG4gICAgLy8gdXBkYXRlZCBhcyBQb3BwZXIgbmVlZHMgdG8gcmVhZCBpdHMgZGltZW5zaW9uc1xuICAgIGlmICghcGFyZW50Tm9kZS5jb250YWlucyhwb3BwZXIpKSB7XG4gICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKHBvcHBlcik7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkID0gdHJ1ZTtcblxuICAgIGNyZWF0ZVBvcHBlckluc3RhbmNlKCk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAvLyBBY2Nlc3NpYmlsaXR5IGNoZWNrXG4gICAgICB3YXJuV2hlbihcbiAgICAgICAgaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiZcbiAgICAgICAgICBhcHBlbmRUbyA9PT0gZGVmYXVsdFByb3BzLmFwcGVuZFRvICYmXG4gICAgICAgICAgbm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgIT09IHBvcHBlcixcbiAgICAgICAgW1xuICAgICAgICAgICdJbnRlcmFjdGl2ZSB0aXBweSBlbGVtZW50IG1heSBub3QgYmUgYWNjZXNzaWJsZSB2aWEga2V5Ym9hcmQnLFxuICAgICAgICAgICduYXZpZ2F0aW9uIGJlY2F1c2UgaXQgaXMgbm90IGRpcmVjdGx5IGFmdGVyIHRoZSByZWZlcmVuY2UgZWxlbWVudCcsXG4gICAgICAgICAgJ2luIHRoZSBET00gc291cmNlIG9yZGVyLicsXG4gICAgICAgICAgJ1xcblxcbicsXG4gICAgICAgICAgJ1VzaW5nIGEgd3JhcHBlciA8ZGl2PiBvciA8c3Bhbj4gdGFnIGFyb3VuZCB0aGUgcmVmZXJlbmNlIGVsZW1lbnQnLFxuICAgICAgICAgICdzb2x2ZXMgdGhpcyBieSBjcmVhdGluZyBhIG5ldyBwYXJlbnROb2RlIGNvbnRleHQuJyxcbiAgICAgICAgICAnXFxuXFxuJyxcbiAgICAgICAgICAnU3BlY2lmeWluZyBgYXBwZW5kVG86IGRvY3VtZW50LmJvZHlgIHNpbGVuY2VzIHRoaXMgd2FybmluZywgYnV0IGl0JyxcbiAgICAgICAgICAnYXNzdW1lcyB5b3UgYXJlIHVzaW5nIGEgZm9jdXMgbWFuYWdlbWVudCBzb2x1dGlvbiB0byBoYW5kbGUnLFxuICAgICAgICAgICdrZXlib2FyZCBuYXZpZ2F0aW9uLicsXG4gICAgICAgICAgJ1xcblxcbicsXG4gICAgICAgICAgJ1NlZTogaHR0cHM6Ly9hdG9taWtzLmdpdGh1Yi5pby90aXBweWpzL3Y2L2FjY2Vzc2liaWxpdHkvI2ludGVyYWN0aXZpdHknLFxuICAgICAgICBdLmpvaW4oJyAnKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXROZXN0ZWRQb3BwZXJUcmVlKCk6IFBvcHBlckVsZW1lbnRbXSB7XG4gICAgcmV0dXJuIGFycmF5RnJvbShcbiAgICAgIHBvcHBlci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1fX05BTUVTUEFDRV9QUkVGSVhfXy1yb290XScpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlU2hvdyhldmVudD86IEV2ZW50KTogdm9pZCB7XG4gICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG5cbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGludm9rZUhvb2soJ29uVHJpZ2dlcicsIFtpbnN0YW5jZSwgZXZlbnRdKTtcbiAgICB9XG5cbiAgICBhZGREb2N1bWVudFByZXNzKCk7XG5cbiAgICBsZXQgZGVsYXkgPSBnZXREZWxheSh0cnVlKTtcbiAgICBjb25zdCBbdG91Y2hWYWx1ZSwgdG91Y2hEZWxheV0gPSBnZXROb3JtYWxpemVkVG91Y2hTZXR0aW5ncygpO1xuXG4gICAgaWYgKGN1cnJlbnRJbnB1dC5pc1RvdWNoICYmIHRvdWNoVmFsdWUgPT09ICdob2xkJyAmJiB0b3VjaERlbGF5KSB7XG4gICAgICBkZWxheSA9IHRvdWNoRGVsYXk7XG4gICAgfVxuXG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBzaG93VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpbnN0YW5jZS5zaG93KCk7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnNob3coKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZUhpZGUoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG5cbiAgICBpbnZva2VIb29rKCdvblVudHJpZ2dlcicsIFtpbnN0YW5jZSwgZXZlbnRdKTtcblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICByZW1vdmVEb2N1bWVudFByZXNzKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGb3IgaW50ZXJhY3RpdmUgdGlwcGllcywgc2NoZWR1bGVIaWRlIGlzIGFkZGVkIHRvIGEgZG9jdW1lbnQuYm9keSBoYW5kbGVyXG4gICAgLy8gZnJvbSBvbk1vdXNlTGVhdmUgc28gbXVzdCBpbnRlcmNlcHQgc2NoZWR1bGVkIGhpZGVzIGZyb20gbW91c2Vtb3ZlL2xlYXZlXG4gICAgLy8gZXZlbnRzIHdoZW4gdHJpZ2dlciBjb250YWlucyBtb3VzZWVudGVyIGFuZCBjbGljaywgYW5kIHRoZSB0aXAgaXNcbiAgICAvLyBjdXJyZW50bHkgc2hvd24gYXMgYSByZXN1bHQgb2YgYSBjbGljay5cbiAgICBpZiAoXG4gICAgICBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ21vdXNlZW50ZXInKSA+PSAwICYmXG4gICAgICBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2NsaWNrJykgPj0gMCAmJlxuICAgICAgWydtb3VzZWxlYXZlJywgJ21vdXNlbW92ZSddLmluZGV4T2YoZXZlbnQudHlwZSkgPj0gMCAmJlxuICAgICAgaXNWaXNpYmxlRnJvbUNsaWNrXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGVsYXkgPSBnZXREZWxheShmYWxzZSk7XG5cbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGhpZGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRml4ZXMgYSBgdHJhbnNpdGlvbmVuZGAgcHJvYmxlbSB3aGVuIGl0IGZpcmVzIDEgZnJhbWUgdG9vXG4gICAgICAvLyBsYXRlIHNvbWV0aW1lcywgd2UgZG9uJ3Qgd2FudCBoaWRlKCkgdG8gYmUgY2FsbGVkLlxuICAgICAgc2NoZWR1bGVIaWRlQW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8g8J+UkSBQdWJsaWMgbWV0aG9kc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZnVuY3Rpb24gZW5hYmxlKCk6IHZvaWQge1xuICAgIGluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNhYmxlKCk6IHZvaWQge1xuICAgIC8vIERpc2FibGluZyB0aGUgaW5zdGFuY2Ugc2hvdWxkIGFsc28gaGlkZSBpdFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9taWtzL3RpcHB5LmpzLXJlYWN0L2lzc3Vlcy8xMDZcbiAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckRlbGF5VGltZW91dHMoKTogdm9pZCB7XG4gICAgY2xlYXJUaW1lb3V0KHNob3dUaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQoaGlkZVRpbWVvdXQpO1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByb3BzKHBhcnRpYWxQcm9wczogUGFydGlhbDxQcm9wcz4pOiB2b2lkIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ3NldFByb3BzJykpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludm9rZUhvb2soJ29uQmVmb3JlVXBkYXRlJywgW2luc3RhbmNlLCBwYXJ0aWFsUHJvcHNdKTtcblxuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuXG4gICAgY29uc3QgcHJldlByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgY29uc3QgbmV4dFByb3BzID0gZXZhbHVhdGVQcm9wcyhyZWZlcmVuY2UsIHtcbiAgICAgIC4uLnByZXZQcm9wcyxcbiAgICAgIC4uLnJlbW92ZVVuZGVmaW5lZFByb3BzKHBhcnRpYWxQcm9wcyksXG4gICAgICBpZ25vcmVBdHRyaWJ1dGVzOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBuZXh0UHJvcHM7XG5cbiAgICBhZGRMaXN0ZW5lcnMoKTtcblxuICAgIGlmIChwcmV2UHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSAhPT0gbmV4dFByb3BzLmludGVyYWN0aXZlRGVib3VuY2UpIHtcbiAgICAgIGNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzKCk7XG4gICAgICBkZWJvdW5jZWRPbk1vdXNlTW92ZSA9IGRlYm91bmNlKFxuICAgICAgICBvbk1vdXNlTW92ZSxcbiAgICAgICAgbmV4dFByb3BzLmludGVyYWN0aXZlRGVib3VuY2VcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHN0YWxlIGFyaWEtZXhwYW5kZWQgYXR0cmlidXRlcyBhcmUgcmVtb3ZlZFxuICAgIGlmIChwcmV2UHJvcHMudHJpZ2dlclRhcmdldCAmJiAhbmV4dFByb3BzLnRyaWdnZXJUYXJnZXQpIHtcbiAgICAgIG5vcm1hbGl6ZVRvQXJyYXkocHJldlByb3BzLnRyaWdnZXJUYXJnZXQpLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobmV4dFByb3BzLnRyaWdnZXJUYXJnZXQpIHtcbiAgICAgIHJlZmVyZW5jZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICB9XG5cbiAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcbiAgICBoYW5kbGVTdHlsZXMoKTtcblxuICAgIGlmIChvblVwZGF0ZSkge1xuICAgICAgb25VcGRhdGUocHJldlByb3BzLCBuZXh0UHJvcHMpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgY3JlYXRlUG9wcGVySW5zdGFuY2UoKTtcblxuICAgICAgLy8gRml4ZXMgYW4gaXNzdWUgd2l0aCBuZXN0ZWQgdGlwcGllcyBpZiB0aGV5IGFyZSBhbGwgZ2V0dGluZyByZS1yZW5kZXJlZCxcbiAgICAgIC8vIGFuZCB0aGUgbmVzdGVkIG9uZXMgZ2V0IHJlLXJlbmRlcmVkIGZpcnN0LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F0b21pa3MvdGlwcHlqcy1yZWFjdC9pc3N1ZXMvMTc3XG4gICAgICAvLyBUT0RPOiBmaW5kIGEgY2xlYW5lciAvIG1vcmUgZWZmaWNpZW50IHNvbHV0aW9uKCEpXG4gICAgICBnZXROZXN0ZWRQb3BwZXJUcmVlKCkuZm9yRWFjaCgobmVzdGVkUG9wcGVyKSA9PiB7XG4gICAgICAgIC8vIFJlYWN0IChhbmQgb3RoZXIgVUkgbGlicyBsaWtlbHkpIHJlcXVpcmVzIGEgckFGIHdyYXBwZXIgYXMgaXQgZmx1c2hlc1xuICAgICAgICAvLyBpdHMgd29yayBpbiBvbmVcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG5lc3RlZFBvcHBlci5fdGlwcHkhLnBvcHBlckluc3RhbmNlIS5mb3JjZVVwZGF0ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpbnZva2VIb29rKCdvbkFmdGVyVXBkYXRlJywgW2luc3RhbmNlLCBwYXJ0aWFsUHJvcHNdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENvbnRlbnQoY29udGVudDogQ29udGVudCk6IHZvaWQge1xuICAgIGluc3RhbmNlLnNldFByb3BzKHtjb250ZW50fSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG93KCk6IHZvaWQge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnc2hvdycpKTtcbiAgICB9XG5cbiAgICAvLyBFYXJseSBiYWlsLW91dFxuICAgIGNvbnN0IGlzQWxyZWFkeVZpc2libGUgPSBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGU7XG4gICAgY29uc3QgaXNEZXN0cm95ZWQgPSBpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZDtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gIWluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZDtcbiAgICBjb25zdCBpc1RvdWNoQW5kVG91Y2hEaXNhYmxlZCA9XG4gICAgICBjdXJyZW50SW5wdXQuaXNUb3VjaCAmJiAhaW5zdGFuY2UucHJvcHMudG91Y2g7XG4gICAgY29uc3QgZHVyYXRpb24gPSBnZXRWYWx1ZUF0SW5kZXhPclJldHVybihcbiAgICAgIGluc3RhbmNlLnByb3BzLmR1cmF0aW9uLFxuICAgICAgMCxcbiAgICAgIGRlZmF1bHRQcm9wcy5kdXJhdGlvblxuICAgICk7XG5cbiAgICBpZiAoXG4gICAgICBpc0FscmVhZHlWaXNpYmxlIHx8XG4gICAgICBpc0Rlc3Ryb3llZCB8fFxuICAgICAgaXNEaXNhYmxlZCB8fFxuICAgICAgaXNUb3VjaEFuZFRvdWNoRGlzYWJsZWRcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgYGRpc2FibGVkYCBiZWhhdmlvciBhY3Jvc3MgYnJvd3NlcnMuXG4gICAgLy8gRmlyZWZveCBhbGxvd3MgZXZlbnRzIG9uIGRpc2FibGVkIGVsZW1lbnRzLCBidXQgQ2hyb21lIGRvZXNuJ3QuXG4gICAgLy8gVXNpbmcgYSB3cmFwcGVyIGVsZW1lbnQgKGkuZS4gPHNwYW4+KSBpcyByZWNvbW1lbmRlZC5cbiAgICBpZiAoZ2V0Q3VycmVudFRhcmdldCgpLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludm9rZUhvb2soJ29uU2hvdycsIFtpbnN0YW5jZV0sIGZhbHNlKTtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMub25TaG93KGluc3RhbmNlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgPSB0cnVlO1xuXG4gICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgIHBvcHBlci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgIH1cblxuICAgIGhhbmRsZVN0eWxlcygpO1xuICAgIGFkZERvY3VtZW50UHJlc3MoKTtcblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICBwb3BwZXIuc3R5bGUudHJhbnNpdGlvbiA9ICdub25lJztcbiAgICB9XG5cbiAgICAvLyBJZiBmbGlwcGluZyB0byB0aGUgb3Bwb3NpdGUgc2lkZSBhZnRlciBoaWRpbmcgYXQgbGVhc3Qgb25jZSwgdGhlXG4gICAgLy8gYW5pbWF0aW9uIHdpbGwgdXNlIHRoZSB3cm9uZyBwbGFjZW1lbnQgd2l0aG91dCByZXNldHRpbmcgdGhlIGR1cmF0aW9uXG4gICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgIGNvbnN0IHtib3gsIGNvbnRlbnR9ID0gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKTtcbiAgICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbihbYm94LCBjb250ZW50XSwgMCk7XG4gICAgfVxuXG4gICAgb25GaXJzdFVwZGF0ZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlIHx8IGlnbm9yZU9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZ25vcmVPbkZpcnN0VXBkYXRlID0gdHJ1ZTtcblxuICAgICAgLy8gcmVmbG93XG4gICAgICB2b2lkIHBvcHBlci5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIHBvcHBlci5zdHlsZS50cmFuc2l0aW9uID0gaW5zdGFuY2UucHJvcHMubW92ZVRyYW5zaXRpb247XG5cbiAgICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpICYmIGluc3RhbmNlLnByb3BzLmFuaW1hdGlvbikge1xuICAgICAgICBjb25zdCB7Ym94LCBjb250ZW50fSA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCk7XG4gICAgICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbihbYm94LCBjb250ZW50XSwgZHVyYXRpb24pO1xuICAgICAgICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JveCwgY29udGVudF0sICd2aXNpYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZUFyaWFDb250ZW50QXR0cmlidXRlKCk7XG4gICAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcblxuICAgICAgcHVzaElmVW5pcXVlKG1vdW50ZWRJbnN0YW5jZXMsIGluc3RhbmNlKTtcblxuICAgICAgLy8gY2VydGFpbiBtb2RpZmllcnMgKGUuZy4gYG1heFNpemVgKSByZXF1aXJlIGEgc2Vjb25kIHVwZGF0ZSBhZnRlciB0aGVcbiAgICAgIC8vIHBvcHBlciBoYXMgYmVlbiBwb3NpdGlvbmVkIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2U/LmZvcmNlVXBkYXRlKCk7XG5cbiAgICAgIGludm9rZUhvb2soJ29uTW91bnQnLCBbaW5zdGFuY2VdKTtcblxuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmFuaW1hdGlvbiAmJiBnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICAgIG9uVHJhbnNpdGlvbmVkSW4oZHVyYXRpb24sICgpID0+IHtcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZS5pc1Nob3duID0gdHJ1ZTtcbiAgICAgICAgICBpbnZva2VIb29rKCdvblNob3duJywgW2luc3RhbmNlXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBtb3VudCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGlkZSgpOiB2b2lkIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ2hpZGUnKSk7XG4gICAgfVxuXG4gICAgLy8gRWFybHkgYmFpbC1vdXRcbiAgICBjb25zdCBpc0FscmVhZHlIaWRkZW4gPSAhaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlO1xuICAgIGNvbnN0IGlzRGVzdHJveWVkID0gaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQ7XG4gICAgY29uc3QgaXNEaXNhYmxlZCA9ICFpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQ7XG4gICAgY29uc3QgZHVyYXRpb24gPSBnZXRWYWx1ZUF0SW5kZXhPclJldHVybihcbiAgICAgIGluc3RhbmNlLnByb3BzLmR1cmF0aW9uLFxuICAgICAgMSxcbiAgICAgIGRlZmF1bHRQcm9wcy5kdXJhdGlvblxuICAgICk7XG5cbiAgICBpZiAoaXNBbHJlYWR5SGlkZGVuIHx8IGlzRGVzdHJveWVkIHx8IGlzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnZva2VIb29rKCdvbkhpZGUnLCBbaW5zdGFuY2VdLCBmYWxzZSk7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzLm9uSGlkZShpbnN0YW5jZSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNTaG93biA9IGZhbHNlO1xuICAgIGlnbm9yZU9uRmlyc3RVcGRhdGUgPSBmYWxzZTtcbiAgICBpc1Zpc2libGVGcm9tQ2xpY2sgPSBmYWxzZTtcblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICBwb3BwZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIH1cblxuICAgIGNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzKCk7XG4gICAgcmVtb3ZlRG9jdW1lbnRQcmVzcygpO1xuICAgIGhhbmRsZVN0eWxlcyh0cnVlKTtcblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICBjb25zdCB7Ym94LCBjb250ZW50fSA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCk7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hbmltYXRpb24pIHtcbiAgICAgICAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFtib3gsIGNvbnRlbnRdLCBkdXJhdGlvbik7XG4gICAgICAgIHNldFZpc2liaWxpdHlTdGF0ZShbYm94LCBjb250ZW50XSwgJ2hpZGRlbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUFyaWFDb250ZW50QXR0cmlidXRlKCk7XG4gICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuYW5pbWF0aW9uKSB7XG4gICAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgICBvblRyYW5zaXRpb25lZE91dChkdXJhdGlvbiwgaW5zdGFuY2UudW5tb3VudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnVubW91bnQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoaWRlV2l0aEludGVyYWN0aXZpdHkoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICB3YXJuV2hlbihcbiAgICAgICAgaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsXG4gICAgICAgIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdoaWRlV2l0aEludGVyYWN0aXZpdHknKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBnZXREb2N1bWVudCgpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGRlYm91bmNlZE9uTW91c2VNb3ZlKTtcbiAgICBwdXNoSWZVbmlxdWUobW91c2VNb3ZlTGlzdGVuZXJzLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSk7XG4gICAgZGVib3VuY2VkT25Nb3VzZU1vdmUoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5tb3VudCgpOiB2b2lkIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ3VubW91bnQnKSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgIH1cblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVzdHJveVBvcHBlckluc3RhbmNlKCk7XG5cbiAgICAvLyBJZiBhIHBvcHBlciBpcyBub3QgaW50ZXJhY3RpdmUsIGl0IHdpbGwgYmUgYXBwZW5kZWQgb3V0c2lkZSB0aGUgcG9wcGVyXG4gICAgLy8gdHJlZSBieSBkZWZhdWx0LiBUaGlzIHNlZW1zIG1haW5seSBmb3IgaW50ZXJhY3RpdmUgdGlwcGllcywgYnV0IHdlIHNob3VsZFxuICAgIC8vIGZpbmQgYSB3b3JrYXJvdW5kIGlmIHBvc3NpYmxlXG4gICAgZ2V0TmVzdGVkUG9wcGVyVHJlZSgpLmZvckVhY2goKG5lc3RlZFBvcHBlcikgPT4ge1xuICAgICAgbmVzdGVkUG9wcGVyLl90aXBweSEudW5tb3VudCgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHBvcHBlci5wYXJlbnROb2RlKSB7XG4gICAgICBwb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwb3BwZXIpO1xuICAgIH1cblxuICAgIG1vdW50ZWRJbnN0YW5jZXMgPSBtb3VudGVkSW5zdGFuY2VzLmZpbHRlcigoaSkgPT4gaSAhPT0gaW5zdGFuY2UpO1xuXG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkID0gZmFsc2U7XG4gICAgaW52b2tlSG9vaygnb25IaWRkZW4nLCBbaW5zdGFuY2VdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdkZXN0cm95JykpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuICAgIGluc3RhbmNlLnVubW91bnQoKTtcblxuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuXG4gICAgZGVsZXRlIHJlZmVyZW5jZS5fdGlwcHk7XG5cbiAgICBpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgICBpbnZva2VIb29rKCdvbkRlc3Ryb3knLCBbaW5zdGFuY2VdKTtcbiAgfVxufVxuIiwgImltcG9ydCBiaW5kR2xvYmFsRXZlbnRMaXN0ZW5lcnMsIHtcbiAgY3VycmVudElucHV0LFxufSBmcm9tICcuL2JpbmRHbG9iYWxFdmVudExpc3RlbmVycyc7XG5pbXBvcnQgY3JlYXRlVGlwcHksIHttb3VudGVkSW5zdGFuY2VzfSBmcm9tICcuL2NyZWF0ZVRpcHB5JztcbmltcG9ydCB7Z2V0QXJyYXlPZkVsZW1lbnRzLCBpc0VsZW1lbnQsIGlzUmVmZXJlbmNlRWxlbWVudH0gZnJvbSAnLi9kb20tdXRpbHMnO1xuaW1wb3J0IHtkZWZhdWx0UHJvcHMsIHNldERlZmF1bHRQcm9wcywgdmFsaWRhdGVQcm9wc30gZnJvbSAnLi9wcm9wcyc7XG5pbXBvcnQge0hpZGVBbGwsIEhpZGVBbGxPcHRpb25zLCBJbnN0YW5jZSwgUHJvcHMsIFRhcmdldHN9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHt2YWxpZGF0ZVRhcmdldHMsIHdhcm5XaGVufSBmcm9tICcuL3ZhbGlkYXRpb24nO1xuXG5mdW5jdGlvbiB0aXBweShcbiAgdGFyZ2V0czogVGFyZ2V0cyxcbiAgb3B0aW9uYWxQcm9wczogUGFydGlhbDxQcm9wcz4gPSB7fVxuKTogSW5zdGFuY2UgfCBJbnN0YW5jZVtdIHtcbiAgY29uc3QgcGx1Z2lucyA9IGRlZmF1bHRQcm9wcy5wbHVnaW5zLmNvbmNhdChvcHRpb25hbFByb3BzLnBsdWdpbnMgfHwgW10pO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgdmFsaWRhdGVUYXJnZXRzKHRhcmdldHMpO1xuICAgIHZhbGlkYXRlUHJvcHMob3B0aW9uYWxQcm9wcywgcGx1Z2lucyk7XG4gIH1cblxuICBiaW5kR2xvYmFsRXZlbnRMaXN0ZW5lcnMoKTtcblxuICBjb25zdCBwYXNzZWRQcm9wczogUGFydGlhbDxQcm9wcz4gPSB7Li4ub3B0aW9uYWxQcm9wcywgcGx1Z2luc307XG5cbiAgY29uc3QgZWxlbWVudHMgPSBnZXRBcnJheU9mRWxlbWVudHModGFyZ2V0cyk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKF9fREVWX18pIHtcbiAgICBjb25zdCBpc1NpbmdsZUNvbnRlbnRFbGVtZW50ID0gaXNFbGVtZW50KHBhc3NlZFByb3BzLmNvbnRlbnQpO1xuICAgIGNvbnN0IGlzTW9yZVRoYW5PbmVSZWZlcmVuY2VFbGVtZW50ID0gZWxlbWVudHMubGVuZ3RoID4gMTtcbiAgICB3YXJuV2hlbihcbiAgICAgIGlzU2luZ2xlQ29udGVudEVsZW1lbnQgJiYgaXNNb3JlVGhhbk9uZVJlZmVyZW5jZUVsZW1lbnQsXG4gICAgICBbXG4gICAgICAgICd0aXBweSgpIHdhcyBwYXNzZWQgYW4gRWxlbWVudCBhcyB0aGUgYGNvbnRlbnRgIHByb3AsIGJ1dCBtb3JlIHRoYW4nLFxuICAgICAgICAnb25lIHRpcHB5IGluc3RhbmNlIHdhcyBjcmVhdGVkIGJ5IHRoaXMgaW52b2NhdGlvbi4gVGhpcyBtZWFucyB0aGUnLFxuICAgICAgICAnY29udGVudCBlbGVtZW50IHdpbGwgb25seSBiZSBhcHBlbmRlZCB0byB0aGUgbGFzdCB0aXBweSBpbnN0YW5jZS4nLFxuICAgICAgICAnXFxuXFxuJyxcbiAgICAgICAgJ0luc3RlYWQsIHBhc3MgdGhlIC5pbm5lckhUTUwgb2YgdGhlIGVsZW1lbnQsIG9yIHVzZSBhIGZ1bmN0aW9uIHRoYXQnLFxuICAgICAgICAncmV0dXJucyBhIGNsb25lZCB2ZXJzaW9uIG9mIHRoZSBlbGVtZW50IGluc3RlYWQuJyxcbiAgICAgICAgJ1xcblxcbicsXG4gICAgICAgICcxKSBjb250ZW50OiBlbGVtZW50LmlubmVySFRNTFxcbicsXG4gICAgICAgICcyKSBjb250ZW50OiAoKSA9PiBlbGVtZW50LmNsb25lTm9kZSh0cnVlKScsXG4gICAgICBdLmpvaW4oJyAnKVxuICAgICk7XG4gIH1cblxuICBjb25zdCBpbnN0YW5jZXMgPSBlbGVtZW50cy5yZWR1Y2U8SW5zdGFuY2VbXT4oXG4gICAgKGFjYywgcmVmZXJlbmNlKTogSW5zdGFuY2VbXSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IHJlZmVyZW5jZSAmJiBjcmVhdGVUaXBweShyZWZlcmVuY2UsIHBhc3NlZFByb3BzKTtcblxuICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGFjYy5wdXNoKGluc3RhbmNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIFtdXG4gICk7XG5cbiAgcmV0dXJuIGlzRWxlbWVudCh0YXJnZXRzKSA/IGluc3RhbmNlc1swXSA6IGluc3RhbmNlcztcbn1cblxudGlwcHkuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xudGlwcHkuc2V0RGVmYXVsdFByb3BzID0gc2V0RGVmYXVsdFByb3BzO1xudGlwcHkuY3VycmVudElucHV0ID0gY3VycmVudElucHV0O1xuXG5leHBvcnQgZGVmYXVsdCB0aXBweTtcblxuZXhwb3J0IGNvbnN0IGhpZGVBbGw6IEhpZGVBbGwgPSAoe1xuICBleGNsdWRlOiBleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UsXG4gIGR1cmF0aW9uLFxufTogSGlkZUFsbE9wdGlvbnMgPSB7fSkgPT4ge1xuICBtb3VudGVkSW5zdGFuY2VzLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XG4gICAgbGV0IGlzRXhjbHVkZWQgPSBmYWxzZTtcblxuICAgIGlmIChleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UpIHtcbiAgICAgIGlzRXhjbHVkZWQgPSBpc1JlZmVyZW5jZUVsZW1lbnQoZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlKVxuICAgICAgICA/IGluc3RhbmNlLnJlZmVyZW5jZSA9PT0gZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlXG4gICAgICAgIDogaW5zdGFuY2UucG9wcGVyID09PSAoZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlIGFzIEluc3RhbmNlKS5wb3BwZXI7XG4gICAgfVxuXG4gICAgaWYgKCFpc0V4Y2x1ZGVkKSB7XG4gICAgICBjb25zdCBvcmlnaW5hbER1cmF0aW9uID0gaW5zdGFuY2UucHJvcHMuZHVyYXRpb247XG5cbiAgICAgIGluc3RhbmNlLnNldFByb3BzKHtkdXJhdGlvbn0pO1xuICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuXG4gICAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFByb3BzKHtkdXJhdGlvbjogb3JpZ2luYWxEdXJhdGlvbn0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuIiwgImltcG9ydCB0aXBweSBmcm9tICcuLic7XG5pbXBvcnQge2Rpdn0gZnJvbSAnLi4vZG9tLXV0aWxzJztcbmltcG9ydCB7XG4gIENyZWF0ZVNpbmdsZXRvbixcbiAgUGx1Z2luLFxuICBDcmVhdGVTaW5nbGV0b25Qcm9wcyxcbiAgUmVmZXJlbmNlRWxlbWVudCxcbiAgQ3JlYXRlU2luZ2xldG9uSW5zdGFuY2UsXG4gIEluc3RhbmNlLFxuICBQcm9wcyxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtub3JtYWxpemVUb0FycmF5LCByZW1vdmVQcm9wZXJ0aWVzfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQge2Vycm9yV2hlbn0gZnJvbSAnLi4vdmFsaWRhdGlvbic7XG5pbXBvcnQge2FwcGx5U3R5bGVzLCBNb2RpZmllcn0gZnJvbSAnQHBvcHBlcmpzL2NvcmUnO1xuXG4vLyBUaGUgZGVmYXVsdCBgYXBwbHlTdHlsZXNgIG1vZGlmaWVyIGhhcyBhIGNsZWFudXAgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZFxuLy8gZXZlcnkgdGltZSB0aGUgcG9wcGVyIGlzIGRlc3Ryb3llZCAoaS5lLiBhIG5ldyB0YXJnZXQpLCByZW1vdmluZyB0aGUgc3R5bGVzXG4vLyBhbmQgY2F1c2luZyB0cmFuc2l0aW9ucyB0byBicmVhayBmb3Igc2luZ2xldG9ucyB3aGVuIHRoZSBjb25zb2xlIGlzIG9wZW4sIGJ1dFxuLy8gbW9zdCBub3RhYmx5IGZvciBub24tdHJhbnNmb3JtIHN0eWxlcyBiZWluZyB1c2VkLCBgZ3B1QWNjZWxlcmF0aW9uOiBmYWxzZWAuXG5jb25zdCBhcHBseVN0eWxlc01vZGlmaWVyOiBNb2RpZmllcjwnYXBwbHlTdHlsZXMnLCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4gPSB7XG4gIC4uLmFwcGx5U3R5bGVzLFxuICBlZmZlY3Qoe3N0YXRlfSkge1xuICAgIGNvbnN0IGluaXRpYWxTdHlsZXMgPSB7XG4gICAgICBwb3BwZXI6IHtcbiAgICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICAgIGxlZnQ6ICcwJyxcbiAgICAgICAgdG9wOiAnMCcsXG4gICAgICAgIG1hcmdpbjogJzAnLFxuICAgICAgfSxcbiAgICAgIGFycm93OiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgfSxcbiAgICAgIHJlZmVyZW5jZToge30sXG4gICAgfTtcblxuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gICAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICAgIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gICAgfVxuXG4gICAgLy8gaW50ZW50aW9uYWxseSByZXR1cm4gbm8gY2xlYW51cCBmdW5jdGlvblxuICAgIC8vIHJldHVybiAoKSA9PiB7IC4uLiB9XG4gIH0sXG59O1xuXG5jb25zdCBjcmVhdGVTaW5nbGV0b246IENyZWF0ZVNpbmdsZXRvbiA9IChcbiAgdGlwcHlJbnN0YW5jZXMsXG4gIG9wdGlvbmFsUHJvcHMgPSB7fVxuKSA9PiB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgZXJyb3JXaGVuKFxuICAgICAgIUFycmF5LmlzQXJyYXkodGlwcHlJbnN0YW5jZXMpLFxuICAgICAgW1xuICAgICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTaW5nbGV0b24oKSBtdXN0IGJlIGFuIGFycmF5IG9mJyxcbiAgICAgICAgJ3RpcHB5IGluc3RhbmNlcy4gVGhlIHBhc3NlZCB2YWx1ZSB3YXMnLFxuICAgICAgICBTdHJpbmcodGlwcHlJbnN0YW5jZXMpLFxuICAgICAgXS5qb2luKCcgJylcbiAgICApO1xuICB9XG5cbiAgbGV0IGluZGl2aWR1YWxJbnN0YW5jZXMgPSB0aXBweUluc3RhbmNlcztcbiAgbGV0IHJlZmVyZW5jZXM6IEFycmF5PFJlZmVyZW5jZUVsZW1lbnQ+ID0gW107XG4gIGxldCB0cmlnZ2VyVGFyZ2V0czogQXJyYXk8RWxlbWVudD4gPSBbXTtcbiAgbGV0IGN1cnJlbnRUYXJnZXQ6IEVsZW1lbnQgfCBudWxsO1xuICBsZXQgb3ZlcnJpZGVzID0gb3B0aW9uYWxQcm9wcy5vdmVycmlkZXM7XG4gIGxldCBpbnRlcmNlcHRTZXRQcm9wc0NsZWFudXBzOiBBcnJheTwoKSA9PiB2b2lkPiA9IFtdO1xuICBsZXQgc2hvd25PbkNyZWF0ZSA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHNldFRyaWdnZXJUYXJnZXRzKCk6IHZvaWQge1xuICAgIHRyaWdnZXJUYXJnZXRzID0gaW5kaXZpZHVhbEluc3RhbmNlc1xuICAgICAgLm1hcCgoaW5zdGFuY2UpID0+XG4gICAgICAgIG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCBpbnN0YW5jZS5yZWZlcmVuY2UpXG4gICAgICApXG4gICAgICAucmVkdWNlKChhY2MsIGl0ZW0pID0+IGFjYy5jb25jYXQoaXRlbSksIFtdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFJlZmVyZW5jZXMoKTogdm9pZCB7XG4gICAgcmVmZXJlbmNlcyA9IGluZGl2aWR1YWxJbnN0YW5jZXMubWFwKChpbnN0YW5jZSkgPT4gaW5zdGFuY2UucmVmZXJlbmNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuYWJsZUluc3RhbmNlcyhpc0VuYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpbmRpdmlkdWFsSW5zdGFuY2VzLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XG4gICAgICBpZiAoaXNFbmFibGVkKSB7XG4gICAgICAgIGluc3RhbmNlLmVuYWJsZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2UuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJjZXB0U2V0UHJvcHMoc2luZ2xldG9uOiBJbnN0YW5jZSk6IEFycmF5PCgpID0+IHZvaWQ+IHtcbiAgICByZXR1cm4gaW5kaXZpZHVhbEluc3RhbmNlcy5tYXAoKGluc3RhbmNlKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbFNldFByb3BzID0gaW5zdGFuY2Uuc2V0UHJvcHM7XG5cbiAgICAgIGluc3RhbmNlLnNldFByb3BzID0gKHByb3BzKTogdm9pZCA9PiB7XG4gICAgICAgIG9yaWdpbmFsU2V0UHJvcHMocHJvcHMpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZS5yZWZlcmVuY2UgPT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICBzaW5nbGV0b24uc2V0UHJvcHMocHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gKCk6IHZvaWQgPT4ge1xuICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyA9IG9yaWdpbmFsU2V0UHJvcHM7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLy8gaGF2ZSB0byBwYXNzIHNpbmdsZXRvbiwgYXMgaXQgbWF5YmUgdW5kZWZpbmVkIG9uIGZpcnN0IGNhbGxcbiAgZnVuY3Rpb24gcHJlcGFyZUluc3RhbmNlKFxuICAgIHNpbmdsZXRvbjogSW5zdGFuY2UsXG4gICAgdGFyZ2V0OiBSZWZlcmVuY2VFbGVtZW50XG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGluZGV4ID0gdHJpZ2dlclRhcmdldHMuaW5kZXhPZih0YXJnZXQpO1xuXG4gICAgLy8gYmFpbC1vdXRcbiAgICBpZiAodGFyZ2V0ID09PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VycmVudFRhcmdldCA9IHRhcmdldDtcblxuICAgIGNvbnN0IG92ZXJyaWRlUHJvcHM6IFBhcnRpYWw8UHJvcHM+ID0gKG92ZXJyaWRlcyB8fCBbXSlcbiAgICAgIC5jb25jYXQoJ2NvbnRlbnQnKVxuICAgICAgLnJlZHVjZSgoYWNjLCBwcm9wKSA9PiB7XG4gICAgICAgIChhY2MgYXMgYW55KVtwcm9wXSA9IGluZGl2aWR1YWxJbnN0YW5jZXNbaW5kZXhdLnByb3BzW3Byb3BdO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuXG4gICAgc2luZ2xldG9uLnNldFByb3BzKHtcbiAgICAgIC4uLm92ZXJyaWRlUHJvcHMsXG4gICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OlxuICAgICAgICB0eXBlb2Ygb3ZlcnJpZGVQcm9wcy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBvdmVycmlkZVByb3BzLmdldFJlZmVyZW5jZUNsaWVudFJlY3RcbiAgICAgICAgICA6ICgpOiBDbGllbnRSZWN0ID0+IHJlZmVyZW5jZXNbaW5kZXhdPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICB9KTtcbiAgfVxuXG4gIGVuYWJsZUluc3RhbmNlcyhmYWxzZSk7XG4gIHNldFJlZmVyZW5jZXMoKTtcbiAgc2V0VHJpZ2dlclRhcmdldHMoKTtcblxuICBjb25zdCBwbHVnaW46IFBsdWdpbiA9IHtcbiAgICBmbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgICBlbmFibGVJbnN0YW5jZXModHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uSGlkZGVuKCk6IHZvaWQge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBvbkNsaWNrT3V0c2lkZShpbnN0YW5jZSk6IHZvaWQge1xuICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5zaG93T25DcmVhdGUgJiYgIXNob3duT25DcmVhdGUpIHtcbiAgICAgICAgICAgIHNob3duT25DcmVhdGUgPSB0cnVlO1xuICAgICAgICAgICAgY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblNob3coaW5zdGFuY2UpOiB2b2lkIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMuc2hvd09uQ3JlYXRlICYmICFzaG93bk9uQ3JlYXRlKSB7XG4gICAgICAgICAgICBzaG93bk9uQ3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHByZXBhcmVJbnN0YW5jZShpbnN0YW5jZSwgcmVmZXJlbmNlc1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblRyaWdnZXIoaW5zdGFuY2UsIGV2ZW50KTogdm9pZCB7XG4gICAgICAgICAgcHJlcGFyZUluc3RhbmNlKGluc3RhbmNlLCBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9LFxuICB9O1xuXG4gIGNvbnN0IHNpbmdsZXRvbiA9IHRpcHB5KGRpdigpLCB7XG4gICAgLi4ucmVtb3ZlUHJvcGVydGllcyhvcHRpb25hbFByb3BzLCBbJ292ZXJyaWRlcyddKSxcbiAgICBwbHVnaW5zOiBbcGx1Z2luLCAuLi4ob3B0aW9uYWxQcm9wcy5wbHVnaW5zIHx8IFtdKV0sXG4gICAgdHJpZ2dlclRhcmdldDogdHJpZ2dlclRhcmdldHMsXG4gICAgcG9wcGVyT3B0aW9uczoge1xuICAgICAgLi4ub3B0aW9uYWxQcm9wcy5wb3BwZXJPcHRpb25zLFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIC4uLihvcHRpb25hbFByb3BzLnBvcHBlck9wdGlvbnM/Lm1vZGlmaWVycyB8fCBbXSksXG4gICAgICAgIGFwcGx5U3R5bGVzTW9kaWZpZXIsXG4gICAgICBdLFxuICAgIH0sXG4gIH0pIGFzIENyZWF0ZVNpbmdsZXRvbkluc3RhbmNlPENyZWF0ZVNpbmdsZXRvblByb3BzPjtcblxuICBjb25zdCBvcmlnaW5hbFNob3cgPSBzaW5nbGV0b24uc2hvdztcblxuICBzaW5nbGV0b24uc2hvdyA9ICh0YXJnZXQ/OiBSZWZlcmVuY2VFbGVtZW50IHwgSW5zdGFuY2UgfCBudW1iZXIpOiB2b2lkID0+IHtcbiAgICBvcmlnaW5hbFNob3coKTtcblxuICAgIC8vIGZpcnN0IHRpbWUsIHNob3dPbkNyZWF0ZSBvciBwcm9ncmFtbWF0aWMgY2FsbCB3aXRoIG5vIHBhcmFtc1xuICAgIC8vIGRlZmF1bHQgdG8gc2hvd2luZyBmaXJzdCBpbnN0YW5jZVxuICAgIGlmICghY3VycmVudFRhcmdldCAmJiB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHByZXBhcmVJbnN0YW5jZShzaW5nbGV0b24sIHJlZmVyZW5jZXNbMF0pO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXJlZCBmcm9tIGV2ZW50IChkbyBub3RoaW5nIGFzIHByZXBhcmVJbnN0YW5jZSBhbHJlYWR5IGNhbGxlZCBieSBvblRyaWdnZXIpXG4gICAgLy8gcHJvZ3JhbW1hdGljIGNhbGwgd2l0aCBubyBwYXJhbXMgd2hlbiBhbHJlYWR5IHZpc2libGUgKGRvIG5vdGhpbmcgYWdhaW4pXG4gICAgaWYgKGN1cnJlbnRUYXJnZXQgJiYgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0YXJnZXQgaXMgaW5kZXggb2YgaW5zdGFuY2VcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHJlZmVyZW5jZXNbdGFyZ2V0XSAmJiBwcmVwYXJlSW5zdGFuY2Uoc2luZ2xldG9uLCByZWZlcmVuY2VzW3RhcmdldF0pXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHRhcmdldCBpcyBhIGNoaWxkIHRpcHB5IGluc3RhbmNlXG4gICAgaWYgKGluZGl2aWR1YWxJbnN0YW5jZXMuaW5kZXhPZih0YXJnZXQgYXMgSW5zdGFuY2UpID49IDApIHtcbiAgICAgIGNvbnN0IHJlZiA9ICh0YXJnZXQgYXMgSW5zdGFuY2UpLnJlZmVyZW5jZTtcbiAgICAgIHJldHVybiBwcmVwYXJlSW5zdGFuY2Uoc2luZ2xldG9uLCByZWYpO1xuICAgIH1cblxuICAgIC8vIHRhcmdldCBpcyBhIFJlZmVyZW5jZUVsZW1lbnRcbiAgICBpZiAocmVmZXJlbmNlcy5pbmRleE9mKHRhcmdldCBhcyBSZWZlcmVuY2VFbGVtZW50KSA+PSAwKSB7XG4gICAgICByZXR1cm4gcHJlcGFyZUluc3RhbmNlKHNpbmdsZXRvbiwgdGFyZ2V0IGFzIFJlZmVyZW5jZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICBzaW5nbGV0b24uc2hvd05leHQgPSAoKTogdm9pZCA9PiB7XG4gICAgY29uc3QgZmlyc3QgPSByZWZlcmVuY2VzWzBdO1xuICAgIGlmICghY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIHNpbmdsZXRvbi5zaG93KDApO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHJlZmVyZW5jZXMuaW5kZXhPZihjdXJyZW50VGFyZ2V0KTtcbiAgICBzaW5nbGV0b24uc2hvdyhyZWZlcmVuY2VzW2luZGV4ICsgMV0gfHwgZmlyc3QpO1xuICB9O1xuXG4gIHNpbmdsZXRvbi5zaG93UHJldmlvdXMgPSAoKTogdm9pZCA9PiB7XG4gICAgY29uc3QgbGFzdCA9IHJlZmVyZW5jZXNbcmVmZXJlbmNlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybiBzaW5nbGV0b24uc2hvdyhsYXN0KTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSByZWZlcmVuY2VzLmluZGV4T2YoY3VycmVudFRhcmdldCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gcmVmZXJlbmNlc1tpbmRleCAtIDFdIHx8IGxhc3Q7XG4gICAgc2luZ2xldG9uLnNob3codGFyZ2V0KTtcbiAgfTtcblxuICBjb25zdCBvcmlnaW5hbFNldFByb3BzID0gc2luZ2xldG9uLnNldFByb3BzO1xuXG4gIHNpbmdsZXRvbi5zZXRQcm9wcyA9IChwcm9wcyk6IHZvaWQgPT4ge1xuICAgIG92ZXJyaWRlcyA9IHByb3BzLm92ZXJyaWRlcyB8fCBvdmVycmlkZXM7XG4gICAgb3JpZ2luYWxTZXRQcm9wcyhwcm9wcyk7XG4gIH07XG5cbiAgc2luZ2xldG9uLnNldEluc3RhbmNlcyA9IChuZXh0SW5zdGFuY2VzKTogdm9pZCA9PiB7XG4gICAgZW5hYmxlSW5zdGFuY2VzKHRydWUpO1xuICAgIGludGVyY2VwdFNldFByb3BzQ2xlYW51cHMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuXG4gICAgaW5kaXZpZHVhbEluc3RhbmNlcyA9IG5leHRJbnN0YW5jZXM7XG5cbiAgICBlbmFibGVJbnN0YW5jZXMoZmFsc2UpO1xuICAgIHNldFJlZmVyZW5jZXMoKTtcbiAgICBzZXRUcmlnZ2VyVGFyZ2V0cygpO1xuICAgIGludGVyY2VwdFNldFByb3BzQ2xlYW51cHMgPSBpbnRlcmNlcHRTZXRQcm9wcyhzaW5nbGV0b24pO1xuXG4gICAgc2luZ2xldG9uLnNldFByb3BzKHt0cmlnZ2VyVGFyZ2V0OiB0cmlnZ2VyVGFyZ2V0c30pO1xuICB9O1xuXG4gIGludGVyY2VwdFNldFByb3BzQ2xlYW51cHMgPSBpbnRlcmNlcHRTZXRQcm9wcyhzaW5nbGV0b24pO1xuXG4gIHJldHVybiBzaW5nbGV0b247XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTaW5nbGV0b247XG4iLCAiaW1wb3J0IHRpcHB5IGZyb20gJy4uJztcbmltcG9ydCB7VE9VQ0hfT1BUSU9OU30gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7ZGVmYXVsdFByb3BzfSBmcm9tICcuLi9wcm9wcyc7XG5pbXBvcnQge0luc3RhbmNlLCBQcm9wcywgVGFyZ2V0c30gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtMaXN0ZW5lck9iamVjdH0gZnJvbSAnLi4vdHlwZXMtaW50ZXJuYWwnO1xuaW1wb3J0IHtub3JtYWxpemVUb0FycmF5LCByZW1vdmVQcm9wZXJ0aWVzfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQge2Vycm9yV2hlbn0gZnJvbSAnLi4vdmFsaWRhdGlvbic7XG5cbmNvbnN0IEJVQkJMSU5HX0VWRU5UU19NQVAgPSB7XG4gIG1vdXNlb3ZlcjogJ21vdXNlZW50ZXInLFxuICBmb2N1c2luOiAnZm9jdXMnLFxuICBjbGljazogJ2NsaWNrJyxcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlbGVnYXRlIGluc3RhbmNlIHRoYXQgY29udHJvbHMgdGhlIGNyZWF0aW9uIG9mIHRpcHB5IGluc3RhbmNlc1xuICogZm9yIGNoaWxkIGVsZW1lbnRzIChgdGFyZ2V0YCBDU1Mgc2VsZWN0b3IpLlxuICovXG5mdW5jdGlvbiBkZWxlZ2F0ZShcbiAgdGFyZ2V0czogVGFyZ2V0cyxcbiAgcHJvcHM6IFBhcnRpYWw8UHJvcHM+ICYge3RhcmdldDogc3RyaW5nfVxuKTogSW5zdGFuY2UgfCBJbnN0YW5jZVtdIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKF9fREVWX18pIHtcbiAgICBlcnJvcldoZW4oXG4gICAgICAhKHByb3BzICYmIHByb3BzLnRhcmdldCksXG4gICAgICBbXG4gICAgICAgICdZb3UgbXVzdCBzcGVjaXR5IGEgYHRhcmdldGAgcHJvcCBpbmRpY2F0aW5nIGEgQ1NTIHNlbGVjdG9yIHN0cmluZyBtYXRjaGluZycsXG4gICAgICAgICd0aGUgdGFyZ2V0IGVsZW1lbnRzIHRoYXQgc2hvdWxkIHJlY2VpdmUgYSB0aXBweS4nLFxuICAgICAgXS5qb2luKCcgJylcbiAgICApO1xuICB9XG5cbiAgbGV0IGxpc3RlbmVyczogTGlzdGVuZXJPYmplY3RbXSA9IFtdO1xuICBsZXQgY2hpbGRUaXBweUluc3RhbmNlczogSW5zdGFuY2VbXSA9IFtdO1xuICBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcblxuICBjb25zdCB7dGFyZ2V0fSA9IHByb3BzO1xuXG4gIGNvbnN0IG5hdGl2ZVByb3BzID0gcmVtb3ZlUHJvcGVydGllcyhwcm9wcywgWyd0YXJnZXQnXSk7XG4gIGNvbnN0IHBhcmVudFByb3BzID0gey4uLm5hdGl2ZVByb3BzLCB0cmlnZ2VyOiAnbWFudWFsJywgdG91Y2g6IGZhbHNlfTtcbiAgY29uc3QgY2hpbGRQcm9wcyA9IHtcbiAgICB0b3VjaDogZGVmYXVsdFByb3BzLnRvdWNoLFxuICAgIC4uLm5hdGl2ZVByb3BzLFxuICAgIHNob3dPbkNyZWF0ZTogdHJ1ZSxcbiAgfTtcblxuICBjb25zdCByZXR1cm5WYWx1ZSA9IHRpcHB5KHRhcmdldHMsIHBhcmVudFByb3BzKTtcbiAgY29uc3Qgbm9ybWFsaXplZFJldHVyblZhbHVlID0gbm9ybWFsaXplVG9BcnJheShyZXR1cm5WYWx1ZSk7XG5cbiAgZnVuY3Rpb24gb25UcmlnZ2VyKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgIGlmICghZXZlbnQudGFyZ2V0IHx8IGRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0Tm9kZSA9IChldmVudC50YXJnZXQgYXMgRWxlbWVudCkuY2xvc2VzdCh0YXJnZXQpO1xuXG4gICAgaWYgKCF0YXJnZXROb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IHJlbGV2YW50IHRyaWdnZXIgd2l0aCBmYWxsYmFja3M6XG4gICAgLy8gMS4gQ2hlY2sgYGRhdGEtdGlwcHktdHJpZ2dlcmAgYXR0cmlidXRlIG9uIHRhcmdldCBub2RlXG4gICAgLy8gMi4gRmFsbGJhY2sgdG8gYHRyaWdnZXJgIHBhc3NlZCB0byBgZGVsZWdhdGUoKWBcbiAgICAvLyAzLiBGYWxsYmFjayB0byBgZGVmYXVsdFByb3BzLnRyaWdnZXJgXG4gICAgY29uc3QgdHJpZ2dlciA9XG4gICAgICB0YXJnZXROb2RlLmdldEF0dHJpYnV0ZSgnZGF0YS10aXBweS10cmlnZ2VyJykgfHxcbiAgICAgIHByb3BzLnRyaWdnZXIgfHxcbiAgICAgIGRlZmF1bHRQcm9wcy50cmlnZ2VyO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICh0YXJnZXROb2RlLl90aXBweSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC50eXBlID09PSAndG91Y2hzdGFydCcgJiYgdHlwZW9mIGNoaWxkUHJvcHMudG91Y2ggPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGV2ZW50LnR5cGUgIT09ICd0b3VjaHN0YXJ0JyAmJlxuICAgICAgdHJpZ2dlci5pbmRleE9mKChCVUJCTElOR19FVkVOVFNfTUFQIGFzIGFueSlbZXZlbnQudHlwZV0pIDwgMFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlID0gdGlwcHkodGFyZ2V0Tm9kZSwgY2hpbGRQcm9wcyk7XG5cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkVGlwcHlJbnN0YW5jZXMgPSBjaGlsZFRpcHB5SW5zdGFuY2VzLmNvbmNhdChpbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb24oXG4gICAgbm9kZTogRWxlbWVudCxcbiAgICBldmVudFR5cGU6IHN0cmluZyxcbiAgICBoYW5kbGVyOiBFdmVudExpc3RlbmVyLFxuICAgIG9wdGlvbnM6IGJvb2xlYW4gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IGZhbHNlXG4gICk6IHZvaWQge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIGxpc3RlbmVycy5wdXNoKHtub2RlLCBldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnN9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKGluc3RhbmNlOiBJbnN0YW5jZSk6IHZvaWQge1xuICAgIGNvbnN0IHtyZWZlcmVuY2V9ID0gaW5zdGFuY2U7XG5cbiAgICBvbihyZWZlcmVuY2UsICd0b3VjaHN0YXJ0Jywgb25UcmlnZ2VyLCBUT1VDSF9PUFRJT05TKTtcbiAgICBvbihyZWZlcmVuY2UsICdtb3VzZW92ZXInLCBvblRyaWdnZXIpO1xuICAgIG9uKHJlZmVyZW5jZSwgJ2ZvY3VzaW4nLCBvblRyaWdnZXIpO1xuICAgIG9uKHJlZmVyZW5jZSwgJ2NsaWNrJywgb25UcmlnZ2VyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKCh7bm9kZSwgZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zfTogTGlzdGVuZXJPYmplY3QpID0+IHtcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIGxpc3RlbmVycyA9IFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlNdXRhdGlvbnMoaW5zdGFuY2U6IEluc3RhbmNlKTogdm9pZCB7XG4gICAgY29uc3Qgb3JpZ2luYWxEZXN0cm95ID0gaW5zdGFuY2UuZGVzdHJveTtcbiAgICBjb25zdCBvcmlnaW5hbEVuYWJsZSA9IGluc3RhbmNlLmVuYWJsZTtcbiAgICBjb25zdCBvcmlnaW5hbERpc2FibGUgPSBpbnN0YW5jZS5kaXNhYmxlO1xuXG4gICAgaW5zdGFuY2UuZGVzdHJveSA9IChzaG91bGREZXN0cm95Q2hpbGRJbnN0YW5jZXMgPSB0cnVlKTogdm9pZCA9PiB7XG4gICAgICBpZiAoc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzKSB7XG4gICAgICAgIGNoaWxkVGlwcHlJbnN0YW5jZXMuZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICBpbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzID0gW107XG5cbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICBvcmlnaW5hbERlc3Ryb3koKTtcbiAgICB9O1xuXG4gICAgaW5zdGFuY2UuZW5hYmxlID0gKCk6IHZvaWQgPT4ge1xuICAgICAgb3JpZ2luYWxFbmFibGUoKTtcbiAgICAgIGNoaWxkVGlwcHlJbnN0YW5jZXMuZm9yRWFjaCgoaW5zdGFuY2UpID0+IGluc3RhbmNlLmVuYWJsZSgpKTtcbiAgICAgIGRpc2FibGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIGluc3RhbmNlLmRpc2FibGUgPSAoKTogdm9pZCA9PiB7XG4gICAgICBvcmlnaW5hbERpc2FibGUoKTtcbiAgICAgIGNoaWxkVGlwcHlJbnN0YW5jZXMuZm9yRWFjaCgoaW5zdGFuY2UpID0+IGluc3RhbmNlLmRpc2FibGUoKSk7XG4gICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIGFkZEV2ZW50TGlzdGVuZXJzKGluc3RhbmNlKTtcbiAgfVxuXG4gIG5vcm1hbGl6ZWRSZXR1cm5WYWx1ZS5mb3JFYWNoKGFwcGx5TXV0YXRpb25zKTtcblxuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlbGVnYXRlO1xuIiwgImltcG9ydCB7QkFDS0RST1BfQ0xBU1N9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQge2Rpdiwgc2V0VmlzaWJpbGl0eVN0YXRlfSBmcm9tICcuLi9kb20tdXRpbHMnO1xuaW1wb3J0IHtnZXRDaGlsZHJlbn0gZnJvbSAnLi4vdGVtcGxhdGUnO1xuaW1wb3J0IHtBbmltYXRlRmlsbH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtlcnJvcldoZW59IGZyb20gJy4uL3ZhbGlkYXRpb24nO1xuXG5jb25zdCBhbmltYXRlRmlsbDogQW5pbWF0ZUZpbGwgPSB7XG4gIG5hbWU6ICdhbmltYXRlRmlsbCcsXG4gIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gIGZuKGluc3RhbmNlKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICghaW5zdGFuY2UucHJvcHMucmVuZGVyPy4kJHRpcHB5KSB7XG4gICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICBlcnJvcldoZW4oXG4gICAgICAgICAgaW5zdGFuY2UucHJvcHMuYW5pbWF0ZUZpbGwsXG4gICAgICAgICAgJ1RoZSBgYW5pbWF0ZUZpbGxgIHBsdWdpbiByZXF1aXJlcyB0aGUgZGVmYXVsdCByZW5kZXIgZnVuY3Rpb24uJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgY29uc3Qge2JveCwgY29udGVudH0gPSBnZXRDaGlsZHJlbihpbnN0YW5jZS5wb3BwZXIpO1xuXG4gICAgY29uc3QgYmFja2Ryb3AgPSBpbnN0YW5jZS5wcm9wcy5hbmltYXRlRmlsbFxuICAgICAgPyBjcmVhdGVCYWNrZHJvcEVsZW1lbnQoKVxuICAgICAgOiBudWxsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ3JlYXRlKCk6IHZvaWQge1xuICAgICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgICBib3guaW5zZXJ0QmVmb3JlKGJhY2tkcm9wLCBib3guZmlyc3RFbGVtZW50Q2hpbGQhKTtcbiAgICAgICAgICBib3guc2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGVmaWxsJywgJycpO1xuICAgICAgICAgIGJveC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXG4gICAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe2Fycm93OiBmYWxzZSwgYW5pbWF0aW9uOiAnc2hpZnQtYXdheSd9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uTW91bnQoKTogdm9pZCB7XG4gICAgICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgICAgIGNvbnN0IHt0cmFuc2l0aW9uRHVyYXRpb259ID0gYm94LnN0eWxlO1xuICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gTnVtYmVyKHRyYW5zaXRpb25EdXJhdGlvbi5yZXBsYWNlKCdtcycsICcnKSk7XG5cbiAgICAgICAgICAvLyBUaGUgY29udGVudCBzaG91bGQgZmFkZSBpbiBhZnRlciB0aGUgYmFja2Ryb3AgaGFzIG1vc3RseSBmaWxsZWQgdGhlXG4gICAgICAgICAgLy8gdG9vbHRpcCBlbGVtZW50LiBgY2xpcC1wYXRoYCBpcyB0aGUgb3RoZXIgYWx0ZXJuYXRpdmUgYnV0IGlzIG5vdFxuICAgICAgICAgIC8vIHdlbGwtc3VwcG9ydGVkIGFuZCBpcyBidWdneSBvbiBzb21lIGRldmljZXMuXG4gICAgICAgICAgY29udGVudC5zdHlsZS50cmFuc2l0aW9uRGVsYXkgPSBgJHtNYXRoLnJvdW5kKGR1cmF0aW9uIC8gMTApfW1zYDtcblxuICAgICAgICAgIGJhY2tkcm9wLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAgICAgICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JhY2tkcm9wXSwgJ3Zpc2libGUnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uU2hvdygpOiB2b2lkIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgYmFja2Ryb3Auc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBtcyc7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkhpZGUoKTogdm9pZCB7XG4gICAgICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgICAgIHNldFZpc2liaWxpdHlTdGF0ZShbYmFja2Ryb3BdLCAnaGlkZGVuJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFuaW1hdGVGaWxsO1xuXG5mdW5jdGlvbiBjcmVhdGVCYWNrZHJvcEVsZW1lbnQoKTogSFRNTERpdkVsZW1lbnQge1xuICBjb25zdCBiYWNrZHJvcCA9IGRpdigpO1xuICBiYWNrZHJvcC5jbGFzc05hbWUgPSBCQUNLRFJPUF9DTEFTUztcbiAgc2V0VmlzaWJpbGl0eVN0YXRlKFtiYWNrZHJvcF0sICdoaWRkZW4nKTtcbiAgcmV0dXJuIGJhY2tkcm9wO1xufVxuIiwgImltcG9ydCB7Z2V0T3duZXJEb2N1bWVudCwgaXNNb3VzZUV2ZW50fSBmcm9tICcuLi9kb20tdXRpbHMnO1xuaW1wb3J0IHtGb2xsb3dDdXJzb3IsIEluc3RhbmNlfSBmcm9tICcuLi90eXBlcyc7XG5cbmxldCBtb3VzZUNvb3JkcyA9IHtjbGllbnRYOiAwLCBjbGllbnRZOiAwfTtcbmxldCBhY3RpdmVJbnN0YW5jZXM6IEFycmF5PHtpbnN0YW5jZTogSW5zdGFuY2U7IGRvYzogRG9jdW1lbnR9PiA9IFtdO1xuXG5mdW5jdGlvbiBzdG9yZU1vdXNlQ29vcmRzKHtjbGllbnRYLCBjbGllbnRZfTogTW91c2VFdmVudCk6IHZvaWQge1xuICBtb3VzZUNvb3JkcyA9IHtjbGllbnRYLCBjbGllbnRZfTtcbn1cblxuZnVuY3Rpb24gYWRkTW91c2VDb29yZHNMaXN0ZW5lcihkb2M6IERvY3VtZW50KTogdm9pZCB7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzdG9yZU1vdXNlQ29vcmRzKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTW91c2VDb29yZHNMaXN0ZW5lcihkb2M6IERvY3VtZW50KTogdm9pZCB7XG4gIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzdG9yZU1vdXNlQ29vcmRzKTtcbn1cblxuY29uc3QgZm9sbG93Q3Vyc29yOiBGb2xsb3dDdXJzb3IgPSB7XG4gIG5hbWU6ICdmb2xsb3dDdXJzb3InLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbihpbnN0YW5jZSkge1xuICAgIGNvbnN0IHJlZmVyZW5jZSA9IGluc3RhbmNlLnJlZmVyZW5jZTtcbiAgICBjb25zdCBkb2MgPSBnZXRPd25lckRvY3VtZW50KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcblxuICAgIGxldCBpc0ludGVybmFsVXBkYXRlID0gZmFsc2U7XG4gICAgbGV0IHdhc0ZvY3VzRXZlbnQgPSBmYWxzZTtcbiAgICBsZXQgaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgIGxldCBwcmV2UHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcblxuICAgIGZ1bmN0aW9uIGdldElzSW5pdGlhbEJlaGF2aW9yKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yID09PSAnaW5pdGlhbCcgJiYgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKCk6IHZvaWQge1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcigpOiB2b2lkIHtcbiAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5zZXRHZXRSZWZlcmVuY2VDbGllbnRSZWN0KCk6IHZvaWQge1xuICAgICAgaXNJbnRlcm5hbFVwZGF0ZSA9IHRydWU7XG4gICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7Z2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogbnVsbH0pO1xuICAgICAgaXNJbnRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAvLyBJZiB0aGUgaW5zdGFuY2UgaXMgaW50ZXJhY3RpdmUsIGF2b2lkIHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB1bmxlc3MgaXQnc1xuICAgICAgLy8gb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICAgIGNvbnN0IGlzQ3Vyc29yT3ZlclJlZmVyZW5jZSA9IGV2ZW50LnRhcmdldFxuICAgICAgICA/IHJlZmVyZW5jZS5jb250YWlucyhldmVudC50YXJnZXQgYXMgTm9kZSlcbiAgICAgICAgOiB0cnVlO1xuICAgICAgY29uc3Qge2ZvbGxvd0N1cnNvcn0gPSBpbnN0YW5jZS5wcm9wcztcbiAgICAgIGNvbnN0IHtjbGllbnRYLCBjbGllbnRZfSA9IGV2ZW50O1xuXG4gICAgICBjb25zdCByZWN0ID0gcmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgcmVsYXRpdmVYID0gY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgIGNvbnN0IHJlbGF0aXZlWSA9IGNsaWVudFkgLSByZWN0LnRvcDtcblxuICAgICAgaWYgKGlzQ3Vyc29yT3ZlclJlZmVyZW5jZSB8fCAhaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSB1bm5lZWRlZCBET01SZWN0IHByb3BlcnRpZXNcbiAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgbGV0IHggPSBjbGllbnRYO1xuICAgICAgICAgICAgbGV0IHkgPSBjbGllbnRZO1xuXG4gICAgICAgICAgICBpZiAoZm9sbG93Q3Vyc29yID09PSAnaW5pdGlhbCcpIHtcbiAgICAgICAgICAgICAgeCA9IHJlY3QubGVmdCArIHJlbGF0aXZlWDtcbiAgICAgICAgICAgICAgeSA9IHJlY3QudG9wICsgcmVsYXRpdmVZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0b3AgPSBmb2xsb3dDdXJzb3IgPT09ICdob3Jpem9udGFsJyA/IHJlY3QudG9wIDogeTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gZm9sbG93Q3Vyc29yID09PSAndmVydGljYWwnID8gcmVjdC5yaWdodCA6IHg7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBmb2xsb3dDdXJzb3IgPT09ICdob3Jpem9udGFsJyA/IHJlY3QuYm90dG9tIDogeTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBmb2xsb3dDdXJzb3IgPT09ICd2ZXJ0aWNhbCcgPyByZWN0LmxlZnQgOiB4O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB3aWR0aDogcmlnaHQgLSBsZWZ0LFxuICAgICAgICAgICAgICBoZWlnaHQ6IGJvdHRvbSAtIHRvcCxcbiAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGUoKTogdm9pZCB7XG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yKSB7XG4gICAgICAgIGFjdGl2ZUluc3RhbmNlcy5wdXNoKHtpbnN0YW5jZSwgZG9jfSk7XG4gICAgICAgIGFkZE1vdXNlQ29vcmRzTGlzdGVuZXIoZG9jKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgYWN0aXZlSW5zdGFuY2VzID0gYWN0aXZlSW5zdGFuY2VzLmZpbHRlcihcbiAgICAgICAgKGRhdGEpID0+IGRhdGEuaW5zdGFuY2UgIT09IGluc3RhbmNlXG4gICAgICApO1xuXG4gICAgICBpZiAoYWN0aXZlSW5zdGFuY2VzLmZpbHRlcigoZGF0YSkgPT4gZGF0YS5kb2MgPT09IGRvYykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU1vdXNlQ29vcmRzTGlzdGVuZXIoZG9jKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb25DcmVhdGU6IGNyZWF0ZSxcbiAgICAgIG9uRGVzdHJveTogZGVzdHJveSxcbiAgICAgIG9uQmVmb3JlVXBkYXRlKCk6IHZvaWQge1xuICAgICAgICBwcmV2UHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcbiAgICAgIH0sXG4gICAgICBvbkFmdGVyVXBkYXRlKF8sIHtmb2xsb3dDdXJzb3J9KTogdm9pZCB7XG4gICAgICAgIGlmIChpc0ludGVybmFsVXBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGZvbGxvd0N1cnNvciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgcHJldlByb3BzLmZvbGxvd0N1cnNvciAhPT0gZm9sbG93Q3Vyc29yXG4gICAgICAgICkge1xuICAgICAgICAgIGRlc3Ryb3koKTtcblxuICAgICAgICAgIGlmIChmb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgICAgIGNyZWF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCAmJlxuICAgICAgICAgICAgICAhd2FzRm9jdXNFdmVudCAmJlxuICAgICAgICAgICAgICAhZ2V0SXNJbml0aWFsQmVoYXZpb3IoKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGFkZExpc3RlbmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICB1bnNldEdldFJlZmVyZW5jZUNsaWVudFJlY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbk1vdW50KCk6IHZvaWQge1xuICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yICYmICF3YXNGb2N1c0V2ZW50KSB7XG4gICAgICAgICAgaWYgKGlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgICBvbk1vdXNlTW92ZShtb3VzZUNvb3JkcyBhcyBNb3VzZUV2ZW50KTtcbiAgICAgICAgICAgIGlzVW5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFnZXRJc0luaXRpYWxCZWhhdmlvcigpKSB7XG4gICAgICAgICAgICBhZGRMaXN0ZW5lcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVHJpZ2dlcihfLCBldmVudCk6IHZvaWQge1xuICAgICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgIG1vdXNlQ29vcmRzID0ge2NsaWVudFg6IGV2ZW50LmNsaWVudFgsIGNsaWVudFk6IGV2ZW50LmNsaWVudFl9O1xuICAgICAgICB9XG4gICAgICAgIHdhc0ZvY3VzRXZlbnQgPSBldmVudC50eXBlID09PSAnZm9jdXMnO1xuICAgICAgfSxcbiAgICAgIG9uSGlkZGVuKCk6IHZvaWQge1xuICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yKSB7XG4gICAgICAgICAgdW5zZXRHZXRSZWZlcmVuY2VDbGllbnRSZWN0KCk7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICBpc1VubW91bnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZvbGxvd0N1cnNvcjtcbiIsICJpbXBvcnQge01vZGlmaWVyLCBQbGFjZW1lbnR9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcbmltcG9ydCB7aXNNb3VzZUV2ZW50fSBmcm9tICcuLi9kb20tdXRpbHMnO1xuaW1wb3J0IHtCYXNlUGxhY2VtZW50LCBJbmxpbmVQb3NpdGlvbmluZywgUHJvcHN9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7YXJyYXlGcm9tLCBnZXRCYXNlUGxhY2VtZW50fSBmcm9tICcuLi91dGlscyc7XG5cbmZ1bmN0aW9uIGdldFByb3BzKHByb3BzOiBQcm9wcywgbW9kaWZpZXI6IE1vZGlmaWVyPGFueSwgYW55Pik6IFBhcnRpYWw8UHJvcHM+IHtcbiAgcmV0dXJuIHtcbiAgICBwb3BwZXJPcHRpb25zOiB7XG4gICAgICAuLi5wcm9wcy5wb3BwZXJPcHRpb25zLFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIC4uLihwcm9wcy5wb3BwZXJPcHRpb25zPy5tb2RpZmllcnMgfHwgW10pLmZpbHRlcihcbiAgICAgICAgICAoe25hbWV9KSA9PiBuYW1lICE9PSBtb2RpZmllci5uYW1lXG4gICAgICAgICksXG4gICAgICAgIG1vZGlmaWVyLFxuICAgICAgXSxcbiAgICB9LFxuICB9O1xufVxuXG5jb25zdCBpbmxpbmVQb3NpdGlvbmluZzogSW5saW5lUG9zaXRpb25pbmcgPSB7XG4gIG5hbWU6ICdpbmxpbmVQb3NpdGlvbmluZycsXG4gIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gIGZuKGluc3RhbmNlKSB7XG4gICAgY29uc3Qge3JlZmVyZW5jZX0gPSBpbnN0YW5jZTtcblxuICAgIGZ1bmN0aW9uIGlzRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiAhIWluc3RhbmNlLnByb3BzLmlubGluZVBvc2l0aW9uaW5nO1xuICAgIH1cblxuICAgIGxldCBwbGFjZW1lbnQ6IFBsYWNlbWVudDtcbiAgICBsZXQgY3Vyc29yUmVjdEluZGV4ID0gLTE7XG4gICAgbGV0IGlzSW50ZXJuYWxVcGRhdGUgPSBmYWxzZTtcbiAgICBsZXQgdHJpZWRQbGFjZW1lbnRzOiBBcnJheTxzdHJpbmc+ID0gW107XG5cbiAgICBjb25zdCBtb2RpZmllcjogTW9kaWZpZXI8XG4gICAgICAndGlwcHlJbmxpbmVQb3NpdGlvbmluZycsXG4gICAgICBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICAgID4gPSB7XG4gICAgICBuYW1lOiAndGlwcHlJbmxpbmVQb3NpdGlvbmluZycsXG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgcGhhc2U6ICdhZnRlcldyaXRlJyxcbiAgICAgIGZuKHtzdGF0ZX0pIHtcbiAgICAgICAgaWYgKGlzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgaWYgKHRyaWVkUGxhY2VtZW50cy5pbmRleE9mKHN0YXRlLnBsYWNlbWVudCkgIT09IC0xKSB7XG4gICAgICAgICAgICB0cmllZFBsYWNlbWVudHMgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwbGFjZW1lbnQgIT09IHN0YXRlLnBsYWNlbWVudCAmJlxuICAgICAgICAgICAgdHJpZWRQbGFjZW1lbnRzLmluZGV4T2Yoc3RhdGUucGxhY2VtZW50KSA9PT0gLTFcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRyaWVkUGxhY2VtZW50cy5wdXNoKHN0YXRlLnBsYWNlbWVudCk7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSB1bm5lZWRlZCBET01SZWN0IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogKCkgPT5cbiAgICAgICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0KHN0YXRlLnBsYWNlbWVudCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwbGFjZW1lbnQgPSBzdGF0ZS5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFJlZmVyZW5jZUNsaWVudFJlY3QocGxhY2VtZW50OiBQbGFjZW1lbnQpOiBQYXJ0aWFsPERPTVJlY3Q+IHtcbiAgICAgIHJldHVybiBnZXRJbmxpbmVCb3VuZGluZ0NsaWVudFJlY3QoXG4gICAgICAgIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSxcbiAgICAgICAgcmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBhcnJheUZyb20ocmVmZXJlbmNlLmdldENsaWVudFJlY3RzKCkpLFxuICAgICAgICBjdXJzb3JSZWN0SW5kZXhcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SW50ZXJuYWxQcm9wcyhwYXJ0aWFsUHJvcHM6IFBhcnRpYWw8UHJvcHM+KTogdm9pZCB7XG4gICAgICBpc0ludGVybmFsVXBkYXRlID0gdHJ1ZTtcbiAgICAgIGluc3RhbmNlLnNldFByb3BzKHBhcnRpYWxQcm9wcyk7XG4gICAgICBpc0ludGVybmFsVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTW9kaWZpZXIoKTogdm9pZCB7XG4gICAgICBpZiAoIWlzSW50ZXJuYWxVcGRhdGUpIHtcbiAgICAgICAgc2V0SW50ZXJuYWxQcm9wcyhnZXRQcm9wcyhpbnN0YW5jZS5wcm9wcywgbW9kaWZpZXIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb25DcmVhdGU6IGFkZE1vZGlmaWVyLFxuICAgICAgb25BZnRlclVwZGF0ZTogYWRkTW9kaWZpZXIsXG4gICAgICBvblRyaWdnZXIoXywgZXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICAgICAgICBjb25zdCByZWN0cyA9IGFycmF5RnJvbShpbnN0YW5jZS5yZWZlcmVuY2UuZ2V0Q2xpZW50UmVjdHMoKSk7XG4gICAgICAgICAgY29uc3QgY3Vyc29yUmVjdCA9IHJlY3RzLmZpbmQoXG4gICAgICAgICAgICAocmVjdCkgPT5cbiAgICAgICAgICAgICAgcmVjdC5sZWZ0IC0gMiA8PSBldmVudC5jbGllbnRYICYmXG4gICAgICAgICAgICAgIHJlY3QucmlnaHQgKyAyID49IGV2ZW50LmNsaWVudFggJiZcbiAgICAgICAgICAgICAgcmVjdC50b3AgLSAyIDw9IGV2ZW50LmNsaWVudFkgJiZcbiAgICAgICAgICAgICAgcmVjdC5ib3R0b20gKyAyID49IGV2ZW50LmNsaWVudFlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gcmVjdHMuaW5kZXhPZihjdXJzb3JSZWN0KTtcbiAgICAgICAgICBjdXJzb3JSZWN0SW5kZXggPSBpbmRleCA+IC0xID8gaW5kZXggOiBjdXJzb3JSZWN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkhpZGRlbigpOiB2b2lkIHtcbiAgICAgICAgY3Vyc29yUmVjdEluZGV4ID0gLTE7XG4gICAgICB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbmxpbmVQb3NpdGlvbmluZztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldElubGluZUJvdW5kaW5nQ2xpZW50UmVjdChcbiAgY3VycmVudEJhc2VQbGFjZW1lbnQ6IEJhc2VQbGFjZW1lbnQgfCBudWxsLFxuICBib3VuZGluZ1JlY3Q6IERPTVJlY3QsXG4gIGNsaWVudFJlY3RzOiBET01SZWN0W10sXG4gIGN1cnNvclJlY3RJbmRleDogbnVtYmVyXG4pOiB7XG4gIHRvcDogbnVtYmVyO1xuICBib3R0b206IG51bWJlcjtcbiAgbGVmdDogbnVtYmVyO1xuICByaWdodDogbnVtYmVyO1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbn0ge1xuICAvLyBOb3QgYW4gaW5saW5lIGVsZW1lbnQsIG9yIHBsYWNlbWVudCBpcyBub3QgeWV0IGtub3duXG4gIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPCAyIHx8IGN1cnJlbnRCYXNlUGxhY2VtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGJvdW5kaW5nUmVjdDtcbiAgfVxuXG4gIC8vIFRoZXJlIGFyZSB0d28gcmVjdHMgYW5kIHRoZXkgYXJlIGRpc2pvaW5lZFxuICBpZiAoXG4gICAgY2xpZW50UmVjdHMubGVuZ3RoID09PSAyICYmXG4gICAgY3Vyc29yUmVjdEluZGV4ID49IDAgJiZcbiAgICBjbGllbnRSZWN0c1swXS5sZWZ0ID4gY2xpZW50UmVjdHNbMV0ucmlnaHRcbiAgKSB7XG4gICAgcmV0dXJuIGNsaWVudFJlY3RzW2N1cnNvclJlY3RJbmRleF0gfHwgYm91bmRpbmdSZWN0O1xuICB9XG5cbiAgc3dpdGNoIChjdXJyZW50QmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAnYm90dG9tJzoge1xuICAgICAgY29uc3QgZmlyc3RSZWN0ID0gY2xpZW50UmVjdHNbMF07XG4gICAgICBjb25zdCBsYXN0UmVjdCA9IGNsaWVudFJlY3RzW2NsaWVudFJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgaXNUb3AgPSBjdXJyZW50QmFzZVBsYWNlbWVudCA9PT0gJ3RvcCc7XG5cbiAgICAgIGNvbnN0IHRvcCA9IGZpcnN0UmVjdC50b3A7XG4gICAgICBjb25zdCBib3R0b20gPSBsYXN0UmVjdC5ib3R0b207XG4gICAgICBjb25zdCBsZWZ0ID0gaXNUb3AgPyBmaXJzdFJlY3QubGVmdCA6IGxhc3RSZWN0LmxlZnQ7XG4gICAgICBjb25zdCByaWdodCA9IGlzVG9wID8gZmlyc3RSZWN0LnJpZ2h0IDogbGFzdFJlY3QucmlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcblxuICAgICAgcmV0dXJuIHt0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQsIHdpZHRoLCBoZWlnaHR9O1xuICAgIH1cbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICdyaWdodCc6IHtcbiAgICAgIGNvbnN0IG1pbkxlZnQgPSBNYXRoLm1pbiguLi5jbGllbnRSZWN0cy5tYXAoKHJlY3RzKSA9PiByZWN0cy5sZWZ0KSk7XG4gICAgICBjb25zdCBtYXhSaWdodCA9IE1hdGgubWF4KC4uLmNsaWVudFJlY3RzLm1hcCgocmVjdHMpID0+IHJlY3RzLnJpZ2h0KSk7XG4gICAgICBjb25zdCBtZWFzdXJlUmVjdHMgPSBjbGllbnRSZWN0cy5maWx0ZXIoKHJlY3QpID0+XG4gICAgICAgIGN1cnJlbnRCYXNlUGxhY2VtZW50ID09PSAnbGVmdCdcbiAgICAgICAgICA/IHJlY3QubGVmdCA9PT0gbWluTGVmdFxuICAgICAgICAgIDogcmVjdC5yaWdodCA9PT0gbWF4UmlnaHRcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRvcCA9IG1lYXN1cmVSZWN0c1swXS50b3A7XG4gICAgICBjb25zdCBib3R0b20gPSBtZWFzdXJlUmVjdHNbbWVhc3VyZVJlY3RzLmxlbmd0aCAtIDFdLmJvdHRvbTtcbiAgICAgIGNvbnN0IGxlZnQgPSBtaW5MZWZ0O1xuICAgICAgY29uc3QgcmlnaHQgPSBtYXhSaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuXG4gICAgICByZXR1cm4ge3RvcCwgYm90dG9tLCBsZWZ0LCByaWdodCwgd2lkdGgsIGhlaWdodH07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiBib3VuZGluZ1JlY3Q7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHtWaXJ0dWFsRWxlbWVudH0gZnJvbSAnQHBvcHBlcmpzL2NvcmUnO1xuaW1wb3J0IHtSZWZlcmVuY2VFbGVtZW50LCBTdGlja3l9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3Qgc3RpY2t5OiBTdGlja3kgPSB7XG4gIG5hbWU6ICdzdGlja3knLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbihpbnN0YW5jZSkge1xuICAgIGNvbnN0IHtyZWZlcmVuY2UsIHBvcHBlcn0gPSBpbnN0YW5jZTtcblxuICAgIGZ1bmN0aW9uIGdldFJlZmVyZW5jZSgpOiBSZWZlcmVuY2VFbGVtZW50IHwgVmlydHVhbEVsZW1lbnQge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnBvcHBlckluc3RhbmNlXG4gICAgICAgID8gaW5zdGFuY2UucG9wcGVySW5zdGFuY2Uuc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlXG4gICAgICAgIDogcmVmZXJlbmNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3VsZENoZWNrKHZhbHVlOiAncmVmZXJlbmNlJyB8ICdwb3BwZXInKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UucHJvcHMuc3RpY2t5ID09PSB0cnVlIHx8IGluc3RhbmNlLnByb3BzLnN0aWNreSA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgbGV0IHByZXZSZWZSZWN0OiBDbGllbnRSZWN0IHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IHByZXZQb3BSZWN0OiBDbGllbnRSZWN0IHwgbnVsbCA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbigpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRSZWZSZWN0ID0gc2hvdWxkQ2hlY2soJ3JlZmVyZW5jZScpXG4gICAgICAgID8gZ2V0UmVmZXJlbmNlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgOiBudWxsO1xuICAgICAgY29uc3QgY3VycmVudFBvcFJlY3QgPSBzaG91bGRDaGVjaygncG9wcGVyJylcbiAgICAgICAgPyBwb3BwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgOiBudWxsO1xuXG4gICAgICBpZiAoXG4gICAgICAgIChjdXJyZW50UmVmUmVjdCAmJiBhcmVSZWN0c0RpZmZlcmVudChwcmV2UmVmUmVjdCwgY3VycmVudFJlZlJlY3QpKSB8fFxuICAgICAgICAoY3VycmVudFBvcFJlY3QgJiYgYXJlUmVjdHNEaWZmZXJlbnQocHJldlBvcFJlY3QsIGN1cnJlbnRQb3BSZWN0KSlcbiAgICAgICkge1xuICAgICAgICBpZiAoaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2UmVmUmVjdCA9IGN1cnJlbnRSZWZSZWN0O1xuICAgICAgcHJldlBvcFJlY3QgPSBjdXJyZW50UG9wUmVjdDtcblxuICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlUG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvbk1vdW50KCk6IHZvaWQge1xuICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMuc3RpY2t5KSB7XG4gICAgICAgICAgdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9O1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgc3RpY2t5O1xuXG5mdW5jdGlvbiBhcmVSZWN0c0RpZmZlcmVudChcbiAgcmVjdEE6IENsaWVudFJlY3QgfCBudWxsLFxuICByZWN0QjogQ2xpZW50UmVjdCB8IG51bGxcbik6IGJvb2xlYW4ge1xuICBpZiAocmVjdEEgJiYgcmVjdEIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgcmVjdEEudG9wICE9PSByZWN0Qi50b3AgfHxcbiAgICAgIHJlY3RBLnJpZ2h0ICE9PSByZWN0Qi5yaWdodCB8fFxuICAgICAgcmVjdEEuYm90dG9tICE9PSByZWN0Qi5ib3R0b20gfHxcbiAgICAgIHJlY3RBLmxlZnQgIT09IHJlY3RCLmxlZnRcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4iLCAiaW1wb3J0IHRpcHB5IGZyb20gJy4uL3NyYyc7XG5pbXBvcnQge3JlbmRlcn0gZnJvbSAnLi4vc3JjL3RlbXBsYXRlJztcblxudGlwcHkuc2V0RGVmYXVsdFByb3BzKHtyZW5kZXJ9KTtcblxuZXhwb3J0IHtkZWZhdWx0LCBoaWRlQWxsfSBmcm9tICcuLi9zcmMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNyZWF0ZVNpbmdsZXRvbn0gZnJvbSAnLi4vc3JjL2FkZG9ucy9jcmVhdGVTaW5nbGV0b24nO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGRlbGVnYXRlfSBmcm9tICcuLi9zcmMvYWRkb25zL2RlbGVnYXRlJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBhbmltYXRlRmlsbH0gZnJvbSAnLi4vc3JjL3BsdWdpbnMvYW5pbWF0ZUZpbGwnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGZvbGxvd0N1cnNvcn0gZnJvbSAnLi4vc3JjL3BsdWdpbnMvZm9sbG93Q3Vyc29yJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbmxpbmVQb3NpdGlvbmluZ30gZnJvbSAnLi4vc3JjL3BsdWdpbnMvaW5saW5lUG9zaXRpb25pbmcnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHN0aWNreX0gZnJvbSAnLi4vc3JjL3BsdWdpbnMvc3RpY2t5JztcbmV4cG9ydCB7Uk9VTkRfQVJST1cgYXMgcm91bmRBcnJvd30gZnJvbSAnLi4vc3JjL2NvbnN0YW50cyc7XG4iLCAiaW1wb3J0IHtcbiAgRWRpdG9yLCBpc05vZGVTZWxlY3Rpb24sIGlzVGV4dFNlbGVjdGlvbiwgcG9zVG9ET01SZWN0LFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSwgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcbmltcG9ydCB0aXBweSwgeyBJbnN0YW5jZSwgUHJvcHMgfSBmcm9tICd0aXBweS5qcydcblxuZXhwb3J0IGludGVyZmFjZSBCdWJibGVNZW51UGx1Z2luUHJvcHMge1xuICBwbHVnaW5LZXk6IFBsdWdpbktleSB8IHN0cmluZ1xuICBlZGl0b3I6IEVkaXRvclxuICBlbGVtZW50OiBIVE1MRWxlbWVudFxuICB0aXBweU9wdGlvbnM/OiBQYXJ0aWFsPFByb3BzPlxuICB1cGRhdGVEZWxheT86IG51bWJlclxuICBzaG91bGRTaG93PzpcbiAgICB8ICgocHJvcHM6IHtcbiAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgdmlldzogRWRpdG9yVmlld1xuICAgICAgICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgICAgICAgb2xkU3RhdGU/OiBFZGl0b3JTdGF0ZVxuICAgICAgICBmcm9tOiBudW1iZXJcbiAgICAgICAgdG86IG51bWJlclxuICAgICAgfSkgPT4gYm9vbGVhbilcbiAgICB8IG51bGxcbn1cblxuZXhwb3J0IHR5cGUgQnViYmxlTWVudVZpZXdQcm9wcyA9IEJ1YmJsZU1lbnVQbHVnaW5Qcm9wcyAmIHtcbiAgdmlldzogRWRpdG9yVmlld1xufVxuXG5leHBvcnQgY2xhc3MgQnViYmxlTWVudVZpZXcge1xuICBwdWJsaWMgZWRpdG9yOiBFZGl0b3JcblxuICBwdWJsaWMgZWxlbWVudDogSFRNTEVsZW1lbnRcblxuICBwdWJsaWMgdmlldzogRWRpdG9yVmlld1xuXG4gIHB1YmxpYyBwcmV2ZW50SGlkZSA9IGZhbHNlXG5cbiAgcHVibGljIHRpcHB5OiBJbnN0YW5jZSB8IHVuZGVmaW5lZFxuXG4gIHB1YmxpYyB0aXBweU9wdGlvbnM/OiBQYXJ0aWFsPFByb3BzPlxuXG4gIHB1YmxpYyB1cGRhdGVEZWxheTogbnVtYmVyXG5cbiAgcHJpdmF0ZSB1cGRhdGVEZWJvdW5jZVRpbWVyOiBudW1iZXIgfCB1bmRlZmluZWRcblxuICBwdWJsaWMgc2hvdWxkU2hvdzogRXhjbHVkZTxCdWJibGVNZW51UGx1Z2luUHJvcHNbJ3Nob3VsZFNob3cnXSwgbnVsbD4gPSAoe1xuICAgIHZpZXcsXG4gICAgc3RhdGUsXG4gICAgZnJvbSxcbiAgICB0byxcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gICAgY29uc3QgeyBlbXB0eSB9ID0gc2VsZWN0aW9uXG5cbiAgICAvLyBTb21ldGltZSBjaGVjayBmb3IgYGVtcHR5YCBpcyBub3QgZW5vdWdoLlxuICAgIC8vIERvdWJsZWNsaWNrIGFuIGVtcHR5IHBhcmFncmFwaCByZXR1cm5zIGEgbm9kZSBzaXplIG9mIDIuXG4gICAgLy8gU28gd2UgY2hlY2sgYWxzbyBmb3IgYW4gZW1wdHkgdGV4dCBzaXplLlxuICAgIGNvbnN0IGlzRW1wdHlUZXh0QmxvY2sgPSAhZG9jLnRleHRCZXR3ZWVuKGZyb20sIHRvKS5sZW5ndGggJiYgaXNUZXh0U2VsZWN0aW9uKHN0YXRlLnNlbGVjdGlvbilcblxuICAgIC8vIFdoZW4gY2xpY2tpbmcgb24gYSBlbGVtZW50IGluc2lkZSB0aGUgYnViYmxlIG1lbnUgdGhlIGVkaXRvciBcImJsdXJcIiBldmVudFxuICAgIC8vIGlzIGNhbGxlZCBhbmQgdGhlIGJ1YmJsZSBtZW51IGl0ZW0gaXMgZm9jdXNzZWQuIEluIHRoaXMgY2FzZSB3ZSBzaG91bGRcbiAgICAvLyBjb25zaWRlciB0aGUgbWVudSBhcyBwYXJ0IG9mIHRoZSBlZGl0b3IgYW5kIGtlZXAgc2hvd2luZyB0aGUgbWVudVxuICAgIGNvbnN0IGlzQ2hpbGRPZk1lbnUgPSB0aGlzLmVsZW1lbnQuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcblxuICAgIGNvbnN0IGhhc0VkaXRvckZvY3VzID0gdmlldy5oYXNGb2N1cygpIHx8IGlzQ2hpbGRPZk1lbnVcblxuICAgIGlmICghaGFzRWRpdG9yRm9jdXMgfHwgZW1wdHkgfHwgaXNFbXB0eVRleHRCbG9jayB8fCAhdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlZGl0b3IsXG4gICAgZWxlbWVudCxcbiAgICB2aWV3LFxuICAgIHRpcHB5T3B0aW9ucyA9IHt9LFxuICAgIHVwZGF0ZURlbGF5ID0gMjUwLFxuICAgIHNob3VsZFNob3csXG4gIH06IEJ1YmJsZU1lbnVWaWV3UHJvcHMpIHtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnRcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy51cGRhdGVEZWxheSA9IHVwZGF0ZURlbGF5XG5cbiAgICBpZiAoc2hvdWxkU2hvdykge1xuICAgICAgdGhpcy5zaG91bGRTaG93ID0gc2hvdWxkU2hvd1xuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KVxuICAgIHRoaXMudmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5kcmFnc3RhcnRIYW5kbGVyKVxuICAgIHRoaXMuZWRpdG9yLm9uKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyKVxuICAgIHRoaXMuZWRpdG9yLm9uKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcilcbiAgICB0aGlzLnRpcHB5T3B0aW9ucyA9IHRpcHB5T3B0aW9uc1xuICAgIC8vIERldGFjaGVzIG1lbnUgY29udGVudCBmcm9tIGl0cyBjdXJyZW50IHBhcmVudFxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmUoKVxuICAgIHRoaXMuZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gIH1cblxuICBtb3VzZWRvd25IYW5kbGVyID0gKCkgPT4ge1xuICAgIHRoaXMucHJldmVudEhpZGUgPSB0cnVlXG4gIH1cblxuICBkcmFnc3RhcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgIHRoaXMuaGlkZSgpXG4gIH1cblxuICBmb2N1c0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgLy8gd2UgdXNlIGBzZXRUaW1lb3V0YCB0byBtYWtlIHN1cmUgYHNlbGVjdGlvbmAgaXMgYWxyZWFkeSB1cGRhdGVkXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnVwZGF0ZSh0aGlzLmVkaXRvci52aWV3KSlcbiAgfVxuXG4gIGJsdXJIYW5kbGVyID0gKHsgZXZlbnQgfTogeyBldmVudDogRm9jdXNFdmVudCB9KSA9PiB7XG4gICAgaWYgKHRoaXMucHJldmVudEhpZGUpIHtcbiAgICAgIHRoaXMucHJldmVudEhpZGUgPSBmYWxzZVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoZXZlbnQ/LnJlbGF0ZWRUYXJnZXQgJiYgdGhpcy5lbGVtZW50LnBhcmVudE5vZGU/LmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQgYXMgTm9kZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuaGlkZSgpXG4gIH1cblxuICB0aXBweUJsdXJIYW5kbGVyID0gKGV2ZW50OiBGb2N1c0V2ZW50KSA9PiB7XG4gICAgdGhpcy5ibHVySGFuZGxlcih7IGV2ZW50IH0pXG4gIH1cblxuICBjcmVhdGVUb29sdGlwKCkge1xuICAgIGNvbnN0IHsgZWxlbWVudDogZWRpdG9yRWxlbWVudCB9ID0gdGhpcy5lZGl0b3Iub3B0aW9uc1xuICAgIGNvbnN0IGVkaXRvcklzQXR0YWNoZWQgPSAhIWVkaXRvckVsZW1lbnQucGFyZW50RWxlbWVudFxuXG4gICAgaWYgKHRoaXMudGlwcHkgfHwgIWVkaXRvcklzQXR0YWNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMudGlwcHkgPSB0aXBweShlZGl0b3JFbGVtZW50LCB7XG4gICAgICBkdXJhdGlvbjogMCxcbiAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IG51bGwsXG4gICAgICBjb250ZW50OiB0aGlzLmVsZW1lbnQsXG4gICAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICAgIGhpZGVPbkNsaWNrOiAndG9nZ2xlJyxcbiAgICAgIC4uLnRoaXMudGlwcHlPcHRpb25zLFxuICAgIH0pXG5cbiAgICAvLyBtYXliZSB3ZSBoYXZlIHRvIGhpZGUgdGlwcHkgb24gaXRzIG93biBibHVyIGV2ZW50IGFzIHdlbGxcbiAgICBpZiAodGhpcy50aXBweS5wb3BwZXIuZmlyc3RDaGlsZCkge1xuICAgICAgKHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQgYXMgSFRNTEVsZW1lbnQpLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIpXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKHZpZXc6IEVkaXRvclZpZXcsIG9sZFN0YXRlPzogRWRpdG9yU3RhdGUpIHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSB2aWV3XG4gICAgY29uc3QgaGFzVmFsaWRTZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ucG9zICE9PSBzdGF0ZS5zZWxlY3Rpb24uJHRvLnBvc1xuXG4gICAgaWYgKHRoaXMudXBkYXRlRGVsYXkgPiAwICYmIGhhc1ZhbGlkU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLmhhbmRsZURlYm91bmNlZFVwZGF0ZSh2aWV3LCBvbGRTdGF0ZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdGlvbkNoYW5nZWQgPSAhb2xkU3RhdGU/LnNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbilcbiAgICBjb25zdCBkb2NDaGFuZ2VkID0gIW9sZFN0YXRlPy5kb2MuZXEodmlldy5zdGF0ZS5kb2MpXG5cbiAgICB0aGlzLnVwZGF0ZUhhbmRsZXIodmlldywgc2VsZWN0aW9uQ2hhbmdlZCwgZG9jQ2hhbmdlZCwgb2xkU3RhdGUpXG4gIH1cblxuICBoYW5kbGVEZWJvdW5jZWRVcGRhdGUgPSAodmlldzogRWRpdG9yVmlldywgb2xkU3RhdGU/OiBFZGl0b3JTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbkNoYW5nZWQgPSAhb2xkU3RhdGU/LnNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbilcbiAgICBjb25zdCBkb2NDaGFuZ2VkID0gIW9sZFN0YXRlPy5kb2MuZXEodmlldy5zdGF0ZS5kb2MpXG5cbiAgICBpZiAoIXNlbGVjdGlvbkNoYW5nZWQgJiYgIWRvY0NoYW5nZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLnVwZGF0ZURlYm91bmNlVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnVwZGF0ZURlYm91bmNlVGltZXIpXG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVEZWJvdW5jZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVIYW5kbGVyKHZpZXcsIHNlbGVjdGlvbkNoYW5nZWQsIGRvY0NoYW5nZWQsIG9sZFN0YXRlKVxuICAgIH0sIHRoaXMudXBkYXRlRGVsYXkpXG4gIH1cblxuICB1cGRhdGVIYW5kbGVyID0gKHZpZXc6IEVkaXRvclZpZXcsIHNlbGVjdGlvbkNoYW5nZWQ6IGJvb2xlYW4sIGRvY0NoYW5nZWQ6IGJvb2xlYW4sIG9sZFN0YXRlPzogRWRpdG9yU3RhdGUpID0+IHtcbiAgICBjb25zdCB7IHN0YXRlLCBjb21wb3NpbmcgfSA9IHZpZXdcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGVcblxuICAgIGNvbnN0IGlzU2FtZSA9ICFzZWxlY3Rpb25DaGFuZ2VkICYmICFkb2NDaGFuZ2VkXG5cbiAgICBpZiAoY29tcG9zaW5nIHx8IGlzU2FtZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jcmVhdGVUb29sdGlwKClcblxuICAgIC8vIHN1cHBvcnQgZm9yIENlbGxTZWxlY3Rpb25zXG4gICAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvblxuICAgIGNvbnN0IGZyb20gPSBNYXRoLm1pbiguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiRmcm9tLnBvcykpXG4gICAgY29uc3QgdG8gPSBNYXRoLm1heCguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiR0by5wb3MpKVxuXG4gICAgY29uc3Qgc2hvdWxkU2hvdyA9IHRoaXMuc2hvdWxkU2hvdz8uKHtcbiAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICB2aWV3LFxuICAgICAgc3RhdGUsXG4gICAgICBvbGRTdGF0ZSxcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICB9KVxuXG4gICAgaWYgKCFzaG91bGRTaG93KSB7XG4gICAgICB0aGlzLmhpZGUoKVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnRpcHB5Py5zZXRQcm9wcyh7XG4gICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OlxuICAgICAgICB0aGlzLnRpcHB5T3B0aW9ucz8uZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdFxuICAgICAgICB8fCAoKCkgPT4ge1xuICAgICAgICAgIGlmIChpc05vZGVTZWxlY3Rpb24oc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSB2aWV3Lm5vZGVET00oZnJvbSkgYXMgSFRNTEVsZW1lbnRcblxuICAgICAgICAgICAgY29uc3Qgbm9kZVZpZXdXcmFwcGVyID0gbm9kZS5kYXRhc2V0Lm5vZGVWaWV3V3JhcHBlciA/IG5vZGUgOiBub2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW5vZGUtdmlldy13cmFwcGVyXScpXG5cbiAgICAgICAgICAgIGlmIChub2RlVmlld1dyYXBwZXIpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IG5vZGVWaWV3V3JhcHBlci5maXJzdENoaWxkIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHBvc1RvRE9NUmVjdCh2aWV3LCBmcm9tLCB0bylcbiAgICAgICAgfSksXG4gICAgfSlcblxuICAgIHRoaXMuc2hvdygpXG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMudGlwcHk/LnNob3coKVxuICB9XG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnRpcHB5Py5oaWRlKClcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMudGlwcHk/LnBvcHBlci5maXJzdENoaWxkKSB7XG4gICAgICAodGhpcy50aXBweS5wb3BwZXIuZmlyc3RDaGlsZCBhcyBIVE1MRWxlbWVudCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgJ2JsdXInLFxuICAgICAgICB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIsXG4gICAgICApXG4gICAgfVxuICAgIHRoaXMudGlwcHk/LmRlc3Ryb3koKVxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KVxuICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5kcmFnc3RhcnRIYW5kbGVyKVxuICAgIHRoaXMuZWRpdG9yLm9mZignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcilcbiAgICB0aGlzLmVkaXRvci5vZmYoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBCdWJibGVNZW51UGx1Z2luID0gKG9wdGlvbnM6IEJ1YmJsZU1lbnVQbHVnaW5Qcm9wcykgPT4ge1xuICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAga2V5OlxuICAgICAgdHlwZW9mIG9wdGlvbnMucGx1Z2luS2V5ID09PSAnc3RyaW5nJyA/IG5ldyBQbHVnaW5LZXkob3B0aW9ucy5wbHVnaW5LZXkpIDogb3B0aW9ucy5wbHVnaW5LZXksXG4gICAgdmlldzogdmlldyA9PiBuZXcgQnViYmxlTWVudVZpZXcoeyB2aWV3LCAuLi5vcHRpb25zIH0pLFxuICB9KVxufVxuIiwgImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuaW1wb3J0IHsgQnViYmxlTWVudVBsdWdpbiwgQnViYmxlTWVudVBsdWdpblByb3BzIH0gZnJvbSAnLi9idWJibGUtbWVudS1wbHVnaW4uanMnXG5cbmV4cG9ydCB0eXBlIEJ1YmJsZU1lbnVPcHRpb25zID0gT21pdDxCdWJibGVNZW51UGx1Z2luUHJvcHMsICdlZGl0b3InIHwgJ2VsZW1lbnQnPiAmIHtcbiAgZWxlbWVudDogSFRNTEVsZW1lbnQgfCBudWxsLFxufVxuXG5leHBvcnQgY29uc3QgQnViYmxlTWVudSA9IEV4dGVuc2lvbi5jcmVhdGU8QnViYmxlTWVudU9wdGlvbnM+KHtcbiAgbmFtZTogJ2J1YmJsZU1lbnUnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICB0aXBweU9wdGlvbnM6IHt9LFxuICAgICAgcGx1Z2luS2V5OiAnYnViYmxlTWVudScsXG4gICAgICB1cGRhdGVEZWxheTogdW5kZWZpbmVkLFxuICAgICAgc2hvdWxkU2hvdzogbnVsbCxcbiAgICB9XG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICBCdWJibGVNZW51UGx1Z2luKHtcbiAgICAgICAgcGx1Z2luS2V5OiB0aGlzLm9wdGlvbnMucGx1Z2luS2V5LFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICBlbGVtZW50OiB0aGlzLm9wdGlvbnMuZWxlbWVudCxcbiAgICAgICAgdGlwcHlPcHRpb25zOiB0aGlzLm9wdGlvbnMudGlwcHlPcHRpb25zLFxuICAgICAgICB1cGRhdGVEZWxheTogdGhpcy5vcHRpb25zLnVwZGF0ZURlbGF5LFxuICAgICAgICBzaG91bGRTaG93OiB0aGlzLm9wdGlvbnMuc2hvdWxkU2hvdyxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHtFeHRlbnNpb259IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGRlZmF1bHQgRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2NsYXNzRXh0ZW5zaW9uJyxcblxuICAgIGFkZEdsb2JhbEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2hlYWRpbmcnLFxuICAgICAgICAgICAgICAgICAgICAncGFyYWdyYXBoJyxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmsnLFxuICAgICAgICAgICAgICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgICAgICAnbGlzdEl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICAnYnVsbGV0TGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICdvcmRlcmVkTGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICd0YWJsZScsXG4gICAgICAgICAgICAgICAgICAgICd0YWJsZUhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgICd0YWJsZVJvdycsXG4gICAgICAgICAgICAgICAgICAgICd0YWJsZUNlbGwnLFxuICAgICAgICAgICAgICAgICAgICAndGV4dFN0eWxlJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckhUTUw6IGF0dHJpYnV0ZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXR0cmlidXRlcy5jbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGF0dHJpYnV0ZXMuY2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdXG4gICAgfVxufSlcbiIsICJpbXBvcnQge0V4dGVuc2lvbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgZGVmYXVsdCBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnY29tbWFuZHNFeHRlbnNpb24nLFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW92ZVRvRW5kOiAoKSA9PiAoe2NoYWluLCBzdGF0ZSwgZGlzcGF0Y2h9KSAgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24uZW1wdHkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbigpLnNldFRleHRTZWxlY3Rpb24oc3RhdGUuc2VsZWN0aW9uLiR0by5wb3MpLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSlcbiIsICJleHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29sdW1uKGNvbFR5cGUsIGNvbFNwYW4sIGNvbENvbnRlbnQgPSBudWxsKSB7XG4gIGlmIChjb2xDb250ZW50KSB7XG4gICAgcmV0dXJuIGNvbFR5cGUuY3JlYXRlQ2hlY2tlZCh7J2RhdGEtY29sLXNwYW4nOiBjb2xTcGFufSwgY29sQ29udGVudCk7XG4gIH1cblxuICByZXR1cm4gY29sVHlwZS5jcmVhdGVBbmRGaWxsKHsnZGF0YS1jb2wtc3Bhbic6IGNvbFNwYW59KTtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2V0R3JpZE5vZGVUeXBlcyhzY2hlbWEpIHtcbiAgaWYgKHNjaGVtYS5jYWNoZWQuZ3JpZE5vZGVUeXBlcykge1xuICAgIHJldHVybiBzY2hlbWEuY2FjaGVkLmdyaWROb2RlVHlwZXM7XG4gIH1cblxuICBjb25zdCByb2xlcyA9IHt9O1xuXG4gIE9iamVjdC5rZXlzKHNjaGVtYS5ub2RlcykuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgIGNvbnN0IG5vZGVUeXBlID0gc2NoZW1hLm5vZGVzW3R5cGVdO1xuXG4gICAgaWYgKG5vZGVUeXBlLnNwZWMuZ3JpZFJvbGUpIHtcbiAgICAgIHJvbGVzW25vZGVUeXBlLnNwZWMuZ3JpZFJvbGVdID0gbm9kZVR5cGU7XG4gICAgfVxuICB9KTtcblxuICBzY2hlbWEuY2FjaGVkLmdyaWROb2RlVHlwZXMgPSByb2xlcztcblxuICByZXR1cm4gcm9sZXM7XG59XG4iLCAiaW1wb3J0IHsgY3JlYXRlQ29sdW1uIH0gZnJvbSBcIi4vY3JlYXRlQ29sdW1uLmpzXCI7XG5pbXBvcnQgeyBnZXRHcmlkTm9kZVR5cGVzIH0gZnJvbSBcIi4vZ2V0R3JpZE5vZGVUeXBlcy5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlR3JpZChzY2hlbWEsIGNvbHNDb3VudCwgc3RhY2tBdCwgYXN5bW1ldHJpYywgbGVmdFNwYW4gPSBudWxsLCByaWdodFNwYW4gPSBudWxsLCBjb2xDb250ZW50ID0gbnVsbCkge1xuICBjb25zdCB7IGdyaWQsIGNvbHVtbiB9ID0gZ2V0R3JpZE5vZGVUeXBlcyhzY2hlbWEpO1xuICBjb25zdCBjb2xzID0gW107XG5cbiAgaWYgKGFzeW1tZXRyaWMpIHtcbiAgICBjb2xzLnB1c2goY3JlYXRlQ29sdW1uKGNvbHVtbiwgbGVmdFNwYW4sIGNvbENvbnRlbnQpKTtcbiAgICBjb2xzLnB1c2goY3JlYXRlQ29sdW1uKGNvbHVtbiwgcmlnaHRTcGFuLCBjb2xDb250ZW50KSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNvbHNDb3VudDsgaW5kZXggKz0gMSkge1xuICAgICAgY29uc3QgY29sID0gY3JlYXRlQ29sdW1uKGNvbHVtbiwgMSwgY29sQ29udGVudCk7XG5cbiAgICAgIGlmIChjb2wpIHtcbiAgICAgICAgY29scy5wdXNoKGNvbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdyaWQuY3JlYXRlQ2hlY2tlZCh7ICdkYXRhLWNvbHVtbnMnOiBjb2xzQ291bnQsICdkYXRhLXR5cGUnOiBhc3ltbWV0cmljID8/ICdyZXNwb25zaXZlJywgJ2RhdGEtc3RhY2stYXQnOiBzdGFja0F0IH0sIGNvbHMpO1xufVxuIiwgImltcG9ydCB7IGNhbGxPclJldHVybiwgZ2V0RXh0ZW5zaW9uRmllbGQsIE5vZGUsIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gXCJAdGlwdGFwL2NvcmVcIjtcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuaW1wb3J0IHsgY3JlYXRlR3JpZCB9IGZyb20gXCIuL3V0aWxzL2NyZWF0ZUdyaWQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgTm9kZS5jcmVhdGUoe1xuICBuYW1lOiBcImdyaWRcIixcbiAgZ3JvdXA6IFwiYmxvY2tcIixcbiAgZGVmaW5pbmc6IHRydWUsXG4gIGlzb2xhdGluZzogdHJ1ZSxcbiAgYWxsb3dHYXBDdXJzb3I6IGZhbHNlLFxuICBjb250ZW50OiBcImdyaWRDb2x1bW4rXCIsXG4gIGdyaWRSb2xlOiBcImdyaWRcIixcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgY2xhc3M6IFwic2NyaWJibGUtZ3JpZFwiLFxuICAgICAgfSxcbiAgICB9O1xuICB9LFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgICdkYXRhLXR5cGUnOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiAncmVzcG9uc2l2ZScsXG4gICAgICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdHlwZVwiKSxcbiAgICAgICAgfSxcbiAgICAgICdkYXRhLWNvbHVtbnMnOiB7XG4gICAgICAgIGRlZmF1bHQ6IDIsXG4gICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2x1bW5zXCIpLFxuICAgICAgfSxcbiAgICAgICdkYXRhLXN0YWNrLWF0Jzoge1xuICAgICAgICBkZWZhdWx0OiAnbWQnLFxuICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtc3RhY2stYXRcIiksXG4gICAgICB9LFxuICAgICAgJ3N0eWxlJzoge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpLFxuICAgICAgICByZW5kZXJIVE1MOiAoYXR0cmlidXRlcykgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdHlsZTogYGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KCR7YXR0cmlidXRlc1snZGF0YS1jb2x1bW5zJ119LCAxZnIpO2BcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImRpdltkYXRhLXR5cGU9J2dyaWQnXVwiLFxuICAgICAgfSxcbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXCJkaXZcIiwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgfSxcbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluc2VydEdyaWQ6XG4gICAgICAgICh7IGNvbHVtbnMgPSAyLCBzdGFja19hdCwgYXN5bW1ldHJpYywgbGVmdF9zcGFuID0gbnVsbCwgcmlnaHRfc3BhbiA9IG51bGwgfSA9IHt9KSA9PlxuICAgICAgICAoeyB0ciwgZGlzcGF0Y2gsIGVkaXRvciB9KSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IGNyZWF0ZUdyaWQoZWRpdG9yLnNjaGVtYSwgY29sdW1ucywgc3RhY2tfYXQsIGFzeW1tZXRyaWMsIGxlZnRfc3BhbiwgcmlnaHRfc3Bhbik7XG5cbiAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRyLnNlbGVjdGlvbi5hbmNob3IgKyAxO1xuXG4gICAgICAgICAgICB0ci5yZXBsYWNlU2VsZWN0aW9uV2l0aChub2RlKVxuICAgICAgICAgICAgICAuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICAgICAgICAuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShvZmZzZXQpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgfSxcbiAgZXh0ZW5kTm9kZVNjaGVtYShleHRlbnNpb24pIHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ3JpZFJvbGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sIFwiZ3JpZFJvbGVcIiwgY29udGV4dCkpLFxuICAgIH07XG4gIH0sXG59KTtcbiIsICJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tIFwiQHRpcHRhcC9jb3JlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGUuY3JlYXRlKHtcbiAgbmFtZTogXCJncmlkQ29sdW1uXCIsXG4gIGNvbnRlbnQ6IFwiYmxvY2srXCIsXG4gIGdyaWRSb2xlOiBcImNvbHVtblwiLFxuICBpc29sYXRpbmc6IHRydWUsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7XG4gICAgICAgIGNsYXNzOiBcInNjcmliYmxlLWdyaWQtY29sdW1uXCIsXG4gICAgICB9LFxuICAgIH07XG4gIH0sXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdkYXRhLWNvbC1zcGFuJzoge1xuICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY29sLXNwYW5cIiksXG4gICAgICAgIHJlbmRlckhUTUw6IChhdHRyaWJ1dGVzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdkYXRhLWNvbC1zcGFuJzogYXR0cmlidXRlc1snZGF0YS1jb2wtc3BhbiddID8/IDEsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ3N0eWxlJzoge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpLFxuICAgICAgICByZW5kZXJIVE1MOiAoYXR0cmlidXRlcykgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdHlsZTogYGdyaWQtY29sdW1uOiBzcGFuICR7YXR0cmlidXRlc1snZGF0YS1jb2wtc3BhbiddID8/IDF9O2BcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImRpdlwiLFxuICAgICAgICBnZXRBdHRyczogKG5vZGUpID0+IG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2NyaWJibGUtZ3JpZC1jb2x1bW5cIikgJiYgbnVsbCxcbiAgICAgIH0sXG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1wiZGl2XCIsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gIH0sXG59KTtcbiIsICJpbXBvcnQge0V4dGVuc2lvbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgZGVmYXVsdCBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnaWRFeHRlbnNpb24nLFxuXG4gICAgYWRkR2xvYmFsQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlczogW1xuICAgICAgICAgICAgICAgICAgICAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgICAgICdsaW5rJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJykgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckhUTUw6IGF0dHJpYnV0ZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXR0cmlidXRlcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGF0dHJpYnV0ZXMuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdXG4gICAgfVxufSlcbiIsICIvLyBUSElTIEZJTEUgSVMgQVVUT01BVElDQUxMWSBHRU5FUkFURUQgRE8gTk9UIEVESVQgRElSRUNUTFlcbi8vIFNlZSB1cGRhdGUtdGxkcy5qcyBmb3IgZW5jb2RpbmcvZGVjb2RpbmcgZm9ybWF0XG4vLyBodHRwczovL2RhdGEuaWFuYS5vcmcvVExEL3RsZHMtYWxwaGEtYnktZG9tYWluLnR4dFxuY29uc3QgZW5jb2RlZFRsZHMgPSAnYWFhMXJwM2JiMG90dDN2aWU0YzFsZTJvZ2FkbzV1ZGhhYmk3YzBhZGVteTVjZW50dXJlNm91bnRhbnQwczlvMXRvcjRkMHMxdWx0NGUwZzFybzJ0bmE0ZjBsMXJpY2E1ZzBha2hhbjVlbmN5NWkwZzFyYnVzM2ZvcmNlNXRlbDVrZG4zbDBpYmFiYTRwYXk0bGZpbmFuejZzdGF0ZTV5MnNhY2UzdG9tNW0wYXpvbjRlcmljYW5leHByZXNzN2ZhbWlseTExeDJmYW0zaWNhM3N0ZXJkYW04bmFseXRpY3M3ZHJvaWQ1cXVhbjR6Mm8wbDJwYXJ0bWVudHM4cDBsZTRxMHVhcmVsbGU4cjBhYjFtY280Y2hpM215MnBhMnQwZTNzMGRhMmlhMnNvY2lhdGVzOXQwaGxldGE1dG9ybmV5N3UwY3Rpb241ZGkwYmxlM28zc3Bvc3Q1dGhvcjNvMHM0dmlhbmNhNncwczJ4MGEyejB1cmU1YmEwYnkyaWR1M25hbWV4M25hcmVwdWJsaWMxMWQxazJyMGNlbG9uYTVsYXljYXJkNHM1ZWZvb3Q1Z2FpbnM2c2ViYWxsNWtldGJhbGw4dWhhdXM1eWVybjViMGMxdDF2YTNjZzFuMmQxZTBhdHMydXR5NGVyMm50bGV5NXJsaW40c3QwYnV5NXQyZjFnMWgwYXJ0aTVpMGJsZTNkMWtlMm5nMG8zbzF6MmoxbGFjazBmcmlkYXk5b2NrYnVzdGVyOGcxb21iZXJnN3VlM20wczF3Mm4wcHBhcmliYXM5bzBhdHMzZWhyaW5nZXI4ZmEybTFuZDJvMGswaW5nNXNjaDJ0aWsyb240dDF1dGlxdWU2eDJyMGFkZXNjbzZpZGdlc3RvbmU5b2Fkd2F5NWtlcjN0aGVyNXVzc2VsczdzMXQxdWlsZDBlcnM2c2luZXNzNnkxenozdjF3MXkxejBoM2NhMGIxZmUybDBsMXZpbmtsZWluOW0wZXJhM3Aybm9uM3BldG93bjVpdGFsMG9uZThyMGF2YW40ZHMyZTBlcjBzNHMyc2ExZTFoMWlubzR0MGVyaW5nNWhvbGljN2JhMW4xcmUzYzFkMWVudGVyNG8xcm4zZjBhMWQyZzFoMGFuZWwybmVsNHJpdHk0c2UydDJlYXAzaW50YWk1cmlzdG1hczZvbWU0dXJjaDVpMHByaWFuaTZyY2xlNHNjbzN0YWRlbDRpMGMyeTNrMWwwYWltczRlYW5pbmc2aWNrMm5pYzFxdWU2b3RoaW5nNXVkM3ViMG1lZDZtMW4xbzBhY2gzZGVzM2ZmZWU0bGxlZ2U0b2duZTVtMGNhc3Q0bWJhbms0dW5pdHk2cGFueTJyZTN1dGVyNXNlYzRuZG9zM3N0cnVjdGlvbjh1bHRpbmc3dGFjdDNyYWN0b3JzOW9raW5nNGwxcDJyc2ljYTV1bnRyeTRwb24wczRyc2VzNnBhMnIwZWRpdDBjYXJkNHVuaW9uOWlja2V0NW93bjNzMXVpc2UwczZ1MGlzaW5lbGxhOXYxdzF4MXkwbXJ1M291M3oyZGFidXIzZDFuY2UzdGExZTFpbmczc3VuNHkyY2xrM2RzMmUwYWwwZXIyczNncmVlNGxpdmVyeTVsMW9pdHRlNXRhM21vY3JhdDZudGFsMmlzdDVzaTBnbjR2MmhsMmlhbW9uZHM2ZXQyZ2l0YWw1cmVjdDBvcnk3c2NvdW50M3ZlcjVoMnkyajFrMW0xbnAybzBjczF0b3I0ZzFtYWluczV0MXdubG9hZDdyaXZlNHR2MnViYWkzbmxvcDRwb250NHJiYW41dmFnMnIyejJlYXJ0aDN0MmMwbzJkZWthM3UwY2F0aW9uOGUxZzFtYWlsM2VyY2s1bmVyZ3k0Z2luZWVyMGluZzl0ZXJwcmlzZXMxMHBzb240cXVpcG1lbnQ4cjBpY3Nzb242bmkzczBxMXRhdGU1dDF1MHJvdmlzaW9uOHMydmVudHM1eGNoYW5nZTZwZXJ0M29zZWQ0cmVzczV0cmFzcGFjZTEwZmFnZTJpbDFyd2luZHM2dGgzbWlseTRuMHMycm0wZXJzNXNoaW9uNHQzZWRleDNlZGJhY2s2cnJhcmkzZXJvNmkwZGVsaXR5NW8ybG0ybmFsMW5jZTFpYWw3cmUwc3RvbmU2bWRhbGU2c2gwaW5nNXQwbmVzczZqMWsxbGlja3IzZ2h0czRyMm9yaXN0NHdlcnM1eTJtMW8wbzBkMXRiYWxsNnJkMWV4MnNhbGU0dW0zdW5kYXRpb244eDJyMGVlMXNlbml1czdsMW9nYW5zNG50aWVyN3RyMnVqaXRzdTVuMGQycm5pdHVyZTd0Ym9sNXlpM2dhMGwwbGVyeTNvMXVwNG1lMHMzcDFyZGVuNHkyYjBpejNkMG4yZTBhMW50MGluZzVvcmdlNWYxZzBlZTNoMWkwZnQwczN2ZXMyaW5nNWwwYXNzM2Uxb2JhbDJvNG0wYWlsM2JoMm8xeDJuMW9kYWRkeTVsZDBwb2ludDZmMm8wZHllYXI1ZzBsZTRwMXQxdjJwMXExcjBhaW5nZXI1cGhpY3M1dGlzNGVlbjNpcGUzb2Nlcnk0dXA0czF0MXUwYXJkaWFuNmNjaTNnZTJpZGUydGFyczVydTN3MXkyaGFpcjJtYnVyZzVuZ291dDV1czNibzJkZmMwYmFuazdlYWx0aDBjYXJlOGxwMXNpbmtpNnJlMW1lczVpcGhvcDRzYW1pdHN1N3RhY2hpNXYyazB0Mm0xbjFvY2tleTRsZGluZ3M1aWRheTVtZWRlcG90NWdvb2RzNXMwZW5zZTduZGEzcnNlM3NwaXRhbDV0MGluZzV0MGVsczNtYWlsNXVzZTN3MnIxc2JjM3QxdTBnaGVzNXlhdHQzdW5kYWk3aWJtMmNiYzJlMXUyZDFlMGVlM2ZtMmthbm80bDFtMGFtYXQ0ZGIybW8wYmlsaWVuOW4wYzFkdXN0cmllczhmaW5pdGk1bzJnMWsxc3RpdHV0ZTZ1cmFuY2U0ZTR0MGVybmF0aW9uYWwxMHVpdDR2ZXN0bWVudHMxMG8xcGlyYW5nYTdxMXIwaXNoNHMwbWFpbGk1dDBhbmJ1bDd0MGF1MnYzamFndWFyNHZhM2NiMmUwZXAydHp0M3dlbHJ5NmlvMmxsMm0wcDJuajJvMGJzMXVyZzR0MXkycDBtb3JnYW42cnMzdWVnb3M0bmlwZXI3a2F1ZmVuNWRkaTNlMHJyeWhvdGVsczZsb2dpc3RpY3M5cHJvcGVydGllczE0ZmgyZzFoMWkwYTFkczJtMW5kbGU0dGNoZW41d2kzbTFuMW9lbG4zbWF0c3U1c2hlcjVwMG1nMm4ycjBkMWVkM3Vva2dyb3VwOHcxeTBvdG80ejJsYTBjYWl4YTVtYm9yZ2hpbmk4ZXIzbmNhc3RlcjZkMHJvdmVyNnhlc3M1c2FsbGU1dDBpbm8zcm9iZTV3MHllcjViMWMxZHMyZWFzZTNjbGVyYzVmcmFrNGdhbDJvMnh1czRnYnQzaTBkbDJmZTBpbnN1cmFuY2U5c3R5bGU3Z2h0aW5nNmtlMmxseTNtaXRlZDRvMm5jb2xuNGsycHN5M3ZlMWluZzVrMWxjMXAyb2FuMHMzY2tlcjN1czNsMW5kb240dHRlMW8zdmUzcGwwZmluYW5jaWFsMTFyMXMxdDBkMGEzdTBuZGJlY2s2eGUxdXJ5NXYxeTJtYTBkcmlkNGlmMXNvbjRrZXVwNG4wYWdlbWVudDdnbzNwMXJrZXQwaW5nM3M0cmlvdHQ1c2hhbGxzN3R0ZWw1YmEyYzBraW5zZXk3ZDFlMGQwaWEzZXQybGJvdXJuZTdtZTFvcmlhbDZuMHUycmNrbXNkN2cxaDFpYW1pM2Nyb3NvZnQ3bDFuaTF0MnQwc3ViaXNoaTlrMWwwYjFzMm0wYTJuMW8wYmkwbGU0ZGEyZTFpMW0xbmFzaDNleTJzdGVyNXJtb24zdGdhZ2U2c2NvdzR0bzByY3ljbGVzOXYwaWU0cDFxMXIxczBkMnQwbjFyMnUwc2V1bTNpYzR2MXcxeDF5MXoybmEwYjFnb3lhNG1lMnR1cmE0dnkzYmEyYzFlMGMxdDBiYW5rNGZsaXg0d29yazV1c3RhcjV3MHMyeHQwZGlyZWN0N3VzNGYwbDJnMG8yaGsyaTBjbzJrZTFvbjNuamEzc3NhbjF5NWwxbzBraWEzcnRvbjR3MHJ1ejN0djRwMXIwYTF3MnR0MnUxeWMyejJvYmkxc2VydmVyN2ZmaWNlNWtpbmF3YTZsYXlhbjBncm91cDlkbmF2eTVsbzNtMGVnYTRuZTFnMWwwaW5lNW9vMnBlbjNyYWNsZTNuZ2U0ZzBhbmljNWlnaW5zNnNha2E0dHN1a2E0dDJ2aDNwYTBnZTJuYXNvbmljN3JpczJzMXRuZXJzNHMxeTN5MmNjdzNlMHQyZjBpemVyNWcxaDBhcm1hY3k2ZDFpbGlwczVvbmUydG8wZ3JhcGh5NnM0eXNpbzVpY3MxdGV0MnVyZXM2ZDFuMGcxazJvbmVlcjV6emE0azFsMGFjZTJ5MHN0YXRpb245dW1iaW5nNXMzbTFuMGMyb2hsMmtlcjNsaXRpZTVybjJzdDNyMGFtZXJpY2E2eGkzZXNzM2ltZTNvMGQwdWN0aW9uczhmMWdyZXNzaXZlOG1vMnBlcnRpZXMzeTV0ZWN0aW9uOHUwZGVudGlhbDlzMXQxdWIydzBjMnkycWExcG9uM3VlYmVjM3N0NXJhY2luZzRkaW80ZTBhZDFsZXN0YXRlNnRvcjJ5NGNpcGVzNWQwc3RvbmU1dW1icmVsbGE5aGFiM2lzZTBuM3QybGlhbmNlNm4wdDBhbHM1cGFpcjNvcnQzdWJsaWNhbjhzdDBhdXJhbnQ4dmlldzBzNXhyb3RoNmljaDBhcmRsaTZvaDNsMW8xcDJvMGNrczNkZW8zZ2VyczRvbTNzMHZwM3UwZ2J5M2hyMm4ydzBlMnl1a3l1NnNhMGFybGFuZDZmZTB0eTRrdXJhNGxlMW9uM21zY2x1YjR1bmc1bmR2aWswY29yb21hbnQxMm9maTRwMXJsMnMxdmUyeG8zYjBpMXMyYzBhMWIxaGFlZmZsZXI3bWlkdDRvbGFyc2hpcHM4b2wzdWxlM3dhcno1aWVuY2U1b3QzZDFlMGFyY2gzdDJjdXJlMWl0eTZlazJsZWN0NG5lcjNydmljZXM2dmVuM3cxeDB5M2ZyMmcxaDBhbmdyaWxhNnJwMncyZWxsM2lhMWtzaGE1b2VzMnAwcGluZzV1amkzdzNpMGxrMm5hMWdsZXM1dGUzajFrMGkwbjJ5MHBlNGwwaW5nNG0wYXJ0M2lsZTRuMGNmM28wY2NlcjNpYWw0ZnRiYW5rNHdhcmU2aHUybGFyMnV0aW9uczduZzF5MnkycGEwY2Uzb3J0MnQzcjBsMnMxdDBhZGEycGxlczRyMXRlYmFuazRmYXJtN2MwZ3JvdXA2b2NraG9sbTZyYWdlM2UzcmVhbTR1ZGlvMnkzeWxlNHUwY2tzM3BwbGllczN5Mm9ydDVyZjFnZXJ5NXp1a2k1djF3YXRjaDRpc3M0eDF5MGRuZXk0c3RlbXM2ejJ0YWIxaXBlaTRsazJvYmFvNHJnZXQ0dGFtb3RvcnM2cjJ0b280eDBpM2MwaTJkMGsyZWFtMmNoMG5vbG9neThsMW1hc2VrNW5uaXM0dmEzZjFnMWgwZDFlYXRlcjJyZTZpYWEyY2tldHM1ZW5kYTRwczJyZXMyb2w0ajBtYXh4NHgyazBtYXh4NWwxbTBhbGw0bjFvMGRheTNreW8zb2xzM3AxcmF5M3NoaWJhNXRhbDN1cnMzd24yeW90YTNzM3IwYWRlMWluZzRpbmluZzV2ZWwwZXJzMGluc3VyYW5jZTE2dXN0M3YydDF1YmUyaTFuZXMzc2h1NHYwczJ3MXoydWExYmFuazNzMmcxazFuaWNvbTN2ZXJzaXR5OG8yb2wycHMyczF5MXoydmEwY2F0aW9uczduYTFndWFyZDdjMWUwZ2FzM250dXJlczZyaXNpZ241bVx1MDBGNmdlbnNiZXJhdGVyMnVuZzE0c2ljaGVydW5nMTB0MmcxaTBhamVzNGRlbzNnMWtpbmc0bGxhczRuMXAxcmdpbjRzYTFpb240dmExbzNsYWFuZGVyZW45bjFvZGthM2x2bzN0ZTFpbmczbzJ5YWdlNXUyd2FsZXMybWFydDR0ZXI0bmcwZ291NXRjaDBlczZlYXRoZXIwY2hhbm5lbDEyYmNhbTNlcjJzaXRlNWQwZGluZzVpYm8ycjNmMWhvc3dobzZpZW4ya2kybGxpYW1oaWxsOW4wZG93czRlMW5lcnM2bWUyb2x0ZXJza2x1d2VyMTFvZHNpZGU2cmswczJsZDN3MnMxdGMxZjN4Ym94M2Vyb3g0ZmluaXR5NmlodWFuNG4yeHgyeXozeWFjaHRzNGhvbzNtYXh1bjVuZGV4NWUxb2RvYmFzaGk3Z2Eya29oYW1hNnUwdHViZTZ0MXVuM3phMHBwb3M0cmEzZXJvM2lwMm0xb25lM3VlcmljaDZ3Mic7XG4vLyBJbnRlcm5hdGlvbmFsaXplZCBkb21haW4gbmFtZXMgY29udGFpbmluZyBub24tQVNDSUlcbmNvbnN0IGVuY29kZWRVdGxkcyA9ICdcdTAzQjVcdTAzQkIxXHUwM0M1Mlx1MDQzMVx1MDQzMzFcdTA0MzVcdTA0M0IzXHUwNDM0XHUwNDM1XHUwNDQyXHUwNDM4NFx1MDQzNVx1MDQ0RTJcdTA0M0FcdTA0MzBcdTA0NDJcdTA0M0VcdTA0M0JcdTA0MzhcdTA0M0E2XHUwNDNFXHUwNDNDM1x1MDQzQ1x1MDQzQVx1MDQzNDJcdTA0M0VcdTA0M0QxXHUwNDQxXHUwNDNBXHUwNDMyXHUwNDMwNlx1MDQzRVx1MDQzRFx1MDQzQlx1MDQzMFx1MDQzOVx1MDQzRDVcdTA0NDBcdTA0MzMzXHUwNDQwXHUwNDQzXHUwNDQxMlx1MDQ0NDJcdTA0NDFcdTA0MzBcdTA0MzlcdTA0NDIzXHUwNDQwXHUwNDMxM1x1MDQ0M1x1MDQzQVx1MDQ0MDNcdTA0OUJcdTA0MzBcdTA0MzczXHUwNTcwXHUwNTYxXHUwNTc1M1x1MDVEOVx1MDVFOVx1MDVFOFx1MDVEMFx1MDVEQzVcdTA1RTdcdTA1RDVcdTA1REQzXHUwNjI3XHUwNjI4XHUwNjQ4XHUwNjM4XHUwNjI4XHUwNjRBNVx1MDYzMVx1MDYyN1x1MDY0NVx1MDY0M1x1MDY0ODVcdTA2NDRcdTA2MjdcdTA2MzFcdTA2MkZcdTA2NDY0XHUwNjI4XHUwNjJEXHUwNjMxXHUwNjRBXHUwNjQ2NVx1MDYyQ1x1MDYzMlx1MDYyN1x1MDYyNlx1MDYzMTVcdTA2MzNcdTA2MzlcdTA2NDhcdTA2MkZcdTA2NEFcdTA2Mjk2XHUwNjM5XHUwNjQ0XHUwNjRBXHUwNjI3XHUwNjQ2NVx1MDY0NVx1MDYzQVx1MDYzMVx1MDYyODVcdTA2NDVcdTA2MjdcdTA2MzFcdTA2MjdcdTA2MkE1XHUwNkNDXHUwNjMxXHUwNjI3XHUwNjQ2NVx1MDYyOFx1MDYyN1x1MDYzMVx1MDYyQTJcdTA2MzJcdTA2MjdcdTA2MzE0XHUwNjRBXHUwNjJBXHUwNjQzM1x1MDZCRVx1MDYyN1x1MDYzMVx1MDYyQTVcdTA2MkFcdTA2NDhcdTA2NDZcdTA2MzM0XHUwNjMzXHUwNjQ4XHUwNjJGXHUwNjI3XHUwNjQ2M1x1MDYzMVx1MDY0QVx1MDYyOTVcdTA2MzRcdTA2MjhcdTA2NDNcdTA2Mjk0XHUwNjM5XHUwNjMxXHUwNjI3XHUwNjQyMlx1MDYyODJcdTA2NDVcdTA2MjdcdTA2NDY0XHUwNjQxXHUwNjQ0XHUwNjMzXHUwNjM3XHUwNjRBXHUwNjQ2Nlx1MDY0Mlx1MDYzN1x1MDYzMTNcdTA2NDNcdTA2MjdcdTA2MkJcdTA2NDhcdTA2NDRcdTA2NEFcdTA2NDM2XHUwNjQ4XHUwNjQ1M1x1MDY0NVx1MDYzNVx1MDYzMTJcdTA2NDRcdTA2NEFcdTA2MzNcdTA2NEFcdTA2Mjc1XHUwNjQ4XHUwNjMxXHUwNjRBXHUwNjJBXHUwNjI3XHUwNjQ2XHUwNjRBXHUwNjI3N1x1MDY0Mlx1MDYzOTRcdTA2NDdcdTA2NDVcdTA2MzFcdTA2MjdcdTA2NDc1XHUwNjdFXHUwNjI3XHUwNkE5XHUwNjMzXHUwNjJBXHUwNjI3XHUwNjQ2N1x1MDY4MFx1MDYyN1x1MDYzMVx1MDYyQTRcdTA5MTVcdTA5NDlcdTA5MkUzXHUwOTI4XHUwOTQ3XHUwOTFGM1x1MDkyRFx1MDkzRVx1MDkzMFx1MDkyNDBcdTA5MkVcdTA5NEQzXHUwOTRCXHUwOTI0NVx1MDkzOFx1MDkwMlx1MDkxN1x1MDkyMFx1MDkyODVcdTA5QUNcdTA5QkVcdTA5ODJcdTA5QjJcdTA5QkU1XHUwOUFEXHUwOUJFXHUwOUIwXHUwOUE0Mlx1MDlGMFx1MDlBNDRcdTBBMkRcdTBBM0VcdTBBMzBcdTBBMjQ0XHUwQUFEXHUwQUJFXHUwQUIwXHUwQUE0NFx1MEIyRFx1MEIzRVx1MEIzMFx1MEIyNDRcdTBCODdcdTBCQThcdTBCQ0RcdTBCQTRcdTBCQkZcdTBCQUZcdTBCQkU2XHUwQkIyXHUwQjk5XHUwQkNEXHUwQjk1XHUwQkM4Nlx1MEI5QVx1MEJCRlx1MEI5OVx1MEJDRFx1MEI5NVx1MEJBQVx1MEJDRFx1MEJBQVx1MEJDMlx1MEJCMFx1MEJDRDExXHUwQzJEXHUwQzNFXHUwQzMwXHUwQzI0XHUwQzRENVx1MENBRFx1MENCRVx1MENCMFx1MENBNDRcdTBEMkRcdTBEM0VcdTBEMzBcdTBEMjRcdTBEMDI1XHUwREJEXHUwRDgyXHUwRDlBXHUwRENGNFx1MEUwNFx1MEUyRFx1MEUyMTNcdTBFNDRcdTBFMTdcdTBFMjIzXHUwRUE1XHUwRUIyXHUwRUE3M1x1MTBEMlx1MTBENDJcdTMwN0ZcdTMwOTNcdTMwNkEzXHUzMEEyXHUzMERFXHUzMEJFXHUzMEYzNFx1MzBBRlx1MzBFOVx1MzBBNlx1MzBDOTRcdTMwQjBcdTMwRkNcdTMwQjBcdTMwRUI0XHUzMEIzXHUzMEUwMlx1MzBCOVx1MzBDOFx1MzBBMjNcdTMwQkJcdTMwRkNcdTMwRUIzXHUzMEQ1XHUzMEExXHUzMEMzXHUzMEI3XHUzMEU3XHUzMEYzNlx1MzBERFx1MzBBNFx1MzBGM1x1MzBDODRcdTRFMTZcdTc1NEMyXHU0RTJEXHU0RkUxMVx1NTZGRDFcdTU3MEIxXHU2NTg3XHU3RjUxM1x1NEU5QVx1OUE2Q1x1OTAwQTNcdTRGMDFcdTRFMUEyXHU0RjVCXHU1QzcxMlx1NEZFMVx1NjA2RjJcdTUwNjVcdTVFQjcyXHU1MTZCXHU1MzY2Mlx1NTE2Q1x1NTNGODFcdTc2Q0EyXHU1M0YwXHU2RTdFMVx1NzA2MzJcdTU1NDZcdTU3Q0UxXHU1RTk3MVx1NjgwNzJcdTU2MDlcdTkxQ0MwXHU1OTI3XHU5MTUyXHU1RTk3NVx1NTcyOFx1N0VCRjJcdTU5MjdcdTYyRkYyXHU1OTI5XHU0RTNCXHU2NTU5M1x1NUEzMVx1NEU1MDJcdTVCQjZcdTk2RkIyXHU1RTdGXHU0RTFDMlx1NUZBRVx1NTM1QTJcdTYxNDhcdTU1ODQyXHU2MjExXHU3MjMxXHU0RjYwM1x1NjI0Qlx1NjczQTJcdTYyREJcdTgwNTgyXHU2NTNGXHU1MkExMVx1NUU5QzJcdTY1QjBcdTUyQTBcdTU3NjEyXHU5NUZCMlx1NjVGNlx1NUMxQTJcdTY2RjhcdTdDNEQyXHU2NzNBXHU2Nzg0Mlx1NkRFMVx1OUE2Q1x1OTUyMTNcdTZFMzhcdTYyMEYyXHU2RkIzXHU5NTgwMlx1NzBCOVx1NzcwQjJcdTc5RkJcdTUyQTgyXHU3RUM0XHU3RUM3XHU2NzNBXHU2Nzg0NFx1N0Y1MVx1NTc0MDFcdTVFOTcxXHU3QUQ5MVx1N0VEQzJcdTgwNTRcdTkwMUEyXHU4QzM3XHU2QjRDMlx1OEQyRFx1NzI2OTJcdTkwMUFcdThDQTkyXHU5NkM2XHU1NkUyMlx1OTZGQlx1OEEwQVx1NzZDOFx1NzlEMTRcdTk4REVcdTUyMjlcdTZENjYzXHU5OERGXHU1NEMxMlx1OTkxMFx1NTM4NTJcdTk5OTlcdTY4M0NcdTkxQ0NcdTYyQzkzXHU2RTJGMlx1QjJGN1x1QjEzNzFcdUNFRjQyXHVDMEJDXHVDMTMxMlx1RDU1Q1x1QUQ2RDInO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBXG4gKiBAdGVtcGxhdGUgQlxuICogQHBhcmFtIHtBfSB0YXJnZXRcbiAqIEBwYXJhbSB7Qn0gcHJvcGVydGllc1xuICogQHJldHVybiB7QSAmIEJ9XG4gKi9cbmNvbnN0IGFzc2lnbiA9ICh0YXJnZXQsIHByb3BlcnRpZXMpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcGVydGllcykge1xuICAgIHRhcmdldFtrZXldID0gcHJvcGVydGllc1trZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEZpbml0ZSBTdGF0ZSBNYWNoaW5lIGdlbmVyYXRpb24gdXRpbGl0aWVzXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge3sgW2dyb3VwOiBzdHJpbmddOiBUW10gfX0gQ29sbGVjdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7IFtncm91cDogc3RyaW5nXTogdHJ1ZSB9fSBGbGFnc1xuICovXG5cbi8vIEtleXMgaW4gc2Nhbm5lciBDb2xsZWN0aW9ucyBpbnN0YW5jZXNcbmNvbnN0IG51bWVyaWMgPSAnbnVtZXJpYyc7XG5jb25zdCBhc2NpaSA9ICdhc2NpaSc7XG5jb25zdCBhbHBoYSA9ICdhbHBoYSc7XG5jb25zdCBhc2NpaW51bWVyaWMgPSAnYXNjaWludW1lcmljJztcbmNvbnN0IGFscGhhbnVtZXJpYyA9ICdhbHBoYW51bWVyaWMnO1xuY29uc3QgZG9tYWluID0gJ2RvbWFpbic7XG5jb25zdCBlbW9qaSA9ICdlbW9qaSc7XG5jb25zdCBzY2hlbWUgPSAnc2NoZW1lJztcbmNvbnN0IHNsYXNoc2NoZW1lID0gJ3NsYXNoc2NoZW1lJztcbmNvbnN0IHdoaXRlc3BhY2UgPSAnd2hpdGVzcGFjZSc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBncm91cHMgdG8gcmVnaXN0ZXIgaW5cbiAqIEByZXR1cm5zIHtUW119IEN1cnJlbnQgbGlzdCBvZiB0b2tlbnMgaW4gdGhlIGdpdmVuIGNvbGxlY3Rpb25cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJHcm91cChuYW1lLCBncm91cHMpIHtcbiAgaWYgKCEobmFtZSBpbiBncm91cHMpKSB7XG4gICAgZ3JvdXBzW25hbWVdID0gW107XG4gIH1cbiAgcmV0dXJuIGdyb3Vwc1tuYW1lXTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB0IHRva2VuIHRvIGFkZFxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gZ3JvdXBzXG4gKiBAcGFyYW0ge0ZsYWdzfSBmbGFnc1xuICovXG5mdW5jdGlvbiBhZGRUb0dyb3Vwcyh0LCBmbGFncywgZ3JvdXBzKSB7XG4gIGlmIChmbGFnc1tudW1lcmljXSkge1xuICAgIGZsYWdzW2FzY2lpbnVtZXJpY10gPSB0cnVlO1xuICAgIGZsYWdzW2FscGhhbnVtZXJpY10gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thc2NpaV0pIHtcbiAgICBmbGFnc1thc2NpaW51bWVyaWNdID0gdHJ1ZTtcbiAgICBmbGFnc1thbHBoYV0gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thc2NpaW51bWVyaWNdKSB7XG4gICAgZmxhZ3NbYWxwaGFudW1lcmljXSA9IHRydWU7XG4gIH1cbiAgaWYgKGZsYWdzW2FscGhhXSkge1xuICAgIGZsYWdzW2FscGhhbnVtZXJpY10gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thbHBoYW51bWVyaWNdKSB7XG4gICAgZmxhZ3NbZG9tYWluXSA9IHRydWU7XG4gIH1cbiAgaWYgKGZsYWdzW2Vtb2ppXSkge1xuICAgIGZsYWdzW2RvbWFpbl0gPSB0cnVlO1xuICB9XG4gIGZvciAoY29uc3QgayBpbiBmbGFncykge1xuICAgIGNvbnN0IGdyb3VwID0gcmVnaXN0ZXJHcm91cChrLCBncm91cHMpO1xuICAgIGlmIChncm91cC5pbmRleE9mKHQpIDwgMCkge1xuICAgICAgZ3JvdXAucHVzaCh0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB0IHRva2VuIHRvIGNoZWNrXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBncm91cHNcbiAqIEByZXR1cm5zIHtGbGFnc30gZ3JvdXAgZmxhZ3MgdGhhdCBjb250YWluIHRoaXMgdG9rZW5cbiAqL1xuZnVuY3Rpb24gZmxhZ3NGb3JUb2tlbih0LCBncm91cHMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgYyBpbiBncm91cHMpIHtcbiAgICBpZiAoZ3JvdXBzW2NdLmluZGV4T2YodCkgPj0gMCkge1xuICAgICAgcmVzdWx0W2NdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge251bGwgfCBUIH0gVHJhbnNpdGlvblxuICovXG5cbi8qKlxuICogRGVmaW5lIGEgYmFzaWMgc3RhdGUgbWFjaGluZSBzdGF0ZS4gaiBpcyB0aGUgbGlzdCBvZiBjaGFyYWN0ZXIgdHJhbnNpdGlvbnMsXG4gKiBqciBpcyB0aGUgbGlzdCBvZiByZWdleC1tYXRjaCB0cmFuc2l0aW9ucywgamQgaXMgdGhlIGRlZmF1bHQgc3RhdGUgdG9cbiAqIHRyYW5zaXRpb24gdG8gdCBpcyB0aGUgYWNjZXB0aW5nIHRva2VuIHR5cGUsIGlmIGFueS4gSWYgdGhpcyBpcyB0aGUgdGVybWluYWxcbiAqIHN0YXRlLCB0aGVuIGl0IGRvZXMgbm90IGVtaXQgYSB0b2tlbi5cbiAqXG4gKiBUaGUgdGVtcGxhdGUgdHlwZSBUIHJlcHJlc2VudHMgdGhlIHR5cGUgb2YgdGhlIHRva2VuIHRoaXMgc3RhdGUgYWNjZXB0cy4gVGhpc1xuICogc2hvdWxkIGJlIGEgc3RyaW5nIChzdWNoIGFzIG9mIHRoZSB0b2tlbiBleHBvcnRzIGluIGB0ZXh0LmpzYCkgb3IgYVxuICogTXVsdGlUb2tlbiBzdWJjbGFzcyAoZnJvbSBgbXVsdGkuanNgKVxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IFt0b2tlbl0gVG9rZW4gdGhhdCB0aGlzIHN0YXRlIGVtaXRzXG4gKi9cbmZ1bmN0aW9uIFN0YXRlKHRva2VuKSB7XG4gIGlmICh0b2tlbiA9PT0gdm9pZCAwKSB7XG4gICAgdG9rZW4gPSBudWxsO1xuICB9XG4gIC8vIHRoaXMubiA9IG51bGw7IC8vIERFQlVHOiBTdGF0ZSBuYW1lXG4gIC8qKiBAdHlwZSB7eyBbaW5wdXQ6IHN0cmluZ106IFN0YXRlPFQ+IH19IGogKi9cbiAgdGhpcy5qID0ge307IC8vIElNUExFTUVOVEFUSU9OIDFcbiAgLy8gdGhpcy5qID0gW107IC8vIElNUExFTUVOVEFUSU9OIDJcbiAgLyoqIEB0eXBlIHtbUmVnRXhwLCBTdGF0ZTxUPl1bXX0ganIgKi9cbiAgdGhpcy5qciA9IFtdO1xuICAvKiogQHR5cGUgez9TdGF0ZTxUPn0gamQgKi9cbiAgdGhpcy5qZCA9IG51bGw7XG4gIC8qKiBAdHlwZSB7P1R9IHQgKi9cbiAgdGhpcy50ID0gdG9rZW47XG59XG5cbi8qKlxuICogU2Nhbm5lciB0b2tlbiBncm91cHNcbiAqIEB0eXBlIENvbGxlY3Rpb25zPHN0cmluZz5cbiAqL1xuU3RhdGUuZ3JvdXBzID0ge307XG5TdGF0ZS5wcm90b3R5cGUgPSB7XG4gIGFjY2VwdHMoKSB7XG4gICAgcmV0dXJuICEhdGhpcy50O1xuICB9LFxuICAvKipcbiAgICogRm9sbG93IGFuIGV4aXN0aW5nIHRyYW5zaXRpb24gZnJvbSB0aGUgZ2l2ZW4gaW5wdXQgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAqIERvZXMgbm90IG11dGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IGNoYXJhY3RlciBvciB0b2tlbiB0eXBlIHRvIHRyYW5zaXRpb24gb25cbiAgICogQHJldHVybnMgez9TdGF0ZTxUPn0gdGhlIG5leHQgc3RhdGUsIGlmIGFueVxuICAgKi9cbiAgZ28oaW5wdXQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXM7XG4gICAgY29uc3QgbmV4dFN0YXRlID0gc3RhdGUualtpbnB1dF07XG4gICAgaWYgKG5leHRTdGF0ZSkge1xuICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5qci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVnZXggPSBzdGF0ZS5qcltpXVswXTtcbiAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IHN0YXRlLmpyW2ldWzFdOyAvLyBub3RlOiBtaWdodCBiZSBlbXB0eSB0byBwcmV2ZW50IGRlZmF1bHQganVtcFxuICAgICAgaWYgKG5leHRTdGF0ZSAmJiByZWdleC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gbmV4dFN0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3doZXJlIGxlZnQgdG8ganVtcCEgUmV0dXJuIGRlZmF1bHQsIGlmIGFueVxuICAgIHJldHVybiBzdGF0ZS5qZDtcbiAgfSxcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHN0YXRlIGhhcyBhIHRyYW5zaXRpb24gZm9yIHRoZSBnaXZlbiBpbnB1dC4gU2V0IHRoZSBzZWNvbmRcbiAgICogYXJndW1lbnQgdG8gdHJ1ZSB0byBvbmx5IGxvb2sgZm9yIGFuIGV4YWN0IG1hdGNoIChhbmQgbm90IGEgZGVmYXVsdCBvclxuICAgKiByZWd1bGFyLWV4cHJlc3Npb24tYmFzZWQgdHJhbnNpdGlvbilcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXhhY3RPbmx5XG4gICAqL1xuICBoYXMoaW5wdXQsIGV4YWN0T25seSkge1xuICAgIGlmIChleGFjdE9ubHkgPT09IHZvaWQgMCkge1xuICAgICAgZXhhY3RPbmx5ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBleGFjdE9ubHkgPyBpbnB1dCBpbiB0aGlzLmogOiAhIXRoaXMuZ28oaW5wdXQpO1xuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidHJhbnNpdGlvbiBhbGxcIjsgY3JlYXRlIGEgdHJhbnNpdGlvbiBmcm9tIHRoZSBhcnJheSBvZiBpdGVtc1xuICAgKiBpbiB0aGUgZ2l2ZW4gbGlzdCB0byB0aGUgc2FtZSBmaW5hbCByZXN1bHRpbmcgc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGlucHV0cyBHcm91cCBvZiBpbnB1dHMgdG8gdHJhbnNpdGlvbiBvblxuICAgKiBAcGFyYW0ge1RyYW5zaXRpb248VD4gfCBTdGF0ZTxUPn0gW25leHRdIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdIENvbGxlY3Rpb25zIGZsYWdzIHRvIGFkZCB0b2tlbiB0b1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXSBNYXN0ZXIgbGlzdCBvZiB0b2tlbiBncm91cHNcbiAgICovXG4gIHRhKGlucHV0cywgbmV4dCwgZmxhZ3MsIGdyb3Vwcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnR0KGlucHV0c1tpXSwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidGFrZSByZWdleHAgdHJhbnNpdGlvblwiOyBkZWZpbmVzIGEgdHJhbnNpdGlvbiBmb3IgdGhpcyBzdGF0ZVxuICAgKiB3aGVuIGl0IGVuY291bnRlcnMgYSB0b2tlbiB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cCBSZWd1bGFyIGV4cHJlc3Npb24gdHJhbnNpdGlvbiAocG9wdWxhdGUgZmlyc3QpXG4gICAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF0gVHJhbnNpdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc10gQ29sbGVjdGlvbnMgZmxhZ3MgdG8gYWRkIHRva2VuIHRvXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdIE1hc3RlciBsaXN0IG9mIHRva2VuIGdyb3Vwc1xuICAgKiBAcmV0dXJucyB7U3RhdGU8VD59IHRha2VuIGFmdGVyIHRoZSBnaXZlbiBpbnB1dFxuICAgKi9cbiAgdHIocmVnZXhwLCBuZXh0LCBmbGFncywgZ3JvdXBzKSB7XG4gICAgZ3JvdXBzID0gZ3JvdXBzIHx8IFN0YXRlLmdyb3VwcztcbiAgICBsZXQgbmV4dFN0YXRlO1xuICAgIGlmIChuZXh0ICYmIG5leHQuaikge1xuICAgICAgbmV4dFN0YXRlID0gbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9rZW4gd2l0aCBtYXliZSB0b2tlbiBncm91cHNcbiAgICAgIG5leHRTdGF0ZSA9IG5ldyBTdGF0ZShuZXh0KTtcbiAgICAgIGlmIChmbGFncyAmJiBncm91cHMpIHtcbiAgICAgICAgYWRkVG9Hcm91cHMobmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuanIucHVzaChbcmVnZXhwLCBuZXh0U3RhdGVdKTtcbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidGFrZSB0cmFuc2l0aW9uc1wiLCB3aWxsIHRha2UgYXMgbWFueSBzZXF1ZW50aWFsIHRyYW5zaXRpb25zIGFzXG4gICAqIHRoZSBsZW5ndGggb2YgdGhlIGdpdmVuIGlucHV0IGFuZCByZXR1cm5zIHRoZVxuICAgKiByZXN1bHRpbmcgZmluYWwgc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGlucHV0XG4gICAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF0gVHJhbnNpdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc10gQ29sbGVjdGlvbnMgZmxhZ3MgdG8gYWRkIHRva2VuIHRvXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdIE1hc3RlciBsaXN0IG9mIHRva2VuIGdyb3Vwc1xuICAgKiBAcmV0dXJucyB7U3RhdGU8VD59IHRha2VuIGFmdGVyIHRoZSBnaXZlbiBpbnB1dFxuICAgKi9cbiAgdHMoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzO1xuICAgIGNvbnN0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICBpZiAoIWxlbikge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgc3RhdGUgPSBzdGF0ZS50dChpbnB1dFtpXSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS50dChpbnB1dFtsZW4gLSAxXSwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBTaG9ydCBmb3IgXCJ0YWtlIHRyYW5zaXRpb25cIiwgdGhpcyBpcyBhIG1ldGhvZCBmb3IgYnVpbGRpbmcvd29ya2luZyB3aXRoXG4gICAqIHN0YXRlIG1hY2hpbmVzLlxuICAgKlxuICAgKiBJZiBhIHN0YXRlIGFscmVhZHkgZXhpc3RzIGZvciB0aGUgZ2l2ZW4gaW5wdXQsIHJldHVybnMgaXQuXG4gICAqXG4gICAqIElmIGEgdG9rZW4gaXMgc3BlY2lmaWVkLCB0aGF0IHN0YXRlIHdpbGwgZW1pdCB0aGF0IHRva2VuIHdoZW4gcmVhY2hlZCBieVxuICAgKiB0aGUgbGlua2lmeSBlbmdpbmUuXG4gICAqXG4gICAqIElmIG5vIHN0YXRlIGV4aXN0cywgaXQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIHNvbWUgZGVmYXVsdCB0cmFuc2l0aW9uc1xuICAgKiB0aGF0IHJlc2VtYmxlIGV4aXN0aW5nIGRlZmF1bHQgdHJhbnNpdGlvbnMuXG4gICAqXG4gICAqIElmIGEgc3RhdGUgaXMgZ2l2ZW4gZm9yIHRoZSBzZWNvbmQgYXJndW1lbnQsIHRoYXQgc3RhdGUgd2lsbCBiZVxuICAgKiB0cmFuc2l0aW9uZWQgdG8gb24gdGhlIGdpdmVuIGlucHV0IHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGF0IGlucHV0XG4gICAqIHByZXZpb3VzbHkgZGlkLlxuICAgKlxuICAgKiBTcGVjaWZ5IGEgdG9rZW4gZ3JvdXAgZmxhZ3MgdG8gZGVmaW5lIGdyb3VwcyB0aGF0IHRoaXMgdG9rZW4gYmVsb25ncyB0by5cbiAgICogVGhlIHRva2VuIHdpbGwgYmUgYWRkZWQgdG8gY29ycmVzcG9uZGluZyBlbnRpcmVzIGluIHRoZSBnaXZlbiBncm91cHNcbiAgICogb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgY2hhcmFjdGVyLCB0b2tlbiB0eXBlIHRvIHRyYW5zaXRpb24gb25cbiAgICogQHBhcmFtIHtUIHwgU3RhdGU8VD59IFtuZXh0XSBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXSBDb2xsZWN0aW9ucyBmbGFncyB0byBhZGQgdG9rZW4gdG9cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc10gTWFzdGVyIGxpc3Qgb2YgZ3JvdXBzXG4gICAqIEByZXR1cm5zIHtTdGF0ZTxUPn0gdGFrZW4gYWZ0ZXIgdGhlIGdpdmVuIGlucHV0XG4gICAqL1xuICB0dChpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcykge1xuICAgIGdyb3VwcyA9IGdyb3VwcyB8fCBTdGF0ZS5ncm91cHM7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzO1xuXG4gICAgLy8gQ2hlY2sgaWYgZXhpc3Rpbmcgc3RhdGUgZ2l2ZW4sIGp1c3QgYSBiYXNpYyB0cmFuc2l0aW9uXG4gICAgaWYgKG5leHQgJiYgbmV4dC5qKSB7XG4gICAgICBzdGF0ZS5qW2lucHV0XSA9IG5leHQ7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gICAgY29uc3QgdCA9IG5leHQ7XG5cbiAgICAvLyBUYWtlIHRoZSB0cmFuc2l0aW9uIHdpdGggdGhlIHVzdWFsIGRlZmF1bHQgbWVjaGFuaXNtcyBhbmQgdXNlIHRoYXQgYXNcbiAgICAvLyBhIHRlbXBsYXRlIGZvciBjcmVhdGluZyB0aGUgbmV4dCBzdGF0ZVxuICAgIGxldCBuZXh0U3RhdGUsXG4gICAgICB0ZW1wbGF0ZVN0YXRlID0gc3RhdGUuZ28oaW5wdXQpO1xuICAgIGlmICh0ZW1wbGF0ZVN0YXRlKSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICAgIGFzc2lnbihuZXh0U3RhdGUuaiwgdGVtcGxhdGVTdGF0ZS5qKTtcbiAgICAgIG5leHRTdGF0ZS5qci5wdXNoLmFwcGx5KG5leHRTdGF0ZS5qciwgdGVtcGxhdGVTdGF0ZS5qcik7XG4gICAgICBuZXh0U3RhdGUuamQgPSB0ZW1wbGF0ZVN0YXRlLmpkO1xuICAgICAgbmV4dFN0YXRlLnQgPSB0ZW1wbGF0ZVN0YXRlLnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5ldyBTdGF0ZSgpO1xuICAgIH1cbiAgICBpZiAodCkge1xuICAgICAgLy8gRW5zdXJlIG5ld2x5IHRva2VuIGlzIGluIHRoZSBzYW1lIGdyb3VwcyBhcyB0aGUgb2xkIHRva2VuXG4gICAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICAgIGlmIChuZXh0U3RhdGUudCAmJiB0eXBlb2YgbmV4dFN0YXRlLnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3QgYWxsRmxhZ3MgPSBhc3NpZ24oZmxhZ3NGb3JUb2tlbihuZXh0U3RhdGUudCwgZ3JvdXBzKSwgZmxhZ3MpO1xuICAgICAgICAgIGFkZFRvR3JvdXBzKHQsIGFsbEZsYWdzLCBncm91cHMpO1xuICAgICAgICB9IGVsc2UgaWYgKGZsYWdzKSB7XG4gICAgICAgICAgYWRkVG9Hcm91cHModCwgZmxhZ3MsIGdyb3Vwcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRTdGF0ZS50ID0gdDsgLy8gb3ZlcndyaXRlIGFueXRoaW5nIHRoYXQgd2FzIHByZXZpb3VzbHkgdGhlcmVcbiAgICB9XG5cbiAgICBzdGF0ZS5qW2lucHV0XSA9IG5leHRTdGF0ZTtcbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIHRvIGltcHJvdmUgbWluaWZpY2F0aW9uIChub3QgZXhwb3J0ZWQgb3V0c2lkZSBsaW5raWZ5anMgbW9kdWxlKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N0YXRlPFQ+fSBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gaW5wdXRcbiAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc11cbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdXG4gKi9cbmNvbnN0IHRhID0gKHN0YXRlLCBpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3VwcykgPT4gc3RhdGUudGEoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N0YXRlPFQ+fSBzdGF0ZVxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICogQHBhcmFtIHtUIHwgU3RhdGU8VD59IFtuZXh0XVxuICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc11cbiAqL1xuY29uc3QgdHIgPSAoc3RhdGUsIHJlZ2V4cCwgbmV4dCwgZmxhZ3MsIGdyb3VwcykgPT4gc3RhdGUudHIocmVnZXhwLCBuZXh0LCBmbGFncywgZ3JvdXBzKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGlucHV0XG4gKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdXG4gKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXVxuICovXG5jb25zdCB0cyA9IChzdGF0ZSwgaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpID0+IHN0YXRlLnRzKGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHtUIHwgU3RhdGU8VD59IFtuZXh0XVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc11cbiAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc11cbiAqL1xuY29uc3QgdHQgPSAoc3RhdGUsIGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKSA9PiBzdGF0ZS50dChpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblRleHQgVG9rZW5zXG5JZGVudGlmaWVycyBmb3IgdG9rZW4gb3V0cHV0cyBmcm9tIHRoZSByZWdleHAgc2Nhbm5lclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBBIHZhbGlkIHdlYiBkb21haW4gdG9rZW5cbmNvbnN0IFdPUkQgPSAnV09SRCc7IC8vIG9ubHkgY29udGFpbnMgYS16XG5jb25zdCBVV09SRCA9ICdVV09SRCc7IC8vIGNvbnRhaW5zIGxldHRlcnMgb3RoZXIgdGhhbiBhLXosIHVzZWQgZm9yIElETlxuXG4vLyBTcGVjaWFsIGNhc2Ugb2Ygd29yZFxuY29uc3QgTE9DQUxIT1NUID0gJ0xPQ0FMSE9TVCc7XG5cbi8vIFZhbGlkIHRvcC1sZXZlbCBkb21haW4sIHNwZWNpYWwgY2FzZSBvZiBXT1JEIChzZWUgdGxkcy5qcylcbmNvbnN0IFRMRCA9ICdUTEQnO1xuXG4vLyBWYWxpZCBJRE4gVExELCBzcGVjaWFsIGNhc2Ugb2YgVVdPUkQgKHNlZSB0bGRzLmpzKVxuY29uc3QgVVRMRCA9ICdVVExEJztcblxuLy8gVGhlIHNjaGVtZSBwb3J0aW9uIG9mIGEgd2ViIFVSSSBwcm90b2NvbC4gU3VwcG9ydGVkIHR5cGVzIGluY2x1ZGU6IGBtYWlsdG9gLFxuLy8gYGZpbGVgLCBhbmQgdXNlci1kZWZpbmVkIGN1c3RvbSBwcm90b2NvbHMuIExpbWl0ZWQgdG8gc2NoZW1lcyB0aGF0IGNvbnRhaW5cbi8vIG9ubHkgbGV0dGVyc1xuY29uc3QgU0NIRU1FID0gJ1NDSEVNRSc7XG5cbi8vIFNpbWlsYXIgdG8gU0NIRU1FLCBleGNlcHQgbWFrZXMgZGlzdGluY3Rpb24gZm9yIHNjaGVtZXMgdGhhdCBtdXN0IGFsd2F5cyBiZVxuLy8gZm9sbG93ZWQgYnkgYDovL2AsIG5vdCBqdXN0IGA6YC4gU3VwcG9ydGVkIHR5cGVzIGluY2x1ZGUgYGh0dHBgLCBgaHR0cHNgLFxuLy8gYGZ0cGAsIGBmdHBzYFxuY29uc3QgU0xBU0hfU0NIRU1FID0gJ1NMQVNIX1NDSEVNRSc7XG5cbi8vIEFueSBzZXF1ZW5jZSBvZiBkaWdpdHMgMC05XG5jb25zdCBOVU0gPSAnTlVNJztcblxuLy8gQW55IG51bWJlciBvZiBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IG5ld2xpbmVcbmNvbnN0IFdTID0gJ1dTJztcblxuLy8gTmV3IGxpbmUgKHVuaXggc3R5bGUpXG5jb25zdCBOTCQxID0gJ05MJzsgLy8gXFxuXG5cbi8vIE9wZW5pbmcvY2xvc2luZyBicmFja2V0IGNsYXNzZXNcbi8vIFRPRE86IFJlbmFtZSBPUEVOIC0+IExFRlQgYW5kIENMT1NFIC0+IFJJR0hUIGluIHY1IHRvIGZpdCB3aXRoIFVuaWNvZGUgbmFtZXNcbi8vIEFsc28gcmVuYW1lIGFuZ2xlIGJyYWNrZXMgdG8gTEVTU1RIQU4gYW5kIEdSRUFURVIgVEhBTlxuY29uc3QgT1BFTkJSQUNFID0gJ09QRU5CUkFDRSc7IC8vIHtcbmNvbnN0IENMT1NFQlJBQ0UgPSAnQ0xPU0VCUkFDRSc7IC8vIH1cbmNvbnN0IE9QRU5CUkFDS0VUID0gJ09QRU5CUkFDS0VUJzsgLy8gW1xuY29uc3QgQ0xPU0VCUkFDS0VUID0gJ0NMT1NFQlJBQ0tFVCc7IC8vIF1cbmNvbnN0IE9QRU5QQVJFTiA9ICdPUEVOUEFSRU4nOyAvLyAoXG5jb25zdCBDTE9TRVBBUkVOID0gJ0NMT1NFUEFSRU4nOyAvLyApXG5jb25zdCBPUEVOQU5HTEVCUkFDS0VUID0gJ09QRU5BTkdMRUJSQUNLRVQnOyAvLyA8XG5jb25zdCBDTE9TRUFOR0xFQlJBQ0tFVCA9ICdDTE9TRUFOR0xFQlJBQ0tFVCc7IC8vID5cbmNvbnN0IEZVTExXSURUSExFRlRQQVJFTiA9ICdGVUxMV0lEVEhMRUZUUEFSRU4nOyAvLyBcdUZGMDhcbmNvbnN0IEZVTExXSURUSFJJR0hUUEFSRU4gPSAnRlVMTFdJRFRIUklHSFRQQVJFTic7IC8vIFx1RkYwOVxuY29uc3QgTEVGVENPUk5FUkJSQUNLRVQgPSAnTEVGVENPUk5FUkJSQUNLRVQnOyAvLyBcdTMwMENcbmNvbnN0IFJJR0hUQ09STkVSQlJBQ0tFVCA9ICdSSUdIVENPUk5FUkJSQUNLRVQnOyAvLyBcdTMwMERcbmNvbnN0IExFRlRXSElURUNPUk5FUkJSQUNLRVQgPSAnTEVGVFdISVRFQ09STkVSQlJBQ0tFVCc7IC8vIFx1MzAwRVxuY29uc3QgUklHSFRXSElURUNPUk5FUkJSQUNLRVQgPSAnUklHSFRXSElURUNPUk5FUkJSQUNLRVQnOyAvLyBcdTMwMEZcbmNvbnN0IEZVTExXSURUSExFU1NUSEFOID0gJ0ZVTExXSURUSExFU1NUSEFOJzsgLy8gXHVGRjFDXG5jb25zdCBGVUxMV0lEVEhHUkVBVEVSVEhBTiA9ICdGVUxMV0lEVEhHUkVBVEVSVEhBTic7IC8vIFx1RkYxRVxuXG4vLyBWYXJpb3VzIHN5bWJvbHNcbmNvbnN0IEFNUEVSU0FORCA9ICdBTVBFUlNBTkQnOyAvLyAmXG5jb25zdCBBUE9TVFJPUEhFID0gJ0FQT1NUUk9QSEUnOyAvLyAnXG5jb25zdCBBU1RFUklTSyA9ICdBU1RFUklTSyc7IC8vICpcbmNvbnN0IEFUID0gJ0FUJzsgLy8gQFxuY29uc3QgQkFDS1NMQVNIID0gJ0JBQ0tTTEFTSCc7IC8vIFxcXG5jb25zdCBCQUNLVElDSyA9ICdCQUNLVElDSyc7IC8vIGBcbmNvbnN0IENBUkVUID0gJ0NBUkVUJzsgLy8gXlxuY29uc3QgQ09MT04gPSAnQ09MT04nOyAvLyA6XG5jb25zdCBDT01NQSA9ICdDT01NQSc7IC8vICxcbmNvbnN0IERPTExBUiA9ICdET0xMQVInOyAvLyAkXG5jb25zdCBET1QgPSAnRE9UJzsgLy8gLlxuY29uc3QgRVFVQUxTID0gJ0VRVUFMUyc7IC8vID1cbmNvbnN0IEVYQ0xBTUFUSU9OID0gJ0VYQ0xBTUFUSU9OJzsgLy8gIVxuY29uc3QgSFlQSEVOID0gJ0hZUEhFTic7IC8vIC1cbmNvbnN0IFBFUkNFTlQgPSAnUEVSQ0VOVCc7IC8vICVcbmNvbnN0IFBJUEUgPSAnUElQRSc7IC8vIHxcbmNvbnN0IFBMVVMgPSAnUExVUyc7IC8vICtcbmNvbnN0IFBPVU5EID0gJ1BPVU5EJzsgLy8gI1xuY29uc3QgUVVFUlkgPSAnUVVFUlknOyAvLyA/XG5jb25zdCBRVU9URSA9ICdRVU9URSc7IC8vIFwiXG5cbmNvbnN0IFNFTUkgPSAnU0VNSSc7IC8vIDtcbmNvbnN0IFNMQVNIID0gJ1NMQVNIJzsgLy8gL1xuY29uc3QgVElMREUgPSAnVElMREUnOyAvLyB+XG5jb25zdCBVTkRFUlNDT1JFID0gJ1VOREVSU0NPUkUnOyAvLyBfXG5cbi8vIEVtb2ppIHN5bWJvbFxuY29uc3QgRU1PSkkkMSA9ICdFTU9KSSc7XG5cbi8vIERlZmF1bHQgdG9rZW4gLSBhbnl0aGluZyB0aGF0IGlzIG5vdCBvbmUgb2YgdGhlIGFib3ZlXG5jb25zdCBTWU0gPSAnU1lNJztcblxudmFyIHRrID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdFdPUkQ6IFdPUkQsXG5cdFVXT1JEOiBVV09SRCxcblx0TE9DQUxIT1NUOiBMT0NBTEhPU1QsXG5cdFRMRDogVExELFxuXHRVVExEOiBVVExELFxuXHRTQ0hFTUU6IFNDSEVNRSxcblx0U0xBU0hfU0NIRU1FOiBTTEFTSF9TQ0hFTUUsXG5cdE5VTTogTlVNLFxuXHRXUzogV1MsXG5cdE5MOiBOTCQxLFxuXHRPUEVOQlJBQ0U6IE9QRU5CUkFDRSxcblx0Q0xPU0VCUkFDRTogQ0xPU0VCUkFDRSxcblx0T1BFTkJSQUNLRVQ6IE9QRU5CUkFDS0VULFxuXHRDTE9TRUJSQUNLRVQ6IENMT1NFQlJBQ0tFVCxcblx0T1BFTlBBUkVOOiBPUEVOUEFSRU4sXG5cdENMT1NFUEFSRU46IENMT1NFUEFSRU4sXG5cdE9QRU5BTkdMRUJSQUNLRVQ6IE9QRU5BTkdMRUJSQUNLRVQsXG5cdENMT1NFQU5HTEVCUkFDS0VUOiBDTE9TRUFOR0xFQlJBQ0tFVCxcblx0RlVMTFdJRFRITEVGVFBBUkVOOiBGVUxMV0lEVEhMRUZUUEFSRU4sXG5cdEZVTExXSURUSFJJR0hUUEFSRU46IEZVTExXSURUSFJJR0hUUEFSRU4sXG5cdExFRlRDT1JORVJCUkFDS0VUOiBMRUZUQ09STkVSQlJBQ0tFVCxcblx0UklHSFRDT1JORVJCUkFDS0VUOiBSSUdIVENPUk5FUkJSQUNLRVQsXG5cdExFRlRXSElURUNPUk5FUkJSQUNLRVQ6IExFRlRXSElURUNPUk5FUkJSQUNLRVQsXG5cdFJJR0hUV0hJVEVDT1JORVJCUkFDS0VUOiBSSUdIVFdISVRFQ09STkVSQlJBQ0tFVCxcblx0RlVMTFdJRFRITEVTU1RIQU46IEZVTExXSURUSExFU1NUSEFOLFxuXHRGVUxMV0lEVEhHUkVBVEVSVEhBTjogRlVMTFdJRFRIR1JFQVRFUlRIQU4sXG5cdEFNUEVSU0FORDogQU1QRVJTQU5ELFxuXHRBUE9TVFJPUEhFOiBBUE9TVFJPUEhFLFxuXHRBU1RFUklTSzogQVNURVJJU0ssXG5cdEFUOiBBVCxcblx0QkFDS1NMQVNIOiBCQUNLU0xBU0gsXG5cdEJBQ0tUSUNLOiBCQUNLVElDSyxcblx0Q0FSRVQ6IENBUkVULFxuXHRDT0xPTjogQ09MT04sXG5cdENPTU1BOiBDT01NQSxcblx0RE9MTEFSOiBET0xMQVIsXG5cdERPVDogRE9ULFxuXHRFUVVBTFM6IEVRVUFMUyxcblx0RVhDTEFNQVRJT046IEVYQ0xBTUFUSU9OLFxuXHRIWVBIRU46IEhZUEhFTixcblx0UEVSQ0VOVDogUEVSQ0VOVCxcblx0UElQRTogUElQRSxcblx0UExVUzogUExVUyxcblx0UE9VTkQ6IFBPVU5ELFxuXHRRVUVSWTogUVVFUlksXG5cdFFVT1RFOiBRVU9URSxcblx0U0VNSTogU0VNSSxcblx0U0xBU0g6IFNMQVNILFxuXHRUSUxERTogVElMREUsXG5cdFVOREVSU0NPUkU6IFVOREVSU0NPUkUsXG5cdEVNT0pJOiBFTU9KSSQxLFxuXHRTWU06IFNZTVxufSk7XG5cbi8vIE5vdGUgdGhhdCB0aGVzZSB0d28gVW5pY29kZSBvbmVzIGV4cGFuZCBpbnRvIGEgcmVhbGx5IGJpZyBvbmUgd2l0aCBCYWJlbFxuY29uc3QgQVNDSUlfTEVUVEVSID0gL1thLXpdLztcbmNvbnN0IExFVFRFUiA9IC9cXHB7TH0vdTsgLy8gQW55IFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggbGV0dGVyIGRhdGEgdHlwZVxuY29uc3QgRU1PSkkgPSAvXFxwe0Vtb2ppfS91OyAvLyBBbnkgVW5pY29kZSBlbW9qaSBjaGFyYWN0ZXJcbmNvbnN0IEVNT0pJX1ZBUklBVElPTiQxID0gL1xcdWZlMGYvO1xuY29uc3QgRElHSVQgPSAvXFxkLztcbmNvbnN0IFNQQUNFID0gL1xccy87XG5cbnZhciByZWdleHAgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0QVNDSUlfTEVUVEVSOiBBU0NJSV9MRVRURVIsXG5cdExFVFRFUjogTEVUVEVSLFxuXHRFTU9KSTogRU1PSkksXG5cdEVNT0pJX1ZBUklBVElPTjogRU1PSklfVkFSSUFUSU9OJDEsXG5cdERJR0lUOiBESUdJVCxcblx0U1BBQ0U6IFNQQUNFXG59KTtcblxuLyoqXG5cdFRoZSBzY2FubmVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSB0aGF0IHRha2VzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXQsIGFuZFxuXHRvdXRwdXRzIGFuIGFycmF5IG9mIHRva2VucyBpbnN0YW5jZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZWFzeSBVUkwgcGFyc2luZy5cbiovXG5jb25zdCBOTCA9ICdcXG4nOyAvLyBOZXcgbGluZSBjaGFyYWN0ZXJcbmNvbnN0IEVNT0pJX1ZBUklBVElPTiA9ICdcXHVmZTBmJzsgLy8gVmFyaWF0aW9uIHNlbGVjdG9yLCBmb2xsb3dzIGhlYXJ0IGFuZCBvdGhlcnNcbmNvbnN0IEVNT0pJX0pPSU5FUiA9ICdcXHUyMDBkJzsgLy8gemVyby13aWR0aCBqb2luZXJcblxubGV0IHRsZHMgPSBudWxsLFxuICB1dGxkcyA9IG51bGw7IC8vIGRvbid0IGNoYW5nZSBzbyBvbmx5IGhhdmUgdG8gYmUgY29tcHV0ZWQgb25jZVxuXG4vKipcbiAqIFNjYW5uZXIgb3V0cHV0IHRva2VuOlxuICogLSBgdGAgaXMgdGhlIHRva2VuIG5hbWUgKGUuZy4sICdOVU0nLCAnRU1PSkknLCAnVExEJylcbiAqIC0gYHZgIGlzIHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gKGUuZy4sICcxMjMnLCAnXHUyNzY0XHVGRTBGJywgJ2NvbScpXG4gKiAtIGBzYCBpcyB0aGUgc3RhcnQgaW5kZXggb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAqIC0gYGVgIGlzIHRoZSBlbmQgaW5kZXggb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAqIEB0eXBlZGVmIHt7dDogc3RyaW5nLCB2OiBzdHJpbmcsIHM6IG51bWJlciwgZTogbnVtYmVyfX0gVG9rZW5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7eyBbY29sbGVjdGlvbjogc3RyaW5nXTogVFtdIH19IENvbGxlY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBzY2FubmVyIGNoYXJhY3Rlci1iYXNlZCBzdGF0ZSBtYWNoaW5lIGZvciB0aGUgZ2l2ZW4gc3RhcnRcbiAqIHN0YXRlXG4gKiBAcGFyYW0ge1tzdHJpbmcsIGJvb2xlYW5dW119IGN1c3RvbVNjaGVtZXMgTGlzdCBvZiBjdXN0b20gc2NoZW1lcywgd2hlcmUgZWFjaFxuICogaXRlbSBpcyBhIGxlbmd0aC0yIHR1cGxlIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgc2V0IHRvIHRoZSBzdHJpbmcgc2NoZW1lLCBhbmRcbiAqIHRoZSBzZWNvbmQgZWxlbWVudCBzZXQgdG8gYHRydWVgIGlmIHRoZSBgOi8vYCBhZnRlciB0aGUgc2NoZW1lIGlzIG9wdGlvbmFsXG4gKi9cbmZ1bmN0aW9uIGluaXQkMihjdXN0b21TY2hlbWVzKSB7XG4gIGlmIChjdXN0b21TY2hlbWVzID09PSB2b2lkIDApIHtcbiAgICBjdXN0b21TY2hlbWVzID0gW107XG4gIH1cbiAgLy8gRnJlcXVlbnRseSB1c2VkIHN0YXRlcyAobmFtZSBhcmd1bWVudCByZW1vdmVkIGR1cmluZyBtaW5pZmljYXRpb24pXG4gIC8qKiBAdHlwZSBDb2xsZWN0aW9uczxzdHJpbmc+ICovXG4gIGNvbnN0IGdyb3VwcyA9IHt9OyAvLyBvZiB0b2tlbnNcbiAgU3RhdGUuZ3JvdXBzID0gZ3JvdXBzO1xuICAvKiogQHR5cGUgU3RhdGU8c3RyaW5nPiAqL1xuICBjb25zdCBTdGFydCA9IG5ldyBTdGF0ZSgpO1xuICBpZiAodGxkcyA9PSBudWxsKSB7XG4gICAgdGxkcyA9IGRlY29kZVRsZHMoZW5jb2RlZFRsZHMpO1xuICB9XG4gIGlmICh1dGxkcyA9PSBudWxsKSB7XG4gICAgdXRsZHMgPSBkZWNvZGVUbGRzKGVuY29kZWRVdGxkcyk7XG4gIH1cblxuICAvLyBTdGF0ZXMgZm9yIHNwZWNpYWwgVVJMIHN5bWJvbHMgdGhhdCBhY2NlcHQgaW1tZWRpYXRlbHkgYWZ0ZXIgc3RhcnRcbiAgdHQoU3RhcnQsIFwiJ1wiLCBBUE9TVFJPUEhFKTtcbiAgdHQoU3RhcnQsICd7JywgT1BFTkJSQUNFKTtcbiAgdHQoU3RhcnQsICd9JywgQ0xPU0VCUkFDRSk7XG4gIHR0KFN0YXJ0LCAnWycsIE9QRU5CUkFDS0VUKTtcbiAgdHQoU3RhcnQsICddJywgQ0xPU0VCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICcoJywgT1BFTlBBUkVOKTtcbiAgdHQoU3RhcnQsICcpJywgQ0xPU0VQQVJFTik7XG4gIHR0KFN0YXJ0LCAnPCcsIE9QRU5BTkdMRUJSQUNLRVQpO1xuICB0dChTdGFydCwgJz4nLCBDTE9TRUFOR0xFQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnXHVGRjA4JywgRlVMTFdJRFRITEVGVFBBUkVOKTtcbiAgdHQoU3RhcnQsICdcdUZGMDknLCBGVUxMV0lEVEhSSUdIVFBBUkVOKTtcbiAgdHQoU3RhcnQsICdcdTMwMEMnLCBMRUZUQ09STkVSQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnXHUzMDBEJywgUklHSFRDT1JORVJCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICdcdTMwMEUnLCBMRUZUV0hJVEVDT1JORVJCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICdcdTMwMEYnLCBSSUdIVFdISVRFQ09STkVSQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnXHVGRjFDJywgRlVMTFdJRFRITEVTU1RIQU4pO1xuICB0dChTdGFydCwgJ1x1RkYxRScsIEZVTExXSURUSEdSRUFURVJUSEFOKTtcbiAgdHQoU3RhcnQsICcmJywgQU1QRVJTQU5EKTtcbiAgdHQoU3RhcnQsICcqJywgQVNURVJJU0spO1xuICB0dChTdGFydCwgJ0AnLCBBVCk7XG4gIHR0KFN0YXJ0LCAnYCcsIEJBQ0tUSUNLKTtcbiAgdHQoU3RhcnQsICdeJywgQ0FSRVQpO1xuICB0dChTdGFydCwgJzonLCBDT0xPTik7XG4gIHR0KFN0YXJ0LCAnLCcsIENPTU1BKTtcbiAgdHQoU3RhcnQsICckJywgRE9MTEFSKTtcbiAgdHQoU3RhcnQsICcuJywgRE9UKTtcbiAgdHQoU3RhcnQsICc9JywgRVFVQUxTKTtcbiAgdHQoU3RhcnQsICchJywgRVhDTEFNQVRJT04pO1xuICB0dChTdGFydCwgJy0nLCBIWVBIRU4pO1xuICB0dChTdGFydCwgJyUnLCBQRVJDRU5UKTtcbiAgdHQoU3RhcnQsICd8JywgUElQRSk7XG4gIHR0KFN0YXJ0LCAnKycsIFBMVVMpO1xuICB0dChTdGFydCwgJyMnLCBQT1VORCk7XG4gIHR0KFN0YXJ0LCAnPycsIFFVRVJZKTtcbiAgdHQoU3RhcnQsICdcIicsIFFVT1RFKTtcbiAgdHQoU3RhcnQsICcvJywgU0xBU0gpO1xuICB0dChTdGFydCwgJzsnLCBTRU1JKTtcbiAgdHQoU3RhcnQsICd+JywgVElMREUpO1xuICB0dChTdGFydCwgJ18nLCBVTkRFUlNDT1JFKTtcbiAgdHQoU3RhcnQsICdcXFxcJywgQkFDS1NMQVNIKTtcbiAgY29uc3QgTnVtID0gdHIoU3RhcnQsIERJR0lULCBOVU0sIHtcbiAgICBbbnVtZXJpY106IHRydWVcbiAgfSk7XG4gIHRyKE51bSwgRElHSVQsIE51bSk7XG5cbiAgLy8gU3RhdGUgd2hpY2ggZW1pdHMgYSB3b3JkIHRva2VuXG4gIGNvbnN0IFdvcmQgPSB0cihTdGFydCwgQVNDSUlfTEVUVEVSLCBXT1JELCB7XG4gICAgW2FzY2lpXTogdHJ1ZVxuICB9KTtcbiAgdHIoV29yZCwgQVNDSUlfTEVUVEVSLCBXb3JkKTtcblxuICAvLyBTYW1lIGFzIHByZXZpb3VzLCBidXQgc3BlY2lmaWMgdG8gbm9uLWZzbS5hc2NpaSBhbHBoYWJldCB3b3Jkc1xuICBjb25zdCBVV29yZCA9IHRyKFN0YXJ0LCBMRVRURVIsIFVXT1JELCB7XG4gICAgW2FscGhhXTogdHJ1ZVxuICB9KTtcbiAgdHIoVVdvcmQsIEFTQ0lJX0xFVFRFUik7IC8vIE5vbi1hY2NlcHRpbmdcbiAgdHIoVVdvcmQsIExFVFRFUiwgVVdvcmQpO1xuXG4gIC8vIFdoaXRlc3BhY2UganVtcHNcbiAgLy8gVG9rZW5zIG9mIG9ubHkgbm9uLW5ld2xpbmUgd2hpdGVzcGFjZSBhcmUgYXJiaXRyYXJpbHkgbG9uZ1xuICAvLyBJZiBhbnkgd2hpdGVzcGFjZSBleGNlcHQgbmV3bGluZSwgbW9yZSB3aGl0ZXNwYWNlIVxuICBjb25zdCBXcyA9IHRyKFN0YXJ0LCBTUEFDRSwgV1MsIHtcbiAgICBbd2hpdGVzcGFjZV06IHRydWVcbiAgfSk7XG4gIHR0KFN0YXJ0LCBOTCwgTkwkMSwge1xuICAgIFt3aGl0ZXNwYWNlXTogdHJ1ZVxuICB9KTtcbiAgdHQoV3MsIE5MKTsgLy8gbm9uLWFjY2VwdGluZyBzdGF0ZSB0byBhdm9pZCBtaXhpbmcgd2hpdGVzcGFjZXNcbiAgdHIoV3MsIFNQQUNFLCBXcyk7XG5cbiAgLy8gRW1vamkgdG9rZW5zLiBUaGV5IGFyZSBub3QgZ3JvdXBlZCBieSB0aGUgc2Nhbm5lciBleGNlcHQgaW4gY2FzZXMgd2hlcmUgYVxuICAvLyB6ZXJvLXdpZHRoIGpvaW5lciBpcyBwcmVzZW50XG4gIGNvbnN0IEVtb2ppID0gdHIoU3RhcnQsIEVNT0pJLCBFTU9KSSQxLCB7XG4gICAgW2Vtb2ppXTogdHJ1ZVxuICB9KTtcbiAgdHIoRW1vamksIEVNT0pJLCBFbW9qaSk7XG4gIHR0KEVtb2ppLCBFTU9KSV9WQVJJQVRJT04sIEVtb2ppKTtcbiAgLy8gdHQoU3RhcnQsIEVNT0pJX1ZBUklBVElPTiwgRW1vamkpOyAvLyBUaGlzIG9uZSBpcyBza2V0Y2h5XG5cbiAgY29uc3QgRW1vamlKb2luZXIgPSB0dChFbW9qaSwgRU1PSklfSk9JTkVSKTtcbiAgdHIoRW1vamlKb2luZXIsIEVNT0pJLCBFbW9qaSk7XG4gIC8vIHR0KEVtb2ppSm9pbmVyLCBFTU9KSV9WQVJJQVRJT04sIEVtb2ppKTsgLy8gYWxzbyBza2V0Y2h5XG5cbiAgLy8gR2VuZXJhdGVzIHN0YXRlcyBmb3IgdG9wLWxldmVsIGRvbWFpbnNcbiAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgbW9zdCBhY2N1cmF0ZSB3aGVuIHRsZHMgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICBjb25zdCB3b3JkanIgPSBbW0FTQ0lJX0xFVFRFUiwgV29yZF1dO1xuICBjb25zdCB1d29yZGpyID0gW1tBU0NJSV9MRVRURVIsIG51bGxdLCBbTEVUVEVSLCBVV29yZF1dO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRsZHMubGVuZ3RoOyBpKyspIHtcbiAgICBmYXN0dHMoU3RhcnQsIHRsZHNbaV0sIFRMRCwgV09SRCwgd29yZGpyKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHV0bGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZmFzdHRzKFN0YXJ0LCB1dGxkc1tpXSwgVVRMRCwgVVdPUkQsIHV3b3JkanIpO1xuICB9XG4gIGFkZFRvR3JvdXBzKFRMRCwge1xuICAgIHRsZDogdHJ1ZSxcbiAgICBhc2NpaTogdHJ1ZVxuICB9LCBncm91cHMpO1xuICBhZGRUb0dyb3VwcyhVVExELCB7XG4gICAgdXRsZDogdHJ1ZSxcbiAgICBhbHBoYTogdHJ1ZVxuICB9LCBncm91cHMpO1xuXG4gIC8vIENvbGxlY3QgdGhlIHN0YXRlcyBnZW5lcmF0ZWQgYnkgZGlmZmVyZW50IHByb3RvY29scy4gTk9URTogSWYgYW55IG5ldyBUTERzXG4gIC8vIGdldCBhZGRlZCB0aGF0IGFyZSBhbHNvIHByb3RvY29scywgc2V0IHRoZSB0b2tlbiB0byBiZSB0aGUgc2FtZSBhcyB0aGVcbiAgLy8gcHJvdG9jb2wgdG8gZW5zdXJlIHBhcnNpbmcgd29ya3MgYXMgZXhwZWN0ZWQuXG4gIGZhc3R0cyhTdGFydCwgJ2ZpbGUnLCBTQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ21haWx0bycsIFNDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgZmFzdHRzKFN0YXJ0LCAnaHR0cCcsIFNMQVNIX1NDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgZmFzdHRzKFN0YXJ0LCAnaHR0cHMnLCBTTEFTSF9TQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ2Z0cCcsIFNMQVNIX1NDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgZmFzdHRzKFN0YXJ0LCAnZnRwcycsIFNMQVNIX1NDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgYWRkVG9Hcm91cHMoU0NIRU1FLCB7XG4gICAgc2NoZW1lOiB0cnVlLFxuICAgIGFzY2lpOiB0cnVlXG4gIH0sIGdyb3Vwcyk7XG4gIGFkZFRvR3JvdXBzKFNMQVNIX1NDSEVNRSwge1xuICAgIHNsYXNoc2NoZW1lOiB0cnVlLFxuICAgIGFzY2lpOiB0cnVlXG4gIH0sIGdyb3Vwcyk7XG5cbiAgLy8gUmVnaXN0ZXIgY3VzdG9tIHNjaGVtZXMuIEFzc3VtZXMgZWFjaCBzY2hlbWUgaXMgYXNjaWludW1lcmljIHdpdGggaHlwaGVuc1xuICBjdXN0b21TY2hlbWVzID0gY3VzdG9tU2NoZW1lcy5zb3J0KChhLCBiKSA9PiBhWzBdID4gYlswXSA/IDEgOiAtMSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY3VzdG9tU2NoZW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNjaCA9IGN1c3RvbVNjaGVtZXNbaV1bMF07XG4gICAgY29uc3Qgb3B0aW9uYWxTbGFzaFNsYXNoID0gY3VzdG9tU2NoZW1lc1tpXVsxXTtcbiAgICBjb25zdCBmbGFncyA9IG9wdGlvbmFsU2xhc2hTbGFzaCA/IHtcbiAgICAgIFtzY2hlbWVdOiB0cnVlXG4gICAgfSA6IHtcbiAgICAgIFtzbGFzaHNjaGVtZV06IHRydWVcbiAgICB9O1xuICAgIGlmIChzY2guaW5kZXhPZignLScpID49IDApIHtcbiAgICAgIGZsYWdzW2RvbWFpbl0gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIUFTQ0lJX0xFVFRFUi50ZXN0KHNjaCkpIHtcbiAgICAgIGZsYWdzW251bWVyaWNdID0gdHJ1ZTsgLy8gbnVtYmVycyBvbmx5XG4gICAgfSBlbHNlIGlmIChESUdJVC50ZXN0KHNjaCkpIHtcbiAgICAgIGZsYWdzW2FzY2lpbnVtZXJpY10gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGFnc1thc2NpaV0gPSB0cnVlO1xuICAgIH1cbiAgICB0cyhTdGFydCwgc2NoLCBzY2gsIGZsYWdzKTtcbiAgfVxuXG4gIC8vIExvY2FsaG9zdCB0b2tlblxuICB0cyhTdGFydCwgJ2xvY2FsaG9zdCcsIExPQ0FMSE9TVCwge1xuICAgIGFzY2lpOiB0cnVlXG4gIH0pO1xuXG4gIC8vIFNldCBkZWZhdWx0IHRyYW5zaXRpb24gZm9yIHN0YXJ0IHN0YXRlIChzb21lIHN5bWJvbClcbiAgU3RhcnQuamQgPSBuZXcgU3RhdGUoU1lNKTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogU3RhcnQsXG4gICAgdG9rZW5zOiBhc3NpZ24oe1xuICAgICAgZ3JvdXBzXG4gICAgfSwgdGspXG4gIH07XG59XG5cbi8qKlxuXHRHaXZlbiBhIHN0cmluZywgcmV0dXJucyBhbiBhcnJheSBvZiBUT0tFTiBpbnN0YW5jZXMgcmVwcmVzZW50aW5nIHRoZVxuXHRjb21wb3NpdGlvbiBvZiB0aGF0IHN0cmluZy5cblxuXHRAbWV0aG9kIHJ1blxuXHRAcGFyYW0ge1N0YXRlPHN0cmluZz59IHN0YXJ0IHNjYW5uZXIgc3RhcnRpbmcgc3RhdGVcblx0QHBhcmFtIHtzdHJpbmd9IHN0ciBpbnB1dCBzdHJpbmcgdG8gc2NhblxuXHRAcmV0dXJuIHtUb2tlbltdfSBsaXN0IG9mIHRva2VucywgZWFjaCB3aXRoIGEgdHlwZSBhbmQgdmFsdWVcbiovXG5mdW5jdGlvbiBydW4kMShzdGFydCwgc3RyKSB7XG4gIC8vIFN0YXRlIG1hY2hpbmUgaXMgbm90IGNhc2Ugc2Vuc2l0aXZlLCBzbyBpbnB1dCBpcyB0b2tlbml6ZWQgaW4gbG93ZXJjYXNlZFxuICAvLyBmb3JtIChzdGlsbCByZXR1cm5zIHJlZ3VsYXIgY2FzZSkuIFVzZXMgc2VsZWN0aXZlIGB0b0xvd2VyQ2FzZWAgYmVjYXVzZVxuICAvLyBsb3dlcmNhc2luZyB0aGUgZW50aXJlIHN0cmluZyBjYXVzZXMgdGhlIGxlbmd0aCBhbmQgY2hhcmFjdGVyIHBvc2l0aW9uIHRvXG4gIC8vIHZhcnkgaW4gc29tZSBub24tRW5nbGlzaCBzdHJpbmdzIHdpdGggVjgtYmFzZWQgcnVudGltZXMuXG4gIGNvbnN0IGl0ZXJhYmxlID0gc3RyaW5nVG9BcnJheShzdHIucmVwbGFjZSgvW0EtWl0vZywgYyA9PiBjLnRvTG93ZXJDYXNlKCkpKTtcbiAgY29uc3QgY2hhckNvdW50ID0gaXRlcmFibGUubGVuZ3RoOyAvLyA8PSBsZW4gaWYgdGhlcmUgYXJlIGVtb2ppcywgZXRjXG4gIGNvbnN0IHRva2VucyA9IFtdOyAvLyByZXR1cm4gdmFsdWVcblxuICAvLyBjdXJzb3IgdGhyb3VnaCB0aGUgc3RyaW5nIGl0c2VsZiwgYWNjb3VudGluZyBmb3IgY2hhcmFjdGVycyB0aGF0IGhhdmVcbiAgLy8gd2lkdGggd2l0aCBsZW5ndGggMiBzdWNoIGFzIGVtb2ppc1xuICBsZXQgY3Vyc29yID0gMDtcblxuICAvLyBDdXJzb3IgdGhyb3VnaCB0aGUgYXJyYXktcmVwcmVzZW50YXRpb24gb2YgdGhlIHN0cmluZ1xuICBsZXQgY2hhckN1cnNvciA9IDA7XG5cbiAgLy8gVG9rZW5pemUgdGhlIHN0cmluZ1xuICB3aGlsZSAoY2hhckN1cnNvciA8IGNoYXJDb3VudCkge1xuICAgIGxldCBzdGF0ZSA9IHN0YXJ0O1xuICAgIGxldCBuZXh0U3RhdGUgPSBudWxsO1xuICAgIGxldCB0b2tlbkxlbmd0aCA9IDA7XG4gICAgbGV0IGxhdGVzdEFjY2VwdGluZyA9IG51bGw7XG4gICAgbGV0IHNpbmNlQWNjZXB0cyA9IC0xO1xuICAgIGxldCBjaGFyc1NpbmNlQWNjZXB0cyA9IC0xO1xuICAgIHdoaWxlIChjaGFyQ3Vyc29yIDwgY2hhckNvdW50ICYmIChuZXh0U3RhdGUgPSBzdGF0ZS5nbyhpdGVyYWJsZVtjaGFyQ3Vyc29yXSkpKSB7XG4gICAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGF0ZXN0IGFjY2VwdGluZyBzdGF0ZVxuICAgICAgaWYgKHN0YXRlLmFjY2VwdHMoKSkge1xuICAgICAgICBzaW5jZUFjY2VwdHMgPSAwO1xuICAgICAgICBjaGFyc1NpbmNlQWNjZXB0cyA9IDA7XG4gICAgICAgIGxhdGVzdEFjY2VwdGluZyA9IHN0YXRlO1xuICAgICAgfSBlbHNlIGlmIChzaW5jZUFjY2VwdHMgPj0gMCkge1xuICAgICAgICBzaW5jZUFjY2VwdHMgKz0gaXRlcmFibGVbY2hhckN1cnNvcl0ubGVuZ3RoO1xuICAgICAgICBjaGFyc1NpbmNlQWNjZXB0cysrO1xuICAgICAgfVxuICAgICAgdG9rZW5MZW5ndGggKz0gaXRlcmFibGVbY2hhckN1cnNvcl0ubGVuZ3RoO1xuICAgICAgY3Vyc29yICs9IGl0ZXJhYmxlW2NoYXJDdXJzb3JdLmxlbmd0aDtcbiAgICAgIGNoYXJDdXJzb3IrKztcbiAgICB9XG5cbiAgICAvLyBSb2xsIGJhY2sgdG8gdGhlIGxhdGVzdCBhY2NlcHRpbmcgc3RhdGVcbiAgICBjdXJzb3IgLT0gc2luY2VBY2NlcHRzO1xuICAgIGNoYXJDdXJzb3IgLT0gY2hhcnNTaW5jZUFjY2VwdHM7XG4gICAgdG9rZW5MZW5ndGggLT0gc2luY2VBY2NlcHRzO1xuXG4gICAgLy8gTm8gbW9yZSBqdW1wcywganVzdCBtYWtlIGEgbmV3IHRva2VuIGZyb20gdGhlIGxhc3QgYWNjZXB0aW5nIG9uZVxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIHQ6IGxhdGVzdEFjY2VwdGluZy50LFxuICAgICAgLy8gdG9rZW4gdHlwZS9uYW1lXG4gICAgICB2OiBzdHIuc2xpY2UoY3Vyc29yIC0gdG9rZW5MZW5ndGgsIGN1cnNvciksXG4gICAgICAvLyBzdHJpbmcgdmFsdWVcbiAgICAgIHM6IGN1cnNvciAtIHRva2VuTGVuZ3RoLFxuICAgICAgLy8gc3RhcnQgaW5kZXhcbiAgICAgIGU6IGN1cnNvciAvLyBlbmQgaW5kZXggKGV4Y2x1ZGluZylcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbi8qKlxuICogQ29udmVydCBhIFN0cmluZyB0byBhbiBBcnJheSBvZiBjaGFyYWN0ZXJzLCB0YWtpbmcgaW50byBhY2NvdW50IHRoYXQgc29tZVxuICogY2hhcmFjdGVycyBsaWtlIGVtb2ppcyB0YWtlIHVwIHR3byBzdHJpbmcgaW5kZXhlcy5cbiAqXG4gKiBBZGFwdGVkIGZyb20gY29yZS1qcyAoTUlUIGxpY2Vuc2UpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iLzJkNjljZjVmOTlhYjNlYTM0NjNjMzk1ZGY4MWU1YTE1YjY4ZjQ5ZDkvcGFja2FnZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qc1xuICpcbiAqIEBmdW5jdGlvbiBzdHJpbmdUb0FycmF5XG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICBsZXQgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBsZW4pIHtcbiAgICBsZXQgZmlyc3QgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgbGV0IHNlY29uZDtcbiAgICBsZXQgY2hhciA9IGZpcnN0IDwgMHhkODAwIHx8IGZpcnN0ID4gMHhkYmZmIHx8IGluZGV4ICsgMSA9PT0gbGVuIHx8IChzZWNvbmQgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpKSA8IDB4ZGMwMCB8fCBzZWNvbmQgPiAweGRmZmYgPyBzdHJbaW5kZXhdIC8vIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICA6IHN0ci5zbGljZShpbmRleCwgaW5kZXggKyAyKTsgLy8gdHdvLWluZGV4IGNoYXJhY3RlcnNcbiAgICByZXN1bHQucHVzaChjaGFyKTtcbiAgICBpbmRleCArPSBjaGFyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEZhc3QgdmVyc2lvbiBvZiB0cyBmdW5jdGlvbiBmb3Igd2hlbiB0cmFuc2l0aW9uIGRlZmF1bHRzIGFyZSB3ZWxsIGtub3duXG4gKiBAcGFyYW0ge1N0YXRlPHN0cmluZz59IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0XG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdHRcbiAqIEBwYXJhbSB7W1JlZ0V4cCwgU3RhdGU8c3RyaW5nPl1bXX0ganJcbiAqIEByZXR1cm5zIHtTdGF0ZTxzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBmYXN0dHMoc3RhdGUsIGlucHV0LCB0LCBkZWZhdWx0dCwganIpIHtcbiAgbGV0IG5leHQ7XG4gIGNvbnN0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgaWYgKHN0YXRlLmpbY2hhcl0pIHtcbiAgICAgIG5leHQgPSBzdGF0ZS5qW2NoYXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0ID0gbmV3IFN0YXRlKGRlZmF1bHR0KTtcbiAgICAgIG5leHQuanIgPSBqci5zbGljZSgpO1xuICAgICAgc3RhdGUualtjaGFyXSA9IG5leHQ7XG4gICAgfVxuICAgIHN0YXRlID0gbmV4dDtcbiAgfVxuICBuZXh0ID0gbmV3IFN0YXRlKHQpO1xuICBuZXh0LmpyID0ganIuc2xpY2UoKTtcbiAgc3RhdGUualtpbnB1dFtsZW4gLSAxXV0gPSBuZXh0O1xuICByZXR1cm4gbmV4dDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBUb3AtTGV2ZWwgRG9tYWluIG5hbWVzIGVuY29kZWQgaW4gdXBkYXRlLXRsZHMuanMgYmFja1xuICogaW50byBhIGxpc3Qgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSB7c3RyfSBlbmNvZGVkIGVuY29kZWQgVExEcyBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJbXX0gb3JpZ2luYWwgVExEcyBsaXN0XG4gKi9cbmZ1bmN0aW9uIGRlY29kZVRsZHMoZW5jb2RlZCkge1xuICBjb25zdCB3b3JkcyA9IFtdO1xuICBjb25zdCBzdGFjayA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIGxldCBkaWdpdHMgPSAnMDEyMzQ1Njc4OSc7XG4gIHdoaWxlIChpIDwgZW5jb2RlZC5sZW5ndGgpIHtcbiAgICBsZXQgcG9wRGlnaXRDb3VudCA9IDA7XG4gICAgd2hpbGUgKGRpZ2l0cy5pbmRleE9mKGVuY29kZWRbaSArIHBvcERpZ2l0Q291bnRdKSA+PSAwKSB7XG4gICAgICBwb3BEaWdpdENvdW50Kys7IC8vIGVuY291bnRlcmVkIHNvbWUgZGlnaXRzLCBoYXZlIHRvIHBvcCB0byBnbyBvbmUgbGV2ZWwgdXAgdHJpZVxuICAgIH1cblxuICAgIGlmIChwb3BEaWdpdENvdW50ID4gMCkge1xuICAgICAgd29yZHMucHVzaChzdGFjay5qb2luKCcnKSk7IC8vIHdoYXRldmVyIHByZWNlZGVkIHRoZSBwb3AgZGlnaXRzIG11c3QgYmUgYSB3b3JkXG4gICAgICBmb3IgKGxldCBwb3BDb3VudCA9IHBhcnNlSW50KGVuY29kZWQuc3Vic3RyaW5nKGksIGkgKyBwb3BEaWdpdENvdW50KSwgMTApOyBwb3BDb3VudCA+IDA7IHBvcENvdW50LS0pIHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICB9XG4gICAgICBpICs9IHBvcERpZ2l0Q291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrLnB1c2goZW5jb2RlZFtpXSk7IC8vIGRyb3AgZG93biBhIGxldmVsIGludG8gdGhlIHRyaWVcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHdvcmRzO1xufVxuXG4vKipcbiAqIEFuIG9iamVjdCB3aGVyZSBlYWNoIGtleSBpcyBhIHZhbGlkIERPTSBFdmVudCBOYW1lIHN1Y2ggYXMgYGNsaWNrYCBvciBgZm9jdXNgXG4gKiBhbmQgZWFjaCB2YWx1ZSBpcyBhbiBldmVudCBoYW5kbGVyIGZ1bmN0aW9uLlxuICpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50I2V2ZW50c1xuICogQHR5cGVkZWYgez97IFtldmVudDogc3RyaW5nXTogRnVuY3Rpb24gfX0gRXZlbnRMaXN0ZW5lcnNcbiAqL1xuXG4vKipcbiAqIEFsbCBmb3JtYXR0ZWQgcHJvcGVydGllcyByZXF1aXJlZCB0byByZW5kZXIgYSBsaW5rLCBpbmNsdWRpbmcgYHRhZ05hbWVgLFxuICogYGF0dHJpYnV0ZXNgLCBgY29udGVudGAgYW5kIGBldmVudExpc3RlbmVyc2AuXG4gKiBAdHlwZWRlZiB7eyB0YWdOYW1lOiBhbnksIGF0dHJpYnV0ZXM6IHtbYXR0cjogc3RyaW5nXTogYW55fSwgY29udGVudDogc3RyaW5nLFxuICogZXZlbnRMaXN0ZW5lcnM6IEV2ZW50TGlzdGVuZXJzIH19IEludGVybWVkaWF0ZVJlcHJlc2VudGF0aW9uXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZ5IGVpdGhlciBhbiBvYmplY3QgZGVzY3JpYmVkIGJ5IHRoZSB0ZW1wbGF0ZSB0eXBlIGBPYCBvciBhIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBmdW5jdGlvbiB0YWtlcyBhIHN0cmluZyB2YWx1ZSAodXN1YWxseSB0aGUgbGluaydzIGhyZWYgYXR0cmlidXRlKSwgdGhlXG4gKiBsaW5rIHR5cGUgKGAndXJsJ2AsIGAnaGFzaHRhZ2AnLCBldGMuKSBhbmQgYW4gaW50ZXJuYWwgdG9rZW4gcmVwcmVzZW50YXRpb25cbiAqIG9mIHRoZSBsaW5rLiBJdCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBvZiB0aGUgdGVtcGxhdGUgdHlwZSBgT2BcbiAqIEB0ZW1wbGF0ZSBPXG4gKiBAdHlwZWRlZiB7TyB8ICgodmFsdWU6IHN0cmluZywgdHlwZTogc3RyaW5nLCB0b2tlbjogTXVsdGlUb2tlbikgPT4gTyl9IE9wdE9ialxuICovXG5cbi8qKlxuICogU3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiBkZXNjcmliZWQgYnkgdGVtcGxhdGUgdHlwZSBgRmAgb3IgYW4gb2JqZWN0LlxuICpcbiAqIEVhY2gga2V5IGluIHRoZSBvYmplY3Qgc2hvdWxkIGJlIGEgbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikuIEVhY2hcbiAqIHZhbHVlIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHdpdGggdGVtcGxhdGUgdHlwZSBgRmAgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgbGluayB0eXBlIGlzIGVuY291bnRlcmVkLlxuICogQHRlbXBsYXRlIEZcbiAqIEB0eXBlZGVmIHtGIHwgeyBbdHlwZTogc3RyaW5nXTogRn19IE9wdEZuXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZ5IGVpdGhlciBhIHZhbHVlIHdpdGggdGVtcGxhdGUgdHlwZSBgVmAsIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGBWYCBvclxuICogYW4gb2JqZWN0IHdoZXJlIGVhY2ggdmFsdWUgcmVzb2x2ZXMgdG8gYFZgLlxuICpcbiAqIFRoZSBmdW5jdGlvbiB0YWtlcyBhIHN0cmluZyB2YWx1ZSAodXN1YWxseSB0aGUgbGluaydzIGhyZWYgYXR0cmlidXRlKSwgdGhlXG4gKiBsaW5rIHR5cGUgKGAndXJsJ2AsIGAnaGFzaHRhZ2AnLCBldGMuKSBhbmQgYW4gaW50ZXJuYWwgdG9rZW4gcmVwcmVzZW50YXRpb25cbiAqIG9mIHRoZSBsaW5rLiBJdCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBvZiB0aGUgdGVtcGxhdGUgdHlwZSBgVmBcbiAqXG4gKiBGb3IgdGhlIG9iamVjdCwgZWFjaCBrZXkgc2hvdWxkIGJlIGEgbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikuXG4gKiBFYWNoIHZhbHVlIHNob3VsZCBlaXRoZXIgaGF2ZSB0eXBlIGBWYCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBWLiBUaGlzXG4gKiBmdW5jdGlvbiBzaW1pbGFybHkgdGFrZXMgYSBzdHJpbmcgdmFsdWUgYW5kIGEgdG9rZW4uXG4gKlxuICogRXhhbXBsZSB2YWxpZCB0eXBlcyBmb3IgYE9wdDxzdHJpbmc+YDpcbiAqXG4gKiBgYGBqc1xuICogJ2hlbGxvJ1xuICogKHZhbHVlLCB0eXBlLCB0b2tlbikgPT4gJ3dvcmxkJ1xuICogeyB1cmw6ICdoZWxsbycsIGVtYWlsOiAodmFsdWUsIHRva2VuKSA9PiAnd29ybGQnfVxuICogYGBgXG4gKiBAdGVtcGxhdGUgVlxuICogQHR5cGVkZWYge1YgfCAoKHZhbHVlOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgdG9rZW46IE11bHRpVG9rZW4pID0+IFYpIHwgeyBbdHlwZTogc3RyaW5nXTogViB8ICgodmFsdWU6IHN0cmluZywgdG9rZW46IE11bHRpVG9rZW4pID0+IFYpIH19IE9wdFxuICovXG5cbi8qKlxuICogU2VlIGF2YWlsYWJsZSBvcHRpb25zOiBodHRwczovL2xpbmtpZnkuanMub3JnL2RvY3Mvb3B0aW9ucy5odG1sXG4gKiBAdHlwZWRlZiB7e1xuICogXHRkZWZhdWx0UHJvdG9jb2w/OiBzdHJpbmcsXG4gKiAgZXZlbnRzPzogT3B0T2JqPEV2ZW50TGlzdGVuZXJzPixcbiAqIFx0Zm9ybWF0PzogT3B0PHN0cmluZz4sXG4gKiBcdGZvcm1hdEhyZWY/OiBPcHQ8c3RyaW5nPixcbiAqIFx0bmwyYnI/OiBib29sZWFuLFxuICogXHR0YWdOYW1lPzogT3B0PGFueT4sXG4gKiBcdHRhcmdldD86IE9wdDxzdHJpbmc+LFxuICogXHRyZWw/OiBPcHQ8c3RyaW5nPixcbiAqIFx0dmFsaWRhdGU/OiBPcHQ8Ym9vbGVhbj4sXG4gKiBcdHRydW5jYXRlPzogT3B0PG51bWJlcj4sXG4gKiBcdGNsYXNzTmFtZT86IE9wdDxzdHJpbmc+LFxuICogXHRhdHRyaWJ1dGVzPzogT3B0T2JqPCh7IFthdHRyOiBzdHJpbmddOiBhbnkgfSk+LFxuICogIGlnbm9yZVRhZ3M/OiBzdHJpbmdbXSxcbiAqIFx0cmVuZGVyPzogT3B0Rm48KChpcjogSW50ZXJtZWRpYXRlUmVwcmVzZW50YXRpb24pID0+IGFueSk+XG4gKiB9fSBPcHRzXG4gKi9cblxuLyoqXG4gKiBAdHlwZSBSZXF1aXJlZDxPcHRzPlxuICovXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgZGVmYXVsdFByb3RvY29sOiAnaHR0cCcsXG4gIGV2ZW50czogbnVsbCxcbiAgZm9ybWF0OiBub29wLFxuICBmb3JtYXRIcmVmOiBub29wLFxuICBubDJicjogZmFsc2UsXG4gIHRhZ05hbWU6ICdhJyxcbiAgdGFyZ2V0OiBudWxsLFxuICByZWw6IG51bGwsXG4gIHZhbGlkYXRlOiB0cnVlLFxuICB0cnVuY2F0ZTogSW5maW5pdHksXG4gIGNsYXNzTmFtZTogbnVsbCxcbiAgYXR0cmlidXRlczogbnVsbCxcbiAgaWdub3JlVGFnczogW10sXG4gIHJlbmRlcjogbnVsbFxufTtcblxuLyoqXG4gKiBVdGlsaXR5IGNsYXNzIGZvciBsaW5raWZ5IGludGVyZmFjZXMgdG8gYXBwbHkgc3BlY2lmaWVkXG4gKiB7QGxpbmsgT3B0cyBmb3JtYXR0aW5nIGFuZCByZW5kZXJpbmcgb3B0aW9uc30uXG4gKlxuICogQHBhcmFtIHtPcHRzIHwgT3B0aW9uc30gW29wdHNdIE9wdGlvbiB2YWx1ZSBvdmVycmlkZXMuXG4gKiBAcGFyYW0geyhpcjogSW50ZXJtZWRpYXRlUmVwcmVzZW50YXRpb24pID0+IGFueX0gW2RlZmF1bHRSZW5kZXJdIChGb3JcbiAqICAgaW50ZXJuYWwgdXNlKSBkZWZhdWx0IHJlbmRlciBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgaG93IHRvIGdlbmVyYXRlIGFuXG4gKiAgIEhUTUwgZWxlbWVudCBiYXNlZCBvbiBhIGxpbmsgdG9rZW4ncyBkZXJpdmVkIHRhZ05hbWUsIGF0dHJpYnV0ZXMgYW5kIEhUTUwuXG4gKiAgIFNpbWlsYXIgdG8gcmVuZGVyIG9wdGlvblxuICovXG5mdW5jdGlvbiBPcHRpb25zKG9wdHMsIGRlZmF1bHRSZW5kZXIpIHtcbiAgaWYgKGRlZmF1bHRSZW5kZXIgPT09IHZvaWQgMCkge1xuICAgIGRlZmF1bHRSZW5kZXIgPSBudWxsO1xuICB9XG4gIGxldCBvID0gYXNzaWduKHt9LCBkZWZhdWx0cyk7XG4gIGlmIChvcHRzKSB7XG4gICAgbyA9IGFzc2lnbihvLCBvcHRzIGluc3RhbmNlb2YgT3B0aW9ucyA/IG9wdHMubyA6IG9wdHMpO1xuICB9XG5cbiAgLy8gRW5zdXJlIGFsbCBpZ25vcmVkIHRhZ3MgYXJlIHVwcGVyY2FzZVxuICBjb25zdCBpZ25vcmVkVGFncyA9IG8uaWdub3JlVGFncztcbiAgY29uc3QgdXBwZXJjYXNlSWdub3JlZFRhZ3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZ25vcmVkVGFncy5sZW5ndGg7IGkrKykge1xuICAgIHVwcGVyY2FzZUlnbm9yZWRUYWdzLnB1c2goaWdub3JlZFRhZ3NbaV0udG9VcHBlckNhc2UoKSk7XG4gIH1cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgdGhpcy5vID0gbztcbiAgaWYgKGRlZmF1bHRSZW5kZXIpIHtcbiAgICB0aGlzLmRlZmF1bHRSZW5kZXIgPSBkZWZhdWx0UmVuZGVyO1xuICB9XG4gIHRoaXMuaWdub3JlVGFncyA9IHVwcGVyY2FzZUlnbm9yZWRUYWdzO1xufVxuT3B0aW9ucy5wcm90b3R5cGUgPSB7XG4gIG86IGRlZmF1bHRzLFxuICAvKipcbiAgICogQHR5cGUgc3RyaW5nW11cbiAgICovXG4gIGlnbm9yZVRhZ3M6IFtdLFxuICAvKipcbiAgICogQHBhcmFtIHtJbnRlcm1lZGlhdGVSZXByZXNlbnRhdGlvbn0gaXJcbiAgICogQHJldHVybnMge2FueX1cbiAgICovXG4gIGRlZmF1bHRSZW5kZXIoaXIpIHtcbiAgICByZXR1cm4gaXI7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgYmFzZWQgb24gd2hldGhlciBhIHRva2VuIHNob3VsZCBiZSBkaXNwbGF5ZWQgYXMgYVxuICAgKiBsaW5rIGJhc2VkIG9uIHRoZSB1c2VyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7TXVsdGlUb2tlbn0gdG9rZW5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjaGVjayh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLmdldCgndmFsaWRhdGUnLCB0b2tlbi50b1N0cmluZygpLCB0b2tlbik7XG4gIH0sXG4gIC8vIFByaXZhdGUgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGFuIG9wdGlvbidzIHZhbHVlIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIGFuZCB0aGUgZ2l2ZW5cbiAgICogcGFyYW1zLiBJZiBvcGVyYXRvciBhbmQgdG9rZW4gYXJlIHNwZWNpZmllZCBhbmQgdGhlIHRhcmdldCBvcHRpb24gaXNcbiAgICogY2FsbGFibGUsIGF1dG9tYXRpY2FsbHkgY2FsbHMgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50LlxuICAgKiBAdGVtcGxhdGUge2tleW9mIE9wdHN9IEtcbiAgICogQHBhcmFtIHtLfSBrZXkgTmFtZSBvZiBvcHRpb24gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3BlcmF0b3JdIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB0YXJnZXQgb3B0aW9uIGlmIGl0J3MgYVxuICAgKiBmdW5jdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgUkFXIGZ1bmN0aW9uIHZhbHVlIGdldHMgcmV0dXJuZWRcbiAgICogQHBhcmFtIHtNdWx0aVRva2VufSBbdG9rZW5dIFRoZSB0b2tlbiBmcm9tIGxpbmtpZnkudG9rZW5pemVcbiAgICogQHJldHVybnMge09wdHNbS10gfCBhbnl9XG4gICAqL1xuICBnZXQoa2V5LCBvcGVyYXRvciwgdG9rZW4pIHtcbiAgICBjb25zdCBpc0NhbGxhYmxlID0gb3BlcmF0b3IgIT0gbnVsbDtcbiAgICBsZXQgb3B0aW9uID0gdGhpcy5vW2tleV07XG4gICAgaWYgKCFvcHRpb24pIHtcbiAgICAgIHJldHVybiBvcHRpb247XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9uID0gdG9rZW4udCBpbiBvcHRpb24gPyBvcHRpb25bdG9rZW4udF0gOiBkZWZhdWx0c1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicgJiYgaXNDYWxsYWJsZSkge1xuICAgICAgICBvcHRpb24gPSBvcHRpb24ob3BlcmF0b3IsIHRva2VuKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicgJiYgaXNDYWxsYWJsZSkge1xuICAgICAgb3B0aW9uID0gb3B0aW9uKG9wZXJhdG9yLCB0b2tlbi50LCB0b2tlbik7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb247XG4gIH0sXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUge2tleW9mIE9wdHN9IExcbiAgICogQHBhcmFtIHtMfSBrZXkgTmFtZSBvZiBvcHRpb25zIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcGVyYXRvcl1cbiAgICogQHBhcmFtIHtNdWx0aVRva2VufSBbdG9rZW5dXG4gICAqIEByZXR1cm5zIHtPcHRzW0xdIHwgYW55fVxuICAgKi9cbiAgZ2V0T2JqKGtleSwgb3BlcmF0b3IsIHRva2VuKSB7XG4gICAgbGV0IG9iaiA9IHRoaXMub1trZXldO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nICYmIG9wZXJhdG9yICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IG9iaihvcGVyYXRvciwgdG9rZW4udCwgdG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9LFxuICAvKipcbiAgICogQ29udmVydCB0aGUgZ2l2ZW4gdG9rZW4gdG8gYSByZW5kZXJlZCBlbGVtZW50IHRoYXQgbWF5IGJlIGFkZGVkIHRvIHRoZVxuICAgKiBjYWxsaW5nLWludGVyZmFjZSdzIERPTVxuICAgKiBAcGFyYW0ge011bHRpVG9rZW59IHRva2VuIFRva2VuIHRvIHJlbmRlciB0byBhbiBIVE1MIGVsZW1lbnRcbiAgICogQHJldHVybnMge2FueX0gUmVuZGVyIHJlc3VsdDsgZS5nLiwgSFRNTCBzdHJpbmcsIERPTSBlbGVtZW50LCBSZWFjdFxuICAgKiAgIENvbXBvbmVudCwgZXRjLlxuICAgKi9cbiAgcmVuZGVyKHRva2VuKSB7XG4gICAgY29uc3QgaXIgPSB0b2tlbi5yZW5kZXIodGhpcyk7IC8vIGludGVybWVkaWF0ZSByZXByZXNlbnRhdGlvblxuICAgIGNvbnN0IHJlbmRlckZuID0gdGhpcy5nZXQoJ3JlbmRlcicsIG51bGwsIHRva2VuKSB8fCB0aGlzLmRlZmF1bHRSZW5kZXI7XG4gICAgcmV0dXJuIHJlbmRlckZuKGlyLCB0b2tlbi50LCB0b2tlbik7XG4gIH1cbn07XG5mdW5jdGlvbiBub29wKHZhbCkge1xuICByZXR1cm4gdmFsO1xufVxuXG52YXIgb3B0aW9ucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRkZWZhdWx0czogZGVmYXVsdHMsXG5cdE9wdGlvbnM6IE9wdGlvbnMsXG5cdGFzc2lnbjogYXNzaWduXG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRNdWx0aS1Ub2tlbnNcblx0VG9rZW5zIGNvbXBvc2VkIG9mIGFycmF5cyBvZiBUZXh0VG9rZW5zXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRva2Vuc1xuICovXG5mdW5jdGlvbiBNdWx0aVRva2VuKHZhbHVlLCB0b2tlbnMpIHtcbiAgdGhpcy50ID0gJ3Rva2VuJztcbiAgdGhpcy52ID0gdmFsdWU7XG4gIHRoaXMudGsgPSB0b2tlbnM7XG59XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdXNlZCBmb3IgbWFudWZhY3R1cmluZyB0b2tlbnMgb2YgdGV4dCB0b2tlbnMuIFRoYXQgaXMgcmF0aGVyXG4gKiB0aGFuIHRoZSB2YWx1ZSBmb3IgYSB0b2tlbiBiZWluZyBhIHNtYWxsIHN0cmluZyBvZiB0ZXh0LCBpdCdzIHZhbHVlIGFuIGFycmF5XG4gKiBvZiB0ZXh0IHRva2Vucy5cbiAqXG4gKiBVc2VkIGZvciBncm91cGluZyB0b2dldGhlciBVUkxzLCBlbWFpbHMsIGhhc2h0YWdzLCBhbmQgb3RoZXIgcG90ZW50aWFsXG4gKiBjcmVhdGlvbnMuXG4gKiBAY2xhc3MgTXVsdGlUb2tlblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2XG4gKiBAcHJvcGVydHkge1Rva2VuW119IHRrXG4gKiBAYWJzdHJhY3RcbiAqL1xuTXVsdGlUb2tlbi5wcm90b3R5cGUgPSB7XG4gIGlzTGluazogZmFsc2UsXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHN0cmluZyB0aGlzIHRva2VuIHJlcHJlc2VudHMuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnY7XG4gIH0sXG4gIC8qKlxuICAgKiBXaGF0IHNob3VsZCB0aGUgdmFsdWUgZm9yIHRoaXMgdG9rZW4gYmUgaW4gdGhlIGBocmVmYCBIVE1MIGF0dHJpYnV0ZT9cbiAgICogUmV0dXJucyB0aGUgYC50b1N0cmluZ2AgdmFsdWUgYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzY2hlbWVdXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgKi9cbiAgdG9IcmVmKHNjaGVtZSkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgRm9ybWF0dGluZyBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdHRlZFN0cmluZyhvcHRpb25zKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy50b1N0cmluZygpO1xuICAgIGNvbnN0IHRydW5jYXRlID0gb3B0aW9ucy5nZXQoJ3RydW5jYXRlJywgdmFsLCB0aGlzKTtcbiAgICBjb25zdCBmb3JtYXR0ZWQgPSBvcHRpb25zLmdldCgnZm9ybWF0JywgdmFsLCB0aGlzKTtcbiAgICByZXR1cm4gdHJ1bmNhdGUgJiYgZm9ybWF0dGVkLmxlbmd0aCA+IHRydW5jYXRlID8gZm9ybWF0dGVkLnN1YnN0cmluZygwLCB0cnVuY2F0ZSkgKyAnXHUyMDI2JyA6IGZvcm1hdHRlZDtcbiAgfSxcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXR0ZWRIcmVmKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5nZXQoJ2Zvcm1hdEhyZWYnLCB0aGlzLnRvSHJlZihvcHRpb25zLmdldCgnZGVmYXVsdFByb3RvY29sJykpLCB0aGlzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBzdGFydCBpbmRleCBvZiB0aGlzIHRva2VuIGluIHRoZSBvcmlnaW5hbCBpbnB1dCBzdHJpbmdcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0YXJ0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudGtbMF0ucztcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBlbmQgaW5kZXggb2YgdGhpcyB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgaW5wdXQgc3RyaW5nICh1cCB0byB0aGlzXG4gICAqIGluZGV4IGJ1dCBub3QgaW5jbHVkaW5nIGl0KVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZW5kSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudGtbdGhpcy50ay5sZW5ndGggLSAxXS5lO1xuICB9LFxuICAvKipcbiAgXHRSZXR1cm5zIGFuIG9iamVjdCAgb2YgcmVsZXZhbnQgdmFsdWVzIGZvciB0aGlzIHRva2VuLCB3aGljaCBpbmNsdWRlcyBrZXlzXG4gIFx0KiB0eXBlIC0gS2luZCBvZiB0b2tlbiAoJ3VybCcsICdlbWFpbCcsIGV0Yy4pXG4gIFx0KiB2YWx1ZSAtIE9yaWdpbmFsIHRleHRcbiAgXHQqIGhyZWYgLSBUaGUgdmFsdWUgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGFuY2hvciB0YWcncyBocmVmXG4gIFx0XHRhdHRyaWJ1dGVcbiAgXHRcdEBtZXRob2QgdG9PYmplY3RcbiAgXHRAcGFyYW0ge3N0cmluZ30gW3Byb3RvY29sXSBgJ2h0dHAnYCBieSBkZWZhdWx0XG4gICovXG4gIHRvT2JqZWN0KHByb3RvY29sKSB7XG4gICAgaWYgKHByb3RvY29sID09PSB2b2lkIDApIHtcbiAgICAgIHByb3RvY29sID0gZGVmYXVsdHMuZGVmYXVsdFByb3RvY29sO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy50LFxuICAgICAgdmFsdWU6IHRoaXMudG9TdHJpbmcoKSxcbiAgICAgIGlzTGluazogdGhpcy5pc0xpbmssXG4gICAgICBocmVmOiB0aGlzLnRvSHJlZihwcm90b2NvbCksXG4gICAgICBzdGFydDogdGhpcy5zdGFydEluZGV4KCksXG4gICAgICBlbmQ6IHRoaXMuZW5kSW5kZXgoKVxuICAgIH07XG4gIH0sXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgRm9ybWF0dGluZyBvcHRpb25cbiAgICovXG4gIHRvRm9ybWF0dGVkT2JqZWN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy50LFxuICAgICAgdmFsdWU6IHRoaXMudG9Gb3JtYXR0ZWRTdHJpbmcob3B0aW9ucyksXG4gICAgICBpc0xpbms6IHRoaXMuaXNMaW5rLFxuICAgICAgaHJlZjogdGhpcy50b0Zvcm1hdHRlZEhyZWYob3B0aW9ucyksXG4gICAgICBzdGFydDogdGhpcy5zdGFydEluZGV4KCksXG4gICAgICBlbmQ6IHRoaXMuZW5kSW5kZXgoKVxuICAgIH07XG4gIH0sXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgdG9rZW4gc2hvdWxkIGJlIHJlbmRlcmVkIGFzIGEgbGluayBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgdmFsaWRhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmdldCgndmFsaWRhdGUnLCB0aGlzLnRvU3RyaW5nKCksIHRoaXMpO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJuIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgaG93IHRoaXMgbGluayBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBGb3JtYXR0aW5uZyBvcHRpb25zXG4gICAqL1xuICByZW5kZXIob3B0aW9ucykge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcztcbiAgICBjb25zdCBocmVmID0gdGhpcy50b0hyZWYob3B0aW9ucy5nZXQoJ2RlZmF1bHRQcm90b2NvbCcpKTtcbiAgICBjb25zdCBmb3JtYXR0ZWRIcmVmID0gb3B0aW9ucy5nZXQoJ2Zvcm1hdEhyZWYnLCBocmVmLCB0aGlzKTtcbiAgICBjb25zdCB0YWdOYW1lID0gb3B0aW9ucy5nZXQoJ3RhZ05hbWUnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMudG9Gb3JtYXR0ZWRTdHJpbmcob3B0aW9ucyk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IG9wdGlvbnMuZ2V0KCdjbGFzc05hbWUnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy5nZXQoJ3RhcmdldCcsIGhyZWYsIHRva2VuKTtcbiAgICBjb25zdCByZWwgPSBvcHRpb25zLmdldCgncmVsJywgaHJlZiwgdG9rZW4pO1xuICAgIGNvbnN0IGF0dHJzID0gb3B0aW9ucy5nZXRPYmooJ2F0dHJpYnV0ZXMnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLmdldE9iaignZXZlbnRzJywgaHJlZiwgdG9rZW4pO1xuICAgIGF0dHJpYnV0ZXMuaHJlZiA9IGZvcm1hdHRlZEhyZWY7XG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgYXR0cmlidXRlcy5jbGFzcyA9IGNsYXNzTmFtZTtcbiAgICB9XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgYXR0cmlidXRlcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgfVxuICAgIGlmIChyZWwpIHtcbiAgICAgIGF0dHJpYnV0ZXMucmVsID0gcmVsO1xuICAgIH1cbiAgICBpZiAoYXR0cnMpIHtcbiAgICAgIGFzc2lnbihhdHRyaWJ1dGVzLCBhdHRycyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0YWdOYW1lLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBldmVudExpc3RlbmVyc1xuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHRva2VuIHRoYXQgY2FuIGJlIGVtaXR0ZWQgYnkgdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSByZWFkYWJsZSB0eXBlIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIHByb3BlcnRpZXMgdG8gYXNzaWduIG9yIG92ZXJyaWRlLCBpbmNsdWRpbmcgaXNMaW5rID0gdHJ1ZSBvciBmYWxzZVxuICogQHJldHVybnMge25ldyAodmFsdWU6IHN0cmluZywgdG9rZW5zOiBUb2tlbltdKSA9PiBNdWx0aVRva2VufSBuZXcgdG9rZW4gY2xhc3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVG9rZW5DbGFzcyh0eXBlLCBwcm9wcykge1xuICBjbGFzcyBUb2tlbiBleHRlbmRzIE11bHRpVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0b2tlbnMpIHtcbiAgICAgIHN1cGVyKHZhbHVlLCB0b2tlbnMpO1xuICAgICAgdGhpcy50ID0gdHlwZTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBwIGluIHByb3BzKSB7XG4gICAgVG9rZW4ucHJvdG90eXBlW3BdID0gcHJvcHNbcF07XG4gIH1cbiAgVG9rZW4udCA9IHR5cGU7XG4gIHJldHVybiBUb2tlbjtcbn1cblxuLyoqXG5cdFJlcHJlc2VudHMgYSBsaXN0IG9mIHRva2VucyBtYWtpbmcgdXAgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXG4qL1xuY29uc3QgRW1haWwgPSBjcmVhdGVUb2tlbkNsYXNzKCdlbWFpbCcsIHtcbiAgaXNMaW5rOiB0cnVlLFxuICB0b0hyZWYoKSB7XG4gICAgcmV0dXJuICdtYWlsdG86JyArIHRoaXMudG9TdHJpbmcoKTtcbiAgfVxufSk7XG5cbi8qKlxuXHRSZXByZXNlbnRzIHNvbWUgcGxhaW4gdGV4dFxuKi9cbmNvbnN0IFRleHQgPSBjcmVhdGVUb2tlbkNsYXNzKCd0ZXh0Jyk7XG5cbi8qKlxuXHRNdWx0aS1saW5lYnJlYWsgdG9rZW4gLSByZXByZXNlbnRzIGEgbGluZSBicmVha1xuXHRAY2xhc3MgTmxcbiovXG5jb25zdCBObCA9IGNyZWF0ZVRva2VuQ2xhc3MoJ25sJyk7XG5cbi8qKlxuXHRSZXByZXNlbnRzIGEgbGlzdCBvZiB0ZXh0IHRva2VucyBtYWtpbmcgdXAgYSB2YWxpZCBVUkxcblx0QGNsYXNzIFVybFxuKi9cbmNvbnN0IFVybCA9IGNyZWF0ZVRva2VuQ2xhc3MoJ3VybCcsIHtcbiAgaXNMaW5rOiB0cnVlLFxuICAvKipcbiAgXHRMb3dlcmNhc2VzIHJlbGV2YW50IHBhcnRzIG9mIHRoZSBkb21haW4gYW5kIGFkZHMgdGhlIHByb3RvY29sIGlmXG4gIFx0cmVxdWlyZWQuIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IGVzY2FwZSB1bnNhZmUgSFRNTCBjaGFyYWN0ZXJzIGluIHRoZVxuICBcdFVSTC5cbiAgXHRcdEBwYXJhbSB7c3RyaW5nfSBbc2NoZW1lXSBkZWZhdWx0IHNjaGVtZSAoZS5nLiwgJ2h0dHBzJylcbiAgXHRAcmV0dXJuIHtzdHJpbmd9IHRoZSBmdWxsIGhyZWZcbiAgKi9cbiAgdG9IcmVmKHNjaGVtZSkge1xuICAgIGlmIChzY2hlbWUgPT09IHZvaWQgMCkge1xuICAgICAgc2NoZW1lID0gZGVmYXVsdHMuZGVmYXVsdFByb3RvY29sO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGhhcyBhIHByZWZpeCBzY2hlbWVcbiAgICByZXR1cm4gdGhpcy5oYXNQcm90b2NvbCgpID8gdGhpcy52IDogYCR7c2NoZW1lfTovLyR7dGhpcy52fWA7XG4gIH0sXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoaXMgVVJMIHRva2VuIGhhcyBhIHByb3RvY29sXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNQcm90b2NvbCgpIHtcbiAgICBjb25zdCB0b2tlbnMgPSB0aGlzLnRrO1xuICAgIHJldHVybiB0b2tlbnMubGVuZ3RoID49IDIgJiYgdG9rZW5zWzBdLnQgIT09IExPQ0FMSE9TVCAmJiB0b2tlbnNbMV0udCA9PT0gQ09MT047XG4gIH1cbn0pO1xuXG52YXIgbXVsdGkgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0TXVsdGlUb2tlbjogTXVsdGlUb2tlbixcblx0QmFzZTogTXVsdGlUb2tlbixcblx0Y3JlYXRlVG9rZW5DbGFzczogY3JlYXRlVG9rZW5DbGFzcyxcblx0RW1haWw6IEVtYWlsLFxuXHRUZXh0OiBUZXh0LFxuXHRObDogTmwsXG5cdFVybDogVXJsXG59KTtcblxuLyoqXG5cdE5vdCBleGFjdGx5IHBhcnNlciwgbW9yZSBsaWtlIHRoZSBzZWNvbmQtc3RhZ2Ugc2Nhbm5lciAoYWx0aG91Z2ggd2UgY2FuXG5cdHRoZW9yZXRpY2FsbHkgaG90c3dhcCB0aGUgY29kZSBoZXJlIHdpdGggYSByZWFsIHBhcnNlciBpbiB0aGUgZnV0dXJlLi4uIGJ1dFxuXHRmb3IgYSBsaXR0bGUgVVJMLWZpbmRpbmcgdXRpbGl0eSBhYnN0cmFjdCBzeW50YXggdHJlZXMgbWF5IGJlIGEgbGl0dGxlXG5cdG92ZXJraWxsKS5cblxuXHRVUkwgZm9ybWF0OiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VSSV9zY2hlbWVcblx0RW1haWwgZm9ybWF0OiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VtYWlsQWRkcmVzcyAobGlua3MgdG8gUkZDIGluXG5cdHJlZmVyZW5jZSlcblxuXHRAbW9kdWxlIGxpbmtpZnlcblx0QHN1Ym1vZHVsZSBwYXJzZXJcblx0QG1haW4gcnVuXG4qL1xuY29uc3QgbWFrZVN0YXRlID0gYXJnID0+IG5ldyBTdGF0ZShhcmcpO1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBwYXJzZXIgbXVsdGkgdG9rZW4tYmFzZWQgc3RhdGUgbWFjaGluZVxuICogQHBhcmFtIHt7IGdyb3VwczogQ29sbGVjdGlvbnM8c3RyaW5nPiB9fSB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gaW5pdCQxKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBncm91cHNcbiAgfSA9IF9yZWY7XG4gIC8vIFR5cGVzIG9mIGNoYXJhY3RlcnMgdGhlIFVSTCBjYW4gZGVmaW5pdGVseSBlbmQgaW5cbiAgY29uc3QgcXNBY2NlcHRpbmcgPSBncm91cHMuZG9tYWluLmNvbmNhdChbQU1QRVJTQU5ELCBBU1RFUklTSywgQVQsIEJBQ0tTTEFTSCwgQkFDS1RJQ0ssIENBUkVULCBET0xMQVIsIEVRVUFMUywgSFlQSEVOLCBOVU0sIFBFUkNFTlQsIFBJUEUsIFBMVVMsIFBPVU5ELCBTTEFTSCwgU1lNLCBUSUxERSwgVU5ERVJTQ09SRV0pO1xuXG4gIC8vIFR5cGVzIG9mIHRva2VucyB0aGF0IGNhbiBmb2xsb3cgYSBVUkwgYW5kIGJlIHBhcnQgb2YgdGhlIHF1ZXJ5IHN0cmluZ1xuICAvLyBidXQgY2Fubm90IGJlIHRoZSB2ZXJ5IGxhc3QgY2hhcmFjdGVyc1xuICAvLyBDaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGFwcGVhciBpbiB0aGUgVVJMIGF0IGFsbCBzaG91bGQgYmUgZXhjbHVkZWRcbiAgY29uc3QgcXNOb25BY2NlcHRpbmcgPSBbQVBPU1RST1BIRSwgQ09MT04sIENPTU1BLCBET1QsIEVYQ0xBTUFUSU9OLCBRVUVSWSwgUVVPVEUsIFNFTUksIE9QRU5BTkdMRUJSQUNLRVQsIENMT1NFQU5HTEVCUkFDS0VULCBPUEVOQlJBQ0UsIENMT1NFQlJBQ0UsIENMT1NFQlJBQ0tFVCwgT1BFTkJSQUNLRVQsIE9QRU5QQVJFTiwgQ0xPU0VQQVJFTiwgRlVMTFdJRFRITEVGVFBBUkVOLCBGVUxMV0lEVEhSSUdIVFBBUkVOLCBMRUZUQ09STkVSQlJBQ0tFVCwgUklHSFRDT1JORVJCUkFDS0VULCBMRUZUV0hJVEVDT1JORVJCUkFDS0VULCBSSUdIVFdISVRFQ09STkVSQlJBQ0tFVCwgRlVMTFdJRFRITEVTU1RIQU4sIEZVTExXSURUSEdSRUFURVJUSEFOXTtcblxuICAvLyBGb3IgYWRkcmVzc2VzIHdpdGhvdXQgdGhlIG1haWx0byBwcmVmaXhcbiAgLy8gVG9rZW5zIGFsbG93ZWQgaW4gdGhlIGxvY2FscGFydCBvZiB0aGUgZW1haWxcbiAgY29uc3QgbG9jYWxwYXJ0QWNjZXB0aW5nID0gW0FNUEVSU0FORCwgQVBPU1RST1BIRSwgQVNURVJJU0ssIEJBQ0tTTEFTSCwgQkFDS1RJQ0ssIENBUkVULCBET0xMQVIsIEVRVUFMUywgSFlQSEVOLCBPUEVOQlJBQ0UsIENMT1NFQlJBQ0UsIFBFUkNFTlQsIFBJUEUsIFBMVVMsIFBPVU5ELCBRVUVSWSwgU0xBU0gsIFNZTSwgVElMREUsIFVOREVSU0NPUkVdO1xuXG4gIC8vIFRoZSB1bml2ZXJzYWwgc3RhcnRpbmcgc3RhdGUuXG4gIC8qKlxuICAgKiBAdHlwZSBTdGF0ZTxUb2tlbj5cbiAgICovXG4gIGNvbnN0IFN0YXJ0ID0gbWFrZVN0YXRlKCk7XG4gIGNvbnN0IExvY2FscGFydCA9IHR0KFN0YXJ0LCBUSUxERSk7IC8vIExvY2FsIHBhcnQgb2YgdGhlIGVtYWlsIGFkZHJlc3NcbiAgdGEoTG9jYWxwYXJ0LCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKExvY2FscGFydCwgZ3JvdXBzLmRvbWFpbiwgTG9jYWxwYXJ0KTtcbiAgY29uc3QgRG9tYWluID0gbWFrZVN0YXRlKCksXG4gICAgU2NoZW1lID0gbWFrZVN0YXRlKCksXG4gICAgU2xhc2hTY2hlbWUgPSBtYWtlU3RhdGUoKTtcbiAgdGEoU3RhcnQsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7IC8vIHBhcnNlZCBzdHJpbmcgZW5kcyB3aXRoIGEgcG90ZW50aWFsIGRvbWFpbiBuYW1lIChBKVxuICB0YShTdGFydCwgZ3JvdXBzLnNjaGVtZSwgU2NoZW1lKTsgLy8gZS5nLiwgJ21haWx0bydcbiAgdGEoU3RhcnQsIGdyb3Vwcy5zbGFzaHNjaGVtZSwgU2xhc2hTY2hlbWUpOyAvLyBlLmcuLCAnaHR0cCdcblxuICB0YShEb21haW4sIGxvY2FscGFydEFjY2VwdGluZywgTG9jYWxwYXJ0KTtcbiAgdGEoRG9tYWluLCBncm91cHMuZG9tYWluLCBEb21haW4pO1xuICBjb25zdCBMb2NhbHBhcnRBdCA9IHR0KERvbWFpbiwgQVQpOyAvLyBMb2NhbCBwYXJ0IG9mIHRoZSBlbWFpbCBhZGRyZXNzIHBsdXMgQFxuXG4gIHR0KExvY2FscGFydCwgQVQsIExvY2FscGFydEF0KTsgLy8gY2xvc2UgdG8gYW4gZW1haWwgYWRkcmVzcyBub3dcblxuICAvLyBMb2NhbCBwYXJ0IG9mIGFuIGVtYWlsIGFkZHJlc3MgY2FuIGJlIGUuZy4gJ2h0dHAnIG9yICdtYWlsdG8nXG4gIHR0KFNjaGVtZSwgQVQsIExvY2FscGFydEF0KTtcbiAgdHQoU2xhc2hTY2hlbWUsIEFULCBMb2NhbHBhcnRBdCk7XG4gIGNvbnN0IExvY2FscGFydERvdCA9IHR0KExvY2FscGFydCwgRE9UKTsgLy8gTG9jYWwgcGFydCBvZiB0aGUgZW1haWwgYWRkcmVzcyBwbHVzICcuJyAobG9jYWxwYXJ0IGNhbm5vdCBlbmQgaW4gLilcbiAgdGEoTG9jYWxwYXJ0RG90LCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKExvY2FscGFydERvdCwgZ3JvdXBzLmRvbWFpbiwgTG9jYWxwYXJ0KTtcbiAgY29uc3QgRW1haWxEb21haW4gPSBtYWtlU3RhdGUoKTtcbiAgdGEoTG9jYWxwYXJ0QXQsIGdyb3Vwcy5kb21haW4sIEVtYWlsRG9tYWluKTsgLy8gcGFyc2VkIHN0cmluZyBzdGFydHMgd2l0aCBsb2NhbCBlbWFpbCBpbmZvICsgQCB3aXRoIGEgcG90ZW50aWFsIGRvbWFpbiBuYW1lXG4gIHRhKEVtYWlsRG9tYWluLCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIGNvbnN0IEVtYWlsRG9tYWluRG90ID0gdHQoRW1haWxEb21haW4sIERPVCk7IC8vIGRvbWFpbiBmb2xsb3dlZCBieSBET1RcbiAgdGEoRW1haWxEb21haW5Eb3QsIGdyb3Vwcy5kb21haW4sIEVtYWlsRG9tYWluKTtcbiAgY29uc3QgRW1haWwkMSA9IG1ha2VTdGF0ZShFbWFpbCk7IC8vIFBvc3NpYmxlIGVtYWlsIGFkZHJlc3MgKGNvdWxkIGhhdmUgbW9yZSB0bGRzKVxuICB0YShFbWFpbERvbWFpbkRvdCwgZ3JvdXBzLnRsZCwgRW1haWwkMSk7XG4gIHRhKEVtYWlsRG9tYWluRG90LCBncm91cHMudXRsZCwgRW1haWwkMSk7XG4gIHR0KExvY2FscGFydEF0LCBMT0NBTEhPU1QsIEVtYWlsJDEpO1xuXG4gIC8vIEh5cGhlbiBjYW4ganVtcCBiYWNrIHRvIGEgZG9tYWluIG5hbWVcbiAgY29uc3QgRW1haWxEb21haW5IeXBoZW4gPSB0dChFbWFpbERvbWFpbiwgSFlQSEVOKTsgLy8gcGFyc2VkIHN0cmluZyBzdGFydHMgd2l0aCBsb2NhbCBlbWFpbCBpbmZvICsgQCB3aXRoIGEgcG90ZW50aWFsIGRvbWFpbiBuYW1lXG4gIHRhKEVtYWlsRG9tYWluSHlwaGVuLCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIHRhKEVtYWlsJDEsIGdyb3Vwcy5kb21haW4sIEVtYWlsRG9tYWluKTtcbiAgdHQoRW1haWwkMSwgRE9ULCBFbWFpbERvbWFpbkRvdCk7XG4gIHR0KEVtYWlsJDEsIEhZUEhFTiwgRW1haWxEb21haW5IeXBoZW4pO1xuXG4gIC8vIEZpbmFsIHBvc3NpYmxlIGVtYWlsIHN0YXRlc1xuICBjb25zdCBFbWFpbENvbG9uID0gdHQoRW1haWwkMSwgQ09MT04pOyAvLyBVUkwgZm9sbG93ZWQgYnkgY29sb24gKHBvdGVudGlhbCBwb3J0IG51bWJlciBoZXJlKVxuICAvKmNvbnN0IEVtYWlsQ29sb25Qb3J0ID0gKi9cbiAgdGEoRW1haWxDb2xvbiwgZ3JvdXBzLm51bWVyaWMsIEVtYWlsKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IGNvbG9uIGFuZCBwb3J0IG51bWJlclxuXG4gIC8vIEFjY291bnQgZm9yIGRvdHMgYW5kIGh5cGhlbnMuIEh5cGhlbnMgYXJlIHVzdWFsbHkgcGFydHMgb2YgZG9tYWluIG5hbWVzXG4gIC8vIChidXQgbm90IFRMRHMpXG4gIGNvbnN0IERvbWFpbkh5cGhlbiA9IHR0KERvbWFpbiwgSFlQSEVOKTsgLy8gZG9tYWluIGZvbGxvd2VkIGJ5IGh5cGhlblxuICBjb25zdCBEb21haW5Eb3QgPSB0dChEb21haW4sIERPVCk7IC8vIGRvbWFpbiBmb2xsb3dlZCBieSBET1RcbiAgdGEoRG9tYWluSHlwaGVuLCBncm91cHMuZG9tYWluLCBEb21haW4pO1xuICB0YShEb21haW5Eb3QsIGxvY2FscGFydEFjY2VwdGluZywgTG9jYWxwYXJ0KTtcbiAgdGEoRG9tYWluRG90LCBncm91cHMuZG9tYWluLCBEb21haW4pO1xuICBjb25zdCBEb21haW5Eb3RUbGQgPSBtYWtlU3RhdGUoVXJsKTsgLy8gU2ltcGxlc3QgcG9zc2libGUgVVJMIHdpdGggbm8gcXVlcnkgc3RyaW5nXG4gIHRhKERvbWFpbkRvdCwgZ3JvdXBzLnRsZCwgRG9tYWluRG90VGxkKTtcbiAgdGEoRG9tYWluRG90LCBncm91cHMudXRsZCwgRG9tYWluRG90VGxkKTtcbiAgdGEoRG9tYWluRG90VGxkLCBncm91cHMuZG9tYWluLCBEb21haW4pO1xuICB0YShEb21haW5Eb3RUbGQsIGxvY2FscGFydEFjY2VwdGluZywgTG9jYWxwYXJ0KTtcbiAgdHQoRG9tYWluRG90VGxkLCBET1QsIERvbWFpbkRvdCk7XG4gIHR0KERvbWFpbkRvdFRsZCwgSFlQSEVOLCBEb21haW5IeXBoZW4pO1xuICB0dChEb21haW5Eb3RUbGQsIEFULCBMb2NhbHBhcnRBdCk7XG4gIGNvbnN0IERvbWFpbkRvdFRsZENvbG9uID0gdHQoRG9tYWluRG90VGxkLCBDT0xPTik7IC8vIFVSTCBmb2xsb3dlZCBieSBjb2xvbiAocG90ZW50aWFsIHBvcnQgbnVtYmVyIGhlcmUpXG4gIGNvbnN0IERvbWFpbkRvdFRsZENvbG9uUG9ydCA9IG1ha2VTdGF0ZShVcmwpOyAvLyBUTEQgZm9sbG93ZWQgYnkgYSBwb3J0IG51bWJlclxuICB0YShEb21haW5Eb3RUbGRDb2xvbiwgZ3JvdXBzLm51bWVyaWMsIERvbWFpbkRvdFRsZENvbG9uUG9ydCk7XG5cbiAgLy8gTG9uZyBVUkwgd2l0aCBvcHRpb25hbCBwb3J0IGFuZCBtYXliZSBxdWVyeSBzdHJpbmdcbiAgY29uc3QgVXJsJDEgPSBtYWtlU3RhdGUoVXJsKTtcblxuICAvLyBVUkwgd2l0aCBleHRyYSBzeW1ib2xzIGF0IHRoZSBlbmQsIGZvbGxvd2VkIGJ5IGFuIG9wZW5pbmcgYnJhY2tldFxuICBjb25zdCBVcmxOb25hY2NlcHQgPSBtYWtlU3RhdGUoKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IHNvbWUgc3ltYm9scyAod2lsbCBub3QgYmUgcGFydCBvZiB0aGUgZmluYWwgVVJMKVxuXG4gIC8vIFF1ZXJ5IHN0cmluZ3NcbiAgdGEoVXJsJDEsIHFzQWNjZXB0aW5nLCBVcmwkMSk7XG4gIHRhKFVybCQxLCBxc05vbkFjY2VwdGluZywgVXJsTm9uYWNjZXB0KTtcbiAgdGEoVXJsTm9uYWNjZXB0LCBxc0FjY2VwdGluZywgVXJsJDEpO1xuICB0YShVcmxOb25hY2NlcHQsIHFzTm9uQWNjZXB0aW5nLCBVcmxOb25hY2NlcHQpO1xuXG4gIC8vIEJlY29tZSByZWFsIFVSTHMgYWZ0ZXIgYFNMQVNIYCBvciBgQ09MT04gTlVNIFNMQVNIYFxuICAvLyBIZXJlIHdvcmtzIHdpdGggb3Igd2l0aG91dCBzY2hlbWU6Ly8gcHJlZml4XG4gIHR0KERvbWFpbkRvdFRsZCwgU0xBU0gsIFVybCQxKTtcbiAgdHQoRG9tYWluRG90VGxkQ29sb25Qb3J0LCBTTEFTSCwgVXJsJDEpO1xuXG4gIC8vIE5vdGUgdGhhdCBkb21haW5zIHRoYXQgYmVnaW4gd2l0aCBzY2hlbWVzIGFyZSB0cmVhdGVkIHNsaWdobHkgZGlmZmVyZW50bHlcbiAgY29uc3QgU2NoZW1lQ29sb24gPSB0dChTY2hlbWUsIENPTE9OKTsgLy8gZS5nLiwgJ21haWx0bzonXG4gIGNvbnN0IFNsYXNoU2NoZW1lQ29sb24gPSB0dChTbGFzaFNjaGVtZSwgQ09MT04pOyAvLyBlLmcuLCAnaHR0cDonXG4gIGNvbnN0IFNsYXNoU2NoZW1lQ29sb25TbGFzaCA9IHR0KFNsYXNoU2NoZW1lQ29sb24sIFNMQVNIKTsgLy8gZS5nLiwgJ2h0dHA6LydcblxuICBjb25zdCBVcmlQcmVmaXggPSB0dChTbGFzaFNjaGVtZUNvbG9uU2xhc2gsIFNMQVNIKTsgLy8gZS5nLiwgJ2h0dHA6Ly8nXG5cbiAgLy8gU2NoZW1lIHN0YXRlcyBjYW4gdHJhbnNpdGlvbiB0byBkb21haW4gc3RhdGVzXG4gIHRhKFNjaGVtZSwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdHQoU2NoZW1lLCBET1QsIERvbWFpbkRvdCk7XG4gIHR0KFNjaGVtZSwgSFlQSEVOLCBEb21haW5IeXBoZW4pO1xuICB0YShTbGFzaFNjaGVtZSwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdHQoU2xhc2hTY2hlbWUsIERPVCwgRG9tYWluRG90KTtcbiAgdHQoU2xhc2hTY2hlbWUsIEhZUEhFTiwgRG9tYWluSHlwaGVuKTtcblxuICAvLyBGb3JjZSBVUkwgd2l0aCBzY2hlbWUgcHJlZml4IGZvbGxvd2VkIGJ5IGFueXRoaW5nIHNhbmVcbiAgdGEoU2NoZW1lQ29sb24sIGdyb3Vwcy5kb21haW4sIFVybCQxKTtcbiAgdHQoU2NoZW1lQ29sb24sIFNMQVNILCBVcmwkMSk7XG4gIHRhKFVyaVByZWZpeCwgZ3JvdXBzLmRvbWFpbiwgVXJsJDEpO1xuICB0YShVcmlQcmVmaXgsIHFzQWNjZXB0aW5nLCBVcmwkMSk7XG4gIHR0KFVyaVByZWZpeCwgU0xBU0gsIFVybCQxKTtcbiAgY29uc3QgYnJhY2tldFBhaXJzID0gW1tPUEVOQlJBQ0UsIENMT1NFQlJBQ0VdLFxuICAvLyB7fVxuICBbT1BFTkJSQUNLRVQsIENMT1NFQlJBQ0tFVF0sXG4gIC8vIFtdXG4gIFtPUEVOUEFSRU4sIENMT1NFUEFSRU5dLFxuICAvLyAoKVxuICBbT1BFTkFOR0xFQlJBQ0tFVCwgQ0xPU0VBTkdMRUJSQUNLRVRdLFxuICAvLyA8PlxuICBbRlVMTFdJRFRITEVGVFBBUkVOLCBGVUxMV0lEVEhSSUdIVFBBUkVOXSxcbiAgLy8gXHVGRjA4XHVGRjA5XG4gIFtMRUZUQ09STkVSQlJBQ0tFVCwgUklHSFRDT1JORVJCUkFDS0VUXSxcbiAgLy8gXHUzMDBDXHUzMDBEXG4gIFtMRUZUV0hJVEVDT1JORVJCUkFDS0VULCBSSUdIVFdISVRFQ09STkVSQlJBQ0tFVF0sXG4gIC8vIFx1MzAwRVx1MzAwRlxuICBbRlVMTFdJRFRITEVTU1RIQU4sIEZVTExXSURUSEdSRUFURVJUSEFOXSAvLyBcdUZGMUNcdUZGMUVcbiAgXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJyYWNrZXRQYWlycy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFtPUEVOLCBDTE9TRV0gPSBicmFja2V0UGFpcnNbaV07XG4gICAgY29uc3QgVXJsT3BlbiA9IHR0KFVybCQxLCBPUEVOKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IG9wZW4gYnJhY2tldFxuXG4gICAgLy8gQ29udGludWUgbm90IGFjY2VwdGluZyBmb3Igb3BlbiBicmFja2V0c1xuICAgIHR0KFVybE5vbmFjY2VwdCwgT1BFTiwgVXJsT3Blbik7XG5cbiAgICAvLyBDbG9zaW5nIGJyYWNrZXQgY29tcG9uZW50LiBUaGlzIGNoYXJhY3RlciBXSUxMIGJlIGluY2x1ZGVkIGluIHRoZSBVUkxcbiAgICB0dChVcmxPcGVuLCBDTE9TRSwgVXJsJDEpO1xuXG4gICAgLy8gVVJMIHRoYXQgYmVpbmdzIHdpdGggYW4gb3BlbmluZyBicmFja2V0LCBmb2xsb3dlZCBieSBhIHN5bWJvbHMuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBmaW5hbCBzdGF0ZSBjYW4gc3RpbGwgYmUgYFVybE9wZW5gIChpZiB0aGUgVVJMIGhhcyBhXG4gICAgLy8gc2luZ2xlIG9wZW5pbmcgYnJhY2tldCBmb3Igc29tZSByZWFzb24pLlxuICAgIGNvbnN0IFVybE9wZW5RID0gbWFrZVN0YXRlKFVybCk7XG4gICAgdGEoVXJsT3BlbiwgcXNBY2NlcHRpbmcsIFVybE9wZW5RKTtcbiAgICBjb25zdCBVcmxPcGVuU3ltcyA9IG1ha2VTdGF0ZSgpOyAvLyBVcmxPcGVuIGZvbGxvd2VkIGJ5IHNvbWUgc3ltYm9scyBpdCBjYW5ub3QgZW5kIGl0XG4gICAgdGEoVXJsT3BlbiwgcXNOb25BY2NlcHRpbmcpO1xuXG4gICAgLy8gVVJMIHRoYXQgYmVnaW5zIHdpdGggYW4gb3BlbmluZyBicmFja2V0LCBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHNcbiAgICB0YShVcmxPcGVuUSwgcXNBY2NlcHRpbmcsIFVybE9wZW5RKTtcbiAgICB0YShVcmxPcGVuUSwgcXNOb25BY2NlcHRpbmcsIFVybE9wZW5TeW1zKTtcbiAgICB0YShVcmxPcGVuU3ltcywgcXNBY2NlcHRpbmcsIFVybE9wZW5RKTtcbiAgICB0YShVcmxPcGVuU3ltcywgcXNOb25BY2NlcHRpbmcsIFVybE9wZW5TeW1zKTtcblxuICAgIC8vIENsb3NlIGJyYWNlL2JyYWNrZXQgdG8gYmVjb21lIHJlZ3VsYXIgVVJMXG4gICAgdHQoVXJsT3BlblEsIENMT1NFLCBVcmwkMSk7XG4gICAgdHQoVXJsT3BlblN5bXMsIENMT1NFLCBVcmwkMSk7XG4gIH1cbiAgdHQoU3RhcnQsIExPQ0FMSE9TVCwgRG9tYWluRG90VGxkKTsgLy8gbG9jYWxob3N0IGlzIGEgdmFsaWQgVVJMIHN0YXRlXG4gIHR0KFN0YXJ0LCBOTCQxLCBObCk7IC8vIHNpbmdsZSBuZXcgbGluZVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IFN0YXJ0LFxuICAgIHRva2VuczogdGtcbiAgfTtcbn1cblxuLyoqXG4gKiBSdW4gdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lIG9uIGEgbGlzdCBvZiBzY2FubmVkIHN0cmluZy1iYXNlZCB0b2tlbnMgdG9cbiAqIGNyZWF0ZSBhIGxpc3Qgb2YgbXVsdGkgdG9rZW5zLCBlYWNoIG9mIHdoaWNoIHJlcHJlc2VudHMgYSBVUkwsIGVtYWlsIGFkZHJlc3MsXG4gKiBwbGFpbiB0ZXh0LCBldGMuXG4gKlxuICogQHBhcmFtIHtTdGF0ZTxNdWx0aVRva2VuPn0gc3RhcnQgcGFyc2VyIHN0YXJ0IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgdGhlIG9yaWdpbmFsIGlucHV0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGdpdmVuIHRva2Vuc1xuICogQHBhcmFtIHtUb2tlbltdfSB0b2tlbnMgbGlzdCBvZiBzY2FubmVkIHRva2Vuc1xuICogQHJldHVybnMge011bHRpVG9rZW5bXX1cbiAqL1xuZnVuY3Rpb24gcnVuKHN0YXJ0LCBpbnB1dCwgdG9rZW5zKSB7XG4gIGxldCBsZW4gPSB0b2tlbnMubGVuZ3RoO1xuICBsZXQgY3Vyc29yID0gMDtcbiAgbGV0IG11bHRpcyA9IFtdO1xuICBsZXQgdGV4dFRva2VucyA9IFtdO1xuICB3aGlsZSAoY3Vyc29yIDwgbGVuKSB7XG4gICAgbGV0IHN0YXRlID0gc3RhcnQ7XG4gICAgbGV0IHNlY29uZFN0YXRlID0gbnVsbDtcbiAgICBsZXQgbmV4dFN0YXRlID0gbnVsbDtcbiAgICBsZXQgbXVsdGlMZW5ndGggPSAwO1xuICAgIGxldCBsYXRlc3RBY2NlcHRpbmcgPSBudWxsO1xuICAgIGxldCBzaW5jZUFjY2VwdHMgPSAtMTtcbiAgICB3aGlsZSAoY3Vyc29yIDwgbGVuICYmICEoc2Vjb25kU3RhdGUgPSBzdGF0ZS5nbyh0b2tlbnNbY3Vyc29yXS50KSkpIHtcbiAgICAgIC8vIFN0YXJ0aW5nIHRva2VucyB3aXRoIG5vd2hlcmUgdG8ganVtcCB0by5cbiAgICAgIC8vIENvbnNpZGVyIHRoZXNlIHRvIGJlIGp1c3QgcGxhaW4gdGV4dFxuICAgICAgdGV4dFRva2Vucy5wdXNoKHRva2Vuc1tjdXJzb3IrK10pO1xuICAgIH1cbiAgICB3aGlsZSAoY3Vyc29yIDwgbGVuICYmIChuZXh0U3RhdGUgPSBzZWNvbmRTdGF0ZSB8fCBzdGF0ZS5nbyh0b2tlbnNbY3Vyc29yXS50KSkpIHtcbiAgICAgIC8vIEdldCB0aGUgbmV4dCBzdGF0ZVxuICAgICAgc2Vjb25kU3RhdGUgPSBudWxsO1xuICAgICAgc3RhdGUgPSBuZXh0U3RhdGU7XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhdGVzdCBhY2NlcHRpbmcgc3RhdGVcbiAgICAgIGlmIChzdGF0ZS5hY2NlcHRzKCkpIHtcbiAgICAgICAgc2luY2VBY2NlcHRzID0gMDtcbiAgICAgICAgbGF0ZXN0QWNjZXB0aW5nID0gc3RhdGU7XG4gICAgICB9IGVsc2UgaWYgKHNpbmNlQWNjZXB0cyA+PSAwKSB7XG4gICAgICAgIHNpbmNlQWNjZXB0cysrO1xuICAgICAgfVxuICAgICAgY3Vyc29yKys7XG4gICAgICBtdWx0aUxlbmd0aCsrO1xuICAgIH1cbiAgICBpZiAoc2luY2VBY2NlcHRzIDwgMCkge1xuICAgICAgLy8gTm8gYWNjZXB0aW5nIHN0YXRlIHdhcyBmb3VuZCwgcGFydCBvZiBhIHJlZ3VsYXIgdGV4dCB0b2tlbiBhZGRcbiAgICAgIC8vIHRoZSBmaXJzdCB0ZXh0IHRva2VuIHRvIHRoZSB0ZXh0IHRva2VucyBhcnJheSBhbmQgdHJ5IGFnYWluIGZyb21cbiAgICAgIC8vIHRoZSBuZXh0XG4gICAgICBjdXJzb3IgLT0gbXVsdGlMZW5ndGg7XG4gICAgICBpZiAoY3Vyc29yIDwgbGVuKSB7XG4gICAgICAgIHRleHRUb2tlbnMucHVzaCh0b2tlbnNbY3Vyc29yXSk7XG4gICAgICAgIGN1cnNvcisrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBY2NlcHRpbmcgc3RhdGUhXG4gICAgICAvLyBGaXJzdCBjbG9zZSBvZmYgdGhlIHRleHRUb2tlbnMgKGlmIGF2YWlsYWJsZSlcbiAgICAgIGlmICh0ZXh0VG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbXVsdGlzLnB1c2goaW5pdE11bHRpVG9rZW4oVGV4dCwgaW5wdXQsIHRleHRUb2tlbnMpKTtcbiAgICAgICAgdGV4dFRva2VucyA9IFtdO1xuICAgICAgfVxuXG4gICAgICAvLyBSb2xsIGJhY2sgdG8gdGhlIGxhdGVzdCBhY2NlcHRpbmcgc3RhdGVcbiAgICAgIGN1cnNvciAtPSBzaW5jZUFjY2VwdHM7XG4gICAgICBtdWx0aUxlbmd0aCAtPSBzaW5jZUFjY2VwdHM7XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBtdWx0aXRva2VuXG4gICAgICBjb25zdCBNdWx0aSA9IGxhdGVzdEFjY2VwdGluZy50O1xuICAgICAgY29uc3Qgc3VidG9rZW5zID0gdG9rZW5zLnNsaWNlKGN1cnNvciAtIG11bHRpTGVuZ3RoLCBjdXJzb3IpO1xuICAgICAgbXVsdGlzLnB1c2goaW5pdE11bHRpVG9rZW4oTXVsdGksIGlucHV0LCBzdWJ0b2tlbnMpKTtcbiAgICB9XG4gIH1cblxuICAvLyBGaW5hbGx5IGNsb3NlIG9mZiB0aGUgdGV4dFRva2VucyAoaWYgYXZhaWxhYmxlKVxuICBpZiAodGV4dFRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgbXVsdGlzLnB1c2goaW5pdE11bHRpVG9rZW4oVGV4dCwgaW5wdXQsIHRleHRUb2tlbnMpKTtcbiAgfVxuICByZXR1cm4gbXVsdGlzO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGluc3RhbnRpYXRpbmcgYSBuZXcgbXVsdGl0b2tlbiB3aXRoIGFsbCB0aGUgcmVsZXZhbnRcbiAqIGZpZWxkcyBkdXJpbmcgcGFyc2luZy5cbiAqIEBwYXJhbSB7bmV3ICh2YWx1ZTogc3RyaW5nLCB0b2tlbnM6IFRva2VuW10pID0+IE11bHRpVG9rZW59IE11bHRpIGNsYXNzIHRvIGluc3RhbnRpYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgb3JpZ2luYWwgaW5wdXQgc3RyaW5nXG4gKiBAcGFyYW0ge1Rva2VuW119IHRva2VucyBjb25zZWN1dGl2ZSB0b2tlbnMgc2Nhbm5lZCBmcm9tIGlucHV0IHN0cmluZ1xuICogQHJldHVybnMge011bHRpVG9rZW59XG4gKi9cbmZ1bmN0aW9uIGluaXRNdWx0aVRva2VuKE11bHRpLCBpbnB1dCwgdG9rZW5zKSB7XG4gIGNvbnN0IHN0YXJ0SWR4ID0gdG9rZW5zWzBdLnM7XG4gIGNvbnN0IGVuZElkeCA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0uZTtcbiAgY29uc3QgdmFsdWUgPSBpbnB1dC5zbGljZShzdGFydElkeCwgZW5kSWR4KTtcbiAgcmV0dXJuIG5ldyBNdWx0aSh2YWx1ZSwgdG9rZW5zKTtcbn1cblxuY29uc3Qgd2FybiA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlICYmIGNvbnNvbGUud2FybiB8fCAoKCkgPT4ge30pO1xuY29uc3Qgd2FybkFkdmljZSA9ICd1bnRpbCBtYW51YWwgY2FsbCBvZiBsaW5raWZ5LmluaXQoKS4gUmVnaXN0ZXIgYWxsIHNjaGVtZXMgYW5kIHBsdWdpbnMgYmVmb3JlIGludm9raW5nIGxpbmtpZnkgdGhlIGZpcnN0IHRpbWUuJztcblxuLy8gU2lkZS1lZmZlY3QgaW5pdGlhbGl6YXRpb24gc3RhdGVcbmNvbnN0IElOSVQgPSB7XG4gIHNjYW5uZXI6IG51bGwsXG4gIHBhcnNlcjogbnVsbCxcbiAgdG9rZW5RdWV1ZTogW10sXG4gIHBsdWdpblF1ZXVlOiBbXSxcbiAgY3VzdG9tU2NoZW1lczogW10sXG4gIGluaXRpYWxpemVkOiBmYWxzZVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogXHRzdGFydDogU3RhdGU8c3RyaW5nPixcbiAqIFx0dG9rZW5zOiB7IGdyb3VwczogQ29sbGVjdGlvbnM8c3RyaW5nPiB9ICYgdHlwZW9mIHRrXG4gKiB9fSBTY2FubmVySW5pdFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqIFx0c3RhcnQ6IFN0YXRlPE11bHRpVG9rZW4+LFxuICogXHR0b2tlbnM6IHR5cGVvZiBtdWx0aVxuICogfX0gUGFyc2VySW5pdFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhhcmc6IHsgc2Nhbm5lcjogU2Nhbm5lckluaXQgfSkgPT4gdm9pZH0gVG9rZW5QbHVnaW5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoYXJnOiB7IHNjYW5uZXI6IFNjYW5uZXJJbml0LCBwYXJzZXI6IFBhcnNlckluaXQgfSkgPT4gdm9pZH0gUGx1Z2luXG4gKi9cblxuLyoqXG4gKiBEZS1yZWdpc3RlciBhbGwgcGx1Z2lucyBhbmQgcmVzZXQgdGhlIGludGVybmFsIHN0YXRlLW1hY2hpbmUuIFVzZWQgZm9yXG4gKiB0ZXN0aW5nOyBub3QgcmVxdWlyZWQgaW4gcHJhY3RpY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNldCgpIHtcbiAgU3RhdGUuZ3JvdXBzID0ge307XG4gIElOSVQuc2Nhbm5lciA9IG51bGw7XG4gIElOSVQucGFyc2VyID0gbnVsbDtcbiAgSU5JVC50b2tlblF1ZXVlID0gW107XG4gIElOSVQucGx1Z2luUXVldWUgPSBbXTtcbiAgSU5JVC5jdXN0b21TY2hlbWVzID0gW107XG4gIElOSVQuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlciBhIHRva2VuIHBsdWdpbiB0byBhbGxvdyB0aGUgc2Nhbm5lciB0byByZWNvZ25pemUgYWRkaXRpb25hbCB0b2tlblxuICogdHlwZXMgYmVmb3JlIHRoZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBpcyBjb25zdHJ1Y3RlZCBmcm9tIHRoZSByZXN1bHRzLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgb2YgcGx1Z2luIHRvIHJlZ2lzdGVyXG4gKiBAcGFyYW0ge1Rva2VuUGx1Z2lufSBwbHVnaW4gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSBzY2FubmVyIHN0YXRlIG1hY2hpbmVcbiAqIGFuZCBhdmFpbGFibGUgc2Nhbm5lciB0b2tlbnMgYW5kIGNvbGxlY3Rpb25zIGFuZCBleHRlbmRzIHRoZSBzdGF0ZSBtYWNoaW5lIHRvXG4gKiByZWNvZ25pemUgYWRkaXRpb25hbCB0b2tlbnMgb3IgZ3JvdXBzLlxuICovXG5mdW5jdGlvbiByZWdpc3RlclRva2VuUGx1Z2luKG5hbWUsIHBsdWdpbikge1xuICBpZiAodHlwZW9mIHBsdWdpbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgbGlua2lmeWpzOiBJbnZhbGlkIHRva2VuIHBsdWdpbiAke3BsdWdpbn0gKGV4cGVjdHMgZnVuY3Rpb24pYCk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBJTklULnRva2VuUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobmFtZSA9PT0gSU5JVC50b2tlblF1ZXVlW2ldWzBdKSB7XG4gICAgICB3YXJuKGBsaW5raWZ5anM6IHRva2VuIHBsdWdpbiBcIiR7bmFtZX1cIiBhbHJlYWR5IHJlZ2lzdGVyZWQgLSB3aWxsIGJlIG92ZXJ3cml0dGVuYCk7XG4gICAgICBJTklULnRva2VuUXVldWVbaV0gPSBbbmFtZSwgcGx1Z2luXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgSU5JVC50b2tlblF1ZXVlLnB1c2goW25hbWUsIHBsdWdpbl0pO1xuICBpZiAoSU5JVC5pbml0aWFsaXplZCkge1xuICAgIHdhcm4oYGxpbmtpZnlqczogYWxyZWFkeSBpbml0aWFsaXplZCAtIHdpbGwgbm90IHJlZ2lzdGVyIHRva2VuIHBsdWdpbiBcIiR7bmFtZX1cIiAke3dhcm5BZHZpY2V9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlciBhIGxpbmtpZnkgcGx1Z2luXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBvZiBwbHVnaW4gdG8gcmVnaXN0ZXJcbiAqIEBwYXJhbSB7UGx1Z2lufSBwbHVnaW4gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBhbmRcbiAqIGV4dGVuZHMgdGhlIHBhcnNlciB0byByZWNvZ25pemUgYWRkaXRpb25hbCBsaW5rIHR5cGVzXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKG5hbWUsIHBsdWdpbikge1xuICBpZiAodHlwZW9mIHBsdWdpbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgbGlua2lmeWpzOiBJbnZhbGlkIHBsdWdpbiAke3BsdWdpbn0gKGV4cGVjdHMgZnVuY3Rpb24pYCk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBJTklULnBsdWdpblF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5hbWUgPT09IElOSVQucGx1Z2luUXVldWVbaV1bMF0pIHtcbiAgICAgIHdhcm4oYGxpbmtpZnlqczogcGx1Z2luIFwiJHtuYW1lfVwiIGFscmVhZHkgcmVnaXN0ZXJlZCAtIHdpbGwgYmUgb3ZlcndyaXR0ZW5gKTtcbiAgICAgIElOSVQucGx1Z2luUXVldWVbaV0gPSBbbmFtZSwgcGx1Z2luXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgSU5JVC5wbHVnaW5RdWV1ZS5wdXNoKFtuYW1lLCBwbHVnaW5dKTtcbiAgaWYgKElOSVQuaW5pdGlhbGl6ZWQpIHtcbiAgICB3YXJuKGBsaW5raWZ5anM6IGFscmVhZHkgaW5pdGlhbGl6ZWQgLSB3aWxsIG5vdCByZWdpc3RlciBwbHVnaW4gXCIke25hbWV9XCIgJHt3YXJuQWR2aWNlfWApO1xuICB9XG59XG5cbi8qKlxuICogRGV0ZWN0IFVSTHMgd2l0aCB0aGUgZm9sbG93aW5nIGFkZGl0aW9uYWwgcHJvdG9jb2wuIEFueXRoaW5nIHdpdGggZm9ybWF0XG4gKiBcInByb3RvY29sOi8vLi4uXCIgd2lsbCBiZSBjb25zaWRlcmVkIGEgbGluay4gSWYgYG9wdGlvbmFsU2xhc2hTbGFzaGAgaXMgc2V0IHRvXG4gKiBgdHJ1ZWAsIGFueXRoaW5nIHdpdGggZm9ybWF0IFwicHJvdG9jb2w6Li4uXCIgd2lsbCBiZSBjb25zaWRlcmVkIGEgbGluay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9uYWxTbGFzaFNsYXNoXVxuICovXG5mdW5jdGlvbiByZWdpc3RlckN1c3RvbVByb3RvY29sKHNjaGVtZSwgb3B0aW9uYWxTbGFzaFNsYXNoKSB7XG4gIGlmIChvcHRpb25hbFNsYXNoU2xhc2ggPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbmFsU2xhc2hTbGFzaCA9IGZhbHNlO1xuICB9XG4gIGlmIChJTklULmluaXRpYWxpemVkKSB7XG4gICAgd2FybihgbGlua2lmeWpzOiBhbHJlYWR5IGluaXRpYWxpemVkIC0gd2lsbCBub3QgcmVnaXN0ZXIgY3VzdG9tIHNjaGVtZSBcIiR7c2NoZW1lfVwiICR7d2FybkFkdmljZX1gKTtcbiAgfVxuICBpZiAoIS9eWzAtOWEtel0rKC1bMC05YS16XSspKiQvLnRlc3Qoc2NoZW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbGlua2lmeWpzOiBpbmNvcnJlY3Qgc2NoZW1lIGZvcm1hdC5cbjEuIE11c3Qgb25seSBjb250YWluIGRpZ2l0cywgbG93ZXJjYXNlIEFTQ0lJIGxldHRlcnMgb3IgXCItXCJcbjIuIENhbm5vdCBzdGFydCBvciBlbmQgd2l0aCBcIi1cIlxuMy4gXCItXCIgY2Fubm90IHJlcGVhdGApO1xuICB9XG4gIElOSVQuY3VzdG9tU2NoZW1lcy5wdXNoKFtzY2hlbWUsIG9wdGlvbmFsU2xhc2hTbGFzaF0pO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGxpbmtpZnkgc3RhdGUgbWFjaGluZS4gQ2FsbGVkIGF1dG9tYXRpY2FsbHkgdGhlIGZpcnN0IHRpbWVcbiAqIGxpbmtpZnkgaXMgY2FsbGVkIG9uIGEgc3RyaW5nLCBidXQgbWF5IGJlIGNhbGxlZCBtYW51YWxseSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBpbml0KCkge1xuICAvLyBJbml0aWFsaXplIHNjYW5uZXIgc3RhdGUgbWFjaGluZSBhbmQgcGx1Z2luc1xuICBJTklULnNjYW5uZXIgPSBpbml0JDIoSU5JVC5jdXN0b21TY2hlbWVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBJTklULnRva2VuUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBJTklULnRva2VuUXVldWVbaV1bMV0oe1xuICAgICAgc2Nhbm5lcjogSU5JVC5zY2FubmVyXG4gICAgfSk7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIHBhcnNlciBzdGF0ZSBtYWNoaW5lIGFuZCBwbHVnaW5zXG4gIElOSVQucGFyc2VyID0gaW5pdCQxKElOSVQuc2Nhbm5lci50b2tlbnMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IElOSVQucGx1Z2luUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBJTklULnBsdWdpblF1ZXVlW2ldWzFdKHtcbiAgICAgIHNjYW5uZXI6IElOSVQuc2Nhbm5lcixcbiAgICAgIHBhcnNlcjogSU5JVC5wYXJzZXJcbiAgICB9KTtcbiAgfVxuICBJTklULmluaXRpYWxpemVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBpbnRvIHRva2VucyB0aGF0IHJlcHJlc2VudCBsaW5rYWJsZSBhbmQgbm9uLWxpbmthYmxlIHN1Yi1jb21wb25lbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtNdWx0aVRva2VuW119IHRva2Vuc1xuICovXG5mdW5jdGlvbiB0b2tlbml6ZShzdHIpIHtcbiAgaWYgKCFJTklULmluaXRpYWxpemVkKSB7XG4gICAgaW5pdCgpO1xuICB9XG4gIHJldHVybiBydW4oSU5JVC5wYXJzZXIuc3RhcnQsIHN0ciwgcnVuJDEoSU5JVC5zY2FubmVyLnN0YXJ0LCBzdHIpKTtcbn1cblxuLyoqXG4gKiBGaW5kIGEgbGlzdCBvZiBsaW5rYWJsZSBpdGVtcyBpbiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBzdHJpbmcgdG8gZmluZCBsaW5rcyBpblxuICogQHBhcmFtIHtzdHJpbmcgfCBPcHRzfSBbdHlwZV0gZWl0aGVyIGZvcm1hdHRpbmcgb3B0aW9ucyBvciBzcGVjaWZpYyB0eXBlIG9mXG4gKiBsaW5rcyB0byBmaW5kLCBlLmcuLCAndXJsJyBvciAnZW1haWwnXG4gKiBAcGFyYW0ge09wdHN9IFtvcHRzXSBmb3JtYXR0aW5nIG9wdGlvbnMgZm9yIGZpbmFsIG91dHB1dC4gQ2Fubm90IGJlIHNwZWNpZmllZFxuICogaWYgb3B0cyBhbHJlYWR5IHByb3ZpZGVkIGluIGB0eXBlYCBhcmd1bWVudFxuICovXG5mdW5jdGlvbiBmaW5kKHN0ciwgdHlwZSwgb3B0cykge1xuICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSBudWxsO1xuICB9XG4gIGlmICh0eXBlICYmIHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChvcHRzKSB7XG4gICAgICB0aHJvdyBFcnJvcihgbGlua2lmeWpzOiBJbnZhbGlkIGxpbmsgdHlwZSAke3R5cGV9OyBtdXN0IGJlIGEgc3RyaW5nYCk7XG4gICAgfVxuICAgIG9wdHMgPSB0eXBlO1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBuZXcgT3B0aW9ucyhvcHRzKTtcbiAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUoc3RyKTtcbiAgY29uc3QgZmlsdGVyZWQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBpZiAodG9rZW4uaXNMaW5rICYmICghdHlwZSB8fCB0b2tlbi50ID09PSB0eXBlKSAmJiBvcHRpb25zLmNoZWNrKHRva2VuKSkge1xuICAgICAgZmlsdGVyZWQucHVzaCh0b2tlbi50b0Zvcm1hdHRlZE9iamVjdChvcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWx0ZXJlZDtcbn1cblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIHZhbGlkIGxpbmthYmxlIHRleHQgb2Ygc29tZSBzb3J0LiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdFxuICogdHJpbSB0aGUgdGV4dCBmb3IgeW91LlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBhIHNlY29uZCBgdHlwZWAgcGFyYW0sIHdoaWNoIGlzIHRoZSB0eXBlIG9mIGxpbmsgdG8gdGVzdFxuICogZm9yLlxuICpcbiAqIEZvciBleGFtcGxlLFxuICpcbiAqICAgICBsaW5raWZ5LnRlc3Qoc3RyLCAnZW1haWwnKTtcbiAqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBzdHIgaXMgYSB2YWxpZCBlbWFpbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgc3RyaW5nIHRvIHRlc3QgZm9yIGxpbmtzXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG9wdGlvbmFsIHNwZWNpZmljIGxpbmsgdHlwZSB0byBsb29rIGZvclxuICogQHJldHVybnMgYm9vbGVhbiB0cnVlL2ZhbHNlXG4gKi9cbmZ1bmN0aW9uIHRlc3Qoc3RyLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICB0eXBlID0gbnVsbDtcbiAgfVxuICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZShzdHIpO1xuICByZXR1cm4gdG9rZW5zLmxlbmd0aCA9PT0gMSAmJiB0b2tlbnNbMF0uaXNMaW5rICYmICghdHlwZSB8fCB0b2tlbnNbMF0udCA9PT0gdHlwZSk7XG59XG5cbmV4cG9ydCB7IE11bHRpVG9rZW4sIE9wdGlvbnMsIFN0YXRlLCBjcmVhdGVUb2tlbkNsYXNzLCBmaW5kLCBpbml0LCBtdWx0aSwgb3B0aW9ucywgcmVnZXhwLCByZWdpc3RlckN1c3RvbVByb3RvY29sLCByZWdpc3RlclBsdWdpbiwgcmVnaXN0ZXJUb2tlblBsdWdpbiwgcmVzZXQsIHN0cmluZ1RvQXJyYXksIHRlc3QsIHRva2VuaXplIH07XG4iLCAiaW1wb3J0IHtcbiAgY29tYmluZVRyYW5zYWN0aW9uU3RlcHMsXG4gIGZpbmRDaGlsZHJlbkluUmFuZ2UsXG4gIGdldENoYW5nZWRSYW5nZXMsXG4gIGdldE1hcmtzQmV0d2VlbixcbiAgTm9kZVdpdGhQb3MsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IGZpbmQgfSBmcm9tICdsaW5raWZ5anMnXG5cbnR5cGUgQXV0b2xpbmtPcHRpb25zID0ge1xuICB0eXBlOiBNYXJrVHlwZVxuICB2YWxpZGF0ZT86ICh1cmw6IHN0cmluZykgPT4gYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXV0b2xpbmsob3B0aW9uczogQXV0b2xpbmtPcHRpb25zKTogUGx1Z2luIHtcbiAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgIGtleTogbmV3IFBsdWdpbktleSgnYXV0b2xpbmsnKSxcbiAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHRyYW5zYWN0aW9ucywgb2xkU3RhdGUsIG5ld1N0YXRlKSA9PiB7XG4gICAgICBjb25zdCBkb2NDaGFuZ2VzID0gdHJhbnNhY3Rpb25zLnNvbWUodHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZCkgJiYgIW9sZFN0YXRlLmRvYy5lcShuZXdTdGF0ZS5kb2MpXG4gICAgICBjb25zdCBwcmV2ZW50QXV0b2xpbmsgPSB0cmFuc2FjdGlvbnMuc29tZSh0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5nZXRNZXRhKCdwcmV2ZW50QXV0b2xpbmsnKSlcblxuICAgICAgaWYgKCFkb2NDaGFuZ2VzIHx8IHByZXZlbnRBdXRvbGluaykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyB0ciB9ID0gbmV3U3RhdGVcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzKG9sZFN0YXRlLmRvYywgWy4uLnRyYW5zYWN0aW9uc10pXG4gICAgICBjb25zdCBjaGFuZ2VzID0gZ2V0Q2hhbmdlZFJhbmdlcyh0cmFuc2Zvcm0pXG5cbiAgICAgIGNoYW5nZXMuZm9yRWFjaCgoeyBuZXdSYW5nZSB9KSA9PiB7XG4gICAgICAgIC8vIE5vdyBsZXTigJlzIHNlZSBpZiB3ZSBjYW4gYWRkIG5ldyBsaW5rcy5cbiAgICAgICAgY29uc3Qgbm9kZXNJbkNoYW5nZWRSYW5nZXMgPSBmaW5kQ2hpbGRyZW5JblJhbmdlKFxuICAgICAgICAgIG5ld1N0YXRlLmRvYyxcbiAgICAgICAgICBuZXdSYW5nZSxcbiAgICAgICAgICBub2RlID0+IG5vZGUuaXNUZXh0YmxvY2ssXG4gICAgICAgIClcblxuICAgICAgICBsZXQgdGV4dEJsb2NrOiBOb2RlV2l0aFBvcyB8IHVuZGVmaW5lZFxuICAgICAgICBsZXQgdGV4dEJlZm9yZVdoaXRlc3BhY2U6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmIChub2Rlc0luQ2hhbmdlZFJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgLy8gR3JhYiB0aGUgZmlyc3Qgbm9kZSB3aXRoaW4gdGhlIGNoYW5nZWQgcmFuZ2VzIChleC4gdGhlIGZpcnN0IG9mIHR3byBwYXJhZ3JhcGhzIHdoZW4gaGl0dGluZyBlbnRlcikuXG4gICAgICAgICAgdGV4dEJsb2NrID0gbm9kZXNJbkNoYW5nZWRSYW5nZXNbMF1cbiAgICAgICAgICB0ZXh0QmVmb3JlV2hpdGVzcGFjZSA9IG5ld1N0YXRlLmRvYy50ZXh0QmV0d2VlbihcbiAgICAgICAgICAgIHRleHRCbG9jay5wb3MsXG4gICAgICAgICAgICB0ZXh0QmxvY2sucG9zICsgdGV4dEJsb2NrLm5vZGUubm9kZVNpemUsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAnICcsXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIG5vZGVzSW5DaGFuZ2VkUmFuZ2VzLmxlbmd0aFxuICAgICAgICAgIC8vIFdlIHdhbnQgdG8gbWFrZSBzdXJlIHRvIGluY2x1ZGUgdGhlIGJsb2NrIHNlcGVyYXRvciBhcmd1bWVudCB0byB0cmVhdCBoYXJkIGJyZWFrcyBsaWtlIHNwYWNlcy5cbiAgICAgICAgICAmJiBuZXdTdGF0ZS5kb2MudGV4dEJldHdlZW4obmV3UmFuZ2UuZnJvbSwgbmV3UmFuZ2UudG8sICcgJywgJyAnKS5lbmRzV2l0aCgnICcpXG4gICAgICAgICkge1xuICAgICAgICAgIHRleHRCbG9jayA9IG5vZGVzSW5DaGFuZ2VkUmFuZ2VzWzBdXG4gICAgICAgICAgdGV4dEJlZm9yZVdoaXRlc3BhY2UgPSBuZXdTdGF0ZS5kb2MudGV4dEJldHdlZW4oXG4gICAgICAgICAgICB0ZXh0QmxvY2sucG9zLFxuICAgICAgICAgICAgbmV3UmFuZ2UudG8sXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAnICcsXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRCbG9jayAmJiB0ZXh0QmVmb3JlV2hpdGVzcGFjZSkge1xuICAgICAgICAgIGNvbnN0IHdvcmRzQmVmb3JlV2hpdGVzcGFjZSA9IHRleHRCZWZvcmVXaGl0ZXNwYWNlLnNwbGl0KCcgJykuZmlsdGVyKHMgPT4gcyAhPT0gJycpXG5cbiAgICAgICAgICBpZiAod29yZHNCZWZvcmVXaGl0ZXNwYWNlLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBsYXN0V29yZEJlZm9yZVNwYWNlID0gd29yZHNCZWZvcmVXaGl0ZXNwYWNlW3dvcmRzQmVmb3JlV2hpdGVzcGFjZS5sZW5ndGggLSAxXVxuICAgICAgICAgIGNvbnN0IGxhc3RXb3JkQW5kQmxvY2tPZmZzZXQgPSB0ZXh0QmxvY2sucG9zICsgdGV4dEJlZm9yZVdoaXRlc3BhY2UubGFzdEluZGV4T2YobGFzdFdvcmRCZWZvcmVTcGFjZSlcblxuICAgICAgICAgIGlmICghbGFzdFdvcmRCZWZvcmVTcGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmluZChsYXN0V29yZEJlZm9yZVNwYWNlKVxuICAgICAgICAgICAgLmZpbHRlcihsaW5rID0+IGxpbmsuaXNMaW5rKVxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGxpbmsgcG9zaXRpb24uXG4gICAgICAgICAgICAubWFwKGxpbmsgPT4gKHtcbiAgICAgICAgICAgICAgLi4ubGluayxcbiAgICAgICAgICAgICAgZnJvbTogbGFzdFdvcmRBbmRCbG9ja09mZnNldCArIGxpbmsuc3RhcnQgKyAxLFxuICAgICAgICAgICAgICB0bzogbGFzdFdvcmRBbmRCbG9ja09mZnNldCArIGxpbmsuZW5kICsgMSxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLy8gaWdub3JlIGxpbmsgaW5zaWRlIGNvZGUgbWFya1xuICAgICAgICAgICAgLmZpbHRlcihsaW5rID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZS5zY2hlbWEubWFya3MuY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gIW5ld1N0YXRlLmRvYy5yYW5nZUhhc01hcmsoXG4gICAgICAgICAgICAgICAgbGluay5mcm9tLFxuICAgICAgICAgICAgICAgIGxpbmsudG8sXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUuc2NoZW1hLm1hcmtzLmNvZGUsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvLyB2YWxpZGF0ZSBsaW5rXG4gICAgICAgICAgICAuZmlsdGVyKGxpbmsgPT4ge1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy52YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnZhbGlkYXRlKGxpbmsudmFsdWUpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvLyBBZGQgbGluayBtYXJrLlxuICAgICAgICAgICAgLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgICAgICAgIGlmIChnZXRNYXJrc0JldHdlZW4obGluay5mcm9tLCBsaW5rLnRvLCBuZXdTdGF0ZS5kb2MpLnNvbWUoaXRlbSA9PiBpdGVtLm1hcmsudHlwZSA9PT0gb3B0aW9ucy50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdHIuYWRkTWFyayhcbiAgICAgICAgICAgICAgICBsaW5rLmZyb20sXG4gICAgICAgICAgICAgICAgbGluay50byxcbiAgICAgICAgICAgICAgICBvcHRpb25zLnR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgIGhyZWY6IGxpbmsuaHJlZixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgaWYgKCF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0clxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgZ2V0QXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxudHlwZSBDbGlja0hhbmRsZXJPcHRpb25zID0ge1xuICB0eXBlOiBNYXJrVHlwZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xpY2tIYW5kbGVyKG9wdGlvbnM6IENsaWNrSGFuZGxlck9wdGlvbnMpOiBQbHVnaW4ge1xuICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAga2V5OiBuZXcgUGx1Z2luS2V5KCdoYW5kbGVDbGlja0xpbmsnKSxcbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlQ2xpY2s6ICh2aWV3LCBwb3MsIGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG4gICAgICAgIGNvbnN0IGVscyA9IFtdXG5cbiAgICAgICAgd2hpbGUgKGEubm9kZU5hbWUgIT09ICdESVYnKSB7XG4gICAgICAgICAgZWxzLnB1c2goYSlcbiAgICAgICAgICBhID0gYS5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVscy5maW5kKHZhbHVlID0+IHZhbHVlLm5vZGVOYW1lID09PSAnQScpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhdHRycyA9IGdldEF0dHJpYnV0ZXModmlldy5zdGF0ZSwgb3B0aW9ucy50eXBlLm5hbWUpXG4gICAgICAgIGNvbnN0IGxpbmsgPSAoZXZlbnQudGFyZ2V0IGFzIEhUTUxMaW5rRWxlbWVudClcblxuICAgICAgICBjb25zdCBocmVmID0gbGluaz8uaHJlZiA/PyBhdHRycy5ocmVmXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGxpbms/LnRhcmdldCA/PyBhdHRycy50YXJnZXRcblxuICAgICAgICBpZiAobGluayAmJiBocmVmKSB7XG4gICAgICAgICAgd2luZG93Lm9wZW4oaHJlZiwgdGFyZ2V0KVxuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSxcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IEVkaXRvciB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IGZpbmQgfSBmcm9tICdsaW5raWZ5anMnXG5cbnR5cGUgUGFzdGVIYW5kbGVyT3B0aW9ucyA9IHtcbiAgZWRpdG9yOiBFZGl0b3JcbiAgdHlwZTogTWFya1R5cGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhc3RlSGFuZGxlcihvcHRpb25zOiBQYXN0ZUhhbmRsZXJPcHRpb25zKTogUGx1Z2luIHtcbiAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgIGtleTogbmV3IFBsdWdpbktleSgnaGFuZGxlUGFzdGVMaW5rJyksXG4gICAgcHJvcHM6IHtcbiAgICAgIGhhbmRsZVBhc3RlOiAodmlldywgZXZlbnQsIHNsaWNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHZpZXdcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gICAgICAgIGNvbnN0IHsgZW1wdHkgfSA9IHNlbGVjdGlvblxuXG4gICAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRleHRDb250ZW50ID0gJydcblxuICAgICAgICBzbGljZS5jb250ZW50LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgKz0gbm9kZS50ZXh0Q29udGVudFxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IGxpbmsgPSBmaW5kKHRleHRDb250ZW50KS5maW5kKGl0ZW0gPT4gaXRlbS5pc0xpbmsgJiYgaXRlbS52YWx1ZSA9PT0gdGV4dENvbnRlbnQpXG5cbiAgICAgICAgaWYgKCF0ZXh0Q29udGVudCB8fCAhbGluaykge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy5lZGl0b3IuY29tbWFuZHMuc2V0TWFyayhvcHRpb25zLnR5cGUsIHtcbiAgICAgICAgICBocmVmOiBsaW5rLmhyZWYsXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0sXG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQge1xuICBNYXJrLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMsIFBhc3RlUnVsZU1hdGNoLFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgZmluZCwgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbCwgcmVzZXQgfSBmcm9tICdsaW5raWZ5anMnXG5cbmltcG9ydCB7IGF1dG9saW5rIH0gZnJvbSAnLi9oZWxwZXJzL2F1dG9saW5rLmpzJ1xuaW1wb3J0IHsgY2xpY2tIYW5kbGVyIH0gZnJvbSAnLi9oZWxwZXJzL2NsaWNrSGFuZGxlci5qcydcbmltcG9ydCB7IHBhc3RlSGFuZGxlciB9IGZyb20gJy4vaGVscGVycy9wYXN0ZUhhbmRsZXIuanMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlua1Byb3RvY29sT3B0aW9ucyB7XG4gIHNjaGVtZTogc3RyaW5nO1xuICBvcHRpb25hbFNsYXNoZXM/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgcGFzdGVSZWdleCA9IC9odHRwcz86XFwvXFwvKD86d3d3XFwuKT9bLWEtekEtWjAtOUA6JS5fK34jPV17MSwyNTZ9XFwuW2EtekEtWl17Mix9XFxiKD86Wy1hLXpBLVowLTlAOiUuXyt+Iz0/ISYvXSopKD86Wy1hLXpBLVowLTlAOiUuXyt+Iz0/ISYvXSopL2dpXG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlua09wdGlvbnMge1xuICAvKipcbiAgICogSWYgZW5hYmxlZCwgaXQgYWRkcyBsaW5rcyBhcyB5b3UgdHlwZS5cbiAgICovXG4gIGF1dG9saW5rOiBib29sZWFuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBjdXN0b20gcHJvdG9jb2xzIHRvIGJlIHJlZ2lzdGVyZWQgd2l0aCBsaW5raWZ5anMuXG4gICAqL1xuICBwcm90b2NvbHM6IEFycmF5PExpbmtQcm90b2NvbE9wdGlvbnMgfCBzdHJpbmc+XG4gIC8qKlxuICAgKiBJZiBlbmFibGVkLCBsaW5rcyB3aWxsIGJlIG9wZW5lZCBvbiBjbGljay5cbiAgICovXG4gIG9wZW5PbkNsaWNrOiBib29sZWFuXG4gIC8qKlxuICAgKiBBZGRzIGEgbGluayB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gaWYgdGhlIHBhc3RlZCBjb250ZW50IG9ubHkgY29udGFpbnMgYW4gdXJsLlxuICAgKi9cbiAgbGlua09uUGFzdGU6IGJvb2xlYW5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBIVE1MIGF0dHJpYnV0ZXMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxuICAvKipcbiAgICogQSB2YWxpZGF0aW9uIGZ1bmN0aW9uIHRoYXQgbW9kaWZpZXMgbGluayB2ZXJpZmljYXRpb24gZm9yIHRoZSBhdXRvIGxpbmtlci5cbiAgICogQHBhcmFtIHVybCAtIFRoZSB1cmwgdG8gYmUgdmFsaWRhdGVkLlxuICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHVybCBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgdmFsaWRhdGU/OiAodXJsOiBzdHJpbmcpID0+IGJvb2xlYW5cbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGxpbms6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgbGluayBtYXJrXG4gICAgICAgKi9cbiAgICAgIHNldExpbms6IChhdHRyaWJ1dGVzOiB7IGhyZWY6IHN0cmluZzsgdGFyZ2V0Pzogc3RyaW5nIHwgbnVsbDsgcmVsPzogc3RyaW5nIHwgbnVsbDsgY2xhc3M/OiBzdHJpbmcgfCBudWxsIH0pID0+IFJldHVyblR5cGVcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgbGluayBtYXJrXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUxpbms6IChhdHRyaWJ1dGVzOiB7IGhyZWY6IHN0cmluZzsgdGFyZ2V0Pzogc3RyaW5nIHwgbnVsbDsgcmVsPzogc3RyaW5nIHwgbnVsbDsgY2xhc3M/OiBzdHJpbmcgfCBudWxsIH0pID0+IFJldHVyblR5cGVcbiAgICAgIC8qKlxuICAgICAgICogVW5zZXQgYSBsaW5rIG1hcmtcbiAgICAgICAqL1xuICAgICAgdW5zZXRMaW5rOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBMaW5rID0gTWFyay5jcmVhdGU8TGlua09wdGlvbnM+KHtcbiAgbmFtZTogJ2xpbmsnLFxuXG4gIHByaW9yaXR5OiAxMDAwLFxuXG4gIGtlZXBPblNwbGl0OiBmYWxzZSxcblxuICBvbkNyZWF0ZSgpIHtcbiAgICB0aGlzLm9wdGlvbnMucHJvdG9jb2xzLmZvckVhY2gocHJvdG9jb2wgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwcm90b2NvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbChwcm90b2NvbClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZWdpc3RlckN1c3RvbVByb3RvY29sKHByb3RvY29sLnNjaGVtZSwgcHJvdG9jb2wub3B0aW9uYWxTbGFzaGVzKVxuICAgIH0pXG4gIH0sXG5cbiAgb25EZXN0cm95KCkge1xuICAgIHJlc2V0KClcbiAgfSxcblxuICBpbmNsdXNpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hdXRvbGlua1xuICB9LFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZW5PbkNsaWNrOiB0cnVlLFxuICAgICAgbGlua09uUGFzdGU6IHRydWUsXG4gICAgICBhdXRvbGluazogdHJ1ZSxcbiAgICAgIHByb3RvY29sczogW10sXG4gICAgICBIVE1MQXR0cmlidXRlczoge1xuICAgICAgICB0YXJnZXQ6ICdfYmxhbmsnLFxuICAgICAgICByZWw6ICdub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93JyxcbiAgICAgICAgY2xhc3M6IG51bGwsXG4gICAgICB9LFxuICAgICAgdmFsaWRhdGU6IHVuZGVmaW5lZCxcbiAgICB9XG4gIH0sXG5cbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaHJlZjoge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgfSxcbiAgICAgIHRhcmdldDoge1xuICAgICAgICBkZWZhdWx0OiB0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMudGFyZ2V0LFxuICAgICAgfSxcbiAgICAgIHJlbDoge1xuICAgICAgICBkZWZhdWx0OiB0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMucmVsLFxuICAgICAgfSxcbiAgICAgIGNsYXNzOiB7XG4gICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcy5jbGFzcyxcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiAnYVtocmVmXTpub3QoW2hyZWYgKj0gXCJqYXZhc2NyaXB0OlwiIGldKScgfV1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIC8vIEZhbHNlIHBvc2l0aXZlOyB3ZSdyZSBleHBsaWNpdGx5IGNoZWNraW5nIGZvciBqYXZhc2NyaXB0OiBsaW5rcyB0byBpZ25vcmUgdGhlbVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zY3JpcHQtdXJsXG4gICAgaWYgKEhUTUxBdHRyaWJ1dGVzLmhyZWY/LnN0YXJ0c1dpdGgoJ2phdmFzY3JpcHQ6JykpIHtcbiAgICAgIC8vIHN0cmlwIG91dCB0aGUgaHJlZlxuICAgICAgcmV0dXJuIFsnYScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIHsgLi4uSFRNTEF0dHJpYnV0ZXMsIGhyZWY6ICcnIH0pLCAwXVxuICAgIH1cbiAgICByZXR1cm4gWydhJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRMaW5rOlxuICAgICAgICBhdHRyaWJ1dGVzID0+ICh7IGNoYWluIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4oKS5zZXRNYXJrKHRoaXMubmFtZSwgYXR0cmlidXRlcykuc2V0TWV0YSgncHJldmVudEF1dG9saW5rJywgdHJ1ZSkucnVuKClcbiAgICAgICAgfSxcblxuICAgICAgdG9nZ2xlTGluazpcbiAgICAgICAgYXR0cmlidXRlcyA9PiAoeyBjaGFpbiB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNoYWluKClcbiAgICAgICAgICAgIC50b2dnbGVNYXJrKHRoaXMubmFtZSwgYXR0cmlidXRlcywgeyBleHRlbmRFbXB0eU1hcmtSYW5nZTogdHJ1ZSB9KVxuICAgICAgICAgICAgLnNldE1ldGEoJ3ByZXZlbnRBdXRvbGluaycsIHRydWUpXG4gICAgICAgICAgICAucnVuKClcbiAgICAgICAgfSxcblxuICAgICAgdW5zZXRMaW5rOlxuICAgICAgICAoKSA9PiAoeyBjaGFpbiB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNoYWluKClcbiAgICAgICAgICAgIC51bnNldE1hcmsodGhpcy5uYW1lLCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlOiB0cnVlIH0pXG4gICAgICAgICAgICAuc2V0TWV0YSgncHJldmVudEF1dG9saW5rJywgdHJ1ZSlcbiAgICAgICAgICAgIC5ydW4oKVxuICAgICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogKHRleHQsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgaHRtbCA9IGV2ZW50Py5jbGlwYm9hcmREYXRhPy5nZXREYXRhKCd0ZXh0L2h0bWwnKVxuXG4gICAgICAgICAgY29uc3QgZm91bmRMaW5rczogUGFzdGVSdWxlTWF0Y2hbXSA9IFtdXG5cbiAgICAgICAgICBpZiAoaHRtbCkge1xuICAgICAgICAgICAgY29uc3QgZG9tID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhodG1sLCAndGV4dC9odG1sJylcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvcnMgPSBkb20ucXVlcnlTZWxlY3RvckFsbCgnYScpXG5cbiAgICAgICAgICAgIGlmIChhbmNob3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBbLi4uYW5jaG9yc10uZm9yRWFjaChhbmNob3IgPT4gKGZvdW5kTGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgdGV4dDogYW5jaG9yLmlubmVyVGV4dCxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICBocmVmOiBhbmNob3IuZ2V0QXR0cmlidXRlKCdocmVmJyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IG9mIHRoZSBhbmNob3IgaW5zaWRlIHRoZSB0ZXh0XG4gICAgICAgICAgICAgICAgLy8gYW5kIGFkZCB0aGUgbGVuZ3RoIG9mIHRoZSBhbmNob3IgdGV4dFxuICAgICAgICAgICAgICAgIGluZGV4OiBkb20uYm9keS5pbm5lclRleHQuaW5kZXhPZihhbmNob3IuaW5uZXJUZXh0KSArIGFuY2hvci5pbm5lclRleHQubGVuZ3RoLFxuICAgICAgICAgICAgICB9KSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gZmluZCh0ZXh0KS5maWx0ZXIoaXRlbSA9PiBpdGVtLmlzTGluaylcblxuICAgICAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBsaW5rcy5mb3JFYWNoKGxpbmsgPT4gKGZvdW5kTGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgdGV4dDogbGluay52YWx1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICBocmVmOiBsaW5rLmhyZWYsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmRleDogbGluay5zdGFydCxcbiAgICAgICAgICAgICAgfSkpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmb3VuZExpbmtzXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBocmVmOiBtYXRjaC5kYXRhPy5ocmVmLFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgY29uc3QgcGx1Z2luczogUGx1Z2luW10gPSBbXVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvbGluaykge1xuICAgICAgcGx1Z2lucy5wdXNoKFxuICAgICAgICBhdXRvbGluayh7XG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgIHZhbGlkYXRlOiB0aGlzLm9wdGlvbnMudmFsaWRhdGUsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMub3Blbk9uQ2xpY2spIHtcbiAgICAgIHBsdWdpbnMucHVzaChcbiAgICAgICAgY2xpY2tIYW5kbGVyKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMubGlua09uUGFzdGUpIHtcbiAgICAgIHBsdWdpbnMucHVzaChcbiAgICAgICAgcGFzdGVIYW5kbGVyKHtcbiAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgfSksXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHBsdWdpbnNcbiAgfSxcbn0pXG4iLCAiaW1wb3J0IExpbmsgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tbGluaydcblxuZXhwb3J0IGRlZmF1bHQgTGluay5leHRlbmQoe1xuICAgIGluY2x1c2l2ZTogZmFsc2UsXG5cbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3Blbk9uQ2xpY2s6IGZhbHNlLFxuICAgICAgICAgICAgbGlua09uUGFzdGU6IHRydWUsXG4gICAgICAgICAgICBhdXRvbGluazogZmFsc2UsXG4gICAgICAgICAgICBwcm90b2NvbHM6IFtdLFxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgICAgdmFsaWRhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaHJlZjoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcy50YXJnZXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaHJlZmxhbmc6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVmZXJyZXJwb2xpY3k6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc19idXR0b246IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcnNlSFRNTDogZWxlbWVudCA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1hcy1idXR0b24nKSA/PyBudWxsLFxuICAgICAgICAgICAgICAgIHJlbmRlckhUTUw6IGF0dHJpYnV0ZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXMuYXNfYnV0dG9uKSByZXR1cm5cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtYXMtYnV0dG9uJzogYXR0cmlidXRlcy5hc19idXR0b24sXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ1dHRvbl90aGVtZToge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWFzLWJ1dHRvbi10aGVtZScpID8/IG51bGwsXG4gICAgICAgICAgICAgICAgcmVuZGVySFRNTDogYXR0cmlidXRlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXR0cmlidXRlcy5idXR0b25fdGhlbWUpIHJldHVyblxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1hcy1idXR0b24tdGhlbWUnOiBhdHRyaWJ1dGVzLmJ1dHRvbl90aGVtZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgfSxcbn0pXG4iLCAiaW1wb3J0IHtcbiAgbWVyZ2VBdHRyaWJ1dGVzLFxuICBOb2RlLFxuICBub2RlSW5wdXRSdWxlLFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VPcHRpb25zIHtcbiAgaW5saW5lOiBib29sZWFuLFxuICBhbGxvd0Jhc2U2NDogYm9vbGVhbixcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBpbWFnZToge1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYW4gaW1hZ2VcbiAgICAgICAqL1xuICAgICAgc2V0SW1hZ2U6IChvcHRpb25zOiB7IHNyYzogc3RyaW5nLCBhbHQ/OiBzdHJpbmcsIHRpdGxlPzogc3RyaW5nIH0pID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSghXFxbKC4rfDo/KV1cXCgoXFxTKykoPzooPzpcXHMrKVtcIiddKFxcUyspW1wiJ10pP1xcKSkkL1xuXG5leHBvcnQgY29uc3QgSW1hZ2UgPSBOb2RlLmNyZWF0ZTxJbWFnZU9wdGlvbnM+KHtcbiAgbmFtZTogJ2ltYWdlJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbmxpbmU6IGZhbHNlLFxuICAgICAgYWxsb3dCYXNlNjQ6IGZhbHNlLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBpbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmxpbmVcbiAgfSxcblxuICBncm91cCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlubGluZSA/ICdpbmxpbmUnIDogJ2Jsb2NrJ1xuICB9LFxuXG4gIGRyYWdnYWJsZTogdHJ1ZSxcblxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzcmM6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIH0sXG4gICAgICBhbHQ6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIH0sXG4gICAgICB0aXRsZToge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogdGhpcy5vcHRpb25zLmFsbG93QmFzZTY0XG4gICAgICAgICAgPyAnaW1nW3NyY10nXG4gICAgICAgICAgOiAnaW1nW3NyY106bm90KFtzcmNePVwiZGF0YTpcIl0pJyxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnaW1nJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRJbWFnZTogb3B0aW9ucyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5pbnNlcnRDb250ZW50KHtcbiAgICAgICAgICB0eXBlOiB0aGlzLm5hbWUsXG4gICAgICAgICAgYXR0cnM6IG9wdGlvbnMsXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBub2RlSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiBtYXRjaCA9PiB7XG4gICAgICAgICAgY29uc3QgWywsIGFsdCwgc3JjLCB0aXRsZV0gPSBtYXRjaFxuXG4gICAgICAgICAgcmV0dXJuIHsgc3JjLCBhbHQsIHRpdGxlIH1cbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHtcblx0cnVuX2FsbCxcblx0c3Vic2NyaWJlLFxuXHRub29wLFxuXHRzYWZlX25vdF9lcXVhbCxcblx0aXNfZnVuY3Rpb24sXG5cdGdldF9zdG9yZV92YWx1ZVxufSBmcm9tICcuLi9pbnRlcm5hbC9pbmRleC5qcyc7XG5cbmNvbnN0IHN1YnNjcmliZXJfcXVldWUgPSBbXTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYFJlYWRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjcmVhZGFibGVcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IFt2YWx1ZV0gaW5pdGlhbCB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuU3RhcnRTdG9wTm90aWZpZXI8VD59IFtzdGFydF1cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuUmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkYWJsZSh2YWx1ZSwgc3RhcnQpIHtcblx0cmV0dXJuIHtcblx0XHRzdWJzY3JpYmU6IHdyaXRhYmxlKHZhbHVlLCBzdGFydCkuc3Vic2NyaWJlXG5cdH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFdyaXRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyBib3RoIHVwZGF0aW5nIGFuZCByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjd3JpdGFibGVcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IFt2YWx1ZV0gaW5pdGlhbCB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuU3RhcnRTdG9wTm90aWZpZXI8VD59IFtzdGFydF1cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuV3JpdGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQgPSBub29wKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlVuc3Vic2NyaWJlcn0gKi9cblx0bGV0IHN0b3A7XG5cdC8qKiBAdHlwZSB7U2V0PGltcG9ydCgnLi9wcml2YXRlLmpzJykuU3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlPFQ+Pn0gKi9cblx0Y29uc3Qgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG5cdC8qKiBAcGFyYW0ge1R9IG5ld192YWx1ZVxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIHNldChuZXdfdmFsdWUpIHtcblx0XHRpZiAoc2FmZV9ub3RfZXF1YWwodmFsdWUsIG5ld192YWx1ZSkpIHtcblx0XHRcdHZhbHVlID0gbmV3X3ZhbHVlO1xuXHRcdFx0aWYgKHN0b3ApIHtcblx0XHRcdFx0Ly8gc3RvcmUgaXMgcmVhZHlcblx0XHRcdFx0Y29uc3QgcnVuX3F1ZXVlID0gIXN1YnNjcmliZXJfcXVldWUubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGNvbnN0IHN1YnNjcmliZXIgb2Ygc3Vic2NyaWJlcnMpIHtcblx0XHRcdFx0XHRzdWJzY3JpYmVyWzFdKCk7XG5cdFx0XHRcdFx0c3Vic2NyaWJlcl9xdWV1ZS5wdXNoKHN1YnNjcmliZXIsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocnVuX3F1ZXVlKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlW2ldWzBdKHN1YnNjcmliZXJfcXVldWVbaSArIDFdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGggPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlVwZGF0ZXI8VD59IGZuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlKGZuKSB7XG5cdFx0c2V0KGZuKHZhbHVlKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuU3Vic2NyaWJlcjxUPn0gcnVuXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5JbnZhbGlkYXRvcjxUPn0gW2ludmFsaWRhdGVdXG5cdCAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuVW5zdWJzY3JpYmVyfVxuXHQgKi9cblx0ZnVuY3Rpb24gc3Vic2NyaWJlKHJ1biwgaW52YWxpZGF0ZSA9IG5vb3ApIHtcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuU3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlPFQ+fSAqL1xuXHRcdGNvbnN0IHN1YnNjcmliZXIgPSBbcnVuLCBpbnZhbGlkYXRlXTtcblx0XHRzdWJzY3JpYmVycy5hZGQoc3Vic2NyaWJlcik7XG5cdFx0aWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDEpIHtcblx0XHRcdHN0b3AgPSBzdGFydChzZXQsIHVwZGF0ZSkgfHwgbm9vcDtcblx0XHR9XG5cdFx0cnVuKHZhbHVlKTtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0c3Vic2NyaWJlcnMuZGVsZXRlKHN1YnNjcmliZXIpO1xuXHRcdFx0aWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDAgJiYgc3RvcCkge1xuXHRcdFx0XHRzdG9wKCk7XG5cdFx0XHRcdHN0b3AgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0cmV0dXJuIHsgc2V0LCB1cGRhdGUsIHN1YnNjcmliZSB9O1xufVxuXG4vKipcbiAqIERlcml2ZWQgdmFsdWUgc3RvcmUgYnkgc3luY2hyb25pemluZyBvbmUgb3IgbW9yZSByZWFkYWJsZSBzdG9yZXMgYW5kXG4gKiBhcHBseWluZyBhbiBhZ2dyZWdhdGlvbiBmdW5jdGlvbiBvdmVyIGl0cyBpbnB1dCB2YWx1ZXMuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI2Rlcml2ZWRcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7U30gc3RvcmVzIC0gaW5wdXQgc3RvcmVzXG4gKiBAcGFyYW0geyh2YWx1ZXM6IGltcG9ydCgnLi9wcml2YXRlLmpzJykuU3RvcmVzVmFsdWVzPFM+LCBzZXQ6ICh2YWx1ZTogVCkgPT4gdm9pZCwgdXBkYXRlOiAoZm46IGltcG9ydCgnLi9wdWJsaWMuanMnKS5VcGRhdGVyPFQ+KSA9PiB2b2lkKSA9PiBpbXBvcnQoJy4vcHVibGljLmpzJykuVW5zdWJzY3JpYmVyIHwgdm9pZH0gZm4gLSBmdW5jdGlvbiBjYWxsYmFjayB0aGF0IGFnZ3JlZ2F0ZXMgdGhlIHZhbHVlc1xuICogQHBhcmFtIHtUfSBbaW5pdGlhbF92YWx1ZV0gLSBpbml0aWFsIHZhbHVlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fVxuICovXG5cbi8qKlxuICogRGVyaXZlZCB2YWx1ZSBzdG9yZSBieSBzeW5jaHJvbml6aW5nIG9uZSBvciBtb3JlIHJlYWRhYmxlIHN0b3JlcyBhbmRcbiAqIGFwcGx5aW5nIGFuIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uIG92ZXIgaXRzIGlucHV0IHZhbHVlcy5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjZGVyaXZlZFxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlN0b3Jlc30gU1xuICogQHRlbXBsYXRlIFRcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtTfSBzdG9yZXMgLSBpbnB1dCBzdG9yZXNcbiAqIEBwYXJhbSB7KHZhbHVlczogaW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdG9yZXNWYWx1ZXM8Uz4pID0+IFR9IGZuIC0gZnVuY3Rpb24gY2FsbGJhY2sgdGhhdCBhZ2dyZWdhdGVzIHRoZSB2YWx1ZXNcbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdIC0gaW5pdGlhbCB2YWx1ZVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn1cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N9IHN0b3Jlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZChzdG9yZXMsIGZuLCBpbml0aWFsX3ZhbHVlKSB7XG5cdGNvbnN0IHNpbmdsZSA9ICFBcnJheS5pc0FycmF5KHN0b3Jlcyk7XG5cdC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPGFueT4+fSAqL1xuXHRjb25zdCBzdG9yZXNfYXJyYXkgPSBzaW5nbGUgPyBbc3RvcmVzXSA6IHN0b3Jlcztcblx0aWYgKCFzdG9yZXNfYXJyYXkuZXZlcnkoQm9vbGVhbikpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Rlcml2ZWQoKSBleHBlY3RzIHN0b3JlcyBhcyBpbnB1dCwgZ290IGEgZmFsc3kgdmFsdWUnKTtcblx0fVxuXHRjb25zdCBhdXRvID0gZm4ubGVuZ3RoIDwgMjtcblx0cmV0dXJuIHJlYWRhYmxlKGluaXRpYWxfdmFsdWUsIChzZXQsIHVwZGF0ZSkgPT4ge1xuXHRcdGxldCBzdGFydGVkID0gZmFsc2U7XG5cdFx0Y29uc3QgdmFsdWVzID0gW107XG5cdFx0bGV0IHBlbmRpbmcgPSAwO1xuXHRcdGxldCBjbGVhbnVwID0gbm9vcDtcblx0XHRjb25zdCBzeW5jID0gKCkgPT4ge1xuXHRcdFx0aWYgKHBlbmRpbmcpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gZm4oc2luZ2xlID8gdmFsdWVzWzBdIDogdmFsdWVzLCBzZXQsIHVwZGF0ZSk7XG5cdFx0XHRpZiAoYXV0bykge1xuXHRcdFx0XHRzZXQocmVzdWx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsZWFudXAgPSBpc19mdW5jdGlvbihyZXN1bHQpID8gcmVzdWx0IDogbm9vcDtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGNvbnN0IHVuc3Vic2NyaWJlcnMgPSBzdG9yZXNfYXJyYXkubWFwKChzdG9yZSwgaSkgPT5cblx0XHRcdHN1YnNjcmliZShcblx0XHRcdFx0c3RvcmUsXG5cdFx0XHRcdCh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHZhbHVlc1tpXSA9IHZhbHVlO1xuXHRcdFx0XHRcdHBlbmRpbmcgJj0gfigxIDw8IGkpO1xuXHRcdFx0XHRcdGlmIChzdGFydGVkKSB7XG5cdFx0XHRcdFx0XHRzeW5jKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQoKSA9PiB7XG5cdFx0XHRcdFx0cGVuZGluZyB8PSAxIDw8IGk7XG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHQpO1xuXHRcdHN0YXJ0ZWQgPSB0cnVlO1xuXHRcdHN5bmMoKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gc3RvcCgpIHtcblx0XHRcdHJ1bl9hbGwodW5zdWJzY3JpYmVycyk7XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHQvLyBXZSBuZWVkIHRvIHNldCB0aGlzIHRvIGZhbHNlIGJlY2F1c2UgY2FsbGJhY2tzIGNhbiBzdGlsbCBoYXBwZW4gZGVzcGl0ZSBoYXZpbmcgdW5zdWJzY3JpYmVkOlxuXHRcdFx0Ly8gQ2FsbGJhY2tzIG1pZ2h0IGFscmVhZHkgYmUgcGxhY2VkIGluIHRoZSBxdWV1ZSB3aGljaCBkb2Vzbid0IGtub3cgaXQgc2hvdWxkIG5vIGxvbmdlclxuXHRcdFx0Ly8gaW52b2tlIHRoaXMgZGVyaXZlZCBzdG9yZS5cblx0XHRcdHN0YXJ0ZWQgPSBmYWxzZTtcblx0XHR9O1xuXHR9KTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHN0b3JlIGFuZCByZXR1cm5zIGEgbmV3IG9uZSBkZXJpdmVkIGZyb20gdGhlIG9sZCBvbmUgdGhhdCBpcyByZWFkYWJsZS5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjcmVhZG9ubHlcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn0gc3RvcmUgIC0gc3RvcmUgdG8gbWFrZSByZWFkb25seVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRvbmx5KHN0b3JlKSB7XG5cdHJldHVybiB7XG5cdFx0c3Vic2NyaWJlOiBzdG9yZS5zdWJzY3JpYmUuYmluZChzdG9yZSlcblx0fTtcbn1cblxuZXhwb3J0IHsgZ2V0X3N0b3JlX3ZhbHVlIGFzIGdldCB9O1xuIiwgImNsYXNzIFN2ZWx0ZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnQsIHsgZWxlbWVudCB9KSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLmRvbSA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoJ3N2ZWx0ZS1yZW5kZXJlcicpO1xuICAgIH1cbiAgICB1cGRhdGVQcm9wcyhwcm9wcykge1xuICAgICAgICB0aGlzLmNvbXBvbmVudC4kc2V0KHByb3BzKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuJGRlc3Ryb3koKTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBTdmVsdGVSZW5kZXJlcjtcbiIsICJleHBvcnQgY29uc3QgVElQVEFQX05PREVfVklFVyA9ICdUaXBUYXBOb2RlVmlldyc7XG4iLCAiaW1wb3J0IHsgTm9kZVZpZXcsIEVkaXRvciB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgU3ZlbHRlUmVuZGVyZXIgZnJvbSAnLi9TdmVsdGVSZW5kZXJlcic7XG5pbXBvcnQgeyBUSVBUQVBfTk9ERV9WSUVXIH0gZnJvbSAnLi9jb250ZXh0JztcbmNsYXNzIFN2ZWx0ZU5vZGVWaWV3IGV4dGVuZHMgTm9kZVZpZXcge1xuICAgIG1vdW50KCkge1xuICAgICAgICBjb25zdCBDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgbm9kZTogdGhpcy5ub2RlLFxuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IHRoaXMuZGVjb3JhdGlvbnMsXG4gICAgICAgICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICBleHRlbnNpb246IHRoaXMuZXh0ZW5zaW9uLFxuICAgICAgICAgICAgZ2V0UG9zOiAoKSA9PiB0aGlzLmdldFBvcygpLFxuICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlczogKGF0dHJpYnV0ZXMgPSB7fSkgPT4gdGhpcy51cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpLFxuICAgICAgICAgICAgZGVsZXRlTm9kZTogKCkgPT4gdGhpcy5kZWxldGVOb2RlKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQgPSB0aGlzLm5vZGUuaXNMZWFmID8gbnVsbCA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ub2RlLmlzSW5saW5lID8gJ3NwYW4nIDogJ2RpdicpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uIHRoZSB3aGl0ZVNwYWNlIHByb3AgaXMgbm90IGluaGVyaXRlZCBwcm9wZXJseSBpbiBDaHJvbWUgYW5kIFNhZmFyaVxuICAgICAgICAgICAgLy8gV2l0aCB0aGlzIGZpeCBpdCBzZWVtcyB0byB3b3JrIGZpbmVcbiAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8xMTk3XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50LnN0eWxlLndoaXRlU3BhY2UgPSAnaW5oZXJpdCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGV4dCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29udGV4dC5zZXQoVElQVEFQX05PREVfVklFVywge1xuICAgICAgICAgICAgb25EcmFnU3RhcnQ6IHRoaXMub25EcmFnU3RhcnQuYmluZCh0aGlzKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFzID0gdGhpcy5vcHRpb25zLmFzID8/ICh0aGlzLm5vZGUuaXNJbmxpbmUgPyAnc3BhbicgOiAnZGl2Jyk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYXMpO1xuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChgbm9kZS0ke3RoaXMubm9kZS50eXBlLm5hbWV9YCk7XG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0aW9uVXBkYXRlID0gdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3NlbGVjdGlvblVwZGF0ZScsIHRoaXMuaGFuZGxlU2VsZWN0aW9uVXBkYXRlKTtcbiAgICAgICAgY29uc3Qgc3ZlbHRlQ29tcG9uZW50ID0gbmV3IENvbXBvbmVudCh7XG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFN2ZWx0ZVJlbmRlcmVyKHN2ZWx0ZUNvbXBvbmVudCwge1xuICAgICAgICAgICAgZWxlbWVudDogdGFyZ2V0LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHBlbmRDb250ZW5kRG9tKCk7XG4gICAgfVxuICAgIGFwcGVuZENvbnRlbmREb20oKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gdGhpcy5kb20ucXVlcnlTZWxlY3RvcignW2RhdGEtbm9kZS12aWV3LWNvbnRlbnRdJyk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET01FbGVtZW50ICYmIGNvbnRlbnRFbGVtZW50ICYmICFjb250ZW50RWxlbWVudC5jb250YWlucyh0aGlzLmNvbnRlbnRET01FbGVtZW50KSkge1xuICAgICAgICAgICAgY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RE9NRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRvbSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyLmRvbS5maXJzdEVsZW1lbnRDaGlsZD8uaGFzQXR0cmlidXRlKCdkYXRhLW5vZGUtdmlldy13cmFwcGVyJykpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdQbGVhc2UgdXNlIHRoZSBOb2RlVmlld1dyYXBwZXIgY29tcG9uZW50IGZvciB5b3VyIG5vZGUgdmlldy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5kb207XG4gICAgfVxuICAgIGdldCBjb250ZW50RE9NKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTUVsZW1lbnQ7XG4gICAgfVxuICAgIGhhbmRsZVNlbGVjdGlvblVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gdGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoZnJvbSA8PSB0aGlzLmdldFBvcygpICYmIHRvID49IHRoaXMuZ2V0UG9zKCkgKyB0aGlzLm5vZGUubm9kZVNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Tm9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdE5vZGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUobm9kZSwgZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlUHJvcHMgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVByb3BzKHsgbm9kZSwgZGVjb3JhdGlvbnMgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3Qgb2xkTm9kZSA9IHRoaXMubm9kZTtcbiAgICAgICAgICAgIGNvbnN0IG9sZERlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0aW9ucztcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gZGVjb3JhdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgb2xkTm9kZSxcbiAgICAgICAgICAgICAgICBvbGREZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgICBuZXdOb2RlOiBub2RlLFxuICAgICAgICAgICAgICAgIG5ld0RlY29yYXRpb25zOiBkZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgICB1cGRhdGVQcm9wczogKCkgPT4gdXBkYXRlUHJvcHMoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09IHRoaXMubm9kZS50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMubm9kZSAmJiB0aGlzLmRlY29yYXRpb25zID09PSBkZWNvcmF0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xuICAgICAgICB1cGRhdGVQcm9wcygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVQcm9wcyh7IHNlbGVjdGVkOiB0cnVlIH0pO1xuICAgIH1cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlUHJvcHMoeyBzZWxlY3RlZDogZmFsc2UgfSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ3NlbGVjdGlvblVwZGF0ZScsIHRoaXMuaGFuZGxlU2VsZWN0aW9uVXBkYXRlKTtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NRWxlbWVudCA9IG51bGw7XG4gICAgfVxufVxuY29uc3QgU3ZlbHRlTm9kZVZpZXdSZW5kZXJlciA9IChjb21wb25lbnQsIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gKHByb3BzKSA9PiBuZXcgU3ZlbHRlTm9kZVZpZXcoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucyk7XG59O1xuZXhwb3J0IGRlZmF1bHQgU3ZlbHRlTm9kZVZpZXdSZW5kZXJlcjtcbiIsICI8c2NyaXB0PmltcG9ydCB7IGdldENvbnRleHQsIG9uTW91bnQsIHRpY2sgfSBmcm9tIFwic3ZlbHRlXCI7XG5pbXBvcnQgeyBUSVBUQVBfTk9ERV9WSUVXIH0gZnJvbSBcIi4vY29udGV4dFwiO1xuY29uc3QgeyBvbkRyYWdTdGFydCB9ID0gZ2V0Q29udGV4dChUSVBUQVBfTk9ERV9WSUVXKTtcbmxldCBlbGVtZW50O1xuZXhwb3J0IGxldCBhcyA9IFwiZGl2XCI7XG5vbk1vdW50KGFzeW5jICgpID0+IHtcbiAgYXdhaXQgdGljaygpO1xuICBlbGVtZW50LnN0eWxlLndoaXRlU3BhY2UgPSBcIm5vcm1hbFwiO1xufSk7XG48L3NjcmlwdD5cblxuPHN2ZWx0ZTplbGVtZW50XG4gIHRoaXM9e2FzfVxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIGRhdGEtbm9kZS12aWV3LXdyYXBwZXI9XCJcIlxuICBvbjpkcmFnc3RhcnQ9e29uRHJhZ1N0YXJ0fVxuICByb2xlPVwibm9uZVwiXG4gIHsuLi4kJHJlc3RQcm9wc31cbj5cbiAgPHNsb3QgLz5cbjwvc3ZlbHRlOmVsZW1lbnQ+XG4iLCAiaW1wb3J0IHRpcHB5IGZyb20gJ3RpcHB5LmpzJ1xuXG5leHBvcnQgY29uc3QgdXVpZCA9ICgpID0+IHtcbiAgICByZXR1cm4gKFsxZTddKy0xZTMrLTRlMystOGUzKy0xZTExKS5yZXBsYWNlKC9bMDE4XS9nLCBjID0+XG4gICAgICAgIChjIF4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxKSlbMF0gJiAxNSA+PiBjIC8gNCkudG9TdHJpbmcoMTYpXG4gICAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IHBvdW5jZSA9IChjb21wb25lbnQsIGFyZ3MpID0+IHtcbiAgICB3aW5kb3cuTGl2ZXdpcmUuZGlzcGF0Y2goJ3BvdW5jZScsIHsgY29tcG9uZW50OiBjb21wb25lbnQsIGFyZ3VtZW50czogYXJncyB9KVxufVxuXG5leHBvcnQgY29uc3QgY29tbWFuZFJ1bm5lciA9IChlZGl0b3IsIGNvbW1hbmRzLCBhcmdzID0gbnVsbCkgPT4ge1xuICAgIGNvbW1hbmRzLmZvckVhY2goY29tbWFuZCA9PiB7XG4gICAgICAgIGVkaXRvci5jaGFpbigpLmZvY3VzKClbY29tbWFuZC5jb21tYW5kXShjb21tYW5kPy5hcmd1bWVudHMgPz8gYXJncykucnVuKClcbiAgICB9KVxufVxuIiwgImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSAnc3ZlbHRlL3N0b3JlJ1xuXG5leHBvcnQgY29uc3QgZ2V0U3RhdGVQYXRoID0gd3JpdGFibGUobnVsbClcbiIsICI8c2NyaXB0PlxuXG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cInNjcmliYmxlLWJsb2NrLWFjdGlvbnNcIiBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiPlxuICAgIDxzbG90IC8+XG48L2Rpdj5cbiIsICI8ZGl2IGRhdGEtZHJhZy1oYW5kbGUgY2xhc3M9XCJzY3JpYmJsZS1ibG9jay1hY3Rpb24gYmxvY2stZHJhZ1wiPlxuICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJzaXplLTRcIj5cbiAgICAgICAgPHBhdGggZD1cIm0yMi42NyAxMmwtNC40OSA0LjVsLTIuNTEtMi41bDEuOTgtMmwtMS45OC0xLjk2bDIuNTEtMi41MXpNMTIgMS4zM2w0LjQ3IDQuNDlsLTIuNTEgMi41MUwxMiA2LjM1bC0yIDEuOThsLTIuNS0yLjUxem0wIDIxLjM0bC00LjQ3LTQuNDlsMi41MS0yLjUxTDEyIDE3LjY1bDItMS45OGwyLjUgMi41MXpNMS4zMyAxMmw0LjQ5LTQuNUw4LjMzIDEwbC0xLjk4IDJsMS45OCAxLjk2bC0yLjUxIDIuNTF6TTEyIDEwYTIgMiAwIDAgMSAyIDJhMiAyIDAgMCAxLTIgMmEyIDIgMCAwIDEtMi0yYTIgMiAwIDAgMSAyLTJcIi8+XG4gICAgPC9zdmc+XG48L2Rpdj5cbiIsICI8c2NyaXB0PlxuICAgIGV4cG9ydCBsZXQgaGFuZGxlT3Blbjtcbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrfHByZXZlbnREZWZhdWx0fHN0b3BQcm9wYWdhdGlvbj17aGFuZGxlT3Blbn0gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwic2NyaWJibGUtYmxvY2stYWN0aW9uIGJsb2NrLXNldHRpbmdzXCI+XG4gICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAxNiAxNlwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInNpemUtNFwiPlxuICAgICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk0xNSA0LjVBMy41IDMuNSAwIDAgMSAxMS40MzUgOGMtLjk5LS4wMTktMi4wOTMuMTMyLTIuNy45MTNsLTQuMTMgNS4zMWEyLjAxNSAyLjAxNSAwIDEgMS0yLjgyNy0yLjgyOGw1LjMwOS00LjEzYy43OC0uNjA3LjkzMi0xLjcxLjkxNC0yLjdMOCA0LjVhMy41IDMuNSAwIDAgMSA0LjQ3Ny0zLjM2MmMuMzI1LjA5NC4zOS40OTcuMTUuNzM2TDEwLjYgMy45MDJhLjQ4LjQ4IDAgMCAwLS4wMzMuNjUzYy4yNzEuMzE0LjU2NS42MDguODc5Ljg3OWEuNDguNDggMCAwIDAgLjY1My0uMDMzbDIuMDI3LTIuMDI3Yy4yMzktLjI0LjY0Mi0uMTc1LjczNi4xNS4wOS4zMS4xMzguNjM3LjEzOC45NzZaTTMuNzUgMTNhLjc1Ljc1IDAgMSAxLTEuNSAwIC43NS43NSAwIDAgMSAxLjUgMFpcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0xMS41IDkuNWMuMzEzIDAgLjYyLS4wMjkuOTE3LS4wODRsMS45NjIgMS45NjJhMi4xMjEgMi4xMjEgMCAwIDEtMyAzbC0yLjgxLTIuODEgMS4zNS0xLjczNGMuMDUtLjA2NC4xNTgtLjE1OC40MjYtLjIzMy4yNzgtLjA3OC42MzktLjExIDEuMDYyLS4xMDJsLjA5My4wMDFaTTUgNGwxLjQ0NiAxLjQ0NWEyLjI1NiAyLjI1NiAwIDAgMS0uMDQ3LjIxYy0uMDc1LjI2OC0uMTY5LjM3Ny0uMjMzLjQyN2wtLjYxLjQ3NEw0IDVIMi42NTVhLjI1LjI1IDAgMCAxLS4yMjQtLjEzOWwtMS4zNS0yLjdhLjI1LjI1IDAgMCAxIC4wNDctLjI4OWwuNzQ1LS43NDVhLjI1LjI1IDAgMCAxIC4yODktLjA0N2wyLjcgMS4zNUEuMjUuMjUgMCAwIDEgNSAyLjY1NFY0WlwiIC8+XG4gICAgPC9zdmc+XG48L2J1dHRvbj5cbiIsICI8c2NyaXB0PlxuICAgIGV4cG9ydCBsZXQgaGFuZGxlUmVtb3ZlO1xuPC9zY3JpcHQ+XG5cbjxidXR0b24gb246Y2xpY2t8cHJldmVudERlZmF1bHR8c3RvcFByb3BhZ2F0aW9uPXtoYW5kbGVSZW1vdmV9IHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzcz1cInNjcmliYmxlLWJsb2NrLWFjdGlvbiBibG9jay1yZW1vdmVcIj5cbiAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwic2l6ZS00XCI+XG4gICAgICAgIDxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTUgMy4yNVY0SDIuNzVhLjc1Ljc1IDAgMCAwIDAgMS41aC4zbC44MTUgOC4xNUExLjUgMS41IDAgMCAwIDUuMzU3IDE1aDUuMjg1YTEuNSAxLjUgMCAwIDAgMS40OTMtMS4zNWwuODE1LTguMTVoLjNhLjc1Ljc1IDAgMCAwIDAtMS41SDExdi0uNzVBMi4yNSAyLjI1IDAgMCAwIDguNzUgMWgtMS41QTIuMjUgMi4yNSAwIDAgMCA1IDMuMjVabTIuMjUtLjc1YS43NS43NSAwIDAgMC0uNzUuNzVWNGgzdi0uNzVhLjc1Ljc1IDAgMCAwLS43NS0uNzVoLTEuNVpNNi4wNSA2YS43NS43NSAwIDAgMSAuNzg3LjcxM2wuMjc1IDUuNWEuNzUuNzUgMCAwIDEtMS40OTguMDc1bC0uMjc1LTUuNUEuNzUuNzUgMCAwIDEgNi4wNSA2Wm0zLjkgMGEuNzUuNzUgMCAwIDEgLjcxMi43ODdsLS4yNzUgNS41YS43NS43NSAwIDAgMS0xLjQ5OC0uMDc1bC4yNzUtNS41YS43NS43NSAwIDAgMSAuNzg2LS43MTFaXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgPC9zdmc+XG48L2J1dHRvbj5cbiIsICI8c2NyaXB0PlxuICAgIGltcG9ydCB7IE5vZGVWaWV3V3JhcHBlciB9IGZyb20gJ3N2ZWx0ZS10aXB0YXAnXG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBwb3VuY2UgfSBmcm9tICcuLi91dGlscy5qcydcbiAgICBpbXBvcnQgeyBnZXRTdGF0ZVBhdGggfSBmcm9tICcuLi9zdG9yZXMuanMnXG4gICAgaW1wb3J0IEJsb2NrQWN0aW9ucyBmcm9tICcuL0Jsb2NrQWN0aW9ucy5zdmVsdGUnXG4gICAgaW1wb3J0IERyYWdIYW5kbGUgZnJvbSAnLi9EcmFnSGFuZGxlLnN2ZWx0ZSdcbiAgICBpbXBvcnQgQmxvY2tTZXR0aW5ncyBmcm9tICcuL0Jsb2NrU2V0dGluZ3Muc3ZlbHRlJ1xuICAgIGltcG9ydCBSZW1vdmVCbG9jayBmcm9tICcuL1JlbW92ZUJsb2NrLnN2ZWx0ZSdcblxuICAgIGV4cG9ydCBsZXQgZWRpdG9yO1xuICAgIGV4cG9ydCBsZXQgbm9kZTtcbiAgICBleHBvcnQgbGV0IHNlbGVjdGVkID0gZmFsc2U7XG4gICAgZXhwb3J0IGxldCB1cGRhdGVBdHRyaWJ1dGVzO1xuXG4gICAgY29uc3QgaGFuZGxlT3BlbiA9ICgpID0+IHtcbiAgICAgICAgcG91bmNlKCdzY3JpYmJsZS1tZWRpYScsIHtcbiAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIHN0YXRlUGF0aDogJGdldFN0YXRlUGF0aCxcbiAgICAgICAgICAgIC4uLm5vZGUuYXR0cnNcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVSZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5jb21tYW5kcy5kZWxldGVTZWxlY3Rpb24oKVxuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZEJsb2NrJywgKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlLmRldGFpbC50eXBlID09PSBub2RlLmF0dHJzLnR5cGUgJiYgZS5kZXRhaWwuc3RhdGVQYXRoID09PSAkZ2V0U3RhdGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlcyh7IHZhbHVlczogZS5kZXRhaWwudmFsdWVzIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSlcbjwvc2NyaXB0PlxuXG48Tm9kZVZpZXdXcmFwcGVyPlxuICAgIDxkaXYgY2xhc3M9XCJzY3JpYmJsZS1ibG9ja1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwic2NyaWJibGUtYmxvY2stY29udGVudCB7c2VsZWN0ZWQgPyAnUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlJyA6ICcnfVwiPlxuICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgIHNyYz17bm9kZS5hdHRycy5zcmN9XG4gICAgICAgICAgICAgICAgYWx0PXtub2RlLmF0dHJzLmFsdH1cbiAgICAgICAgICAgICAgICB0aXRsZT17bm9kZS5hdHRycz8udGl0bGUgPz8gbnVsbH1cbiAgICAgICAgICAgICAgICB3aWR0aD17bm9kZS5hdHRycy53aWR0aH1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9e25vZGUuYXR0cnMuaGVpZ2h0fVxuICAgICAgICAgICAgICAgIGxvYWRpbmc9e25vZGUuYXR0cnMubG9hZGluZ31cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8QmxvY2tBY3Rpb25zPlxuICAgICAgICAgICAgPERyYWdIYW5kbGUgLz5cbiAgICAgICAgICAgIDxCbG9ja1NldHRpbmdzIHtoYW5kbGVPcGVufSAvPlxuICAgICAgICAgICAgPFJlbW92ZUJsb2NrIHtoYW5kbGVSZW1vdmV9IC8+XG4gICAgICAgIDwvQmxvY2tBY3Rpb25zPlxuICAgIDwvZGl2PlxuPC9Ob2RlVmlld1dyYXBwZXI+XG4iLCAiaW1wb3J0IEltYWdlIGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1pbWFnZVwiO1xuaW1wb3J0IHsgU3ZlbHRlTm9kZVZpZXdSZW5kZXJlciB9IGZyb20gJ3N2ZWx0ZS10aXB0YXAnXG5pbXBvcnQgTWVkaWFWaWV3IGZyb20gJy4uL2NvbXBvbmVudHMvTWVkaWFWaWV3LnN2ZWx0ZSdcblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2UuZXh0ZW5kKHtcbiAgICBzZWxlY3RhYmxlOiB0cnVlLFxuXG4gICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNyYzoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWx0OiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlaWdodDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9hZGluZzoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2l6ZXM6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNyY3NldDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFkZE5vZGVWaWV3KCkge1xuICAgICAgICByZXR1cm4gU3ZlbHRlTm9kZVZpZXdSZW5kZXJlcihNZWRpYVZpZXcpXG4gICAgfVxufSk7XG4iLCAiaW1wb3J0IHsgRWRpdG9yLCBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBOb2RlIGFzIFByb3NlbWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuXG5leHBvcnQgaW50ZXJmYWNlIFBsYWNlaG9sZGVyT3B0aW9ucyB7XG4gIC8qKlxuICAgKiAqKlRoZSBjbGFzcyBuYW1lIGZvciB0aGUgZW1wdHkgZWRpdG9yKipcbiAgICogQGRlZmF1bHQgJ2lzLWVkaXRvci1lbXB0eSdcbiAgICovXG4gIGVtcHR5RWRpdG9yQ2xhc3M6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiAqKlRoZSBjbGFzcyBuYW1lIGZvciBlbXB0eSBub2RlcyoqXG4gICAqIEBkZWZhdWx0ICdpcy1lbXB0eSdcbiAgICovXG4gIGVtcHR5Tm9kZUNsYXNzOiBzdHJpbmdcblxuICAvKipcbiAgICogKipUaGUgcGxhY2Vob2xkZXIgY29udGVudCoqXG4gICAqXG4gICAqIFlvdSBjYW4gdXNlIGEgZnVuY3Rpb24gdG8gcmV0dXJuIGEgZHluYW1pYyBwbGFjZWhvbGRlciBvciBhIHN0cmluZy5cbiAgICogQGRlZmF1bHQgJ1dyaXRlIHNvbWV0aGluZyDigKYnXG4gICAqL1xuICBwbGFjZWhvbGRlcjpcbiAgICB8ICgoUGxhY2Vob2xkZXJQcm9wczoge1xuICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICBub2RlOiBQcm9zZW1pcnJvck5vZGVcbiAgICAgICAgcG9zOiBudW1iZXJcbiAgICAgICAgaGFzQW5jaG9yOiBib29sZWFuXG4gICAgICB9KSA9PiBzdHJpbmcpXG4gICAgfCBzdHJpbmdcblxuICAvKipcbiAgICogKipVc2VkIGZvciBlbXB0eSBjaGVjayBvbiB0aGUgZG9jdW1lbnQuKipcbiAgICpcbiAgICogSWYgdHJ1ZSwgYW55IG5vZGUgdGhhdCBpcyBub3QgYSBsZWFmIG9yIGF0b20gd2lsbCBiZSBjb25zaWRlcmVkIGZvciBlbXB0eSBjaGVjay5cbiAgICogSWYgZmFsc2UsIG9ubHkgZGVmYXVsdCBub2RlcyAocGFyYWdyYXBocykgd2lsbCBiZSBjb25zaWRlcmVkIGZvciBlbXB0eSBjaGVjay5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGNvbnNpZGVyQW55QXNFbXB0eTogYm9vbGVhblxuXG4gIC8qKlxuICAgKiAqKkNoZWNrcyBpZiB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIGJlIG9ubHkgc2hvd24gd2hlbiB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLioqXG4gICAqXG4gICAqIElmIHRydWUsIHRoZSBwbGFjZWhvbGRlciB3aWxsIG9ubHkgYmUgc2hvd24gd2hlbiB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLlxuICAgKiBJZiBmYWxzZSwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYWx3YXlzIGJlIHNob3duLlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBzaG93T25seVdoZW5FZGl0YWJsZTogYm9vbGVhblxuXG4gIC8qKlxuICAgKiAqKkNoZWNrcyBpZiB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIGJlIG9ubHkgc2hvd24gd2hlbiB0aGUgY3VycmVudCBub2RlIGlzIGVtcHR5LioqXG4gICAqXG4gICAqIElmIHRydWUsIHRoZSBwbGFjZWhvbGRlciB3aWxsIG9ubHkgYmUgc2hvd24gd2hlbiB0aGUgY3VycmVudCBub2RlIGlzIGVtcHR5LlxuICAgKiBJZiBmYWxzZSwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYmUgc2hvd24gd2hlbiBhbnkgbm9kZSBpcyBlbXB0eS5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgc2hvd09ubHlDdXJyZW50OiBib29sZWFuXG5cbiAgLyoqXG4gICAqICoqQ29udHJvbHMgaWYgdGhlIHBsYWNlaG9sZGVyIHNob3VsZCBiZSBzaG93biBmb3IgYWxsIGRlc2NlbmRlbnRzLioqXG4gICAqXG4gICAqIElmIHRydWUsIHRoZSBwbGFjZWhvbGRlciB3aWxsIGJlIHNob3duIGZvciBhbGwgZGVzY2VuZGVudHMuXG4gICAqIElmIGZhbHNlLCB0aGUgcGxhY2Vob2xkZXIgd2lsbCBvbmx5IGJlIHNob3duIGZvciB0aGUgY3VycmVudCBub2RlLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaW5jbHVkZUNoaWxkcmVuOiBib29sZWFuXG59XG5cbmV4cG9ydCBjb25zdCBQbGFjZWhvbGRlciA9IEV4dGVuc2lvbi5jcmVhdGU8UGxhY2Vob2xkZXJPcHRpb25zPih7XG4gIG5hbWU6ICdwbGFjZWhvbGRlcicsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZW1wdHlFZGl0b3JDbGFzczogJ2lzLWVkaXRvci1lbXB0eScsXG4gICAgICBlbXB0eU5vZGVDbGFzczogJ2lzLWVtcHR5JyxcbiAgICAgIHBsYWNlaG9sZGVyOiAnV3JpdGUgc29tZXRoaW5nIOKApicsXG4gICAgICBzaG93T25seVdoZW5FZGl0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbnNpZGVyQW55QXNFbXB0eTogZmFsc2UsXG4gICAgICBzaG93T25seUN1cnJlbnQ6IHRydWUsXG4gICAgICBpbmNsdWRlQ2hpbGRyZW46IGZhbHNlLFxuICAgIH1cbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ3BsYWNlaG9sZGVyJyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgZGVjb3JhdGlvbnM6ICh7IGRvYywgc2VsZWN0aW9uIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuZWRpdG9yLmlzRWRpdGFibGUgfHwgIXRoaXMub3B0aW9ucy5zaG93T25seVdoZW5FZGl0YWJsZVxuICAgICAgICAgICAgY29uc3QgeyBhbmNob3IgfSA9IHNlbGVjdGlvblxuICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbnM6IERlY29yYXRpb25bXSA9IFtdXG5cbiAgICAgICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG9ubHkgY2FsY3VsYXRlIGlzRW1wdHkgb25jZSBkdWUgdG8gaXRzIHBlcmZvcm1hbmNlIGltcGFjdHMgKHNlZSBpc3N1ZSAjMzM2MClcbiAgICAgICAgICAgIGNvbnN0IHsgZmlyc3RDaGlsZCB9ID0gZG9jLmNvbnRlbnRcbiAgICAgICAgICAgIGNvbnN0IGlzTGVhZiA9IGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC50eXBlLmlzTGVhZlxuICAgICAgICAgICAgY29uc3QgaXNBdG9tID0gZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLmlzQXRvbVxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZE5vZGUgPSB0aGlzLm9wdGlvbnMuY29uc2lkZXJBbnlBc0VtcHR5XG4gICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICA6IGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC50eXBlLm5hbWUgPT09IGRvYy50eXBlLmNvbnRlbnRNYXRjaC5kZWZhdWx0VHlwZT8ubmFtZVxuICAgICAgICAgICAgY29uc3QgaXNFbXB0eURvYyA9IGRvYy5jb250ZW50LmNoaWxkQ291bnQgPD0gMVxuICAgICAgICAgICAgICAmJiBmaXJzdENoaWxkXG4gICAgICAgICAgICAgICYmIGlzVmFsaWROb2RlXG4gICAgICAgICAgICAgICYmIChmaXJzdENoaWxkLm5vZGVTaXplIDw9IDIgJiYgKCFpc0xlYWYgfHwgIWlzQXRvbSkpXG5cbiAgICAgICAgICAgIGRvYy5kZXNjZW5kYW50cygobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGhhc0FuY2hvciA9IGFuY2hvciA+PSBwb3MgJiYgYW5jaG9yIDw9IHBvcyArIG5vZGUubm9kZVNpemVcbiAgICAgICAgICAgICAgY29uc3QgaXNFbXB0eSA9ICFub2RlLmlzTGVhZiAmJiAhbm9kZS5jaGlsZENvdW50XG5cbiAgICAgICAgICAgICAgaWYgKChoYXNBbmNob3IgfHwgIXRoaXMub3B0aW9ucy5zaG93T25seUN1cnJlbnQpICYmIGlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gW3RoaXMub3B0aW9ucy5lbXB0eU5vZGVDbGFzc11cblxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5RG9jKSB7XG4gICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2godGhpcy5vcHRpb25zLmVtcHR5RWRpdG9yQ2xhc3MpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbiA9IERlY29yYXRpb24ubm9kZShwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzOiBjbGFzc2VzLmpvaW4oJyAnKSxcbiAgICAgICAgICAgICAgICAgICdkYXRhLXBsYWNlaG9sZGVyJzpcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQW5jaG9yLFxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIGRlY29yYXRpb25zLnB1c2goZGVjb3JhdGlvbilcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5jbHVkZUNoaWxkcmVuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoZG9jLCBkZWNvcmF0aW9ucylcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEJsb2NrcXVvdGVPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBibG9ja1F1b3RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIGJsb2NrcXVvdGUgbm9kZVxuICAgICAgICovXG4gICAgICBzZXRCbG9ja3F1b3RlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBibG9ja3F1b3RlIG5vZGVcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlQmxvY2txdW90ZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zZXQgYSBibG9ja3F1b3RlIG5vZGVcbiAgICAgICAqL1xuICAgICAgdW5zZXRCbG9ja3F1b3RlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaW5wdXRSZWdleCA9IC9eXFxzKj5cXHMkL1xuXG5leHBvcnQgY29uc3QgQmxvY2txdW90ZSA9IE5vZGUuY3JlYXRlPEJsb2NrcXVvdGVPcHRpb25zPih7XG5cbiAgbmFtZTogJ2Jsb2NrcXVvdGUnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgY29udGVudDogJ2Jsb2NrKycsXG5cbiAgZ3JvdXA6ICdibG9jaycsXG5cbiAgZGVmaW5pbmc6IHRydWUsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHRhZzogJ2Jsb2NrcXVvdGUnIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnYmxvY2txdW90ZScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0QmxvY2txdW90ZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMud3JhcEluKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB0b2dnbGVCbG9ja3F1b3RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVXcmFwKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB1bnNldEJsb2NrcXVvdGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmxpZnQodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtU2hpZnQtYic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUJsb2NrcXVvdGUoKSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7XG4gIE1hcmssXG4gIG1hcmtJbnB1dFJ1bGUsXG4gIG1hcmtQYXN0ZVJ1bGUsXG4gIG1lcmdlQXR0cmlidXRlcyxcbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEJvbGRPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBib2xkOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIGJvbGQgbWFya1xuICAgICAgICovXG4gICAgICBzZXRCb2xkOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBib2xkIG1hcmtcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlQm9sZDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zZXQgYSBib2xkIG1hcmtcbiAgICAgICAqL1xuICAgICAgdW5zZXRCb2xkOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc3RhcklucHV0UmVnZXggPSAvKD86XnxcXHMpKCg/OlxcKlxcKikoKD86W14qXSspKSg/OlxcKlxcKikpJC9cbmV4cG9ydCBjb25zdCBzdGFyUGFzdGVSZWdleCA9IC8oPzpefFxccykoKD86XFwqXFwqKSgoPzpbXipdKykpKD86XFwqXFwqKSkvZ1xuZXhwb3J0IGNvbnN0IHVuZGVyc2NvcmVJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpfXykoKD86W15fX10rKSkoPzpfXykpJC9cbmV4cG9ydCBjb25zdCB1bmRlcnNjb3JlUGFzdGVSZWdleCA9IC8oPzpefFxccykoKD86X18pKCg/OlteX19dKykpKD86X18pKS9nXG5cbmV4cG9ydCBjb25zdCBCb2xkID0gTWFyay5jcmVhdGU8Qm9sZE9wdGlvbnM+KHtcbiAgbmFtZTogJ2JvbGQnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ3N0cm9uZycsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6ICdiJyxcbiAgICAgICAgZ2V0QXR0cnM6IG5vZGUgPT4gKG5vZGUgYXMgSFRNTEVsZW1lbnQpLnN0eWxlLmZvbnRXZWlnaHQgIT09ICdub3JtYWwnICYmIG51bGwsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogJ2ZvbnQtd2VpZ2h0JyxcbiAgICAgICAgZ2V0QXR0cnM6IHZhbHVlID0+IC9eKGJvbGQoZXIpP3xbNS05XVxcZHsyLH0pJC8udGVzdCh2YWx1ZSBhcyBzdHJpbmcpICYmIG51bGwsXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ3N0cm9uZycsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0Qm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdG9nZ2xlQm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdW5zZXRCb2xkOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtYic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUJvbGQoKSxcbiAgICAgICdNb2QtQic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUJvbGQoKSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IHN0YXJJbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlSW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxuXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFyUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogdW5kZXJzY29yZVBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIExpc3RJdGVtT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBidWxsZXRMaXN0VHlwZU5hbWU6IHN0cmluZ1xuICBvcmRlcmVkTGlzdFR5cGVOYW1lOiBzdHJpbmdcbn1cblxuZXhwb3J0IGNvbnN0IExpc3RJdGVtID0gTm9kZS5jcmVhdGU8TGlzdEl0ZW1PcHRpb25zPih7XG4gIG5hbWU6ICdsaXN0SXRlbScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgYnVsbGV0TGlzdFR5cGVOYW1lOiAnYnVsbGV0TGlzdCcsXG4gICAgICBvcmRlcmVkTGlzdFR5cGVOYW1lOiAnb3JkZXJlZExpc3QnLFxuICAgIH1cbiAgfSxcblxuICBjb250ZW50OiAncGFyYWdyYXBoIGJsb2NrKicsXG5cbiAgZGVmaW5pbmc6IHRydWUsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ2xpJyxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnbGknLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEVudGVyOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zcGxpdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICBUYWI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNpbmtMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgJ1NoaWZ0LVRhYic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmxpZnRMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHtcbiAgZ2V0TWFya0F0dHJpYnV0ZXMsXG4gIE1hcmssXG4gIG1lcmdlQXR0cmlidXRlcyxcbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFRleHRTdHlsZU9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHRleHRTdHlsZToge1xuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgc3BhbnMgd2l0aG91dCBpbmxpbmUgc3R5bGUgYXR0cmlidXRlcy5cbiAgICAgICAqL1xuICAgICAgcmVtb3ZlRW1wdHlUZXh0U3R5bGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBUZXh0U3R5bGUgPSBNYXJrLmNyZWF0ZTxUZXh0U3R5bGVPcHRpb25zPih7XG4gIG5hbWU6ICd0ZXh0U3R5bGUnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgICBnZXRBdHRyczogZWxlbWVudCA9PiB7XG4gICAgICAgICAgY29uc3QgaGFzU3R5bGVzID0gKGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKVxuXG4gICAgICAgICAgaWYgKCFoYXNTdHlsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7fVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydzcGFuJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZW1vdmVFbXB0eVRleHRTdHlsZTogKCkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0aGlzLnR5cGUpXG4gICAgICAgIGNvbnN0IGhhc1N0eWxlcyA9IE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLnNvbWUoKFssIHZhbHVlXSkgPT4gISF2YWx1ZSlcblxuICAgICAgICBpZiAoaGFzU3R5bGVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB3cmFwcGluZ0lucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuaW1wb3J0IExpc3RJdGVtIGZyb20gJy4uLy4uL2V4dGVuc2lvbi1saXN0LWl0ZW0vc3JjL2luZGV4LmpzJ1xuaW1wb3J0IFRleHRTdHlsZSBmcm9tICcuLi8uLi9leHRlbnNpb24tdGV4dC1zdHlsZS9zcmMvaW5kZXguanMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVsbGV0TGlzdE9wdGlvbnMge1xuICBpdGVtVHlwZU5hbWU6IHN0cmluZyxcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIGtlZXBNYXJrczogYm9vbGVhbixcbiAga2VlcEF0dHJpYnV0ZXM6IGJvb2xlYW4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBidWxsZXRMaXN0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIGJ1bGxldCBsaXN0XG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUJ1bGxldExpc3Q6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbnB1dFJlZ2V4ID0gL15cXHMqKFstKypdKVxccyQvXG5cbmV4cG9ydCBjb25zdCBCdWxsZXRMaXN0ID0gTm9kZS5jcmVhdGU8QnVsbGV0TGlzdE9wdGlvbnM+KHtcbiAgbmFtZTogJ2J1bGxldExpc3QnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1UeXBlTmFtZTogJ2xpc3RJdGVtJyxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGtlZXBNYXJrczogZmFsc2UsXG4gICAgICBrZWVwQXR0cmlidXRlczogZmFsc2UsXG4gICAgfVxuICB9LFxuXG4gIGdyb3VwOiAnYmxvY2sgbGlzdCcsXG5cbiAgY29udGVudCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZX0rYFxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB0YWc6ICd1bCcgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWyd1bCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9nZ2xlQnVsbGV0TGlzdDogKCkgPT4gKHsgY29tbWFuZHMsIGNoYWluIH0pID0+IHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAgIHJldHVybiBjaGFpbigpLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKS51cGRhdGVBdHRyaWJ1dGVzKExpc3RJdGVtLm5hbWUsIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlLm5hbWUpKS5ydW4oKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcylcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLVNoaWZ0LTgnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCdWxsZXRMaXN0KCksXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgbGV0IGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgfSlcblxuICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcE1hcmtzIHx8IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGtlZXBNYXJrczogdGhpcy5vcHRpb25zLmtlZXBNYXJrcyxcbiAgICAgICAga2VlcEF0dHJpYnV0ZXM6IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcyxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogKCkgPT4geyByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGUubmFtZSkgfSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICBpbnB1dFJ1bGUsXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQge1xuICBNYXJrLFxuICBtYXJrSW5wdXRSdWxlLFxuICBtYXJrUGFzdGVSdWxlLFxuICBtZXJnZUF0dHJpYnV0ZXMsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBDb2RlT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY29kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBjb2RlIG1hcmtcbiAgICAgICAqL1xuICAgICAgc2V0Q29kZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGlubGluZSBjb2RlXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUNvZGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGEgY29kZSBtYXJrXG4gICAgICAgKi9cbiAgICAgIHVuc2V0Q29kZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGlucHV0UmVnZXggPSAvKD86XnxcXHMpKCg/OmApKCg/OlteYF0rKSkoPzpgKSkkL1xuZXhwb3J0IGNvbnN0IHBhc3RlUmVnZXggPSAvKD86XnxcXHMpKCg/OmApKCg/OlteYF0rKSkoPzpgKSkvZ1xuXG5leHBvcnQgY29uc3QgQ29kZSA9IE1hcmsuY3JlYXRlPENvZGVPcHRpb25zPih7XG4gIG5hbWU6ICdjb2RlJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIGV4Y2x1ZGVzOiAnXycsXG5cbiAgY29kZTogdHJ1ZSxcblxuICBleGl0YWJsZTogdHJ1ZSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgdGFnOiAnY29kZScgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydjb2RlJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRDb2RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB0b2dnbGVDb2RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB1bnNldENvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1lJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQ29kZSgpLFxuICAgIH1cbiAgfSxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxuXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBwYXN0ZVJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSwgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5LCBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGludGVyZmFjZSBDb2RlQmxvY2tPcHRpb25zIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBwcmVmaXggdG8gbGFuZ3VhZ2UgY2xhc3NlcyB0aGF0IGFyZSBhcHBsaWVkIHRvIGNvZGUgdGFncy5cbiAgICogRGVmYXVsdHMgdG8gYCdsYW5ndWFnZS0nYC5cbiAgICovXG4gIGxhbmd1YWdlQ2xhc3NQcmVmaXg6IHN0cmluZ1xuICAvKipcbiAgICogRGVmaW5lIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGV4aXRlZCBvbiB0cmlwbGUgZW50ZXIuXG4gICAqIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICovXG4gIGV4aXRPblRyaXBsZUVudGVyOiBib29sZWFuXG4gIC8qKlxuICAgKiBEZWZpbmUgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgZXhpdGVkIG9uIGFycm93IGRvd24gaWYgdGhlcmUgaXMgbm8gbm9kZSBhZnRlciBpdC5cbiAgICogRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKi9cbiAgZXhpdE9uQXJyb3dEb3duOiBib29sZWFuXG4gIC8qKlxuICAgKiBDdXN0b20gSFRNTCBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSByZW5kZXJlZCBIVE1MIHRhZy5cbiAgICovXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBjb2RlQmxvY2s6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgY29kZSBibG9ja1xuICAgICAgICovXG4gICAgICBzZXRDb2RlQmxvY2s6IChhdHRyaWJ1dGVzPzogeyBsYW5ndWFnZTogc3RyaW5nIH0pID0+IFJldHVyblR5cGVcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgY29kZSBibG9ja1xuICAgICAgICovXG4gICAgICB0b2dnbGVDb2RlQmxvY2s6IChhdHRyaWJ1dGVzPzogeyBsYW5ndWFnZTogc3RyaW5nIH0pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGJhY2t0aWNrSW5wdXRSZWdleCA9IC9eYGBgKFthLXpdKyk/W1xcc1xcbl0kL1xuZXhwb3J0IGNvbnN0IHRpbGRlSW5wdXRSZWdleCA9IC9efn5+KFthLXpdKyk/W1xcc1xcbl0kL1xuXG5leHBvcnQgY29uc3QgQ29kZUJsb2NrID0gTm9kZS5jcmVhdGU8Q29kZUJsb2NrT3B0aW9ucz4oe1xuICBuYW1lOiAnY29kZUJsb2NrJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsYW5ndWFnZUNsYXNzUHJlZml4OiAnbGFuZ3VhZ2UtJyxcbiAgICAgIGV4aXRPblRyaXBsZUVudGVyOiB0cnVlLFxuICAgICAgZXhpdE9uQXJyb3dEb3duOiB0cnVlLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBjb250ZW50OiAndGV4dConLFxuXG4gIG1hcmtzOiAnJyxcblxuICBncm91cDogJ2Jsb2NrJyxcblxuICBjb2RlOiB0cnVlLFxuXG4gIGRlZmluaW5nOiB0cnVlLFxuXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhbmd1YWdlOiB7XG4gICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIHBhcnNlSFRNTDogZWxlbWVudCA9PiB7XG4gICAgICAgICAgY29uc3QgeyBsYW5ndWFnZUNsYXNzUHJlZml4IH0gPSB0aGlzLm9wdGlvbnNcbiAgICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gWy4uLihlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkPy5jbGFzc0xpc3QgfHwgW10pXVxuICAgICAgICAgIGNvbnN0IGxhbmd1YWdlcyA9IGNsYXNzTmFtZXNcbiAgICAgICAgICAgIC5maWx0ZXIoY2xhc3NOYW1lID0+IGNsYXNzTmFtZS5zdGFydHNXaXRoKGxhbmd1YWdlQ2xhc3NQcmVmaXgpKVxuICAgICAgICAgICAgLm1hcChjbGFzc05hbWUgPT4gY2xhc3NOYW1lLnJlcGxhY2UobGFuZ3VhZ2VDbGFzc1ByZWZpeCwgJycpKVxuICAgICAgICAgIGNvbnN0IGxhbmd1YWdlID0gbGFuZ3VhZ2VzWzBdXG5cbiAgICAgICAgICBpZiAoIWxhbmd1YWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBsYW5ndWFnZVxuICAgICAgICB9LFxuICAgICAgICByZW5kZXJlZDogZmFsc2UsXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAncHJlJyxcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAnZnVsbCcsXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgbm9kZSwgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXG4gICAgICAncHJlJyxcbiAgICAgIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSxcbiAgICAgIFtcbiAgICAgICAgJ2NvZGUnLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3M6IG5vZGUuYXR0cnMubGFuZ3VhZ2VcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLmxhbmd1YWdlQ2xhc3NQcmVmaXggKyBub2RlLmF0dHJzLmxhbmd1YWdlXG4gICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICAgIDAsXG4gICAgICBdLFxuICAgIF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0Q29kZUJsb2NrOlxuICAgICAgICBhdHRyaWJ1dGVzID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpXG4gICAgICAgIH0sXG4gICAgICB0b2dnbGVDb2RlQmxvY2s6XG4gICAgICAgIGF0dHJpYnV0ZXMgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVOb2RlKHRoaXMubmFtZSwgJ3BhcmFncmFwaCcsIGF0dHJpYnV0ZXMpXG4gICAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLUFsdC1jJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQ29kZUJsb2NrKCksXG5cbiAgICAgIC8vIHJlbW92ZSBjb2RlIGJsb2NrIHdoZW4gYXQgc3RhcnQgb2YgZG9jdW1lbnQgb3IgY29kZSBibG9jayBpcyBlbXB0eVxuICAgICAgQmFja3NwYWNlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZW1wdHksICRhbmNob3IgfSA9IHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvblxuICAgICAgICBjb25zdCBpc0F0U3RhcnQgPSAkYW5jaG9yLnBvcyA9PT0gMVxuXG4gICAgICAgIGlmICghZW1wdHkgfHwgJGFuY2hvci5wYXJlbnQudHlwZS5uYW1lICE9PSB0aGlzLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0F0U3RhcnQgfHwgISRhbmNob3IucGFyZW50LnRleHRDb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5jb21tYW5kcy5jbGVhck5vZGVzKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgLy8gZXhpdCBub2RlIG9uIHRyaXBsZSBlbnRlclxuICAgICAgRW50ZXI6ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmV4aXRPblRyaXBsZUVudGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBlZGl0b3JcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gICAgICAgIGNvbnN0IHsgJGZyb20sIGVtcHR5IH0gPSBzZWxlY3Rpb25cblxuICAgICAgICBpZiAoIWVtcHR5IHx8ICRmcm9tLnBhcmVudC50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzQXRFbmQgPSAkZnJvbS5wYXJlbnRPZmZzZXQgPT09ICRmcm9tLnBhcmVudC5ub2RlU2l6ZSAtIDJcbiAgICAgICAgY29uc3QgZW5kc1dpdGhEb3VibGVOZXdsaW5lID0gJGZyb20ucGFyZW50LnRleHRDb250ZW50LmVuZHNXaXRoKCdcXG5cXG4nKVxuXG4gICAgICAgIGlmICghaXNBdEVuZCB8fCAhZW5kc1dpdGhEb3VibGVOZXdsaW5lKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWRpdG9yXG4gICAgICAgICAgLmNoYWluKClcbiAgICAgICAgICAuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgICB0ci5kZWxldGUoJGZyb20ucG9zIC0gMiwgJGZyb20ucG9zKVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmV4aXRDb2RlKClcbiAgICAgICAgICAucnVuKClcbiAgICAgIH0sXG5cbiAgICAgIC8vIGV4aXQgbm9kZSBvbiBhcnJvdyBkb3duXG4gICAgICBBcnJvd0Rvd246ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmV4aXRPbkFycm93RG93bikge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yXG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHN0YXRlXG4gICAgICAgIGNvbnN0IHsgJGZyb20sIGVtcHR5IH0gPSBzZWxlY3Rpb25cblxuICAgICAgICBpZiAoIWVtcHR5IHx8ICRmcm9tLnBhcmVudC50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzQXRFbmQgPSAkZnJvbS5wYXJlbnRPZmZzZXQgPT09ICRmcm9tLnBhcmVudC5ub2RlU2l6ZSAtIDJcblxuICAgICAgICBpZiAoIWlzQXRFbmQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFmdGVyID0gJGZyb20uYWZ0ZXIoKVxuXG4gICAgICAgIGlmIChhZnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub2RlQWZ0ZXIgPSBkb2Mubm9kZUF0KGFmdGVyKVxuXG4gICAgICAgIGlmIChub2RlQWZ0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlZGl0b3IuY29tbWFuZHMuZXhpdENvZGUoKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGJhY2t0aWNrSW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiBtYXRjaCA9PiAoe1xuICAgICAgICAgIGxhbmd1YWdlOiBtYXRjaFsxXSxcbiAgICAgICAgfSksXG4gICAgICB9KSxcbiAgICAgIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiB0aWxkZUlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHtcbiAgICAgICAgICBsYW5ndWFnZTogbWF0Y2hbMV0sXG4gICAgICAgIH0pLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gdGhpcyBwbHVnaW4gY3JlYXRlcyBhIGNvZGUgYmxvY2sgZm9yIHBhc3RlZCBjb250ZW50IGZyb20gVlMgQ29kZVxuICAgICAgLy8gd2UgY2FuIGFsc28gZGV0ZWN0IHRoZSBjb3BpZWQgY29kZSBsYW5ndWFnZVxuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnY29kZUJsb2NrVlNDb2RlSGFuZGxlcicpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGhhbmRsZVBhc3RlOiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghZXZlbnQuY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZG9u4oCZdCBjcmVhdGUgYSBuZXcgY29kZSBibG9jayB3aXRoaW4gY29kZSBibG9ja3NcbiAgICAgICAgICAgIGlmICh0aGlzLmVkaXRvci5pc0FjdGl2ZSh0aGlzLnR5cGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKVxuICAgICAgICAgICAgY29uc3QgdnNjb2RlID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd2c2NvZGUtZWRpdG9yLWRhdGEnKVxuICAgICAgICAgICAgY29uc3QgdnNjb2RlRGF0YSA9IHZzY29kZSA/IEpTT04ucGFyc2UodnNjb2RlKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSB2c2NvZGVEYXRhPy5tb2RlXG5cbiAgICAgICAgICAgIGlmICghdGV4dCB8fCAhbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHsgdHIgfSA9IHZpZXcuc3RhdGVcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IGNvZGUgYmxvY2tcbiAgICAgICAgICAgIHRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHRoaXMudHlwZS5jcmVhdGUoeyBsYW5ndWFnZSB9KSlcblxuICAgICAgICAgICAgLy8gcHV0IGN1cnNvciBpbnNpZGUgdGhlIG5ld2x5IGNyZWF0ZWQgY29kZSBibG9ja1xuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShNYXRoLm1heCgwLCB0ci5zZWxlY3Rpb24uZnJvbSAtIDIpKSkpXG5cbiAgICAgICAgICAgIC8vIGFkZCB0ZXh0IHRvIGNvZGUgYmxvY2tcbiAgICAgICAgICAgIC8vIHN0cmlwIGNhcnJpYWdlIHJldHVybiBjaGFycyBmcm9tIHRleHQgcGFzdGVkIGFzIGNvZGVcbiAgICAgICAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yLXZpZXcvY29tbWl0L2E1MGE2YmNjZWI0Y2U1MmFjOGZjYzYxNjI0ODhkODg3NTYxM2FhY2RcbiAgICAgICAgICAgIHRyLmluc2VydFRleHQodGV4dC5yZXBsYWNlKC9cXHJcXG4/L2csICdcXG4nKSlcblxuICAgICAgICAgICAgLy8gc3RvcmUgbWV0YSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgLy8gdGhpcyBpcyB1c2VmdWwgZm9yIG90aGVyIHBsdWdpbnMgdGhhdCBkZXBlbmRzIG9uIHRoZSBwYXN0ZSBldmVudFxuICAgICAgICAgICAgLy8gbGlrZSB0aGUgcGFzdGUgcnVsZSBwbHVnaW5cbiAgICAgICAgICAgIHRyLnNldE1ldGEoJ3Bhc3RlJywgdHJ1ZSlcblxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cilcblxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgY29uc3QgRG9jdW1lbnQgPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6ICdkb2MnLFxuICB0b3BOb2RlOiB0cnVlLFxuICBjb250ZW50OiAnYmxvY2srJyxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgZHJvcFBvaW50IH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcblxuLyoqXG5DcmVhdGUgYSBwbHVnaW4gdGhhdCwgd2hlbiBhZGRlZCB0byBhIFByb3NlTWlycm9yIGluc3RhbmNlLFxuY2F1c2VzIGEgZGVjb3JhdGlvbiB0byBzaG93IHVwIGF0IHRoZSBkcm9wIHBvc2l0aW9uIHdoZW4gc29tZXRoaW5nXG5pcyBkcmFnZ2VkIG92ZXIgdGhlIGVkaXRvci5cblxuTm9kZXMgbWF5IGFkZCBhIGBkaXNhYmxlRHJvcEN1cnNvcmAgcHJvcGVydHkgdG8gdGhlaXIgc3BlYyB0b1xuY29udHJvbCB0aGUgc2hvd2luZyBvZiBhIGRyb3AgY3Vyc29yIGluc2lkZSB0aGVtLiBUaGlzIG1heSBiZSBhXG5ib29sZWFuIG9yIGEgZnVuY3Rpb24sIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYSB2aWV3IGFuZCBhXG5wb3NpdGlvbiwgYW5kIHNob3VsZCByZXR1cm4gYSBib29sZWFuLlxuKi9cbmZ1bmN0aW9uIGRyb3BDdXJzb3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICB2aWV3KGVkaXRvclZpZXcpIHsgcmV0dXJuIG5ldyBEcm9wQ3Vyc29yVmlldyhlZGl0b3JWaWV3LCBvcHRpb25zKTsgfVxuICAgIH0pO1xufVxuY2xhc3MgRHJvcEN1cnNvclZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGVkaXRvclZpZXcsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmVkaXRvclZpZXcgPSBlZGl0b3JWaWV3O1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLndpZHRoID0gKF9hID0gb3B0aW9ucy53aWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdGlvbnMuY29sb3IgPT09IGZhbHNlID8gdW5kZWZpbmVkIDogKG9wdGlvbnMuY29sb3IgfHwgXCJibGFja1wiKTtcbiAgICAgICAgdGhpcy5jbGFzcyA9IG9wdGlvbnMuY2xhc3M7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXCJkcmFnb3ZlclwiLCBcImRyYWdlbmRcIiwgXCJkcm9wXCIsIFwiZHJhZ2xlYXZlXCJdLm1hcChuYW1lID0+IHtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyID0gKGUpID0+IHsgdGhpc1tuYW1lXShlKTsgfTtcbiAgICAgICAgICAgIGVkaXRvclZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lLCBoYW5kbGVyIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzLmZvckVhY2goKHsgbmFtZSwgaGFuZGxlciB9KSA9PiB0aGlzLmVkaXRvclZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcikpO1xuICAgIH1cbiAgICB1cGRhdGUoZWRpdG9yVmlldywgcHJldlN0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvclBvcyAhPSBudWxsICYmIHByZXZTdGF0ZS5kb2MgIT0gZWRpdG9yVmlldy5zdGF0ZS5kb2MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnNvclBvcyA+IGVkaXRvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnNvcihudWxsKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU92ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDdXJzb3IocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPT0gdGhpcy5jdXJzb3JQb3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gcG9zO1xuICAgICAgICBpZiAocG9zID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlT3ZlcmxheSgpIHtcbiAgICAgICAgbGV0ICRwb3MgPSB0aGlzLmVkaXRvclZpZXcuc3RhdGUuZG9jLnJlc29sdmUodGhpcy5jdXJzb3JQb3MpO1xuICAgICAgICBsZXQgaXNCbG9jayA9ICEkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50LCByZWN0O1xuICAgICAgICBpZiAoaXNCbG9jaykge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgICAgIGlmIChiZWZvcmUgfHwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZWRpdG9yVmlldy5ub2RlRE9NKHRoaXMuY3Vyc29yUG9zIC0gKGJlZm9yZSA/IGJlZm9yZS5ub2RlU2l6ZSA6IDApKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZVJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9wID0gYmVmb3JlID8gbm9kZVJlY3QuYm90dG9tIDogbm9kZVJlY3QudG9wO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlICYmIGFmdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gKHRvcCArIHRoaXMuZWRpdG9yVmlldy5ub2RlRE9NKHRoaXMuY3Vyc29yUG9zKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogbm9kZVJlY3QubGVmdCwgcmlnaHQ6IG5vZGVSZWN0LnJpZ2h0LCB0b3A6IHRvcCAtIHRoaXMud2lkdGggLyAyLCBib3R0b206IHRvcCArIHRoaXMud2lkdGggLyAyIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVjdCkge1xuICAgICAgICAgICAgbGV0IGNvb3JkcyA9IHRoaXMuZWRpdG9yVmlldy5jb29yZHNBdFBvcyh0aGlzLmN1cnNvclBvcyk7XG4gICAgICAgICAgICByZWN0ID0geyBsZWZ0OiBjb29yZHMubGVmdCAtIHRoaXMud2lkdGggLyAyLCByaWdodDogY29vcmRzLmxlZnQgKyB0aGlzLndpZHRoIC8gMiwgdG9wOiBjb29yZHMudG9wLCBib3R0b206IGNvb3Jkcy5ib3R0b20gfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5lZGl0b3JWaWV3LmRvbS5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGFzcylcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5jbGFzcztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IHotaW5kZXg6IDUwOyBwb2ludGVyLWV2ZW50czogbm9uZTtcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJwcm9zZW1pcnJvci1kcm9wY3Vyc29yLWJsb2NrXCIsIGlzQmxvY2spO1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcInByb3NlbWlycm9yLWRyb3BjdXJzb3ItaW5saW5lXCIsICFpc0Jsb2NrKTtcbiAgICAgICAgbGV0IHBhcmVudExlZnQsIHBhcmVudFRvcDtcbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50ID09IGRvY3VtZW50LmJvZHkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpLnBvc2l0aW9uID09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICAgIHBhcmVudExlZnQgPSAtcGFnZVhPZmZzZXQ7XG4gICAgICAgICAgICBwYXJlbnRUb3AgPSAtcGFnZVlPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHBhcmVudExlZnQgPSByZWN0LmxlZnQgLSBwYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHBhcmVudFRvcCA9IHJlY3QudG9wIC0gcGFyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubGVmdCA9IChyZWN0LmxlZnQgLSBwYXJlbnRMZWZ0KSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCA9IChyZWN0LnRvcCAtIHBhcmVudFRvcCkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IChyZWN0LmJvdHRvbSAtIHJlY3QudG9wKSArIFwicHhcIjtcbiAgICB9XG4gICAgc2NoZWR1bGVSZW1vdmFsKHRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZXRDdXJzb3IobnVsbCksIHRpbWVvdXQpO1xuICAgIH1cbiAgICBkcmFnb3ZlcihldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZWRpdG9yVmlldy5lZGl0YWJsZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZWRpdG9yVmlldy5wb3NBdENvb3Jkcyh7IGxlZnQ6IGV2ZW50LmNsaWVudFgsIHRvcDogZXZlbnQuY2xpZW50WSB9KTtcbiAgICAgICAgbGV0IG5vZGUgPSBwb3MgJiYgcG9zLmluc2lkZSA+PSAwICYmIHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5kb2Mubm9kZUF0KHBvcy5pbnNpZGUpO1xuICAgICAgICBsZXQgZGlzYWJsZURyb3BDdXJzb3IgPSBub2RlICYmIG5vZGUudHlwZS5zcGVjLmRpc2FibGVEcm9wQ3Vyc29yO1xuICAgICAgICBsZXQgZGlzYWJsZWQgPSB0eXBlb2YgZGlzYWJsZURyb3BDdXJzb3IgPT0gXCJmdW5jdGlvblwiID8gZGlzYWJsZURyb3BDdXJzb3IodGhpcy5lZGl0b3JWaWV3LCBwb3MsIGV2ZW50KSA6IGRpc2FibGVEcm9wQ3Vyc29yO1xuICAgICAgICBpZiAocG9zICYmICFkaXNhYmxlZCkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHBvcy5wb3M7XG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0b3JWaWV3LmRyYWdnaW5nICYmIHRoaXMuZWRpdG9yVmlldy5kcmFnZ2luZy5zbGljZSkge1xuICAgICAgICAgICAgICAgIGxldCBwb2ludCA9IGRyb3BQb2ludCh0aGlzLmVkaXRvclZpZXcuc3RhdGUuZG9jLCB0YXJnZXQsIHRoaXMuZWRpdG9yVmlldy5kcmFnZ2luZy5zbGljZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IodGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW1vdmFsKDUwMDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYWdlbmQoKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZW1vdmFsKDIwKTtcbiAgICB9XG4gICAgZHJvcCgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoMjApO1xuICAgIH1cbiAgICBkcmFnbGVhdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PSB0aGlzLmVkaXRvclZpZXcuZG9tIHx8ICF0aGlzLmVkaXRvclZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IobnVsbCk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBkcm9wQ3Vyc29yIH07XG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgZHJvcEN1cnNvciB9IGZyb20gJ0B0aXB0YXAvcG0vZHJvcGN1cnNvcidcblxuZXhwb3J0IGludGVyZmFjZSBEcm9wY3Vyc29yT3B0aW9ucyB7XG4gIGNvbG9yOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIHdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gIGNsYXNzOiBzdHJpbmcgfCB1bmRlZmluZWQsXG59XG5cbmV4cG9ydCBjb25zdCBEcm9wY3Vyc29yID0gRXh0ZW5zaW9uLmNyZWF0ZTxEcm9wY3Vyc29yT3B0aW9ucz4oe1xuICBuYW1lOiAnZHJvcEN1cnNvcicsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgd2lkdGg6IDEsXG4gICAgICBjbGFzczogdW5kZWZpbmVkLFxuICAgIH1cbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGRyb3BDdXJzb3IodGhpcy5vcHRpb25zKSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IGtleWRvd25IYW5kbGVyIH0gZnJvbSAncHJvc2VtaXJyb3Ita2V5bWFwJztcbmltcG9ydCB7IFNlbGVjdGlvbiwgTm9kZVNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiwgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgU2xpY2UsIEZyYWdtZW50IH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgRGVjb3JhdGlvblNldCwgRGVjb3JhdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuXG4vKipcbkdhcCBjdXJzb3Igc2VsZWN0aW9ucyBhcmUgcmVwcmVzZW50ZWQgdXNpbmcgdGhpcyBjbGFzcy4gSXRzXG5gJGFuY2hvcmAgYW5kIGAkaGVhZGAgcHJvcGVydGllcyBib3RoIHBvaW50IGF0IHRoZSBjdXJzb3IgcG9zaXRpb24uXG4qL1xuY2xhc3MgR2FwQ3Vyc29yIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBnYXAgY3Vyc29yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoJHBvcykge1xuICAgICAgICBzdXBlcigkcG9zLCAkcG9zKTtcbiAgICB9XG4gICAgbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgICAgICByZXR1cm4gR2FwQ3Vyc29yLnZhbGlkKCRwb3MpID8gbmV3IEdhcEN1cnNvcigkcG9zKSA6IFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbiAgICBjb250ZW50KCkgeyByZXR1cm4gU2xpY2UuZW1wdHk7IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBHYXBDdXJzb3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWQ7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJnYXBjdXJzb3JcIiwgcG9zOiB0aGlzLmhlYWQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgR2FwQ3Vyc29yLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEdhcEN1cnNvcihkb2MucmVzb2x2ZShqc29uLnBvcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldEJvb2ttYXJrKCkgeyByZXR1cm4gbmV3IEdhcEJvb2ttYXJrKHRoaXMuYW5jaG9yKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHZhbGlkKCRwb3MpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRwb3MucGFyZW50O1xuICAgICAgICBpZiAocGFyZW50LmlzVGV4dGJsb2NrIHx8ICFjbG9zZWRCZWZvcmUoJHBvcykgfHwgIWNsb3NlZEFmdGVyKCRwb3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSBwYXJlbnQudHlwZS5zcGVjLmFsbG93R2FwQ3Vyc29yO1xuICAgICAgICBpZiAob3ZlcnJpZGUgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBvdmVycmlkZTtcbiAgICAgICAgbGV0IGRlZmx0ID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KCRwb3MuaW5kZXgoKSkuZGVmYXVsdFR5cGU7XG4gICAgICAgIHJldHVybiBkZWZsdCAmJiBkZWZsdC5pc1RleHRibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEdhcEN1cnNvckZyb20oJHBvcywgZGlyLCBtdXN0TW92ZSA9IGZhbHNlKSB7XG4gICAgICAgIHNlYXJjaDogZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKCFtdXN0TW92ZSAmJiBHYXBDdXJzb3IudmFsaWQoJHBvcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3M7XG4gICAgICAgICAgICBsZXQgcG9zID0gJHBvcy5wb3MsIG5leHQgPSBudWxsO1xuICAgICAgICAgICAgLy8gU2NhbiB1cCBmcm9tIHRoaXMgcG9zaXRpb25cbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOzsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMCA/ICRwb3MuaW5kZXhBZnRlcihkKSA8IHBhcmVudC5jaGlsZENvdW50IDogJHBvcy5pbmRleChkKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBhcmVudC5jaGlsZChkaXIgPiAwID8gJHBvcy5pbmRleEFmdGVyKGQpIDogJHBvcy5pbmRleChkKSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gZGlyO1xuICAgICAgICAgICAgICAgIGxldCAkY3VyID0gJHBvcy5kb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChHYXBDdXJzb3IudmFsaWQoJGN1cikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQW5kIHRoZW4gZG93biBpbnRvIHRoZSBuZXh0IG5vZGVcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zaWRlID0gZGlyID4gMCA/IG5leHQuZmlyc3RDaGlsZCA6IG5leHQubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmICghaW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmlzQXRvbSAmJiAhbmV4dC5pc1RleHQgJiYgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcG9zID0gJHBvcy5kb2MucmVzb2x2ZShwb3MgKyBuZXh0Lm5vZGVTaXplICogZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBzZWFyY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQgPSBpbnNpZGU7XG4gICAgICAgICAgICAgICAgcG9zICs9IGRpcjtcbiAgICAgICAgICAgICAgICBsZXQgJGN1ciA9ICRwb3MuZG9jLnJlc29sdmUocG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoR2FwQ3Vyc29yLnZhbGlkKCRjdXIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuR2FwQ3Vyc29yLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5HYXBDdXJzb3IuZmluZEZyb20gPSBHYXBDdXJzb3IuZmluZEdhcEN1cnNvckZyb207XG5TZWxlY3Rpb24uanNvbklEKFwiZ2FwY3Vyc29yXCIsIEdhcEN1cnNvcik7XG5jbGFzcyBHYXBCb29rbWFyayB7XG4gICAgY29uc3RydWN0b3IocG9zKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbmV3IEdhcEJvb2ttYXJrKG1hcHBpbmcubWFwKHRoaXMucG9zKSk7XG4gICAgfVxuICAgIHJlc29sdmUoZG9jKSB7XG4gICAgICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUodGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gR2FwQ3Vyc29yLnZhbGlkKCRwb3MpID8gbmV3IEdhcEN1cnNvcigkcG9zKSA6IFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlZEJlZm9yZSgkcG9zKSB7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXgoZCksIHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICAgICAgLy8gQXQgdGhlIHN0YXJ0IG9mIHRoaXMgcGFyZW50LCBsb29rIGF0IG5leHQgb25lXG4gICAgICAgIGlmIChpbmRleCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgaWYgdGhlIG5vZGUgYmVmb3JlIChvciBpdHMgZmlyc3QgYW5jZXN0b3IpIGlzIGNsb3NlZFxuICAgICAgICBmb3IgKGxldCBiZWZvcmUgPSBwYXJlbnQuY2hpbGQoaW5kZXggLSAxKTs7IGJlZm9yZSA9IGJlZm9yZS5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmICgoYmVmb3JlLmNoaWxkQ291bnQgPT0gMCAmJiAhYmVmb3JlLmlubGluZUNvbnRlbnQpIHx8IGJlZm9yZS5pc0F0b20gfHwgYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoYmVmb3JlLmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhpdCBzdGFydCBvZiBkb2N1bWVudFxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2xvc2VkQWZ0ZXIoJHBvcykge1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoZCksIHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICAgICAgaWYgKGluZGV4ID09IHBhcmVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBhZnRlciA9IHBhcmVudC5jaGlsZChpbmRleCk7OyBhZnRlciA9IGFmdGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmICgoYWZ0ZXIuY2hpbGRDb3VudCA9PSAwICYmICFhZnRlci5pbmxpbmVDb250ZW50KSB8fCBhZnRlci5pc0F0b20gfHwgYWZ0ZXIudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChhZnRlci5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG5DcmVhdGUgYSBnYXAgY3Vyc29yIHBsdWdpbi4gV2hlbiBlbmFibGVkLCB0aGlzIHdpbGwgY2FwdHVyZSBjbGlja3Ncbm5lYXIgYW5kIGFycm93LWtleS1tb3Rpb24gcGFzdCBwbGFjZXMgdGhhdCBkb24ndCBoYXZlIGEgbm9ybWFsbHlcbnNlbGVjdGFibGUgcG9zaXRpb24gbmVhcmJ5LCBhbmQgY3JlYXRlIGEgZ2FwIGN1cnNvciBzZWxlY3Rpb24gZm9yXG50aGVtLiBUaGUgY3Vyc29yIGlzIGRyYXduIGFzIGFuIGVsZW1lbnQgd2l0aCBjbGFzc1xuYFByb3NlTWlycm9yLWdhcGN1cnNvcmAuIFlvdSBjYW4gZWl0aGVyIGluY2x1ZGVcbmBzdHlsZS9nYXBjdXJzb3IuY3NzYCBmcm9tIHRoZSBwYWNrYWdlJ3MgZGlyZWN0b3J5IG9yIGFkZCB5b3VyIG93blxuc3R5bGVzIHRvIG1ha2UgaXQgdmlzaWJsZS5cbiovXG5mdW5jdGlvbiBnYXBDdXJzb3IoKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IGRyYXdHYXBDdXJzb3IsXG4gICAgICAgICAgICBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuKF92aWV3LCAkYW5jaG9yLCAkaGVhZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkYW5jaG9yLnBvcyA9PSAkaGVhZC5wb3MgJiYgR2FwQ3Vyc29yLnZhbGlkKCRoZWFkKSA/IG5ldyBHYXBDdXJzb3IoJGhlYWQpIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVDbGljayxcbiAgICAgICAgICAgIGhhbmRsZUtleURvd24sXG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHsgYmVmb3JlaW5wdXQ6IGJlZm9yZWlucHV0IH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgaGFuZGxlS2V5RG93biA9IGtleWRvd25IYW5kbGVyKHtcbiAgICBcIkFycm93TGVmdFwiOiBhcnJvdyhcImhvcml6XCIsIC0xKSxcbiAgICBcIkFycm93UmlnaHRcIjogYXJyb3coXCJob3JpelwiLCAxKSxcbiAgICBcIkFycm93VXBcIjogYXJyb3coXCJ2ZXJ0XCIsIC0xKSxcbiAgICBcIkFycm93RG93blwiOiBhcnJvdyhcInZlcnRcIiwgMSlcbn0pO1xuZnVuY3Rpb24gYXJyb3coYXhpcywgZGlyKSB7XG4gICAgY29uc3QgZGlyU3RyID0gYXhpcyA9PSBcInZlcnRcIiA/IChkaXIgPiAwID8gXCJkb3duXCIgOiBcInVwXCIpIDogKGRpciA+IDAgPyBcInJpZ2h0XCIgOiBcImxlZnRcIik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICAgICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0ICRzdGFydCA9IGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tLCBtdXN0TW92ZSA9IHNlbC5lbXB0eTtcbiAgICAgICAgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghdmlldy5lbmRPZlRleHRibG9jayhkaXJTdHIpIHx8ICRzdGFydC5kZXB0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHN0YXJ0LmFmdGVyKCkgOiAkc3RhcnQuYmVmb3JlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCAkZm91bmQgPSBHYXBDdXJzb3IuZmluZEdhcEN1cnNvckZyb20oJHN0YXJ0LCBkaXIsIG11c3RNb3ZlKTtcbiAgICAgICAgaWYgKCEkZm91bmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgR2FwQ3Vyc29yKCRmb3VuZCkpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNsaWNrKHZpZXcsIHBvcywgZXZlbnQpIHtcbiAgICBpZiAoIXZpZXcgfHwgIXZpZXcuZWRpdGFibGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoIUdhcEN1cnNvci52YWxpZCgkcG9zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjbGlja1BvcyA9IHZpZXcucG9zQXRDb29yZHMoeyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfSk7XG4gICAgaWYgKGNsaWNrUG9zICYmIGNsaWNrUG9zLmluc2lkZSA+IC0xICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKHZpZXcuc3RhdGUuZG9jLm5vZGVBdChjbGlja1Bvcy5pbnNpZGUpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEdhcEN1cnNvcigkcG9zKSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gVGhpcyBpcyBhIGhhY2sgdGhhdCwgd2hlbiBhIGNvbXBvc2l0aW9uIHN0YXJ0cyB3aGlsZSBhIGdhcCBjdXJzb3Jcbi8vIGlzIGFjdGl2ZSwgcXVpY2tseSBjcmVhdGVzIGFuIGlubGluZSBjb250ZXh0IGZvciB0aGUgY29tcG9zaXRpb24gdG9cbi8vIGhhcHBlbiBpbiwgdG8gYXZvaWQgaXQgYmVpbmcgYWJvcnRlZCBieSB0aGUgRE9NIHNlbGVjdGlvbiBiZWluZ1xuLy8gbW92ZWQgaW50byBhIHZhbGlkIHBvc2l0aW9uLlxuZnVuY3Rpb24gYmVmb3JlaW5wdXQodmlldywgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaW5wdXRUeXBlICE9IFwiaW5zZXJ0Q29tcG9zaXRpb25UZXh0XCIgfHwgISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEdhcEN1cnNvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyAkZnJvbSB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IGluc2VydCA9ICRmcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleCgpKS5maW5kV3JhcHBpbmcodmlldy5zdGF0ZS5zY2hlbWEubm9kZXMudGV4dCk7XG4gICAgaWYgKCFpbnNlcnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZnJhZyA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGkgPSBpbnNlcnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGZyYWcgPSBGcmFnbWVudC5mcm9tKGluc2VydFtpXS5jcmVhdGVBbmRGaWxsKG51bGwsIGZyYWcpKTtcbiAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnJlcGxhY2UoJGZyb20ucG9zLCAkZnJvbS5wb3MsIG5ldyBTbGljZShmcmFnLCAwLCAwKSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAxKSkpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRyYXdHYXBDdXJzb3Ioc3RhdGUpIHtcbiAgICBpZiAoIShzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBHYXBDdXJzb3IpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbm9kZS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLWdhcGN1cnNvclwiO1xuICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtEZWNvcmF0aW9uLndpZGdldChzdGF0ZS5zZWxlY3Rpb24uaGVhZCwgbm9kZSwgeyBrZXk6IFwiZ2FwY3Vyc29yXCIgfSldKTtcbn1cblxuZXhwb3J0IHsgR2FwQ3Vyc29yLCBnYXBDdXJzb3IgfTtcbiIsICJpbXBvcnQge1xuICBjYWxsT3JSZXR1cm4sXG4gIEV4dGVuc2lvbixcbiAgZ2V0RXh0ZW5zaW9uRmllbGQsXG4gIFBhcmVudENvbmZpZyxcbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgZ2FwQ3Vyc29yIH0gZnJvbSAnQHRpcHRhcC9wbS9nYXBjdXJzb3InXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4ge1xuICAgIC8qKlxuICAgICAqIEFsbG93IGdhcCBjdXJzb3JcbiAgICAgKi9cbiAgICBhbGxvd0dhcEN1cnNvcj86XG4gICAgICB8IGJvb2xlYW5cbiAgICAgIHwgbnVsbFxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgICBvcHRpb25zOiBPcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBTdG9yYWdlLFxuICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnM+PlsnYWxsb3dHYXBDdXJzb3InXSxcbiAgICAgIH0pID0+IGJvb2xlYW4gfCBudWxsKSxcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgR2FwY3Vyc29yID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdnYXBDdXJzb3InLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgZ2FwQ3Vyc29yKCksXG4gICAgXVxuICB9LFxuXG4gIGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWxsb3dHYXBDdXJzb3I6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhbGxvd0dhcEN1cnNvcicsIGNvbnRleHQpKSA/PyBudWxsLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEhhcmRCcmVha09wdGlvbnMge1xuICBrZWVwTWFya3M6IGJvb2xlYW4sXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaGFyZEJyZWFrOiB7XG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhIGhhcmQgYnJlYWtcbiAgICAgICAqL1xuICAgICAgc2V0SGFyZEJyZWFrOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgSGFyZEJyZWFrID0gTm9kZS5jcmVhdGU8SGFyZEJyZWFrT3B0aW9ucz4oe1xuICBuYW1lOiAnaGFyZEJyZWFrJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZWVwTWFya3M6IHRydWUsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIGlubGluZTogdHJ1ZSxcblxuICBncm91cDogJ2lubGluZScsXG5cbiAgc2VsZWN0YWJsZTogZmFsc2UsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHRhZzogJ2JyJyB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ2JyJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpXVxuICB9LFxuXG4gIHJlbmRlclRleHQoKSB7XG4gICAgcmV0dXJuICdcXG4nXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEhhcmRCcmVhazogKCkgPT4gKHtcbiAgICAgICAgY29tbWFuZHMsXG4gICAgICAgIGNoYWluLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZWRpdG9yLFxuICAgICAgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuZmlyc3QoW1xuICAgICAgICAgICgpID0+IGNvbW1hbmRzLmV4aXRDb2RlKCksXG4gICAgICAgICAgKCkgPT4gY29tbWFuZHMuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlXG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uJGZyb20ucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHsga2VlcE1hcmtzIH0gPSB0aGlzLm9wdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IHsgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlclxuICAgICAgICAgICAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrc1xuICAgICAgICAgICAgICB8fCAoc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG5cbiAgICAgICAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgICAgICAgIC5pbnNlcnRDb250ZW50KHsgdHlwZTogdGhpcy5uYW1lIH0pXG4gICAgICAgICAgICAgIC5jb21tYW5kKCh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoICYmIG1hcmtzICYmIGtlZXBNYXJrcykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKVxuXG4gICAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5ydW4oKVxuICAgICAgICAgIH0pLFxuICAgICAgICBdKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtRW50ZXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRIYXJkQnJlYWsoKSxcbiAgICAgICdTaGlmdC1FbnRlcic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldEhhcmRCcmVhaygpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgdHlwZSBMZXZlbCA9IDEgfCAyIHwgMyB8IDQgfCA1IHwgNlxuXG5leHBvcnQgaW50ZXJmYWNlIEhlYWRpbmdPcHRpb25zIHtcbiAgbGV2ZWxzOiBMZXZlbFtdLFxuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGhlYWRpbmc6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgaGVhZGluZyBub2RlXG4gICAgICAgKi9cbiAgICAgIHNldEhlYWRpbmc6IChhdHRyaWJ1dGVzOiB7IGxldmVsOiBMZXZlbCB9KSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBoZWFkaW5nIG5vZGVcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlSGVhZGluZzogKGF0dHJpYnV0ZXM6IHsgbGV2ZWw6IExldmVsIH0pID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBIZWFkaW5nID0gTm9kZS5jcmVhdGU8SGVhZGluZ09wdGlvbnM+KHtcbiAgbmFtZTogJ2hlYWRpbmcnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsczogWzEsIDIsIDMsIDQsIDUsIDZdLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBjb250ZW50OiAnaW5saW5lKicsXG5cbiAgZ3JvdXA6ICdibG9jaycsXG5cbiAgZGVmaW5pbmc6IHRydWUsXG5cbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWw6IHtcbiAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgcmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGV2ZWxzXG4gICAgICAubWFwKChsZXZlbDogTGV2ZWwpID0+ICh7XG4gICAgICAgIHRhZzogYGgke2xldmVsfWAsXG4gICAgICAgIGF0dHJzOiB7IGxldmVsIH0sXG4gICAgICB9KSlcbiAgfSxcblxuICByZW5kZXJIVE1MKHsgbm9kZSwgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIGNvbnN0IGhhc0xldmVsID0gdGhpcy5vcHRpb25zLmxldmVscy5pbmNsdWRlcyhub2RlLmF0dHJzLmxldmVsKVxuICAgIGNvbnN0IGxldmVsID0gaGFzTGV2ZWxcbiAgICAgID8gbm9kZS5hdHRycy5sZXZlbFxuICAgICAgOiB0aGlzLm9wdGlvbnMubGV2ZWxzWzBdXG5cbiAgICByZXR1cm4gW2BoJHtsZXZlbH1gLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEhlYWRpbmc6IGF0dHJpYnV0ZXMgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMoYXR0cmlidXRlcy5sZXZlbCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSwgYXR0cmlidXRlcylcbiAgICAgIH0sXG4gICAgICB0b2dnbGVIZWFkaW5nOiBhdHRyaWJ1dGVzID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubGV2ZWxzLmluY2x1ZGVzKGF0dHJpYnV0ZXMubGV2ZWwpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTm9kZSh0aGlzLm5hbWUsICdwYXJhZ3JhcGgnLCBhdHRyaWJ1dGVzKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHMucmVkdWNlKChpdGVtcywgbGV2ZWwpID0+ICh7XG4gICAgICAuLi5pdGVtcyxcbiAgICAgIC4uLntcbiAgICAgICAgW2BNb2QtQWx0LSR7bGV2ZWx9YF06ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUhlYWRpbmcoeyBsZXZlbCB9KSxcbiAgICAgIH0sXG4gICAgfSksIHt9KVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHMubWFwKGxldmVsID0+IHtcbiAgICAgIHJldHVybiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogbmV3IFJlZ0V4cChgXigjezEsJHtsZXZlbH19KVxcXFxzJGApLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBsZXZlbCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcbn0pXG4iLCAidmFyIEdPT0RfTEVBRl9TSVpFID0gMjAwO1xuXG4vLyA6OiBjbGFzczxUPiBBIHJvcGUgc2VxdWVuY2UgaXMgYSBwZXJzaXN0ZW50IHNlcXVlbmNlIGRhdGEgc3RydWN0dXJlXG4vLyB0aGF0IHN1cHBvcnRzIGFwcGVuZGluZywgcHJlcGVuZGluZywgYW5kIHNsaWNpbmcgd2l0aG91dCBkb2luZyBhXG4vLyBmdWxsIGNvcHkuIEl0IGlzIHJlcHJlc2VudGVkIGFzIGEgbW9zdGx5LWJhbGFuY2VkIHRyZWUuXG52YXIgUm9wZVNlcXVlbmNlID0gZnVuY3Rpb24gUm9wZVNlcXVlbmNlICgpIHt9O1xuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCAob3RoZXIpIHtcbiAgaWYgKCFvdGhlci5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICBvdGhlciA9IFJvcGVTZXF1ZW5jZS5mcm9tKG90aGVyKTtcblxuICByZXR1cm4gKCF0aGlzLmxlbmd0aCAmJiBvdGhlcikgfHxcbiAgICAob3RoZXIubGVuZ3RoIDwgR09PRF9MRUFGX1NJWkUgJiYgdGhpcy5sZWFmQXBwZW5kKG90aGVyKSkgfHxcbiAgICAodGhpcy5sZW5ndGggPCBHT09EX0xFQUZfU0laRSAmJiBvdGhlci5sZWFmUHJlcGVuZCh0aGlzKSkgfHxcbiAgICB0aGlzLmFwcGVuZElubmVyKG90aGVyKVxufTtcblxuLy8gOjogKHVuaW9uPFtUXSwgUm9wZVNlcXVlbmNlPFQ+PikgXHUyMTkyIFJvcGVTZXF1ZW5jZTxUPlxuLy8gUHJlcGVuZCBhbiBhcnJheSBvciBvdGhlciByb3BlIHRvIHRoaXMgb25lLCByZXR1cm5pbmcgYSBuZXcgcm9wZS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQgKG90aGVyKSB7XG4gIGlmICghb3RoZXIubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgcmV0dXJuIFJvcGVTZXF1ZW5jZS5mcm9tKG90aGVyKS5hcHBlbmQodGhpcylcbn07XG5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuYXBwZW5kSW5uZXIgPSBmdW5jdGlvbiBhcHBlbmRJbm5lciAob3RoZXIpIHtcbiAgcmV0dXJuIG5ldyBBcHBlbmQodGhpcywgb3RoZXIpXG59O1xuXG4vLyA6OiAoP251bWJlciwgP251bWJlcikgXHUyMTkyIFJvcGVTZXF1ZW5jZTxUPlxuLy8gQ3JlYXRlIGEgcm9wZSByZXBlc2VudGluZyBhIHN1Yi1zZXF1ZW5jZSBvZiB0aGlzIHJvcGUuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChmcm9tID49IHRvKSB7IHJldHVybiBSb3BlU2VxdWVuY2UuZW1wdHkgfVxuICByZXR1cm4gdGhpcy5zbGljZUlubmVyKE1hdGgubWF4KDAsIGZyb20pLCBNYXRoLm1pbih0aGlzLmxlbmd0aCwgdG8pKVxufTtcblxuLy8gOjogKG51bWJlcikgXHUyMTkyIFRcbi8vIFJldHJpZXZlIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBmcm9tIHRoaXMgcm9wZS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB7IHJldHVybiB1bmRlZmluZWQgfVxuICByZXR1cm4gdGhpcy5nZXRJbm5lcihpKVxufTtcblxuLy8gOjogKChlbGVtZW50OiBULCBpbmRleDogbnVtYmVyKSBcdTIxOTIgP2Jvb2wsID9udW1iZXIsID9udW1iZXIpXG4vLyBDYWxsIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50IGJldHdlZW4gdGhlIGdpdmVuXG4vLyBpbmRpY2VzLiBUaGlzIHRlbmRzIHRvIGJlIG1vcmUgZWZmaWNpZW50IHRoYW4gbG9vcGluZyBvdmVyIHRoZVxuLy8gaW5kaWNlcyBhbmQgY2FsbGluZyBgZ2V0YCwgYmVjYXVzZSBpdCBkb2Vzbid0IGhhdmUgdG8gZGVzY2VuZCB0aGVcbi8vIHRyZWUgZm9yIGV2ZXJ5IGVsZW1lbnQuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoIChmLCBmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZnJvbSA8PSB0bylcbiAgICB7IHRoaXMuZm9yRWFjaElubmVyKGYsIGZyb20sIHRvLCAwKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmZvckVhY2hJbnZlcnRlZElubmVyKGYsIGZyb20sIHRvLCAwKTsgfVxufTtcblxuLy8gOjogKChlbGVtZW50OiBULCBpbmRleDogbnVtYmVyKSBcdTIxOTIgVSwgP251bWJlciwgP251bWJlcikgXHUyMTkyIFtVXVxuLy8gTWFwIHRoZSBnaXZlbiBmdW5jdGlvbnMgb3ZlciB0aGUgZWxlbWVudHMgb2YgdGhlIHJvcGUsIHByb2R1Y2luZ1xuLy8gYSBmbGF0IGFycmF5LlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKGYsIGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMubGVuZ3RoO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbHQsIGkpIHsgcmV0dXJuIHJlc3VsdC5wdXNoKGYoZWx0LCBpKSk7IH0sIGZyb20sIHRvKTtcbiAgcmV0dXJuIHJlc3VsdFxufTtcblxuLy8gOjogKD91bmlvbjxbVF0sIFJvcGVTZXF1ZW5jZTxUPj4pIFx1MjE5MiBSb3BlU2VxdWVuY2U8VD5cbi8vIENyZWF0ZSBhIHJvcGUgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBhcnJheSwgb3IgcmV0dXJuIHRoZSByb3BlXG4vLyBpdHNlbGYgaWYgYSByb3BlIHdhcyBnaXZlbi5cblJvcGVTZXF1ZW5jZS5mcm9tID0gZnVuY3Rpb24gZnJvbSAodmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBSb3BlU2VxdWVuY2UpIHsgcmV0dXJuIHZhbHVlcyB9XG4gIHJldHVybiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCA/IG5ldyBMZWFmKHZhbHVlcykgOiBSb3BlU2VxdWVuY2UuZW1wdHlcbn07XG5cbnZhciBMZWFmID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUm9wZVNlcXVlbmNlKSB7XG4gIGZ1bmN0aW9uIExlYWYodmFsdWVzKSB7XG4gICAgUm9wZVNlcXVlbmNlLmNhbGwodGhpcyk7XG4gICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gIH1cblxuICBpZiAoIFJvcGVTZXF1ZW5jZSApIExlYWYuX19wcm90b19fID0gUm9wZVNlcXVlbmNlO1xuICBMZWFmLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJvcGVTZXF1ZW5jZSAmJiBSb3BlU2VxdWVuY2UucHJvdG90eXBlICk7XG4gIExlYWYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGVhZjtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBsZW5ndGg6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sZGVwdGg6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICBMZWFmLnByb3RvdHlwZS5mbGF0dGVuID0gZnVuY3Rpb24gZmxhdHRlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuc2xpY2VJbm5lciA9IGZ1bmN0aW9uIHNsaWNlSW5uZXIgKGZyb20sIHRvKSB7XG4gICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gICAgcmV0dXJuIG5ldyBMZWFmKHRoaXMudmFsdWVzLnNsaWNlKGZyb20sIHRvKSlcbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5nZXRJbm5lciA9IGZ1bmN0aW9uIGdldElubmVyIChpKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzW2ldXG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZm9yRWFjaElubmVyID0gZnVuY3Rpb24gZm9yRWFjaElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICB7IGlmIChmKHRoaXMudmFsdWVzW2ldLCBzdGFydCArIGkpID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZm9yRWFjaEludmVydGVkSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW52ZXJ0ZWRJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgZm9yICh2YXIgaSA9IGZyb20gLSAxOyBpID49IHRvOyBpLS0pXG4gICAgICB7IGlmIChmKHRoaXMudmFsdWVzW2ldLCBzdGFydCArIGkpID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUubGVhZkFwcGVuZCA9IGZ1bmN0aW9uIGxlYWZBcHBlbmQgKG90aGVyKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoICsgb3RoZXIubGVuZ3RoIDw9IEdPT0RfTEVBRl9TSVpFKVxuICAgICAgeyByZXR1cm4gbmV3IExlYWYodGhpcy52YWx1ZXMuY29uY2F0KG90aGVyLmZsYXR0ZW4oKSkpIH1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5sZWFmUHJlcGVuZCA9IGZ1bmN0aW9uIGxlYWZQcmVwZW5kIChvdGhlcikge1xuICAgIGlmICh0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCA8PSBHT09EX0xFQUZfU0laRSlcbiAgICAgIHsgcmV0dXJuIG5ldyBMZWFmKG90aGVyLmZsYXR0ZW4oKS5jb25jYXQodGhpcy52YWx1ZXMpKSB9XG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmxlbmd0aC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnZhbHVlcy5sZW5ndGggfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuZGVwdGguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMZWFmLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIExlYWY7XG59KFJvcGVTZXF1ZW5jZSkpO1xuXG4vLyA6OiBSb3BlU2VxdWVuY2Vcbi8vIFRoZSBlbXB0eSByb3BlIHNlcXVlbmNlLlxuUm9wZVNlcXVlbmNlLmVtcHR5ID0gbmV3IExlYWYoW10pO1xuXG52YXIgQXBwZW5kID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUm9wZVNlcXVlbmNlKSB7XG4gIGZ1bmN0aW9uIEFwcGVuZChsZWZ0LCByaWdodCkge1xuICAgIFJvcGVTZXF1ZW5jZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIHRoaXMubGVuZ3RoID0gbGVmdC5sZW5ndGggKyByaWdodC5sZW5ndGg7XG4gICAgdGhpcy5kZXB0aCA9IE1hdGgubWF4KGxlZnQuZGVwdGgsIHJpZ2h0LmRlcHRoKSArIDE7XG4gIH1cblxuICBpZiAoIFJvcGVTZXF1ZW5jZSApIEFwcGVuZC5fX3Byb3RvX18gPSBSb3BlU2VxdWVuY2U7XG4gIEFwcGVuZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSb3BlU2VxdWVuY2UgJiYgUm9wZVNlcXVlbmNlLnByb3RvdHlwZSApO1xuICBBcHBlbmQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXBwZW5kO1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uIGZsYXR0ZW4gKCkge1xuICAgIHJldHVybiB0aGlzLmxlZnQuZmxhdHRlbigpLmNvbmNhdCh0aGlzLnJpZ2h0LmZsYXR0ZW4oKSlcbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmdldElubmVyID0gZnVuY3Rpb24gZ2V0SW5uZXIgKGkpIHtcbiAgICByZXR1cm4gaSA8IHRoaXMubGVmdC5sZW5ndGggPyB0aGlzLmxlZnQuZ2V0KGkpIDogdGhpcy5yaWdodC5nZXQoaSAtIHRoaXMubGVmdC5sZW5ndGgpXG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5mb3JFYWNoSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIHZhciBsZWZ0TGVuID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICBpZiAoZnJvbSA8IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hJbm5lcihmLCBmcm9tLCBNYXRoLm1pbih0bywgbGVmdExlbiksIHN0YXJ0KSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRvID4gbGVmdExlbiAmJlxuICAgICAgICB0aGlzLnJpZ2h0LmZvckVhY2hJbm5lcihmLCBNYXRoLm1heChmcm9tIC0gbGVmdExlbiwgMCksIE1hdGgubWluKHRoaXMubGVuZ3RoLCB0bykgLSBsZWZ0TGVuLCBzdGFydCArIGxlZnRMZW4pID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmZvckVhY2hJbnZlcnRlZElubmVyID0gZnVuY3Rpb24gZm9yRWFjaEludmVydGVkSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIHZhciBsZWZ0TGVuID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICBpZiAoZnJvbSA+IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoSW52ZXJ0ZWRJbm5lcihmLCBmcm9tIC0gbGVmdExlbiwgTWF0aC5tYXgodG8sIGxlZnRMZW4pIC0gbGVmdExlbiwgc3RhcnQgKyBsZWZ0TGVuKSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRvIDwgbGVmdExlbiAmJlxuICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaEludmVydGVkSW5uZXIoZiwgTWF0aC5taW4oZnJvbSwgbGVmdExlbiksIHRvLCBzdGFydCkgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuc2xpY2VJbm5lciA9IGZ1bmN0aW9uIHNsaWNlSW5uZXIgKGZyb20sIHRvKSB7XG4gICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gICAgdmFyIGxlZnRMZW4gPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgIGlmICh0byA8PSBsZWZ0TGVuKSB7IHJldHVybiB0aGlzLmxlZnQuc2xpY2UoZnJvbSwgdG8pIH1cbiAgICBpZiAoZnJvbSA+PSBsZWZ0TGVuKSB7IHJldHVybiB0aGlzLnJpZ2h0LnNsaWNlKGZyb20gLSBsZWZ0TGVuLCB0byAtIGxlZnRMZW4pIH1cbiAgICByZXR1cm4gdGhpcy5sZWZ0LnNsaWNlKGZyb20sIGxlZnRMZW4pLmFwcGVuZCh0aGlzLnJpZ2h0LnNsaWNlKDAsIHRvIC0gbGVmdExlbikpXG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5sZWFmQXBwZW5kID0gZnVuY3Rpb24gbGVhZkFwcGVuZCAob3RoZXIpIHtcbiAgICB2YXIgaW5uZXIgPSB0aGlzLnJpZ2h0LmxlYWZBcHBlbmQob3RoZXIpO1xuICAgIGlmIChpbm5lcikgeyByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLmxlZnQsIGlubmVyKSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5sZWFmUHJlcGVuZCA9IGZ1bmN0aW9uIGxlYWZQcmVwZW5kIChvdGhlcikge1xuICAgIHZhciBpbm5lciA9IHRoaXMubGVmdC5sZWFmUHJlcGVuZChvdGhlcik7XG4gICAgaWYgKGlubmVyKSB7IHJldHVybiBuZXcgQXBwZW5kKGlubmVyLCB0aGlzLnJpZ2h0KSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5hcHBlbmRJbm5lciA9IGZ1bmN0aW9uIGFwcGVuZElubmVyIChvdGhlcikge1xuICAgIGlmICh0aGlzLmxlZnQuZGVwdGggPj0gTWF0aC5tYXgodGhpcy5yaWdodC5kZXB0aCwgb3RoZXIuZGVwdGgpICsgMSlcbiAgICAgIHsgcmV0dXJuIG5ldyBBcHBlbmQodGhpcy5sZWZ0LCBuZXcgQXBwZW5kKHRoaXMucmlnaHQsIG90aGVyKSkgfVxuICAgIHJldHVybiBuZXcgQXBwZW5kKHRoaXMsIG90aGVyKVxuICB9O1xuXG4gIHJldHVybiBBcHBlbmQ7XG59KFJvcGVTZXF1ZW5jZSkpO1xuXG5leHBvcnQgZGVmYXVsdCBSb3BlU2VxdWVuY2U7XG4iLCAiaW1wb3J0IFJvcGVTZXF1ZW5jZSBmcm9tICdyb3BlLXNlcXVlbmNlJztcbmltcG9ydCB7IE1hcHBpbmcgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgUGx1Z2luS2V5LCBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbi8vIFByb3NlTWlycm9yJ3MgaGlzdG9yeSBpc24ndCBzaW1wbHkgYSB3YXkgdG8gcm9sbCBiYWNrIHRvIGEgcHJldmlvdXNcbi8vIHN0YXRlLCBiZWNhdXNlIFByb3NlTWlycm9yIHN1cHBvcnRzIGFwcGx5aW5nIGNoYW5nZXMgd2l0aG91dCBhZGRpbmdcbi8vIHRoZW0gdG8gdGhlIGhpc3RvcnkgKGZvciBleGFtcGxlIGR1cmluZyBjb2xsYWJvcmF0aW9uKS5cbi8vXG4vLyBUbyB0aGlzIGVuZCwgZWFjaCAnQnJhbmNoJyAob25lIGZvciB0aGUgdW5kbyBoaXN0b3J5IGFuZCBvbmUgZm9yXG4vLyB0aGUgcmVkbyBoaXN0b3J5KSBrZWVwcyBhbiBhcnJheSBvZiAnSXRlbXMnLCB3aGljaCBjYW4gb3B0aW9uYWxseVxuLy8gaG9sZCBhIHN0ZXAgKGFuIGFjdHVhbCB1bmRvYWJsZSBjaGFuZ2UpLCBhbmQgYWx3YXlzIGhvbGQgYSBwb3NpdGlvblxuLy8gbWFwICh3aGljaCBpcyBuZWVkZWQgdG8gbW92ZSBjaGFuZ2VzIGJlbG93IHRoZW0gdG8gYXBwbHkgdG8gdGhlXG4vLyBjdXJyZW50IGRvY3VtZW50KS5cbi8vXG4vLyBBbiBpdGVtIHRoYXQgaGFzIGJvdGggYSBzdGVwIGFuZCBhIHNlbGVjdGlvbiBib29rbWFyayBpcyB0aGUgc3RhcnRcbi8vIG9mIGFuICdldmVudCcgXHUyMDE0IGEgZ3JvdXAgb2YgY2hhbmdlcyB0aGF0IHdpbGwgYmUgdW5kb25lIG9yIHJlZG9uZSBhdFxuLy8gb25jZS4gKEl0IHN0b3JlcyBvbmx5IHRoZSBib29rbWFyaywgc2luY2UgdGhhdCB3YXkgd2UgZG9uJ3QgaGF2ZSB0b1xuLy8gcHJvdmlkZSBhIGRvY3VtZW50IHVudGlsIHRoZSBzZWxlY3Rpb24gaXMgYWN0dWFsbHkgYXBwbGllZCwgd2hpY2hcbi8vIGlzIHVzZWZ1bCB3aGVuIGNvbXByZXNzaW5nLilcbi8vIFVzZWQgdG8gc2NoZWR1bGUgaGlzdG9yeSBjb21wcmVzc2lvblxuY29uc3QgbWF4X2VtcHR5X2l0ZW1zID0gNTAwO1xuY2xhc3MgQnJhbmNoIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVtcywgZXZlbnRDb3VudCkge1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuZXZlbnRDb3VudCA9IGV2ZW50Q291bnQ7XG4gICAgfVxuICAgIC8vIFBvcCB0aGUgbGF0ZXN0IGV2ZW50IG9mZiB0aGUgYnJhbmNoJ3MgaGlzdG9yeSBhbmQgYXBwbHkgaXRcbiAgICAvLyB0byBhIGRvY3VtZW50IHRyYW5zZm9ybS5cbiAgICBwb3BFdmVudChzdGF0ZSwgcHJlc2VydmVJdGVtcykge1xuICAgICAgICBpZiAodGhpcy5ldmVudENvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKDs7IGVuZC0tKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuaXRlbXMuZ2V0KGVuZCAtIDEpO1xuICAgICAgICAgICAgaWYgKG5leHQuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLS1lbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlbWFwLCBtYXBGcm9tO1xuICAgICAgICBpZiAocHJlc2VydmVJdGVtcykge1xuICAgICAgICAgICAgcmVtYXAgPSB0aGlzLnJlbWFwcGluZyhlbmQsIHRoaXMuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIG1hcEZyb20gPSByZW1hcC5tYXBzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHJhbnNmb3JtID0gc3RhdGUudHI7XG4gICAgICAgIGxldCBzZWxlY3Rpb24sIHJlbWFpbmluZztcbiAgICAgICAgbGV0IGFkZEFmdGVyID0gW10sIGFkZEJlZm9yZSA9IFtdO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIGlmICghaXRlbS5zdGVwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZW1hcCkge1xuICAgICAgICAgICAgICAgICAgICByZW1hcCA9IHRoaXMucmVtYXBwaW5nKGVuZCwgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgICAgICBhZGRCZWZvcmUucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVtYXApIHtcbiAgICAgICAgICAgICAgICBhZGRCZWZvcmUucHVzaChuZXcgSXRlbShpdGVtLm1hcCkpO1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gaXRlbS5zdGVwLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSksIG1hcDtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCAmJiB0cmFuc2Zvcm0ubWF5YmVTdGVwKHN0ZXApLmRvYykge1xuICAgICAgICAgICAgICAgICAgICBtYXAgPSB0cmFuc2Zvcm0ubWFwcGluZy5tYXBzW3RyYW5zZm9ybS5tYXBwaW5nLm1hcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGFkZEFmdGVyLnB1c2gobmV3IEl0ZW0obWFwLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYWRkQWZ0ZXIubGVuZ3RoICsgYWRkQmVmb3JlLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgaWYgKG1hcClcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAuYXBwZW5kTWFwKG1hcCwgbWFwRnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0ubWF5YmVTdGVwKGl0ZW0uc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSByZW1hcCA/IGl0ZW0uc2VsZWN0aW9uLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSkgOiBpdGVtLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICByZW1haW5pbmcgPSBuZXcgQnJhbmNoKHRoaXMuaXRlbXMuc2xpY2UoMCwgZW5kKS5hcHBlbmQoYWRkQmVmb3JlLnJldmVyc2UoKS5jb25jYXQoYWRkQWZ0ZXIpKSwgdGhpcy5ldmVudENvdW50IC0gMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLml0ZW1zLmxlbmd0aCwgMCk7XG4gICAgICAgIHJldHVybiB7IHJlbWFpbmluZzogcmVtYWluaW5nLCB0cmFuc2Zvcm0sIHNlbGVjdGlvbjogc2VsZWN0aW9uIH07XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIG5ldyBicmFuY2ggd2l0aCB0aGUgZ2l2ZW4gdHJhbnNmb3JtIGFkZGVkLlxuICAgIGFkZFRyYW5zZm9ybSh0cmFuc2Zvcm0sIHNlbGVjdGlvbiwgaGlzdE9wdGlvbnMsIHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgbGV0IG5ld0l0ZW1zID0gW10sIGV2ZW50Q291bnQgPSB0aGlzLmV2ZW50Q291bnQ7XG4gICAgICAgIGxldCBvbGRJdGVtcyA9IHRoaXMuaXRlbXMsIGxhc3RJdGVtID0gIXByZXNlcnZlSXRlbXMgJiYgb2xkSXRlbXMubGVuZ3RoID8gb2xkSXRlbXMuZ2V0KG9sZEl0ZW1zLmxlbmd0aCAtIDEpIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm0uc3RlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGVwID0gdHJhbnNmb3JtLnN0ZXBzW2ldLmludmVydCh0cmFuc2Zvcm0uZG9jc1tpXSk7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IG5ldyBJdGVtKHRyYW5zZm9ybS5tYXBwaW5nLm1hcHNbaV0sIHN0ZXAsIHNlbGVjdGlvbiksIG1lcmdlZDtcbiAgICAgICAgICAgIGlmIChtZXJnZWQgPSBsYXN0SXRlbSAmJiBsYXN0SXRlbS5tZXJnZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBtZXJnZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgICAgIG5ld0l0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2xkSXRlbXMgPSBvbGRJdGVtcy5zbGljZSgwLCBvbGRJdGVtcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0l0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRDb3VudCsrO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJlc2VydmVJdGVtcylcbiAgICAgICAgICAgICAgICBsYXN0SXRlbSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG92ZXJmbG93ID0gZXZlbnRDb3VudCAtIGhpc3RPcHRpb25zLmRlcHRoO1xuICAgICAgICBpZiAob3ZlcmZsb3cgPiBERVBUSF9PVkVSRkxPVykge1xuICAgICAgICAgICAgb2xkSXRlbXMgPSBjdXRPZmZFdmVudHMob2xkSXRlbXMsIG92ZXJmbG93KTtcbiAgICAgICAgICAgIGV2ZW50Q291bnQgLT0gb3ZlcmZsb3c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCcmFuY2gob2xkSXRlbXMuYXBwZW5kKG5ld0l0ZW1zKSwgZXZlbnRDb3VudCk7XG4gICAgfVxuICAgIHJlbWFwcGluZyhmcm9tLCB0bykge1xuICAgICAgICBsZXQgbWFwcyA9IG5ldyBNYXBwaW5nO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBtaXJyb3JQb3MgPSBpdGVtLm1pcnJvck9mZnNldCAhPSBudWxsICYmIGkgLSBpdGVtLm1pcnJvck9mZnNldCA+PSBmcm9tXG4gICAgICAgICAgICAgICAgPyBtYXBzLm1hcHMubGVuZ3RoIC0gaXRlbS5taXJyb3JPZmZzZXQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBtYXBzLmFwcGVuZE1hcChpdGVtLm1hcCwgbWlycm9yUG9zKTtcbiAgICAgICAgfSwgZnJvbSwgdG8pO1xuICAgICAgICByZXR1cm4gbWFwcztcbiAgICB9XG4gICAgYWRkTWFwcyhhcnJheSkge1xuICAgICAgICBpZiAodGhpcy5ldmVudENvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBCcmFuY2godGhpcy5pdGVtcy5hcHBlbmQoYXJyYXkubWFwKG1hcCA9PiBuZXcgSXRlbShtYXApKSksIHRoaXMuZXZlbnRDb3VudCk7XG4gICAgfVxuICAgIC8vIFdoZW4gdGhlIGNvbGxhYiBtb2R1bGUgcmVjZWl2ZXMgcmVtb3RlIGNoYW5nZXMsIHRoZSBoaXN0b3J5IGhhc1xuICAgIC8vIHRvIGtub3cgYWJvdXQgdGhvc2UsIHNvIHRoYXQgaXQgY2FuIGFkanVzdCB0aGUgc3RlcHMgdGhhdCB3ZXJlXG4gICAgLy8gcmViYXNlZCBvbiB0b3Agb2YgdGhlIHJlbW90ZSBjaGFuZ2VzLCBhbmQgaW5jbHVkZSB0aGUgcG9zaXRpb25cbiAgICAvLyBtYXBzIGZvciB0aGUgcmVtb3RlIGNoYW5nZXMgaW4gaXRzIGFycmF5IG9mIGl0ZW1zLlxuICAgIHJlYmFzZWQocmViYXNlZFRyYW5zZm9ybSwgcmViYXNlZENvdW50KSB7XG4gICAgICAgIGlmICghdGhpcy5ldmVudENvdW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCByZWJhc2VkSXRlbXMgPSBbXSwgc3RhcnQgPSBNYXRoLm1heCgwLCB0aGlzLml0ZW1zLmxlbmd0aCAtIHJlYmFzZWRDb3VudCk7XG4gICAgICAgIGxldCBtYXBwaW5nID0gcmViYXNlZFRyYW5zZm9ybS5tYXBwaW5nO1xuICAgICAgICBsZXQgbmV3VW50aWwgPSByZWJhc2VkVHJhbnNmb3JtLnN0ZXBzLmxlbmd0aDtcbiAgICAgICAgbGV0IGV2ZW50Q291bnQgPSB0aGlzLmV2ZW50Q291bnQ7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChpdGVtID0+IHsgaWYgKGl0ZW0uc2VsZWN0aW9uKVxuICAgICAgICAgICAgZXZlbnRDb3VudC0tOyB9LCBzdGFydCk7XG4gICAgICAgIGxldCBpUmViYXNlZCA9IHJlYmFzZWRDb3VudDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcuZ2V0TWlycm9yKC0taVJlYmFzZWQpO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIG5ld1VudGlsID0gTWF0aC5taW4obmV3VW50aWwsIHBvcyk7XG4gICAgICAgICAgICBsZXQgbWFwID0gbWFwcGluZy5tYXBzW3Bvc107XG4gICAgICAgICAgICBpZiAoaXRlbS5zdGVwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSByZWJhc2VkVHJhbnNmb3JtLnN0ZXBzW3Bvc10uaW52ZXJ0KHJlYmFzZWRUcmFuc2Zvcm0uZG9jc1twb3NdKTtcbiAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gaXRlbS5zZWxlY3Rpb24gJiYgaXRlbS5zZWxlY3Rpb24ubWFwKG1hcHBpbmcuc2xpY2UoaVJlYmFzZWQgKyAxLCBwb3MpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBldmVudENvdW50Kys7XG4gICAgICAgICAgICAgICAgcmViYXNlZEl0ZW1zLnB1c2gobmV3IEl0ZW0obWFwLCBzdGVwLCBzZWxlY3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlYmFzZWRJdGVtcy5wdXNoKG5ldyBJdGVtKG1hcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzdGFydCk7XG4gICAgICAgIGxldCBuZXdNYXBzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSByZWJhc2VkQ291bnQ7IGkgPCBuZXdVbnRpbDsgaSsrKVxuICAgICAgICAgICAgbmV3TWFwcy5wdXNoKG5ldyBJdGVtKG1hcHBpbmcubWFwc1tpXSkpO1xuICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLml0ZW1zLnNsaWNlKDAsIHN0YXJ0KS5hcHBlbmQobmV3TWFwcykuYXBwZW5kKHJlYmFzZWRJdGVtcyk7XG4gICAgICAgIGxldCBicmFuY2ggPSBuZXcgQnJhbmNoKGl0ZW1zLCBldmVudENvdW50KTtcbiAgICAgICAgaWYgKGJyYW5jaC5lbXB0eUl0ZW1Db3VudCgpID4gbWF4X2VtcHR5X2l0ZW1zKVxuICAgICAgICAgICAgYnJhbmNoID0gYnJhbmNoLmNvbXByZXNzKHRoaXMuaXRlbXMubGVuZ3RoIC0gcmViYXNlZEl0ZW1zLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgfVxuICAgIGVtcHR5SXRlbUNvdW50KCkge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7IGlmICghaXRlbS5zdGVwKVxuICAgICAgICAgICAgY291bnQrKzsgfSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgLy8gQ29tcHJlc3NpbmcgYSBicmFuY2ggbWVhbnMgcmV3cml0aW5nIGl0IHRvIHB1c2ggdGhlIGFpciAobWFwLW9ubHlcbiAgICAvLyBpdGVtcykgb3V0LiBEdXJpbmcgY29sbGFib3JhdGlvbiwgdGhlc2UgbmF0dXJhbGx5IGFjY3VtdWxhdGVcbiAgICAvLyBiZWNhdXNlIGVhY2ggcmVtb3RlIGNoYW5nZSBhZGRzIG9uZS4gVGhlIGB1cHRvYCBhcmd1bWVudCBpcyB1c2VkXG4gICAgLy8gdG8gZW5zdXJlIHRoYXQgb25seSB0aGUgaXRlbXMgYmVsb3cgYSBnaXZlbiBsZXZlbCBhcmUgY29tcHJlc3NlZCxcbiAgICAvLyBiZWNhdXNlIGByZWJhc2VkYCByZWxpZXMgb24gYSBjbGVhbiwgdW50b3VjaGVkIHNldCBvZiBpdGVtcyBpblxuICAgIC8vIG9yZGVyIHRvIGFzc29jaWF0ZSBvbGQgaXRlbXMgd2l0aCByZWJhc2VkIHN0ZXBzLlxuICAgIGNvbXByZXNzKHVwdG8gPSB0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICBsZXQgcmVtYXAgPSB0aGlzLnJlbWFwcGluZygwLCB1cHRvKSwgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICAgICAgICBsZXQgaXRlbXMgPSBbXSwgZXZlbnRzID0gMDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSA+PSB1cHRvKSB7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5zdGVwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSBpdGVtLnN0ZXAubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKSwgbWFwID0gc3RlcCAmJiBzdGVwLmdldE1hcCgpO1xuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgICAgICBpZiAobWFwKVxuICAgICAgICAgICAgICAgICAgICByZW1hcC5hcHBlbmRNYXAobWFwLCBtYXBGcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gaXRlbS5zZWxlY3Rpb24gJiYgaXRlbS5zZWxlY3Rpb24ubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cysrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3SXRlbSA9IG5ldyBJdGVtKG1hcC5pbnZlcnQoKSwgc3RlcCwgc2VsZWN0aW9uKSwgbWVyZ2VkLCBsYXN0ID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lcmdlZCA9IGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1tsYXN0XS5tZXJnZShuZXdJdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2xhc3RdID0gbWVyZ2VkO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKG5ld0l0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0ubWFwKSB7XG4gICAgICAgICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLml0ZW1zLmxlbmd0aCwgMCk7XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKFJvcGVTZXF1ZW5jZS5mcm9tKGl0ZW1zLnJldmVyc2UoKSksIGV2ZW50cyk7XG4gICAgfVxufVxuQnJhbmNoLmVtcHR5ID0gbmV3IEJyYW5jaChSb3BlU2VxdWVuY2UuZW1wdHksIDApO1xuZnVuY3Rpb24gY3V0T2ZmRXZlbnRzKGl0ZW1zLCBuKSB7XG4gICAgbGV0IGN1dFBvaW50O1xuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uICYmIChuLS0gPT0gMCkpIHtcbiAgICAgICAgICAgIGN1dFBvaW50ID0gaTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpdGVtcy5zbGljZShjdXRQb2ludCk7XG59XG5jbGFzcyBJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgKGZvcndhcmQpIHN0ZXAgbWFwIGZvciB0aGlzIGl0ZW0uXG4gICAgbWFwLCBcbiAgICAvLyBUaGUgaW52ZXJ0ZWQgc3RlcFxuICAgIHN0ZXAsIFxuICAgIC8vIElmIHRoaXMgaXMgbm9uLW51bGwsIHRoaXMgaXRlbSBpcyB0aGUgc3RhcnQgb2YgYSBncm91cCwgYW5kXG4gICAgLy8gdGhpcyBzZWxlY3Rpb24gaXMgdGhlIHN0YXJ0aW5nIHNlbGVjdGlvbiBmb3IgdGhlIGdyb3VwICh0aGUgb25lXG4gICAgLy8gdGhhdCB3YXMgYWN0aXZlIGJlZm9yZSB0aGUgZmlyc3Qgc3RlcCB3YXMgYXBwbGllZClcbiAgICBzZWxlY3Rpb24sIFxuICAgIC8vIElmIHRoaXMgaXRlbSBpcyB0aGUgaW52ZXJzZSBvZiBhIHByZXZpb3VzIG1hcHBpbmcgb24gdGhlIHN0YWNrLFxuICAgIC8vIHRoaXMgcG9pbnRzIGF0IHRoZSBpbnZlcnNlJ3Mgb2Zmc2V0XG4gICAgbWlycm9yT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICB0aGlzLnN0ZXAgPSBzdGVwO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5taXJyb3JPZmZzZXQgPSBtaXJyb3JPZmZzZXQ7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN0ZXAgJiYgb3RoZXIuc3RlcCAmJiAhb3RoZXIuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgc3RlcCA9IG90aGVyLnN0ZXAubWVyZ2UodGhpcy5zdGVwKTtcbiAgICAgICAgICAgIGlmIChzdGVwKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSXRlbShzdGVwLmdldE1hcCgpLmludmVydCgpLCBzdGVwLCB0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBUaGUgdmFsdWUgb2YgdGhlIHN0YXRlIGZpZWxkIHRoYXQgdHJhY2tzIHVuZG8vcmVkbyBoaXN0b3J5IGZvciB0aGF0XG4vLyBzdGF0ZS4gV2lsbCBiZSBzdG9yZWQgaW4gdGhlIHBsdWdpbiBzdGF0ZSB3aGVuIHRoZSBoaXN0b3J5IHBsdWdpblxuLy8gaXMgYWN0aXZlLlxuY2xhc3MgSGlzdG9yeVN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb25lLCB1bmRvbmUsIHByZXZSYW5nZXMsIHByZXZUaW1lLCBwcmV2Q29tcG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5kb25lID0gZG9uZTtcbiAgICAgICAgdGhpcy51bmRvbmUgPSB1bmRvbmU7XG4gICAgICAgIHRoaXMucHJldlJhbmdlcyA9IHByZXZSYW5nZXM7XG4gICAgICAgIHRoaXMucHJldlRpbWUgPSBwcmV2VGltZTtcbiAgICAgICAgdGhpcy5wcmV2Q29tcG9zaXRpb24gPSBwcmV2Q29tcG9zaXRpb247XG4gICAgfVxufVxuY29uc3QgREVQVEhfT1ZFUkZMT1cgPSAyMDtcbi8vIFJlY29yZCBhIHRyYW5zZm9ybWF0aW9uIGluIHVuZG8gaGlzdG9yeS5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNhY3Rpb24oaGlzdG9yeSwgc3RhdGUsIHRyLCBvcHRpb25zKSB7XG4gICAgbGV0IGhpc3RvcnlUciA9IHRyLmdldE1ldGEoaGlzdG9yeUtleSksIHJlYmFzZWQ7XG4gICAgaWYgKGhpc3RvcnlUcilcbiAgICAgICAgcmV0dXJuIGhpc3RvcnlUci5oaXN0b3J5U3RhdGU7XG4gICAgaWYgKHRyLmdldE1ldGEoY2xvc2VIaXN0b3J5S2V5KSlcbiAgICAgICAgaGlzdG9yeSA9IG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLCBoaXN0b3J5LnVuZG9uZSwgbnVsbCwgMCwgLTEpO1xuICAgIGxldCBhcHBlbmRlZCA9IHRyLmdldE1ldGEoXCJhcHBlbmRlZFRyYW5zYWN0aW9uXCIpO1xuICAgIGlmICh0ci5zdGVwcy5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gaGlzdG9yeTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXBwZW5kZWQgJiYgYXBwZW5kZWQuZ2V0TWV0YShoaXN0b3J5S2V5KSkge1xuICAgICAgICBpZiAoYXBwZW5kZWQuZ2V0TWV0YShoaXN0b3J5S2V5KS5yZWRvKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZFRyYW5zZm9ybSh0ciwgdW5kZWZpbmVkLCBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLCBoaXN0b3J5LnVuZG9uZSwgcmFuZ2VzRm9yKHRyLm1hcHBpbmcubWFwc1t0ci5zdGVwcy5sZW5ndGggLSAxXSksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLCBoaXN0b3J5LnVuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIHVuZGVmaW5lZCwgb3B0aW9ucywgbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpKSwgbnVsbCwgaGlzdG9yeS5wcmV2VGltZSwgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ci5nZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIpICE9PSBmYWxzZSAmJiAhKGFwcGVuZGVkICYmIGFwcGVuZGVkLmdldE1ldGEoXCJhZGRUb0hpc3RvcnlcIikgPT09IGZhbHNlKSkge1xuICAgICAgICAvLyBHcm91cCB0cmFuc2Zvcm1zIHRoYXQgb2NjdXIgaW4gcXVpY2sgc3VjY2Vzc2lvbiBpbnRvIG9uZSBldmVudC5cbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uID0gdHIuZ2V0TWV0YShcImNvbXBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgbmV3R3JvdXAgPSBoaXN0b3J5LnByZXZUaW1lID09IDAgfHxcbiAgICAgICAgICAgICghYXBwZW5kZWQgJiYgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24gIT0gY29tcG9zaXRpb24gJiZcbiAgICAgICAgICAgICAgICAoaGlzdG9yeS5wcmV2VGltZSA8ICh0ci50aW1lIHx8IDApIC0gb3B0aW9ucy5uZXdHcm91cERlbGF5IHx8ICFpc0FkamFjZW50VG8odHIsIGhpc3RvcnkucHJldlJhbmdlcykpKTtcbiAgICAgICAgbGV0IHByZXZSYW5nZXMgPSBhcHBlbmRlZCA/IG1hcFJhbmdlcyhoaXN0b3J5LnByZXZSYW5nZXMsIHRyLm1hcHBpbmcpIDogcmFuZ2VzRm9yKHRyLm1hcHBpbmcubWFwc1t0ci5zdGVwcy5sZW5ndGggLSAxXSk7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIG5ld0dyb3VwID8gc3RhdGUuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCkgOiB1bmRlZmluZWQsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksIEJyYW5jaC5lbXB0eSwgcHJldlJhbmdlcywgdHIudGltZSwgY29tcG9zaXRpb24gPT0gbnVsbCA/IGhpc3RvcnkucHJldkNvbXBvc2l0aW9uIDogY29tcG9zaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWJhc2VkID0gdHIuZ2V0TWV0YShcInJlYmFzZWRcIikpIHtcbiAgICAgICAgLy8gVXNlZCBieSB0aGUgY29sbGFiIG1vZHVsZSB0byB0ZWxsIHRoZSBoaXN0b3J5IHRoYXQgc29tZSBvZiBpdHNcbiAgICAgICAgLy8gY29udGVudCBoYXMgYmVlbiByZWJhc2VkLlxuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUucmViYXNlZCh0ciwgcmViYXNlZCksIGhpc3RvcnkudW5kb25lLnJlYmFzZWQodHIsIHJlYmFzZWQpLCBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSwgaGlzdG9yeS5wcmV2VGltZSwgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZE1hcHModHIubWFwcGluZy5tYXBzKSwgaGlzdG9yeS51bmRvbmUuYWRkTWFwcyh0ci5tYXBwaW5nLm1hcHMpLCBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSwgaGlzdG9yeS5wcmV2VGltZSwgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQWRqYWNlbnRUbyh0cmFuc2Zvcm0sIHByZXZSYW5nZXMpIHtcbiAgICBpZiAoIXByZXZSYW5nZXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXRyYW5zZm9ybS5kb2NDaGFuZ2VkKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgYWRqYWNlbnQgPSBmYWxzZTtcbiAgICB0cmFuc2Zvcm0ubWFwcGluZy5tYXBzWzBdLmZvckVhY2goKHN0YXJ0LCBlbmQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2UmFuZ2VzLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKHN0YXJ0IDw9IHByZXZSYW5nZXNbaSArIDFdICYmIGVuZCA+PSBwcmV2UmFuZ2VzW2ldKVxuICAgICAgICAgICAgICAgIGFkamFjZW50ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWRqYWNlbnQ7XG59XG5mdW5jdGlvbiByYW5nZXNGb3IobWFwKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIG1hcC5mb3JFYWNoKChfZnJvbSwgX3RvLCBmcm9tLCB0bykgPT4gcmVzdWx0LnB1c2goZnJvbSwgdG8pKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFwUmFuZ2VzKHJhbmdlcywgbWFwcGluZykge1xuICAgIGlmICghcmFuZ2VzKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcChyYW5nZXNbaV0sIDEpLCB0byA9IG1hcHBpbmcubWFwKHJhbmdlc1tpICsgMV0sIC0xKTtcbiAgICAgICAgaWYgKGZyb20gPD0gdG8pXG4gICAgICAgICAgICByZXN1bHQucHVzaChmcm9tLCB0byk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBBcHBseSB0aGUgbGF0ZXN0IGV2ZW50IGZyb20gb25lIGJyYW5jaCB0byB0aGUgZG9jdW1lbnQgYW5kIHNoaWZ0IHRoZSBldmVudFxuLy8gb250byB0aGUgb3RoZXIgYnJhbmNoLlxuZnVuY3Rpb24gaGlzdFRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCBkaXNwYXRjaCwgcmVkbykge1xuICAgIGxldCBwcmVzZXJ2ZUl0ZW1zID0gbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpO1xuICAgIGxldCBoaXN0T3B0aW9ucyA9IGhpc3RvcnlLZXkuZ2V0KHN0YXRlKS5zcGVjLmNvbmZpZztcbiAgICBsZXQgcG9wID0gKHJlZG8gPyBoaXN0b3J5LnVuZG9uZSA6IGhpc3RvcnkuZG9uZSkucG9wRXZlbnQoc3RhdGUsIHByZXNlcnZlSXRlbXMpO1xuICAgIGlmICghcG9wKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHNlbGVjdGlvbiA9IHBvcC5zZWxlY3Rpb24ucmVzb2x2ZShwb3AudHJhbnNmb3JtLmRvYyk7XG4gICAgbGV0IGFkZGVkID0gKHJlZG8gPyBoaXN0b3J5LmRvbmUgOiBoaXN0b3J5LnVuZG9uZSkuYWRkVHJhbnNmb3JtKHBvcC50cmFuc2Zvcm0sIHN0YXRlLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpLCBoaXN0T3B0aW9ucywgcHJlc2VydmVJdGVtcyk7XG4gICAgbGV0IG5ld0hpc3QgPSBuZXcgSGlzdG9yeVN0YXRlKHJlZG8gPyBhZGRlZCA6IHBvcC5yZW1haW5pbmcsIHJlZG8gPyBwb3AucmVtYWluaW5nIDogYWRkZWQsIG51bGwsIDAsIC0xKTtcbiAgICBkaXNwYXRjaChwb3AudHJhbnNmb3JtLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pLnNldE1ldGEoaGlzdG9yeUtleSwgeyByZWRvLCBoaXN0b3J5U3RhdGU6IG5ld0hpc3QgfSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG59XG5sZXQgY2FjaGVkUHJlc2VydmVJdGVtcyA9IGZhbHNlLCBjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyA9IG51bGw7XG4vLyBDaGVjayB3aGV0aGVyIGFueSBwbHVnaW4gaW4gdGhlIGdpdmVuIHN0YXRlIGhhcyBhXG4vLyBgaGlzdG9yeVByZXNlcnZlSXRlbXNgIHByb3BlcnR5IGluIGl0cyBzcGVjLCBpbiB3aGljaCBjYXNlIHdlIG11c3Rcbi8vIHByZXNlcnZlIHN0ZXBzIGV4YWN0bHkgYXMgdGhleSBjYW1lIGluLCBzbyB0aGF0IHRoZXkgY2FuIGJlXG4vLyByZWJhc2VkLlxuZnVuY3Rpb24gbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpIHtcbiAgICBsZXQgcGx1Z2lucyA9IHN0YXRlLnBsdWdpbnM7XG4gICAgaWYgKGNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zICE9IHBsdWdpbnMpIHtcbiAgICAgICAgY2FjaGVkUHJlc2VydmVJdGVtcyA9IGZhbHNlO1xuICAgICAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyA9IHBsdWdpbnM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChwbHVnaW5zW2ldLnNwZWMuaGlzdG9yeVByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFByZXNlcnZlSXRlbXM7XG59XG4vKipcblNldCBhIGZsYWcgb24gdGhlIGdpdmVuIHRyYW5zYWN0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IGZ1cnRoZXIgc3RlcHNcbmZyb20gYmVpbmcgYXBwZW5kZWQgdG8gYW4gZXhpc3RpbmcgaGlzdG9yeSBldmVudCAoc28gdGhhdCB0aGV5XG5yZXF1aXJlIGEgc2VwYXJhdGUgdW5kbyBjb21tYW5kIHRvIHVuZG8pLlxuKi9cbmZ1bmN0aW9uIGNsb3NlSGlzdG9yeSh0cikge1xuICAgIHJldHVybiB0ci5zZXRNZXRhKGNsb3NlSGlzdG9yeUtleSwgdHJ1ZSk7XG59XG5jb25zdCBoaXN0b3J5S2V5ID0gbmV3IFBsdWdpbktleShcImhpc3RvcnlcIik7XG5jb25zdCBjbG9zZUhpc3RvcnlLZXkgPSBuZXcgUGx1Z2luS2V5KFwiY2xvc2VIaXN0b3J5XCIpO1xuLyoqXG5SZXR1cm5zIGEgcGx1Z2luIHRoYXQgZW5hYmxlcyB0aGUgdW5kbyBoaXN0b3J5IGZvciBhbiBlZGl0b3IuIFRoZVxucGx1Z2luIHdpbGwgdHJhY2sgdW5kbyBhbmQgcmVkbyBzdGFja3MsIHdoaWNoIGNhbiBiZSB1c2VkIHdpdGggdGhlXG5bYHVuZG9gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jaGlzdG9yeS51bmRvKSBhbmQgW2ByZWRvYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2hpc3RvcnkucmVkbykgY29tbWFuZHMuXG5cbllvdSBjYW4gc2V0IGFuIGBcImFkZFRvSGlzdG9yeVwiYCBbbWV0YWRhdGFcbnByb3BlcnR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc2V0TWV0YSkgb2YgYGZhbHNlYCBvbiBhIHRyYW5zYWN0aW9uXG50byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcm9sbGVkIGJhY2sgYnkgdW5kby5cbiovXG5mdW5jdGlvbiBoaXN0b3J5KGNvbmZpZyA9IHt9KSB7XG4gICAgY29uZmlnID0geyBkZXB0aDogY29uZmlnLmRlcHRoIHx8IDEwMCxcbiAgICAgICAgbmV3R3JvdXBEZWxheTogY29uZmlnLm5ld0dyb3VwRGVsYXkgfHwgNTAwIH07XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IGhpc3RvcnlLZXksXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKEJyYW5jaC5lbXB0eSwgQnJhbmNoLmVtcHR5LCBudWxsLCAwLCAtMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwbHkodHIsIGhpc3QsIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIHRyLCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgICAgICBiZWZvcmVpbnB1dCh2aWV3LCBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnB1dFR5cGUgPSBlLmlucHV0VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbW1hbmQgPSBpbnB1dFR5cGUgPT0gXCJoaXN0b3J5VW5kb1wiID8gdW5kbyA6IGlucHV0VHlwZSA9PSBcImhpc3RvcnlSZWRvXCIgPyByZWRvIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG5BIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB1bmRvZXMgdGhlIGxhc3QgY2hhbmdlLCBpZiBhbnkuXG4qL1xuY29uc3QgdW5kbyA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgIGlmICghaGlzdCB8fCBoaXN0LmRvbmUuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBoaXN0VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIGRpc3BhdGNoLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCByZWRvZXMgdGhlIGxhc3QgdW5kb25lIGNoYW5nZSwgaWYgYW55LlxuKi9cbmNvbnN0IHJlZG8gPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICBpZiAoIWhpc3QgfHwgaGlzdC51bmRvbmUuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBoaXN0VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblRoZSBhbW91bnQgb2YgdW5kb2FibGUgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIHVuZG9EZXB0aChzdGF0ZSkge1xuICAgIGxldCBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIGhpc3QgPyBoaXN0LmRvbmUuZXZlbnRDb3VudCA6IDA7XG59XG4vKipcblRoZSBhbW91bnQgb2YgcmVkb2FibGUgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIGVkaXRvciBzdGF0ZS5cbiovXG5mdW5jdGlvbiByZWRvRGVwdGgoc3RhdGUpIHtcbiAgICBsZXQgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiBoaXN0ID8gaGlzdC51bmRvbmUuZXZlbnRDb3VudCA6IDA7XG59XG5cbmV4cG9ydCB7IGNsb3NlSGlzdG9yeSwgaGlzdG9yeSwgcmVkbywgcmVkb0RlcHRoLCB1bmRvLCB1bmRvRGVwdGggfTtcbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBoaXN0b3J5LCByZWRvLCB1bmRvIH0gZnJvbSAnQHRpcHRhcC9wbS9oaXN0b3J5J1xuXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcnlPcHRpb25zIHtcbiAgZGVwdGg6IG51bWJlcixcbiAgbmV3R3JvdXBEZWxheTogbnVtYmVyLFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaGlzdG9yeToge1xuICAgICAgLyoqXG4gICAgICAgKiBVbmRvIHJlY2VudCBjaGFuZ2VzXG4gICAgICAgKi9cbiAgICAgIHVuZG86ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFJlYXBwbHkgcmV2ZXJ0ZWQgY2hhbmdlc1xuICAgICAgICovXG4gICAgICByZWRvOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgSGlzdG9yeSA9IEV4dGVuc2lvbi5jcmVhdGU8SGlzdG9yeU9wdGlvbnM+KHtcbiAgbmFtZTogJ2hpc3RvcnknLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlcHRoOiAxMDAsXG4gICAgICBuZXdHcm91cERlbGF5OiA1MDAsXG4gICAgfVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB1bmRvOiAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICByZXR1cm4gdW5kbyhzdGF0ZSwgZGlzcGF0Y2gpXG4gICAgICB9LFxuICAgICAgcmVkbzogKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZG8oc3RhdGUsIGRpc3BhdGNoKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBoaXN0b3J5KHRoaXMub3B0aW9ucyksXG4gICAgXVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLXonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy51bmRvKCksXG4gICAgICAnU2hpZnQtTW9kLXonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgICAnTW9kLXknOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG5cbiAgICAgIC8vIFJ1c3NpYW4ga2V5Ym9hcmQgbGF5b3V0c1xuICAgICAgJ01vZC3Rjyc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnVuZG8oKSxcbiAgICAgICdTaGlmdC1Nb2Qt0Y8nOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIG5vZGVJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGludGVyZmFjZSBIb3Jpem9udGFsUnVsZU9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaG9yaXpvbnRhbFJ1bGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogQWRkIGEgaG9yaXpvbnRhbCBydWxlXG4gICAgICAgKi9cbiAgICAgIHNldEhvcml6b250YWxSdWxlOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBIb3Jpem9udGFsUnVsZSA9IE5vZGUuY3JlYXRlPEhvcml6b250YWxSdWxlT3B0aW9ucz4oe1xuICBuYW1lOiAnaG9yaXpvbnRhbFJ1bGUnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgZ3JvdXA6ICdibG9jaycsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6ICdocicgfV1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ2hyJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRIb3Jpem9udGFsUnVsZTpcbiAgICAgICAgKCkgPT4gKHsgY2hhaW4sIHN0YXRlIH0pID0+IHtcbiAgICAgICAgICBjb25zdCB7ICR0bzogJG9yaWdpblRvIH0gPSBzdGF0ZS5zZWxlY3Rpb25cblxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRDaGFpbiA9IGNoYWluKClcblxuICAgICAgICAgIGlmICgkb3JpZ2luVG8ucGFyZW50T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICBjdXJyZW50Q2hhaW4uaW5zZXJ0Q29udGVudEF0KE1hdGgubWF4KCRvcmlnaW5Uby5wb3MgLSAyLCAwKSwgeyB0eXBlOiB0aGlzLm5hbWUgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudENoYWluLmluc2VydENvbnRlbnQoeyB0eXBlOiB0aGlzLm5hbWUgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY3VycmVudENoYWluXG4gICAgICAgICAgICAgIC8vIHNldCBjdXJzb3IgYWZ0ZXIgaG9yaXpvbnRhbCBydWxlXG4gICAgICAgICAgICAgIC5jb21tYW5kKCh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB7ICR0byB9ID0gdHIuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICBjb25zdCBwb3NBZnRlciA9ICR0by5lbmQoKVxuXG4gICAgICAgICAgICAgICAgICBpZiAoJHRvLm5vZGVBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJHRvLm5vZGVBZnRlci5pc1RleHRibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICR0by5wb3MgKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkdG8ubm9kZUFmdGVyLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkdG8ucG9zKSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkdG8ucG9zKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIG5vZGUgYWZ0ZXIgaG9yaXpvbnRhbCBydWxlIGlmIGl04oCZcyB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gJHRvLnBhcmVudC50eXBlLmNvbnRlbnRNYXRjaC5kZWZhdWx0VHlwZT8uY3JlYXRlKClcblxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRyLmluc2VydChwb3NBZnRlciwgbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb3NBZnRlciArIDEpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHRyLnNjcm9sbEludG9WaWV3KClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAucnVuKClcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5vZGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiAvXig/Oi0tLXzigJQtfF9fX1xcc3xcXCpcXCpcXCpcXHMpJC8sXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHtcbiAgTWFyayxcbiAgbWFya0lucHV0UnVsZSxcbiAgbWFya1Bhc3RlUnVsZSxcbiAgbWVyZ2VBdHRyaWJ1dGVzLFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgSXRhbGljT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaXRhbGljOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhbiBpdGFsaWMgbWFya1xuICAgICAgICovXG4gICAgICBzZXRJdGFsaWM6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhbiBpdGFsaWMgbWFya1xuICAgICAgICovXG4gICAgICB0b2dnbGVJdGFsaWM6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGFuIGl0YWxpYyBtYXJrXG4gICAgICAgKi9cbiAgICAgIHVuc2V0SXRhbGljOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc3RhcklucHV0UmVnZXggPSAvKD86XnxcXHMpKCg/OlxcKikoKD86W14qXSspKSg/OlxcKikpJC9cbmV4cG9ydCBjb25zdCBzdGFyUGFzdGVSZWdleCA9IC8oPzpefFxccykoKD86XFwqKSgoPzpbXipdKykpKD86XFwqKSkvZ1xuZXhwb3J0IGNvbnN0IHVuZGVyc2NvcmVJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpfKSgoPzpbXl9dKykpKD86XykpJC9cbmV4cG9ydCBjb25zdCB1bmRlcnNjb3JlUGFzdGVSZWdleCA9IC8oPzpefFxccykoKD86XykoKD86W15fXSspKSg/Ol8pKS9nXG5cbmV4cG9ydCBjb25zdCBJdGFsaWMgPSBNYXJrLmNyZWF0ZTxJdGFsaWNPcHRpb25zPih7XG4gIG5hbWU6ICdpdGFsaWMnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ2VtJyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogJ2knLFxuICAgICAgICBnZXRBdHRyczogbm9kZSA9PiAobm9kZSBhcyBIVE1MRWxlbWVudCkuc3R5bGUuZm9udFN0eWxlICE9PSAnbm9ybWFsJyAmJiBudWxsLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6ICdmb250LXN0eWxlPWl0YWxpYycsXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ2VtJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRJdGFsaWM6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZUl0YWxpYzogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdW5zZXRJdGFsaWM6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1pJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlSXRhbGljKCksXG4gICAgICAnTW9kLUknOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVJdGFsaWMoKSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IHN0YXJJbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlSW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxuXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFyUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogdW5kZXJzY29yZVBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIExpc3RJdGVtT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBidWxsZXRMaXN0VHlwZU5hbWU6IHN0cmluZ1xuICBvcmRlcmVkTGlzdFR5cGVOYW1lOiBzdHJpbmdcbn1cblxuZXhwb3J0IGNvbnN0IExpc3RJdGVtID0gTm9kZS5jcmVhdGU8TGlzdEl0ZW1PcHRpb25zPih7XG4gIG5hbWU6ICdsaXN0SXRlbScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgYnVsbGV0TGlzdFR5cGVOYW1lOiAnYnVsbGV0TGlzdCcsXG4gICAgICBvcmRlcmVkTGlzdFR5cGVOYW1lOiAnb3JkZXJlZExpc3QnLFxuICAgIH1cbiAgfSxcblxuICBjb250ZW50OiAncGFyYWdyYXBoIGJsb2NrKicsXG5cbiAgZGVmaW5pbmc6IHRydWUsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ2xpJyxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnbGknLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEVudGVyOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zcGxpdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICBUYWI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNpbmtMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgJ1NoaWZ0LVRhYic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmxpZnRMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIExpc3RJdGVtT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBidWxsZXRMaXN0VHlwZU5hbWU6IHN0cmluZ1xuICBvcmRlcmVkTGlzdFR5cGVOYW1lOiBzdHJpbmdcbn1cblxuZXhwb3J0IGNvbnN0IExpc3RJdGVtID0gTm9kZS5jcmVhdGU8TGlzdEl0ZW1PcHRpb25zPih7XG4gIG5hbWU6ICdsaXN0SXRlbScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgYnVsbGV0TGlzdFR5cGVOYW1lOiAnYnVsbGV0TGlzdCcsXG4gICAgICBvcmRlcmVkTGlzdFR5cGVOYW1lOiAnb3JkZXJlZExpc3QnLFxuICAgIH1cbiAgfSxcblxuICBjb250ZW50OiAncGFyYWdyYXBoIGJsb2NrKicsXG5cbiAgZGVmaW5pbmc6IHRydWUsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ2xpJyxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnbGknLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEVudGVyOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zcGxpdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICBUYWI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNpbmtMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgJ1NoaWZ0LVRhYic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmxpZnRMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHtcbiAgZ2V0TWFya0F0dHJpYnV0ZXMsXG4gIE1hcmssXG4gIG1lcmdlQXR0cmlidXRlcyxcbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFRleHRTdHlsZU9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHRleHRTdHlsZToge1xuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgc3BhbnMgd2l0aG91dCBpbmxpbmUgc3R5bGUgYXR0cmlidXRlcy5cbiAgICAgICAqL1xuICAgICAgcmVtb3ZlRW1wdHlUZXh0U3R5bGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBUZXh0U3R5bGUgPSBNYXJrLmNyZWF0ZTxUZXh0U3R5bGVPcHRpb25zPih7XG4gIG5hbWU6ICd0ZXh0U3R5bGUnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgICBnZXRBdHRyczogZWxlbWVudCA9PiB7XG4gICAgICAgICAgY29uc3QgaGFzU3R5bGVzID0gKGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKVxuXG4gICAgICAgICAgaWYgKCFoYXNTdHlsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7fVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydzcGFuJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZW1vdmVFbXB0eVRleHRTdHlsZTogKCkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0aGlzLnR5cGUpXG4gICAgICAgIGNvbnN0IGhhc1N0eWxlcyA9IE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLnNvbWUoKFssIHZhbHVlXSkgPT4gISF2YWx1ZSlcblxuICAgICAgICBpZiAoaGFzU3R5bGVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB3cmFwcGluZ0lucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuaW1wb3J0IExpc3RJdGVtIGZyb20gJy4uLy4uL2V4dGVuc2lvbi1saXN0LWl0ZW0vc3JjL2luZGV4LmpzJ1xuaW1wb3J0IFRleHRTdHlsZSBmcm9tICcuLi8uLi9leHRlbnNpb24tdGV4dC1zdHlsZS9zcmMvaW5kZXguanMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgT3JkZXJlZExpc3RPcHRpb25zIHtcbiAgaXRlbVR5cGVOYW1lOiBzdHJpbmcsXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBrZWVwTWFya3M6IGJvb2xlYW4sXG4gIGtlZXBBdHRyaWJ1dGVzOiBib29sZWFuLFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgb3JkZXJlZExpc3Q6IHtcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGFuIG9yZGVyZWQgbGlzdFxuICAgICAgICovXG4gICAgICB0b2dnbGVPcmRlcmVkTGlzdDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGlucHV0UmVnZXggPSAvXihcXGQrKVxcLlxccyQvXG5cbmV4cG9ydCBjb25zdCBPcmRlcmVkTGlzdCA9IE5vZGUuY3JlYXRlPE9yZGVyZWRMaXN0T3B0aW9ucz4oe1xuICBuYW1lOiAnb3JkZXJlZExpc3QnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1UeXBlTmFtZTogJ2xpc3RJdGVtJyxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGtlZXBNYXJrczogZmFsc2UsXG4gICAgICBrZWVwQXR0cmlidXRlczogZmFsc2UsXG4gICAgfVxuICB9LFxuXG4gIGdyb3VwOiAnYmxvY2sgbGlzdCcsXG5cbiAgY29udGVudCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZX0rYFxuICB9LFxuXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiB7XG4gICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgIHBhcnNlSFRNTDogZWxlbWVudCA9PiB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdzdGFydCcpXG4gICAgICAgICAgICA/IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdGFydCcpIHx8ICcnLCAxMClcbiAgICAgICAgICAgIDogMVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ29sJyxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgY29uc3QgeyBzdGFydCwgLi4uYXR0cmlidXRlc1dpdGhvdXRTdGFydCB9ID0gSFRNTEF0dHJpYnV0ZXNcblxuICAgIHJldHVybiBzdGFydCA9PT0gMVxuICAgICAgPyBbJ29sJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgYXR0cmlidXRlc1dpdGhvdXRTdGFydCksIDBdXG4gICAgICA6IFsnb2wnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvZ2dsZU9yZGVyZWRMaXN0OiAoKSA9PiAoeyBjb21tYW5kcywgY2hhaW4gfSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYWluKCkudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpLnVwZGF0ZUF0dHJpYnV0ZXMoTGlzdEl0ZW0ubmFtZSwgdGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGUubmFtZSkpLnJ1bigpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtU2hpZnQtNyc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZU9yZGVyZWRMaXN0KCksXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgbGV0IGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICBnZXRBdHRyaWJ1dGVzOiBtYXRjaCA9PiAoeyBzdGFydDogK21hdGNoWzFdIH0pLFxuICAgICAgam9pblByZWRpY2F0ZTogKG1hdGNoLCBub2RlKSA9PiBub2RlLmNoaWxkQ291bnQgKyBub2RlLmF0dHJzLnN0YXJ0ID09PSArbWF0Y2hbMV0sXG4gICAgfSlcblxuICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcE1hcmtzIHx8IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGtlZXBNYXJrczogdGhpcy5vcHRpb25zLmtlZXBNYXJrcyxcbiAgICAgICAga2VlcEF0dHJpYnV0ZXM6IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcyxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHsgc3RhcnQ6ICttYXRjaFsxXSwgLi4udGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGUubmFtZSkgfSksXG4gICAgICAgIGpvaW5QcmVkaWNhdGU6IChtYXRjaCwgbm9kZSkgPT4gbm9kZS5jaGlsZENvdW50ICsgbm9kZS5hdHRycy5zdGFydCA9PT0gK21hdGNoWzFdLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIGlucHV0UnVsZSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBQYXJhZ3JhcGhPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBwYXJhZ3JhcGg6IHtcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgcGFyYWdyYXBoXG4gICAgICAgKi9cbiAgICAgIHNldFBhcmFncmFwaDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFBhcmFncmFwaCA9IE5vZGUuY3JlYXRlPFBhcmFncmFwaE9wdGlvbnM+KHtcbiAgbmFtZTogJ3BhcmFncmFwaCcsXG5cbiAgcHJpb3JpdHk6IDEwMDAsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBncm91cDogJ2Jsb2NrJyxcblxuICBjb250ZW50OiAnaW5saW5lKicsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHRhZzogJ3AnIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsncCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0UGFyYWdyYXBoOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLUFsdC0wJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0UGFyYWdyYXBoKCksXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQge1xuICBpc01hY09TLFxuICBNYXJrLFxuICBtYXJrSW5wdXRSdWxlLFxuICBtYXJrUGFzdGVSdWxlLFxuICBtZXJnZUF0dHJpYnV0ZXMsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBTdHJpa2VPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzdHJpa2U6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgc3RyaWtlIG1hcmtcbiAgICAgICAqL1xuICAgICAgc2V0U3RyaWtlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBzdHJpa2UgbWFya1xuICAgICAgICovXG4gICAgICB0b2dnbGVTdHJpa2U6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGEgc3RyaWtlIG1hcmtcbiAgICAgICAqL1xuICAgICAgdW5zZXRTdHJpa2U6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSgoPzp+fikoKD86W15+XSspKSg/On5+KSkkL1xuZXhwb3J0IGNvbnN0IHBhc3RlUmVnZXggPSAvKD86XnxcXHMpKCg/On5+KSgoPzpbXn5dKykpKD86fn4pKS9nXG5cbmV4cG9ydCBjb25zdCBTdHJpa2UgPSBNYXJrLmNyZWF0ZTxTdHJpa2VPcHRpb25zPih7XG4gIG5hbWU6ICdzdHJpa2UnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ3MnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnZGVsJyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogJ3N0cmlrZScsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogJ3RleHQtZGVjb3JhdGlvbicsXG4gICAgICAgIGNvbnN1bWluZzogZmFsc2UsXG4gICAgICAgIGdldEF0dHJzOiBzdHlsZSA9PiAoKHN0eWxlIGFzIHN0cmluZykuaW5jbHVkZXMoJ2xpbmUtdGhyb3VnaCcpID8ge30gOiBmYWxzZSksXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ3MnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFN0cmlrZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdG9nZ2xlU3RyaWtlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB1bnNldFN0cmlrZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIGNvbnN0IHNob3J0Y3V0czogUmVjb3JkPHN0cmluZywgKCkgPT4gYm9vbGVhbj4gPSB7fVxuXG4gICAgaWYgKGlzTWFjT1MoKSkge1xuICAgICAgc2hvcnRjdXRzWydNb2QtU2hpZnQtcyddID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlU3RyaWtlKClcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvcnRjdXRzWydDdHJsLVNoaWZ0LXMnXSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVN0cmlrZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHNob3J0Y3V0c1xuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGNvbnN0IFRleHQgPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6ICd0ZXh0JyxcbiAgZ3JvdXA6ICdpbmxpbmUnLFxufSlcbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBCbG9ja3F1b3RlLCBCbG9ja3F1b3RlT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJsb2NrcXVvdGUnXG5pbXBvcnQgeyBCb2xkLCBCb2xkT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJvbGQnXG5pbXBvcnQgeyBCdWxsZXRMaXN0LCBCdWxsZXRMaXN0T3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJ1bGxldC1saXN0J1xuaW1wb3J0IHsgQ29kZSwgQ29kZU9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1jb2RlJ1xuaW1wb3J0IHsgQ29kZUJsb2NrLCBDb2RlQmxvY2tPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jaydcbmltcG9ydCB7IERvY3VtZW50IH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQnXG5pbXBvcnQgeyBEcm9wY3Vyc29yLCBEcm9wY3Vyc29yT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWRyb3BjdXJzb3InXG5pbXBvcnQgeyBHYXBjdXJzb3IgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1nYXBjdXJzb3InXG5pbXBvcnQgeyBIYXJkQnJlYWssIEhhcmRCcmVha09wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1oYXJkLWJyZWFrJ1xuaW1wb3J0IHsgSGVhZGluZywgSGVhZGluZ09wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1oZWFkaW5nJ1xuaW1wb3J0IHsgSGlzdG9yeSwgSGlzdG9yeU9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1oaXN0b3J5J1xuaW1wb3J0IHsgSG9yaXpvbnRhbFJ1bGUsIEhvcml6b250YWxSdWxlT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWhvcml6b250YWwtcnVsZSdcbmltcG9ydCB7IEl0YWxpYywgSXRhbGljT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWl0YWxpYydcbmltcG9ydCB7IExpc3RJdGVtLCBMaXN0SXRlbU9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1saXN0LWl0ZW0nXG5pbXBvcnQgeyBPcmRlcmVkTGlzdCwgT3JkZXJlZExpc3RPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tb3JkZXJlZC1saXN0J1xuaW1wb3J0IHsgUGFyYWdyYXBoLCBQYXJhZ3JhcGhPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoJ1xuaW1wb3J0IHsgU3RyaWtlLCBTdHJpa2VPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlJ1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLXRleHQnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhcnRlcktpdE9wdGlvbnMge1xuICBibG9ja3F1b3RlOiBQYXJ0aWFsPEJsb2NrcXVvdGVPcHRpb25zPiB8IGZhbHNlLFxuICBib2xkOiBQYXJ0aWFsPEJvbGRPcHRpb25zPiB8IGZhbHNlLFxuICBidWxsZXRMaXN0OiBQYXJ0aWFsPEJ1bGxldExpc3RPcHRpb25zPiB8IGZhbHNlLFxuICBjb2RlOiBQYXJ0aWFsPENvZGVPcHRpb25zPiB8IGZhbHNlLFxuICBjb2RlQmxvY2s6IFBhcnRpYWw8Q29kZUJsb2NrT3B0aW9ucz4gfCBmYWxzZSxcbiAgZG9jdW1lbnQ6IGZhbHNlLFxuICBkcm9wY3Vyc29yOiBQYXJ0aWFsPERyb3BjdXJzb3JPcHRpb25zPiB8IGZhbHNlLFxuICBnYXBjdXJzb3I6IGZhbHNlLFxuICBoYXJkQnJlYWs6IFBhcnRpYWw8SGFyZEJyZWFrT3B0aW9ucz4gfCBmYWxzZSxcbiAgaGVhZGluZzogUGFydGlhbDxIZWFkaW5nT3B0aW9ucz4gfCBmYWxzZSxcbiAgaGlzdG9yeTogUGFydGlhbDxIaXN0b3J5T3B0aW9ucz4gfCBmYWxzZSxcbiAgaG9yaXpvbnRhbFJ1bGU6IFBhcnRpYWw8SG9yaXpvbnRhbFJ1bGVPcHRpb25zPiB8IGZhbHNlLFxuICBpdGFsaWM6IFBhcnRpYWw8SXRhbGljT3B0aW9ucz4gfCBmYWxzZSxcbiAgbGlzdEl0ZW06IFBhcnRpYWw8TGlzdEl0ZW1PcHRpb25zPiB8IGZhbHNlLFxuICBvcmRlcmVkTGlzdDogUGFydGlhbDxPcmRlcmVkTGlzdE9wdGlvbnM+IHwgZmFsc2UsXG4gIHBhcmFncmFwaDogUGFydGlhbDxQYXJhZ3JhcGhPcHRpb25zPiB8IGZhbHNlLFxuICBzdHJpa2U6IFBhcnRpYWw8U3RyaWtlT3B0aW9ucz4gfCBmYWxzZSxcbiAgdGV4dDogZmFsc2UsXG59XG5cbmV4cG9ydCBjb25zdCBTdGFydGVyS2l0ID0gRXh0ZW5zaW9uLmNyZWF0ZTxTdGFydGVyS2l0T3B0aW9ucz4oe1xuICBuYW1lOiAnc3RhcnRlcktpdCcsXG5cbiAgYWRkRXh0ZW5zaW9ucygpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gW11cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmxvY2txdW90ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChCbG9ja3F1b3RlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmJsb2NrcXVvdGUpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYm9sZCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChCb2xkLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmJvbGQpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYnVsbGV0TGlzdCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChCdWxsZXRMaXN0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmJ1bGxldExpc3QpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29kZSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChDb2RlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmNvZGUpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29kZUJsb2NrICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKENvZGVCbG9jay5jb25maWd1cmUodGhpcy5vcHRpb25zPy5jb2RlQmxvY2spKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZG9jdW1lbnQgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goRG9jdW1lbnQuY29uZmlndXJlKHRoaXMub3B0aW9ucz8uZG9jdW1lbnQpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZHJvcGN1cnNvciAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChEcm9wY3Vyc29yLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmRyb3BjdXJzb3IpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2FwY3Vyc29yICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEdhcGN1cnNvci5jb25maWd1cmUodGhpcy5vcHRpb25zPy5nYXBjdXJzb3IpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFyZEJyZWFrICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhhcmRCcmVhay5jb25maWd1cmUodGhpcy5vcHRpb25zPy5oYXJkQnJlYWspKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGluZyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChIZWFkaW5nLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmhlYWRpbmcpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGlzdG9yeSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChIaXN0b3J5LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/Lmhpc3RvcnkpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbFJ1bGUgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goSG9yaXpvbnRhbFJ1bGUuY29uZmlndXJlKHRoaXMub3B0aW9ucz8uaG9yaXpvbnRhbFJ1bGUpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaXRhbGljICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEl0YWxpYy5jb25maWd1cmUodGhpcy5vcHRpb25zPy5pdGFsaWMpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMubGlzdEl0ZW0gIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goTGlzdEl0ZW0uY29uZmlndXJlKHRoaXMub3B0aW9ucz8ubGlzdEl0ZW0pKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMub3JkZXJlZExpc3QgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goT3JkZXJlZExpc3QuY29uZmlndXJlKHRoaXMub3B0aW9ucz8ub3JkZXJlZExpc3QpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGFyYWdyYXBoICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFBhcmFncmFwaC5jb25maWd1cmUodGhpcy5vcHRpb25zPy5wYXJhZ3JhcGgpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaWtlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFN0cmlrZS5jb25maWd1cmUodGhpcy5vcHRpb25zPy5zdHJpa2UpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChUZXh0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LnRleHQpKVxuICAgIH1cblxuICAgIHJldHVybiBleHRlbnNpb25zXG4gIH0sXG59KVxuIiwgIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTm9kZVZpZXdXcmFwcGVyIH0gZnJvbSAnc3ZlbHRlLXRpcHRhcCdcbiAgICBpbXBvcnQgeyBvbk1vdW50LCB0aWNrIH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IHBvdW5jZSB9IGZyb20gJy4uL3V0aWxzLmpzJ1xuICAgIGltcG9ydCB7IGdldFN0YXRlUGF0aCB9IGZyb20gJy4uL3N0b3Jlcy5qcydcbiAgICBpbXBvcnQgQmxvY2tTZXR0aW5ncyBmcm9tICcuL0Jsb2NrU2V0dGluZ3Muc3ZlbHRlJ1xuICAgIGltcG9ydCBEcmFnSGFuZGxlIGZyb20gJy4vRHJhZ0hhbmRsZS5zdmVsdGUnXG4gICAgaW1wb3J0IFJlbW92ZUJsb2NrIGZyb20gJy4vUmVtb3ZlQmxvY2suc3ZlbHRlJ1xuICAgIGltcG9ydCBCbG9ja0FjdGlvbnMgZnJvbSAnLi9CbG9ja0FjdGlvbnMuc3ZlbHRlJ1xuXG4gICAgZXhwb3J0IGxldCBlZGl0b3I7XG4gICAgZXhwb3J0IGxldCBub2RlO1xuICAgIGV4cG9ydCBsZXQgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBleHBvcnQgbGV0IHVwZGF0ZUF0dHJpYnV0ZXM7XG5cbiAgICBsZXQgdmlldyA9IG51bGw7XG4gICAgJDogd3JhcHBlciA9IG51bGw7XG5cbiAgICBjb25zdCBoYW5kbGVPcGVuID0gKCkgPT4ge1xuICAgICAgICBwb3VuY2Uobm9kZS5hdHRycy5pZGVudGlmaWVyLCB7XG4gICAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgICBzdGF0ZVBhdGg6ICRnZXRTdGF0ZVBhdGgsXG4gICAgICAgICAgICBibG9ja0lkOiBub2RlLmF0dHJzLmlkLFxuICAgICAgICAgICAgLi4ubm9kZS5hdHRycy52YWx1ZXNcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVSZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5jb21tYW5kcy5kZWxldGVTZWxlY3Rpb24oKVxuICAgIH1cblxuICAgICQ6IGdldFZpZXcgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzY3JpYmJsZS1yZW5kZXJlcicpLmdldEF0dHJpYnV0ZSgnd2lyZTppZCcpXG5cbiAgICAgICAgd2luZG93LkxpdmV3aXJlXG4gICAgICAgICAgICAuZmluZChjb21wb25lbnQpXG4gICAgICAgICAgICAuY2FsbCgnZ2V0VmlldycsIG5vZGUuYXR0cnMuaWRlbnRpZmllciwgbm9kZS5hdHRycy52YWx1ZXMpXG4gICAgICAgICAgICAudGhlbihlID0+IHtcbiAgICAgICAgICAgICAgICB2aWV3ID0gZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdpZCcpLnJlcGxhY2UoJ2RhdGEuJywgJycpXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUF0dHJpYnV0ZXMoeyB2YWx1ZXM6IHsuLi5ub2RlLmF0dHJzLnZhbHVlcywgW25hbWVdOiB2YWx1ZSB9IH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGdldFZpZXcoKVxuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVkQmxvY2snLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGUuZGV0YWlsLmlkZW50aWZpZXIgPT09IG5vZGUuYXR0cnMuaWRlbnRpZmllclxuICAgICAgICAgICAgICAgICYmIGUuZGV0YWlsLnN0YXRlUGF0aCA9PT0gJGdldFN0YXRlUGF0aFxuICAgICAgICAgICAgICAgICYmIGUuZGV0YWlsLmJsb2NrSWQgPT09IG5vZGUuYXR0cnMuaWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUF0dHJpYnV0ZXMoeyB2YWx1ZXM6IGUuZGV0YWlsLnZhbHVlcyB9KVxuICAgICAgICAgICAgICAgIGdldFZpZXcoKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudE5vZGUgPSBlZGl0b3IuJG5vZGUoJ3NjcmliYmxlQmxvY2snLCB7aWQ6IG5vZGUuYXR0cnMuaWR9KTtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmNvbW1hbmRzLnNldE5vZGVTZWxlY3Rpb24oY3VycmVudE5vZGUucG9zKVxuICAgICAgICAgICAgICAgIH0sIDEwMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KVxuPC9zY3JpcHQ+XG5cbjxOb2RlVmlld1dyYXBwZXI+XG4gICAgPGRpdiBjbGFzcz1cInNjcmliYmxlLWJsb2NrXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzY3JpYmJsZS1ibG9jay1jb250ZW50IHtzZWxlY3RlZCA/ICdQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGUnIDogJyd9XCIgYmluZDp0aGlzPXt3cmFwcGVyfT5cbiAgICAgICAgICAgIHtAaHRtbCB2aWV3fVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPEJsb2NrQWN0aW9ucz5cbiAgICAgICAgICAgIDxEcmFnSGFuZGxlIC8+XG4gICAgICAgICAgICB7I2lmIG5vZGUuYXR0cnMudHlwZSAhPT0gJ3N0YXRpYyd9XG4gICAgICAgICAgICA8QmxvY2tTZXR0aW5ncyB7aGFuZGxlT3Blbn0gLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8UmVtb3ZlQmxvY2sge2hhbmRsZVJlbW92ZX0gLz5cbiAgICAgICAgPC9CbG9ja0FjdGlvbnM+XG4gICAgPC9kaXY+XG48L05vZGVWaWV3V3JhcHBlcj5cbiIsICJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgU3ZlbHRlTm9kZVZpZXdSZW5kZXJlciB9IGZyb20gJ3N2ZWx0ZS10aXB0YXAnXG5pbXBvcnQgU2NyaWJibGVCbG9ja1ZpZXcgZnJvbSBcIi4uL2NvbXBvbmVudHMvU2NyaWJibGVCbG9jay5zdmVsdGVcIlxuaW1wb3J0IHsgdXVpZCwgcG91bmNlIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgTm9kZS5jcmVhdGUoe1xuICAgIG5hbWU6ICdzY3JpYmJsZUJsb2NrJyxcbiAgICBpc0Jsb2NrOiB0cnVlLFxuICAgIGlubGluZTogZmFsc2UsXG4gICAgZ3JvdXA6ICdibG9jaycsXG4gICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgIGRlZmluaW5nOiB0cnVlLFxuICAgIHNlbGVjdGFibGU6IHRydWUsXG5cbiAgICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICdibG9jaydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZGVudGlmaWVyOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnc2NyaWJibGUtYmxvY2snLFxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiAoZG9tKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRvbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydzY3JpYmJsZS1ibG9jaycsIEpTT04uc3RyaW5naWZ5KEhUTUxBdHRyaWJ1dGVzKV07XG4gICAgfSxcblxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0U2NyaWJibGVCbG9jazogKG9wdGlvbnMpID0+ICh7IHRyLCBzdGF0ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcG91bmNlKG9wdGlvbnMuaWRlbnRpZmllciwgeyBzdGF0ZVBhdGg6IG9wdGlvbnMuc3RhdGVQYXRoIH0pXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW5zZXJ0U2NyaWJibGVCbG9jazogKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHsgdHIsIGRpc3BhdGNoLCBzdGF0ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy50eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi57aWQ6IHV1aWQoKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5yZXBsYWNlUmFuZ2VXaXRoKHNlbGVjdGlvbi5mcm9tIC0gc2VsZWN0aW9uLiRhbmNob3IucGFyZW50T2Zmc2V0LCBzZWxlY3Rpb24udG8sIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZE5vZGVWaWV3KCkge1xuICAgICAgICByZXR1cm4gU3ZlbHRlTm9kZVZpZXdSZW5kZXJlcihTY3JpYmJsZUJsb2NrVmlldylcbiAgICB9XG59KVxuIiwgImltcG9ydCB7IGVzY2FwZUZvclJlZ0V4LCBSYW5nZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IFJlc29sdmVkUG9zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGludGVyZmFjZSBUcmlnZ2VyIHtcbiAgY2hhcjogc3RyaW5nXG4gIGFsbG93U3BhY2VzOiBib29sZWFuXG4gIGFsbG93ZWRQcmVmaXhlczogc3RyaW5nW10gfCBudWxsXG4gIHN0YXJ0T2ZMaW5lOiBib29sZWFuXG4gICRwb3NpdGlvbjogUmVzb2x2ZWRQb3Ncbn1cblxuZXhwb3J0IHR5cGUgU3VnZ2VzdGlvbk1hdGNoID0ge1xuICByYW5nZTogUmFuZ2VcbiAgcXVlcnk6IHN0cmluZ1xuICB0ZXh0OiBzdHJpbmdcbn0gfCBudWxsXG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kU3VnZ2VzdGlvbk1hdGNoKGNvbmZpZzogVHJpZ2dlcik6IFN1Z2dlc3Rpb25NYXRjaCB7XG4gIGNvbnN0IHtcbiAgICBjaGFyLCBhbGxvd1NwYWNlcywgYWxsb3dlZFByZWZpeGVzLCBzdGFydE9mTGluZSwgJHBvc2l0aW9uLFxuICB9ID0gY29uZmlnXG5cbiAgY29uc3QgZXNjYXBlZENoYXIgPSBlc2NhcGVGb3JSZWdFeChjaGFyKVxuICBjb25zdCBzdWZmaXggPSBuZXcgUmVnRXhwKGBcXFxccyR7ZXNjYXBlZENoYXJ9JGApXG4gIGNvbnN0IHByZWZpeCA9IHN0YXJ0T2ZMaW5lID8gJ14nIDogJydcbiAgY29uc3QgcmVnZXhwID0gYWxsb3dTcGFjZXNcbiAgICA/IG5ldyBSZWdFeHAoYCR7cHJlZml4fSR7ZXNjYXBlZENoYXJ9Lio/KD89XFxcXHMke2VzY2FwZWRDaGFyfXwkKWAsICdnbScpXG4gICAgOiBuZXcgUmVnRXhwKGAke3ByZWZpeH0oPzpeKT8ke2VzY2FwZWRDaGFyfVteXFxcXHMke2VzY2FwZWRDaGFyfV0qYCwgJ2dtJylcblxuICBjb25zdCB0ZXh0ID0gJHBvc2l0aW9uLm5vZGVCZWZvcmU/LmlzVGV4dCAmJiAkcG9zaXRpb24ubm9kZUJlZm9yZS50ZXh0XG5cbiAgaWYgKCF0ZXh0KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHRleHRGcm9tID0gJHBvc2l0aW9uLnBvcyAtIHRleHQubGVuZ3RoXG4gIGNvbnN0IG1hdGNoID0gQXJyYXkuZnJvbSh0ZXh0Lm1hdGNoQWxsKHJlZ2V4cCkpLnBvcCgpXG5cbiAgaWYgKCFtYXRjaCB8fCBtYXRjaC5pbnB1dCA9PT0gdW5kZWZpbmVkIHx8IG1hdGNoLmluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gSmF2YVNjcmlwdCBkb2Vzbid0IGhhdmUgbG9va2JlaGluZHMuIFRoaXMgaGFja3MgYSBjaGVjayB0aGF0IGZpcnN0IGNoYXJhY3RlclxuICAvLyBpcyBhIHNwYWNlIG9yIHRoZSBzdGFydCBvZiB0aGUgbGluZVxuICBjb25zdCBtYXRjaFByZWZpeCA9IG1hdGNoLmlucHV0LnNsaWNlKE1hdGgubWF4KDAsIG1hdGNoLmluZGV4IC0gMSksIG1hdGNoLmluZGV4KVxuICBjb25zdCBtYXRjaFByZWZpeElzQWxsb3dlZCA9IG5ldyBSZWdFeHAoYF5bJHthbGxvd2VkUHJlZml4ZXM/LmpvaW4oJycpfVxcMF0/JGApLnRlc3QobWF0Y2hQcmVmaXgpXG5cbiAgaWYgKGFsbG93ZWRQcmVmaXhlcyAhPT0gbnVsbCAmJiAhbWF0Y2hQcmVmaXhJc0FsbG93ZWQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBtYXRjaCBpbiB0aGUgZG9jdW1lbnRcbiAgY29uc3QgZnJvbSA9IHRleHRGcm9tICsgbWF0Y2guaW5kZXhcbiAgbGV0IHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aFxuXG4gIC8vIEVkZ2UgY2FzZSBoYW5kbGluZzsgaWYgc3BhY2VzIGFyZSBhbGxvd2VkIGFuZCB3ZSdyZSBkaXJlY3RseSBpbiBiZXR3ZWVuXG4gIC8vIHR3byB0cmlnZ2Vyc1xuICBpZiAoYWxsb3dTcGFjZXMgJiYgc3VmZml4LnRlc3QodGV4dC5zbGljZSh0byAtIDEsIHRvICsgMSkpKSB7XG4gICAgbWF0Y2hbMF0gKz0gJyAnXG4gICAgdG8gKz0gMVxuICB9XG5cbiAgLy8gSWYgdGhlICRwb3NpdGlvbiBpcyBsb2NhdGVkIHdpdGhpbiB0aGUgbWF0Y2hlZCBzdWJzdHJpbmcsIHJldHVybiB0aGF0IHJhbmdlXG4gIGlmIChmcm9tIDwgJHBvc2l0aW9uLnBvcyAmJiB0byA+PSAkcG9zaXRpb24ucG9zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgfSxcbiAgICAgIHF1ZXJ5OiBtYXRjaFswXS5zbGljZShjaGFyLmxlbmd0aCksXG4gICAgICB0ZXh0OiBtYXRjaFswXSxcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIiwgImltcG9ydCB7IEVkaXRvciwgUmFuZ2UgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSwgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCwgRWRpdG9yVmlldyB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHsgZmluZFN1Z2dlc3Rpb25NYXRjaCBhcyBkZWZhdWx0RmluZFN1Z2dlc3Rpb25NYXRjaCB9IGZyb20gJy4vZmluZFN1Z2dlc3Rpb25NYXRjaC5qcydcblxuZXhwb3J0IGludGVyZmFjZSBTdWdnZXN0aW9uT3B0aW9uczxJID0gYW55PiB7XG4gIHBsdWdpbktleT86IFBsdWdpbktleVxuICBlZGl0b3I6IEVkaXRvclxuICBjaGFyPzogc3RyaW5nXG4gIGFsbG93U3BhY2VzPzogYm9vbGVhblxuICBhbGxvd2VkUHJlZml4ZXM/OiBzdHJpbmdbXSB8IG51bGxcbiAgc3RhcnRPZkxpbmU/OiBib29sZWFuXG4gIGRlY29yYXRpb25UYWc/OiBzdHJpbmdcbiAgZGVjb3JhdGlvbkNsYXNzPzogc3RyaW5nXG4gIGNvbW1hbmQ/OiAocHJvcHM6IHsgZWRpdG9yOiBFZGl0b3I7IHJhbmdlOiBSYW5nZTsgcHJvcHM6IEkgfSkgPT4gdm9pZFxuICBpdGVtcz86IChwcm9wczogeyBxdWVyeTogc3RyaW5nOyBlZGl0b3I6IEVkaXRvciB9KSA9PiBJW10gfCBQcm9taXNlPElbXT5cbiAgcmVuZGVyPzogKCkgPT4ge1xuICAgIG9uQmVmb3JlU3RhcnQ/OiAocHJvcHM6IFN1Z2dlc3Rpb25Qcm9wczxJPikgPT4gdm9pZFxuICAgIG9uU3RhcnQ/OiAocHJvcHM6IFN1Z2dlc3Rpb25Qcm9wczxJPikgPT4gdm9pZFxuICAgIG9uQmVmb3JlVXBkYXRlPzogKHByb3BzOiBTdWdnZXN0aW9uUHJvcHM8ST4pID0+IHZvaWRcbiAgICBvblVwZGF0ZT86IChwcm9wczogU3VnZ2VzdGlvblByb3BzPEk+KSA9PiB2b2lkXG4gICAgb25FeGl0PzogKHByb3BzOiBTdWdnZXN0aW9uUHJvcHM8ST4pID0+IHZvaWRcbiAgICBvbktleURvd24/OiAocHJvcHM6IFN1Z2dlc3Rpb25LZXlEb3duUHJvcHMpID0+IGJvb2xlYW5cbiAgfVxuICBhbGxvdz86IChwcm9wczogeyBlZGl0b3I6IEVkaXRvcjsgc3RhdGU6IEVkaXRvclN0YXRlOyByYW5nZTogUmFuZ2UgfSkgPT4gYm9vbGVhblxuICBmaW5kU3VnZ2VzdGlvbk1hdGNoPzogdHlwZW9mIGRlZmF1bHRGaW5kU3VnZ2VzdGlvbk1hdGNoXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3VnZ2VzdGlvblByb3BzPEkgPSBhbnk+IHtcbiAgZWRpdG9yOiBFZGl0b3JcbiAgcmFuZ2U6IFJhbmdlXG4gIHF1ZXJ5OiBzdHJpbmdcbiAgdGV4dDogc3RyaW5nXG4gIGl0ZW1zOiBJW11cbiAgY29tbWFuZDogKHByb3BzOiBJKSA9PiB2b2lkXG4gIGRlY29yYXRpb25Ob2RlOiBFbGVtZW50IHwgbnVsbFxuICBjbGllbnRSZWN0PzogKCgpID0+IERPTVJlY3QgfCBudWxsKSB8IG51bGxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdWdnZXN0aW9uS2V5RG93blByb3BzIHtcbiAgdmlldzogRWRpdG9yVmlld1xuICBldmVudDogS2V5Ym9hcmRFdmVudFxuICByYW5nZTogUmFuZ2Vcbn1cblxuZXhwb3J0IGNvbnN0IFN1Z2dlc3Rpb25QbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5KCdzdWdnZXN0aW9uJylcblxuZXhwb3J0IGZ1bmN0aW9uIFN1Z2dlc3Rpb248SSA9IGFueT4oe1xuICBwbHVnaW5LZXkgPSBTdWdnZXN0aW9uUGx1Z2luS2V5LFxuICBlZGl0b3IsXG4gIGNoYXIgPSAnQCcsXG4gIGFsbG93U3BhY2VzID0gZmFsc2UsXG4gIGFsbG93ZWRQcmVmaXhlcyA9IFsnICddLFxuICBzdGFydE9mTGluZSA9IGZhbHNlLFxuICBkZWNvcmF0aW9uVGFnID0gJ3NwYW4nLFxuICBkZWNvcmF0aW9uQ2xhc3MgPSAnc3VnZ2VzdGlvbicsXG4gIGNvbW1hbmQgPSAoKSA9PiBudWxsLFxuICBpdGVtcyA9ICgpID0+IFtdLFxuICByZW5kZXIgPSAoKSA9PiAoe30pLFxuICBhbGxvdyA9ICgpID0+IHRydWUsXG4gIGZpbmRTdWdnZXN0aW9uTWF0Y2ggPSBkZWZhdWx0RmluZFN1Z2dlc3Rpb25NYXRjaCxcbn06IFN1Z2dlc3Rpb25PcHRpb25zPEk+KSB7XG4gIGxldCBwcm9wczogU3VnZ2VzdGlvblByb3BzPEk+IHwgdW5kZWZpbmVkXG4gIGNvbnN0IHJlbmRlcmVyID0gcmVuZGVyPy4oKVxuXG4gIGNvbnN0IHBsdWdpbjogUGx1Z2luPGFueT4gPSBuZXcgUGx1Z2luKHtcbiAgICBrZXk6IHBsdWdpbktleSxcblxuICAgIHZpZXcoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGU6IGFzeW5jICh2aWV3LCBwcmV2U3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5rZXk/LmdldFN0YXRlKHByZXZTdGF0ZSlcbiAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5rZXk/LmdldFN0YXRlKHZpZXcuc3RhdGUpXG5cbiAgICAgICAgICAvLyBTZWUgaG93IHRoZSBzdGF0ZSBjaGFuZ2VkXG4gICAgICAgICAgY29uc3QgbW92ZWQgPSBwcmV2LmFjdGl2ZSAmJiBuZXh0LmFjdGl2ZSAmJiBwcmV2LnJhbmdlLmZyb20gIT09IG5leHQucmFuZ2UuZnJvbVxuICAgICAgICAgIGNvbnN0IHN0YXJ0ZWQgPSAhcHJldi5hY3RpdmUgJiYgbmV4dC5hY3RpdmVcbiAgICAgICAgICBjb25zdCBzdG9wcGVkID0gcHJldi5hY3RpdmUgJiYgIW5leHQuYWN0aXZlXG4gICAgICAgICAgY29uc3QgY2hhbmdlZCA9ICFzdGFydGVkICYmICFzdG9wcGVkICYmIHByZXYucXVlcnkgIT09IG5leHQucXVlcnlcbiAgICAgICAgICBjb25zdCBoYW5kbGVTdGFydCA9IHN0YXJ0ZWQgfHwgbW92ZWRcbiAgICAgICAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSBjaGFuZ2VkICYmICFtb3ZlZFxuICAgICAgICAgIGNvbnN0IGhhbmRsZUV4aXQgPSBzdG9wcGVkIHx8IG1vdmVkXG5cbiAgICAgICAgICAvLyBDYW5jZWwgd2hlbiBzdWdnZXN0aW9uIGlzbid0IGFjdGl2ZVxuICAgICAgICAgIGlmICghaGFuZGxlU3RhcnQgJiYgIWhhbmRsZUNoYW5nZSAmJiAhaGFuZGxlRXhpdCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBoYW5kbGVFeGl0ICYmICFoYW5kbGVTdGFydCA/IHByZXYgOiBuZXh0XG4gICAgICAgICAgY29uc3QgZGVjb3JhdGlvbk5vZGUgPSB2aWV3LmRvbS5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgYFtkYXRhLWRlY29yYXRpb24taWQ9XCIke3N0YXRlLmRlY29yYXRpb25JZH1cIl1gLFxuICAgICAgICAgIClcblxuICAgICAgICAgIHByb3BzID0ge1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLnJhbmdlLFxuICAgICAgICAgICAgcXVlcnk6IHN0YXRlLnF1ZXJ5LFxuICAgICAgICAgICAgdGV4dDogc3RhdGUudGV4dCxcbiAgICAgICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgICAgIGNvbW1hbmQ6IGNvbW1hbmRQcm9wcyA9PiB7XG4gICAgICAgICAgICAgIGNvbW1hbmQoe1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICByYW5nZTogc3RhdGUucmFuZ2UsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGNvbW1hbmRQcm9wcyxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvcmF0aW9uTm9kZSxcbiAgICAgICAgICAgIC8vIHZpcnR1YWwgbm9kZSBmb3IgcG9wcGVyLmpzIG9yIHRpcHB5LmpzXG4gICAgICAgICAgICAvLyB0aGlzIGNhbiBiZSB1c2VkIGZvciBidWlsZGluZyBwb3B1cHMgd2l0aG91dCBhIERPTSBub2RlXG4gICAgICAgICAgICBjbGllbnRSZWN0OiBkZWNvcmF0aW9uTm9kZVxuICAgICAgICAgICAgICA/ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIG9mIGBpdGVtc2AgY2FuIGJlIGFzeW5jaHJvdW5vdXMgd2XigJlsbCBzZWFyY2ggZm9yIHRoZSBjdXJyZW50IGRlY29yYXRpb24gbm9kZVxuICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWNvcmF0aW9uSWQgfSA9IHRoaXMua2V5Py5nZXRTdGF0ZShlZGl0b3Iuc3RhdGUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RGVjb3JhdGlvbk5vZGUgPSB2aWV3LmRvbS5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICAgICAgYFtkYXRhLWRlY29yYXRpb24taWQ9XCIke2RlY29yYXRpb25JZH1cIl1gLFxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGVjb3JhdGlvbk5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHx8IG51bGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhbmRsZVN0YXJ0KSB7XG4gICAgICAgICAgICByZW5kZXJlcj8ub25CZWZvcmVTdGFydD8uKHByb3BzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYW5kbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyPy5vbkJlZm9yZVVwZGF0ZT8uKHByb3BzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYW5kbGVDaGFuZ2UgfHwgaGFuZGxlU3RhcnQpIHtcbiAgICAgICAgICAgIHByb3BzLml0ZW1zID0gYXdhaXQgaXRlbXMoe1xuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIHF1ZXJ5OiBzdGF0ZS5xdWVyeSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhbmRsZUV4aXQpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyPy5vbkV4aXQ/Lihwcm9wcylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFuZGxlQ2hhbmdlKSB7XG4gICAgICAgICAgICByZW5kZXJlcj8ub25VcGRhdGU/Lihwcm9wcylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFuZGxlU3RhcnQpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyPy5vblN0YXJ0Py4ocHJvcHMpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW5kZXJlcj8ub25FeGl0Py4ocHJvcHMpXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0YXRlOiB7XG4gICAgICAvLyBJbml0aWFsaXplIHRoZSBwbHVnaW4ncyBpbnRlcm5hbCBzdGF0ZS5cbiAgICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlOiB7XG4gICAgICAgICAgYWN0aXZlOiBib29sZWFuXG4gICAgICAgICAgcmFuZ2U6IFJhbmdlXG4gICAgICAgICAgcXVlcnk6IG51bGwgfCBzdHJpbmdcbiAgICAgICAgICB0ZXh0OiBudWxsIHwgc3RyaW5nXG4gICAgICAgICAgY29tcG9zaW5nOiBib29sZWFuXG4gICAgICAgICAgZGVjb3JhdGlvbklkPzogc3RyaW5nIHwgbnVsbFxuICAgICAgICB9ID0ge1xuICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgIGZyb206IDAsXG4gICAgICAgICAgICB0bzogMCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHF1ZXJ5OiBudWxsLFxuICAgICAgICAgIHRleHQ6IG51bGwsXG4gICAgICAgICAgY29tcG9zaW5nOiBmYWxzZSxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGF0ZVxuICAgICAgfSxcblxuICAgICAgLy8gQXBwbHkgY2hhbmdlcyB0byB0aGUgcGx1Z2luIHN0YXRlIGZyb20gYSB2aWV3IHRyYW5zYWN0aW9uLlxuICAgICAgYXBwbHkodHJhbnNhY3Rpb24sIHByZXYsIG9sZFN0YXRlLCBzdGF0ZSkge1xuICAgICAgICBjb25zdCB7IGlzRWRpdGFibGUgfSA9IGVkaXRvclxuICAgICAgICBjb25zdCB7IGNvbXBvc2luZyB9ID0gZWRpdG9yLnZpZXdcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyYW5zYWN0aW9uXG4gICAgICAgIGNvbnN0IHsgZW1wdHksIGZyb20gfSA9IHNlbGVjdGlvblxuICAgICAgICBjb25zdCBuZXh0ID0geyAuLi5wcmV2IH1cblxuICAgICAgICBuZXh0LmNvbXBvc2luZyA9IGNvbXBvc2luZ1xuXG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IGJlIHN1Z2dlc3RpbmcgaWYgdGhlIHZpZXcgaXMgZWRpdGFibGUsIGFuZDpcbiAgICAgICAgLy8gICAqIHRoZXJlIGlzIG5vIHNlbGVjdGlvbiwgb3JcbiAgICAgICAgLy8gICAqIGEgY29tcG9zaXRpb24gaXMgYWN0aXZlIChzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMTQ0OSlcbiAgICAgICAgaWYgKGlzRWRpdGFibGUgJiYgKGVtcHR5IHx8IGVkaXRvci52aWV3LmNvbXBvc2luZykpIHtcbiAgICAgICAgICAvLyBSZXNldCBhY3RpdmUgc3RhdGUgaWYgd2UganVzdCBsZWZ0IHRoZSBwcmV2aW91cyBzdWdnZXN0aW9uIHJhbmdlXG4gICAgICAgICAgaWYgKChmcm9tIDwgcHJldi5yYW5nZS5mcm9tIHx8IGZyb20gPiBwcmV2LnJhbmdlLnRvKSAmJiAhY29tcG9zaW5nICYmICFwcmV2LmNvbXBvc2luZykge1xuICAgICAgICAgICAgbmV4dC5hY3RpdmUgPSBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCBhZ2FpbnN0IHdoZXJlIG91ciBjdXJzb3IgY3VycmVudGx5IGlzXG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBmaW5kU3VnZ2VzdGlvbk1hdGNoKHtcbiAgICAgICAgICAgIGNoYXIsXG4gICAgICAgICAgICBhbGxvd1NwYWNlcyxcbiAgICAgICAgICAgIGFsbG93ZWRQcmVmaXhlcyxcbiAgICAgICAgICAgIHN0YXJ0T2ZMaW5lLFxuICAgICAgICAgICAgJHBvc2l0aW9uOiBzZWxlY3Rpb24uJGZyb20sXG4gICAgICAgICAgfSlcbiAgICAgICAgICBjb25zdCBkZWNvcmF0aW9uSWQgPSBgaWRfJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmKX1gXG5cbiAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIG1hdGNoLCB1cGRhdGUgdGhlIGN1cnJlbnQgc3RhdGUgdG8gc2hvdyBpdFxuICAgICAgICAgIGlmIChtYXRjaCAmJiBhbGxvdyh7IGVkaXRvciwgc3RhdGUsIHJhbmdlOiBtYXRjaC5yYW5nZSB9KSkge1xuICAgICAgICAgICAgbmV4dC5hY3RpdmUgPSB0cnVlXG4gICAgICAgICAgICBuZXh0LmRlY29yYXRpb25JZCA9IHByZXYuZGVjb3JhdGlvbklkID8gcHJldi5kZWNvcmF0aW9uSWQgOiBkZWNvcmF0aW9uSWRcbiAgICAgICAgICAgIG5leHQucmFuZ2UgPSBtYXRjaC5yYW5nZVxuICAgICAgICAgICAgbmV4dC5xdWVyeSA9IG1hdGNoLnF1ZXJ5XG4gICAgICAgICAgICBuZXh0LnRleHQgPSBtYXRjaC50ZXh0XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHQuYWN0aXZlID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dC5hY3RpdmUgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRvIGVtcHR5IHRoZSByYW5nZSBpZiBzdWdnZXN0aW9uIGlzIGluYWN0aXZlXG4gICAgICAgIGlmICghbmV4dC5hY3RpdmUpIHtcbiAgICAgICAgICBuZXh0LmRlY29yYXRpb25JZCA9IG51bGxcbiAgICAgICAgICBuZXh0LnJhbmdlID0geyBmcm9tOiAwLCB0bzogMCB9XG4gICAgICAgICAgbmV4dC5xdWVyeSA9IG51bGxcbiAgICAgICAgICBuZXh0LnRleHQgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dFxuICAgICAgfSxcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcbiAgICAgIC8vIENhbGwgdGhlIGtleWRvd24gaG9vayBpZiBzdWdnZXN0aW9uIGlzIGFjdGl2ZS5cbiAgICAgIGhhbmRsZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBhY3RpdmUsIHJhbmdlIH0gPSBwbHVnaW4uZ2V0U3RhdGUodmlldy5zdGF0ZSlcblxuICAgICAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyPy5vbktleURvd24/Lih7IHZpZXcsIGV2ZW50LCByYW5nZSB9KSB8fCBmYWxzZVxuICAgICAgfSxcblxuICAgICAgLy8gU2V0dXAgZGVjb3JhdG9yIG9uIHRoZSBjdXJyZW50bHkgYWN0aXZlIHN1Z2dlc3Rpb24uXG4gICAgICBkZWNvcmF0aW9ucyhzdGF0ZSkge1xuICAgICAgICBjb25zdCB7IGFjdGl2ZSwgcmFuZ2UsIGRlY29yYXRpb25JZCB9ID0gcGx1Z2luLmdldFN0YXRlKHN0YXRlKVxuXG4gICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtcbiAgICAgICAgICBEZWNvcmF0aW9uLmlubGluZShyYW5nZS5mcm9tLCByYW5nZS50bywge1xuICAgICAgICAgICAgbm9kZU5hbWU6IGRlY29yYXRpb25UYWcsXG4gICAgICAgICAgICBjbGFzczogZGVjb3JhdGlvbkNsYXNzLFxuICAgICAgICAgICAgJ2RhdGEtZGVjb3JhdGlvbi1pZCc6IGRlY29yYXRpb25JZCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgXSlcbiAgICAgIH0sXG4gICAgfSxcbiAgfSlcblxuICByZXR1cm4gcGx1Z2luXG59XG4iLCAiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBwb3VuY2UsIGNvbW1hbmRSdW5uZXIgfSBmcm9tICcuLi91dGlscy5qcydcbiAgICBpbXBvcnQgeyBnZXRTdGF0ZVBhdGggfSBmcm9tICcuLi9zdG9yZXMuanMnXG5cbiAgICBleHBvcnQgbGV0IGl0ZW1zXG4gICAgZXhwb3J0IGxldCBlZGl0b3JcbiAgICBleHBvcnQgbGV0IHJhbmdlXG5cbiAgICBsZXQgc2VsZWN0ZWRJbmRleCA9IDBcbiAgICBsZXQgZHJvcGRvd25cbiAgICBsZXQgZ3JvdXBzXG5cbiAgICBjb25zdCBnZXRHcm91cHMgPSBhcnJheSA9PiB7XG4gICAgICAgIGxldCBtYXAgPSBhcnJheS5tYXAoKGUsIGkpID0+IHtcbiAgICAgICAgICAgIGUuaW5kZXggPSBpXG4gICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICB9KVxuXG4gICAgICAgIGdyb3VwcyA9IG1hcC5yZWR1Y2UoZnVuY3Rpb24ociwgYSkge1xuICAgICAgICAgICAgclthLmdyb3VwXSA9IHJbYS5ncm91cF0gfHwgW11cbiAgICAgICAgICAgIHJbYS5ncm91cF0ucHVzaChhKVxuICAgICAgICAgICAgcmV0dXJuIHJcbiAgICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSlcbiAgICB9XG5cbiAgICAkOiBnZXRHcm91cHMoaXRlbXMpXG5cbiAgICBleHBvcnQgY29uc3QgcmVzZXRJbmRleCA9ICgpID0+IHNlbGVjdGVkSW5kZXggPSAwXG5cbiAgICBleHBvcnQgY29uc3Qgb25LZXlEb3duID0gKHsgZXZlbnQgfSkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnQXJyb3dVcCcpIHtcbiAgICAgICAgICAgIHVwSGFuZGxlcigpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0Fycm93RG93bicpIHtcbiAgICAgICAgICAgIGRvd25IYW5kbGVyKClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICBlbnRlckhhbmRsZXIoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IHVwSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgc2VsZWN0ZWRJbmRleCA9ICgoc2VsZWN0ZWRJbmRleCArIGl0ZW1zLmxlbmd0aCkgLSAxKSAlIGl0ZW1zLmxlbmd0aFxuICAgICAgICBzY3JvbGxUb1NlbGVjdCgpXG4gICAgfVxuXG4gICAgY29uc3QgZG93bkhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHNlbGVjdGVkSW5kZXggPSAoc2VsZWN0ZWRJbmRleCArIDEpICUgaXRlbXMubGVuZ3RoXG4gICAgICAgIHNjcm9sbFRvU2VsZWN0KClcbiAgICB9XG5cbiAgICBjb25zdCBlbnRlckhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHNlbGVjdEl0ZW0oc2VsZWN0ZWRJbmRleClcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3RJdGVtID0gaW5kZXggPT4ge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaW5kZXhdXG5cbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGVkaXRvci5jb21tYW5kcy5kZWxldGVSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1hbmQnOlxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kUnVubmVyKGVkaXRvciwgaXRlbS5jb21tYW5kcylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlICdtb2RhbCc6XG4gICAgICAgICAgICAgICAgICAgIHBvdW5jZShpdGVtLmlkZW50aWZpZXIsIHsgc3RhdGVQYXRoOiAkZ2V0U3RhdGVQYXRoLCAuLi5lZGl0b3IuZ2V0QXR0cmlidXRlcyhpdGVtLmV4dGVuc2lvbikgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhdGljJzpcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmNoYWluKCkuaW5zZXJ0U2NyaWJibGVCbG9jayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBpdGVtLmlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBpdGVtLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0pLmZvY3VzKCkucnVuKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmNvbW1hbmRzLnNldFNjcmliYmxlQmxvY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaXRlbS5pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXRoOiBpdGVtLnN0YXRlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbFRvU2VsZWN0ID0gKCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3IoJy5hY3RpdmUtb3B0aW9uJykuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJyxcbiAgICAgICAgICAgICAgICBibG9jazogJ25lYXJlc3QnLFxuICAgICAgICAgICAgICAgIGlubGluZTogJ2VuZCcsXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCAwKVxuICAgIH1cbjwvc2NyaXB0PlxuXG48ZGl2XG4gICAgY2xhc3M9XCJzY3JpYmJsZS1zdWdnZXN0aW9uc1wiXG4gICAgYmluZDp0aGlzPXtkcm9wZG93bn1cbj5cbiAgICA8ZGl2IGNsYXNzPVwiZ3JvdXBcIj5cbiAgICAgICAgeyNpZiBpdGVtcy5sZW5ndGh9XG4gICAgICAgICAgICB7I2VhY2ggT2JqZWN0LmtleXMoZ3JvdXBzKSBhcyBncm91cH1cbiAgICAgICAgICAgICAgICB7I2lmIGdyb3VwIH1cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImdyb3VwLXRpdGxlXCI+e2dyb3VwfTwvZGl2PlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgeyNlYWNoIGdyb3Vwc1tncm91cF0gYXMgaXRlbX1cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2s9eygpID0+IHNlbGVjdEl0ZW0oaXRlbS5pbmRleCl9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cIiB7IGl0ZW0uaW5kZXggPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4ID8gJ2FjdGl2ZS1vcHRpb24nIDogJycgfVwiXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAaHRtbCBpdGVtLmljb259XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRleHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImxhYmVsXCI+e2l0ZW0ubGFiZWx9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgaXRlbS5kZXNjcmlwdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImRlc2NyaXB0aW9uXCI+e2l0ZW0uZGVzY3JpcHRpb259PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgey9pZn1cblxuICAgICAgICB7I2lmICFpdGVtcy5sZW5ndGh9XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibm8tYmxvY2tzXCI+Tm8gYmxvY2tzIGZvdW5kPC9kaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgPC9kaXY+XG48L2Rpdj5cbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgU3VnZ2VzdGlvbiBmcm9tICdAdGlwdGFwL3N1Z2dlc3Rpb24nXG5pbXBvcnQgQ29tbWFuZHNMaXN0IGZyb20gJy4uL2NvbXBvbmVudHMvQ29tbWFuZHNMaXN0LnN2ZWx0ZSdcbmltcG9ydCB0aXBweSBmcm9tICd0aXBweS5qcydcbmltcG9ydCB7IFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBkZWZhdWx0IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdzbGFzaEV4dGVuc2lvbicsXG5cbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmxvY2tzOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFN1Z2dlc3Rpb24oe1xuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgY2hhcjogJy8nLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICh7IGVkaXRvciwgcmFuZ2UsIHByb3BzIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuY29tbWFuZCh7IGVkaXRvciwgcmFuZ2UgfSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0YXJ0T2ZMaW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBsdWdpbktleTogbmV3IFBsdWdpbktleSgnc2xhc2hFeHRlbnNpb24nKSxcbiAgICAgICAgICAgICAgICBpdGVtczogKHsgcXVlcnkgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRvb2xzLmZpbHRlcihpdGVtID0+IGl0ZW0ubGFiZWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbmRlcjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3B1cFxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblN0YXJ0OiBwcm9wcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wcy5jbGllbnRSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gbmV3IENvbW1hbmRzTGlzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBwcm9wcy5pdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogcHJvcHMuZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHByb3BzLnJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVwID0gdGlwcHkoJ2JvZHknLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IHByb3BzLmNsaWVudFJlY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZFRvOiAoKSA9PiBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb21wb25lbnQuJCQucm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd09uQ3JlYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogJ21hbnVhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbS1zdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lOiAnc2NyaWJibGUtcGFuZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpJbmRleDogNDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvblVwZGF0ZShwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC4kc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHByb3BzLml0ZW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IHByb3BzLmVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHByb3BzLnJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQucmVzZXRJbmRleCgpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BzLmNsaWVudFJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wdXBbMF0uc2V0UHJvcHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBwcm9wcy5jbGllbnRSZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbktleURvd24ocHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMuZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3B1cFswXS5oaWRlKClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQub25LZXlEb3duKHByb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXhpdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3B1cFswXS5kZXN0cm95KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuJGRlc3Ryb3koKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgIF1cbiAgICB9XG59KVxuIiwgImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBTdWJzY3JpcHRFeHRlbnNpb25PcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IE9iamVjdCxcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHN1YnNjcmlwdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBzdWJzY3JpcHQgbWFya1xuICAgICAgICovXG4gICAgICBzZXRTdWJzY3JpcHQ6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIHN1YnNjcmlwdCBtYXJrXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZVN1YnNjcmlwdDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zZXQgYSBzdWJzY3JpcHQgbWFya1xuICAgICAgICovXG4gICAgICB1bnNldFN1YnNjcmlwdDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFN1YnNjcmlwdCA9IE1hcmsuY3JlYXRlPFN1YnNjcmlwdEV4dGVuc2lvbk9wdGlvbnM+KHtcbiAgbmFtZTogJ3N1YnNjcmlwdCcsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnc3ViJyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiAndmVydGljYWwtYWxpZ24nLFxuICAgICAgICBnZXRBdHRycyh2YWx1ZSkge1xuICAgICAgICAgIC8vIERvbuKAmXQgbWF0Y2ggdGhpcyBydWxlIGlmIHRoZSB2ZXJ0aWNhbCBhbGlnbiBpc27igJl0IHN1Yi5cbiAgICAgICAgICBpZiAodmFsdWUgIT09ICdzdWInKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBpdCBmYWxscyB0aHJvdWdoIHdl4oCZbGwgbWF0Y2gsIGFuZCB0aGlzIG1hcmsgd2lsbCBiZSBhcHBsaWVkLlxuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ3N1YicsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0U3Vic2NyaXB0OiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB0b2dnbGVTdWJzY3JpcHQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHVuc2V0U3Vic2NyaXB0OiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtLCc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVN1YnNjcmlwdCgpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgTWFyaywgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFN1cGVyc2NyaXB0RXh0ZW5zaW9uT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBPYmplY3QsXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzdXBlcnNjcmlwdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBzdXBlcnNjcmlwdCBtYXJrXG4gICAgICAgKi9cbiAgICAgIHNldFN1cGVyc2NyaXB0OiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBzdXBlcnNjcmlwdCBtYXJrXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZVN1cGVyc2NyaXB0OiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBVbnNldCBhIHN1cGVyc2NyaXB0IG1hcmtcbiAgICAgICAqL1xuICAgICAgdW5zZXRTdXBlcnNjcmlwdDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFN1cGVyc2NyaXB0ID0gTWFyay5jcmVhdGU8U3VwZXJzY3JpcHRFeHRlbnNpb25PcHRpb25zPih7XG4gIG5hbWU6ICdzdXBlcnNjcmlwdCcsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnc3VwJyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiAndmVydGljYWwtYWxpZ24nLFxuICAgICAgICBnZXRBdHRycyh2YWx1ZSkge1xuICAgICAgICAgIC8vIERvbuKAmXQgbWF0Y2ggdGhpcyBydWxlIGlmIHRoZSB2ZXJ0aWNhbCBhbGlnbiBpc27igJl0IHN1cGVyLlxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJ3N1cGVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgaXQgZmFsbHMgdGhyb3VnaCB3ZeKAmWxsIG1hdGNoLCBhbmQgdGhpcyBtYXJrIHdpbGwgYmUgYXBwbGllZC5cbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydzdXAnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFN1cGVyc2NyaXB0OiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB0b2dnbGVTdXBlcnNjcmlwdDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdW5zZXRTdXBlcnNjcmlwdDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLS4nOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVTdXBlcnNjcmlwdCgpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgZGVmYXVsdCBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAndGV4dEFsaWduJyxcblxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlczogW10sXG4gICAgICAgICAgICBhbGlnbm1lbnRzOiBbJ3N0YXJ0JywgJ2NlbnRlcicsICdlbmQnLCAnanVzdGlmeSddLFxuICAgICAgICAgICAgZGVmYXVsdEFsaWdubWVudDogJ3N0YXJ0JyxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRHbG9iYWxBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGVzOiB0aGlzLm9wdGlvbnMudHlwZXMsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5kZWZhdWx0QWxpZ25tZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IGVsZW1lbnQuc3R5bGUudGV4dEFsaWduIHx8IHRoaXMub3B0aW9ucy5kZWZhdWx0QWxpZ25tZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVySFRNTDogYXR0cmlidXRlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMudGV4dEFsaWduID09PSB0aGlzLm9wdGlvbnMuZGVmYXVsdEFsaWdubWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdHlsZTogYHRleHQtYWxpZ246ICR7YXR0cmlidXRlcy50ZXh0QWxpZ259YCB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdXG4gICAgfSxcblxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0VGV4dEFsaWduOiAoYWxpZ25tZW50KSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxpZ25tZW50cy5pbmNsdWRlcyhhbGlnbm1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZXMuZXZlcnkodHlwZSA9PiBjb21tYW5kcy51cGRhdGVBdHRyaWJ1dGVzKHR5cGUsIHsgdGV4dEFsaWduOiBhbGlnbm1lbnQgfSkpXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB1bnNldFRleHRBbGlnbjogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZXMuZXZlcnkodHlwZSA9PiBjb21tYW5kcy5yZXNldEF0dHJpYnV0ZXModHlwZSwgJ3RleHRBbGlnbicpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtU2hpZnQtbCc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFRleHRBbGlnbignc3RhcnQnKSxcbiAgICAgICAgICAgICdNb2QtU2hpZnQtZSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFRleHRBbGlnbignY2VudGVyJyksXG4gICAgICAgICAgICAnTW9kLVNoaWZ0LXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRUZXh0QWxpZ24oJ2VuZCcpLFxuICAgICAgICAgICAgJ01vZC1TaGlmdC1qJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0VGV4dEFsaWduKCdqdXN0aWZ5JyksXG4gICAgICAgIH1cbiAgICB9LFxufSlcbiIsICJpbXBvcnQge1xuICBnZXRNYXJrQXR0cmlidXRlcyxcbiAgTWFyayxcbiAgbWVyZ2VBdHRyaWJ1dGVzLFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dFN0eWxlT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdGV4dFN0eWxlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBzcGFucyB3aXRob3V0IGlubGluZSBzdHlsZSBhdHRyaWJ1dGVzLlxuICAgICAgICovXG4gICAgICByZW1vdmVFbXB0eVRleHRTdHlsZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFRleHRTdHlsZSA9IE1hcmsuY3JlYXRlPFRleHRTdHlsZU9wdGlvbnM+KHtcbiAgbmFtZTogJ3RleHRTdHlsZScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnc3BhbicsXG4gICAgICAgIGdldEF0dHJzOiBlbGVtZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBoYXNTdHlsZXMgPSAoZWxlbWVudCBhcyBIVE1MRWxlbWVudCkuaGFzQXR0cmlidXRlKCdzdHlsZScpXG5cbiAgICAgICAgICBpZiAoIWhhc1N0eWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHt9XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ3NwYW4nLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbW92ZUVtcHR5VGV4dFN0eWxlOiAoKSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHRoaXMudHlwZSlcbiAgICAgICAgY29uc3QgaGFzU3R5bGVzID0gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuc29tZSgoWywgdmFsdWVdKSA9PiAhIXZhbHVlKVxuXG4gICAgICAgIGlmIChoYXNTdHlsZXMpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxufSlcbiIsICJpbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVW5kZXJsaW5lT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdW5kZXJsaW5lOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhbiB1bmRlcmxpbmUgbWFya1xuICAgICAgICovXG4gICAgICBzZXRVbmRlcmxpbmU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhbiB1bmRlcmxpbmUgbWFya1xuICAgICAgICovXG4gICAgICB0b2dnbGVVbmRlcmxpbmU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGFuIHVuZGVybGluZSBtYXJrXG4gICAgICAgKi9cbiAgICAgIHVuc2V0VW5kZXJsaW5lOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgVW5kZXJsaW5lID0gTWFyay5jcmVhdGU8VW5kZXJsaW5lT3B0aW9ucz4oe1xuICBuYW1lOiAndW5kZXJsaW5lJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICd1JyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiAndGV4dC1kZWNvcmF0aW9uJyxcbiAgICAgICAgY29uc3VtaW5nOiBmYWxzZSxcbiAgICAgICAgZ2V0QXR0cnM6IHN0eWxlID0+ICgoc3R5bGUgYXMgc3RyaW5nKS5pbmNsdWRlcygndW5kZXJsaW5lJykgPyB7fSA6IGZhbHNlKSxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsndScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0VW5kZXJsaW5lOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB0b2dnbGVVbmRlcmxpbmU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHVuc2V0VW5kZXJsaW5lOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtdSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVVuZGVybGluZSgpLFxuICAgICAgJ01vZC1VJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlVW5kZXJsaW5lKCksXG4gICAgfVxuICB9LFxufSlcbiIsICJmdW5jdGlvbiByKGUpe3ZhciB0LGYsbj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZSluKz1lO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSl7dmFyIG89ZS5sZW5ndGg7Zm9yKHQ9MDt0PG87dCsrKWVbdF0mJihmPXIoZVt0XSkpJiYobiYmKG4rPVwiIFwiKSxuKz1mKX1lbHNlIGZvcihmIGluIGUpZVtmXSYmKG4mJihuKz1cIiBcIiksbis9Zik7cmV0dXJuIG59ZXhwb3J0IGZ1bmN0aW9uIGNsc3goKXtmb3IodmFyIGUsdCxmPTAsbj1cIlwiLG89YXJndW1lbnRzLmxlbmd0aDtmPG87ZisrKShlPWFyZ3VtZW50c1tmXSkmJih0PXIoZSkpJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZGVmYXVsdCBjbHN4OyIsICI8c2NyaXB0PlxuICAgIGltcG9ydCBjeCBmcm9tICdjbHN4J1xuXG4gICAgZXhwb3J0IGxldCBlZGl0b3JcbiAgICBleHBvcnQgbGV0IGtleVxuICAgIGV4cG9ydCBsZXQgYWN0aXZlID0gZmFsc2VcbiAgICBleHBvcnQgbGV0IGhpZGRlbjtcbjwvc2NyaXB0PlxuXG57I2lmIGVkaXRvciAmJiAhaGlkZGVufVxuPGJ1dHRvblxuICAgIHR5cGU9XCJidXR0b25cIlxuICAgIGNsYXNzOmFjdGl2ZT17YWN0aXZlfVxuICAgIG9uOmNsaWNrXG4gICAgY2xhc3M9e2N4KFxuICAgICAgICBgc2NyaWJibGUtYnV0dG9uICR7a2V5fWAsXG4gICAgICAgIHtcbiAgICAgICAgICAgICdhY3RpdmUnOiBhY3RpdmVcbiAgICAgICAgfVxuICAgICl9XG4+XG4gICAgPHNsb3QgLz5cbjwvYnV0dG9uPlxuey9pZn1cbiIsICI8c2NyaXB0PlxuICAgIGltcG9ydCBCdXR0b24gZnJvbSAnLi9CdXR0b24uc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGdldFN0YXRlUGF0aCB9IGZyb20gJy4uL3N0b3Jlcy5qcydcblxuICAgIGV4cG9ydCBsZXQgZWRpdG9yXG5cbiAgICBjb25zdCB0b2dnbGVGdWxsc2NyZWVuID0gKCkgPT4ge1xuICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3RvZ2dsZS1mdWxsc2NyZWVuJywgeyBkZXRhaWw6IHsgc3RhdGVQYXRoOiAkZ2V0U3RhdGVQYXRoIH0gfSkpXG4gICAgICAgIGVkaXRvci5jb21tYW5kcy5mb2N1cygpXG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgZWRpdG9yfVxuPGRpdiBjbGFzcz1cInNjcmliYmxlLWNvbnRyb2xzXCI+XG4gICAgPGRpdiBjbGFzcz1cInNjcmliYmxlLWNvbnRyb2xzLXBhbmVsXCI+XG4gICAgICAgIDxCdXR0b24ge2VkaXRvcn0ga2V5PVwidW5kb1wiIG9uOmNsaWNrPXsoKSA9PiBlZGl0b3IuY2hhaW4oKS5mb2N1cygpLnVuZG8oKS5ydW4oKX0+XG4gICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDUxMiA1MTJcIj5cbiAgICAgICAgICAgICAgICA8cGF0aCBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMzJcIiBkPVwiTTI0MCA0MjR2LTk2YzExNi40IDAgMTU5LjM5IDMzLjc2IDIwOCA5NmMwLTExOS4yMy0zOS41Ny0yNDAtMjA4LTI0MFY4OEw2NCAyNTZaXCIvPlxuICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgICA8QnV0dG9uIHtlZGl0b3J9IGtleT1cInJlZG9cIiBvbjpjbGljaz17KCkgPT4gZWRpdG9yLmNoYWluKCkuZm9jdXMoKS5yZWRvKCkucnVuKCl9PlxuICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCA1MTIgNTEyXCI+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjMyXCIgZD1cIk00NDggMjU2TDI3MiA4OHY5NkMxMDMuNTcgMTg0IDY0IDMwNC43NyA2NCA0MjRjNDguNjEtNjIuMjQgOTEuNi05NiAyMDgtOTZ2OTZaXCIvPlxuICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgICA8QnV0dG9uIHtlZGl0b3J9IGtleT1cImNsZWFyXCIgb246Y2xpY2s9eygpID0+IGVkaXRvci5jaGFpbigpLmZvY3VzKCkuY2xlYXJDb250ZW50KHRydWUpLnJ1bigpfT5cbiAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+XG4gICAgICAgICAgICAgICAgPHBhdGggZD1cIk0xMy45OTk5IDE4Ljk5NjdIMjAuOTk5OVYyMC45OTY3SDExLjk5OTlMOC4wMDIyOSAyMC45OTkyTDEuNTE0NTcgMTQuNTExNUMxLjEyNDA1IDE0LjEyMDkgMS4xMjQwNSAxMy40ODc4IDEuNTE0NTcgMTMuMDk3MkwxMi4xMjEyIDIuNDkwNjVDMTIuNTExNyAyLjEwMDEyIDEzLjE0NDkgMi4xMDAxMiAxMy41MzU0IDIuNDkwNjVMMjEuMzEzNiAxMC4yNjg4QzIxLjcwNDEgMTAuNjU5MyAyMS43MDQxIDExLjI5MjUgMjEuMzEzNiAxMS42ODNMMTMuOTk5OSAxOC45OTY3Wk0xNS42NTY3IDE0LjUxMTVMMTkuMTkyMiAxMC45NzU5TDEyLjgyODMgNC42MTE5N0w5LjI5Mjc1IDguMTQ3NUwxNS42NTY3IDE0LjUxMTVaXCIvPlxuICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgICA8QnV0dG9uIHtlZGl0b3J9IGtleT1cImVudGVyLWZ1bGxzY3JlZW5cIiBvbjpjbGljaz17dG9nZ2xlRnVsbHNjcmVlbn0+XG4gICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiPlxuICAgICAgICAgICAgICAgIDxwYXRoIGZpbGw9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIi8+PHBhdGggZD1cIk0yMCAzaDJ2NmgtMlY1aC00VjNoNHpNNCAzaDR2Mkg0djRIMlYzaDJ6bTE2IDE2di00aDJ2NmgtNnYtMmg0ek00IDE5aDR2Mkgydi02aDJ2NHpcIi8+XG4gICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgPC9CdXR0b24+XG4gICAgICAgIDxCdXR0b24ge2VkaXRvcn0ga2V5PVwiZXhpdC1mdWxsc2NyZWVuXCIgb246Y2xpY2s9e3RvZ2dsZUZ1bGxzY3JlZW59PlxuICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIj5cbiAgICAgICAgICAgICAgICA8cGF0aCBmaWxsPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIvPjxwYXRoIGQ9XCJNMTggN2g0djJoLTZWM2gydjR6TTggOUgyVjdoNFYzaDJ2NnptMTAgOHY0aC0ydi02aDZ2MmgtNHpNOCAxNXY2SDZ2LTRIMnYtMmg2elwiLz5cbiAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L0J1dHRvbj5cbiAgICA8L2Rpdj5cbjwvZGl2Plxuey9pZn1cbiIsICI8c2NyaXB0PlxuICAgIGltcG9ydCBCdXR0b24gZnJvbSAnLi9CdXR0b24uc3ZlbHRlJ1xuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tICdzdmVsdGUnXG5cbiAgICBleHBvcnQgbGV0IGVkaXRvclxuICAgIGV4cG9ydCBsZXQgaXNBY3RpdmVcbiAgICBleHBvcnQgbGV0IHRvb2xzXG4gICAgZXhwb3J0IGxldCBoYW5kbGVUb29sQ2xpY2tcblxuICAgIGxldCBncm91cHMgPSB7fVxuXG4gICAgY29uc3QgZ2V0R3JvdXBzID0gYXJyYXkgPT4ge1xuICAgICAgICBsZXQgbWFwID0gYXJyYXkubWFwKChlLCBpKSA9PiB7XG4gICAgICAgICAgICBlLmluZGV4ID0gaVxuICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgfSlcblxuICAgICAgICBncm91cHMgPSBtYXAucmVkdWNlKGZ1bmN0aW9uKHIsIGEpIHtcbiAgICAgICAgICAgIHJbYS5ncm91cF0gPSByW2EuZ3JvdXBdIHx8IFtdXG4gICAgICAgICAgICByW2EuZ3JvdXBdLnB1c2goYSlcbiAgICAgICAgICAgIHJldHVybiByXG4gICAgICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpXG4gICAgfVxuXG4gICAgJDogZ2V0R3JvdXBzKHRvb2xzKVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIHRvb2xzID0gdG9vbHMuZmlsdGVyKHRvb2wgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICEgdG9vbC5pc0hpZGRlblxuICAgICAgICB9KVxuICAgIH0pXG48L3NjcmlwdD5cblxueyNpZiBlZGl0b3J9XG4gICAgPGRpdiBjbGFzcz1cInNjcmliYmxlLWJ1YmJsZS1tZW51XCI+XG4gICAgICAgIHsjaWYgIWlzQWN0aXZlKCdsaW5rJyl9XG4gICAgICAgICAgICB7I2lmIHRvb2xzLmxlbmd0aH1cbiAgICAgICAgICAgICAgICB7I2VhY2ggT2JqZWN0LmtleXMoZ3JvdXBzKSBhcyBncm91cH1cbiAgICAgICAgICAgICAgICAgICAgeyNpZiBncm91cCAhPT0gJyd9XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJidWJibGUtZ3JvdXBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjZWFjaCBncm91cHNbZ3JvdXBdIGFzIHRvb2x9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24ge2VkaXRvcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17dG9vbC5leHRlbnNpb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU9e2lzQWN0aXZlKHRvb2wuZXh0ZW5zaW9uLCB0b29sLmFjdGl2ZUF0dHJpYnV0ZXMpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2s9eygpID0+IGhhbmRsZVRvb2xDbGljayh0b29sKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbj17dG9vbC5pc0hpZGRlbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BodG1sIHRvb2wuaWNvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHsjZWFjaCBncm91cHNbZ3JvdXBdIGFzIHRvb2x9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiB7ZWRpdG9yfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e3Rvb2wuZXh0ZW5zaW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU9e2lzQWN0aXZlKHRvb2wuZXh0ZW5zaW9uLCB0b29sLmFjdGl2ZUF0dHJpYnV0ZXMpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjbGljaz17KCkgPT4gaGFuZGxlVG9vbENsaWNrKHRvb2wpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW49e3Rvb2wuaXNIaWRkZW59XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGh0bWwgdG9vbC5pY29ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIHs6ZWxzZSBpZiBpc0FjdGl2ZSgnbGluaycpfVxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJsaW5rLXByZXZpZXdcIj57ZWRpdG9yLmdldEF0dHJpYnV0ZXMoJ2xpbmsnKS5ocmVmfTwvc3Bhbj5cbiAgICAgICAgICAgIDxCdXR0b24ge2VkaXRvcn0ga2V5PVwiZWRpdExpbmtcIiBvbjpjbGljaz17KCkgPT4gaGFuZGxlVG9vbENsaWNrKHRvb2xzLmZpbmQoKGl0ZW0pID0+IGl0ZW0uZXh0ZW5zaW9uID09PSAnbGluaycpLCB0cnVlKX0+XG4gICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIj5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cIk0xOC4zNjQzIDE1LjUzNTNMMTYuOTUgMTQuMTIxMUwxOC4zNjQzIDEyLjcwNjlDMjAuMzE2OSAxMC43NTQzIDIwLjMxNjkgNy41ODg0NyAxOC4zNjQzIDUuNjM1ODVDMTYuNDExNiAzLjY4MzIzIDEzLjI0NTggMy42ODMyMyAxMS4yOTMyIDUuNjM1ODVMOS44Nzg5OCA3LjA1MDA3TDguNDY0NzcgNS42MzU4NUw5Ljg3ODk4IDQuMjIxNjRDMTIuNjEyNyAxLjQ4Nzk3IDE3LjA0NDggMS40ODc5NyAxOS43Nzg1IDQuMjIxNjRDMjIuNTEyMSA2Ljk1NTMxIDIyLjUxMjEgMTEuMzg3NSAxOS43Nzg1IDE0LjEyMTFMMTguMzY0MyAxNS41MzUzWk0xNS41MzU4IDE4LjM2MzhMMTQuMTIxNiAxOS43NzhDMTEuMzg4IDIyLjUxMTcgNi45NTU4IDIyLjUxMTcgNC4yMjIxMyAxOS43NzhDMS40ODg0NiAxNy4wNDQzIDEuNDg4NDYgMTIuNjEyMiA0LjIyMjEzIDkuODc4NDlMNS42MzYzNCA4LjQ2NDI4TDcuMDUwNTUgOS44Nzg0OUw1LjYzNjM0IDExLjI5MjdDMy42ODM3MiAxMy4yNDUzIDMuNjgzNzIgMTYuNDExMiA1LjYzNjM0IDE4LjM2MzhDNy41ODg5NiAyMC4zMTY0IDEwLjc1NDggMjAuMzE2NCAxMi43MDc0IDE4LjM2MzhMMTQuMTIxNiAxNi45NDk2TDE1LjUzNTggMTguMzYzOFpNMTQuODI4NyA3Ljc1NzE3TDE2LjI0MjkgOS4xNzEzOUw5LjE3MTg3IDE2LjI0MjVMNy43NTc2NiAxNC44MjgyTDE0LjgyODcgNy43NTcxN1pcIi8+XG4gICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgIDxCdXR0b24ge2VkaXRvcn0ga2V5PVwidW5zZXRMaW5rXCIgb246Y2xpY2s9eygpID0+IGVkaXRvci5jaGFpbigpLmZvY3VzKCkuZXh0ZW5kTWFya1JhbmdlKCdsaW5rJykudW5zZXRMaW5rKCkuc2VsZWN0VGV4dGJsb2NrRW5kKCkucnVuKCl9PlxuICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTcgMTdIMjJWMTlIMTlWMjJIMTdWMTdaTTcgN0gyVjVINVYySDdWN1pNMTguMzY0IDE1LjUzNTVMMTYuOTQ5NyAxNC4xMjEzTDE4LjM2NCAxMi43MDcxQzIwLjMxNjYgMTAuNzU0NSAyMC4zMTY2IDcuNTg4NjYgMTguMzY0IDUuNjM2MDRDMTYuNDExMyAzLjY4MzQyIDEzLjI0NTUgMy42ODM0MiAxMS4yOTI5IDUuNjM2MDRMOS44Nzg2OCA3LjA1MDI1TDguNDY0NDcgNS42MzYwNEw5Ljg3ODY4IDQuMjIxODNDMTIuNjEyMyAxLjQ4ODE2IDE3LjA0NDUgMS40ODgxNiAxOS43NzgyIDQuMjIxODNDMjIuNTExOCA2Ljk1NTUgMjIuNTExOCAxMS4zODc3IDE5Ljc3ODIgMTQuMTIxM0wxOC4zNjQgMTUuNTM1NVpNMTUuNTM1NSAxOC4zNjRMMTQuMTIxMyAxOS43NzgyQzExLjM4NzcgMjIuNTExOCA2Ljk1NTUgMjIuNTExOCA0LjIyMTgzIDE5Ljc3ODJDMS40ODgxNiAxNy4wNDQ1IDEuNDg4MTYgMTIuNjEyMyA0LjIyMTgzIDkuODc4NjhMNS42MzYwNCA4LjQ2NDQ3TDcuMDUwMjUgOS44Nzg2OEw1LjYzNjA0IDExLjI5MjlDMy42ODM0MiAxMy4yNDU1IDMuNjgzNDIgMTYuNDExMyA1LjYzNjA0IDE4LjM2NEM3LjU4ODY2IDIwLjMxNjYgMTAuNzU0NSAyMC4zMTY2IDEyLjcwNzEgMTguMzY0TDE0LjEyMTMgMTYuOTQ5N0wxNS41MzU1IDE4LjM2NFpNMTQuODI4NCA3Ljc1NzM2TDE2LjI0MjYgOS4xNzE1N0w5LjE3MTU3IDE2LjI0MjZMNy43NTczNiAxNC44Mjg0TDE0LjgyODQgNy43NTczNlpcIi8+XG4gICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgey9pZn1cbiAgICA8L2Rpdj5cbnsvaWZ9XG4iLCAiPHNjcmlwdD5cbiAgICBpbXBvcnQgQnV0dG9uIGZyb20gJy4vQnV0dG9uLnN2ZWx0ZSdcblxuICAgIGV4cG9ydCBsZXQgZWRpdG9yXG4gICAgZXhwb3J0IGxldCBpc0FjdGl2ZVxuICAgIGV4cG9ydCBsZXQgdG9vbHNcbiAgICBleHBvcnQgbGV0IGhhbmRsZVRvb2xDbGlja1xuXG4gICAgbGV0IGdyb3VwcyA9IHt9XG5cbiAgICBjb25zdCBnZXRHcm91cHMgPSBhcnJheSA9PiB7XG4gICAgICAgIGxldCBtYXAgPSBhcnJheS5tYXAoKGUsIGkpID0+IHtcbiAgICAgICAgICAgIGUuaW5kZXggPSBpXG4gICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICB9KVxuXG4gICAgICAgIGdyb3VwcyA9IG1hcC5yZWR1Y2UoZnVuY3Rpb24ociwgYSkge1xuICAgICAgICAgICAgclthLmdyb3VwXSA9IHJbYS5ncm91cF0gfHwgW11cbiAgICAgICAgICAgIHJbYS5ncm91cF0ucHVzaChhKVxuICAgICAgICAgICAgcmV0dXJuIHJcbiAgICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSlcbiAgICB9XG5cbiAgICAkOiBnZXRHcm91cHModG9vbHMpXG48L3NjcmlwdD5cblxueyNpZiBlZGl0b3IgJiYgdG9vbHMgJiYgdG9vbHMubGVuZ3RoID4gMH1cbiAgICA8ZGl2IGNsYXNzPVwic2NyaWJibGUtdG9vbGJhclwiPlxuICAgICAgICB7I2lmIHRvb2xzLmxlbmd0aH1cbiAgICAgICAgICAgIHsjZWFjaCBPYmplY3Qua2V5cyhncm91cHMpIGFzIGdyb3VwfVxuICAgICAgICAgICAgICAgIHsjaWYgZ3JvdXAgIT09ICcnfVxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInRvb2xiYXItZ3JvdXBcIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICB7I2VhY2ggZ3JvdXBzW2dyb3VwXSBhcyB0b29sfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24ge2VkaXRvcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXt0b29sLmV4dGVuc2lvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXtpc0FjdGl2ZSh0b29sLmV4dGVuc2lvbiwgdG9vbC5hY3RpdmVBdHRyaWJ1dGVzKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2s9eygpID0+IGhhbmRsZVRvb2xDbGljayh0b29sKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuPXt0b29sLmlzSGlkZGVufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BodG1sIHRvb2wuaWNvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICB7I2VhY2ggZ3JvdXBzW2dyb3VwXSBhcyB0b29sfVxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiB7ZWRpdG9yfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17dG9vbC5leHRlbnNpb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXtpc0FjdGl2ZSh0b29sLmV4dGVuc2lvbiwgdG9vbC5hY3RpdmVBdHRyaWJ1dGVzKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjbGljaz17KCkgPT4gaGFuZGxlVG9vbENsaWNrKHRvb2wpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbj17dG9vbC5pc0hpZGRlbn1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGh0bWwgdG9vbC5pY29ufVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7L2lmfVxuICAgIDwvZGl2Plxuey9pZn1cbiIsICI8c2NyaXB0PlxuICAgIGltcG9ydCB7b25Nb3VudCwgb25EZXN0cm95fSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuICAgIGltcG9ydCB7IEJ1YmJsZU1lbnUgYXMgVGlwdGFwQnViYmxlTWVudSB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJ1YmJsZS1tZW51J1xuICAgIGltcG9ydCBDbGFzc0V4dGVuc2lvbiBmcm9tICcuL2V4dGVuc2lvbnMvQ2xhc3NFeHRlbnNpb24uanMnXG4gICAgaW1wb3J0IENvbW1hbmRzRXh0ZW5zaW9uIGZyb20gJy4vZXh0ZW5zaW9ucy9Db21tYW5kc0V4dGVuc2lvbi5qcydcbiAgICBpbXBvcnQgR3JpZCBmcm9tICcuL2V4dGVuc2lvbnMvR3JpZC9HcmlkLmpzJ1xuICAgIGltcG9ydCBHcmlkQ29sdW1uIGZyb20gJy4vZXh0ZW5zaW9ucy9HcmlkL0dyaWRDb2x1bW4uanMnXG4gICAgaW1wb3J0IElkRXh0ZW5zaW9uIGZyb20gJy4vZXh0ZW5zaW9ucy9JZEV4dGVuc2lvbi5qcydcbiAgICBpbXBvcnQgTGlua0V4dGVuc2lvbiBmcm9tICcuL2V4dGVuc2lvbnMvTGlua0V4dGVuc2lvbi5qcydcbiAgICBpbXBvcnQgTWVkaWFFeHRlbnNpb24gZnJvbSAnLi9leHRlbnNpb25zL01lZGlhRXh0ZW5zaW9uLmpzJ1xuICAgIGltcG9ydCBQbGFjZWhvbGRlciBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1wbGFjZWhvbGRlcidcbiAgICBpbXBvcnQgU3RhcnRlcktpdCBmcm9tICdAdGlwdGFwL3N0YXJ0ZXIta2l0JztcbiAgICBpbXBvcnQgU2NyaWJibGVCbG9jayBmcm9tICcuL2V4dGVuc2lvbnMvU2NyaWJibGVCbG9jayc7XG4gICAgaW1wb3J0IFNsYXNoRXh0ZW5zaW9uIGZyb20gJy4vZXh0ZW5zaW9ucy9TbGFzaEV4dGVuc2lvbi5qcydcbiAgICBpbXBvcnQgU3Vic2NyaXB0IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLXN1YnNjcmlwdCdcbiAgICBpbXBvcnQgU3VwZXJzY3JpcHQgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tc3VwZXJzY3JpcHQnXG4gICAgaW1wb3J0IFRleHRBbGlnbiBmcm9tICcuL2V4dGVuc2lvbnMvVGV4dEFsaWduRXh0ZW5zaW9uLmpzJ1xuICAgIGltcG9ydCBUZXh0U3R5bGUgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tdGV4dC1zdHlsZSdcbiAgICBpbXBvcnQgeyBVbmRlcmxpbmUgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi11bmRlcmxpbmUnXG4gICAgaW1wb3J0IHsgcG91bmNlLCBjb21tYW5kUnVubmVyIH0gZnJvbSAnLi91dGlscy5qcydcbiAgICBpbXBvcnQgeyBnZXRTdGF0ZVBhdGggfSBmcm9tICcuL3N0b3Jlcy5qcydcbiAgICBpbXBvcnQgQ29udHJvbHMgZnJvbSAnLi9jb21wb25lbnRzL0NvbnRyb2xzLnN2ZWx0ZSdcbiAgICBpbXBvcnQgQnViYmxlTWVudSBmcm9tICcuL2NvbXBvbmVudHMvQnViYmxlTWVudS5zdmVsdGUnXG4gICAgaW1wb3J0IFRvb2xiYXIgZnJvbSAnLi9jb21wb25lbnRzL1Rvb2xiYXIuc3ZlbHRlJ1xuXG4gICAgbGV0IGVkaXRvcjtcbiAgICBsZXQgZWxlbWVudDtcbiAgICBsZXQgYnViYmxlTWVudUVsZW1lbnQ7XG4gICAgbGV0IHRvb2xzO1xuXG4gICAgZXhwb3J0IGxldCBjb250ZW50O1xuICAgIGV4cG9ydCBsZXQgc3RhdGVQYXRoO1xuICAgIGV4cG9ydCBsZXQgcGxhY2Vob2xkZXI7XG4gICAgZXhwb3J0IGxldCBidWJibGVUb29scztcbiAgICBleHBvcnQgbGV0IHN1Z2dlc3Rpb25Ub29scztcbiAgICBleHBvcnQgbGV0IHRvb2xiYXJUb29scztcblxuICAgICRnZXRTdGF0ZVBhdGggPSBzdGF0ZVBhdGhcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBlZGl0b3IgPSBuZXcgRWRpdG9yKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgZXh0ZW5zaW9uczogW1xuICAgICAgICAgICAgICAgIFN0YXJ0ZXJLaXQsXG4gICAgICAgICAgICAgICAgQ2xhc3NFeHRlbnNpb24sXG4gICAgICAgICAgICAgICAgQ29tbWFuZHNFeHRlbnNpb24sXG4gICAgICAgICAgICAgICAgTGlua0V4dGVuc2lvbixcbiAgICAgICAgICAgICAgICBJZEV4dGVuc2lvbixcbiAgICAgICAgICAgICAgICBHcmlkLFxuICAgICAgICAgICAgICAgIEdyaWRDb2x1bW4sXG4gICAgICAgICAgICAgICAgU2NyaWJibGVCbG9jayxcbiAgICAgICAgICAgICAgICBTdWJzY3JpcHQsXG4gICAgICAgICAgICAgICAgU3VwZXJzY3JpcHQsXG4gICAgICAgICAgICAgICAgTWVkaWFFeHRlbnNpb24sXG4gICAgICAgICAgICAgICAgVW5kZXJsaW5lLFxuICAgICAgICAgICAgICAgIFRleHRBbGlnbi5jb25maWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlczogWydoZWFkaW5nJywgJ3BhcmFncmFwaCddXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgVGV4dFN0eWxlLFxuICAgICAgICAgICAgICAgIFNsYXNoRXh0ZW5zaW9uLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xzOiBzdWdnZXN0aW9uVG9vbHNcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBUaXB0YXBCdWJibGVNZW51LmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGJ1YmJsZU1lbnVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0aXBweU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20tc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWU6ICdzY3JpYmJsZS1idWJibGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFNob3c6ICh7IGVkaXRvciwgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPT09IHRvICYmIGVkaXRvci5pc0FjdGl2ZSgnbGluaycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb20gIT09IHRvICYmICEgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5pc0FjdGl2ZSgnaW1hZ2UnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5pc0FjdGl2ZSgnc2NyaWJibGVCbG9jaycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmlzQWN0aXZlKCdzbGFzaEV4dGVuc2lvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgUGxhY2Vob2xkZXIuY29uZmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgICAgICBlbXB0eUVkaXRvckNsYXNzOiAnaXMtZWRpdG9yLWVtcHR5JyxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBvblRyYW5zYWN0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZWRpdG9yID0gZWRpdG9yXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25VcGRhdGUoe2VkaXRvcn0pIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3VwZGF0ZWRFZGl0b3InLCB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXRoOiBzdGF0ZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBlZGl0b3IuZ2V0SlNPTigpLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICB9KVxuXG4gICAgb25EZXN0cm95KCgpID0+IHtcbiAgICAgICAgZWRpdG9yLmRlc3Ryb3koKVxuICAgIH0pXG5cbiAgICB0b29scyA9IFtcbiAgICAgICAgLi4uYnViYmxlVG9vbHMuZmxhdCgpLFxuICAgICAgICAuLi5zdWdnZXN0aW9uVG9vbHMuZmxhdCgpLFxuICAgICAgICAuLi50b29sYmFyVG9vbHMuZmxhdCgpXG4gICAgXVxuXG4gICAgJDogaXNBY3RpdmUgPSAobmFtZSwgYXR0cnMgPSB7fSkgPT4gZWRpdG9yLmlzQWN0aXZlKG5hbWUsIGF0dHJzKTtcblxuICAgIHRvb2xzLmZvckVhY2godG9vbCA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGBpbnNlcnQtJHt0b29sLmV4dGVuc2lvbn1gLCBkYXRhID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhLmRldGFpbC5zdGF0ZVBhdGggIT09IHN0YXRlUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9vbC50eXBlID09PSAnYmxvY2snIHx8IHRvb2wudHlwZSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuY2hhaW4oKS5pbnNlcnRTY3JpYmJsZUJsb2NrKHtcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogdG9vbC5pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b29sLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogZGF0YS5kZXRhaWwudmFsdWVzXG4gICAgICAgICAgICAgICAgfSkuZm9jdXMoKS5ydW4oKTtcblxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb21tYW5kUnVubmVyKGVkaXRvciwgdG9vbC5jb21tYW5kcywgZGF0YS5kZXRhaWwudmFsdWVzKVxuICAgICAgICB9KVxuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGB1cGRhdGUtJHt0b29sLmV4dGVuc2lvbn1gLCBkYXRhID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhLmRldGFpbC5zdGF0ZVBhdGggIT09IHN0YXRlUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9vbC50eXBlID09PSAnYmxvY2snIHx8IHRvb2wudHlwZSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3VwZGF0ZWRCbG9jaycsIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVBhdGg6IHN0YXRlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IHRvb2wuaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRvb2wudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrSWQ6IGRhdGEuZGV0YWlsLmJsb2NrSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGEuZGV0YWlsLnZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbW1hbmRSdW5uZXIoZWRpdG9yLCB0b29sLmNvbW1hbmRzLCBkYXRhLmRldGFpbC52YWx1ZXMpXG4gICAgICAgIH0pXG4gICAgfSlcblxuICAgIGNvbnN0IGhhbmRsZVRvb2xDbGljayA9ICh0b29sLCB1cGRhdGUgPSBmYWxzZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHRvb2wudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY29tbWFuZCc6IGNvbW1hbmRSdW5uZXIoZWRpdG9yLCB0b29sLmNvbW1hbmRzKTsgcmV0dXJuXG4gICAgICAgICAgICBjYXNlICdtb2RhbCc6IHBvdW5jZSh0b29sLmlkZW50aWZpZXIsIHsgc3RhdGVQYXRoOiB0b29sLnN0YXRlUGF0aCwgdXBkYXRlOiB1cGRhdGUsIC4uLmVkaXRvci5nZXRBdHRyaWJ1dGVzKHRvb2wuZXh0ZW5zaW9uKSB9KTsgcmV0dXJuXG4gICAgICAgICAgICBjYXNlICdzdGF0aWMnOiBlZGl0b3IuY2hhaW4oKS5pbnNlcnRTY3JpYmJsZUJsb2NrKHtcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogdG9vbC5pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b29sLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczoge31cbiAgICAgICAgICAgICAgICB9KS5mb2N1cygpLnJ1bigpOyByZXR1cm5cbiAgICAgICAgICAgIGRlZmF1bHQ6IGVkaXRvci5jb21tYW5kcy5zZXRTY3JpYmJsZUJsb2NrKHtcbiAgICAgICAgICAgICAgICBzdGF0ZVBhdGg6IHN0YXRlUGF0aCxcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiB0b29sLmlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgdHlwZTogdG9vbC50eXBlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwic2NyaWJibGUtZWRpdG9yLXdyYXBwZXJcIj5cbiAgICA8Q29udHJvbHMge2VkaXRvcn0gLz5cblxuICAgIDxUb29sYmFyIHtlZGl0b3J9IHRvb2xzPXt0b29sYmFyVG9vbHN9IHtoYW5kbGVUb29sQ2xpY2t9IHtpc0FjdGl2ZX0gLz5cblxuICAgIDxkaXYgY2xhc3M9XCJzY3JpYmJsZS1lZGl0b3JcIiBiaW5kOnRoaXM9e2VsZW1lbnR9IC8+XG5cbiAgICA8ZGl2IGJpbmQ6dGhpcz17YnViYmxlTWVudUVsZW1lbnR9PlxuICAgICAgICA8QnViYmxlTWVudSB7ZWRpdG9yfSB0b29scz17YnViYmxlVG9vbHN9IHtoYW5kbGVUb29sQ2xpY2t9IHtpc0FjdGl2ZX0gLz5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuIiwgImltcG9ydCBTY3JpYmJsZSBmcm9tICcuL1NjcmliYmxlLnN2ZWx0ZSdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2NyaWJibGUoYnViYmxlVG9vbHMsIHN1Z2dlc3Rpb25Ub29scywgdG9vbGJhclRvb2xzLCBzdGF0ZSwgc3RhdGVQYXRoLCBwbGFjZWhvbGRlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJ1YmJsZVRvb2xzLFxuICAgICAgICBzdWdnZXN0aW9uVG9vbHMsXG4gICAgICAgIHRvb2xiYXJUb29scyxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHN0YXRlUGF0aCxcbiAgICAgICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyID8/IFwicHJlc3MgJy8nIGZvciBibG9ja3NcIixcbiAgICAgICAgZnVsbHNjcmVlbjogZmFsc2UsXG5cbiAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpc1xuXG4gICAgICAgICAgICBuZXcgU2NyaWJibGUoe1xuICAgICAgICAgICAgICAgIHRhcmdldDogX3RoaXMuJHJvb3QsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlVG9vbHM6IF90aGlzLmJ1YmJsZVRvb2xzLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uVG9vbHM6IF90aGlzLnN1Z2dlc3Rpb25Ub29scyxcbiAgICAgICAgICAgICAgICAgICAgdG9vbGJhclRvb2xzOiBfdGhpcy50b29sYmFyVG9vbHMsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IF90aGlzLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVBhdGg6IF90aGlzLnN0YXRlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IF90aGlzLnBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVkRWRpdG9yJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUuZGV0YWlsLnN0YXRlUGF0aCA9PT0gX3RoaXMuc3RhdGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gZS5kZXRhaWwuY29udGVudFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9nZ2xlRnVsbHNjcmVlbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRldGFpbC5zdGF0ZVBhdGggIT09IHRoaXMuc3RhdGVQYXRoKSByZXR1cm5cbiAgICAgICAgICAgIHRoaXMuZnVsbHNjcmVlbiA9ICF0aGlzLmZ1bGxzY3JlZW5cbiAgICAgICAgfSxcbiAgICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7OztBQUNPLFNBQVMsT0FBTztBQUFDO0FBV2pCLFNBQVMsT0FBTyxLQUFLLEtBQUs7QUFFaEMsYUFBVyxLQUFLO0FBQUssUUFBSSxDQUFDLElBQUksSUFBSSxDQUFDO0FBQ25DO0FBQUE7QUFBQSxJQUE2QjtBQUFBO0FBQzlC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S0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUNQO0FBRU8sSUFBSSxRQUFRO0FBQUEsRUFDakIsSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUNQO0FBRUEsSUFBSUMsT0FBTSxPQUFPLGFBQWEsZUFBZSxNQUFNLEtBQUssVUFBVSxRQUFRO0FBQzFFLElBQUlDLE1BQUssT0FBTyxhQUFhLGVBQWUsZ0RBQWdELEtBQUssVUFBVSxTQUFTO0FBR3BILEtBQVMsSUFBSSxHQUFHLElBQUksSUFBSTtBQUFLLE9BQUssS0FBSyxDQUFDLElBQUksS0FBSyxLQUFLLENBQUMsSUFBSSxPQUFPLENBQUM7QUFBMUQ7QUFHVCxLQUFTLElBQUksR0FBRyxLQUFLLElBQUk7QUFBSyxPQUFLLElB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RCxhQUFPLGlCQUFpQixpQkFBaUIsT0FBSztBQUMxQyxZQUFJLEVBQUUsT0FBTyxjQUFjLE1BQU0sV0FBVztBQUN4QyxnQkFBTSxRQUFRLEVBQUUsT0FBTztBQUFBLFFBQzNCO0FBQUEsTUFDSixDQUFDO0FBQUEsSUFDTDtBQUFBLElBRUEsaUJBQWlCLE9BQU87QUFDcEIsVUFBSSxNQUFNLE9BQU8sY0FBYyxLQUFLO0FBQVc7QUFDL0MsV0FBSyxhQUFhLENBQUMsS0FBSztBQUFBLElBQzVCO0FBQUEsRUFDSjtBQUNKOyIsCiAgIm5hbWVzIjogWyJmbiIsICJmbiIsICJrZXlzIiwgImVsZW1lbnQiLCAiZm4iLCAiZWxlbWVudCIsICJ0ZXh0IiwgImVsZW1lbnQiLCAiZWxlbWVudCIsICJmbiIsICJmbiIsICJmbiIsICJmbiIsICJkZXRhY2giLCAidXBkYXRlIiwgImluc3RhbmNlIiwgImNyZWF0ZV9mcmFnbWVudCIsICJjcmVhdGVfc2xvdCIsICJhdHRyIiwgImZvdW5kIiwgIm1hcCIsICJmcm9tIiwgImVuZCIsICJzdGFydCIsICJ0ZXh0IiwgImZpcnN0IiwgImNvcHkiLCAiZm91bmQiLCAicm91bmQiLCAib2Zmc2V0IiwgImluc2VydCIsICJzbGljZSIsICJtYWluIiwgImRvYyIsICJiYXNlIiwgImkiLCAibWluIiwgIm1heCIsICJ0eXBlIiwgIm5mYSIsICJlZGdlIiwgImV4cHIiLCAibG9vcCIsICJub2RlIiwgInN0YXRlcyIsICJkZWZhdWx0cyIsICJhdHRyIiwgIm1hcmsiLCAiRE9NUGFyc2VyIiwgInIiLCAic3R5bGUiLCAid3JhcCIsICJ0b3AiLCAic3BhY2UiLCAib2Zmc2V0IiwgInN0YXJ0IiwgImVuZCIsICJkZWwiLCAiZnJvbSIsICJtYXAiLCAiZG9jIiwgInNsaWNlIiwgInBhcmVudCIsICJpbnNlcnQiLCAidHIiLCAiZm91bmQiLCAic3R5bGUiLCAiYmFzZSIsICJpbmRleCIsICJqb2luYWJsZSIsICJmaXJzdCIsICJ3cmFwIiwgIm1hdGNoZXMiLCAidG9wIiwgIm1hdGNoIiwgInR5cGUiLCAiY2xvc2UiLCAiYXR0ciIsICJUcmFuc2Zvcm1FcnJvciIsICJ0ciIsICJmcm9tIiwgImZvdW5kIiwgImRvYyIsICJ0ZXh0IiwgIm1hcCIsICJlbmQiLCAic2xpY2UiLCAiaW5zdGFuY2UiLCAiZnJvbSIsICJvZmZzZXQiLCAiZG9jIiwgInRvcCIsICJsZWZ0IiwgImVsZW1lbnQiLCAiZmlyc3QiLCAiY2hpbGRyZW4iLCAiZW5kIiwgImVudGVyIiwgImJhc2UiLCAid3JhcCIsICJ0ZXh0IiwgImNvcHkiLCAic3RhcnQiLCAiZm91bmQiLCAicHJlTWF0Y2giLCAibWF0Y2hlcyIsICJlbXB0eSIsICJ0ciIsICJzbGljZSIsICJET01QYXJzZXIiLCAiZG9tIiwgImV2ZW50IiwgImhhbmRsZXJzIiwgIm5vdyIsICJjdXQiLCAiTm9kZVR5cGUiLCAiciIsICJpIiwgIm9sZE9mZnNldCIsICJyZWFkIiwgImZpbmQiLCAiYW5jaG9yIiwgInNlbCIsICJ1cGRhdGUiLCAiZnJvbSIsICJmb3VuZCIsICJwcm9wIiwgIm9mZnNldCIsICJ0ZXh0IiwgInRyIiwgImF0dHIiLCAibWFjIiwgImllIiwgIm1hYyIsICJzaGlmdCIsICJtYXAiLCAiY29weSIsICJ0ciIsICJlbXB0eSIsICJsaWZ0IiwgImZpcnN0IiwgImVuZCIsICJ3cmFwIiwgInRyIiwgInNldEJsb2NrVHlwZSIsICJmcm9tIiwgImNvbW1hbmRzIiwgIm1hYyIsICJ3cmFwIiwgInRyIiwgImZvdW5kIiwgImZpcnN0IiwgInRyIiwgImVuZCIsICJzdGFydCIsICJzbGljZSIsICJkb2MiLCAidHIiLCAiY29tbWFuZCIsICJydW4iLCAiZm4iLCAiZXh0ZW5zaW9ucyIsICJfYSIsICJ0ZXh0IiwgImZpbmQiLCAiZnJvbSIsICJjb21tYW5kcyIsICJtYXRjaGVzIiwgImhhbmRsZXJzIiwgInN0YXJ0IiwgImVuZCIsICJvbkNyZWF0ZSIsICJvbkRlc3Ryb3kiLCAiTWFyayIsICJyYW5nZSIsICJjcmVhdGVQYXJhZ3JhcGhOZWFyIiwgIm9yaWdpbmFsQ3JlYXRlUGFyYWdyYXBoTmVhciIsICJkZWxldGVSYW5nZSIsICJkZWxldGVTZWxlY3Rpb24iLCAib3JpZ2luYWxEZWxldGVTZWxlY3Rpb24iLCAiZXhpdENvZGUiLCAib3JpZ2luYWxFeGl0Q29kZSIsICJrZXlzIiwgIm1pbiIsICJtYXgiLCAiY2hpbGRyZW4iLCAiRE9NUGFyc2VyIiwgInNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kIiwgIm1hcCIsICJqb2luVXAiLCAib3JpZ2luYWxKb2luVXAiLCAiam9pbkRvd24iLCAib3JpZ2luYWxKb2luRG93biIsICJqb2luQmFja3dhcmQiLCAib3JpZ2luYWxKb2luQmFja3dhcmQiLCAiam9pbkZvcndhcmQiLCAib3JpZ2luYWxKb2luRm9yd2FyZCIsICJqb2luVGV4dGJsb2NrQmFja3dhcmQiLCAib3JpZ2luYWxDb21tYW5kIiwgImpvaW5UZXh0YmxvY2tGb3J3YXJkIiwgIm5vcm1hbGl6ZUtleU5hbWUiLCAic2hpZnQiLCAiZW1wdHkiLCAibGlmdCIsICJpc0FjdGl2ZSIsICJvcmlnaW5hbExpZnQiLCAibGlmdEVtcHR5QmxvY2siLCAib3JpZ2luYWxMaWZ0RW1wdHlCbG9jayIsICJsaWZ0TGlzdEl0ZW0iLCAib3JpZ2luYWxMaWZ0TGlzdEl0ZW0iLCAibmV3bGluZUluQ29kZSIsICJvcmlnaW5hbE5ld2xpbmVJbkNvZGUiLCAic2VsZWN0QWxsIiwgInNlbGVjdE5vZGVCYWNrd2FyZCIsICJvcmlnaW5hbFNlbGVjdE5vZGVCYWNrd2FyZCIsICJzZWxlY3ROb2RlRm9yd2FyZCIsICJvcmlnaW5hbFNlbGVjdE5vZGVGb3J3YXJkIiwgInNlbGVjdFBhcmVudE5vZGUiLCAib3JpZ2luYWxTZWxlY3RQYXJlbnROb2RlIiwgInNlbGVjdFRleHRibG9ja0VuZCIsICJvcmlnaW5hbFNlbGVjdFRleHRibG9ja0VuZCIsICJzZWxlY3RUZXh0YmxvY2tTdGFydCIsICJvcmlnaW5hbFNlbGVjdFRleHRibG9ja1N0YXJ0IiwgImRvY3VtZW50IiwgImRlZmF1bHRCbG9ja0F0IiwgImdldFRleHQiLCAiZnJvbSIsICJub2RlIiwgImZyb20iLCAiZG9jIiwgImVtcHR5IiwgImZyb20iLCAicmFuZ2UiLCAiZXh0ZW5zaW9ucyIsICJmcm9tIiwgInN0YXJ0IiwgImVuZCIsICJ0b3AiLCAiYm90dG9tIiwgImxlZnQiLCAicmlnaHQiLCAidHIiLCAiZW1wdHkiLCAiY29tbWFuZHMiLCAic2V0QmxvY2tUeXBlIiwgImRvYyIsICJzaW5rTGlzdEl0ZW0iLCAib3JpZ2luYWxTaW5rTGlzdEl0ZW0iLCAic3BsaXRCbG9jayIsICJkZWZhdWx0QmxvY2tBdCIsICJmaXJzdCIsICJ3cmFwIiwgIm5ld05leHRUeXBlQXR0cmlidXRlcyIsICJuZXh0VHlwZSIsICJpc0FjdGl2ZSIsICJ3cmFwSW4iLCAib3JpZ2luYWxXcmFwSW4iLCAid3JhcEluTGlzdCIsICJvcmlnaW5hbFdyYXBJbkxpc3QiLCAiY2hpbGRyZW4iLCAib2Zmc2V0IiwgInN0eWxlIiwgImZuIiwgImZvY3VzIiwgImJsdXIiLCAiZ2V0VGV4dCIsICJ0ciIsICJNYXJrIiwgInJlbW92ZU1hcmsiLCAiTm9kZSIsICJmcm9tIiwgImVsZW1lbnQiLCAic3R5bGUiLCAiZWxlbWVudCIsICJuYW1lIiwgImVsZW1lbnQiLCAiY2xpZW50UmVjdCIsICJlbGVtZW50IiwgImNsaWVudFJlY3QiLCAiZ2V0Q29tcHV0ZWRTdHlsZSIsICJlbGVtZW50IiwgImVsZW1lbnQiLCAiZWxlbWVudCIsICJlbGVtZW50IiwgImVsZW1lbnQiLCAiZ2V0Q29tcHV0ZWRTdHlsZSIsICJ3aW5kb3ciLCAibWluIiwgIm1heCIsICJrZXlzIiwgInRvUGFkZGluZ09iamVjdCIsICJwb3BwZXJPZmZzZXRzIiwgIm1pbiIsICJtYXgiLCAib2Zmc2V0IiwgImVmZmVjdCIsICJwb3BwZXIiLCAiZ2V0Q29tcHV0ZWRTdHlsZSIsICJlZmZlY3QiLCAiaW5zdGFuY2UiLCAid2luZG93IiwgImhhc2giLCAiZWxlbWVudCIsICJlbGVtZW50IiwgImVsZW1lbnQiLCAiZ2V0Q29tcHV0ZWRTdHlsZSIsICJlbGVtZW50IiwgImdldENvbXB1dGVkU3R5bGUiLCAiZWxlbWVudCIsICJlbGVtZW50IiwgImNsaXBwaW5nUGFyZW50cyIsICJnZXRDb21wdXRlZFN0eWxlIiwgInJlZmVyZW5jZSIsICJlbGVtZW50IiwgImVsZW1lbnQiLCAicG9wcGVyT2Zmc2V0cyIsICJvZmZzZXQiLCAicGxhY2VtZW50cyIsICJwbGFjZW1lbnQiLCAicGxhY2VtZW50cyIsICJwbGFjZW1lbnQiLCAiX2xvb3AiLCAiX2kiLCAiY2hlY2tzIiwgIm9mZnNldCIsICJwb3BwZXJPZmZzZXRzIiwgIm9mZnNldCIsICJtaW4iLCAibWF4IiwgImVsZW1lbnQiLCAiZWxlbWVudCIsICJtb2RpZmllcnMiLCAibWFwIiwgImZuIiwgIm1vZGlmaWVycyIsICJtZXJnZWQiLCAiZWxlbWVudCIsICJkZWZhdWx0TW9kaWZpZXJzIiwgImNyZWF0ZVBvcHBlciIsICJyZWZlcmVuY2UiLCAicG9wcGVyIiwgImluc3RhbmNlIiwgIm9wdGlvbnMiLCAiZm4iLCAic3RhdGUiLCAiZWZmZWN0IiwgIm5vb3BGbiIsICJCT1hfQ0xBU1MiLCAiQ09OVEVOVF9DTEFTUyIsICJCQUNLRFJPUF9DTEFTUyIsICJBUlJPV19DTEFTUyIsICJTVkdfQVJST1dfQ0xBU1MiLCAiVE9VQ0hfT1BUSU9OUyIsICJwYXNzaXZlIiwgImNhcHR1cmUiLCAiVElQUFlfREVGQVVMVF9BUFBFTkRfVE8iLCAiZG9jdW1lbnQiLCAiYm9keSIsICJoYXNPd25Qcm9wZXJ0eSIsICJvYmoiLCAia2V5IiwgImNhbGwiLCAiZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4iLCAidmFsdWUiLCAiaW5kZXgiLCAiZGVmYXVsdFZhbHVlIiwgIkFycmF5IiwgImlzQXJyYXkiLCAidiIsICJpc1R5cGUiLCAidHlwZSIsICJzdHIiLCAidG9TdHJpbmciLCAiaW5kZXhPZiIsICJpbnZva2VXaXRoQXJnc09yUmV0dXJuIiwgImFyZ3MiLCAiZGVib3VuY2UiLCAiZm4iLCAibXMiLCAidGltZW91dCIsICJhcmciLCAiY2xlYXJUaW1lb3V0IiwgInNldFRpbWVvdXQiLCAicmVtb3ZlUHJvcGVydGllcyIsICJrZXlzIiwgImNsb25lIiwgImZvckVhY2giLCAic3BsaXRCeVNwYWNlcyIsICJzcGxpdCIsICJmaWx0ZXIiLCAiQm9vbGVhbiIsICJub3JtYWxpemVUb0FycmF5IiwgImNvbmNhdCIsICJwdXNoSWZVbmlxdWUiLCAiYXJyIiwgInB1c2giLCAidW5pcXVlIiwgIml0ZW0iLCAiZ2V0QmFzZVBsYWNlbWVudCIsICJwbGFjZW1lbnQiLCAiYXJyYXlGcm9tIiwgInNsaWNlIiwgInJlbW92ZVVuZGVmaW5lZFByb3BzIiwgIk9iamVjdCIsICJyZWR1Y2UiLCAiYWNjIiwgInVuZGVmaW5lZCIsICJkaXYiLCAiY3JlYXRlRWxlbWVudCIsICJpc0VsZW1lbnQiLCAic29tZSIsICJpc05vZGVMaXN0IiwgImlzTW91c2VFdmVudCIsICJpc1JlZmVyZW5jZUVsZW1lbnQiLCAiX3RpcHB5IiwgInJlZmVyZW5jZSIsICJnZXRBcnJheU9mRWxlbWVudHMiLCAicXVlcnlTZWxlY3RvckFsbCIsICJzZXRUcmFuc2l0aW9uRHVyYXRpb24iLCAiZWxzIiwgImVsIiwgInN0eWxlIiwgInRyYW5zaXRpb25EdXJhdGlvbiIsICJzZXRWaXNpYmlsaXR5U3RhdGUiLCAic3RhdGUiLCAic2V0QXR0cmlidXRlIiwgImdldE93bmVyRG9jdW1lbnQiLCAiZWxlbWVudE9yRWxlbWVudHMiLCAiZWxlbWVudCIsICJvd25lckRvY3VtZW50IiwgImlzQ3Vyc29yT3V0c2lkZUludGVyYWN0aXZlQm9yZGVyIiwgInBvcHBlclRyZWVEYXRhIiwgImV2ZW50IiwgImNsaWVudFgiLCAiY2xpZW50WSIsICJldmVyeSIsICJwb3BwZXJSZWN0IiwgInBvcHBlclN0YXRlIiwgInByb3BzIiwgImludGVyYWN0aXZlQm9yZGVyIiwgImJhc2VQbGFjZW1lbnQiLCAib2Zmc2V0RGF0YSIsICJtb2RpZmllcnNEYXRhIiwgIm9mZnNldCIsICJ0b3BEaXN0YW5jZSIsICJ0b3AiLCAieSIsICJib3R0b21EaXN0YW5jZSIsICJib3R0b20iLCAibGVmdERpc3RhbmNlIiwgImxlZnQiLCAieCIsICJyaWdodERpc3RhbmNlIiwgInJpZ2h0IiwgImV4Y2VlZHNUb3AiLCAiZXhjZWVkc0JvdHRvbSIsICJleGNlZWRzTGVmdCIsICJleGNlZWRzUmlnaHQiLCAidXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyIiwgImJveCIsICJhY3Rpb24iLCAibGlzdGVuZXIiLCAibWV0aG9kIiwgImFjdHVhbENvbnRhaW5zIiwgInBhcmVudCIsICJjaGlsZCIsICJ0YXJnZXQiLCAiY29udGFpbnMiLCAiZ2V0Um9vdE5vZGUiLCAiaG9zdCIsICJjdXJyZW50SW5wdXQiLCAiaXNUb3VjaCIsICJsYXN0TW91c2VNb3ZlVGltZSIsICJvbkRvY3VtZW50VG91Y2hTdGFydCIsICJ3aW5kb3ciLCAicGVyZm9ybWFuY2UiLCAiYWRkRXZlbnRMaXN0ZW5lciIsICJvbkRvY3VtZW50TW91c2VNb3ZlIiwgIm5vdyIsICJyZW1vdmVFdmVudExpc3RlbmVyIiwgIm9uV2luZG93Qmx1ciIsICJhY3RpdmVFbGVtZW50IiwgImluc3RhbmNlIiwgImJsdXIiLCAiaXNWaXNpYmxlIiwgImJpbmRHbG9iYWxFdmVudExpc3RlbmVycyIsICJpc0Jyb3dzZXIiLCAiaXNJRTExIiwgIm1zQ3J5cHRvIiwgImNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nIiwgInR4dCIsICJqb2luIiwgImNsZWFuIiwgInNwYWNlc0FuZFRhYnMiLCAibGluZVN0YXJ0V2l0aFNwYWNlcyIsICJyZXBsYWNlIiwgInRyaW0iLCAiZ2V0RGV2TWVzc2FnZSIsICJtZXNzYWdlIiwgImdldEZvcm1hdHRlZE1lc3NhZ2UiLCAidmlzaXRlZE1lc3NhZ2VzIiwgInJlc2V0VmlzaXRlZE1lc3NhZ2VzIiwgIlNldCIsICJ3YXJuV2hlbiIsICJjb25kaXRpb24iLCAiaGFzIiwgImFkZCIsICJjb25zb2xlIiwgIndhcm4iLCAiZXJyb3JXaGVuIiwgImVycm9yIiwgInZhbGlkYXRlVGFyZ2V0cyIsICJ0YXJnZXRzIiwgImRpZFBhc3NGYWxzeVZhbHVlIiwgImRpZFBhc3NQbGFpbk9iamVjdCIsICJwcm90b3R5cGUiLCAiU3RyaW5nIiwgInBsdWdpblByb3BzIiwgImFuaW1hdGVGaWxsIiwgImZvbGxvd0N1cnNvciIsICJpbmxpbmVQb3NpdGlvbmluZyIsICJzdGlja3kiLCAicmVuZGVyUHJvcHMiLCAiYWxsb3dIVE1MIiwgImFuaW1hdGlvbiIsICJhcnJvdyIsICJjb250ZW50IiwgImluZXJ0aWEiLCAibWF4V2lkdGgiLCAicm9sZSIsICJ0aGVtZSIsICJ6SW5kZXgiLCAiZGVmYXVsdFByb3BzIiwgImFwcGVuZFRvIiwgImFyaWEiLCAiZXhwYW5kZWQiLCAiZGVsYXkiLCAiZHVyYXRpb24iLCAiZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCIsICJoaWRlT25DbGljayIsICJpZ25vcmVBdHRyaWJ1dGVzIiwgImludGVyYWN0aXZlIiwgImludGVyYWN0aXZlRGVib3VuY2UiLCAibW92ZVRyYW5zaXRpb24iLCAib25BZnRlclVwZGF0ZSIsICJvbkJlZm9yZVVwZGF0ZSIsICJvbkNyZWF0ZSIsICJvbkRlc3Ryb3kiLCAib25IaWRkZW4iLCAib25IaWRlIiwgIm9uTW91bnQiLCAib25TaG93IiwgIm9uU2hvd24iLCAib25UcmlnZ2VyIiwgIm9uVW50cmlnZ2VyIiwgIm9uQ2xpY2tPdXRzaWRlIiwgInBsdWdpbnMiLCAicG9wcGVyT3B0aW9ucyIsICJyZW5kZXIiLCAic2hvd09uQ3JlYXRlIiwgInRvdWNoIiwgInRyaWdnZXIiLCAidHJpZ2dlclRhcmdldCIsICJkZWZhdWx0S2V5cyIsICJzZXREZWZhdWx0UHJvcHMiLCAicGFydGlhbFByb3BzIiwgInZhbGlkYXRlUHJvcHMiLCAiZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wcyIsICJwYXNzZWRQcm9wcyIsICJwbHVnaW4iLCAibmFtZSIsICJnZXREYXRhQXR0cmlidXRlUHJvcHMiLCAicHJvcEtleXMiLCAidmFsdWVBc1N0cmluZyIsICJnZXRBdHRyaWJ1dGUiLCAiSlNPTiIsICJwYXJzZSIsICJlIiwgImV2YWx1YXRlUHJvcHMiLCAib3V0IiwgInByb3AiLCAibm9uUGx1Z2luUHJvcHMiLCAiZGlkUGFzc1Vua25vd25Qcm9wIiwgImxlbmd0aCIsICJpbm5lckhUTUwiLCAiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCAiaHRtbCIsICJjcmVhdGVBcnJvd0VsZW1lbnQiLCAiY2xhc3NOYW1lIiwgImFwcGVuZENoaWxkIiwgInNldENvbnRlbnQiLCAidGV4dENvbnRlbnQiLCAiZ2V0Q2hpbGRyZW4iLCAicG9wcGVyIiwgImZpcnN0RWxlbWVudENoaWxkIiwgImJveENoaWxkcmVuIiwgImNoaWxkcmVuIiwgImZpbmQiLCAibm9kZSIsICJjbGFzc0xpc3QiLCAiYmFja2Ryb3AiLCAib25VcGRhdGUiLCAicHJldlByb3BzIiwgIm5leHRQcm9wcyIsICJyZW1vdmVBdHRyaWJ1dGUiLCAicmVtb3ZlQ2hpbGQiLCAiJCR0aXBweSIsICJpZENvdW50ZXIiLCAibW91c2VNb3ZlTGlzdGVuZXJzIiwgIm1vdW50ZWRJbnN0YW5jZXMiLCAiY3JlYXRlVGlwcHkiLCAic2hvd1RpbWVvdXQiLCAiaGlkZVRpbWVvdXQiLCAic2NoZWR1bGVIaWRlQW5pbWF0aW9uRnJhbWUiLCAiaXNWaXNpYmxlRnJvbUNsaWNrIiwgImRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duIiwgImRpZFRvdWNoTW92ZSIsICJpZ25vcmVPbkZpcnN0VXBkYXRlIiwgImxhc3RUcmlnZ2VyRXZlbnQiLCAiY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lciIsICJvbkZpcnN0VXBkYXRlIiwgImxpc3RlbmVycyIsICJkZWJvdW5jZWRPbk1vdXNlTW92ZSIsICJvbk1vdXNlTW92ZSIsICJjdXJyZW50VGFyZ2V0IiwgImlkIiwgInBvcHBlckluc3RhbmNlIiwgImlzRW5hYmxlZCIsICJpc0Rlc3Ryb3llZCIsICJpc01vdW50ZWQiLCAiaXNTaG93biIsICJjbGVhckRlbGF5VGltZW91dHMiLCAic2V0UHJvcHMiLCAic2hvdyIsICJoaWRlIiwgImhpZGVXaXRoSW50ZXJhY3Rpdml0eSIsICJlbmFibGUiLCAiZGlzYWJsZSIsICJ1bm1vdW50IiwgImRlc3Ryb3kiLCAicGx1Z2luc0hvb2tzIiwgIm1hcCIsICJoYXNBcmlhRXhwYW5kZWQiLCAiaGFzQXR0cmlidXRlIiwgImFkZExpc3RlbmVycyIsICJoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUiLCAiaGFuZGxlU3R5bGVzIiwgImludm9rZUhvb2siLCAic2NoZWR1bGVTaG93IiwgImdldERvY3VtZW50IiwgImdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzIiwgImdldElzQ3VzdG9tVG91Y2hCZWhhdmlvciIsICJnZXRJc0RlZmF1bHRSZW5kZXJGbiIsICJnZXRDdXJyZW50VGFyZ2V0IiwgInBhcmVudE5vZGUiLCAiZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4iLCAiZ2V0RGVsYXkiLCAiaXNTaG93IiwgImZyb21IaWRlIiwgInBvaW50ZXJFdmVudHMiLCAiaG9vayIsICJzaG91bGRJbnZva2VQcm9wc0hvb2siLCAicGx1Z2luSG9va3MiLCAiaGFuZGxlQXJpYUNvbnRlbnRBdHRyaWJ1dGUiLCAiYXR0ciIsICJub2RlcyIsICJjdXJyZW50VmFsdWUiLCAibmV4dFZhbHVlIiwgImNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzIiwgIm9uRG9jdW1lbnRQcmVzcyIsICJhY3R1YWxUYXJnZXQiLCAiY29tcG9zZWRQYXRoIiwgInJlbW92ZURvY3VtZW50UHJlc3MiLCAib25Ub3VjaE1vdmUiLCAib25Ub3VjaFN0YXJ0IiwgImFkZERvY3VtZW50UHJlc3MiLCAiZG9jIiwgIm9uVHJhbnNpdGlvbmVkT3V0IiwgImNhbGxiYWNrIiwgIm9uVHJhbnNpdGlvbkVuZCIsICJvblRyYW5zaXRpb25lZEluIiwgIm9uIiwgImV2ZW50VHlwZSIsICJoYW5kbGVyIiwgIm9wdGlvbnMiLCAib25Nb3VzZUxlYXZlIiwgIm9uQmx1ck9yRm9jdXNPdXQiLCAicmVtb3ZlTGlzdGVuZXJzIiwgInNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlIiwgImlzRXZlbnRMaXN0ZW5lclN0b3BwZWQiLCAid2FzRm9jdXNlZCIsICJzY2hlZHVsZUhpZGUiLCAiaXNDdXJzb3JPdmVyUmVmZXJlbmNlT3JQb3BwZXIiLCAiZ2V0TmVzdGVkUG9wcGVyVHJlZSIsICJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCAic2hvdWxkQmFpbCIsICJyZWxhdGVkVGFyZ2V0IiwgImNyZWF0ZVBvcHBlckluc3RhbmNlIiwgImRlc3Ryb3lQb3BwZXJJbnN0YW5jZSIsICJjb21wdXRlZFJlZmVyZW5jZSIsICJjb250ZXh0RWxlbWVudCIsICJ0aXBweU1vZGlmaWVyIiwgImVuYWJsZWQiLCAicGhhc2UiLCAicmVxdWlyZXMiLCAiYXR0cmlidXRlcyIsICJtb2RpZmllcnMiLCAicGFkZGluZyIsICJhZGFwdGl2ZSIsICJjcmVhdGVQb3BwZXIiLCAibW91bnQiLCAibmV4dEVsZW1lbnRTaWJsaW5nIiwgInRvdWNoVmFsdWUiLCAidG91Y2hEZWxheSIsICJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCAiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCAibmVzdGVkUG9wcGVyIiwgImZvcmNlVXBkYXRlIiwgImlzQWxyZWFkeVZpc2libGUiLCAiaXNEaXNhYmxlZCIsICJpc1RvdWNoQW5kVG91Y2hEaXNhYmxlZCIsICJ2aXNpYmlsaXR5IiwgInRyYW5zaXRpb24iLCAib2Zmc2V0SGVpZ2h0IiwgImlzQWxyZWFkeUhpZGRlbiIsICJpIiwgInRpcHB5IiwgIm9wdGlvbmFsUHJvcHMiLCAiZWxlbWVudHMiLCAiaXNTaW5nbGVDb250ZW50RWxlbWVudCIsICJpc01vcmVUaGFuT25lUmVmZXJlbmNlRWxlbWVudCIsICJpbnN0YW5jZXMiLCAiYXBwbHlTdHlsZXNNb2RpZmllciIsICJhcHBseVN0eWxlcyIsICJlZmZlY3QiLCAic3RhdGUiLCAiaW5pdGlhbFN0eWxlcyIsICJwb3BwZXIiLCAicG9zaXRpb24iLCAib3B0aW9ucyIsICJzdHJhdGVneSIsICJsZWZ0IiwgInRvcCIsICJtYXJnaW4iLCAiYXJyb3ciLCAicmVmZXJlbmNlIiwgIk9iamVjdCIsICJhc3NpZ24iLCAiZWxlbWVudHMiLCAic3R5bGUiLCAic3R5bGVzIiwgInRpcHB5IiwgInNldERlZmF1bHRQcm9wcyIsICJyZW5kZXIiLCAiZWxlbWVudCIsICJ2aWV3IiwgImZyb20iLCAiZG9jIiwgImVtcHR5IiwgInNob3VsZFNob3ciLCAiZWxlbWVudCIsICJOb2RlIiwgImVsZW1lbnQiLCAidHIiLCAib2Zmc2V0IiwgIk5vZGUiLCAiZWxlbWVudCIsICJlbGVtZW50IiwgImFzc2lnbiIsICJuZXh0U3RhdGUiLCAiYXNzaWduIiwgInJ1biQxIiwgInN0YXJ0IiwgImZpcnN0IiwgIm5vb3AiLCAic2NoZW1lIiwgImFzc2lnbiIsICJydW4iLCAic3RhcnQiLCAic2NoZW1lIiwgImluaXQiLCAicnVuIiwgInJ1biQxIiwgInRyIiwgInNsaWNlIiwgImVtcHR5IiwgIk1hcmsiLCAidGV4dCIsICJlbGVtZW50IiwgIk5vZGUiLCAiY29tbWFuZHMiLCAic3RhcnQiLCAidXBkYXRlIiwgImZuIiwgInN1YnNjcmliZSIsICJydW4iLCAiZWxlbWVudCIsICJmcm9tIiwgImN0eCIsICJlbGVtZW50IiwgImNvbW1hbmRzIiwgImNvbW1hbmQiLCAiZGl2IiwgImRpdiIsICJjdHgiLCAidXBkYXRlQXR0cmlidXRlcyIsICJkb2MiLCAiaW5wdXRSZWdleCIsICJOb2RlIiwgImNvbW1hbmRzIiwgIk1hcmsiLCAiY29tbWFuZHMiLCAiTm9kZSIsICJNYXJrIiwgImVsZW1lbnQiLCAiY29tbWFuZHMiLCAiaW5wdXRSZWdleCIsICJpbnB1dFJlZ2V4IiwgIk1hcmsiLCAiY29tbWFuZHMiLCAiTm9kZSIsICJlbGVtZW50IiwgImNvbW1hbmRzIiwgImVtcHR5IiwgInRyIiwgImRvYyIsICJ0ZXh0IiwgIk5vZGUiLCAidG9wIiwgInJlY3QiLCAiZG9jIiwgImFycm93IiwgImluc2VydCIsICJ0ciIsICJOb2RlIiwgImNvbW1hbmRzIiwgInRyIiwgIk5vZGUiLCAiY29tbWFuZHMiLCAiUm9wZVNlcXVlbmNlIiwgImFwcGVuZCIsICJmcm9tIiwgImZvckVhY2giLCAiTGVhZiIsICJzdGFydCIsICJBcHBlbmQiLCAibGVmdCIsICJyaWdodCIsICJhcHBlbmRJbm5lciIsICJkaXN0X2RlZmF1bHQiLCAiZW5kIiwgIm1hcCIsICJmcm9tIiwgInN0YXJ0IiwgImRpc3RfZGVmYXVsdCIsICJoaXN0b3J5IiwgInRyIiwgInJlZG8iLCAidHIiLCAiY29tbWFuZCIsICJOb2RlIiwgInRyIiwgInN0YXJJbnB1dFJlZ2V4IiwgInN0YXJQYXN0ZVJlZ2V4IiwgInVuZGVyc2NvcmVJbnB1dFJlZ2V4IiwgInVuZGVyc2NvcmVQYXN0ZVJlZ2V4IiwgIk1hcmsiLCAiY29tbWFuZHMiLCAiTGlzdEl0ZW0iLCAiTm9kZSIsICJMaXN0SXRlbSIsICJOb2RlIiwgIlRleHRTdHlsZSIsICJNYXJrIiwgImVsZW1lbnQiLCAiY29tbWFuZHMiLCAiaW5wdXRSZWdleCIsICJzdGFydCIsICJOb2RlIiwgImNvbW1hbmRzIiwgImlucHV0UmVnZXgiLCAicGFzdGVSZWdleCIsICJNYXJrIiwgInN0eWxlIiwgImNvbW1hbmRzIiwgIlRleHQiLCAiTm9kZSIsICJleHRlbnNpb25zIiwgIkxpc3RJdGVtIiwgIlRleHQiLCAiY3R4IiwgInVwZGF0ZUF0dHJpYnV0ZXMiLCAiU2NyaWJibGVCbG9ja19kZWZhdWx0IiwgIk5vZGUiLCAidHIiLCAidGV4dCIsICJmcm9tIiwgImNvbW1hbmQiLCAicmVuZGVyIiwgImZpbmRTdWdnZXN0aW9uTWF0Y2giLCAiZGVmYXVsdEZpbmRTdWdnZXN0aW9uTWF0Y2giLCAiX2EiLCAiZW1wdHkiLCAiY3R4IiwgImRpdiIsICJjcmVhdGVfaWZfYmxvY2siLCAibWFwIiwgInIiLCAiZWxlbWVudCIsICJNYXJrIiwgImNvbW1hbmRzIiwgIk1hcmsiLCAiY29tbWFuZHMiLCAiZWxlbWVudCIsICJjb21tYW5kcyIsICJUZXh0U3R5bGUiLCAiTWFyayIsICJlbGVtZW50IiwgImNvbW1hbmRzIiwgIk1hcmsiLCAic3R5bGUiLCAiY29tbWFuZHMiLCAiY3R4IiwgImNyZWF0ZV9pZl9ibG9jayIsICJjcmVhdGVfaWZfYmxvY2siLCAiY3R4IiwgImN0eCIsICJkaXYiLCAiY3JlYXRlX2lmX2Jsb2NrXzIiLCAiY3JlYXRlX2lmX2Jsb2NrIiwgImlzQWN0aXZlIiwgIm1hcCIsICJyIiwgImNyZWF0ZV9pZl9ibG9ja18xIiwgImRpdiIsICJjdHgiLCAiY3JlYXRlX2lmX2Jsb2NrIiwgImlzQWN0aXZlIiwgIm1hcCIsICJyIiwgImN0eCIsICJlbGVtZW50IiwgIlNjcmliYmxlQmxvY2tfZGVmYXVsdCIsICJUZXh0U3R5bGUiLCAiZWRpdG9yIiwgImZyb20iLCAidXBkYXRlIiwgImlzQWN0aXZlIl0KfQo=
