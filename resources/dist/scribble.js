var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn2) {
  return fn2();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn2) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn2);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn2) {
  return definition[1] && fn2 ? assign($$scope.ctx.slice(), definition[1](fn2(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn2) {
  if (definition[2] && fn2) {
    const lets = definition[2](fn2(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys2) {
  const rest = {};
  keys2 = new Set(keys2);
  for (const k in props)
    if (!keys2.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    return this._observer ?? (this._observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        this._listeners.get(entry.target)?.(entry);
      }
    }));
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn2) {
  return function(event) {
    event.preventDefault();
    return fn2.call(this, event);
  };
}
function stop_propagation(fn2) {
  return function(event) {
    event.stopPropagation();
    return fn2.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
var always_set_through_set_attribute = ["width", "height"];
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function set_custom_element_data_map(node, data_map) {
  Object.keys(data_map).forEach((key) => {
    set_custom_element_data(node, key, data_map[key]);
  });
}
function set_custom_element_data(node, prop, value) {
  const lower = prop.toLowerCase();
  if (lower in node) {
    node[lower] = typeof node[lower] === "boolean" && value === "" ? true : value;
  } else if (prop in node) {
    node[prop] = typeof node[prop] === "boolean" && value === "" ? true : value;
  } else {
    attr(node, prop, value);
  }
}
function set_dynamic_element_data(tag) {
  return /-/.test(tag) ? set_custom_element_data_map : set_attributes;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
var HtmlTag = class {
  constructor(is_svg = false) {
    /**
     * @private
     * @default false
     */
    __publicField(this, "is_svg", false);
    /** parent for creating node */
    __publicField(this, "e");
    /** html tag nodes */
    __publicField(this, "n");
    /** target */
    __publicField(this, "t");
    /** anchor */
    __publicField(this, "a");
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target.nodeName
        );
      else
        this.e = element(
          /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? "TEMPLATE" : target.nodeName
        );
      this.t = target.tagName !== "TEMPLATE" ? target : (
        /** @type {HTMLTemplateElement} */
        target.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
};
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn2) {
  get_current_component().$$.on_mount.push(fn2);
}
function onDestroy(fn2) {
  get_current_component().$$.on_destroy.push(fn2);
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn2) => fn2.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn2) {
  render_callbacks.push(fn2);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance9, create_fragment9, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance9 ? instance9(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment9 ? create_fragment9($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      this.$$c?.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  const type = props_definition[prop]?.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function writable(value, start2 = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn2) {
    set(fn2(value));
  }
  function subscribe2(run4, invalidate = noop) {
    const subscriber = [run4, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set, update2) || noop;
    }
    run4(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// node_modules/orderedmap/dist/index.js
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self.find(key), content = self.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey)
        content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size)
      return this;
    return new OrderedMap(map2.content.concat(this.subtract(map2).content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size)
      return this;
    return new OrderedMap(this.subtract(map2).content.concat(map2.content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map2) {
    var result = this;
    map2 = OrderedMap.from(map2);
    for (var i = 0; i < map2.content.length; i += 2)
      result = result.remove(map2.content[i]);
    return result;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap)
    return value;
  var content = [];
  if (value)
    for (var prop in value)
      content.push(prop, value[prop]);
  return new OrderedMap(content);
};
var dist_default = OrderedMap;

// node_modules/prosemirror-model/dist/index.js
function findDiffStart(a, b, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment = class _Fragment {
  /**
  @internal
  */
  constructor(content, size) {
    this.content = content;
    this.size = size || 0;
    if (size == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from2, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end2 = pos + child.nodeSize;
      if (end2 > from2 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start2 = pos + 1;
        child.nodesBetween(Math.max(0, from2 - start2), Math.min(child.content.size, to - start2), f, nodeStart + start2);
      }
      pos = end2;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from2, to, blockSeparator, leafText) {
    let text2 = "", first2 = true;
    this.nodesBetween(from2, to, (node, pos) => {
      let nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first2)
          first2 = false;
        else
          text2 += blockSeparator;
      }
      text2 += nodeText;
    }, 0);
    return text2;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first2)) {
      content[content.length - 1] = last.withText(last.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new _Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from2, to = this.size) {
    if (from2 == 0 && to == this.size)
      return this;
    let result = [], size = 0;
    if (to > from2)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end2 = pos + child.nodeSize;
        if (end2 > from2) {
          if (pos < from2 || end2 > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size += child.nodeSize;
        }
        pos = end2;
      }
    return new _Fragment(result, size);
  }
  /**
  @internal
  */
  cutByIndex(from2, to) {
    if (from2 == to)
      return _Fragment.empty;
    if (from2 == 0 && to == this.content.length)
      return this;
    return new _Fragment(this.content.slice(from2, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index, node) {
    let current = this.content[index];
    if (current == node)
      return this;
    let copy2 = this.content.slice();
    let size = this.size + node.nodeSize - current.nodeSize;
    copy2[index] = node;
    return new _Fragment(copy2, size);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node) {
    return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node) {
    return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index) {
    let found2 = this.content[index];
    if (!found2)
      throw new RangeError("Index " + index + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index) {
    return this.content[index] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. (Not public.)
  */
  findIndex(pos, round2 = -1) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end2 = curPos + cur.nodeSize;
      if (end2 >= pos) {
        if (end2 == pos || round2 > 0)
          return retIndex(i + 1, end2);
        return retIndex(i, curPos);
      }
      curPos = end2;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema, value) {
    if (!value)
      return _Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new _Fragment(value.map(schema.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array) {
    if (!array.length)
      return _Fragment.empty;
    let joined, size = 0;
    for (let i = 0; i < array.length; i++) {
      let node = array[i];
      size += node.nodeSize;
      if (i && node.isText && array[i - 1].sameMarkup(node)) {
        if (!joined)
          joined = array.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new _Fragment(joined || array, size);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return _Fragment.empty;
    if (nodes instanceof _Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new _Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
Fragment.empty = new Fragment([], 0);
var found = { index: 0, offset: 0 };
function retIndex(index, offset2) {
  found.index = index;
  found.offset = offset2;
  return found;
}
function compareDeep(a, b) {
  if (a === b)
    return true;
  if (!(a && typeof a == "object") || !(b && typeof b == "object"))
    return false;
  let array = Array.isArray(a);
  if (Array.isArray(b) != array)
    return false;
  if (array) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compareDeep(a[i], b[i]))
        return false;
  } else {
    for (let p in a)
      if (!(p in b) || !compareDeep(a[p], b[p]))
        return false;
    for (let p in b)
      if (!(p in a))
        return false;
  }
  return true;
}
var Mark = class _Mark {
  /**
  @internal
  */
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set) {
    let copy2, placed = false;
    for (let i = 0; i < set.length; i++) {
      let other = set[i];
      if (this.eq(other))
        return set;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set.slice(0, i);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return set.slice(0, i).concat(set.slice(i + 1));
    return set;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    return type.create(json.attrs);
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a, b) {
    if (a == b)
      return true;
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].eq(b[i]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return _Mark.none;
    if (marks instanceof _Mark)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a, b) => a.type.rank - b.type.rank);
    return copy2;
  }
};
Mark.none = [];
var ReplaceError = class extends Error {
};
var Slice = class _Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new _Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from2, to) {
    return new _Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      return _Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new _Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new _Slice(fragment, openStart, openEnd);
  }
};
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from2, to) {
  let { index, offset: offset2 } = content.findIndex(from2), child = content.maybeChild(index);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset2 == from2 || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from2).append(content.cut(to));
  }
  if (index != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index, child.copy(removeRange(child.content, from2 - offset2 - 1, to - offset2 - 1)));
}
function insertInto(content, dist, insert2, parent) {
  let { index, offset: offset2 } = content.findIndex(dist), child = content.maybeChild(index);
  if (offset2 == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert2))
      return null;
    return content.cut(0, dist).append(insert2).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset2 - 1, insert2);
  return inner && content.replaceChild(index, child.copy(inner));
}
function replace($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index = $from.index(depth), node = $from.node(depth);
  if (index == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner = replaceOuter($from, $to, slice2, depth + 1);
    return node.copy(node.content.replaceChild(index, inner));
  } else if (!slice2.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
  } else {
    let { start: start2, end: end2 } = prepareSliceForReplace(slice2, $from);
    return close(node, replaceThreeWay($from, start2, end2, $to, depth));
  }
}
function checkJoin(main2, sub) {
  if (!sub.type.compatibleContent(main2.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
}
function joinable($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++)
    addNode(node.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node = parent.copy(slice2.content);
  for (let i = extra - 1; i >= 0; i--)
    node = $along.node(i).copy(Fragment.from(node));
  return {
    start: node.resolveNoCache(slice2.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
  };
}
var ResolvedPos = class _ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index = this.index(this.depth);
    if (index == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
    return dOff ? parent.child(index).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index).cut(0, dOff);
    return index == 0 ? null : this.parent.child(index - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index; i++)
      pos += node.child(i).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index = this.index();
    if (parent.content.size == 0)
      return Mark.none;
    if (this.textOffset)
      return parent.child(index).marks;
    let main2 = parent.maybeChild(index - 1), other = parent.maybeChild(index);
    if (!main2) {
      let tmp = main2;
      main2 = other;
      other = tmp;
    }
    let marks = main2.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc3, pos) {
    if (!(pos >= 0 && pos <= doc3.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start2 = 0, parentOffset = pos;
    for (let node = doc3; ; ) {
      let { index, offset: offset2 } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset2;
      path.push(node, index, start2 + offset2);
      if (!rem)
        break;
      node = node.child(index);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start2 += offset2 + 1;
    }
    return new _ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc3, pos) {
    for (let i = 0; i < resolveCache.length; i++) {
      let cached = resolveCache[i];
      if (cached.pos == pos && cached.doc == doc3)
        return cached;
    }
    let result = resolveCache[resolveCachePos] = _ResolvedPos.resolve(doc3, pos);
    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
    return result;
  }
};
var resolveCache = [];
var resolveCachePos = 0;
var resolveCacheSize = 12;
var NodeRange = class {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
};
var emptyAttrs = /* @__PURE__ */ Object.create(null);
var Node = class _Node {
  /**
  @internal
  */
  constructor(type, attrs, content, marks = Mark.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index) {
    return this.content.child(index);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index) {
    return this.content.maybeChild(index);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from2, to, f, startPos = 0) {
    this.content.nodesBetween(from2, to, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(from2, to, blockSeparator, leafText) {
    return this.content.textBetween(from2, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new _Node(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from2, to = this.content.size) {
    if (from2 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from2, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from2, to = this.content.size, includeParents = false) {
    if (from2 == to)
      return Slice.empty;
    let $from = this.resolve(from2), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start2 = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start2, $to.pos - start2);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from2, to, slice2) {
    return replace(this.resolve(from2), this.resolve(to), slice2);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node = this; ; ) {
      let { index, offset: offset2 } = node.content.findIndex(pos);
      node = node.maybeChild(index);
      if (!node)
        return null;
      if (offset2 == pos || node.isText)
        return node;
      pos -= offset2 + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index, offset: offset2 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index), index, offset: offset2 };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index, offset: offset2 } = this.content.findIndex(pos);
    if (offset2 < pos)
      return { node: this.content.child(index), index, offset: offset2 };
    let node = this.content.child(index - 1);
    return { node, index: index - 1, offset: offset2 - node.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from2, to, type) {
    let found2 = false;
    if (to > from2)
      this.nodesBetween(from2, to, (node) => {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from2, to, replacement = Fragment.empty, start2 = 0, end2 = replacement.childCount) {
    let one = this.contentMatchAt(from2).matchFragment(replacement, start2, end2);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start2; i < end2; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from2, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start2 = this.contentMatchAt(from2).matchType(type);
    let end2 = start2 && start2.matchFragment(this.content, to);
    return end2 ? end2.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise error when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    let copy2 = Mark.none;
    for (let i = 0; i < this.marks.length; i++)
      copy2 = this.marks[i].addToSet(copy2);
    if (!Mark.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n) => n.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = null;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment.fromJSON(schema, json.content);
    return schema.nodeType(json.type).create(json.attrs, content, marks);
  }
};
Node.prototype.text = void 0;
var TextNode = class _TextNode extends Node {
  /**
  @internal
  */
  constructor(type, attrs, content, marks) {
    super(type, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from2, to) {
    return this.text.slice(from2, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text2) {
    if (text2 == this.text)
      return this;
    return new _TextNode(this.type, this.attrs, text2, this.marks);
  }
  cut(from2 = 0, to = this.text.length) {
    if (from2 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from2, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
};
function wrapMarks(marks, str) {
  for (let i = marks.length - 1; i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str;
}
var ContentMatch = class _ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string, nodeTypes) {
    let stream = new TokenStream(string, nodeTypes);
    if (stream.next == null)
      return _ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type)
        return this.next[i].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start2 = 0, end2 = frag.childCount) {
    let cur = this;
    for (let i = start2; cur && i < end2; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type } = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j = 0; j < other.next.length; j++)
        if (this.next[i].type == other.next[j].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match, types) {
      let finished = match.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search(next, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n) {
    if (n >= this.next.length)
      throw new RangeError(`There's no ${n}th edge in this content match`);
    return this.next[n];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i = 0; i < m.next.length; i++)
        if (seen.indexOf(m.next[i].next) == -1)
          scan(m.next[i].next);
    }
    scan(this);
    return seen.map((m, i) => {
      let out = i + (m.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m.next.length; i2++)
        out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
      return out;
    }).join("\n");
  }
};
ContentMatch.empty = new ContentMatch(true);
var TokenStream = class {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
};
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max2 = parseNum(stream);
    else
      max2 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.groups.indexOf(name) > -1)
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    let edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next = compile(expr2.exprs[i], from2);
        if (i == expr2.exprs.length - 1)
          return next;
        connect(next, from2 = node());
      }
    } else if (expr2.type == "star") {
      let loop2 = node();
      edge(from2, loop2);
      connect(compile(expr2.expr, loop2), loop2);
      return [edge(loop2)];
    } else if (expr2.type == "plus") {
      let loop2 = node();
      connect(compile(expr2.expr, from2), loop2);
      connect(compile(expr2.expr, loop2), loop2);
      return [edge(loop2)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i = 0; i < expr2.min; i++) {
        let next = node();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next = node();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i = 0; i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set = out[i][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node2) == -1)
            set.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i = 0, work = [match]; i < work.length; i++) {
    let state = work[i], dead = !state.validEnd, nodes = [];
    for (let j = 0; j < state.next.length; j++) {
      let { type, next } = state.next[j];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults2 = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr2 = attrs[attrName];
    if (!attr2.hasDefault)
      return null;
    defaults2[attrName] = attr2.default;
  }
  return defaults2;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr2 = attrs[name];
      if (attr2.hasDefault)
        given = attr2.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function initAttrs(attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(attrs[name]);
  return result;
}
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs = null, content, marks) {
    content = Fragment.from(content);
    this.checkContent(content);
    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment.empty, true);
    if (!after)
      return null;
    return new Node(this, attrs, content.append(after), Mark.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type with the given attributes.
  */
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i);
      } else if (copy2) {
        copy2.push(marks[i]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new _NodeType(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _ in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
};
var Attribute = class {
  constructor(options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
  }
  get isRequired() {
    return !this.hasDefault;
  }
};
var MarkType = class _MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(spec.attrs);
    this.excluded = null;
    let defaults2 = defaultAttrs(this.attrs);
    this.instance = defaults2 ? new Mark(this, defaults2) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark(this, computeAttrs(this.attrs, attrs));
  }
  /**
  @internal
  */
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set) {
    for (var i = 0; i < set.length; i++)
      if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
    return set;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (set[i].type == this)
        return set[i];
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
};
var Schema = class {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type, attrs = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text2, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text2, Mark.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(json) {
    return Node.fromJSON(this, json);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(json) {
    return Mark.fromJSON(this, json);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
};
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
var DOMParser = class _DOMParser {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    rules.forEach((rule) => {
      if (rule.tag)
        this.tags.push(rule);
      else if (rule.style)
        this.styles.push(rule);
    });
    this.normalizeLists = !this.tags.some((r2) => {
      if (!/^(ul|ol)\b/.test(r2.tag) || !r2.node)
        return false;
      let node = schema.nodes[r2.node];
      return node.contentMatch.matchType(node);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, options.from, options.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, options.from, options.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style2 = rule.style;
      if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema) {
    let result = [];
    function insert2(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert2(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert2(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new _DOMParser(schema, _DOMParser.schemaRules(schema)));
  }
};
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1;
var OPT_PRESERVE_WS_FULL = 2;
var OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
var NodeContext = class {
  constructor(type, attrs, marks, pendingMarks, solid, match, options) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.pendingMarks = pendingMarks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark.none;
    this.stashMarks = [];
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start2 = this.type.contentMatch, wrap2;
        if (wrap2 = start2.findWrapping(node.type)) {
          this.match = start2;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last = this.content[this.content.length - 1], m;
      if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        let text2 = last;
        if (last.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text2.withText(text2.text.slice(0, text2.text.length - m[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  popFromStashMark(mark) {
    for (let i = this.stashMarks.length - 1; i >= 0; i--)
      if (mark.eq(this.stashMarks[i]))
        return this.stashMarks.splice(i, 1)[0];
  }
  applyPending(nextType) {
    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {
      let mark = pending[i];
      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
        this.activeMarks = mark.addToSet(this.activeMarks);
        this.pendingMarks = mark.removeFromSet(this.pendingMarks);
      }
    }
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
};
var ParseContext = class {
  constructor(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom) {
    if (dom.nodeType == 3)
      this.addTextNode(dom);
    else if (dom.nodeType == 1)
      this.addElement(dom);
  }
  withStyleRules(dom, f) {
    let style2 = dom.getAttribute("style");
    if (!style2)
      return f();
    let marks = this.readStyles(parseStyles(style2));
    if (!marks)
      return;
    let [addMarks, removeMarks] = marks, top2 = this.top;
    for (let i = 0; i < removeMarks.length; i++)
      this.removePendingMark(removeMarks[i], top2);
    for (let i = 0; i < addMarks.length; i++)
      this.addPendingMark(addMarks[i]);
    f();
    for (let i = 0; i < addMarks.length; i++)
      this.removePendingMark(addMarks[i], top2);
    for (let i = 0; i < removeMarks.length; i++)
      this.addPendingMark(removeMarks[i]);
  }
  addTextNode(dom) {
    let value = dom.nodeValue;
    let top2 = this.top;
    if (top2.options & OPT_PRESERVE_WS_FULL || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!(top2.options & OPT_PRESERVE_WS)) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top2.content[top2.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (!(top2.options & OPT_PRESERVE_WS_FULL)) {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, matchAfter) {
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync, top2 = this.top, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (top2.content.length && top2.content[0].isInline && this.open) {
          this.open--;
          top2 = this.top;
        }
        sync = true;
        if (!top2.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom);
        return;
      }
      if (rule && rule.skip)
        this.addAll(dom);
      else
        this.withStyleRules(dom, () => this.addAll(dom));
      if (sync)
        this.sync(top2);
      this.needsBlock = oldNeedsBlock;
    } else {
      this.withStyleRules(dom, () => {
        this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : void 0);
      });
    }
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  }
  // Called for ignored nodes
  ignoreFallback(dom) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"));
  }
  // Run any style parser associated with the node's styles. Either
  // return an array of marks, or null to indicate some of the styles
  // had a rule with `ignore` set.
  readStyles(styles) {
    let add = Mark.none, remove = Mark.none;
    for (let i = 0; i < styles.length; i += 2) {
      for (let after = void 0; ; ) {
        let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
        if (!rule)
          break;
        if (rule.ignore)
          return null;
        if (rule.clearMark) {
          this.top.pendingMarks.concat(this.top.activeMarks).forEach((m) => {
            if (rule.clearMark(m))
              remove = m.addToSet(remove);
          });
        } else {
          add = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add);
        }
        if (rule.consuming === false)
          after = rule;
        else
          break;
      }
    }
    return [add, remove];
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, continueAfter) {
    let sync, nodeType, mark;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
      } else if (!this.insertNode(nodeType.create(rule.attrs))) {
        this.leafFallback(dom);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      mark = markType.create(rule.attrs);
      this.addPendingMark(mark);
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM);
    }
    if (sync && this.sync(startIn))
      this.open--;
    if (mark)
      this.removePendingMark(mark, startIn);
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, startIndex, endIndex) {
    let index = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end2 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end2; dom = dom.nextSibling, ++index) {
      this.findAtPoint(parent, index);
      this.addDOM(dom);
    }
    this.findAtPoint(parent, index);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node) {
    let route, sync;
    for (let depth = this.open; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid)
        break;
    }
    if (!route)
      return false;
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      this.enterInner(route[i], null, false);
    return true;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        this.enterInner(block);
    }
    if (this.findPlace(node)) {
      this.closeExtra();
      let top2 = this.top;
      top2.applyPending(node.type);
      if (top2.match)
        top2.match = top2.match.matchType(node.type);
      let marks = top2.activeMarks;
      for (let i = 0; i < node.marks.length; i++)
        if (!top2.type || top2.type.allowsMarkType(node.marks[i].type))
          marks = node.marks[i].addToSet(marks);
      top2.content.push(node.mark(marks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type, attrs, preserveWS) {
    let ok = this.findPlace(type.create(attrs));
    if (ok)
      this.enterInner(type, attrs, true, preserveWS);
    return ok;
  }
  // Open a node of the given type
  enterInner(type, attrs = null, solid = false, preserveWS) {
    this.closeExtra();
    let top2 = this.top;
    top2.applyPending(type);
    top2.match = top2.match && top2.match.matchType(type);
    let options = wsOptionsFor(type, preserveWS, top2.options);
    if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0)
      options |= OPT_OPEN_LEFT;
    this.nodes.push(new NodeContext(type, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
    this.open++;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(to) {
    for (let i = this.open; i >= 0; i--)
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j = content.length - 1; j >= 0; j--)
        pos += content[j].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset2) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset2)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && next.groups.indexOf(part) == -1)
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth; d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
  addPendingMark(mark) {
    let found2 = findSameMarkInSet(mark, this.top.pendingMarks);
    if (found2)
      this.top.stashMarks.push(found2);
    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
  }
  removePendingMark(mark, upto) {
    for (let depth = this.open; depth >= 0; depth--) {
      let level = this.nodes[depth];
      let found2 = level.pendingMarks.lastIndexOf(mark);
      if (found2 > -1) {
        level.pendingMarks = mark.removeFromSet(level.pendingMarks);
      } else {
        level.activeMarks = mark.removeFromSet(level.activeMarks);
        let stashMark = level.popFromStashMark(mark);
        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
          level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
      if (level == upto)
        break;
    }
  }
};
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles(style2) {
  let re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
  while (m = re.exec(style2))
    result.push(m[1], m[2].trim());
  return result;
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i = 0; i < match.edgeCount; i++) {
        let { type, next } = match.edge(i);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
function findSameMarkInSet(mark, set) {
  for (let i = 0; i < set.length; i++) {
    if (mark.eq(set[i]))
      return set[i];
  }
}
var DOMSerializer = class _DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc(options).createDocumentFragment();
    let top2 = target, active = [];
    fragment.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top2 = active.pop()[1];
        while (rendered < node.marks.length) {
          let add = node.marks[rendered++];
          let markDOM = this.serializeMark(add, node.isInline, options);
          if (markDOM) {
            active.push([add, top2]);
            top2.appendChild(markDOM.dom);
            top2 = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top2.appendChild(this.serializeNodeInner(node, options));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node, options) {
    let { dom, contentDOM } = _DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node, options = {}) {
    let dom = this.serializeNodeInner(node, options);
    for (let i = node.marks.length - 1; i >= 0; i--) {
      let wrap2 = this.serializeMark(node.marks[i], node.isInline, options);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && _DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));
  }
  /**
  Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
  the spec has a hole (zero) in it, `contentDOM` will point at the
  node with the hole.
  */
  static renderSpec(doc3, structure, xmlNS = null) {
    if (typeof structure == "string")
      return { dom: doc3.createTextNode(structure) };
    if (structure.nodeType != null)
      return { dom: structure };
    if (structure.dom && structure.dom.nodeType != null)
      return structure;
    let tagName = structure[0], space2 = tagName.indexOf(" ");
    if (space2 > 0) {
      xmlNS = tagName.slice(0, space2);
      tagName = tagName.slice(space2 + 1);
    }
    let contentDOM;
    let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);
    let attrs = structure[1], start2 = 1;
    if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
      start2 = 2;
      for (let name in attrs)
        if (attrs[name] != null) {
          let space3 = name.indexOf(" ");
          if (space3 > 0)
            dom.setAttributeNS(name.slice(0, space3), name.slice(space3 + 1), attrs[name]);
          else
            dom.setAttribute(name, attrs[name]);
        }
    }
    for (let i = start2; i < structure.length; i++) {
      let child = structure[i];
      if (child === 0) {
        if (i < structure.length - 1 || i > start2)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom, contentDOM: dom };
      } else {
        let { dom: inner, contentDOM: innerContent } = _DOMSerializer.renderSpec(doc3, child, xmlNS);
        dom.appendChild(inner);
        if (innerContent) {
          if (contentDOM)
            throw new RangeError("Multiple content holes");
          contentDOM = innerContent;
        }
      }
    }
    return { dom, contentDOM };
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
};
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc(options) {
  return options.document || window.document;
}

// node_modules/prosemirror-transform/dist/index.js
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index, offset2) {
  return index + offset2 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var DEL_BEFORE = 1;
var DEL_AFTER = 2;
var DEL_ACROSS = 4;
var DEL_SIDE = 8;
var MapResult = class {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
};
var StepMap = class _StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && _StepMap.empty)
      return _StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end2 = start2 + oldSize;
      if (pos <= end2) {
        let side = !oldSize ? assoc : pos == start2 ? -1 : pos == end2 ? 1 : assoc;
        let result = start2 + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start2 : end2) ? null : makeRecover(i / 3, pos - start2);
        let del2 = pos == start2 ? DEL_AFTER : pos == end2 ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start2 : pos != end2)
          del2 |= DEL_SIDE;
        return new MapResult(result, del2, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end2 = start2 + oldSize;
      if (pos <= end2 && i == index * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i], oldStart = start2 - (this.inverted ? diff : 0), newStart = start2 + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new _StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n) {
    return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
};
StepMap.empty = new StepMap([]);
var Mapping = class _Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps = [], mirror, from2 = 0, to = maps.length) {
    this.maps = maps;
    this.mirror = mirror;
    this.from = from2;
    this.to = to;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from2 = 0, to = this.maps.length) {
    return new _Mapping(this.maps, this.mirror, from2, to);
  }
  /**
  @internal
  */
  copy() {
    return new _Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map2, mirrors) {
    this.to = this.maps.push(map2);
    if (mirrors != null)
      this.setMirror(this.maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new _Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this.maps[i].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map2 = this.maps[i], result = map2.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this.maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
};
var stepsByID = /* @__PURE__ */ Object.create(null);
var Step = class {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
};
var StepResult = class _StepResult {
  /**
  @internal
  */
  constructor(doc3, failed) {
    this.doc = doc3;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc3) {
    return new _StepResult(doc3, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message) {
    return new _StepResult(null, message);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc3, from2, to, slice2) {
    try {
      return _StepResult.ok(doc3.replace(from2, to, slice2));
    } catch (e) {
      if (e instanceof ReplaceError)
        return _StepResult.fail(e.message);
      throw e;
    }
  }
};
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
var AddMarkStep = class _AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _AddMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new _AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addMark", AddMarkStep);
var RemoveMarkStep = class _RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to);
    let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc3), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _RemoveMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new _RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeMark", RemoveMarkStep);
var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i = 0; i < node.marks.length; i++)
          if (!node.marks[i].isInSet(newSet))
            return new _AddNodeMarkStep(this.pos, node.marks[i]);
        return new _AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new _AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addNodeMark", AddNodeMarkStep);
var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new _RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
var ReplaceStep = class _ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from2, to, slice2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.slice = slice2;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && contentBetween(doc3, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc3, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc3) {
    return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deletedAcross && to.deletedAcross)
      return null;
    return new _ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice);
  }
  merge(other) {
    if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new _ReplaceStep(other.from, this.to, slice2, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
};
Step.jsonID("replace", ReplaceStep);
var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from2, to, gapFrom, gapTo, slice2, insert2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice2;
    this.insert = insert2;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc3.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc3, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc3) {
    let gap = this.gapTo - this.gapFrom;
    return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
      return null;
    return new _ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
};
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc3, from2, to) {
  let $from = doc3.resolve(from2), dist = to - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr2, from2, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr2.doc.nodesBetween(from2, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start2 = Math.max(pos, from2), end2 = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start2 && removing.mark.eq(marks[i]))
            removing.to = end2;
          else
            removed.push(removing = new RemoveMarkStep(start2, end2, marks[i]));
        }
      }
      if (adding && adding.to == start2)
        adding.to = end2;
      else
        added.push(adding = new AddMarkStep(start2, end2, mark));
    }
  });
  removed.forEach((s) => tr2.step(s));
  added.forEach((s) => tr2.step(s));
}
function removeMark(tr2, from2, to, mark) {
  let matched = [], step = 0;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set = node.marks, found2;
      while (found2 = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found2);
        set = found2.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end2 = Math.min(pos + node.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style2 = toRemove[i], found2;
        for (let j = 0; j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step - 1 && style2.eq(matched[j].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end2;
          found2.step = step;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from2), to: end2, step });
        }
      }
    }
  });
  matched.forEach((m) => tr2.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr2, pos, parentType, match = parentType.contentMatch) {
  let node = tr2.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i), end2 = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end2, Slice.empty));
    } else {
      match = allowed;
      for (let j = 0; j < child.marks.length; j++)
        if (!parentType.allowsMarkType(child.marks[j].type))
          tr2.step(new RemoveMarkStep(cur, end2, child.marks[j]));
      if (child.isText && !parentType.spec.code) {
        let m, newline = /\r?\n|\r/g, slice2;
        while (m = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
        }
      }
    }
    cur = end2;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment.empty, true);
    tr2.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = replSteps.length - 1; i >= 0; i--)
    tr2.step(replSteps[i]);
}
function canCut(node, start2, end2) {
  return (start2 == 0 || node.canReplace(start2, node.childCount)) && (end2 == node.childCount || node.canReplace(0, end2));
}
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth; ; --depth) {
    let node = range.$from.node(depth);
    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
      break;
  }
  return null;
}
function lift(tr2, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start2 = gapStart, end2 = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start2--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end2++;
    }
  tr2.step(new ReplaceAroundStep(start2, end2, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex; innerMatch && i < endIndex; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr2, range, wrappers) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      let match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let start2 = range.start, end2 = range.end;
  tr2.step(new ReplaceAroundStep(start2, end2, start2, end2, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType(tr2, from2, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr2.steps.length;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr2.doc, tr2.mapping.slice(mapFrom).map(pos), type)) {
      tr2.clearIncompatible(tr2.mapping.slice(mapFrom).map(pos, 1), type);
      let mapping = tr2.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr2.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
      return false;
    }
  });
}
function canChangeType(doc3, pos, type) {
  let $pos = doc3.resolve(pos), index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type);
}
function setNodeMarkup(tr2, pos, type, attrs, marks) {
  let node = tr2.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr2.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr2.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc3, pos, depth = 1, typesAfter) {
  let $pos = doc3.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
    let node = $pos.node(d), index2 = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index2, node.childCount);
    let overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i] || node;
    if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr2, pos, depth = 1, typesAfter) {
  let $pos = tr2.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = Fragment.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr2.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc3, pos) {
  let $pos = doc3.resolve(pos), index = $pos.index();
  return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
}
function joinable2(a, b) {
  return !!(a && b && !a.isLeaf && a.canAppend(b));
}
function joinPoint(doc3, pos, dir = -1) {
  let $pos = doc3.resolve(pos);
  for (let d = $pos.depth; ; d--) {
    let before, after, index = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index++;
      after = $pos.node(d).maybeChild(index);
    } else {
      before = $pos.node(d).maybeChild(index - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index, index + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join(tr2, pos, depth) {
  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
  tr2.step(step);
}
function insertPoint(doc3, pos, nodeType) {
  let $pos = doc3.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType))
        return $pos.before(d + 1);
      if (index > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType))
        return $pos.after(d + 1);
      if (index < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc3, pos, slice2) {
  let $pos = doc3.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content = slice2.content;
  for (let i = 0; i < slice2.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc3, from2, to = from2, slice2 = Slice.empty) {
  if (from2 == to && !slice2.size)
    return null;
  let $from = doc3.resolve(from2), $to = doc3.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
var Fitter = class {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice2 = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
    if (slice2.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice2);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
      let node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        this.openFrontierNode(wrap2[i]);
    let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
    let openStart = slice2.openStart - sliceDepth;
    let taken = 0, add = [];
    let { match, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i = 0; i < inject.childCount; i++)
        add.push(inject.child(i));
      match = match.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment; i < openEndCount; i++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top2 = this.frontier[this.depth], level;
    if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan:
      for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        let { match, type } = this.frontier[i];
        let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        let fit = contentAfterFits($to, i, type, match, dropInner);
        if (!fit)
          continue;
        for (let d = i - 1; d >= 0; d--) {
          let { match: match2, type: type2 } = this.frontier[d];
          let matches2 = contentAfterFits($to, d, type2, match2, true);
          if (!matches2 || matches2.childCount)
            continue scan;
        }
        return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
      }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d = close2.depth + 1; d <= $to.depth; d++) {
      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
      this.openFrontierNode(node.type, node.attrs, add);
    }
    return $to;
  }
  openFrontierNode(type, attrs = null, content) {
    let top2 = this.frontier[this.depth];
    top2.match = top2.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add = open.match.fillBefore(Fragment.empty, true);
    if (add.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add);
  }
};
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i = 0; i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null;
}
function invalidMarks(type, fragment, start2) {
  for (let i = start2; i < fragment.childCount; i++)
    if (!type.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr2, from2, to, slice2) {
  if (!slice2.size)
    return tr2.deleteRange(from2, to);
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr2.step(new ReplaceStep(from2, to, slice2));
  let targetDepths = coveredDepths($from, tr2.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content = slice2.content, i = 0; ; i++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i == slice2.openStart)
      break;
    content = node.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j = slice2.openStart; j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
    let insert2 = leftNodes[openDepth];
    if (!insert2)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert2.type, insert2.marks))
        return tr2.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr2.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr2.replace(from2, to, slice2);
    if (tr2.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start2 = match.fillBefore(fragment).append(fragment);
    fragment = start2.append(match.matchFragment(start2).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr2, from2, to, node) {
  if (!node.isInline && from2 == to && tr2.doc.resolve(from2).parent.content.size) {
    let point = insertPoint(tr2.doc, from2, node.type);
    if (point != null)
      from2 = to = point;
  }
  tr2.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange(tr2, from2, to) {
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr2.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr2.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
      return tr2.delete($from.before(d), to);
  }
  tr2.delete(from2, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start2 = $from.start(d);
    if (start2 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start2 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start2 - 1)
      result.push(d);
  }
  return result;
}
var AttrStep = class _AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr2, value) {
    super();
    this.pos = pos;
    this.attr = attr2;
    this.value = value;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node.attrs)
      attrs[name] = node.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node.type.create(attrs, null, node.marks);
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new _AttrStep(json.pos, json.attr, json.value);
  }
};
Step.jsonID("attr", AttrStep);
var DocAttrStep = class _DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr2, value) {
    super();
    this.attr = attr2;
    this.value = value;
  }
  apply(doc3) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in doc3.attrs)
      attrs[name] = doc3.attrs[name];
    attrs[this.attr] = this.value;
    let updated = doc3.type.create(attrs, doc3.content, doc3.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _DocAttrStep(this.attr, doc3.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new _DocAttrStep(json.attr, json.value);
  }
};
Step.jsonID("docAttr", DocAttrStep);
var TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
var Transform = class {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc3) {
    this.doc = doc3;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc3;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from2, to = from2, slice2 = Slice.empty) {
    let step = replaceStep(this.doc, from2, to, slice2);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from2, to, content) {
    return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from2, to) {
    return this.replace(from2, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from2, to, slice2) {
    replaceRange(this, from2, to, slice2);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from2, to, node) {
    replaceRangeWith(this, from2, to, node);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from2, to) {
    deleteRange(this, from2, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range, target) {
    lift(this, range, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range, wrappers) {
    wrap(this, range, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from2, to = from2, type, attrs = null) {
    setBlockType(this, from2, to, type, attrs);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type, attrs = null, marks) {
    setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr2, value) {
    this.step(new AttrStep(pos, attr2, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr2, value) {
    this.step(new DocAttrStep(attr2, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    if (!(mark instanceof Mark)) {
      let node = this.doc.nodeAt(pos);
      if (!node)
        throw new RangeError("No node at position " + pos);
      mark = mark.isInSet(node.marks);
      if (!mark)
        return this;
    }
    this.step(new RemoveNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from2, to, mark) {
    addMark(this, from2, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from2, to, mark) {
    removeMark(this, from2, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
};

// node_modules/prosemirror-state/dist/index.js
var classesById = /* @__PURE__ */ Object.create(null);
var Selection = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr2, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      tr2.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd(tr2, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr2, node) {
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr2.deleteRange(from2, to);
      } else {
        tr2.replaceRangeWith(from2, to, node);
        selectionToInsertionEnd(tr2, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc3) {
    return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc3) {
    return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc3, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc3, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
};
Selection.prototype.visible = true;
var SelectionRange = class {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
};
var warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
var TextSelection = class _TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc3, mapping) {
    let $head = doc3.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc3.resolve(mapping.map(this.anchor));
    return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr2, content = Slice.empty) {
    super.replace(tr2, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr2.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new _TextSelection(doc3.resolve(json.anchor), doc3.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc3, anchor, head = anchor) {
    let $anchor = doc3.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new _TextSelection($anchor, $head);
  }
};
Selection.jsonID("text", TextSelection);
var TextBookmark = class _TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc3) {
    return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));
  }
};
var NodeSelection = class _NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc3, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc3.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new _NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof _NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new _NodeSelection(doc3.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc3, from2) {
    return new _NodeSelection(doc3.resolve(from2));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
};
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
var NodeBookmark = class _NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
};
var AllSelection = class _AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc3) {
    super(doc3.resolve(0), doc3.resolve(doc3.content.size));
  }
  replace(tr2, content = Slice.empty) {
    if (content == Slice.empty) {
      tr2.delete(0, tr2.doc.content.size);
      let sel = Selection.atStart(tr2.doc);
      if (!sel.eq(tr2.selection))
        tr2.setSelection(sel);
    } else {
      super.replace(tr2, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc3) {
    return new _AllSelection(doc3);
  }
  map(doc3) {
    return new _AllSelection(doc3);
  }
  eq(other) {
    return other instanceof _AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
};
Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map() {
    return this;
  },
  resolve(doc3) {
    return new AllSelection(doc3);
  }
};
function findSelectionIn(doc3, node, pos, index, dir, text2 = false) {
  if (node.inlineContent)
    return TextSelection.create(doc3, pos);
  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text2);
      if (inner)
        return inner;
    } else if (!text2 && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr2, startLen, bias) {
  let last = tr2.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr2.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map2 = tr2.mapping.maps[last], end2;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 == null)
      end2 = newTo;
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end2), bias));
}
var UPDATED_SEL = 1;
var UPDATED_MARKS = 2;
var UPDATED_SCROLL = 4;
var Transaction = class extends Transform {
  /**
  @internal
  */
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    super.addStep(step, doc3);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time) {
    this.time = time;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice2) {
    this.selection.replace(this, slice2);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
    selection.replaceWith(this, node);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text2, from2, to) {
    let schema = this.doc.type.schema;
    if (from2 == null) {
      if (!text2)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text2), true);
    } else {
      if (to == null)
        to = from2;
      to = to == null ? from2 : to;
      if (!text2)
        return this.deleteRange(from2, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from2);
        marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from2, to, schema.text(text2, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _ in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
};
function bind(f, self) {
  return !self || !f ? f : f.bind(self);
}
var FieldDesc = class {
  constructor(name, desc, self) {
    this.name = name;
    this.init = bind(desc.init, self);
    this.apply = bind(desc.apply, self);
  }
};
var baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr2) {
      return tr2.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance9) {
      return config.selection || Selection.atStart(instance9.doc);
    },
    apply(tr2) {
      return tr2.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr2, _marks, _old, state) {
      return state.selection.$cursor ? tr2.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr2, prev) {
      return tr2.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
var Configuration = class {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
};
var EditorState = class _EditorState {
  /**
  @internal
  */
  constructor(config) {
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr2) {
    return this.applyTransaction(tr2).state;
  }
  /**
  @internal
  */
  filterTransaction(tr2, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr2, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr2 = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr2 && newState.filterTransaction(tr2, i)) {
            tr2.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0; j < this.config.plugins.length; j++)
                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr2);
            newState = newState.applyInner(tr2);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr2) {
    if (!tr2.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new _EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr2, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction(this);
  }
  /**
  Create a new state.
  */
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance9 = new _EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance9[$config.fields[i].name] = $config.fields[i].init(config, instance9);
    return instance9;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance9 = new _EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance9[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance9);
    }
    return instance9;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance9 = new _EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance9.doc = Node.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance9.selection = Selection.fromJSON(instance9.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance9.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance9[field.name] = state.fromJSON.call(plugin, config, json[prop], instance9);
              return;
            }
          }
        instance9[field.name] = field.init(config, instance9);
      }
    });
    return instance9;
  }
};
function bindProps(obj, self, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self, {});
    target[prop] = val;
  }
  return target;
}
var Plugin = class {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};
var keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
var PluginKey = class {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};

// node_modules/prosemirror-view/dist/index.js
var domIndex = function(node) {
  for (var index = 0; ; index++) {
    node = node.previousSibling;
    if (!node)
      return index;
  }
};
var parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function(node, from2, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from2 || 0);
  return range;
};
var isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false")
        return false;
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isOnEdge(node, offset2, parent) {
  for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc3) {
  let elt = doc3.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc3, x, y) {
  if (doc3.caretPositionFromPoint) {
    try {
      let pos = doc3.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: pos.offset };
    } catch (_) {
    }
  }
  if (doc3.caretRangeFromPoint) {
    let range = doc3.caretRangeFromPoint(x, y);
    if (range)
      return { node: range.startContainer, offset: range.startOffset };
  }
}
var nav = typeof navigator != "undefined" ? navigator : null;
var doc2 = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
var windows = nav ? /Win/.test(nav.platform) : false;
var android = /Android \d/.test(agent);
var webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc3) {
  return {
    left: 0,
    right: doc3.documentElement.clientWidth,
    top: 0,
    bottom: doc3.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc3 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent)
      break;
    if (parent.nodeType != 1)
      continue;
    let elt = parent;
    let atTop = elt == doc3.body;
    let bounding = atTop ? windowRect(doc3) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc3.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position))
      break;
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack = [], doc3 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc3)
      break;
  }
  return stack;
}
function resetScrollPos({ refDOM, refTop, stack }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (let i = 0; i < stack.length; i++) {
    let { dom, top: top2, left: left2 } = stack[i];
    if (dom.scrollTop != top2 + dTop)
      dom.scrollTop = top2 + dTop;
    if (dom.scrollLeft != left2)
      dom.scrollLeft = left2;
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset2 = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset: offset2 };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange();
  for (let i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset: offset2 } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset2, bias);
}
function posFromCaret(view, node, offset2, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true);
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent && !sawBlock || !desc.contentDOM)) {
      let rect = desc.dom.getBoundingClientRect();
      if (desc.node.isBlock && desc.parent && !sawBlock) {
        sawBlock = true;
        if (rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset2, -1);
}
function elementFromPoint(element2, coords, box) {
  let len = element2.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      let child = element2.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element2;
}
function posAtCoords(view, coords) {
  let doc3 = view.dom.ownerDocument, node, offset2 = 0;
  let caret = caretFromPoint(doc3, coords.left, coords.top);
  if (caret)
    ({ node, offset: offset2 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p = elt; node && p; p = parentNode(p))
      if (p.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset2 = Math.min(offset2, node.childNodes.length);
      if (offset2 < node.childNodes.length) {
        let next = node.childNodes[offset2], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset2++;
      }
    }
    let prev;
    if (webkit && offset2 && node.nodeType == 1 && (prev = node.childNodes[offset2 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset2--;
    if (node == view.dom && offset2 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset2 == 0 || node.nodeType != 1 || node.childNodes[offset2 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset2, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset: offset2, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset2 : offset2 == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset2, offset2), side);
      if (gecko && offset2 && /\s/.test(node.nodeValue[offset2 - 1]) && offset2 < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from2 = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
      let before = node.childNodes[offset2 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset2 < nodeSize(node)) {
      let after = node.childNodes[offset2];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
    let before = node.childNodes[offset2 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset2 < nodeSize(node)) {
    let after = node.childNodes[offset2];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left2) {
  if (rect.width == 0)
    return rect;
  let x = left2 ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top2) {
  if (rect.height == 0)
    return rect;
  let y = top2 ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
var cachedState = null;
var cachedDir = null;
var cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
var NOT_DIRTY = 0;
var CHILD_DIRTY = 1;
var CONTENT_DIRTY = 2;
var NODE_DIRTY = 3;
var ViewDesc = class {
  constructor(parent, children2, dom, contentDOM) {
    this.parent = parent;
    this.children = children2;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size = 0;
    for (let i = 0; i < this.children.length; i++)
      size += this.children[i].size;
    return size;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset2, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset2 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset2];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset2 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset2 == 0)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd == null && offset2 == dom.childNodes.length)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = true;
            break;
          }
          if (search.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset2, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset2, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (offset2 == pos && end2 != offset2) {
        while (!child.border && child.children.length)
          child = child.children[0];
        return child;
      }
      if (pos < end2)
        return child.descAt(pos - offset2 - child.border);
      offset2 = end2;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset2 = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = curPos + child.size;
      if (end2 > pos || child instanceof TrailingHackViewDesc) {
        offset2 = pos - curPos;
        break;
      }
      curPos = end2;
    }
    if (offset2)
      return this.children[i].domFromPos(offset2 - this.children[i].border, side);
    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev, enter2 = true;
      for (; ; i--, enter2 = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter2 && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter2 = true;
      for (; ; i++, enter2 = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter2 && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from2, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset2 = base2, i = 0; ; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (fromOffset == -1 && from2 <= end2) {
        let childBase = offset2 + child.border;
        if (from2 >= childBase && to <= end2 - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = offset2;
        for (let j = i; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end2 > to || i == this.children.length - 1)) {
        to = end2;
        for (let j = i + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset2 = end2;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset: offset2 } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset2 == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset2];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, root, force = false) {
    let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (from2 > offset2 && to < end2)
        return child.setSelection(anchor - offset2 - child.border, head - offset2 - child.border, root, force);
      offset2 = end2;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = root.getSelection();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node, offset: offset2 } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset2 && node.nodeValue[offset2 - 1] == "\n");
        if (brKludge && offset2 == node.nodeValue.length) {
          for (let scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset2 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
      let after = domSel.focusNode.childNodes[domSel.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from2, to) {
    for (let offset2 = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (offset2 == end2 ? from2 <= end2 && to >= offset2 : from2 < end2 && to > offset2) {
        let startInside = offset2 + child.border, endInside = end2 - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == offset2 || to == end2 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset2 = end2;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
};
var WidgetViewDesc = class extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self)
          return pos;
        if (self.parent)
          return self.parent.posBeforeChild(self);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get side() {
    return this.widget.type.side;
  }
};
var CompositionViewDesc = class extends ViewDesc {
  constructor(parent, dom, textDOM, text2) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text2;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset2) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset2 ? this.size : 0);
    return this.posAtStart + offset2;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
};
var MarkViewDesc = class _MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
  }
  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
    return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from2, to, view) {
    let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size = this.size;
    if (to < size)
      nodes = replaceNodes(nodes, to, size, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (let i = 0; i < nodes.length; i++)
      nodes[i].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
};
var NodeViewDesc = class _NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      ({ dom, contentDOM } = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)));
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i))
        ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))
        ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off))
        ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from2, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
      return null;
    let sel = view.domSelectionRange();
    let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text2 = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text2, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text: text2 };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text: text2 }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text2);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text2.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.removeAttribute("draggable");
  }
  get domAtom() {
    return this.node.isAtom;
  }
};
function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc3);
  let docView = new NodeViewDesc(void 0, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
var TextViewDesc = class _TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset2, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    return super.localPosFromDOM(dom, offset2, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from2, to, view) {
    let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
    return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
};
var TrailingHackViewDesc = class extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
};
var CustomNodeViewDesc = class extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, root, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : super.setSelection(anchor, head, root, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
};
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
var OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top2];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top2 = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top2 = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top2.class = (top2.class ? top2.class + " " : "") + val;
      else if (name == "style")
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      else if (name != "nodeName")
        top2[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom.classList.add(curList[i]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].type.eq(b[i].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ViewTreeUpdater = class {
  constructor(top2, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top2;
    this.preMatch = preMatch(top2.node.content, top2);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start2, end2) {
    if (start2 == end2)
      return;
    for (let i = start2; i < end2; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start2, end2 - start2);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        let next = this.top.children[i];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index) {
    let found2 = -1, targetDesc;
    if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index, view) {
    let child = this.top.children[index];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
};
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer:
    while (fI > 0) {
      let desc;
      for (; ; ) {
        if (descI) {
          let next = curDesc.children[descI - 1];
          if (next instanceof MarkViewDesc) {
            curDesc = next;
            descI = next.children.length;
          } else {
            desc = next;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      let node = desc.node;
      if (!node)
        continue;
      if (node != frag.child(fI - 1))
        break;
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset2 = 0;
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset2, child), i);
      offset2 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset2) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index;
    if (restNode) {
      index = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset2)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
      active.push(locals[decoIndex++]);
    let end2 = offset2 + child.nodeSize;
    if (child.isText) {
      let cutAt = end2;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end2) {
        restNode = child.cut(cutAt - offset2);
        child = child.cut(0, cutAt - offset2);
        end2 = cutAt;
        index = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end2)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset2, child), index);
    offset2 = end2;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function nearbyTextNode(node, offset2) {
  for (; ; ) {
    if (node.nodeType == 3)
      return node;
    if (node.nodeType == 1 && offset2 > 0) {
      if (node.childNodes.length > offset2 && node.childNodes[offset2].nodeType == 3)
        return node.childNodes[offset2];
      node = node.childNodes[offset2 - 1];
      offset2 = nodeSize(node);
    } else if (node.nodeType == 1 && offset2 < node.childNodes.length) {
      node = node.childNodes[offset2];
      offset2 = 0;
    } else {
      return null;
    }
  }
}
function findTextInFragment(frag, text2, from2, to) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      if (pos >= to && str.slice(to - text2.length - childStart, to - childStart) == text2)
        return to - text2.length;
      let found2 = childStart < to ? str.lastIndexOf(text2, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text2.length + childStart >= from2)
        return childStart + found2;
      if (from2 == to && str.length >= to + text2.length - childStart && str.slice(to - childStart, to - childStart + text2.length) == text2)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  let result = [];
  for (let i = 0, off = 0; i < nodes.length; i++) {
    let child = nodes[i], start2 = off, end2 = off += child.size;
    if (start2 >= to || end2 <= from2) {
      result.push(child);
    } else {
      if (start2 < from2)
        result.push(child.slice(0, from2 - start2, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end2 > to)
        result.push(child.slice(to - start2, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc3 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc3.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
    }
  } else {
    let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    if (anchor < 0)
      return null;
    $anchor = doc3.resolve(anchor);
  }
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset2 } = view.docView.domFromPos(pos, 0);
  let after = offset2 < node.childNodes.length ? node.childNodes[offset2] : null;
  let before = offset2 ? node.childNodes[offset2 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element2) {
  element2.contentEditable = "true";
  if (safari && element2.draggable) {
    element2.draggable = false;
    element2.wasDraggable = true;
  }
  return element2;
}
function resetEditable(element2) {
  element2.contentEditable = "false";
  if (element2.wasDraggable) {
    element2.draggable = true;
    element2.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc3 = view.dom.ownerDocument;
  doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset2) {
      doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range = document.createRange();
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    range.setEnd(node.parentNode, domIndex(node) + 1);
  else
    range.setEnd(node, 0);
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset2 < nodeLen(node) && isIgnorable(node.childNodes[offset2], -1))
    force = true;
  for (; ; ) {
    if (offset2 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset2 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset2;
        } else if (before.nodeType == 3) {
          node = before;
          offset2 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = 0;
      } else {
        node = prev;
        offset2 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset2);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset2];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset2;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = len = 0;
      } else {
        node = next;
        offset2 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset2) {
  while (node && offset2 == node.childNodes.length && !hasBlockDesc(node)) {
    offset2 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset2 < node.childNodes.length) {
    let next = node.childNodes[offset2];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = 0;
  }
}
function textNodeBefore(node, offset2) {
  while (node && !offset2 && !hasBlockDesc(node)) {
    offset2 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset2) {
    let next = node.childNodes[offset2 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset2) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset2)) {
      node = after;
      offset2 = 0;
    } else if (before = textNodeBefore(node, offset2)) {
      node = before;
      offset2 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset2);
    range.setStart(node, offset2);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset2);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed = getComputedStyle(view.dom).direction;
  return computed == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty3 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty3)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr2 = view.state.tr;
    if (dir < 0)
      tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr2);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code = event.keyCode, mods = getMods(event);
  if (code == 8 || mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac && code == 66 && mods == "c") {
    let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac && code == 70 && mods == "c") {
    let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 38 || mac && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc3 = detachedDoc(), wrap2 = doc3.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc3.createElement(needsWrap[i]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text2 = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap2, text: text2 };
}
function parseFromClipboard(view, text2, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html && !text2)
    return null;
  let asText = text2 && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text2 = f(text2, inCode || plainText, view);
    });
    if (inCode)
      return text2 ? new Slice(Fragment.from(view.state.schema.text(text2.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text2, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text2.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p = dom.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0; i--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view);
  });
  return slice2;
}
var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap2 = match.findWrapping(node.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap2);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap2, from2 = 0) {
  for (let i = wrap2.length - 1; i >= from2; i--)
    node = wrap2[i].create(null, Fragment.from(node));
  return node;
}
function addToSibling(wrap2, lastWrap, node, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = html;
  if (wrap2)
    for (let i = 0; i < wrap2.length; i++)
      elt = elt.querySelector(wrap2[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes.length; i++) {
    let node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema = slice2.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i = array.length - 2; i >= 0; i -= 2) {
    let type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
var handlers = {};
var editHandlers = {};
var passiveHandlers = { touchstart: true, touchmove: true };
var InputState = class {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "" };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastAndroidDelete = 0;
    this.composing = false;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
};
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now2 = Date.now();
    view.input.lastIOSEnter = now2;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now2) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text2 = String.fromCharCode(event.charCode);
    if (!/[\r\n]/.test(text2) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text2)))
      view.dispatch(view.state.tr.insertText(text2).scrollIntoView());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  let tr2 = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr2.setMeta("pointer", true);
  view.dispatch(tr2);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc3 = view.state.doc;
  if (inside == -1) {
    if (doc3.inlineContent) {
      updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc3.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now2 = Date.now(), type = "singleClick";
  if (now2 - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now2, x: event.clientX, y: event.clientY, type };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
var MouseDown = class {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
};
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$from;
    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node = sel.focusNode, offset2 = sel.focusOffset; node && node.nodeType == 1 && offset2 != 0; ) {
          let before = offset2 < 0 ? node.lastChild : node.childNodes[offset2 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            view.domSelection().collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset2 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, forceUpdate = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection))
      view.dispatch(view.state.tr.setSelection(sel));
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut2 = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom, text: text2 } = serializeForClipboard(view, slice2);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text2);
  } else {
    captureCopy(view, dom);
  }
  if (cut2)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text2, html, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text2, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr2 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr2.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  let text2 = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text2)
    return text2;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
var Dragging = class {
  constructor(slice2, move, node) {
    this.slice = slice2;
    this.move = move;
    this.node = node;
  }
};
var dragCopyModifier = mac ? "altKey" : "ctrlKey";
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let slice2 = (node || view.state.selection).content(), { dom, text: text2 } = serializeForClipboard(view, slice2);
  event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text2);
  view.dragging = new Dragging(slice2, !event[dragCopyModifier], node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
  } else {
    slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move = !!(dragging && !event[dragCopyModifier]);
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr2 = view.state.tr;
  if (move) {
    let { node } = dragging;
    if (node)
      node.replace(tr2);
    else
      tr2.deleteSelection();
  }
  let pos = tr2.mapping.map(insertPos);
  let isNode = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr2.doc;
  if (isNode)
    tr2.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr2.replaceRange(pos, pos, slice2);
  if (tr2.doc.eq(beforeInsert))
    return;
  let $pos = tr2.doc.resolve(pos);
  if (isNode && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr2.setSelection(new NodeSelection($pos));
  } else {
    let end2 = tr2.mapping.map(insertPos);
    tr2.mapping.maps[tr2.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end2 = newTo);
    tr2.setSelection(selectionBetween(view, $pos, tr2.doc.resolve(end2)));
  }
  view.focus();
  view.dispatch(tr2.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (let p in a)
    if (a[p] !== b[p])
      return false;
  for (let p in b)
    if (!(p in a))
      return false;
  return true;
}
var WidgetType = class _WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset2, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
};
var InlineType = class _InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
    return from2 >= to ? null : new Decoration(from2, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof _InlineType;
  }
  destroy() {
  }
};
var NodeType2 = class _NodeType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset2, to.pos - offset2, this);
  }
  valid(node, span) {
    let { index, offset: offset2 } = node.content.findIndex(span.from), child;
    return offset2 == span.from && !(child = node.child(index)).isText && offset2 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
};
var Decoration = class _Decoration {
  /**
  @internal
  */
  constructor(from2, to, type) {
    this.from = from2;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from2, to) {
    return new _Decoration(from2, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset2 = 0) {
    return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset2, oldOffset) {
    return this.type.map(mapping, this, offset2, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new InlineType(attrs, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new NodeType2(attrs, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
};
var none = [];
var noSpec = {};
var DecorationSet = class _DecorationSet {
  /**
  @internal
  */
  constructor(local, children2) {
    this.local = local.length ? local : none;
    this.children = children2.length ? children2 : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc3, decorations) {
    return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty2;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start2, end2, predicate) {
    let result = [];
    this.findInner(start2 == null ? 0 : start2, end2 == null ? 1e9 : end2, result, 0, predicate);
    return result;
  }
  findInner(start2, end2, result, offset2, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end2 && span.to >= start2 && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset2, span.to + offset2));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end2 && this.children[i + 1] > start2) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start2 - childOff, end2 - childOff, result, offset2 + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc3, options) {
    if (this == empty2 || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc3, 0, 0, options || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node, offset2, oldOffset, options) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset2, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset2, oldOffset, options);
    else
      return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty2;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc3, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty2)
      return _DecorationSet.create(doc3, decorations);
    return this.addInner(doc3, decorations, 0);
  }
  addInner(doc3, decorations, offset2) {
    let children2, childIndex = 0;
    doc3.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset2, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children2)
        children2 = this.children.slice();
      while (childIndex < children2.length && children2[childIndex] < childOffset)
        childIndex += 3;
      if (children2[childIndex] == childOffset)
        children2[childIndex + 2] = children2[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children2.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc3, local[i]))
        local.splice(i--, 1);
    return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children2 || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty2)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset2) {
    let children2 = this.children, local = this.local;
    for (let i = 0; i < children2.length; i += 3) {
      let found2;
      let from2 = children2[i] + offset2, to = children2[i + 1] + offset2;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from2 && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children2 == this.children)
        children2 = this.children.slice();
      let removed = children2[i + 2].removeInner(found2, from2 + 1);
      if (removed != empty2) {
        children2[i + 2] = removed;
      } else {
        children2.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset2)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children2 == this.children && local == this.local)
      return this;
    return local.length || children2.length ? new _DecorationSet(local, children2) : empty2;
  }
  /**
  @internal
  */
  forChild(offset2, node) {
    if (this == empty2)
      return this;
    if (node.isLeaf)
      return _DecorationSet.empty;
    let child, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset2) {
        if (this.children[i] == offset2)
          child = this.children[i + 2];
        break;
      }
    let start2 = offset2 + 1, end2 = start2 + node.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end2 && dec.to > start2 && dec.type instanceof InlineType) {
        let from2 = Math.max(start2, dec.from) - start2, to = Math.min(end2, dec.to) - start2;
        if (from2 < to)
          (local || (local = [])).push(dec.copy(from2, to));
      }
    }
    if (local) {
      let localSet = new _DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty2;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  /**
  @internal
  */
  localsInner(node) {
    if (this == empty2)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result;
  }
};
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
var empty2 = DecorationSet.empty;
var DecorationGroup = class _DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc3) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
    return _DecorationGroup.from(mappedDecos);
  }
  forChild(offset2, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i = 0; i < this.members.length; i++) {
      let result = this.members[i].forChild(offset2, child);
      if (result == empty2)
        continue;
      if (result instanceof _DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return _DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++)
          result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty2;
      case 1:
        return members[0];
      default:
        return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r2, m) => r2.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
};
function mapChildren(oldChildren, newLocal, mapping, node, offset2, oldOffset, options) {
  let children2 = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0; i2 < children2.length; i2 += 3) {
        let end2 = children2[i2 + 1];
        if (end2 < 0 || oldStart > end2 + baseOffset - moved)
          continue;
        let start2 = children2[i2] + baseOffset - moved;
        if (oldEnd >= start2) {
          children2[i2 + 1] = oldStart <= start2 ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children2[i2] += dSize;
          children2[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0; i < children2.length; i += 3)
    if (children2[i + 1] < 0) {
      if (children2[i + 1] == -2) {
        mustRebuild = true;
        children2[i + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset2;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset2;
      let { index, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children2[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options);
        if (mapped != empty2) {
          children2[i] = fromLocal;
          children2[i + 1] = toLocal;
          children2[i + 2] = mapped;
        } else {
          children2[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children2, oldChildren, newLocal, mapping, offset2, oldOffset, options);
    let built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (let i = 0; i < children2.length; i += 3)
      if (children2[i + 1] < 0) {
        children2.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from2 = built.children[i];
      while (j < children2.length && children2[j] < from2)
        j += 3;
      children2.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children2);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length)
    return spans;
  let result = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children2, oldChildren, decorations, mapping, offset2, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (let i = 0; i < set.local.length; i++) {
      let mapped = set.local[i].map(mapping, offset2, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set.local[i].spec);
    }
    for (let i = 0; i < set.children.length; i += 3)
      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children2.length; i += 3)
    if (children2[i + 1] == -1)
      gather(children2[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset2) {
  if (node.isLeaf)
    return null;
  let end2 = offset2 + node.nodeSize, found2 = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset2 && span.to < end2) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  let result = [];
  for (let i = 0; i < array.length; i++)
    if (array[i] != null)
      result.push(array[i]);
  return result;
}
function buildTree(spans, node, offset2, options) {
  let children2 = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset2 + localStart + 1, options);
      if (subtree != empty2)
        children2.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (let i = 0; i < locals.length; i++)
    if (!locals[i].type.valid(node, locals[i])) {
      if (options.onRemove)
        options.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children2.length ? new DecorationSet(locals, children2) : empty2;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0)
    i++;
  array.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty2)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = ie && ie_version <= 11;
var SelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
};
var DOMObserver = class {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from2 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result = this.registerMutation(mutations[i], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length > 1) {
      let brs = added.filter((n) => n.nodeName == "BR");
      if (brs.length == 2) {
        let a = brs[0], b = brs[1];
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      }
    }
    let readSel = null;
    if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from2 > -1 || newSel) {
      if (from2 > -1) {
        view.docView.markDirty(from2, to);
        checkCSS(view);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++)
        added.push(mut.addedNodes[i]);
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from2, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
};
var cssChecked = /* @__PURE__ */ new WeakMap();
var cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function safariShadowSelectionRange(view) {
  let found2;
  function read2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read2, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read2, true);
  let anchorNode = found2.startContainer, anchorOffset = found2.startOffset;
  let focusNode = found2.endContainer, focusOffset = found2.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find2;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc3 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc3, sel, from: from2, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr3 = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr3.setMeta("pointer", true);
      else if (origin == "key")
        tr3.scrollIntoView();
      if (compositionID)
        tr3.setMeta("composition", compositionID);
      view.dispatch(tr3);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared = $before.sharedDepth(to);
  from2 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse = parseBetween(view, from2, to);
  let doc3 = view.state.doc, compare = doc3.slice(parse.from, parse.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr3 = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr3.setMeta("composition", compositionID);
          view.dispatch(tr3);
        }
      }
      return;
    }
  }
  if (chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from && parse.sel.head == parse.sel.anchor) {
    let size = change.endB - change.start;
    parse.sel = { anchor: parse.sel.anchor + size, head: parse.sel.anchor + size };
  }
  view.input.domChangeCount++;
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse.doc.resolveNoCache(change.start - parse.from);
  let $to = parse.doc.resolveNoCache(change.endB - parse.from);
  let $fromA = doc3.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && !$from.sameParent($to) && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeJoin(doc3, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && android && change.endB == change.start)
    view.input.lastAndroidDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let tr2, storedMarks, markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      tr2 = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      tr2 = view.state.tr;
      if (markChange.type == "add")
        tr2.addMark(chFrom, chTo, markChange.mark);
      else
        tr2.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text2 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text2)))
        return;
      tr2 = view.state.tr.insertText(text2, chFrom, chTo);
    }
  }
  if (!tr2)
    tr2 = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
  if (parse.sel) {
    let sel2 = resolveSelection(view, tr2.doc, parse.sel);
    if (sel2 && !(chrome && android && view.composing && sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr2.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
      tr2.setSelection(sel2);
  }
  if (storedMarks)
    tr2.ensureMarks(storedMarks);
  if (compositionID)
    tr2.setMeta("composition", compositionID);
  view.dispatch(tr2.scrollIntoView());
}
function resolveSelection(view, doc3, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)
    return null;
  return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update2;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update2 = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update2 = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++)
    updated.push(update2(prev.child(i)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeJoin(old, start2, end2, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || // The content must have shrunk
  end2 - start2 <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
  skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
    return false;
  let $start = old.resolve(start2);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end2 || skipClosingAndOpening($next, true, false) < end2)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end2 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end2++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end2++;
    }
  }
  return end2;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  let start2 = a.findDiffStart(b, pos);
  if (start2 == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start2 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start2;
  }
  if (endA < start2 && a.size < b.size) {
    let move = preferredPos <= start2 && preferredPos >= endA ? start2 - preferredPos : 0;
    start2 -= move;
    if (start2 && start2 < b.size && isSurrogatePair(b.textBetween(start2 - 1, start2 + 1)))
      start2 += move ? 1 : -1;
    endB = start2 + (endB - endA);
    endA = start2;
  } else if (endB < start2) {
    let move = preferredPos <= start2 && preferredPos >= endB ? start2 - preferredPos : 0;
    start2 -= move;
    if (start2 && start2 < a.size && isSurrogatePair(a.textBetween(start2 - 1, start2 + 1)))
      start2 += move ? 1 : -1;
    endA = start2 + (endA - endB);
    endB = start2;
  }
  return { start: start2, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a = str.charCodeAt(0), b = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
}
var EditorView = class {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco([]);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (this.someProp("handleScrollToSelection", (f) => f(this)))
      ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin = this.directPlugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin = this.state.plugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0; i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection)
            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
          return this._root = search;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node, offset2, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset2, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text2, event) {
    return doPaste(this, text2, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(tr2) {
    let dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction)
      dispatchTransaction.call(this, tr2);
    else
      this.updateState(this.state.apply(tr2));
  }
  /**
  @internal
  */
  domSelectionRange() {
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom ? safariShadowSelectionRange(this) : this.domSelection();
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
};
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr2 in value) {
        if (attr2 == "class")
          attrs.class += " " + value[attr2];
        else if (attr2 == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr2];
        else if (!attrs[attr2] && attr2 != "contenteditable" && attr2 != "nodeName")
          attrs[attr2] = String(value[attr2]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}

// node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i = 0; i < 10; i++)
  base[48 + i] = base[96 + i] = String(i);
var i;
for (i = 1; i <= 24; i++)
  base[i + 111] = "F" + i;
var i;
for (i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
var i;
for (code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
var code;
function keyName(event) {
  var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}

// node_modules/prosemirror-keymap/dist/index.js
var mac3 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac3)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function normalize(map2) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map2)
    copy2[normalizeKeyName(prop)] = map2[prop];
  return copy2;
}
function modifiers(name, event, shift2 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map2 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map2[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map2[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}

// node_modules/prosemirror-commands/dist/index.js
var deleteSelection = (state, dispatch) => {
  if (state.selection.empty)
    return false;
  if (dispatch)
    dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
var joinBackward = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr2 = state.tr.step(delStep);
        tr2.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr2.doc, $cut.pos - before.nodeSize));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
var selectNodeBackward = (state, dispatch, view) => {
  let { $head, empty: empty3 } = state.selection, $cut = $head;
  if (!empty3)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0)
        return $pos.doc.resolve($pos.before(i + 1));
      if ($pos.node(i).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
var joinForward = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr2 = state.tr.step(delStep);
        tr2.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos)), 1) : NodeSelection.create(tr2.doc, tr2.mapping.map($cut.pos)));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
var selectNodeForward = (state, dispatch, view) => {
  let { $head, empty: empty3 } = state.selection, $cut = $head;
  if (!empty3)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      let parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
var joinUp = (state, dispatch) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch) {
    let tr2 = state.tr.join(point);
    if (nodeSel)
      tr2.setSelection(NodeSelection.create(tr2.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var joinDown = (state, dispatch) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch)
    dispatch(state.tr.join(point).scrollIntoView());
  return true;
};
var lift2 = (state, dispatch) => {
  let { $from, $to } = state.selection;
  let range = $from.blockRange($to), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
var newlineInCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    let { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
var exitCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch) {
    let pos = $head.after(), tr2 = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr2.setSelection(Selection.near(tr2.doc.resolve(pos), 1));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var createParagraphNear = (state, dispatch) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr2 = state.tr.insert(side, type.createAndFill());
    tr2.setSelection(TextSelection.create(tr2.doc, side + 1));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var liftEmptyBlock = (state, dispatch) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch)
        dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state, dispatch) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch)
        dispatch(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.parent.isBlock)
      return false;
    if (dispatch) {
      let atEnd = $to.parentOffset == $to.parent.content.size;
      let tr2 = state.tr;
      if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
        tr2.deleteSelection();
      let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      let splitType = splitNode && splitNode($to.parent, atEnd);
      let types = splitType ? [splitType] : atEnd && deflt ? [{ type: deflt }] : void 0;
      let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
      if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
        if (deflt)
          types = [{ type: deflt }];
        can = true;
      }
      if (can) {
        tr2.split(tr2.mapping.map($from.pos), 1, types);
        if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
          let first2 = tr2.mapping.map($from.before()), $first = tr2.doc.resolve(first2);
          if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))
            tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
}
var splitBlock = splitBlockAs();
var selectParentNode = (state, dispatch) => {
  let { $from, to } = state.selection, pos;
  let same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
var selectAll = (state, dispatch) => {
  if (dispatch)
    dispatch(state.tr.setSelection(new AllSelection(state.doc)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  if (before.type.spec.isolating || after.type.spec.isolating)
    return false;
  if (joinMaybeClear(state, $cut, dispatch))
    return true;
  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end2 = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap2 = Fragment.from(conn[i].create(null, wrap2));
      wrap2 = Fragment.from(before.copy(wrap2));
      let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end2, $cut.pos, end2, new Slice(wrap2, 1, 0), conn.length, true));
      let joinAt = end2 + 2 * conn.length;
      if (canJoin(tr2.doc, joinAt))
        tr2.join(joinAt);
      dispatch(tr2.scrollIntoView());
    }
    return true;
  }
  let selAfter = Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        let end2 = Fragment.empty;
        for (let i = wrap2.length - 1; i >= 0; i--)
          end2 = Fragment.from(wrap2[i].copy(end2));
        let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end2, wrap2.length, 0), 0, true));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
var selectTextblockStart = selectTextblockSide(-1);
var selectTextblockEnd = selectTextblockSide(1);
function wrapIn(nodeType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch)
      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType2(nodeType, attrs = null) {
  return function(state, dispatch) {
    let applicable = false;
    for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
      let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index = $pos.index();
          applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr2 = state.tr;
      for (let i = 0; i < state.selection.ranges.length; i++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
        tr2.setBlockType(from2, to, nodeType, attrs);
      }
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands2) {
  return function(state, dispatch, view) {
    for (let i = 0; i < commands2.length; i++)
      if (commands2[i](state, dispatch, view))
        return true;
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (let key in pcBaseKeymap)
  macBaseKeymap[key] = pcBaseKeymap[key];
var mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;

// node_modules/prosemirror-schema-list/dist/index.js
function wrapInList(listType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), doJoin = false, outerRange = range;
    if (!range)
      return false;
    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      if ($from.index(range.depth - 1) == 0)
        return false;
      let $insert = state.doc.resolve(range.start - 2);
      outerRange = new NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount)
        range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
      doJoin = true;
    }
    let wrap2 = findWrapping(outerRange, listType, attrs, range);
    if (!wrap2)
      return false;
    if (dispatch)
      dispatch(doWrapInList(state.tr, range, wrap2, doJoin, listType).scrollIntoView());
    return true;
  };
}
function doWrapInList(tr2, range, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--)
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  tr2.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i = 0; i < wrappers.length; i++)
    if (wrappers[i].type == listType)
      found2 = i + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i = range.startIndex, e = range.endIndex, first2 = true; i < e; i++, first2 = false) {
    if (!first2 && canSplit(tr2.doc, splitPos, splitDepth)) {
      tr2.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i).nodeSize;
  }
  return tr2;
}
function liftListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range);
    else
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  let tr2 = state.tr, end2 = range.end, endOfList = range.$to.end(range.depth);
  if (end2 < endOfList) {
    tr2.step(new ReplaceAroundStep(end2 - 1, endOfList, end2, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr2.doc.resolve(range.$from.pos), tr2.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr2.lift(range, target);
  let after = tr2.mapping.map(end2, -1) - 1;
  if (canJoin(tr2.doc, after))
    tr2.join(after);
  dispatch(tr2.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  let tr2 = state.tr, list = range.parent;
  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr2.delete(pos - 1, pos + 1);
  }
  let $start = tr2.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr2.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start2 = $start.pos, end2 = start2 + item.nodeSize;
  tr2.step(new ReplaceAroundStep(start2 - (atStart ? 1 : 0), end2 + (atEnd ? 1 : 0), start2 + 1, end2 - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr2.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}

// node_modules/@tiptap/core/dist/index.js
function createChainableState(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc3 } = transaction;
  let { storedMarks } = transaction;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    filterTransaction: state.filterTransaction,
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc3;
    },
    get tr() {
      selection = transaction.selection;
      doc3 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
var CommandManager = class {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr: tr2 } = state;
    const props = this.buildProps(tr2);
    return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      const method = (...args) => {
        const callback = command2(...args)(props);
        if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr2);
        }
        return callback;
      };
      return [name, method];
    }));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr2 = startTr || state.tr;
    const run4 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr2);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain = {
      ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const chainedCommand = (...args) => {
          const props = this.buildProps(tr2, shouldDispatch);
          const callback = command2(...args)(props);
          callbacks.push(callback);
          return chain;
        };
        return [name, chainedCommand];
      })),
      run: run4
    };
    return chain;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch = false;
    const tr2 = startTr || state.tr;
    const props = this.buildProps(tr2, dispatch);
    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
    }));
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr2, dispatch)
    };
  }
  buildProps(tr2, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr: tr2,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr2
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr2, shouldDispatch),
      can: () => this.createCan(tr2),
      get commands() {
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)(props)];
        }));
      }
    };
    return props;
  }
};
var EventEmitter = class {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn2) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn2);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn2) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn2) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn2);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function splitExtensions(extensions2) {
  const baseExtensions = extensions2.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions2.filter((extension) => extension.type === "node");
  const markExtensions = extensions2.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions2) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions2.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(extension, "addAttributes", context);
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? value.split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        mergedAttributes[key] = [mergedAttributes[key], value].join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function isFunction(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if (parseRule.style) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key, value]) => {
      if (key === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function getSchemaByResolvedExtensions(extensions2, editor) {
  var _a;
  const allAttributes = getAttributesFromExtensions(extensions2);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a === void 0 ? void 0 : _a.name;
  const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraNodeFields = extensions2.reduce((fields, e) => {
      const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
      return {
        ...fields,
        ...extendNodeSchema ? extendNodeSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraNodeFields,
      content: callOrReturn(getExtensionField(extension, "content", context)),
      marks: callOrReturn(getExtensionField(extension, "marks", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      inline: callOrReturn(getExtensionField(extension, "inline", context)),
      atom: callOrReturn(getExtensionField(extension, "atom", context)),
      selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
      draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      defining: callOrReturn(getExtensionField(extension, "defining", context)),
      isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (node) => renderHTML({
        node,
        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
      });
    }
    const renderText = getExtensionField(extension, "renderText", context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  }));
  const marks = Object.fromEntries(markExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraMarkFields = extensions2.reduce((fields, e) => {
      const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
      return {
        ...fields,
        ...extendMarkSchema ? extendMarkSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraMarkFields,
      inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
      excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (mark) => renderHTML({
        mark,
        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
      });
    }
    return [extension.name, schema];
  }));
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
var getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {
    var _a, _b;
    const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {
      node,
      pos,
      parent,
      index
    })) || node.textContent || "%leaf%";
    textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
var InputRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var inputRuleMatcherHandler = (text2, find2) => {
  if (isRegExp(find2)) {
    return find2.exec(text2);
  }
  const inputRuleMatch = find2(text2);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text2;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run$1(config) {
  var _a;
  const { editor, from: from2, to, text: text2, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from2);
  if (
    // check for code node
    $from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark) => mark.type.spec.code))
  ) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text2;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    const tr2 = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr2
    });
    const range = {
      from: from2 - (match[0].length - text2.length),
      to
    };
    const { commands: commands2, chain, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range,
      match,
      commands: commands2,
      chain,
      can
    });
    if (handler === null || !tr2.steps.length) {
      return;
    }
    tr2.setMeta(plugin, {
      transform: tr2,
      from: from2,
      to,
      text: text2
    });
    view.dispatch(tr2);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr2, prev) {
        const stored = tr2.getMeta(plugin);
        if (stored) {
          return stored;
        }
        return tr2.selectionSet || tr2.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from2, to, text2) {
        return run$1({
          editor,
          from: from2,
          to,
          text: text2,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run$1({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function isNumber(value) {
  return typeof value === "number";
}
var PasteRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var pasteRuleMatcherHandler = (text2, find2, event) => {
  if (isRegExp(find2)) {
    return [...text2.matchAll(find2)];
  }
  const matches2 = find2(text2, event);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text2;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run2(config) {
  const { editor, state, from: from2, to, rule, pasteEvent, dropEvent } = config;
  const { commands: commands2, chain, can } = new CommandManager({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isTextblock || node.type.spec.code) {
      return;
    }
    const resolvedFrom = Math.max(from2, pos);
    const resolvedTo = Math.min(to, pos + node.content.size);
    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches2.forEach((match) => {
      if (match.index === void 0) {
        return;
      }
      const start2 = resolvedFrom + match.index + 1;
      const end2 = start2 + match[0].length;
      const range = {
        from: state.tr.mapping.map(start2),
        to: state.tr.mapping.map(end2)
      };
      const handler = rule.handler({
        state,
        range,
        match,
        commands: commands2,
        chain,
        can,
        pasteEvent,
        dropEvent
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  let pasteEvent = new ClipboardEvent("paste");
  let dropEvent = new DragEvent("drop");
  const plugins = rules.map((rule) => {
    return new Plugin({
      // we register a global drag handler to track the current drag source element
      view(view) {
        const handleDragstart = (event) => {
          var _a;
          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
        };
        window.addEventListener("dragstart", handleDragstart);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view, event) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            return false;
          },
          paste: (_view, event) => {
            var _a;
            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
            pasteEvent = event;
            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction = transactions[0];
        const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        if (!isPaste && !isDrop) {
          return;
        }
        const from2 = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from2) || !to || from2 === to.b) {
          return;
        }
        const tr2 = state.tr;
        const chainableState = createChainableState({
          state,
          transaction: tr2
        });
        const handler = run2({
          editor,
          state: chainableState,
          from: Math.max(from2 - 1, 0),
          to: to.b - 1,
          rule,
          pasteEvent,
          dropEvent
        });
        if (!handler || !tr2.steps.length) {
          return;
        }
        dropEvent = new DragEvent("drop");
        pasteEvent = new ClipboardEvent("paste");
        return tr2;
      }
    });
  });
  return plugins;
}
function findDuplicates(items) {
  const filtered = items.filter((el, index) => items.indexOf(el) !== index);
  return [...new Set(filtered)];
}
var ExtensionManager = class _ExtensionManager {
  constructor(extensions2, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = _ExtensionManager.resolve(extensions2);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.extensions.forEach((extension) => {
      var _a;
      this.editor.extensionStorage[extension.name] = extension.storage;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      const onCreate2 = getExtensionField(extension, "onCreate", context);
      if (onCreate2) {
        this.editor.on("create", onCreate2);
      }
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      const onFocus = getExtensionField(extension, "onFocus", context);
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      const onBlur = getExtensionField(extension, "onBlur", context);
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      const onDestroy3 = getExtensionField(extension, "onDestroy", context);
      if (onDestroy3) {
        this.editor.on("destroy", onDestroy3);
      }
    });
  }
  static resolve(extensions2) {
    const resolvedExtensions = _ExtensionManager.sort(_ExtensionManager.flatten(extensions2));
    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
    if (duplicatedNames.length) {
      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
    }
    return resolvedExtensions;
  }
  static flatten(extensions2) {
    return extensions2.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addExtensions = getExtensionField(extension, "addExtensions", context);
      if (addExtensions) {
        return [extension, ...this.flatten(addExtensions())];
      }
      return extension;
    }).flat(10);
  }
  static sort(extensions2) {
    const defaultPriority = 100;
    return extensions2.sort((a, b) => {
      const priorityA = getExtensionField(a, "priority") || defaultPriority;
      const priorityB = getExtensionField(b, "priority") || defaultPriority;
      if (priorityA > priorityB) {
        return -1;
      }
      if (priorityA < priorityB) {
        return 1;
      }
      return 0;
    });
  }
  get commands() {
    return this.extensions.reduce((commands2, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands2;
      }
      return {
        ...commands2,
        ...addCommands()
      };
    }, {});
  }
  get plugins() {
    const { editor } = this;
    const extensions2 = _ExtensionManager.sort([...this.extensions].reverse());
    const inputRules = [];
    const pasteRules = [];
    const allPlugins = extensions2.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
      let defaultBindings = {};
      if (extension.type === "mark" && extension.config.exitable) {
        defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
          return [shortcut, () => method({ editor })];
        }));
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        pasteRules.push(...addPasteRules());
      }
      const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...pasteRulesPlugin({
        editor,
        rules: pasteRules
      }),
      ...allPlugins
    ];
  }
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
      const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionField(extension, "addNodeView", context);
      if (!addNodeView) {
        return [];
      }
      const nodeview = (node, view, getPos, decorations) => {
        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
        return addNodeView()({
          editor,
          node,
          getPos,
          decorations,
          HTMLAttributes,
          extension
        });
      };
      return [extension.name, nodeview];
    }));
  }
};
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key])) {
        if (!(key in target)) {
          Object.assign(output, { [key]: source[key] });
        } else {
          output[key] = mergeDeep(target[key], source[key]);
        }
      } else {
        Object.assign(output, { [key]: source[key] });
      }
    });
  }
  return output;
}
var Extension = class _Extension {
  constructor(config = {}) {
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Extension(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Extension(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function getTextBetween(startNode, range, options) {
  const { from: from2, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  let text2 = "";
  let separated = true;
  startNode.nodesBetween(from2, to, (node, pos, parent, index) => {
    var _a;
    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (node.isBlock && !separated) {
        text2 += blockSeparator;
        separated = true;
      }
      if (parent) {
        text2 += textSerializer({
          node,
          pos,
          parent,
          index,
          range
        });
      }
    } else if (node.isText) {
      text2 += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from2, pos) - pos, to - pos);
      separated = false;
    } else if (node.isBlock && !separated) {
      text2 += blockSeparator;
      separated = true;
    }
  });
  return text2;
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
}
var ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc3, selection } = state;
            const { ranges } = selection;
            const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema);
            const range = { from: from2, to };
            return getTextBetween(doc3, range, {
              textSerializers
            });
          }
        }
      })
    ];
  }
});
var blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
    }
  });
  return true;
};
var clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
  return commands2.setContent("", emitUpdate);
};
var clearNodes = () => ({ state, tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const { ranges } = selection;
  if (!dispatch) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc3, mapping } = tr2;
      const $mappedFrom = doc3.resolve(mapping.map(pos));
      const $mappedTo = doc3.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr2.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr2.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var command = (fn2) => (props) => {
  return fn2(props);
};
var createParagraphNear2 = () => ({ state, dispatch }) => {
  return createParagraphNear(state, dispatch);
};
var cut = (originRange, targetPos) => ({ editor, tr: tr2 }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr2.deleteRange(originRange.from, originRange.to);
  const newPos = tr2.mapping.map(targetPos);
  tr2.insert(newPos, contentSlice.content);
  tr2.setSelection(new TextSelection(tr2.doc.resolve(newPos - 1)));
  return true;
};
var deleteCurrentNode = () => ({ tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteNode = (typeOrName) => ({ tr: tr2, state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteRange2 = (range) => ({ tr: tr2, dispatch }) => {
  const { from: from2, to } = range;
  if (dispatch) {
    tr2.delete(from2, to);
  }
  return true;
};
var deleteSelection2 = () => ({ state, dispatch }) => {
  return deleteSelection(state, dispatch);
};
var enter = () => ({ commands: commands2 }) => {
  return commands2.keyboardShortcut("Enter");
};
var exitCode2 = () => ({ state, dispatch }) => {
  return exitCode(state, dispatch);
};
function objectIncludes(object1, object2, options = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(item.attrs, attributes);
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes = {}) {
  if (!$pos || !type) {
    return;
  }
  let start2 = $pos.parent.childAfter($pos.parentOffset);
  if ($pos.parentOffset === start2.offset && start2.offset !== 0) {
    start2 = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start2.node) {
    return;
  }
  const mark = findMarkInSet([...start2.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start2.index;
  let startPos = $pos.start() + start2.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start2.node.nodeSize;
  findMarkInSet([...start2.node.marks], type, attributes);
  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
var extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc3, selection } = tr2;
  const { $from, from: from2, to } = selection;
  if (dispatch) {
    const range = getMarkRange($from, type, attributes);
    if (range && range.from <= from2 && range.to >= to) {
      const newSelection = TextSelection.create(doc3, range.from, range.to);
      tr2.setSelection(newSelection);
    }
  }
  return true;
};
var first = (commands2) => (props) => {
  const items = typeof commands2 === "function" ? commands2(props) : commands2;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) {
      return true;
    }
  }
  return false;
};
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function resolveFocusPosition(doc3, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc3);
  const selectionAtEnd = Selection.atEnd(doc3);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc3, minMax(0, minPos, maxPos), minMax(doc3.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc3, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function isiOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var focus = (position = null, options = {}) => ({ editor, view, tr: tr2, dispatch }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position === null || position === false) {
    return true;
  }
  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr2.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch) {
    if (!isSameSelection) {
      tr2.setSelection(selection);
    }
    if (isSameSelection && tr2.storedMarks) {
      tr2.setStoredMarks(tr2.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var forEach = (items, fn2) => (props) => {
  return items.every((item, index) => fn2(item, { ...props, index }));
};
var insertContent = (value, options) => ({ tr: tr2, commands: commands2 }) => {
  return commands2.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options);
};
var removeWhitespaces = (node) => {
  const children2 = node.childNodes;
  for (let i = children2.length - 1; i >= 0; i -= 1) {
    const child = children2[i];
    if (child.nodeType === 3 && child.nodeValue && !/\S/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  removeWhitespaces(html);
  return removeWhitespaces(html);
}
function createNodeFromContent(content, schema, options) {
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  if (typeof content === "object" && content !== null) {
    try {
      if (Array.isArray(content) && content.length > 0) {
        return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      return schema.nodeFromJSON(content);
    } catch (error) {
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema, options);
    }
  }
  if (typeof content === "string") {
    const parser = DOMParser.fromSchema(schema);
    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function selectionToInsertionEnd2(tr2, startLen, bias) {
  const last = tr2.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step = tr2.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map2 = tr2.mapping.maps[last];
  let end2 = 0;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 === 0) {
      end2 = newTo;
    }
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end2), bias));
}
var isFragment = (nodeOrFragment) => {
  return nodeOrFragment.toString().startsWith("<");
};
var insertContentAt = (position, value, options) => ({ tr: tr2, dispatch, editor }) => {
  if (dispatch) {
    options = {
      parseOptions: {},
      updateSelection: true,
      ...options
    };
    const content = createNodeFromContent(value, editor.schema, {
      parseOptions: {
        preserveWhitespace: "full",
        ...options.parseOptions
      }
    });
    if (content.toString() === "<>") {
      return true;
    }
    let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr2.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        tr2.insertText(value.map((v) => v.text || "").join(""), from2, to);
      } else if (typeof value === "object" && !!value && !!value.text) {
        tr2.insertText(value.text, from2, to);
      } else {
        tr2.insertText(value, from2, to);
      }
    } else {
      tr2.replaceWith(from2, to, content);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd2(tr2, tr2.steps.length - 1, -1);
    }
  }
  return true;
};
var joinUp2 = () => ({ state, dispatch }) => {
  return joinUp(state, dispatch);
};
var joinDown2 = () => ({ state, dispatch }) => {
  return joinDown(state, dispatch);
};
var joinBackward2 = () => ({ state, dispatch }) => {
  return joinBackward(state, dispatch);
};
var joinForward2 = () => ({ state, dispatch }) => {
  return joinForward(state, dispatch);
};
var joinItemBackward = () => ({ tr: tr2, state, dispatch }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch) {
      dispatch(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
var joinItemForward = () => ({ state, dispatch, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch) {
      dispatch(tr2);
    }
    return true;
  } catch (e) {
    return false;
  }
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName2(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift2;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift2) {
    result = `Shift-${result}`;
  }
  return result;
}
var keyboardShortcut = (name) => ({ editor, view, tr: tr2, dispatch }) => {
  const keys2 = normalizeKeyName2(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr2.mapping);
    if (newStep && dispatch) {
      tr2.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty3 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty3) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
var lift3 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift2(state, dispatch);
};
var liftEmptyBlock2 = () => ({ state, dispatch }) => {
  return liftEmptyBlock(state, dispatch);
};
var liftListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem(type)(state, dispatch);
};
var newlineInCode2 = () => ({ state, dispatch }) => {
  return newlineInCode(state, dispatch);
};
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes = (typeOrName, attributes) => ({ tr: tr2, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr2.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr2.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var scrollIntoView = () => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    tr2.scrollIntoView();
  }
  return true;
};
var selectAll2 = () => ({ tr: tr2, commands: commands2 }) => {
  return commands2.setTextSelection({
    from: 0,
    to: tr2.doc.content.size
  });
};
var selectNodeBackward2 = () => ({ state, dispatch }) => {
  return selectNodeBackward(state, dispatch);
};
var selectNodeForward2 = () => ({ state, dispatch }) => {
  return selectNodeForward(state, dispatch);
};
var selectParentNode2 = () => ({ state, dispatch }) => {
  return selectParentNode(state, dispatch);
};
var selectTextblockEnd2 = () => ({ state, dispatch }) => {
  return selectTextblockEnd(state, dispatch);
};
var selectTextblockStart2 = () => ({ state, dispatch }) => {
  return selectTextblockStart(state, dispatch);
};
function createDocument(content, schema, parseOptions = {}) {
  return createNodeFromContent(content, schema, { slice: false, parseOptions });
}
var setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr: tr2, editor, dispatch }) => {
  const { doc: doc3 } = tr2;
  const document2 = createDocument(content, editor.schema, parseOptions);
  if (dispatch) {
    tr2.replaceWith(0, doc3.content.size, document2).setMeta("preventUpdate", !emitUpdate);
  }
  return true;
};
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from2, to, empty: empty3 } = state.selection;
  const marks = [];
  if (empty3) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function combineTransactionSteps(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction) => {
    transaction.steps.forEach((step) => {
      transform.step(step);
    });
  });
  return transform;
}
function defaultBlockAt2(match) {
  for (let i = 0; i < match.edgeCount; i += 1) {
    const { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildrenInRange(node, range, predicate) {
  const nodesWithPos = [];
  node.nodesBetween(range.from, range.to, (child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function getText2(node, options) {
  const range = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween(node, range, options);
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from: from2, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from2, to, (node2) => {
    nodes.push(node2);
  });
  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return { ...node.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function removeDuplicates(array, by = JSON.stringify) {
  const seen = {};
  return array.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {
    const rest = uniqueChanges.filter((_, i) => i !== index);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  const { mapping, steps } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from2, to } = steps[index];
      if (from2 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from2, to });
    } else {
      stepMap.forEach((from2, to) => {
        ranges.push({ from: from2, to });
      });
    }
    ranges.forEach(({ from: from2, to }) => {
      const newStart = mapping.slice(index).map(from2, -1);
      const newEnd = mapping.slice(index).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function getMarksBetween(from2, to, doc3) {
  const marks = [];
  if (from2 === to) {
    doc3.resolve(from2).marks().forEach((mark) => {
      const $pos = doc3.resolve(from2 - 1);
      const range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push({
        mark,
        ...range
      });
    });
  } else {
    doc3.nodesBetween(from2, to, (node, pos) => {
      if (!node || node.nodeSize === void 0) {
        return;
      }
      marks.push(...node.marks.map((mark) => ({
        from: pos,
        to: pos + node.nodeSize,
        mark
      })));
    });
  }
  return marks;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
    const extensionAttribute = extensionAttributes.find((item) => {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty3, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty3) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(...node.marks.map((mark) => ({
        mark,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
function isList(name, extensions2) {
  const { nodeExtensions } = splitExtensions(extensions2);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty(node) {
  var _a;
  const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
  const content = node.toJSON();
  return JSON.stringify(defaultContent) === JSON.stringify(content);
}
function isNodeSelection(value) {
  return value instanceof NodeSelection;
}
function posToDOMRect(view, from2, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from2, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start2 = view.coordsAtPos(resolvedFrom);
  const end2 = view.coordsAtPos(resolvedEnd, -1);
  const top2 = Math.min(start2.top, end2.top);
  const bottom2 = Math.max(start2.bottom, end2.bottom);
  const left2 = Math.min(start2.left, end2.left);
  const right2 = Math.max(start2.right, end2.right);
  const width = right2 - left2;
  const height = bottom2 - top2;
  const x = left2;
  const y = top2;
  const data = {
    top: top2,
    bottom: bottom2,
    left: left2,
    right: right2,
    width,
    height,
    x,
    y
  };
  return {
    ...data,
    toJSON: () => data
  };
}
function canSetMark(state, tr2, newMarkType) {
  var _a;
  const { selection } = tr2;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  const { selection } = tr2;
  const { empty: empty3, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch) {
    if (empty3) {
      const oldAttributes = getMarkAttributes(state, type);
      tr2.addStoredMark(type.create({
        ...oldAttributes,
        ...attributes
      }));
    } else {
      ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr2.addMark(trimmedFrom, trimmedTo, type.create({
                  ...mark.attrs,
                  ...attributes
                }));
              }
            });
          } else {
            tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr2, type);
};
var setMeta = (key, value) => ({ tr: tr2 }) => {
  tr2.setMeta(key, value);
  return true;
};
var setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
  const type = getNodeType(typeOrName, state.schema);
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain().command(({ commands: commands2 }) => {
    const canSetBlock = setBlockType2(type, attributes)(state);
    if (canSetBlock) {
      return true;
    }
    return commands2.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType2(type, attributes)(updatedState, dispatch);
  }).run();
};
var setNodeSelection = (position) => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr2;
    const from2 = minMax(position, 0, doc3.content.size);
    const selection = NodeSelection.create(doc3, from2);
    tr2.setSelection(selection);
  }
  return true;
};
var setTextSelection = (position) => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr2;
    const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = TextSelection.atStart(doc3).from;
    const maxPos = TextSelection.atEnd(doc3).to;
    const resolvedFrom = minMax(from2, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc3, resolvedFrom, resolvedEnd);
    tr2.setSelection(selection);
  }
  return true;
};
var sinkListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem(type)(state, dispatch);
};
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch, editor }) => {
  const { selection, doc: doc3 } = tr2;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc3, $from.pos)) {
      return false;
    }
    if (dispatch) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr2.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  if (dispatch) {
    const atEnd = $to.parentOffset === $to.parent.content.size;
    if (selection instanceof TextSelection) {
      tr2.deleteSelection();
    }
    const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    let types = atEnd && deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
    let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
      can = true;
      types = deflt ? [
        {
          type: deflt,
          attrs: newAttributes
        }
      ] : void 0;
    }
    if (can) {
      tr2.split(tr2.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr2.mapping.map($from.before());
        const $first = tr2.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr2.scrollIntoView();
  }
  return true;
};
var splitListItem = (typeOrName) => ({ tr: tr2, state, dispatch, editor }) => {
  var _a;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch) {
      let wrap2 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment.from($from.node(d).copy(wrap2));
      }
      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
      const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start2 = $from.before($from.depth - (depthBefore - 1));
      tr2.replace(start2, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr2.doc.nodesBetween(start2, tr2.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
      }
      tr2.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  tr2.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr2.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr2.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
  }
  return true;
};
var joinListBackwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const before = tr2.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr2.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr2.join(list.pos);
  return true;
};
var joinListForwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const after = tr2.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr2.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr2.join(after);
  return true;
};
var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr2, state, dispatch, chain, commands: commands2, can }) => {
  const { extensions: extensions2, splittableMarks } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode((node) => isList(node.type.name, extensions2))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands2.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions2) && listType.validContent(parentList.node.content) && dispatch) {
      return chain().command(() => {
        tr2.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch) {
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
  }
  return chain().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands2.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
};
var toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands2.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands2.setMark(type, attributes);
};
var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands2.setNode(toggleType);
  }
  return commands2.setNode(type, attributes);
};
var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands2.lift(type);
  }
  return commands2.wrapIn(type, attributes);
};
var undoInputRule = () => ({ state, dispatch }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        const tr2 = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr2.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr2.doc.resolve(undoable.from).marks();
          tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr2.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var unsetAllMarks = () => ({ tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const { empty: empty3, ranges } = selection;
  if (empty3) {
    return true;
  }
  if (dispatch) {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
var unsetMark = (typeOrName, options = {}) => ({ tr: tr2, state, dispatch }) => {
  var _a;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr2;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty3, ranges } = selection;
  if (!dispatch) {
    return true;
  }
  if (empty3 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
    const range = getMarkRange($from, type, attrs);
    if (range) {
      from2 = range.from;
      to = range.to;
    }
    tr2.removeMark(from2, to, type);
  } else {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr2.removeStoredMark(type);
  return true;
};
var updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr2.selection.ranges.forEach((range) => {
      const from2 = range.$from.pos;
      const to = range.$to.pos;
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr2.setNodeMarkup(pos, void 0, {
            ...node.attrs,
            ...attributes
          });
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              const trimmedFrom = Math.max(pos, from2);
              const trimmedTo = Math.min(pos + node.nodeSize, to);
              tr2.addMark(trimmedFrom, trimmedTo, markType.create({
                ...mark.attrs,
                ...attributes
              }));
            }
          });
        }
      });
    });
  }
  return true;
};
var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn(type, attributes)(state, dispatch);
};
var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList(type, attributes)(state, dispatch);
};
var commands = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur,
  clearContent,
  clearNodes,
  command,
  createParagraphNear: createParagraphNear2,
  cut,
  deleteCurrentNode,
  deleteNode,
  deleteRange: deleteRange2,
  deleteSelection: deleteSelection2,
  enter,
  exitCode: exitCode2,
  extendMarkRange,
  first,
  focus,
  forEach,
  insertContent,
  insertContentAt,
  joinUp: joinUp2,
  joinDown: joinDown2,
  joinBackward: joinBackward2,
  joinForward: joinForward2,
  joinItemBackward,
  joinItemForward,
  keyboardShortcut,
  lift: lift3,
  liftEmptyBlock: liftEmptyBlock2,
  liftListItem: liftListItem2,
  newlineInCode: newlineInCode2,
  resetAttributes,
  scrollIntoView,
  selectAll: selectAll2,
  selectNodeBackward: selectNodeBackward2,
  selectNodeForward: selectNodeForward2,
  selectParentNode: selectParentNode2,
  selectTextblockEnd: selectTextblockEnd2,
  selectTextblockStart: selectTextblockStart2,
  setContent,
  setMark,
  setMeta,
  setNode,
  setNodeSelection,
  setTextSelection,
  sinkListItem: sinkListItem2,
  splitBlock: splitBlock2,
  splitListItem,
  toggleList,
  toggleMark,
  toggleNode,
  toggleWrap,
  undoInputRule,
  unsetAllMarks,
  unsetMark,
  updateAttributes,
  wrapIn: wrapIn2,
  wrapInList: wrapInList2
});
var Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...commands
    };
  }
});
var Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: new PluginKey("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
var Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands2.command(({ tr: tr2 }) => {
        const { selection, doc: doc3 } = tr2;
        const { empty: empty3, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock ? tr2.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc3).from === pos;
        if (!empty3 || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {
          return false;
        }
        return commands2.clearNodes();
      }),
      () => commands2.deleteSelection(),
      () => commands2.joinBackward(),
      () => commands2.selectNodeBackward()
    ]);
    const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.deleteSelection(),
      () => commands2.deleteCurrentNode(),
      () => commands2.joinForward(),
      () => commands2.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.newlineInCode(),
      () => commands2.createParagraphNear(),
      () => commands2.liftEmptyBlock(),
      () => commands2.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete,
      "Mod-Delete": handleDelete,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete,
      "Ctrl-Alt-Backspace": handleDelete,
      "Alt-Delete": handleDelete,
      "Alt-d": handleDelete,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          if (!docChanges) {
            return;
          }
          const { empty: empty3, from: from2, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from2 === allFrom && to === allEnd;
          if (empty3 || !allWasSelected) {
            return;
          }
          const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, " ", " ").length === 0;
          if (!isEmpty) {
            return;
          }
          const tr2 = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr2
          });
          const { commands: commands2 } = new CommandManager({
            editor: this.editor,
            state
          });
          commands2.clearNodes();
          if (!tr2.steps.length) {
            return;
          }
          return tr2;
        }
      })
    ];
  }
});
var Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var extensions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ClipboardTextSerializer,
  Commands,
  Editable,
  FocusEvents,
  Keymap,
  Tabindex
});
var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function createStyleTag(style2, nonce, suffix) {
  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
var Editor = class extends EventEmitter {
  constructor(options = {}) {
    super();
    this.isFocused = false;
    this.extensionStorage = {};
    this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.createView();
    this.injectCSS();
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    if (this.options.injectCSS && document) {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr });
    }
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   */
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKey The plugins name
   */
  unregisterPlugin(nameOrPluginKey) {
    if (this.isDestroyed) {
      return;
    }
    const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
    const state = this.state.reconfigure({
      // @ts-ignore
      plugins: this.state.plugins.filter((plugin) => !plugin.key.startsWith(name))
    });
    this.view.updateState(state);
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    const doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions);
    const selection = resolveFocusPosition(doc3, this.options.autofocus);
    this.view = new EditorView(this.options.element, {
      ...this.options.editorProps,
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: EditorState.create({
        doc: doc3,
        selection: selection || void 0
      })
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    this.prependClass();
    const dom = this.view.dom;
    dom.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(fn2) {
    this.isCapturingTransaction = true;
    fn2();
    this.isCapturingTransaction = false;
    const tr2 = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr2;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(transaction) {
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach((step) => {
        var _a;
        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);
      });
      return;
    }
    const state = this.state.apply(transaction);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction
      });
    }
    const focus2 = transaction.getMeta("focus");
    const blur2 = transaction.getMeta("blur");
    if (focus2) {
      this.emit("focus", {
        editor: this,
        event: focus2.event,
        transaction
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        transaction
      });
    }
    if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(options) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    return getText2(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(this.schema),
        ...textSerializers
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
    return this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy");
    if (this.view) {
      this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var _a;
    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
  }
};
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        const markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
function nodeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const { tr: tr2 } = state;
      const start2 = range.from;
      let end2 = range.to;
      const newNode = config.type.create(attributes);
      if (match[1]) {
        const offset2 = match[0].lastIndexOf(match[1]);
        let matchStart = start2 + offset2;
        if (matchStart > end2) {
          matchStart = end2;
        } else {
          end2 = matchStart + match[1].length;
        }
        const lastChar = match[0][match[0].length - 1];
        tr2.insertText(lastChar, start2 + match[0].length - 1);
        tr2.replaceWith(matchStart, end2, newNode);
      } else if (match[0]) {
        tr2.insert(start2 - 1, config.type.create(attributes)).delete(tr2.mapping.map(start2), tr2.mapping.map(end2));
      }
      tr2.scrollIntoView();
    }
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const $start = state.doc.resolve(range.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    }
  });
}
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match, chain }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const tr2 = state.tr.delete(range.from, range.to);
      const $start = tr2.doc.resolve(range.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr2.wrap(blockRange, wrapping);
      if (config.keepMarks && config.editor) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = config.editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (marks) {
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr2.ensureMarks(filteredMarks);
        }
      }
      if (config.keepAttributes) {
        const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
        chain().updateAttributes(nodeType, attributes).run();
      }
      const before = tr2.doc.resolve(range.from - 1).nodeBefore;
      if (before && before.type === config.type && canJoin(tr2.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
        tr2.join(range.from - 1);
      }
    }
  });
}
var Mark2 = class _Mark {
  constructor(config = {}) {
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Mark(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Mark(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  static handleExit({ editor, mark }) {
    const { tr: tr2 } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (removeMark2) {
        tr2.removeStoredMark(removeMark2);
      }
      tr2.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr2);
      return true;
    }
    return false;
  }
};
var Node2 = class _Node {
  constructor(config = {}) {
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Node(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Node(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function isAndroid() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
var NodeView = class {
  constructor(component, props, options) {
    this.isDragging = false;
    this.component = component;
    this.editor = props.editor;
    this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...options
    };
    this.extension = props.extension;
    this.node = props.node;
    this.decorations = props.decorations;
    this.getPos = props.getPos;
    this.mount();
  }
  mount() {
    return;
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(event) {
    var _a, _b, _c, _d, _e, _f, _g;
    const { view } = this.editor;
    const target = event.target;
    const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest("[data-drag-handle]") : target.closest("[data-drag-handle]");
    if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {
      return;
    }
    let x = 0;
    let y = 0;
    if (this.dom !== dragHandle) {
      const domBox = this.dom.getBoundingClientRect();
      const handleBox = dragHandle.getBoundingClientRect();
      const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;
      const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;
      x = handleBox.x - domBox.x + offsetX;
      y = handleBox.y - domBox.y + offsetY;
    }
    (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y);
    const selection = NodeSelection.create(view.state.doc, this.getPos());
    const transaction = view.state.tr.setSelection(selection);
    view.dispatch(transaction);
  }
  stopEvent(event) {
    var _a;
    if (!this.dom) {
      return false;
    }
    if (typeof this.options.stopEvent === "function") {
      return this.options.stopEvent({ event });
    }
    const target = event.target;
    const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));
    if (!isInElement) {
      return false;
    }
    const isDragEvent = event.type.startsWith("drag");
    const isDropEvent = event.type === "drop";
    const isInput = ["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(target.tagName) || target.isContentEditable;
    if (isInput && !isDropEvent && !isDragEvent) {
      return true;
    }
    const { isEditable } = this.editor;
    const { isDragging } = this;
    const isDraggable = !!this.node.type.spec.draggable;
    const isSelectable = NodeSelection.isSelectable(this.node);
    const isCopyEvent = event.type === "copy";
    const isPasteEvent = event.type === "paste";
    const isCutEvent = event.type === "cut";
    const isClickEvent = event.type === "mousedown";
    if (!isDraggable && isSelectable && isDragEvent) {
      event.preventDefault();
    }
    if (isDraggable && isDragEvent && !isDragging) {
      event.preventDefault();
      return false;
    }
    if (isDraggable && isEditable && !isDragging && isClickEvent) {
      const dragHandle = target.closest("[data-drag-handle]");
      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));
      if (isValidDragHandle) {
        this.isDragging = true;
        document.addEventListener("dragend", () => {
          this.isDragging = false;
        }, { once: true });
        document.addEventListener("drop", () => {
          this.isDragging = false;
        }, { once: true });
        document.addEventListener("mouseup", () => {
          this.isDragging = false;
        }, { once: true });
      }
    }
    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {
      return false;
    }
    return true;
  }
  ignoreMutation(mutation) {
    if (!this.dom || !this.contentDOM) {
      return true;
    }
    if (typeof this.options.ignoreMutation === "function") {
      return this.options.ignoreMutation({ mutation });
    }
    if (this.node.isLeaf || this.node.isAtom) {
      return true;
    }
    if (mutation.type === "selection") {
      return false;
    }
    if (this.dom.contains(mutation.target) && mutation.type === "childList" && (isiOS() || isAndroid()) && this.editor.isFocused) {
      const changedNodes = [
        ...Array.from(mutation.addedNodes),
        ...Array.from(mutation.removedNodes)
      ];
      if (changedNodes.every((node) => node.isContentEditable)) {
        return false;
      }
    }
    if (this.contentDOM === mutation.target && mutation.type === "attributes") {
      return true;
    }
    if (this.contentDOM.contains(mutation.target)) {
      return false;
    }
    return true;
  }
  updateAttributes(attributes) {
    this.editor.commands.command(({ tr: tr2 }) => {
      const pos = this.getPos();
      tr2.setNodeMarkup(pos, void 0, {
        ...this.node.attrs,
        ...attributes
      });
      return true;
    });
  }
  deleteNode() {
    const from2 = this.getPos();
    const to = from2 + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: from2, to });
  }
};
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range, match, pasteEvent }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
function escapeForRegEx(string) {
  return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect2 = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect2.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect2.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect2.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect2.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect2.width / scaleX;
  var height = clientRect2.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect2 = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect2.width - width) <= 1) {
    width = clientRect2.width;
  }
  if (Math.abs(clientRect2.height - height) <= 1) {
    height = clientRect2.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element2.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element2.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element2.parentNode || // DOM Element detected
    (isShadowRoot(element2) ? element2.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element2)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance9 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance9.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance9.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance9.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance9.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element2),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers2) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers2.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance9 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance9.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance: instance9
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance9.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance9;
    }
    instance9.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect5 = _ref.effect;
        if (typeof effect5 === "function") {
          var cleanupFn = effect5({
            state,
            name,
            instance: instance9,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance9;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// node_modules/tippy.js/dist/tippy.esm.js
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce2(fn2, ms) {
  if (ms === 0) {
    return fn2;
  }
  var timeout;
  return function(arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      fn2(arg);
    }, ms);
  };
}
function removeProperties(obj, keys2) {
  var clone = Object.assign({}, obj);
  keys2.forEach(function(key) {
    delete clone[key];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function(item, index) {
    return arr.indexOf(item) === index;
  });
}
function getBasePlacement2(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement2(value) {
  return ["Element", "Fragment"].some(function(type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement2(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function(el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function(el) {
    if (el) {
      el.setAttribute("data-state", state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element2 = _normalizeToArray[0];
  return element2 != null && (_element$ownerDocumen = element2.ownerDocument) != null && _element$ownerDocumen.body ? element2.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref) {
    var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement2(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method](event, listener);
  });
}
function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now2 = performance.now();
  if (now2 - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now2;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance9 = activeElement._tippy;
    if (activeElement.blur && !instance9.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser ? (
  // @ts-ignore
  !!window.msCrypto
) : false;
function createMemoryLeakWarning(method) {
  var txt = method === "destroy" ? "n already-" : " ";
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
}
function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\u{1F477}\u200D This is a development-only message. It will be removed in production.\n  ");
}
function getFormattedMessage(message) {
  return [
    getDevMessage(message),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var visitedMessages;
if (true) {
  resetVisitedMessages();
}
function resetVisitedMessages() {
  visitedMessages = /* @__PURE__ */ new Set();
}
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;
    visitedMessages.add(message);
    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;
    visitedMessages.add(message);
    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
  errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {
  },
  onBeforeUpdate: function onBeforeUpdate() {
  },
  onCreate: function onCreate() {
  },
  onDestroy: function onDestroy2() {
  },
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount2() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  onUntrigger: function onUntrigger() {
  },
  onClickOutside: function onClickOutside() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  if (true) {
    validateProps(partialProps, []);
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps2 = plugins.reduce(function(acc, plugin) {
    var name = plugin.name, defaultValue = plugin.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key) {
    var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference2, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference2])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function(plugin) {
        return plugin.name === prop;
      }).length === 0;
    }
    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element2, html) {
  element2[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow3 = div();
  if (value === true) {
    arrow3.className = ARROW_CLASS;
  } else {
    arrow3.className = SVG_ARROW_CLASS;
    if (isElement2(value)) {
      arrow3.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow3, value);
    }
  }
  return arrow3;
}
function setContent2(content, props) {
  if (isElement2(props.content)) {
    dangerouslySetInnerHTML(content, "");
    content.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function(node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance9) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute("data-state", "hidden");
  setContent2(content, instance9.props);
  popper2.appendChild(box);
  box.appendChild(content);
  onUpdate(instance9.props, instance9.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow3 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent2(content2, instance9.props);
    }
    if (nextProps.arrow) {
      if (!arrow3) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow3);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow3) {
      box2.removeChild(arrow3);
    }
  }
  return {
    popper: popper2,
    onUpdate
  };
}
render.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce2(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance9 = {
    // properties
    id,
    reference: reference2,
    popper: div(),
    popperInstance,
    props,
    state,
    plugins,
    // methods
    clearDelayTimeouts,
    setProps,
    setContent: setContent3,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy
  };
  if (!props.render) {
    if (true) {
      errorWhen(true, "render() function has not been supplied.");
    }
    return instance9;
  }
  var _props$render = props.render(instance9), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance9.id;
  instance9.popper = popper2;
  reference2._tippy = instance9;
  popper2._tippy = instance9;
  var pluginsHooks = plugins.map(function(plugin) {
    return plugin.fn(instance9);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance9]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance9.props.interactive && instance9.state.isVisible) {
      instance9.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance9.props.interactive && instance9.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance9;
  function getNormalizedTouchSettings() {
    var touch = instance9.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance9.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance9.state.isMounted && !instance9.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance9.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance9.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance9.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance9.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance9.props.aria;
    if (!aria.content) {
      return;
    }
    var attr2 = "aria-" + aria.content;
    var id2 = popper2.id;
    var nodes = normalizeToArray(instance9.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      var currentValue = node.getAttribute(attr2);
      if (instance9.state.isVisible) {
        node.setAttribute(attr2, currentValue ? currentValue + " " + id2 : id2);
      } else {
        var nextValue = currentValue && currentValue.replace(id2, "").trim();
        if (nextValue) {
          node.setAttribute(attr2, nextValue);
        } else {
          node.removeAttribute(attr2);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance9.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance9.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      if (instance9.props.interactive) {
        node.setAttribute("aria-expanded", instance9.state.isVisible && node === getCurrentTarget() ? "true" : "false");
      } else {
        node.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance9.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance9.props.triggerTarget || reference2).some(function(el) {
      return actualContains(el, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance9.state.isVisible && instance9.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance9, event]);
    }
    if (instance9.props.hideOnClick === true) {
      instance9.clearDelayTimeouts();
      instance9.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance9.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc3 = getDocument();
    doc3.addEventListener("mousedown", onDocumentPress, true);
    doc3.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc3.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc3.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc3 = getDocument();
    doc3.removeEventListener("mousedown", onDocumentPress, true);
    doc3.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc3.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc3.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance9.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance9.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node,
        eventType,
        handler,
        options
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on("touchstart", onTrigger2, {
        passive: true
      });
      on("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance9.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on("mouseleave", onMouseLeave);
          break;
        case "focus":
          on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function(_ref) {
      var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance9.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance9.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance9.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance9.props.hideOnClick !== false && instance9.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
      var _instance$popperInsta;
      var instance10 = popper3._tippy;
      var state2 = (_instance$popperInsta = instance10.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state2) {
        return {
          popperRect: popper3.getBoundingClientRect(),
          popperState: state2,
          props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance9.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance9.props.interactive) {
      instance9.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance9.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance9.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance9.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow3 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference2;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn2(_ref2) {
        var state2 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr2) {
            if (attr2 === "placement") {
              box.setAttribute("data-placement", state2.placement);
            } else {
              if (state2.attributes.popper["data-popper-" + attr2]) {
                box.setAttribute("data-" + attr2, "");
              } else {
                box.removeAttribute("data-" + attr2);
              }
            }
          });
          state2.attributes.popper = {};
        }
      }
    };
    var modifiers2 = [{
      name: "offset",
      options: {
        offset: offset2
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow3) {
      modifiers2.push({
        name: "arrow",
        options: {
          element: arrow3,
          padding: 3
        }
      });
    }
    modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance9.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers: modifiers2
    }));
  }
  function destroyPopperInstance() {
    if (instance9.popperInstance) {
      instance9.popperInstance.destroy();
      instance9.popperInstance = null;
    }
  }
  function mount() {
    var appendTo = instance9.props.appendTo;
    var parentNode2;
    var node = getCurrentTarget();
    if (instance9.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode2 = node.parentNode;
    } else {
      parentNode2 = invokeWithArgsOrReturn(appendTo, [node]);
    }
    if (!parentNode2.contains(popper2)) {
      parentNode2.appendChild(popper2);
    }
    instance9.state.isMounted = true;
    createPopperInstance();
    if (true) {
      warnWhen(instance9.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
    }
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance9.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance9, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance9.show();
      }, delay);
    } else {
      instance9.show();
    }
  }
  function scheduleHide(event) {
    instance9.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance9, event]);
    if (!instance9.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance9.props.trigger.indexOf("mouseenter") >= 0 && instance9.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance9.state.isVisible) {
          instance9.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance9.hide();
      });
    }
  }
  function enable() {
    instance9.state.isEnabled = true;
  }
  function disable() {
    instance9.hide();
    instance9.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    if (true) {
      warnWhen(instance9.state.isDestroyed, createMemoryLeakWarning("setProps"));
    }
    if (instance9.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance9, partialProps]);
    removeListeners();
    var prevProps = instance9.props;
    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance9.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce2(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
        node.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance9.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance9, partialProps]);
  }
  function setContent3(content) {
    instance9.setProps({
      content
    });
  }
  function show() {
    if (true) {
      warnWhen(instance9.state.isDestroyed, createMemoryLeakWarning("show"));
    }
    var isAlreadyVisible = instance9.state.isVisible;
    var isDestroyed = instance9.state.isDestroyed;
    var isDisabled = !instance9.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance9.props.touch;
    var duration = getValueAtIndexOrReturn(instance9.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance9], false);
    if (instance9.props.onShow(instance9) === false) {
      return;
    }
    instance9.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance9.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance9.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance9.props.moveTransition;
      if (getIsDefaultRenderFn() && instance9.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance9);
      (_instance$popperInsta2 = instance9.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance9]);
      if (instance9.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance9.state.isShown = true;
          invokeHook("onShown", [instance9]);
        });
      }
    };
    mount();
  }
  function hide2() {
    if (true) {
      warnWhen(instance9.state.isDestroyed, createMemoryLeakWarning("hide"));
    }
    var isAlreadyHidden = !instance9.state.isVisible;
    var isDestroyed = instance9.state.isDestroyed;
    var isDisabled = !instance9.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance9.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance9], false);
    if (instance9.props.onHide(instance9) === false) {
      return;
    }
    instance9.state.isVisible = false;
    instance9.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
      if (instance9.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance9.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance9.unmount);
      }
    } else {
      instance9.unmount();
    }
  }
  function hideWithInteractivity(event) {
    if (true) {
      warnWhen(instance9.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
    }
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    if (true) {
      warnWhen(instance9.state.isDestroyed, createMemoryLeakWarning("unmount"));
    }
    if (instance9.state.isVisible) {
      instance9.hide();
    }
    if (!instance9.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i) {
      return i !== instance9;
    });
    instance9.state.isMounted = false;
    invokeHook("onHidden", [instance9]);
  }
  function destroy() {
    if (true) {
      warnWhen(instance9.state.isDestroyed, createMemoryLeakWarning("destroy"));
    }
    if (instance9.state.isDestroyed) {
      return;
    }
    instance9.clearDelayTimeouts();
    instance9.unmount();
    removeListeners();
    delete reference2._tippy;
    instance9.state.isDestroyed = true;
    invokeHook("onDestroy", [instance9]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  if (true) {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins
  });
  var elements = getArrayOfElements(targets);
  if (true) {
    var isSingleContentElement = isElement2(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var instances = elements.reduce(function(acc, reference2) {
    var instance9 = reference2 && createTippy(reference2, passedProps);
    if (instance9) {
      acc.push(instance9);
    }
    return acc;
  }, []);
  return isElement2(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
var applyStylesModifier = Object.assign({}, applyStyles_default, {
  effect: function effect4(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
  }
});
tippy.setDefaultProps({
  render
});
var tippy_esm_default = tippy;

// node_modules/@tiptap/extension-bubble-menu/dist/index.js
var BubbleMenuView = class {
  constructor({ editor, element: element2, view, tippyOptions = {}, updateDelay = 250, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state, from: from2, to }) => {
      const { doc: doc3, selection } = state;
      const { empty: empty3 } = selection;
      const isEmptyTextBlock = !doc3.textBetween(from2, to).length && isTextSelection(state.selection);
      const isChildOfMenu = this.element.contains(document.activeElement);
      const hasEditorFocus = view2.hasFocus() || isChildOfMenu;
      if (!hasEditorFocus || empty3 || isEmptyTextBlock || !this.editor.isEditable) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.dragstartHandler = () => {
      this.hide();
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      this.hide();
    };
    this.tippyBlurHandler = (event) => {
      this.blurHandler({ event });
    };
    this.handleDebouncedUpdate = (view2, oldState) => {
      const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view2.state.selection));
      const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view2.state.doc));
      if (!selectionChanged && !docChanged) {
        return;
      }
      if (this.updateDebounceTimer) {
        clearTimeout(this.updateDebounceTimer);
      }
      this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(view2, selectionChanged, docChanged, oldState);
      }, this.updateDelay);
    };
    this.updateHandler = (view2, selectionChanged, docChanged, oldState) => {
      var _a, _b, _c;
      const { state, composing } = view2;
      const { selection } = state;
      const isSame = !selectionChanged && !docChanged;
      if (composing || isSame) {
        return;
      }
      this.createTooltip();
      const { ranges } = selection;
      const from2 = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      const shouldShow2 = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
        editor: this.editor,
        view: view2,
        state,
        oldState,
        from: from2,
        to
      });
      if (!shouldShow2) {
        this.hide();
        return;
      }
      (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
        getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {
          if (isNodeSelection(state.selection)) {
            let node = view2.nodeDOM(from2);
            const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector("[data-node-view-wrapper]");
            if (nodeViewWrapper) {
              node = nodeViewWrapper.firstChild;
            }
            if (node) {
              return node.getBoundingClientRect();
            }
          }
          return posToDOMRect(view2, from2, to);
        })
      });
      this.show();
    };
    this.editor = editor;
    this.element = element2;
    this.view = view;
    this.updateDelay = updateDelay;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.addEventListener("dragstart", this.dragstartHandler);
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy_esm_default(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
    }
  }
  update(view, oldState) {
    const { state } = view;
    const hasValidSelection = state.selection.$from.pos !== state.selection.$to.pos;
    if (this.updateDelay > 0 && hasValidSelection) {
      this.handleDebouncedUpdate(view, oldState);
      return;
    }
    const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));
    const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));
    this.updateHandler(view, selectionChanged, docChanged, oldState);
  }
  show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a, _b;
    if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {
      this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
};
var BubbleMenuPlugin = (options) => {
  return new Plugin({
    key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
    view: (view) => new BubbleMenuView({ view, ...options })
  });
};
var BubbleMenu = Extension.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      BubbleMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});

// resources/js/extensions/ClassExtension.js
var ClassExtension = Extension.create({
  name: "classExtension",
  addGlobalAttributes() {
    return [
      {
        types: [
          "heading",
          "paragraph",
          "link",
          "image",
          "listItem",
          "bulletList",
          "orderedList",
          "table",
          "tableHeader",
          "tableRow",
          "tableCell",
          "textStyle"
        ],
        attributes: {
          class: {
            default: null,
            parseHTML: (element2) => element2.getAttribute("class") ?? null,
            renderHTML: (attributes) => {
              if (!attributes.class) {
                return null;
              }
              return {
                class: attributes.class
              };
            }
          }
        }
      }
    ];
  }
});

// resources/js/extensions/IdExtension.js
var IdExtension = Extension.create({
  name: "idExtension",
  addGlobalAttributes() {
    return [
      {
        types: [
          "heading",
          "link"
        ],
        attributes: {
          id: {
            default: null,
            parseHTML: (element2) => element2.getAttribute("id") ?? null,
            renderHTML: (attributes) => {
              if (!attributes.id) {
                return null;
              }
              return {
                id: attributes.id
              };
            }
          }
        }
      }
    ];
  }
});

// node_modules/linkifyjs/dist/linkify.es.js
var encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5m\xF6gensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
var encodedUtlds = "\u03B5\u03BB1\u03C52\u0431\u04331\u0435\u043B3\u0434\u0435\u0442\u04384\u0435\u044E2\u043A\u0430\u0442\u043E\u043B\u0438\u043A6\u043E\u043C3\u043C\u043A\u04342\u043E\u043D1\u0441\u043A\u0432\u04306\u043E\u043D\u043B\u0430\u0439\u043D5\u0440\u04333\u0440\u0443\u04412\u04442\u0441\u0430\u0439\u04423\u0440\u04313\u0443\u043A\u04403\u049B\u0430\u04373\u0570\u0561\u05753\u05D9\u05E9\u05E8\u05D0\u05DC5\u05E7\u05D5\u05DD3\u0627\u0628\u0648\u0638\u0628\u064A5\u0631\u0627\u0645\u0643\u06485\u0644\u0627\u0631\u062F\u06464\u0628\u062D\u0631\u064A\u06465\u062C\u0632\u0627\u0626\u06315\u0633\u0639\u0648\u062F\u064A\u06296\u0639\u0644\u064A\u0627\u06465\u0645\u063A\u0631\u06285\u0645\u0627\u0631\u0627\u062A5\u06CC\u0631\u0627\u06465\u0628\u0627\u0631\u062A2\u0632\u0627\u06314\u064A\u062A\u06433\u06BE\u0627\u0631\u062A5\u062A\u0648\u0646\u06334\u0633\u0648\u062F\u0627\u06463\u0631\u064A\u06295\u0634\u0628\u0643\u06294\u0639\u0631\u0627\u06422\u06282\u0645\u0627\u06464\u0641\u0644\u0633\u0637\u064A\u06466\u0642\u0637\u06313\u0643\u0627\u062B\u0648\u0644\u064A\u06436\u0648\u06453\u0645\u0635\u06312\u0644\u064A\u0633\u064A\u06275\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u06277\u0642\u06394\u0647\u0645\u0631\u0627\u06475\u067E\u0627\u06A9\u0633\u062A\u0627\u06467\u0680\u0627\u0631\u062A4\u0915\u0949\u092E3\u0928\u0947\u091F3\u092D\u093E\u0930\u09240\u092E\u094D3\u094B\u09245\u0938\u0902\u0917\u0920\u09285\u09AC\u09BE\u0982\u09B2\u09BE5\u09AD\u09BE\u09B0\u09A42\u09F0\u09A44\u0A2D\u0A3E\u0A30\u0A244\u0AAD\u0ABE\u0AB0\u0AA44\u0B2D\u0B3E\u0B30\u0B244\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE6\u0BB2\u0B99\u0BCD\u0B95\u0BC86\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD11\u0C2D\u0C3E\u0C30\u0C24\u0C4D5\u0CAD\u0CBE\u0CB0\u0CA44\u0D2D\u0D3E\u0D30\u0D24\u0D025\u0DBD\u0D82\u0D9A\u0DCF4\u0E04\u0E2D\u0E213\u0E44\u0E17\u0E223\u0EA5\u0EB2\u0EA73\u10D2\u10D42\u307F\u3093\u306A3\u30A2\u30DE\u30BE\u30F34\u30AF\u30E9\u30A6\u30C94\u30B0\u30FC\u30B0\u30EB4\u30B3\u30E02\u30B9\u30C8\u30A23\u30BB\u30FC\u30EB3\u30D5\u30A1\u30C3\u30B7\u30E7\u30F36\u30DD\u30A4\u30F3\u30C84\u4E16\u754C2\u4E2D\u4FE11\u56FD1\u570B1\u6587\u7F513\u4E9A\u9A6C\u900A3\u4F01\u4E1A2\u4F5B\u5C712\u4FE1\u606F2\u5065\u5EB72\u516B\u53662\u516C\u53F81\u76CA2\u53F0\u6E7E1\u70632\u5546\u57CE1\u5E971\u68072\u5609\u91CC0\u5927\u9152\u5E975\u5728\u7EBF2\u5927\u62FF2\u5929\u4E3B\u65593\u5A31\u4E502\u5BB6\u96FB2\u5E7F\u4E1C2\u5FAE\u535A2\u6148\u55842\u6211\u7231\u4F603\u624B\u673A2\u62DB\u80582\u653F\u52A11\u5E9C2\u65B0\u52A0\u57612\u95FB2\u65F6\u5C1A2\u66F8\u7C4D2\u673A\u67842\u6DE1\u9A6C\u95213\u6E38\u620F2\u6FB3\u95802\u70B9\u770B2\u79FB\u52A82\u7EC4\u7EC7\u673A\u67844\u7F51\u57401\u5E971\u7AD91\u7EDC2\u8054\u901A2\u8C37\u6B4C2\u8D2D\u72692\u901A\u8CA92\u96C6\u56E22\u96FB\u8A0A\u76C8\u79D14\u98DE\u5229\u6D663\u98DF\u54C12\u9910\u53852\u9999\u683C\u91CC\u62C93\u6E2F2\uB2F7\uB1371\uCEF42\uC0BC\uC1312\uD55C\uAD6D2";
var assign2 = (target, properties) => {
  for (const key in properties) {
    target[key] = properties[key];
  }
  return target;
};
var numeric = "numeric";
var ascii = "ascii";
var alpha = "alpha";
var asciinumeric = "asciinumeric";
var alphanumeric = "alphanumeric";
var domain = "domain";
var emoji = "emoji";
var scheme = "scheme";
var slashscheme = "slashscheme";
var whitespace = "whitespace";
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}
function addToGroups(t, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (const k in flags) {
    const group = registerGroup(k, groups);
    if (group.indexOf(t) < 0) {
      group.push(t);
    }
  }
}
function flagsForToken(t, groups) {
  const result = {};
  for (const c in groups) {
    if (groups[c].indexOf(t) >= 0) {
      result[c] = true;
    }
  }
  return result;
}
function State(token) {
  if (token === void 0) {
    token = null;
  }
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.groups = {};
State.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(input) {
    const state = this;
    const nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (let i = 0; i < state.jr.length; i++) {
      const regex = state.jr[i][0];
      const nextState2 = state.jr[i][1];
      if (nextState2 && regex.test(input)) {
        return nextState2;
      }
    }
    return state.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(input, exactOnly) {
    if (exactOnly === void 0) {
      exactOnly = false;
    }
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(inputs, next, flags, groups) {
    for (let i = 0; i < inputs.length; i++) {
      this.tt(inputs[i], next, flags, groups);
    }
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(regexp, next, flags, groups) {
    groups = groups || State.groups;
    let nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp, nextState]);
    return nextState;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(input, next, flags, groups) {
    let state = this;
    const len = input.length;
    if (!len) {
      return state;
    }
    for (let i = 0; i < len - 1; i++) {
      state = state.tt(input[i]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(input, next, flags, groups) {
    groups = groups || State.groups;
    const state = this;
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    const t = next;
    let nextState, templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      assign2(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t) {
      if (groups) {
        if (nextState.t && typeof nextState.t === "string") {
          const allFlags = assign2(flagsForToken(nextState.t, groups), flags);
          addToGroups(t, allFlags, groups);
        } else if (flags) {
          addToGroups(t, flags, groups);
        }
      }
      nextState.t = t;
    }
    state.j[input] = nextState;
    return nextState;
  }
};
var ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);
var tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);
var ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);
var tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);
var WORD = "WORD";
var UWORD = "UWORD";
var LOCALHOST = "LOCALHOST";
var TLD = "TLD";
var UTLD = "UTLD";
var SCHEME = "SCHEME";
var SLASH_SCHEME = "SLASH_SCHEME";
var NUM = "NUM";
var WS = "WS";
var NL$1 = "NL";
var OPENBRACE = "OPENBRACE";
var CLOSEBRACE = "CLOSEBRACE";
var OPENBRACKET = "OPENBRACKET";
var CLOSEBRACKET = "CLOSEBRACKET";
var OPENPAREN = "OPENPAREN";
var CLOSEPAREN = "CLOSEPAREN";
var OPENANGLEBRACKET = "OPENANGLEBRACKET";
var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
var FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
var FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
var LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
var RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
var LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
var RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
var FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
var FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
var AMPERSAND = "AMPERSAND";
var APOSTROPHE = "APOSTROPHE";
var ASTERISK = "ASTERISK";
var AT = "AT";
var BACKSLASH = "BACKSLASH";
var BACKTICK = "BACKTICK";
var CARET = "CARET";
var COLON = "COLON";
var COMMA = "COMMA";
var DOLLAR = "DOLLAR";
var DOT = "DOT";
var EQUALS = "EQUALS";
var EXCLAMATION = "EXCLAMATION";
var HYPHEN = "HYPHEN";
var PERCENT = "PERCENT";
var PIPE = "PIPE";
var PLUS = "PLUS";
var POUND = "POUND";
var QUERY = "QUERY";
var QUOTE = "QUOTE";
var SEMI = "SEMI";
var SLASH = "SLASH";
var TILDE = "TILDE";
var UNDERSCORE = "UNDERSCORE";
var EMOJI$1 = "EMOJI";
var SYM = "SYM";
var tk = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD,
  UWORD,
  LOCALHOST,
  TLD,
  UTLD,
  SCHEME,
  SLASH_SCHEME,
  NUM,
  WS,
  NL: NL$1,
  OPENBRACE,
  CLOSEBRACE,
  OPENBRACKET,
  CLOSEBRACKET,
  OPENPAREN,
  CLOSEPAREN,
  OPENANGLEBRACKET,
  CLOSEANGLEBRACKET,
  FULLWIDTHLEFTPAREN,
  FULLWIDTHRIGHTPAREN,
  LEFTCORNERBRACKET,
  RIGHTCORNERBRACKET,
  LEFTWHITECORNERBRACKET,
  RIGHTWHITECORNERBRACKET,
  FULLWIDTHLESSTHAN,
  FULLWIDTHGREATERTHAN,
  AMPERSAND,
  APOSTROPHE,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EQUALS,
  EXCLAMATION,
  HYPHEN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  SEMI,
  SLASH,
  TILDE,
  UNDERSCORE,
  EMOJI: EMOJI$1,
  SYM
});
var ASCII_LETTER = /[a-z]/;
var LETTER = /\p{L}/u;
var EMOJI = /\p{Emoji}/u;
var DIGIT = /\d/;
var SPACE = /\s/;
var NL = "\n";
var EMOJI_VARIATION = "\uFE0F";
var EMOJI_JOINER = "\u200D";
var tlds = null;
var utlds = null;
function init$2(customSchemes) {
  if (customSchemes === void 0) {
    customSchemes = [];
  }
  const groups = {};
  State.groups = groups;
  const Start = new State();
  if (tlds == null) {
    tlds = decodeTlds(encodedTlds);
  }
  if (utlds == null) {
    utlds = decodeTlds(encodedUtlds);
  }
  tt(Start, "'", APOSTROPHE);
  tt(Start, "{", OPENBRACE);
  tt(Start, "}", CLOSEBRACE);
  tt(Start, "[", OPENBRACKET);
  tt(Start, "]", CLOSEBRACKET);
  tt(Start, "(", OPENPAREN);
  tt(Start, ")", CLOSEPAREN);
  tt(Start, "<", OPENANGLEBRACKET);
  tt(Start, ">", CLOSEANGLEBRACKET);
  tt(Start, "\uFF08", FULLWIDTHLEFTPAREN);
  tt(Start, "\uFF09", FULLWIDTHRIGHTPAREN);
  tt(Start, "\u300C", LEFTCORNERBRACKET);
  tt(Start, "\u300D", RIGHTCORNERBRACKET);
  tt(Start, "\u300E", LEFTWHITECORNERBRACKET);
  tt(Start, "\u300F", RIGHTWHITECORNERBRACKET);
  tt(Start, "\uFF1C", FULLWIDTHLESSTHAN);
  tt(Start, "\uFF1E", FULLWIDTHGREATERTHAN);
  tt(Start, "&", AMPERSAND);
  tt(Start, "*", ASTERISK);
  tt(Start, "@", AT);
  tt(Start, "`", BACKTICK);
  tt(Start, "^", CARET);
  tt(Start, ":", COLON);
  tt(Start, ",", COMMA);
  tt(Start, "$", DOLLAR);
  tt(Start, ".", DOT);
  tt(Start, "=", EQUALS);
  tt(Start, "!", EXCLAMATION);
  tt(Start, "-", HYPHEN);
  tt(Start, "%", PERCENT);
  tt(Start, "|", PIPE);
  tt(Start, "+", PLUS);
  tt(Start, "#", POUND);
  tt(Start, "?", QUERY);
  tt(Start, '"', QUOTE);
  tt(Start, "/", SLASH);
  tt(Start, ";", SEMI);
  tt(Start, "~", TILDE);
  tt(Start, "_", UNDERSCORE);
  tt(Start, "\\", BACKSLASH);
  const Num = tr(Start, DIGIT, NUM, {
    [numeric]: true
  });
  tr(Num, DIGIT, Num);
  const Word = tr(Start, ASCII_LETTER, WORD, {
    [ascii]: true
  });
  tr(Word, ASCII_LETTER, Word);
  const UWord = tr(Start, LETTER, UWORD, {
    [alpha]: true
  });
  tr(UWord, ASCII_LETTER);
  tr(UWord, LETTER, UWord);
  const Ws = tr(Start, SPACE, WS, {
    [whitespace]: true
  });
  tt(Start, NL, NL$1, {
    [whitespace]: true
  });
  tt(Ws, NL);
  tr(Ws, SPACE, Ws);
  const Emoji = tr(Start, EMOJI, EMOJI$1, {
    [emoji]: true
  });
  tr(Emoji, EMOJI, Emoji);
  tt(Emoji, EMOJI_VARIATION, Emoji);
  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
  tr(EmojiJoiner, EMOJI, Emoji);
  const wordjr = [[ASCII_LETTER, Word]];
  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];
  for (let i = 0; i < tlds.length; i++) {
    fastts(Start, tlds[i], TLD, WORD, wordjr);
  }
  for (let i = 0; i < utlds.length; i++) {
    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);
  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);
  for (let i = 0; i < customSchemes.length; i++) {
    const sch = customSchemes[i][0];
    const optionalSlashSlash = customSchemes[i][1];
    const flags = optionalSlashSlash ? {
      [scheme]: true
    } : {
      [slashscheme]: true
    };
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts(Start, sch, sch, flags);
  }
  ts(Start, "localhost", LOCALHOST, {
    ascii: true
  });
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: assign2({
      groups
    }, tk)
  };
}
function run$12(start2, str) {
  const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
  const charCount = iterable.length;
  const tokens = [];
  let cursor = 0;
  let charCursor = 0;
  while (charCursor < charCount) {
    let state = start2;
    let nextState = null;
    let tokenLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    let charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str) {
  const result = [];
  const len = str.length;
  let index = 0;
  while (index < len) {
    let first2 = str.charCodeAt(index);
    let second;
    let char = first2 < 55296 || first2 > 56319 || index + 1 === len || (second = str.charCodeAt(index + 1)) < 56320 || second > 57343 ? str[index] : str.slice(index, index + 2);
    result.push(char);
    index += char.length;
  }
  return result;
}
function fastts(state, input, t, defaultt, jr) {
  let next;
  const len = input.length;
  for (let i = 0; i < len - 1; i++) {
    const char = input[i];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function decodeTlds(encoded) {
  const words = [];
  const stack = [];
  let i = 0;
  let digits = "0123456789";
  while (i < encoded.length) {
    let popDigitCount = 0;
    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
      popDigitCount++;
    }
    if (popDigitCount > 0) {
      words.push(stack.join(""));
      for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {
        stack.pop();
      }
      i += popDigitCount;
    } else {
      stack.push(encoded[i]);
      i++;
    }
  }
  return words;
}
var defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop2,
  formatHref: noop2,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: Infinity,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Options(opts, defaultRender) {
  if (defaultRender === void 0) {
    defaultRender = null;
  }
  let o = assign2({}, defaults);
  if (opts) {
    o = assign2(o, opts instanceof Options ? opts.o : opts);
  }
  const ignoredTags = o.ignoreTags;
  const uppercaseIgnoredTags = [];
  for (let i = 0; i < ignoredTags.length; i++) {
    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
  }
  this.o = o;
  if (defaultRender) {
    this.defaultRender = defaultRender;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(ir) {
    return ir;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(token) {
    return this.get("validate", token.toString(), token);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(key, operator, token) {
    const isCallable = operator != null;
    let option = this.o[key];
    if (!option) {
      return option;
    }
    if (typeof option === "object") {
      option = token.t in option ? option[token.t] : defaults[key];
      if (typeof option === "function" && isCallable) {
        option = option(operator, token);
      }
    } else if (typeof option === "function" && isCallable) {
      option = option(operator, token.t, token);
    }
    return option;
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(key, operator, token) {
    let obj = this.o[key];
    if (typeof obj === "function" && operator != null) {
      obj = obj(operator, token.t, token);
    }
    return obj;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(token) {
    const ir = token.render(this);
    const renderFn = this.get("render", null, token) || this.defaultRender;
    return renderFn(ir, token.t, token);
  }
};
function noop2(val) {
  return val;
}
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
MultiToken.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
  */
  toHref(scheme2) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(options) {
    const val = this.toString();
    const truncate = options.get("truncate", val, this);
    const formatted = options.get("format", val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "\u2026" : formatted;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(options) {
    return options.get("formatHref", this.toHref(options.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(protocol) {
    if (protocol === void 0) {
      protocol = defaults.defaultProtocol;
    }
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(options) {
    return {
      type: this.t,
      value: this.toFormattedString(options),
      isLink: this.isLink,
      href: this.toFormattedHref(options),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(options) {
    return options.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(options) {
    const token = this;
    const href = this.toHref(options.get("defaultProtocol"));
    const formattedHref = options.get("formatHref", href, this);
    const tagName = options.get("tagName", href, token);
    const content = this.toFormattedString(options);
    const attributes = {};
    const className = options.get("className", href, token);
    const target = options.get("target", href, token);
    const rel = options.get("rel", href, token);
    const attrs = options.getObj("attributes", href, token);
    const eventListeners = options.getObj("events", href, token);
    attributes.href = formattedHref;
    if (className) {
      attributes.class = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs) {
      assign2(attributes, attrs);
    }
    return {
      tagName,
      attributes,
      content,
      eventListeners
    };
  }
};
function createTokenClass(type, props) {
  class Token extends MultiToken {
    constructor(value, tokens) {
      super(value, tokens);
      this.t = type;
    }
  }
  for (const p in props) {
    Token.prototype[p] = props[p];
  }
  Token.t = type;
  return Token;
}
var Email = createTokenClass("email", {
  isLink: true,
  toHref() {
    return "mailto:" + this.toString();
  }
});
var Text = createTokenClass("text");
var Nl = createTokenClass("nl");
var Url = createTokenClass("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(scheme2) {
    if (scheme2 === void 0) {
      scheme2 = defaults.defaultProtocol;
    }
    return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
var makeState = (arg) => new State(arg);
function init$1(_ref) {
  let {
    groups
  } = _ref;
  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  const Start = makeState();
  const Localpart = tt(Start, TILDE);
  ta(Localpart, localpartAccepting, Localpart);
  ta(Localpart, groups.domain, Localpart);
  const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta(Start, groups.domain, Domain);
  ta(Start, groups.scheme, Scheme);
  ta(Start, groups.slashscheme, SlashScheme);
  ta(Domain, localpartAccepting, Localpart);
  ta(Domain, groups.domain, Domain);
  const LocalpartAt = tt(Domain, AT);
  tt(Localpart, AT, LocalpartAt);
  tt(Scheme, AT, LocalpartAt);
  tt(SlashScheme, AT, LocalpartAt);
  const LocalpartDot = tt(Localpart, DOT);
  ta(LocalpartDot, localpartAccepting, Localpart);
  ta(LocalpartDot, groups.domain, Localpart);
  const EmailDomain = makeState();
  ta(LocalpartAt, groups.domain, EmailDomain);
  ta(EmailDomain, groups.domain, EmailDomain);
  const EmailDomainDot = tt(EmailDomain, DOT);
  ta(EmailDomainDot, groups.domain, EmailDomain);
  const Email$1 = makeState(Email);
  ta(EmailDomainDot, groups.tld, Email$1);
  ta(EmailDomainDot, groups.utld, Email$1);
  tt(LocalpartAt, LOCALHOST, Email$1);
  const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
  ta(EmailDomainHyphen, groups.domain, EmailDomain);
  ta(Email$1, groups.domain, EmailDomain);
  tt(Email$1, DOT, EmailDomainDot);
  tt(Email$1, HYPHEN, EmailDomainHyphen);
  const EmailColon = tt(Email$1, COLON);
  ta(EmailColon, groups.numeric, Email);
  const DomainHyphen = tt(Domain, HYPHEN);
  const DomainDot = tt(Domain, DOT);
  ta(DomainHyphen, groups.domain, Domain);
  ta(DomainDot, localpartAccepting, Localpart);
  ta(DomainDot, groups.domain, Domain);
  const DomainDotTld = makeState(Url);
  ta(DomainDot, groups.tld, DomainDotTld);
  ta(DomainDot, groups.utld, DomainDotTld);
  ta(DomainDotTld, groups.domain, Domain);
  ta(DomainDotTld, localpartAccepting, Localpart);
  tt(DomainDotTld, DOT, DomainDot);
  tt(DomainDotTld, HYPHEN, DomainHyphen);
  tt(DomainDotTld, AT, LocalpartAt);
  const DomainDotTldColon = tt(DomainDotTld, COLON);
  const DomainDotTldColonPort = makeState(Url);
  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  const Url$1 = makeState(Url);
  const UrlNonaccept = makeState();
  ta(Url$1, qsAccepting, Url$1);
  ta(Url$1, qsNonAccepting, UrlNonaccept);
  ta(UrlNonaccept, qsAccepting, Url$1);
  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt(DomainDotTld, SLASH, Url$1);
  tt(DomainDotTldColonPort, SLASH, Url$1);
  const SchemeColon = tt(Scheme, COLON);
  const SlashSchemeColon = tt(SlashScheme, COLON);
  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
  const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
  ta(Scheme, groups.domain, Domain);
  tt(Scheme, DOT, DomainDot);
  tt(Scheme, HYPHEN, DomainHyphen);
  ta(SlashScheme, groups.domain, Domain);
  tt(SlashScheme, DOT, DomainDot);
  tt(SlashScheme, HYPHEN, DomainHyphen);
  ta(SchemeColon, groups.domain, Url$1);
  tt(SchemeColon, SLASH, Url$1);
  ta(UriPrefix, groups.domain, Url$1);
  ta(UriPrefix, qsAccepting, Url$1);
  tt(UriPrefix, SLASH, Url$1);
  const bracketPairs = [
    [OPENBRACE, CLOSEBRACE],
    // {}
    [OPENBRACKET, CLOSEBRACKET],
    // []
    [OPENPAREN, CLOSEPAREN],
    // ()
    [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
    // <>
    [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
    // （）
    [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
    // 「」
    [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
    // 『』
    [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
    // ＜＞
  ];
  for (let i = 0; i < bracketPairs.length; i++) {
    const [OPEN, CLOSE] = bracketPairs[i];
    const UrlOpen = tt(Url$1, OPEN);
    tt(UrlNonaccept, OPEN, UrlOpen);
    tt(UrlOpen, CLOSE, Url$1);
    const UrlOpenQ = makeState(Url);
    ta(UrlOpen, qsAccepting, UrlOpenQ);
    const UrlOpenSyms = makeState();
    ta(UrlOpen, qsNonAccepting);
    ta(UrlOpenQ, qsAccepting, UrlOpenQ);
    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
    tt(UrlOpenQ, CLOSE, Url$1);
    tt(UrlOpenSyms, CLOSE, Url$1);
  }
  tt(Start, LOCALHOST, DomainDotTld);
  tt(Start, NL$1, Nl);
  return {
    start: Start,
    tokens: tk
  };
}
function run3(start2, input, tokens) {
  let len = tokens.length;
  let cursor = 0;
  let multis = [];
  let textTokens = [];
  while (cursor < len) {
    let state = start2;
    let secondState = null;
    let nextState = null;
    let multiLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      const Multi = latestAccepting.t;
      const subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  const startIdx = tokens[0].s;
  const endIdx = tokens[tokens.length - 1].e;
  const value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
var warn = typeof console !== "undefined" && console && console.warn || (() => {
});
var warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
var INIT = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};
function reset() {
  State.groups = {};
  INIT.scanner = null;
  INIT.parser = null;
  INIT.tokenQueue = [];
  INIT.pluginQueue = [];
  INIT.customSchemes = [];
  INIT.initialized = false;
}
function registerCustomProtocol(scheme2, optionalSlashSlash) {
  if (optionalSlashSlash === void 0) {
    optionalSlashSlash = false;
  }
  if (INIT.initialized) {
    warn(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
  }
  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  }
  INIT.customSchemes.push([scheme2, optionalSlashSlash]);
}
function init2() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (let i = 0; i < INIT.tokenQueue.length; i++) {
    INIT.tokenQueue[i][1]({
      scanner: INIT.scanner
    });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (let i = 0; i < INIT.pluginQueue.length; i++) {
    INIT.pluginQueue[i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init2();
  }
  return run3(INIT.parser.start, str, run$12(INIT.scanner.start, str));
}
function find(str, type, opts) {
  if (type === void 0) {
    type = null;
  }
  if (opts === void 0) {
    opts = null;
  }
  if (type && typeof type === "object") {
    if (opts) {
      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);
    }
    opts = type;
    type = null;
  }
  const options = new Options(opts);
  const tokens = tokenize(str);
  const filtered = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token.isLink && (!type || token.t === type) && options.check(token)) {
      filtered.push(token.toFormattedObject(options));
    }
  }
  return filtered;
}

// node_modules/@tiptap/extension-link/dist/index.js
function autolink(options) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr: tr2 } = newState;
      const transform = combineTransactionSteps(oldState.doc, [...transactions]);
      const changes = getChangedRanges(transform);
      changes.forEach(({ newRange }) => {
        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node) => node.isTextblock);
        let textBlock;
        let textBeforeWhitespace;
        if (nodesInChangedRanges.length > 1) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
        } else if (nodesInChangedRanges.length && newState.doc.textBetween(newRange.from, newRange.to, " ", " ").endsWith(" ")) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
        }
        if (textBlock && textBeforeWhitespace) {
          const wordsBeforeWhitespace = textBeforeWhitespace.split(" ").filter((s) => s !== "");
          if (wordsBeforeWhitespace.length <= 0) {
            return false;
          }
          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
          if (!lastWordBeforeSpace) {
            return false;
          }
          find(lastWordBeforeSpace).filter((link) => link.isLink).map((link) => ({
            ...link,
            from: lastWordAndBlockOffset + link.start + 1,
            to: lastWordAndBlockOffset + link.end + 1
          })).filter((link) => {
            if (!newState.schema.marks.code) {
              return true;
            }
            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
          }).filter((link) => {
            if (options.validate) {
              return options.validate(link.value);
            }
            return true;
          }).forEach((link) => {
            if (getMarksBetween(link.from, link.to, newState.doc).some((item) => item.mark.type === options.type)) {
              return;
            }
            tr2.addMark(link.from, link.to, options.type.create({
              href: link.href
            }));
          });
        }
      });
      if (!tr2.steps.length) {
        return;
      }
      return tr2;
    }
  });
}
function clickHandler(options) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a, _b;
        if (event.button !== 0) {
          return false;
        }
        const eventTarget = event.target;
        if (eventTarget.nodeName !== "A") {
          return false;
        }
        const attrs = getAttributes(view.state, options.type.name);
        const link = event.target;
        const href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs.href;
        const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;
        if (link && href) {
          if (view.editable) {
            window.open(href, target);
          }
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, event, slice2) => {
        var _a;
        const { state } = view;
        const { selection } = state;
        const { empty: empty3 } = selection;
        if (empty3) {
          return false;
        }
        let textContent = "";
        slice2.content.forEach((node) => {
          textContent += node.textContent;
        });
        const link = find(textContent).find((item) => item.isLink && item.value === textContent);
        if (!textContent || !link) {
          return false;
        }
        const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
        const hrefRegex = /href="([^"]*)"/;
        const existingLink = html === null || html === void 0 ? void 0 : html.match(hrefRegex);
        const url = existingLink ? existingLink[1] : link.href;
        options.editor.commands.setMark(options.type, {
          href: url
        });
        return true;
      }
    }
  });
}
var Link = Mark2.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  onCreate() {
    this.options.protocols.forEach((protocol) => {
      if (typeof protocol === "string") {
        registerCustomProtocol(protocol);
        return;
      }
      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
    });
  },
  onDestroy() {
    reset();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      validate: void 0
    };
  },
  addAttributes() {
    return {
      href: {
        default: null
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [{ tag: 'a[href]:not([href *= "javascript:" i])' }];
  },
  renderHTML({ HTMLAttributes }) {
    var _a;
    if ((_a = HTMLAttributes.href) === null || _a === void 0 ? void 0 : _a.startsWith("javascript:")) {
      return ["a", mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }), 0];
    }
    return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain }) => {
        return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain }) => {
        return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain }) => {
        return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: (text2) => find(text2).filter((link) => {
          if (this.options.validate) {
            return this.options.validate(link.value);
          }
          return true;
        }).filter((link) => link.isLink).map((link) => ({
          text: link.value,
          index: link.start,
          data: link
        })),
        type: this.type,
        getAttributes: (match, pasteEvent) => {
          var _a, _b;
          const html = (_a = pasteEvent === null || pasteEvent === void 0 ? void 0 : pasteEvent.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
          const hrefRegex = /href="([^"]*)"/;
          const existingLink = html === null || html === void 0 ? void 0 : html.match(hrefRegex);
          if (existingLink) {
            return {
              href: existingLink[1]
            };
          }
          return {
            href: (_b = match.data) === null || _b === void 0 ? void 0 : _b.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins = [];
    if (this.options.autolink) {
      plugins.push(autolink({
        type: this.type,
        validate: this.options.validate
      }));
    }
    if (this.options.openOnClick) {
      plugins.push(clickHandler({
        type: this.type
      }));
    }
    if (this.options.linkOnPaste) {
      plugins.push(pasteHandler({
        editor: this.editor,
        type: this.type
      }));
    }
    return plugins;
  }
});

// resources/js/extensions/LinkExtension.js
var LinkExtension = Link.extend({
  inclusive: false,
  addOptions() {
    return {
      openOnClick: false,
      linkOnPaste: true,
      autolink: false,
      protocols: [],
      HTMLAttributes: {},
      validate: void 0
    };
  },
  addAttributes() {
    return {
      href: {
        default: null
      },
      id: {
        default: null
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      hreflang: {
        default: null
      },
      rel: {
        default: null
      },
      referrerpolicy: {
        default: null
      },
      class: {
        default: null
      },
      as_button: {
        default: null,
        parseHTML: (element2) => element2.getAttribute("data-as-button") ?? null,
        renderHTML: (attributes) => {
          if (!attributes.as_button)
            return;
          return {
            "data-as-button": attributes.as_button
          };
        }
      },
      button_theme: {
        default: null,
        parseHTML: (element2) => element2.getAttribute("data-as-button-theme") ?? null,
        renderHTML: (attributes) => {
          if (!attributes.button_theme)
            return;
          return {
            "data-as-button-theme": attributes.button_theme
          };
        }
      }
    };
  }
});

// node_modules/@tiptap/extension-image/dist/index.js
var inputRegex = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
var Image = Node2.create({
  name: "image",
  addOptions() {
    return {
      inline: false,
      allowBase64: false,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["img", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setImage: (options) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: options
        });
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: inputRegex,
        type: this.type,
        getAttributes: (match) => {
          const [, , alt, src, title] = match;
          return { src, alt, title };
        }
      })
    ];
  }
});

// node_modules/svelte-tiptap/dist/SvelteRenderer.js
var SvelteRenderer = class {
  constructor(component, { element: element2 }) {
    this.component = component;
    this.dom = element2;
    this.dom.classList.add("svelte-renderer");
  }
  updateProps(props) {
    this.component.$set(props);
  }
  destroy() {
    this.component.$destroy();
  }
};
var SvelteRenderer_default = SvelteRenderer;

// node_modules/svelte-tiptap/dist/context.js
var TIPTAP_NODE_VIEW = "TipTapNodeView";

// node_modules/svelte-tiptap/dist/SvelteNodeViewRenderer.js
var SvelteNodeView = class extends NodeView {
  mount() {
    const Component = this.component;
    const props = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      selected: false,
      extension: this.extension,
      getPos: () => this.getPos(),
      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),
      deleteNode: () => this.deleteNode()
    };
    this.contentDOMElement = this.node.isLeaf ? null : document.createElement(this.node.isInline ? "span" : "div");
    if (this.contentDOMElement) {
      this.contentDOMElement.style.whiteSpace = "inherit";
    }
    const context = /* @__PURE__ */ new Map();
    context.set(TIPTAP_NODE_VIEW, {
      onDragStart: this.onDragStart.bind(this)
    });
    const as = this.options.as ?? (this.node.isInline ? "span" : "div");
    const target = document.createElement(as);
    target.classList.add(`node-${this.node.type.name}`);
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);
    this.editor.on("selectionUpdate", this.handleSelectionUpdate);
    const svelteComponent = new Component({
      target,
      props,
      context
    });
    this.renderer = new SvelteRenderer_default(svelteComponent, {
      element: target
    });
    this.appendContendDom();
  }
  appendContendDom() {
    const contentElement = this.dom.querySelector("[data-node-view-content]");
    if (this.contentDOMElement && contentElement && !contentElement.contains(this.contentDOMElement)) {
      contentElement.appendChild(this.contentDOMElement);
    }
  }
  get dom() {
    if (!this.renderer.dom.firstElementChild?.hasAttribute("data-node-view-wrapper")) {
      throw Error("Please use the NodeViewWrapper component for your node view.");
    }
    return this.renderer.dom;
  }
  get contentDOM() {
    if (this.node.isLeaf) {
      return null;
    }
    return this.contentDOMElement;
  }
  handleSelectionUpdate() {
    const { from: from2, to } = this.editor.state.selection;
    if (from2 <= this.getPos() && to >= this.getPos() + this.node.nodeSize) {
      this.selectNode();
    } else {
      this.deselectNode();
    }
  }
  update(node, decorations) {
    const updateProps = () => {
      this.renderer.updateProps({ node, decorations });
    };
    if (typeof this.options.update === "function") {
      const oldNode = this.node;
      const oldDecorations = this.decorations;
      this.node = node;
      this.decorations = decorations;
      return this.options.update({
        oldNode,
        oldDecorations,
        newNode: node,
        newDecorations: decorations,
        updateProps: () => updateProps()
      });
    }
    if (node.type !== this.node.type) {
      return false;
    }
    if (node === this.node && this.decorations === decorations) {
      return true;
    }
    this.node = node;
    this.decorations = decorations;
    updateProps();
    return true;
  }
  selectNode() {
    this.renderer.updateProps({ selected: true });
  }
  deselectNode() {
    this.renderer.updateProps({ selected: false });
  }
  destroy() {
    this.renderer.destroy();
    this.editor.off("selectionUpdate", this.handleSelectionUpdate);
    this.contentDOMElement = null;
  }
};
var SvelteNodeViewRenderer = (component, options) => {
  return (props) => new SvelteNodeView(component, props, options);
};
var SvelteNodeViewRenderer_default = SvelteNodeViewRenderer;

// node_modules/svelte-tiptap/dist/NodeViewWrapper.svelte
function create_dynamic_element(ctx) {
  let svelte_element;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let svelte_element_levels = [
    { "data-node-view-wrapper": "" },
    { role: "none" },
    /*$$restProps*/
    ctx[3]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  return {
    c() {
      svelte_element = element(
        /*as*/
        ctx[0]
      );
      if (default_slot)
        default_slot.c();
      set_dynamic_element_data(
        /*as*/
        ctx[0]
      )(svelte_element, svelte_element_data);
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[6](svelte_element);
      current = true;
      if (!mounted) {
        dispose = listen(
          svelte_element,
          "dragstart",
          /*onDragStart*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*as*/
        ctx2[0]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        { "data-node-view-wrapper": "" },
        { role: "none" },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let previous_tag = (
    /*as*/
    ctx[0]
  );
  let svelte_element_anchor;
  let current;
  let svelte_element = (
    /*as*/
    ctx[0] && create_dynamic_element(ctx)
  );
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*as*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*as*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*as*/
        ctx2[0];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(svelte_element, local);
      current = true;
    },
    o(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["as"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const { onDragStart } = getContext(TIPTAP_NODE_VIEW);
  let element2;
  let { as = "div" } = $$props;
  onMount(async () => {
    await tick();
    $$invalidate(1, element2.style.whiteSpace = "normal", element2);
  });
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  return [as, element2, onDragStart, $$restProps, $$scope, slots, svelte_element_binding];
}
var NodeViewWrapper = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { as: 0 });
  }
};
var NodeViewWrapper_default = NodeViewWrapper;

// node_modules/svelte-tiptap/dist/NodeViewContent.svelte
function create_dynamic_element2(ctx) {
  let svelte_element;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let svelte_element_levels = [
    { "data-node-view-content": "" },
    /*$$restProps*/
    ctx[2]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  return {
    c() {
      svelte_element = element(
        /*as*/
        ctx[0]
      );
      if (default_slot)
        default_slot.c();
      set_dynamic_element_data(
        /*as*/
        ctx[0]
      )(svelte_element, svelte_element_data);
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[5](svelte_element);
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*as*/
        ctx2[0]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        { "data-node-view-content": "" },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[5](null);
    }
  };
}
function create_fragment2(ctx) {
  let previous_tag = (
    /*as*/
    ctx[0]
  );
  let svelte_element_anchor;
  let current;
  let svelte_element = (
    /*as*/
    ctx[0] && create_dynamic_element2(ctx)
  );
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*as*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element2(ctx2);
          previous_tag = /*as*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*as*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element2(ctx2);
          previous_tag = /*as*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*as*/
        ctx2[0];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(svelte_element, local);
      current = true;
    },
    o(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["as"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let element2;
  let { as = "div" } = $$props;
  onMount(async () => {
    await tick();
    $$invalidate(1, element2.style.whiteSpace = "pre-wrap", element2);
  });
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  return [as, element2, $$restProps, $$scope, slots, svelte_element_binding];
}
var NodeViewContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { as: 0 });
  }
};
var NodeViewContent_default = NodeViewContent;

// resources/js/utils/pounce.js
var pounce = (component, args) => {
  window.Livewire.dispatch("pounce", { component, arguments: args });
};

// resources/js/stores.js
var getStatePath = writable(null);

// resources/js/components/MediaView.svelte
function create_default_slot(ctx) {
  let div3;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let img_title_value;
  let img_width_value;
  let img_height_value;
  let img_loading_value;
  let div0_class_value;
  let t0;
  let div2;
  let div1;
  let t1;
  let button0;
  let t2;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      div1.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="size-4"><path d="m22.67 12l-4.49 4.5l-2.51-2.5l1.98-2l-1.98-1.96l2.51-2.51zM12 1.33l4.47 4.49l-2.51 2.51L12 6.35l-2 1.98l-2.5-2.51zm0 21.34l-4.47-4.49l2.51-2.51L12 17.65l2-1.98l2.5 2.51zM1.33 12l4.49-4.5L8.33 10l-1.98 2l1.98 1.96l-2.51 2.51zM12 10a2 2 0 0 1 2 2a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2"></path></svg>`;
      t1 = space();
      button0 = element("button");
      button0.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="size-4"><path fill-rule="evenodd" d="M15 4.5A3.5 3.5 0 0 1 11.435 8c-.99-.019-2.093.132-2.7.913l-4.13 5.31a2.015 2.015 0 1 1-2.827-2.828l5.309-4.13c.78-.607.932-1.71.914-2.7L8 4.5a3.5 3.5 0 0 1 4.477-3.362c.325.094.39.497.15.736L10.6 3.902a.48.48 0 0 0-.033.653c.271.314.565.608.879.879a.48.48 0 0 0 .653-.033l2.027-2.027c.239-.24.642-.175.736.15.09.31.138.637.138.976ZM3.75 13a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0Z" clip-rule="evenodd"></path><path d="M11.5 9.5c.313 0 .62-.029.917-.084l1.962 1.962a2.121 2.121 0 0 1-3 3l-2.81-2.81 1.35-1.734c.05-.064.158-.158.426-.233.278-.078.639-.11 1.062-.102l.093.001ZM5 4l1.446 1.445a2.256 2.256 0 0 1-.047.21c-.075.268-.169.377-.233.427l-.61.474L4 5H2.655a.25.25 0 0 1-.224-.139l-1.35-2.7a.25.25 0 0 1 .047-.289l.745-.745a.25.25 0 0 1 .289-.047l2.7 1.35A.25.25 0 0 1 5 2.654V4Z"></path></svg>`;
      t2 = space();
      button1 = element("button");
      button1.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="size-4"><path fill-rule="evenodd" d="M5 3.25V4H2.75a.75.75 0 0 0 0 1.5h.3l.815 8.15A1.5 1.5 0 0 0 5.357 15h5.285a1.5 1.5 0 0 0 1.493-1.35l.815-8.15h.3a.75.75 0 0 0 0-1.5H11v-.75A2.25 2.25 0 0 0 8.75 1h-1.5A2.25 2.25 0 0 0 5 3.25Zm2.25-.75a.75.75 0 0 0-.75.75V4h3v-.75a.75.75 0 0 0-.75-.75h-1.5ZM6.05 6a.75.75 0 0 1 .787.713l.275 5.5a.75.75 0 0 1-1.498.075l-.275-5.5A.75.75 0 0 1 6.05 6Zm3.9 0a.75.75 0 0 1 .712.787l-.275 5.5a.75.75 0 0 1-1.498-.075l.275-5.5a.75.75 0 0 1 .786-.711Z" clip-rule="evenodd"></path></svg>`;
      if (!src_url_equal(img.src, img_src_value = /*node*/
      ctx[0].attrs.src))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*node*/
      ctx[0].attrs.alt);
      attr(img, "title", img_title_value = /*node*/
      ctx[0].attrs?.title ?? null);
      attr(img, "width", img_width_value = /*node*/
      ctx[0].attrs.width);
      attr(img, "height", img_height_value = /*node*/
      ctx[0].attrs.height);
      attr(img, "loading", img_loading_value = /*node*/
      ctx[0].attrs.loading);
      attr(div0, "class", div0_class_value = "transition rounded-md overflow-hidden z-10 relative " + /*selected*/
      (ctx[1] ? "ProseMirror-selectednode" : ""));
      attr(div1, "data-drag-handle", "");
      attr(div1, "class", "cursor-grabbing text-white block rounded p-1 hover:text-primary-500 hover:bg-gray-800");
      attr(button0, "type", "button");
      attr(button0, "class", "text-white block rounded p-1 hover:text-primary-500 hover:bg-gray-800");
      attr(button1, "type", "button");
      attr(button1, "class", "text-white block rounded p-1 hover:text-primary-500 hover:bg-gray-800");
      attr(div2, "class", "scribble-block-actions transition opacity-0 absolute z-20 top-0 right-0 p-1 rounded-tr-md rounded-bl-lg flex items-center bg-gray-950 group-hover:opacity-100");
      attr(div3, "class", "relative group bg-gray-900/5 dark:bg-white/5 rounded-md");
      set_style(div3, "min-height", "3rem");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, img);
      append(div3, t0);
      append(div3, div2);
      append(div2, div1);
      append(div2, t1);
      append(div2, button0);
      append(div2, t2);
      append(div2, button1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", stop_propagation(prevent_default(
            /*open*/
            ctx[2]
          ))),
          listen(button1, "click", stop_propagation(prevent_default(
            /*removeBlock*/
            ctx[3]
          )))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*node*/
      1 && !src_url_equal(img.src, img_src_value = /*node*/
      ctx2[0].attrs.src)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*node*/
      1 && img_alt_value !== (img_alt_value = /*node*/
      ctx2[0].attrs.alt)) {
        attr(img, "alt", img_alt_value);
      }
      if (dirty & /*node*/
      1 && img_title_value !== (img_title_value = /*node*/
      ctx2[0].attrs?.title ?? null)) {
        attr(img, "title", img_title_value);
      }
      if (dirty & /*node*/
      1 && img_width_value !== (img_width_value = /*node*/
      ctx2[0].attrs.width)) {
        attr(img, "width", img_width_value);
      }
      if (dirty & /*node*/
      1 && img_height_value !== (img_height_value = /*node*/
      ctx2[0].attrs.height)) {
        attr(img, "height", img_height_value);
      }
      if (dirty & /*node*/
      1 && img_loading_value !== (img_loading_value = /*node*/
      ctx2[0].attrs.loading)) {
        attr(img, "loading", img_loading_value);
      }
      if (dirty & /*selected*/
      2 && div0_class_value !== (div0_class_value = "transition rounded-md overflow-hidden z-10 relative " + /*selected*/
      (ctx2[1] ? "ProseMirror-selectednode" : ""))) {
        attr(div0, "class", div0_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment3(ctx) {
  let nodeviewwrapper;
  let current;
  nodeviewwrapper = new NodeViewWrapper_default({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(nodeviewwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nodeviewwrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const nodeviewwrapper_changes = {};
      if (dirty & /*$$scope, selected, node*/
      131) {
        nodeviewwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      nodeviewwrapper.$set(nodeviewwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nodeviewwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodeviewwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nodeviewwrapper, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let $getStatePath;
  component_subscribe($$self, getStatePath, ($$value) => $$invalidate(6, $getStatePath = $$value));
  let { editor } = $$props;
  let { node } = $$props;
  let { selected = false } = $$props;
  let { updateAttributes: updateAttributes2 } = $$props;
  const open = () => {
    pounce("scribble-media", {
      update: true,
      statePath: $getStatePath,
      ...node.attrs
    });
  };
  const removeBlock = () => {
    editor.commands.deleteSelection();
  };
  onMount(() => {
    window.addEventListener("updatedBlock", (e) => {
      if (e.detail.type === node.attrs.type && e.detail.statePath === node.attrs.statePath) {
        updateAttributes2({ values: e.detail.values });
      }
    });
  });
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(4, editor = $$props2.editor);
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("selected" in $$props2)
      $$invalidate(1, selected = $$props2.selected);
    if ("updateAttributes" in $$props2)
      $$invalidate(5, updateAttributes2 = $$props2.updateAttributes);
  };
  return [node, selected, open, removeBlock, editor, updateAttributes2];
}
var MediaView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      editor: 4,
      node: 0,
      selected: 1,
      updateAttributes: 5
    });
  }
};
var MediaView_default = MediaView;

// resources/js/extensions/MediaExtension.js
var MediaExtension = Image.extend({
  selectable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      },
      width: {
        default: null
      },
      height: {
        default: null
      },
      loading: {
        default: null
      },
      sizes: {
        default: null
      },
      srcset: {
        default: null
      }
    };
  },
  addNodeView() {
    return SvelteNodeViewRenderer_default(MediaView_default);
  }
});

// node_modules/@tiptap/extension-placeholder/dist/index.js
var Placeholder = Extension.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something \u2026",
      showOnlyWhenEditable: true,
      showOnlyCurrent: true,
      includeChildren: false
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("placeholder"),
        props: {
          decorations: ({ doc: doc3, selection }) => {
            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
            const { anchor } = selection;
            const decorations = [];
            if (!active) {
              return null;
            }
            const emptyDocInstance = doc3.type.createAndFill();
            const isEditorEmpty = (emptyDocInstance === null || emptyDocInstance === void 0 ? void 0 : emptyDocInstance.sameMarkup(doc3)) && emptyDocInstance.content.findDiffStart(doc3.content) === null;
            doc3.descendants((node, pos) => {
              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;
              const isEmpty = !node.isLeaf && !node.childCount;
              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {
                const classes = [this.options.emptyNodeClass];
                if (isEditorEmpty) {
                  classes.push(this.options.emptyEditorClass);
                }
                const decoration = Decoration.node(pos, pos + node.nodeSize, {
                  class: classes.join(" "),
                  "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                    editor: this.editor,
                    node,
                    pos,
                    hasAnchor
                  }) : this.options.placeholder
                });
                decorations.push(decoration);
              }
              return this.options.includeChildren;
            });
            return DecorationSet.create(doc3, decorations);
          }
        }
      })
    ];
  }
});

// node_modules/@tiptap/extension-blockquote/dist/index.js
var inputRegex2 = /^\s*>\s$/;
var Blockquote = Node2.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: commands2 }) => {
        return commands2.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands: commands2 }) => {
        return commands2.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands: commands2 }) => {
        return commands2.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex2,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-bold/dist/index.js
var starInputRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/;
var starPasteRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g;
var underscoreInputRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/;
var underscorePasteRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;
var Bold = Mark2.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node) => node.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleBold: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetBold: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-bullet-list/dist/index.js
var ListItem = Node2.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
var TextStyle = Mark2.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (element2) => {
          const hasStyles = element2.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
        const attributes = getMarkAttributes(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) {
          return true;
        }
        return commands2.unsetMark(this.name);
      }
    };
  }
});
var inputRegex3 = /^\s*([-+*])\s$/;
var BulletList = Node2.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: commands2, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem.name, this.editor.getAttributes(TextStyle.name)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex3,
      type: this.type
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex3,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: () => {
          return this.editor.getAttributes(TextStyle.name);
        },
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});

// node_modules/@tiptap/extension-code/dist/index.js
var inputRegex4 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/;
var pasteRegex = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g;
var Code = Mark2.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  exitable: true,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleCode: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetCode: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex4,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-code-block/dist/index.js
var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
var CodeBlock = Node2.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: null,
        parseHTML: (element2) => {
          var _a;
          const { languageClassPrefix } = this.options;
          const classNames = [...((_a = element2.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []];
          const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
          const language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "pre",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      [
        "code",
        {
          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.setNode(this.name, attributes);
      },
      toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: empty3, $anchor } = this.editor.state.selection;
        const isAtStart = $anchor.pos === 1;
        if (!empty3 || $anchor.parent.type.name !== this.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return this.editor.commands.clearNodes();
        }
        return false;
      },
      // exit node on triple enter
      Enter: ({ editor }) => {
        if (!this.options.exitOnTripleEnter) {
          return false;
        }
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty3 } = selection;
        if (!empty3 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(({ tr: tr2 }) => {
          tr2.delete($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor }) => {
        if (!this.options.exitOnArrowDown) {
          return false;
        }
        const { state } = editor;
        const { selection, doc: doc3 } = state;
        const { $from, empty: empty3 } = selection;
        if (!empty3 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        const after = $from.after();
        if (after === void 0) {
          return false;
        }
        const nodeAfter = doc3.nodeAt(after);
        if (nodeAfter) {
          return false;
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      textblockTypeInputRule({
        find: backtickInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      }),
      textblockTypeInputRule({
        find: tildeInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Plugin({
        key: new PluginKey("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (view, event) => {
            if (!event.clipboardData) {
              return false;
            }
            if (this.editor.isActive(this.type.name)) {
              return false;
            }
            const text2 = event.clipboardData.getData("text/plain");
            const vscode = event.clipboardData.getData("vscode-editor-data");
            const vscodeData = vscode ? JSON.parse(vscode) : void 0;
            const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
            if (!text2 || !language) {
              return false;
            }
            const { tr: tr2 } = view.state;
            tr2.replaceSelectionWith(this.type.create({ language }));
            tr2.setSelection(TextSelection.near(tr2.doc.resolve(Math.max(0, tr2.selection.from - 2))));
            tr2.insertText(text2.replace(/\r\n?/g, "\n"));
            tr2.setMeta("paste", true);
            view.dispatch(tr2);
            return true;
          }
        }
      })
    ];
  }
});

// node_modules/@tiptap/extension-document/dist/index.js
var Document = Node2.create({
  name: "doc",
  topNode: true,
  content: "block+"
});

// node_modules/prosemirror-dropcursor/dist/index.js
function dropCursor(options = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}
var DropCursorView = class {
  constructor(editorView, options) {
    var _a;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
    this.color = options.color === false ? void 0 : options.color || "black";
    this.class = options.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    if (isBlock) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top2 = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top2 = (top2 + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top2 - this.width / 2, bottom: top2 + this.width / 2 };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      parentLeft = rect2.left - parent.scrollLeft;
      parentTop = rect2.top - parent.scrollTop;
    }
    this.element.style.left = rect.left - parentLeft + "px";
    this.element.style.top = rect.top - parentTop + "px";
    this.element.style.width = rect.right - rect.left + "px";
    this.element.style.height = rect.bottom - rect.top + "px";
  }
  scheduleRemoval(timeout) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
};

// node_modules/@tiptap/extension-dropcursor/dist/index.js
var Dropcursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      dropCursor(this.options)
    ];
  }
});

// node_modules/prosemirror-gapcursor/dist/index.js
var GapCursor = class _GapCursor extends Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc3, mapping) {
    let $pos = doc3.resolve(mapping.map(this.head));
    return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof _GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new _GapCursor(doc3.resolve(json.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search:
      for (; ; ) {
        if (!mustMove && _GapCursor.valid($pos))
          return $pos;
        let pos = $pos.pos, next = null;
        for (let d = $pos.depth; ; d--) {
          let parent = $pos.node(d);
          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
            break;
          } else if (d == 0) {
            return null;
          }
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        for (; ; ) {
          let inside = dir > 0 ? next.firstChild : next.lastChild;
          if (!inside) {
            if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
              mustMove = false;
              continue search;
            }
            break;
          }
          next = inside;
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        return null;
      }
  }
};
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
var GapBookmark = class _GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new _GapBookmark(mapping.map(this.pos));
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
};
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.index(d), parent = $pos.node(d);
    if (index == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.indexAfter(d), parent = $pos.node(d);
    if (index == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
var handleKeyDown = keydownHandler({
  "ArrowLeft": arrow2("horiz", -1),
  "ArrowRight": arrow2("horiz", 1),
  "ArrowUp": arrow2("vert", -1),
  "ArrowDown": arrow2("vert", 1)
});
function arrow2(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert2 = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert2)
    return false;
  let frag = Fragment.empty;
  for (let i = insert2.length - 1; i >= 0; i--)
    frag = Fragment.from(insert2[i].createAndFill(null, frag));
  let tr2 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr2.setSelection(TextSelection.near(tr2.doc.resolve($from.pos + 1)));
  view.dispatch(tr2);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}

// node_modules/@tiptap/extension-gapcursor/dist/index.js
var Gapcursor = Extension.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      gapCursor()
    ];
  },
  extendNodeSchema(extension) {
    var _a;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      allowGapCursor: (_a = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a !== void 0 ? _a : null
    };
  }
});

// node_modules/@tiptap/extension-hard-break/dist/index.js
var HardBreak = Node2.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return "\n";
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: commands2, chain, state, editor }) => {
        return commands2.first([
          () => commands2.exitCode(),
          () => commands2.command(() => {
            const { selection, storedMarks } = state;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain().insertContent({ type: this.name }).command(({ tr: tr2, dispatch }) => {
              if (dispatch && marks && keepMarks) {
                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                tr2.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});

// node_modules/@tiptap/extension-heading/dist/index.js
var Heading = Node2.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((items, level) => ({
      ...items,
      ...{
        [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
      }
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{1,${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});

// node_modules/rope-sequence/dist/index.js
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append2(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3)
    Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    for (var i = from2; i < to; i++) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    for (var i = from2 - 1; i >= to; i--) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(RopeSequence3) {
  function Append2(left2, right2) {
    RopeSequence3.call(this);
    this.left = left2;
    this.right = right2;
    this.length = left2.length + right2.length;
    this.depth = Math.max(left2.depth, right2.depth) + 1;
  }
  if (RopeSequence3)
    Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start2) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start2 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start2 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start2) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var dist_default2 = RopeSequence;

// node_modules/prosemirror-history/dist/index.js
var max_empty_items = 500;
var Branch = class _Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end2 = this.items.length;
    for (; ; end2--) {
      let next = this.items.get(end2 - 1);
      if (next.selection) {
        --end2;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end2, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end2, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map2;
        if (step && transform.maybeStep(step).doc) {
          map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new _Branch(this.items.slice(0, end2).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform.steps.length; i++) {
      let step = transform.steps[i].invert(transform.docs[i]);
      let item = new Item(transform.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new _Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new _Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start2 = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start2);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map2 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map2, step, selection));
      } else {
        rebasedItems.push(new Item(map2));
      }
    }, start2);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item(mapping.maps[i]));
    let items = this.items.slice(0, start2).append(newMaps).append(rebasedItems);
    let branch = new _Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count++;
    });
    return count;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;
          if (merged = items.length && items[last].merge(newItem))
            items[last] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new _Branch(dist_default2.from(items.reverse()), events);
  }
};
Branch.empty = new Branch(dist_default2.empty, 0);
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i) => {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item = class _Item {
  constructor(map2, step, selection, mirrorOffset) {
    this.map = map2;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new _Item(step.getMap().invert(), step, this.selection);
    }
  }
};
var HistoryState = class {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
};
var DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr2, options) {
  let historyTr = tr2.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr2.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr2.getMeta("appendedTransaction");
  if (tr2.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr2, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr2.mapping.maps[tr2.steps.length - 1]), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr2, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr2.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr2.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr2.time || 0) - options.newGroupDelay || !isAdjacentTo(tr2, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr2.mapping) : rangesFor(tr2.mapping.maps[tr2.steps.length - 1]);
    return new HistoryState(history2.done.addTransform(tr2, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr2.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr2.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr2, rebased), history2.undone.rebased(tr2, rebased), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr2.mapping.maps), history2.undone.addMaps(tr2.mapping.maps), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start2, end2) => {
    for (let i = 0; i < prevRanges.length; i += 2)
      if (start2 <= prevRanges[i + 1] && end2 >= prevRanges[i])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(map2) {
  let result = [];
  map2.forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i = 0; i < ranges.length; i += 2) {
    let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state, dispatch, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
}
var cachedPreserveItems = false;
var cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i = 0; i < plugins.length; i++)
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr2, hist, state) {
        return applyTransaction(hist, state, tr2, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
var undo = (state, dispatch) => {
  let hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0)
    return false;
  if (dispatch)
    histTransaction(hist, state, dispatch, false);
  return true;
};
var redo = (state, dispatch) => {
  let hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0)
    return false;
  if (dispatch)
    histTransaction(hist, state, dispatch, true);
  return true;
};

// node_modules/@tiptap/extension-history/dist/index.js
var History = Extension.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch }) => {
        return undo(state, dispatch);
      },
      redo: () => ({ state, dispatch }) => {
        return redo(state, dispatch);
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      history(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-Z": () => this.editor.commands.undo(),
      "Mod-y": () => this.editor.commands.redo(),
      "Mod-Y": () => this.editor.commands.redo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Shift-Mod-Z": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-\u044F": () => this.editor.commands.undo(),
      "Shift-Mod-\u044F": () => this.editor.commands.redo()
    };
  }
});

// node_modules/@tiptap/extension-horizontal-rule/dist/index.js
var HorizontalRule = Node2.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain, state }) => {
        const { $to: $originTo } = state.selection;
        const currentChain = chain();
        if ($originTo.parentOffset === 0) {
          currentChain.insertContentAt(Math.max($originTo.pos - 2, 0), { type: this.name });
        } else {
          currentChain.insertContent({ type: this.name });
        }
        return currentChain.command(({ tr: tr2, dispatch }) => {
          var _a;
          if (dispatch) {
            const { $to } = tr2.selection;
            const posAfter = $to.end();
            if ($to.nodeAfter) {
              if ($to.nodeAfter.isTextblock) {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos + 1));
              } else if ($to.nodeAfter.isBlock) {
                tr2.setSelection(NodeSelection.create(tr2.doc, $to.pos));
              } else {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos));
              }
            } else {
              const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
              if (node) {
                tr2.insert(posAfter, node);
                tr2.setSelection(TextSelection.create(tr2.doc, posAfter + 1));
              }
            }
            tr2.scrollIntoView();
          }
          return true;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-italic/dist/index.js
var starInputRegex2 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/;
var starPasteRegex2 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g;
var underscoreInputRegex2 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/;
var underscorePasteRegex2 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;
var Italic = Mark2.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node) => node.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleItalic: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex2,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex2,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex2,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-list-item/dist/index.js
var ListItem2 = Node2.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});

// node_modules/@tiptap/extension-ordered-list/dist/index.js
var ListItem3 = Node2.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
var TextStyle2 = Mark2.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (element2) => {
          const hasStyles = element2.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
        const attributes = getMarkAttributes(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) {
          return true;
        }
        return commands2.unsetMark(this.name);
      }
    };
  }
});
var inputRegex5 = /^(\d+)\.\s$/;
var OrderedList = Node2.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element2) => {
          return element2.hasAttribute("start") ? parseInt(element2.getAttribute("start") || "", 10) : 1;
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const { start: start2, ...attributesWithoutStart } = HTMLAttributes;
    return start2 === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: commands2, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem3.name, this.editor.getAttributes(TextStyle2.name)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex5,
      type: this.type,
      getAttributes: (match) => ({ start: +match[1] }),
      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex5,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyle2.name) }),
        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});

// node_modules/@tiptap/extension-paragraph/dist/index.js
var Paragraph = Node2.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: commands2 }) => {
        return commands2.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});

// node_modules/@tiptap/extension-strike/dist/index.js
var inputRegex6 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/;
var pasteRegex2 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;
var Strike = Mark2.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleStrike: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    const shortcuts = {};
    if (isMacOS()) {
      shortcuts["Mod-Shift-s"] = () => this.editor.commands.toggleStrike();
    } else {
      shortcuts["Ctrl-Shift-s"] = () => this.editor.commands.toggleStrike();
    }
    return shortcuts;
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex2,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-text/dist/index.js
var Text2 = Node2.create({
  name: "text",
  group: "inline"
});

// node_modules/@tiptap/starter-kit/dist/index.js
var StarterKit = Extension.create({
  name: "starterKit",
  addExtensions() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const extensions2 = [];
    if (this.options.blockquote !== false) {
      extensions2.push(Blockquote.configure((_a = this.options) === null || _a === void 0 ? void 0 : _a.blockquote));
    }
    if (this.options.bold !== false) {
      extensions2.push(Bold.configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.bold));
    }
    if (this.options.bulletList !== false) {
      extensions2.push(BulletList.configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));
    }
    if (this.options.code !== false) {
      extensions2.push(Code.configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));
    }
    if (this.options.codeBlock !== false) {
      extensions2.push(CodeBlock.configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));
    }
    if (this.options.document !== false) {
      extensions2.push(Document.configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));
    }
    if (this.options.dropcursor !== false) {
      extensions2.push(Dropcursor.configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));
    }
    if (this.options.gapcursor !== false) {
      extensions2.push(Gapcursor.configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));
    }
    if (this.options.hardBreak !== false) {
      extensions2.push(HardBreak.configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));
    }
    if (this.options.heading !== false) {
      extensions2.push(Heading.configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));
    }
    if (this.options.history !== false) {
      extensions2.push(History.configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));
    }
    if (this.options.horizontalRule !== false) {
      extensions2.push(HorizontalRule.configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));
    }
    if (this.options.italic !== false) {
      extensions2.push(Italic.configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));
    }
    if (this.options.listItem !== false) {
      extensions2.push(ListItem2.configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));
    }
    if (this.options.orderedList !== false) {
      extensions2.push(OrderedList.configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));
    }
    if (this.options.paragraph !== false) {
      extensions2.push(Paragraph.configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));
    }
    if (this.options.strike !== false) {
      extensions2.push(Strike.configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));
    }
    if (this.options.text !== false) {
      extensions2.push(Text2.configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));
    }
    return extensions2;
  }
});

// resources/js/components/ScribbleBlock.svelte
function create_default_slot2(ctx) {
  let div3;
  let div0;
  let div0_class_value;
  let t0;
  let div2;
  let div1;
  let t1;
  let button0;
  let t2;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      div1.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="size-4"><path d="m22.67 12l-4.49 4.5l-2.51-2.5l1.98-2l-1.98-1.96l2.51-2.51zM12 1.33l4.47 4.49l-2.51 2.51L12 6.35l-2 1.98l-2.5-2.51zm0 21.34l-4.47-4.49l2.51-2.51L12 17.65l2-1.98l2.5 2.51zM1.33 12l4.49-4.5L8.33 10l-1.98 2l1.98 1.96l-2.51 2.51zM12 10a2 2 0 0 1 2 2a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2"></path></svg>`;
      t1 = space();
      button0 = element("button");
      button0.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="size-4"><path fill-rule="evenodd" d="M15 4.5A3.5 3.5 0 0 1 11.435 8c-.99-.019-2.093.132-2.7.913l-4.13 5.31a2.015 2.015 0 1 1-2.827-2.828l5.309-4.13c.78-.607.932-1.71.914-2.7L8 4.5a3.5 3.5 0 0 1 4.477-3.362c.325.094.39.497.15.736L10.6 3.902a.48.48 0 0 0-.033.653c.271.314.565.608.879.879a.48.48 0 0 0 .653-.033l2.027-2.027c.239-.24.642-.175.736.15.09.31.138.637.138.976ZM3.75 13a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0Z" clip-rule="evenodd"></path><path d="M11.5 9.5c.313 0 .62-.029.917-.084l1.962 1.962a2.121 2.121 0 0 1-3 3l-2.81-2.81 1.35-1.734c.05-.064.158-.158.426-.233.278-.078.639-.11 1.062-.102l.093.001ZM5 4l1.446 1.445a2.256 2.256 0 0 1-.047.21c-.075.268-.169.377-.233.427l-.61.474L4 5H2.655a.25.25 0 0 1-.224-.139l-1.35-2.7a.25.25 0 0 1 .047-.289l.745-.745a.25.25 0 0 1 .289-.047l2.7 1.35A.25.25 0 0 1 5 2.654V4Z"></path></svg>`;
      t2 = space();
      button1 = element("button");
      button1.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="size-4"><path fill-rule="evenodd" d="M5 3.25V4H2.75a.75.75 0 0 0 0 1.5h.3l.815 8.15A1.5 1.5 0 0 0 5.357 15h5.285a1.5 1.5 0 0 0 1.493-1.35l.815-8.15h.3a.75.75 0 0 0 0-1.5H11v-.75A2.25 2.25 0 0 0 8.75 1h-1.5A2.25 2.25 0 0 0 5 3.25Zm2.25-.75a.75.75 0 0 0-.75.75V4h3v-.75a.75.75 0 0 0-.75-.75h-1.5ZM6.05 6a.75.75 0 0 1 .787.713l.275 5.5a.75.75 0 0 1-1.498.075l-.275-5.5A.75.75 0 0 1 6.05 6Zm3.9 0a.75.75 0 0 1 .712.787l-.275 5.5a.75.75 0 0 1-1.498-.075l.275-5.5a.75.75 0 0 1 .786-.711Z" clip-rule="evenodd"></path></svg>`;
      attr(div0, "class", div0_class_value = "transition cursor-pointer rounded-md overflow-hidden z-10 relative " + /*selected*/
      (ctx[0] ? "ProseMirror-selectednode" : ""));
      attr(div1, "data-drag-handle", "");
      attr(div1, "class", "cursor-grabbing text-white block rounded p-1 hover:text-primary-500 hover:bg-gray-800");
      attr(button0, "type", "button");
      attr(button0, "class", "text-white block rounded p-1 hover:text-primary-500 hover:bg-gray-800");
      attr(button1, "type", "button");
      attr(button1, "class", "text-white block rounded p-1 hover:text-primary-500 hover:bg-gray-800");
      attr(div2, "class", "scribble-block-actions transition opacity-0 absolute z-20 top-0 right-0 p-1 rounded-tr-md rounded-bl-lg flex items-center bg-gray-950 group-hover:opacity-100");
      attr(div3, "class", "relative group bg-gray-900/5 dark:bg-white/5 rounded-md");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      div0.innerHTML = /*view*/
      ctx[1];
      ctx[8](div0);
      append(div3, t0);
      append(div3, div2);
      append(div2, div1);
      append(div2, t1);
      append(div2, button0);
      append(div2, t2);
      append(div2, button1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", stop_propagation(prevent_default(
            /*open*/
            ctx[3]
          ))),
          listen(button1, "click", stop_propagation(prevent_default(
            /*removeBlock*/
            ctx[4]
          )))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*view*/
      2)
        div0.innerHTML = /*view*/
        ctx2[1];
      ;
      if (dirty & /*selected*/
      1 && div0_class_value !== (div0_class_value = "transition cursor-pointer rounded-md overflow-hidden z-10 relative " + /*selected*/
      (ctx2[0] ? "ProseMirror-selectednode" : ""))) {
        attr(div0, "class", div0_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      ctx[8](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment4(ctx) {
  let nodeviewwrapper;
  let current;
  nodeviewwrapper = new NodeViewWrapper_default({
    props: {
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(nodeviewwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nodeviewwrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const nodeviewwrapper_changes = {};
      if (dirty & /*$$scope, selected, wrapper, view*/
      2055) {
        nodeviewwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      nodeviewwrapper.$set(nodeviewwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nodeviewwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodeviewwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nodeviewwrapper, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let $getStatePath;
  component_subscribe($$self, getStatePath, ($$value) => $$invalidate(9, $getStatePath = $$value));
  let { editor } = $$props;
  let { node } = $$props;
  let { selected = false } = $$props;
  let { updateAttributes: updateAttributes2 } = $$props;
  let view = null;
  let wrapper;
  const open = () => {
    pounce(node.attrs.type, {
      update: true,
      statePath: $getStatePath,
      ...node.attrs.values
    });
  };
  const removeBlock = () => {
    editor.commands.deleteSelection();
  };
  const getView = () => {
    const component = document.querySelector("#scribble-renderer").getAttribute("wire:id");
    window.Livewire.find(component).call("getView", node.attrs.type, node.attrs.values).then((e) => $$invalidate(1, view = e)).then(() => {
      wrapper.querySelectorAll("input")?.forEach((input) => {
        input.addEventListener("change", (e) => {
          let name = e.target.getAttribute("id");
          let value = e.target.value;
          updateAttributes2({
            values: { ...node.attrs.values, [name]: value }
          });
        });
      });
    });
  };
  onMount(() => {
    getView();
    window.addEventListener("updatedBlock", (e) => {
      if (e.detail.type === node.attrs.type && e.detail.statePath === $getStatePath) {
        updateAttributes2({ values: e.detail.values });
        getView();
      }
    });
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapper = $$value;
      $$invalidate(2, wrapper);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(5, editor = $$props2.editor);
    if ("node" in $$props2)
      $$invalidate(6, node = $$props2.node);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("updateAttributes" in $$props2)
      $$invalidate(7, updateAttributes2 = $$props2.updateAttributes);
  };
  return [
    selected,
    view,
    wrapper,
    open,
    removeBlock,
    editor,
    node,
    updateAttributes2,
    div0_binding
  ];
}
var ScribbleBlock = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      editor: 5,
      node: 6,
      selected: 0,
      updateAttributes: 7
    });
  }
};
var ScribbleBlock_default = ScribbleBlock;

// resources/js/utils/uuid.js
var uuid = () => {
  return ("10000000-1000-4000-8000" + -1e11).replace(
    /[018]/g,
    (c) => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  );
};

// resources/js/extensions/ScribbleBlock.js
var ScribbleBlock_default2 = Node2.create({
  name: "scribbleBlock",
  isBlock: true,
  inline: false,
  group: "block",
  draggable: true,
  defining: true,
  selectable: true,
  addAttributes() {
    return {
      id: {
        default: null
      },
      type: {
        default: null
      },
      values: {
        default: {}
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "scribble-block",
        getAttrs: (dom) => {
          return JSON.parse(dom.innerHTML);
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["scribble-block", JSON.stringify(HTMLAttributes)];
  },
  addCommands() {
    return {
      setScribbleBlock: (options) => ({ tr: tr2, state }) => {
        const { selection } = tr2;
        const node = state.schema.nodes["paragraph"].create();
        tr2.replaceRangeWith(selection.from - selection.$anchor.parentOffset, selection.to, node);
        pounce(options.type, { statePath: options.statePath });
        return true;
      },
      insertScribbleBlock: (options) => {
        return ({ tr: tr2, dispatch, state }) => {
          const { selection } = tr2;
          const node = this.type.create({
            ...{ id: uuid() },
            ...options
          });
          if (dispatch) {
            tr2.replaceRangeWith(selection.from - selection.$anchor.parentOffset, selection.to, node);
          }
          return true;
        };
      }
    };
  },
  addNodeView() {
    return SvelteNodeViewRenderer_default(ScribbleBlock_default);
  }
});

// node_modules/@tiptap/suggestion/dist/index.js
function findSuggestionMatch(config) {
  var _a;
  const { char, allowSpaces, allowedPrefixes, startOfLine, $position } = config;
  const escapedChar = escapeForRegEx(char);
  const suffix = new RegExp(`\\s${escapedChar}$`);
  const prefix = startOfLine ? "^" : "";
  const regexp = allowSpaces ? new RegExp(`${prefix}${escapedChar}.*?(?=\\s${escapedChar}|$)`, "gm") : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\s${escapedChar}]*`, "gm");
  const text2 = ((_a = $position.nodeBefore) === null || _a === void 0 ? void 0 : _a.isText) && $position.nodeBefore.text;
  if (!text2) {
    return null;
  }
  const textFrom = $position.pos - text2.length;
  const match = Array.from(text2.matchAll(regexp)).pop();
  if (!match || match.input === void 0 || match.index === void 0) {
    return null;
  }
  const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);
  const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join("")}\0]?$`).test(matchPrefix);
  if (allowedPrefixes !== null && !matchPrefixIsAllowed) {
    return null;
  }
  const from2 = textFrom + match.index;
  let to = from2 + match[0].length;
  if (allowSpaces && suffix.test(text2.slice(to - 1, to + 1))) {
    match[0] += " ";
    to += 1;
  }
  if (from2 < $position.pos && to >= $position.pos) {
    return {
      range: {
        from: from2,
        to
      },
      query: match[0].slice(char.length),
      text: match[0]
    };
  }
  return null;
}
var SuggestionPluginKey = new PluginKey("suggestion");
function Suggestion({ pluginKey = SuggestionPluginKey, editor, char = "@", allowSpaces = false, allowedPrefixes = [" "], startOfLine = false, decorationTag = "span", decorationClass = "suggestion", command: command2 = () => null, items = () => [], render: render2 = () => ({}), allow = () => true }) {
  let props;
  const renderer = render2 === null || render2 === void 0 ? void 0 : render2();
  const plugin = new Plugin({
    key: pluginKey,
    view() {
      return {
        update: async (view, prevState) => {
          var _a, _b, _c, _d, _e, _f, _g;
          const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);
          const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);
          const moved = prev.active && next.active && prev.range.from !== next.range.from;
          const started = !prev.active && next.active;
          const stopped = prev.active && !next.active;
          const changed = !started && !stopped && prev.query !== next.query;
          const handleStart = started || moved;
          const handleChange = changed && !moved;
          const handleExit = stopped || moved;
          if (!handleStart && !handleChange && !handleExit) {
            return;
          }
          const state = handleExit && !handleStart ? prev : next;
          const decorationNode = view.dom.querySelector(`[data-decoration-id="${state.decorationId}"]`);
          props = {
            editor,
            range: state.range,
            query: state.query,
            text: state.text,
            items: [],
            command: (commandProps) => {
              command2({
                editor,
                range: state.range,
                props: commandProps
              });
            },
            decorationNode,
            // virtual node for popper.js or tippy.js
            // this can be used for building popups without a DOM node
            clientRect: decorationNode ? () => {
              var _a2;
              const { decorationId } = (_a2 = this.key) === null || _a2 === void 0 ? void 0 : _a2.getState(editor.state);
              const currentDecorationNode = view.dom.querySelector(`[data-decoration-id="${decorationId}"]`);
              return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;
            } : null
          };
          if (handleStart) {
            (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);
          }
          if (handleChange) {
            (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);
          }
          if (handleChange || handleStart) {
            props.items = await items({
              editor,
              query: state.query
            });
          }
          if (handleExit) {
            (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e === void 0 ? void 0 : _e.call(renderer, props);
          }
          if (handleChange) {
            (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);
          }
          if (handleStart) {
            (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);
          }
        },
        destroy: () => {
          var _a;
          if (!props) {
            return;
          }
          (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        const state = {
          active: false,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: false
        };
        return state;
      },
      // Apply changes to the plugin state from a view transaction.
      apply(transaction, prev, oldState, state) {
        const { isEditable } = editor;
        const { composing } = editor.view;
        const { selection } = transaction;
        const { empty: empty3, from: from2 } = selection;
        const next = { ...prev };
        next.composing = composing;
        if (isEditable && (empty3 || editor.view.composing)) {
          if ((from2 < prev.range.from || from2 > prev.range.to) && !composing && !prev.composing) {
            next.active = false;
          }
          const match = findSuggestionMatch({
            char,
            allowSpaces,
            allowedPrefixes,
            startOfLine,
            $position: selection.$from
          });
          const decorationId = `id_${Math.floor(Math.random() * 4294967295)}`;
          if (match && allow({ editor, state, range: match.range })) {
            next.active = true;
            next.decorationId = prev.decorationId ? prev.decorationId : decorationId;
            next.range = match.range;
            next.query = match.query;
            next.text = match.text;
          } else {
            next.active = false;
          }
        } else {
          next.active = false;
        }
        if (!next.active) {
          next.decorationId = null;
          next.range = { from: 0, to: 0 };
          next.query = null;
          next.text = null;
        }
        return next;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(view, event) {
        var _a;
        const { active, range } = plugin.getState(view.state);
        if (!active) {
          return false;
        }
        return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, { view, event, range })) || false;
      },
      // Setup decorator on the currently active suggestion.
      decorations(state) {
        const { active, range, decorationId } = plugin.getState(state);
        if (!active) {
          return null;
        }
        return DecorationSet.create(state.doc, [
          Decoration.inline(range.from, range.to, {
            nodeName: decorationTag,
            class: decorationClass,
            "data-decoration-id": decorationId
          })
        ]);
      }
    }
  });
  return plugin;
}

// resources/js/components/CommandsList.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_if_block_1(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(Object.keys(
    /*groups*/
    ctx[3]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups, Object, selectedIndex, selectItem*/
      26) {
        each_value = ensure_array_like(Object.keys(
          /*groups*/
          ctx2[3]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let div2;
  let t_value = (
    /*group*/
    ctx[16] + ""
  );
  let t;
  return {
    c() {
      div2 = element("div");
      t = text(t_value);
      attr(div2, "class", "text-xs my-1 px-2 font-bold");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups*/
      8 && t_value !== (t_value = /*group*/
      ctx2[16] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_if_block_2(ctx) {
  let span;
  let t_value = (
    /*item*/
    ctx[19].description + ""
  );
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "block text-xs text-gray-300");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups*/
      8 && t_value !== (t_value = /*item*/
      ctx2[19].description + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block_1(ctx) {
  let button;
  let span0;
  let raw_value = (
    /*item*/
    ctx[19].icon + ""
  );
  let t0;
  let span2;
  let span1;
  let t1_value = (
    /*item*/
    ctx[19].label + ""
  );
  let t1;
  let t2;
  let t3;
  let button_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*item*/
    ctx[19].description && create_if_block_2(ctx)
  );
  function click_handler() {
    return (
      /*click_handler*/
      ctx[9](
        /*item*/
        ctx[19]
      )
    );
  }
  return {
    c() {
      button = element("button");
      span0 = element("span");
      t0 = space();
      span2 = element("span");
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      attr(span0, "class", "shrink-0 rounded-md flex items-center justify-center text-gray-200");
      attr(span1, "class", "block");
      attr(span2, "class", "flex-1 text-left");
      attr(button, "class", button_class_value = "p-2 w-full flex gap-2 items-center cursor-pointer select-none " + /*item*/
      (ctx[19].index === /*selectedIndex*/
      ctx[1] ? "bg-gray-800 active-option" : "hover:bg-gray-800"));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span0);
      span0.innerHTML = raw_value;
      append(button, t0);
      append(button, span2);
      append(span2, span1);
      append(span1, t1);
      append(span2, t2);
      if (if_block)
        if_block.m(span2, null);
      append(button, t3);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*groups*/
      8 && raw_value !== (raw_value = /*item*/
      ctx[19].icon + ""))
        span0.innerHTML = raw_value;
      ;
      if (dirty & /*groups*/
      8 && t1_value !== (t1_value = /*item*/
      ctx[19].label + ""))
        set_data(t1, t1_value);
      if (
        /*item*/
        ctx[19].description
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_2(ctx);
          if_block.c();
          if_block.m(span2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*groups, selectedIndex*/
      10 && button_class_value !== (button_class_value = "p-2 w-full flex gap-2 items-center cursor-pointer select-none " + /*item*/
      (ctx[19].index === /*selectedIndex*/
      ctx[1] ? "bg-gray-800 active-option" : "hover:bg-gray-800"))) {
        attr(button, "class", button_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_each_block(ctx) {
  let t;
  let each_1_anchor;
  let if_block = (
    /*group*/
    ctx[16] && create_if_block_3(ctx)
  );
  let each_value_1 = ensure_array_like(
    /*groups*/
    ctx[3][
      /*group*/
      ctx[16]
    ]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*group*/
        ctx2[16]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*groups, Object, selectedIndex, selectItem*/
      26) {
        each_value_1 = ensure_array_like(
          /*groups*/
          ctx2[3][
            /*group*/
            ctx2[16]
          ]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(each_1_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block(ctx) {
  let div2;
  return {
    c() {
      div2 = element("div");
      div2.textContent = "No blocks found";
      attr(div2, "class", "p-2 text-gray-200");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_fragment5(ctx) {
  let div1;
  let div0;
  let t;
  let if_block0 = (
    /*items*/
    ctx[0].length && create_if_block_1(ctx)
  );
  let if_block1 = !/*items*/
  ctx[0].length && create_if_block(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(div1, "class", "w-56 max-h-56 overflow-y-auto scrollbar-hide text-xs rounded-lg shadow-lg ring-1 ring-gray-950/5 transition dark:ring-white/10");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t);
      if (if_block1)
        if_block1.m(div0, null);
      ctx[10](div1);
    },
    p(ctx2, [dirty]) {
      if (
        /*items*/
        ctx2[0].length
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(div0, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*items*/
      ctx2[0].length) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[10](null);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { items } = $$props;
  let { editor } = $$props;
  let { range } = $$props;
  let selectedIndex = 0;
  let dropdown;
  let groups;
  const getGroups = (array) => {
    let map2 = array.map((e, i) => {
      e.index = i;
      return e;
    });
    $$invalidate(3, groups = map2.reduce(
      function(r2, a) {
        r2[a.group] = r2[a.group] || [];
        r2[a.group].push(a);
        return r2;
      },
      /* @__PURE__ */ Object.create(null)
    ));
  };
  const resetIndex = () => $$invalidate(1, selectedIndex = 0);
  const onKeyDown = ({ event }) => {
    if (event.key === "ArrowUp") {
      upHandler();
      return true;
    }
    if (event.key === "ArrowDown") {
      downHandler();
      return true;
    }
    if (event.key === "Enter") {
      enterHandler();
      return true;
    }
    return false;
  };
  const upHandler = () => {
    $$invalidate(1, selectedIndex = (selectedIndex + items.length - 1) % items.length);
    scrollToSelect();
  };
  const downHandler = () => {
    $$invalidate(1, selectedIndex = (selectedIndex + 1) % items.length);
    scrollToSelect();
  };
  const enterHandler = () => {
    selectItem(selectedIndex);
  };
  const selectItem = (index) => {
    const item = items[index];
    if (item) {
      console.log(item);
      if (item.type === "block" && item.prerender) {
        editor.chain().insertScribbleBlock({
          type: item.identifier,
          statePath: item.statePath,
          values: {}
        }).focus().run();
      } else {
        switch (item.type) {
          case "command":
            editor.chain().focus().deleteRange(range)[item.command](item.commandArguments).run();
            break;
          case "modal":
            editor.commands.deleteRange(range);
            pounce(item.identifier, {
              statePath: item.statePath,
              ...editor.getAttributes(item.extension)
            });
            break;
          default:
            editor.commands.setScribbleBlock({
              type: item.identifier,
              statePath: item.statePath
            });
        }
      }
    }
  };
  const scrollToSelect = () => {
    setTimeout(
      () => {
        dropdown.querySelector(".active-option").scrollIntoView({
          behavior: "smooth",
          block: "nearest",
          inline: "end"
        });
      },
      0
    );
  };
  const click_handler = (item) => selectItem(item.index);
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dropdown = $$value;
      $$invalidate(2, dropdown);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("editor" in $$props2)
      $$invalidate(5, editor = $$props2.editor);
    if ("range" in $$props2)
      $$invalidate(6, range = $$props2.range);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*items*/
    1) {
      $:
        getGroups(items);
    }
  };
  return [
    items,
    selectedIndex,
    dropdown,
    groups,
    selectItem,
    editor,
    range,
    resetIndex,
    onKeyDown,
    click_handler,
    div1_binding
  ];
}
var CommandsList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      items: 0,
      editor: 5,
      range: 6,
      resetIndex: 7,
      onKeyDown: 8
    });
  }
  get resetIndex() {
    return this.$$.ctx[7];
  }
  get onKeyDown() {
    return this.$$.ctx[8];
  }
};
var CommandsList_default = CommandsList;

// resources/js/extensions/SlashExtension.js
var SlashExtension_default = Extension.create({
  name: "slashExtension",
  addOptions() {
    return {
      blocks: {
        default: []
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      Suggestion({
        editor: this.editor,
        char: "/",
        command: ({ editor, range, props }) => {
          props.command({ editor, range });
        },
        startOfLine: true,
        pluginKey: new PluginKey("slashExtension"),
        items: ({ query }) => {
          return this.options.tools.filter((item) => item.label.toLowerCase().includes(query.toLowerCase()));
        },
        render: () => {
          let component;
          let popup;
          return {
            onStart: (props) => {
              if (!props.clientRect) {
                return;
              }
              const element2 = document.createElement("div");
              component = new CommandsList_default({
                target: element2,
                props: {
                  items: props.items,
                  editor: props.editor,
                  range: props.range
                }
              });
              popup = tippy_esm_default("body", {
                getReferenceClientRect: props.clientRect,
                appendTo: () => document.body,
                content: component.$$.root,
                showOnCreate: true,
                interactive: true,
                trigger: "manual",
                placement: "bottom-start",
                theme: "scribble-panel",
                arrow: false,
                zIndex: 40
              });
            },
            onUpdate(props) {
              component.$set({
                items: props.items,
                editor: props.editor,
                range: props.range
              });
              component.resetIndex();
              if (!props.clientRect) {
                return;
              }
              popup[0].setProps({
                getReferenceClientRect: props.clientRect
              });
            },
            onKeyDown(props) {
              if (props.event.key === "Escape") {
                popup[0].hide();
                return true;
              }
              return component.onKeyDown(props);
            },
            onExit() {
              popup[0].destroy();
              component.$destroy();
            }
          };
        }
      })
    ];
  }
});

// node_modules/@tiptap/extension-subscript/dist/index.js
var Subscript = Mark2.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(value) {
          if (value !== "sub") {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["sub", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleSubscript: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetSubscript: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
});

// node_modules/@tiptap/extension-superscript/dist/index.js
var Superscript = Mark2.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(value) {
          if (value !== "super") {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["sup", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleSuperscript: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetSuperscript: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
});

// resources/js/extensions/TextAlignExtension.js
var TextAlign = Extension.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["start", "center", "end", "justify"],
      defaultAlignment: "start"
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (element2) => element2.style.textAlign || this.options.defaultAlignment,
            renderHTML: (attributes) => {
              if (attributes.textAlign === this.options.defaultAlignment) {
                return {};
              }
              return { style: `text-align: ${attributes.textAlign}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (alignment) => ({ commands: commands2 }) => {
        if (!this.options.alignments.includes(alignment)) {
          return false;
        }
        return this.options.types.every((type) => commands2.updateAttributes(type, { textAlign: alignment }));
      },
      unsetTextAlign: () => ({ commands: commands2 }) => {
        return this.options.types.every((type) => commands2.resetAttributes(type, "textAlign"));
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("start"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("end"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});

// node_modules/@tiptap/extension-text-style/dist/index.js
var TextStyle3 = Mark2.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (element2) => {
          const hasStyles = element2.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
        const attributes = getMarkAttributes(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) {
          return true;
        }
        return commands2.unsetMark(this.name);
      }
    };
  }
});

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e)
    n += e;
  else if ("object" == typeof e)
    if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++)
        e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else
      for (f in e)
        e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++)
    (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_default = clsx;

// resources/js/components/Button.svelte
function create_if_block2(ctx) {
  let button;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(button, "type", "button");
      attr(button, "class", button_class_value = clsx_default(`rounded-sm p-1 bg-transparent hover:text-primary-500 focus:outline-none focus:ring-1 focus:ring-primary-500 ${/*key*/
      ctx[1]}`, {
        "text-inherit": !/*editor*/
        ctx[0].isActive(
          /*key*/
          ctx[1]
        ),
        "text-primary-500": (
          /*editor*/
          ctx[0].isActive(
            /*key*/
            ctx[1]
          )
        )
      }));
      toggle_class(
        button,
        "active",
        /*editor*/
        ctx[0].isActive(
          /*key*/
          ctx[1]
        )
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*key, editor*/
      3 && button_class_value !== (button_class_value = clsx_default(`rounded-sm p-1 bg-transparent hover:text-primary-500 focus:outline-none focus:ring-1 focus:ring-primary-500 ${/*key*/
      ctx2[1]}`, {
        "text-inherit": !/*editor*/
        ctx2[0].isActive(
          /*key*/
          ctx2[1]
        ),
        "text-primary-500": (
          /*editor*/
          ctx2[0].isActive(
            /*key*/
            ctx2[1]
          )
        )
      }))) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*key, editor, editor, key*/
      3) {
        toggle_class(
          button,
          "active",
          /*editor*/
          ctx2[0].isActive(
            /*key*/
            ctx2[1]
          )
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment6(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*editor*/
    ctx[0] && create_if_block2(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*editor*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*editor*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { editor } = $$props;
  let { key } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(0, editor = $$props2.editor);
    if ("key" in $$props2)
      $$invalidate(1, key = $$props2.key);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [editor, key, $$scope, slots, click_handler];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, { editor: 0, key: 1 });
  }
};
var Button_default = Button;

// resources/js/components/HeroView.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_each_block2(ctx) {
  let option;
  let t_value = (
    /*color*/
    ctx[7].label + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*color*/
      ctx[7].key;
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_default_slot3(ctx) {
  let div3;
  let div0;
  let nodeviewcontent;
  let t0;
  let div2;
  let div1;
  let t1;
  let select;
  let option;
  let t3;
  let button;
  let div3_class_value;
  let current;
  let mounted;
  let dispose;
  nodeviewcontent = new NodeViewContent_default({});
  let each_value = ensure_array_like(
    /*colors*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      create_component(nodeviewcontent.$$.fragment);
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      div1.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="size-4"><path d="m22.67 12l-4.49 4.5l-2.51-2.5l1.98-2l-1.98-1.96l2.51-2.51zM12 1.33l4.47 4.49l-2.51 2.51L12 6.35l-2 1.98l-2.5-2.51zm0 21.34l-4.47-4.49l2.51-2.51L12 17.65l2-1.98l2.5 2.51zM1.33 12l4.49-4.5L8.33 10l-1.98 2l1.98 1.96l-2.51 2.51zM12 10a2 2 0 0 1 2 2a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2"></path></svg>`;
      t1 = space();
      select = element("select");
      option = element("option");
      option.textContent = "Color";
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      button = element("button");
      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="size-4"><path fill-rule="evenodd" d="M5 3.25V4H2.75a.75.75 0 0 0 0 1.5h.3l.815 8.15A1.5 1.5 0 0 0 5.357 15h5.285a1.5 1.5 0 0 0 1.493-1.35l.815-8.15h.3a.75.75 0 0 0 0-1.5H11v-.75A2.25 2.25 0 0 0 8.75 1h-1.5A2.25 2.25 0 0 0 5 3.25Zm2.25-.75a.75.75 0 0 0-.75.75V4h3v-.75a.75.75 0 0 0-.75-.75h-1.5ZM6.05 6a.75.75 0 0 1 .787.713l.275 5.5a.75.75 0 0 1-1.498.075l-.275-5.5A.75.75 0 0 1 6.05 6Zm3.9 0a.75.75 0 0 1 .712.787l-.275 5.5a.75.75 0 0 1-1.498-.075l.275-5.5a.75.75 0 0 1 .786-.711Z" clip-rule="evenodd"></path></svg>`;
      attr(div0, "class", "transition rounded-md relative");
      attr(div1, "data-drag-handle", "");
      attr(div1, "class", "cursor-grabbing text-white block rounded p-1 hover:text-primary-500 hover:bg-gray-800");
      option.__value = "null";
      set_input_value(option, option.__value);
      attr(select, "name", "backgroundColor");
      attr(select, "class", "");
      if (
        /*selectedColor*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[6].call(select)
        ));
      attr(button, "type", "button");
      attr(button, "class", "text-white block rounded p-1 hover:text-primary-500 hover:bg-gray-800");
      attr(div2, "class", "scribble-block-actions transition opacity-0 absolute z-20 top-0 right-0 p-1 rounded-tr-md rounded-bl-lg flex items-center bg-gray-950 group-hover:opacity-100");
      attr(div3, "class", div3_class_value = clsx_default(
        "relative group p-6",
        /*selectedColor*/
        ctx[0]
      ));
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      mount_component(nodeviewcontent, div0, null);
      append(div3, t0);
      append(div3, div2);
      append(div2, div1);
      append(div2, t1);
      append(div2, select);
      append(select, option);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*selectedColor*/
        ctx[0],
        true
      );
      append(div2, t3);
      append(div2, button);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[6]
          ),
          listen(
            select,
            "change",
            /*handleColorChange*/
            ctx[3]
          ),
          listen(button, "click", stop_propagation(prevent_default(
            /*removeBlock*/
            ctx[2]
          )))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*colors*/
      2) {
        each_value = ensure_array_like(
          /*colors*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*selectedColor, colors*/
      3) {
        select_option(
          select,
          /*selectedColor*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*selectedColor, colors*/
      3 && div3_class_value !== (div3_class_value = clsx_default(
        "relative group p-6",
        /*selectedColor*/
        ctx2[0]
      ))) {
        attr(div3, "class", div3_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(nodeviewcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodeviewcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(nodeviewcontent);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment7(ctx) {
  let nodeviewwrapper;
  let current;
  nodeviewwrapper = new NodeViewWrapper_default({
    props: {
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(nodeviewwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nodeviewwrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const nodeviewwrapper_changes = {};
      if (dirty & /*$$scope, selectedColor*/
      1025) {
        nodeviewwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      nodeviewwrapper.$set(nodeviewwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nodeviewwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodeviewwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nodeviewwrapper, detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { editor } = $$props;
  let { updateAttributes: updateAttributes2 } = $$props;
  let selectedColor = "gray";
  let colors = [
    { key: "primary", label: "Primary" },
    { key: "secondary", label: "Secondary" },
    { key: "tertiary", label: "Tertiary" },
    { key: "accent", label: "Accent" },
    { key: "grayLight", label: "Gray - Light" },
    { key: "gray", label: "Gray" },
    { key: "grayDark", label: "Gray - Dark" }
  ];
  const removeBlock = () => {
    editor.commands.deleteSelection();
  };
  const handleColorChange = () => {
    updateAttributes2({ color: selectedColor });
  };
  function select_change_handler() {
    selectedColor = select_value(this);
    $$invalidate(0, selectedColor);
    $$invalidate(1, colors);
  }
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(4, editor = $$props2.editor);
    if ("updateAttributes" in $$props2)
      $$invalidate(5, updateAttributes2 = $$props2.updateAttributes);
  };
  return [
    selectedColor,
    colors,
    removeBlock,
    handleColorChange,
    editor,
    updateAttributes2,
    select_change_handler
  ];
}
var HeroView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, { editor: 4, updateAttributes: 5 });
  }
};
var HeroView_default = HeroView;

// resources/js/extensions/HeroExtension.js
var HeroExtension = Node2.create({
  name: "hero",
  group: "block",
  content: "block+",
  addOptions() {
    return {
      colors: [
        "grayLight",
        "gray",
        "grayDark",
        "primary",
        "secondary",
        "tertiary",
        "accent"
      ],
      HTMLAttributes: {
        class: "hero-block"
      }
    };
  },
  addAttributes() {
    return {
      color: {
        default: "primary",
        parseHTML: (element2) => element2.getAttribute("data-color"),
        renderHTML: (attributes) => {
          if (!attributes.color) {
            return null;
          }
          return {
            "data-color": attributes.color
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "div",
        getAttrs: (element2) => element2.classList.contains("hero-block")
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "div",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      0
    ];
  },
  addCommands() {
    return {
      toggleHero: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleWrap(this.name, attributes);
      }
    };
  },
  addNodeView() {
    return SvelteNodeViewRenderer_default(HeroView_default);
  }
});

// resources/js/Scribble.svelte
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}
function create_if_block_32(ctx) {
  let div1;
  let div0;
  let button0;
  let t0;
  let button1;
  let t1;
  let button2;
  let t2;
  let button3;
  let t3;
  let button4;
  let current;
  button0 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[1]
      ),
      key: "undo",
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*click_handler*/
    ctx[11]
  );
  button1 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[1]
      ),
      key: "redo",
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*click_handler_1*/
    ctx[12]
  );
  button2 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[1]
      ),
      key: "clear",
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  button2.$on(
    "click",
    /*click_handler_2*/
    ctx[13]
  );
  button3 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[1]
      ),
      key: "enter-fullscreen",
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  button3.$on(
    "click",
    /*toggleFullscreen*/
    ctx[6]
  );
  button4 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[1]
      ),
      key: "exit-fullscreen",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  button4.$on(
    "click",
    /*toggleFullscreen*/
    ctx[6]
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(button2.$$.fragment);
      t2 = space();
      create_component(button3.$$.fragment);
      t3 = space();
      create_component(button4.$$.fragment);
      attr(div0, "class", "scribble-controls-panel inline-flex px-2 items-center rounded-full border border-gray-950/10 dark:border-white/20 shadow-md");
      attr(div1, "class", "scribble-controls");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(button0, div0, null);
      append(div0, t0);
      mount_component(button1, div0, null);
      append(div0, t1);
      mount_component(button2, div0, null);
      append(div0, t2);
      mount_component(button3, div0, null);
      append(div0, t3);
      mount_component(button4, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*editor*/
      2)
        button0_changes.editor = /*editor*/
        ctx2[1];
      if (dirty & /*$$scope*/
      33554432) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*editor*/
      2)
        button1_changes.editor = /*editor*/
        ctx2[1];
      if (dirty & /*$$scope*/
      33554432) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*editor*/
      2)
        button2_changes.editor = /*editor*/
        ctx2[1];
      if (dirty & /*$$scope*/
      33554432) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      const button3_changes = {};
      if (dirty & /*editor*/
      2)
        button3_changes.editor = /*editor*/
        ctx2[1];
      if (dirty & /*$$scope*/
      33554432) {
        button3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button3.$set(button3_changes);
      const button4_changes = {};
      if (dirty & /*editor*/
      2)
        button4_changes.editor = /*editor*/
        ctx2[1];
      if (dirty & /*$$scope*/
      33554432) {
        button4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button4.$set(button4_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      transition_in(button4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      transition_out(button4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button2);
      destroy_component(button3);
      destroy_component(button4);
    }
  };
}
function create_default_slot_7(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "none");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "32");
      attr(path, "d", "M240 424v-96c116.4 0 159.39 33.76 208 96c0-119.23-39.57-240-208-240V88L64 256Z");
      attr(svg, "class", "size-5");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "32");
      attr(svg, "height", "32");
      attr(svg, "viewBox", "0 0 512 512");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot_6(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "none");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "32");
      attr(path, "d", "M448 256L272 88v96C103.57 184 64 304.77 64 424c48.61-62.24 91.6-96 208-96v96Z");
      attr(svg, "class", "size-5");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "32");
      attr(svg, "height", "32");
      attr(svg, "viewBox", "0 0 512 512");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot_5(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M13.9999 18.9967H20.9999V20.9967H11.9999L8.00229 20.9992L1.51457 14.5115C1.12405 14.1209 1.12405 13.4878 1.51457 13.0972L12.1212 2.49065C12.5117 2.10012 13.1449 2.10012 13.5354 2.49065L21.3136 10.2688C21.7041 10.6593 21.7041 11.2925 21.3136 11.683L13.9999 18.9967ZM15.6567 14.5115L19.1922 10.9759L12.8283 4.61197L9.29275 8.1475L15.6567 14.5115Z");
      attr(svg, "class", "size-5");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot_4(ctx) {
  let svg;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "fill", "none");
      attr(path0, "d", "M0 0h24v24H0z");
      attr(path1, "d", "M20 3h2v6h-2V5h-4V3h4zM4 3h4v2H4v4H2V3h2zm16 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z");
      attr(svg, "class", "size-5");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot_3(ctx) {
  let svg;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "fill", "none");
      attr(path0, "d", "M0 0h24v24H0z");
      attr(path1, "d", "M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z");
      attr(svg, "class", "size-5");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block3(ctx) {
  let div2;
  let show_if;
  let show_if_1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_12, create_if_block_22];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*isActive*/
    32)
      show_if = null;
    if (dirty & /*isActive*/
    32)
      show_if_1 = null;
    if (show_if == null)
      show_if = !!!/*isActive*/
      ctx2[5]("link");
    if (show_if)
      return 0;
    if (show_if_1 == null)
      show_if_1 = !!/*isActive*/
      ctx2[5]("link");
    if (show_if_1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      attr(div2, "class", "flex items-center");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div2, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block_22(ctx) {
  let span;
  let t0_value = (
    /*editor*/
    ctx[1].getAttributes("link").href + ""
  );
  let t0;
  let t1;
  let button0;
  let t2;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[1]
      ),
      key: "editLink",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*click_handler_4*/
    ctx[16]
  );
  button1 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[1]
      ),
      key: "unsetLink",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*click_handler_5*/
    ctx[17]
  );
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      create_component(button0.$$.fragment);
      t2 = space();
      create_component(button1.$$.fragment);
      attr(span, "class", "max-w-xs text-sm leading-none truncate overflow-hidden whitespace-nowrap");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      mount_component(button0, target, anchor);
      insert(target, t2, anchor);
      mount_component(button1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*editor*/
      2) && t0_value !== (t0_value = /*editor*/
      ctx2[1].getAttributes("link").href + ""))
        set_data(t0, t0_value);
      const button0_changes = {};
      if (dirty & /*editor*/
      2)
        button0_changes.editor = /*editor*/
        ctx2[1];
      if (dirty & /*$$scope, tools*/
      33554433) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*editor*/
      2)
        button1_changes.editor = /*editor*/
        ctx2[1];
      if (dirty & /*$$scope*/
      33554432) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t1);
        detach(t2);
      }
      destroy_component(button0, detaching);
      destroy_component(button1, detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*bubbleTools*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*editor, bubbleTools, handleToolClick*/
      146) {
        each_value = ensure_array_like(
          /*bubbleTools*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let html_tag;
  let raw_value = (
    /*tools*/
    ctx[0].find(func)?.icon + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*tools*/
      1 && raw_value !== (raw_value = /*tools*/
      ctx2[0].find(func)?.icon + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_default_slot_1(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M17 17H22V19H19V22H17V17ZM7 7H2V5H5V2H7V7ZM18.364 15.5355L16.9497 14.1213L18.364 12.7071C20.3166 10.7545 20.3166 7.58866 18.364 5.63604C16.4113 3.68342 13.2455 3.68342 11.2929 5.63604L9.87868 7.05025L8.46447 5.63604L9.87868 4.22183C12.6123 1.48816 17.0445 1.48816 19.7782 4.22183C22.5118 6.9555 22.5118 11.3877 19.7782 14.1213L18.364 15.5355ZM15.5355 18.364L14.1213 19.7782C11.3877 22.5118 6.9555 22.5118 4.22183 19.7782C1.48816 17.0445 1.48816 12.6123 4.22183 9.87868L5.63604 8.46447L7.05025 9.87868L5.63604 11.2929C3.68342 13.2455 3.68342 16.4113 5.63604 18.364C7.58866 20.3166 10.7545 20.3166 12.7071 18.364L14.1213 16.9497L15.5355 18.364ZM14.8284 7.75736L16.2426 9.17157L9.17157 16.2426L7.75736 14.8284L14.8284 7.75736Z");
      attr(svg, "class", "size-5");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot4(ctx) {
  let html_tag;
  let raw_value = (
    /*tool*/
    ctx[22].icon + ""
  );
  let t;
  return {
    c() {
      html_tag = new HtmlTag(false);
      t = space();
      html_tag.a = t;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*bubbleTools*/
      16 && raw_value !== (raw_value = /*tool*/
      ctx2[22].icon + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        html_tag.d();
        detach(t);
      }
    }
  };
}
function create_each_block3(ctx) {
  let button;
  let current;
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[15](
        /*tool*/
        ctx[22]
      )
    );
  }
  button = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[1]
      ),
      key: (
        /*tool*/
        ctx[22].extension
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler_3);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*editor*/
      2)
        button_changes.editor = /*editor*/
        ctx[1];
      if (dirty & /*bubbleTools*/
      16)
        button_changes.key = /*tool*/
        ctx[22].extension;
      if (dirty & /*$$scope, bubbleTools*/
      33554448) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_fragment8(ctx) {
  let div2;
  let t0;
  let div0;
  let t1;
  let div1;
  let current;
  let if_block0 = (
    /*editor*/
    ctx[1] && create_if_block_32(ctx)
  );
  let if_block1 = (
    /*editor*/
    ctx[1] && create_if_block3(ctx)
  );
  return {
    c() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      t1 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "scribble-editor");
      attr(div2, "class", "scribble-editor-wrapper w-full");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t0);
      append(div2, div0);
      ctx[14](div0);
      append(div2, t1);
      append(div2, div1);
      if (if_block1)
        if_block1.m(div1, null);
      ctx[18](div1);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*editor*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*editor*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_32(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*editor*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*editor*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      ctx[14](null);
      if (if_block1)
        if_block1.d();
      ctx[18](null);
    }
  };
}
var func = (item) => item.extension === "link";
function instance8($$self, $$props, $$invalidate) {
  let isActive2;
  let $getStatePath;
  component_subscribe($$self, getStatePath, ($$value) => $$invalidate(20, $getStatePath = $$value));
  let editor;
  let element2;
  let bubbleMenuElement;
  let bubbleTools;
  let suggestionTools;
  let { tools } = $$props;
  let { content } = $$props;
  let { statePath } = $$props;
  let { placeholder } = $$props;
  set_store_value(getStatePath, $getStatePath = statePath, $getStatePath);
  const contentStore = writable(content);
  bubbleTools = tools.filter((tool) => tool.bubble === true);
  suggestionTools = tools.filter((tool) => tool.suggestion === true);
  onMount(() => {
    $$invalidate(1, editor = new Editor({
      content,
      element: element2,
      extensions: [
        StarterKit,
        ClassExtension,
        LinkExtension,
        IdExtension,
        ScribbleBlock_default2,
        Subscript,
        Superscript,
        MediaExtension,
        HeroExtension,
        TextAlign.configure({ types: ["heading", "paragraph"] }),
        TextStyle3,
        SlashExtension_default.configure({ tools: suggestionTools }),
        BubbleMenu.configure({
          element: bubbleMenuElement,
          tippyOptions: {
            maxWidth: "none",
            placement: "top-start",
            theme: "scribble-bubble"
          },
          shouldShow: ({ editor: editor2, from: from2, to }) => {
            if (from2 === to && editor2.isActive("link")) {
              return true;
            }
            return from2 !== to && !(editor2.isActive("image") || editor2.isActive("scribbleBlock") || editor2.isActive("slashExtension"));
          }
        }),
        Placeholder.configure({
          placeholder,
          emptyEditorClass: "is-editor-empty"
        })
      ],
      onTransaction: () => {
        $$invalidate(1, editor);
      },
      onUpdate({ editor: editor2 }) {
        window.dispatchEvent(new CustomEvent(
          "updatedEditor",
          {
            detail: { statePath, content: editor2.getJSON() }
          }
        ));
        contentStore.set(editor2.getHTML());
      }
    }));
  });
  onDestroy(() => {
    editor.destroy();
  });
  const toggleFullscreen = () => {
    window.dispatchEvent(new CustomEvent("toggle-fullscreen", { detail: { statePath } }));
    editor.commands.focus();
  };
  tools.forEach((tool) => {
    window.addEventListener(`insert-${tool.extension}`, (data) => {
      if (data.detail.statePath !== statePath) {
        return;
      }
      if (tool.extension === "link") {
        editor.chain().focus().extendMarkRange("link").setLink(data.detail.data).selectTextblockEnd().run();
        return;
      }
      if (tool.extension === "media") {
        editor.chain().focus().setImage(data.detail.data).run();
        return;
      }
      if (tool.type === "block") {
        editor.chain().insertScribbleBlock({
          type: tool.identifier,
          statePath: tool.statePath,
          values: data.detail.data
        }).focus().run();
        return;
      }
      editor.chain().focus()[tool.command](data.detail.data).run();
    });
    window.addEventListener(`update-${tool.extension}`, (data) => {
      if (data.detail.statePath !== statePath) {
        return;
      }
      if (tool.extension === "link") {
        editor.chain().focus().extendMarkRange("link").setLink(data.detail.data).selectTextblockEnd().run();
        return;
      }
      if (tool.extension === "media") {
        editor.chain().focus().setImage(data.detail.data).run();
        return;
      }
      if (tool.type === "block") {
        window.dispatchEvent(new CustomEvent(
          "updatedBlock",
          {
            detail: {
              type: tool.identifier,
              statePath: tool.statePath,
              values: data.detail.data
            }
          }
        ));
        return;
      }
      editor.chain().focus()[tool.command](data.detail.data).run();
    });
  });
  const handleToolClick = (tool) => {
    if (tool.type === "block" && tool.prerender) {
      editor.chain().insertScribbleBlock({
        type: tool.identifier,
        statePath: tool.statePath,
        values: {}
      }).focus().run();
    }
    switch (tool.type) {
      case "command":
        editor.chain().focus()[tool.command](tool.commandArguments).run();
        return;
      case "modal":
        pounce(tool.identifier, {
          statePath: tool.statePath,
          ...editor.getAttributes(tool.extension)
        });
        return;
      default:
        editor.commands.setScribbleBlock({
          type: tool.identifier,
          statePath: tool.statePath
        });
    }
  };
  const click_handler = () => editor.chain().focus().undo().run();
  const click_handler_1 = () => editor.chain().focus().redo().run();
  const click_handler_2 = () => editor.chain().focus().clearContent(true).run();
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  const click_handler_3 = (tool) => handleToolClick(tool);
  const click_handler_4 = () => handleToolClick(tools.find((item) => item.extension === "link"));
  const click_handler_5 = () => editor.chain().focus().extendMarkRange("link").unsetLink().selectTextblockEnd().run();
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      bubbleMenuElement = $$value;
      $$invalidate(3, bubbleMenuElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("tools" in $$props2)
      $$invalidate(0, tools = $$props2.tools);
    if ("content" in $$props2)
      $$invalidate(8, content = $$props2.content);
    if ("statePath" in $$props2)
      $$invalidate(9, statePath = $$props2.statePath);
    if ("placeholder" in $$props2)
      $$invalidate(10, placeholder = $$props2.placeholder);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*editor*/
    2) {
      $:
        $$invalidate(5, isActive2 = (name, attrs = {}) => editor.isActive(name, attrs));
    }
  };
  return [
    tools,
    editor,
    element2,
    bubbleMenuElement,
    bubbleTools,
    isActive2,
    toggleFullscreen,
    handleToolClick,
    content,
    statePath,
    placeholder,
    click_handler,
    click_handler_1,
    click_handler_2,
    div0_binding,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    div1_binding
  ];
}
var Scribble = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      tools: 0,
      content: 8,
      statePath: 9,
      placeholder: 10
    });
  }
};
var Scribble_default = Scribble;

// resources/js/index.js
function scribble(tools, state, statePath, placeholder) {
  return {
    tools,
    state,
    statePath,
    placeholder: placeholder ?? "press '/' for blocks",
    fullscreen: false,
    init() {
      const _this = this;
      new Scribble_default({
        target: _this.$root,
        props: {
          tools: _this.tools,
          content: _this.state,
          statePath: _this.statePath,
          placeholder: _this.placeholder
        }
      });
      window.addEventListener("updatedEditor", (e) => {
        if (e.detail.statePath === _this.statePath) {
          _this.state = e.detail.content;
        }
      });
    },
    toggleFullscreen(event) {
      if (event.detail.statePath !== this.statePath)
        return;
      this.fullscreen = !this.fullscreen;
    }
  };
}
export {
  scribble as default
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC91dGlscy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2dsb2JhbHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9SZXNpemVPYnNlcnZlclNpbmdsZXRvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2RvbS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2xpZmVjeWNsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3NjaGVkdWxlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3RyYW5zaXRpb25zLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZWFjaC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3NwcmVhZC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9zaGFyZWQvYm9vbGVhbl9hdHRyaWJ1dGVzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvQ29tcG9uZW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3NoYXJlZC92ZXJzaW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZGlzY2xvc2UtdmVyc2lvbi9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL3N0b3JlL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vcmRlcmVkbWFwL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLW1vZGVsL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXRyYW5zZm9ybS9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1zdGF0ZS9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci12aWV3L2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3czYy1rZXluYW1lL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1rZXltYXAvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itc2NoZW1hLWxpc3QvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2NyZWF0ZUNoYWluYWJsZVN0YXRlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL0NvbW1hbmRNYW5hZ2VyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL0V2ZW50RW1pdHRlci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldEV4dGVuc2lvbkZpZWxkLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvc3BsaXRFeHRlbnNpb25zLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0Tm9kZVR5cGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL21lcmdlQXR0cmlidXRlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFJlbmRlcmVkQXR0cmlidXRlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNGdW5jdGlvbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc0VtcHR5T2JqZWN0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9mcm9tU3RyaW5nLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRTY2hlbWFUeXBlQnlOYW1lLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRUZXh0Q29udGVudEZyb21Ob2Rlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNSZWdFeHAudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvSW5wdXRSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc051bWJlci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9QYXN0ZVJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2ZpbmREdXBsaWNhdGVzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL0V4dGVuc2lvbk1hbmFnZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzUGxhaW5PYmplY3QudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL21lcmdlRGVlcC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9FeHRlbnNpb24udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRUZXh0QmV0d2Vlbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvZXh0ZW5zaW9ucy9jbGlwYm9hcmRUZXh0U2VyaWFsaXplci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9ibHVyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2NsZWFyQ29udGVudC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9jbGVhck5vZGVzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2NvbW1hbmQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvY3JlYXRlUGFyYWdyYXBoTmVhci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9jdXQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZGVsZXRlQ3VycmVudE5vZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZGVsZXRlTm9kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9kZWxldGVSYW5nZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9kZWxldGVTZWxlY3Rpb24udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZW50ZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZXhpdENvZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL29iamVjdEluY2x1ZGVzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0TWFya1JhbmdlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0TWFya1R5cGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZXh0ZW5kTWFya1JhbmdlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2ZpcnN0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNUZXh0U2VsZWN0aW9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9taW5NYXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9yZXNvbHZlRm9jdXNQb3NpdGlvbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNpT1MudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZm9jdXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZm9yRWFjaC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9pbnNlcnRDb250ZW50LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9lbGVtZW50RnJvbVN0cmluZy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2NyZWF0ZU5vZGVGcm9tQ29udGVudC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL3NlbGVjdGlvblRvSW5zZXJ0aW9uRW5kLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2luc2VydENvbnRlbnRBdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9qb2luLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2pvaW5JdGVtQmFja3dhcmQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvam9pbkl0ZW1Gb3J3YXJkLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc01hY09TLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2tleWJvYXJkU2hvcnRjdXQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc05vZGVBY3RpdmUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvbGlmdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9saWZ0RW1wdHlCbG9jay50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9saWZ0TGlzdEl0ZW0udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvbmV3bGluZUluQ29kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNjaGVtYVR5cGVOYW1lQnlOYW1lLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9kZWxldGVQcm9wcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9yZXNldEF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2Nyb2xsSW50b1ZpZXcudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2VsZWN0QWxsLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdE5vZGVCYWNrd2FyZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZWxlY3ROb2RlRm9yd2FyZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZWxlY3RQYXJlbnROb2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdFRleHRibG9ja0VuZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZWxlY3RUZXh0YmxvY2tTdGFydC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2NyZWF0ZURvY3VtZW50LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldENvbnRlbnQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRNYXJrQXR0cmlidXRlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2NvbWJpbmVUcmFuc2FjdGlvblN0ZXBzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZGVmYXVsdEJsb2NrQXQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9maW5kQ2hpbGRyZW4udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9maW5kQ2hpbGRyZW5JblJhbmdlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9maW5kUGFyZW50Tm9kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldEhUTUxGcm9tRnJhZ21lbnQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRTY2hlbWEudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZW5lcmF0ZUhUTUwudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZW5lcmF0ZUpTT04udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRUZXh0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2VuZXJhdGVUZXh0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0Tm9kZUF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9yZW1vdmVEdXBsaWNhdGVzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0Q2hhbmdlZFJhbmdlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldERlYnVnSlNPTi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE1hcmtzQmV0d2Vlbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE5vZGVBdFBvc2l0aW9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNNYXJrQWN0aXZlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNBY3RpdmUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0F0RW5kT2ZOb2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNBdFN0YXJ0T2ZOb2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNMaXN0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNOb2RlRW1wdHkudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc05vZGVTZWxlY3Rpb24udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9wb3NUb0RPTVJlY3QudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0TWFyay50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXRNZXRhLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldE5vZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0Tm9kZVNlbGVjdGlvbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXRUZXh0U2VsZWN0aW9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NpbmtMaXN0SXRlbS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zcGxpdEJsb2NrLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NwbGl0TGlzdEl0ZW0udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdG9nZ2xlTGlzdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy90b2dnbGVNYXJrLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3RvZ2dsZU5vZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdG9nZ2xlV3JhcC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy91bmRvSW5wdXRSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3Vuc2V0QWxsTWFya3MudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdW5zZXRNYXJrLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3VwZGF0ZUF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvd3JhcEluLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3dyYXBJbkxpc3QudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvZXh0ZW5zaW9ucy9jb21tYW5kcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2VkaXRhYmxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2V4dGVuc2lvbnMvZm9jdXNFdmVudHMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvZXh0ZW5zaW9ucy9rZXltYXAudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvZXh0ZW5zaW9ucy90YWJpbmRleC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9zdHlsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvY3JlYXRlU3R5bGVUYWcudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvRWRpdG9yLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2lucHV0UnVsZXMvbWFya0lucHV0UnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9pbnB1dFJ1bGVzL25vZGVJbnB1dFJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaW5wdXRSdWxlcy90ZXh0YmxvY2tUeXBlSW5wdXRSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2lucHV0UnVsZXMvdGV4dElucHV0UnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9pbnB1dFJ1bGVzL3dyYXBwaW5nSW5wdXRSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL01hcmsudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvTm9kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNBbmRyb2lkLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL05vZGVWaWV3LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3Bhc3RlUnVsZXMvbWFya1Bhc3RlUnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvZXNjYXBlRm9yUmVnRXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzU3RyaW5nLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3Bhc3RlUnVsZXMvbm9kZVBhc3RlUnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9wYXN0ZVJ1bGVzL3RleHRQYXN0ZVJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvVHJhY2tlci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21hdGguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy91c2VyQWdlbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNMYXlvdXRWaWV3cG9ydC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVTY3JvbGwuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL2NvbnN0YW50cy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL3V0aWxzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvZG9tLXV0aWxzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvYnJvd3Nlci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL3ZhbGlkYXRpb24udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy9wcm9wcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL3RlbXBsYXRlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvY3JlYXRlVGlwcHkudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy9pbmRleC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL2FkZG9ucy9jcmVhdGVTaW5nbGV0b24udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy9hZGRvbnMvZGVsZWdhdGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy9wbHVnaW5zL2FuaW1hdGVGaWxsLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvcGx1Z2lucy9mb2xsb3dDdXJzb3IudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy9wbHVnaW5zL2lubGluZVBvc2l0aW9uaW5nLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvcGx1Z2lucy9zdGlja3kudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL2J1aWxkL2Jhc2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJ1YmJsZS1tZW51L3NyYy9idWJibGUtbWVudS1wbHVnaW4udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJ1YmJsZS1tZW51L3NyYy9idWJibGUtbWVudS50cyIsICIuLi9qcy9leHRlbnNpb25zL0NsYXNzRXh0ZW5zaW9uLmpzIiwgIi4uL2pzL2V4dGVuc2lvbnMvSWRFeHRlbnNpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2xpbmtpZnlqcy9kaXN0L2xpbmtpZnkuZXMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpbmsvc3JjL2hlbHBlcnMvYXV0b2xpbmsudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpbmsvc3JjL2hlbHBlcnMvY2xpY2tIYW5kbGVyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saW5rL3NyYy9oZWxwZXJzL3Bhc3RlSGFuZGxlci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9zcmMvbGluay50cyIsICIuLi9qcy9leHRlbnNpb25zL0xpbmtFeHRlbnNpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWltYWdlL3NyYy9pbWFnZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXRpcHRhcC9kaXN0L1N2ZWx0ZVJlbmRlcmVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtdGlwdGFwL2Rpc3QvY29udGV4dC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXRpcHRhcC9kaXN0L1N2ZWx0ZU5vZGVWaWV3UmVuZGVyZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS10aXB0YXAvZGlzdC9Ob2RlVmlld1dyYXBwZXIuc3ZlbHRlIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtdGlwdGFwL2Rpc3QvTm9kZVZpZXdDb250ZW50LnN2ZWx0ZSIsICIuLi9qcy91dGlscy9wb3VuY2UuanMiLCAiLi4vanMvc3RvcmVzLmpzIiwgIi4uL2pzL2NvbXBvbmVudHMvTWVkaWFWaWV3LnN2ZWx0ZSIsICIuLi9qcy9leHRlbnNpb25zL01lZGlhRXh0ZW5zaW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1wbGFjZWhvbGRlci9zcmMvcGxhY2Vob2xkZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJsb2NrcXVvdGUvc3JjL2Jsb2NrcXVvdGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJvbGQvc3JjL2JvbGQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3QtaXRlbS9zcmMvbGlzdC1pdGVtLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10ZXh0LXN0eWxlL3NyYy90ZXh0LXN0eWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1idWxsZXQtbGlzdC9zcmMvYnVsbGV0LWxpc3QudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUvc3JjL2NvZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUtYmxvY2svc3JjL2NvZGUtYmxvY2sudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWRvY3VtZW50L3NyYy9kb2N1bWVudC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItZHJvcGN1cnNvci9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1kcm9wY3Vyc29yL3NyYy9kcm9wY3Vyc29yLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1nYXBjdXJzb3IvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZ2FwY3Vyc29yL3NyYy9nYXBjdXJzb3IudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhhcmQtYnJlYWsvc3JjL2hhcmQtYnJlYWsudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhlYWRpbmcvc3JjL2hlYWRpbmcudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3JvcGUtc2VxdWVuY2UvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItaGlzdG9yeS9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oaXN0b3J5L3NyYy9oaXN0b3J5LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ob3Jpem9udGFsLXJ1bGUvc3JjL2hvcml6b250YWwtcnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taXRhbGljL3NyYy9pdGFsaWMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3QtaXRlbS9zcmMvbGlzdC1pdGVtLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saXN0LWl0ZW0vc3JjL2xpc3QtaXRlbS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC1zdHlsZS9zcmMvdGV4dC1zdHlsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tb3JkZXJlZC1saXN0L3NyYy9vcmRlcmVkLWxpc3QudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXBhcmFncmFwaC9zcmMvcGFyYWdyYXBoLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1zdHJpa2Uvc3JjL3N0cmlrZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC9zcmMvdGV4dC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdGFydGVyLWtpdC9zcmMvc3RhcnRlci1raXQudHMiLCAiLi4vanMvY29tcG9uZW50cy9TY3JpYmJsZUJsb2NrLnN2ZWx0ZSIsICIuLi9qcy91dGlscy91dWlkLmpzIiwgIi4uL2pzL2V4dGVuc2lvbnMvU2NyaWJibGVCbG9jay5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdWdnZXN0aW9uL3NyYy9maW5kU3VnZ2VzdGlvbk1hdGNoLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3N1Z2dlc3Rpb24vc3JjL3N1Z2dlc3Rpb24udHMiLCAiLi4vanMvY29tcG9uZW50cy9Db21tYW5kc0xpc3Quc3ZlbHRlIiwgIi4uL2pzL2V4dGVuc2lvbnMvU2xhc2hFeHRlbnNpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXN1YnNjcmlwdC9zcmMvc3Vic2NyaXB0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1zdXBlcnNjcmlwdC9zcmMvc3VwZXJzY3JpcHQudHMiLCAiLi4vanMvZXh0ZW5zaW9ucy9UZXh0QWxpZ25FeHRlbnNpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXRleHQtc3R5bGUvc3JjL3RleHQtc3R5bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm1qcyIsICIuLi9qcy9jb21wb25lbnRzL0J1dHRvbi5zdmVsdGUiLCAiLi4vanMvY29tcG9uZW50cy9IZXJvVmlldy5zdmVsdGUiLCAiLi4vanMvZXh0ZW5zaW9ucy9IZXJvRXh0ZW5zaW9uLmpzIiwgIi4uL2pzL1NjcmliYmxlLnN2ZWx0ZSIsICIuLi9qcy9pbmRleC5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5leHBvcnQgY29uc3QgaWRlbnRpdHkgPSAoeCkgPT4geDtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIFNcbiAqIEBwYXJhbSB7VH0gdGFyXG4gKiBAcGFyYW0ge1N9IHNyY1xuICogQHJldHVybnMge1QgJiBTfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhciwgc3JjKSB7XG5cdC8vIEB0cy1pZ25vcmVcblx0Zm9yIChjb25zdCBrIGluIHNyYykgdGFyW2tdID0gc3JjW2tdO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtUICYgU30gKi8gKHRhcik7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL0xJQ0VOU0Vcbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgUHJvbWlzZUxpa2U8YW55Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3Byb21pc2UodmFsdWUpIHtcblx0cmV0dXJuIChcblx0XHQhIXZhbHVlICYmXG5cdFx0KHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSAmJlxuXHRcdHR5cGVvZiAoLyoqIEB0eXBlIHthbnl9ICovICh2YWx1ZSkudGhlbikgPT09ICdmdW5jdGlvbidcblx0KTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9sb2NhdGlvbihlbGVtZW50LCBmaWxlLCBsaW5lLCBjb2x1bW4sIGNoYXIpIHtcblx0ZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuXHRcdGxvYzogeyBmaWxlLCBsaW5lLCBjb2x1bW4sIGNoYXIgfVxuXHR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVuKGZuKSB7XG5cdHJldHVybiBmbigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmxhbmtfb2JqZWN0KCkge1xuXHRyZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW119IGZuc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5fYWxsKGZucykge1xuXHRmbnMuZm9yRWFjaChydW4pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB0aGluZ1xuICogQHJldHVybnMge3RoaW5nIGlzIEZ1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfZnVuY3Rpb24odGhpbmcpIHtcblx0cmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqIEByZXR1cm5zIHtib29sZWFufSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhZmVfbm90X2VxdWFsKGEsIGIpIHtcblx0cmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGIgfHwgKGEgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB8fCB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxubGV0IHNyY191cmxfZXF1YWxfYW5jaG9yO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50X3NyY1xuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcmNfdXJsX2VxdWFsKGVsZW1lbnRfc3JjLCB1cmwpIHtcblx0aWYgKGVsZW1lbnRfc3JjID09PSB1cmwpIHJldHVybiB0cnVlO1xuXHRpZiAoIXNyY191cmxfZXF1YWxfYW5jaG9yKSB7XG5cdFx0c3JjX3VybF9lcXVhbF9hbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdH1cblx0Ly8gVGhpcyBpcyBhY3R1YWxseSBmYXN0ZXIgdGhhbiBkb2luZyBVUkwoLi4pLmhyZWZcblx0c3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZiA9IHVybDtcblx0cmV0dXJuIGVsZW1lbnRfc3JjID09PSBzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmO1xufVxuXG4vKiogQHBhcmFtIHtzdHJpbmd9IHNyY3NldCAqL1xuZnVuY3Rpb24gc3BsaXRfc3Jjc2V0KHNyY3NldCkge1xuXHRyZXR1cm4gc3Jjc2V0LnNwbGl0KCcsJykubWFwKChzcmMpID0+IHNyYy50cmltKCkuc3BsaXQoJyAnKS5maWx0ZXIoQm9vbGVhbikpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFNvdXJjZUVsZW1lbnQgfCBIVE1MSW1hZ2VFbGVtZW50fSBlbGVtZW50X3NyY3NldFxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBzcmNzZXRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3Jjc2V0X3VybF9lcXVhbChlbGVtZW50X3NyY3NldCwgc3Jjc2V0KSB7XG5cdGNvbnN0IGVsZW1lbnRfdXJscyA9IHNwbGl0X3NyY3NldChlbGVtZW50X3NyY3NldC5zcmNzZXQpO1xuXHRjb25zdCB1cmxzID0gc3BsaXRfc3Jjc2V0KHNyY3NldCB8fCAnJyk7XG5cblx0cmV0dXJuIChcblx0XHR1cmxzLmxlbmd0aCA9PT0gZWxlbWVudF91cmxzLmxlbmd0aCAmJlxuXHRcdHVybHMuZXZlcnkoXG5cdFx0XHQoW3VybCwgd2lkdGhdLCBpKSA9PlxuXHRcdFx0XHR3aWR0aCA9PT0gZWxlbWVudF91cmxzW2ldWzFdICYmXG5cdFx0XHRcdC8vIFdlIG5lZWQgdG8gdGVzdCBib3RoIHdheXMgYmVjYXVzZSBWaXRlIHdpbGwgY3JlYXRlIGFuIGEgZnVsbCBVUkwgd2l0aFxuXHRcdFx0XHQvLyBgbmV3IFVSTChhc3NldCwgaW1wb3J0Lm1ldGEudXJsKS5ocmVmYCBmb3IgdGhlIGNsaWVudCB3aGVuIGBiYXNlOiAnLi8nYCwgYW5kIHRoZVxuXHRcdFx0XHQvLyByZWxhdGl2ZSBVUkxzIGluc2lkZSBzcmNzZXQgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IHJlc29sdmVkIHRvIGFic29sdXRlIFVSTHMgYnlcblx0XHRcdFx0Ly8gYnJvd3NlcnMgKGluIGNvbnRyYXN0IHRvIGltZy5zcmMpLiBUaGlzIG1lYW5zIGJvdGggU1NSIGFuZCBET00gY29kZSBjb3VsZFxuXHRcdFx0XHQvLyBjb250YWluIHJlbGF0aXZlIG9yIGFic29sdXRlIFVSTHMuXG5cdFx0XHRcdChzcmNfdXJsX2VxdWFsKGVsZW1lbnRfdXJsc1tpXVswXSwgdXJsKSB8fCBzcmNfdXJsX2VxdWFsKHVybCwgZWxlbWVudF91cmxzW2ldWzBdKSlcblx0XHQpXG5cdCk7XG59XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3RfZXF1YWwoYSwgYikge1xuXHRyZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYjtcbn1cblxuLyoqIEByZXR1cm5zIHtib29sZWFufSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2VtcHR5KG9iaikge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZV9zdG9yZShzdG9yZSwgbmFtZSkge1xuXHRpZiAoc3RvcmUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RvcmUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGAnJHtuYW1lfScgaXMgbm90IGEgc3RvcmUgd2l0aCBhICdzdWJzY3JpYmUnIG1ldGhvZGApO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJzY3JpYmUoc3RvcmUsIC4uLmNhbGxiYWNrcykge1xuXHRpZiAoc3RvcmUgPT0gbnVsbCkge1xuXHRcdGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XG5cdFx0XHRjYWxsYmFjayh1bmRlZmluZWQpO1xuXHRcdH1cblx0XHRyZXR1cm4gbm9vcDtcblx0fVxuXHRjb25zdCB1bnN1YiA9IHN0b3JlLnN1YnNjcmliZSguLi5jYWxsYmFja3MpO1xuXHRyZXR1cm4gdW5zdWIudW5zdWJzY3JpYmUgPyAoKSA9PiB1bnN1Yi51bnN1YnNjcmliZSgpIDogdW5zdWI7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIGZyb20gYSBzdG9yZSBieSBzdWJzY3JpYmluZyBhbmQgaW1tZWRpYXRlbHkgdW5zdWJzY3JpYmluZy5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjZ2V0XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3N0b3JlL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fSBzdG9yZVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfc3RvcmVfdmFsdWUoc3RvcmUpIHtcblx0bGV0IHZhbHVlO1xuXHRzdWJzY3JpYmUoc3RvcmUsIChfKSA9PiAodmFsdWUgPSBfKSkoKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50X3N1YnNjcmliZShjb21wb25lbnQsIHN0b3JlLCBjYWxsYmFjaykge1xuXHRjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKHN1YnNjcmliZShzdG9yZSwgY2FsbGJhY2spKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9zbG90KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcblx0aWYgKGRlZmluaXRpb24pIHtcblx0XHRjb25zdCBzbG90X2N0eCA9IGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbik7XG5cdFx0cmV0dXJuIGRlZmluaXRpb25bMF0oc2xvdF9jdHgpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuXHRyZXR1cm4gZGVmaW5pdGlvblsxXSAmJiBmbiA/IGFzc2lnbigkJHNjb3BlLmN0eC5zbGljZSgpLCBkZWZpbml0aW9uWzFdKGZuKGN0eCkpKSA6ICQkc2NvcGUuY3R4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3Nsb3RfY2hhbmdlcyhkZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZm4pIHtcblx0aWYgKGRlZmluaXRpb25bMl0gJiYgZm4pIHtcblx0XHRjb25zdCBsZXRzID0gZGVmaW5pdGlvblsyXShmbihkaXJ0eSkpO1xuXHRcdGlmICgkJHNjb3BlLmRpcnR5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBsZXRzO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIGxldHMgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRjb25zdCBtZXJnZWQgPSBbXTtcblx0XHRcdGNvbnN0IGxlbiA9IE1hdGgubWF4KCQkc2NvcGUuZGlydHkubGVuZ3RoLCBsZXRzLmxlbmd0aCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG5cdFx0XHRcdG1lcmdlZFtpXSA9ICQkc2NvcGUuZGlydHlbaV0gfCBsZXRzW2ldO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1lcmdlZDtcblx0XHR9XG5cdFx0cmV0dXJuICQkc2NvcGUuZGlydHkgfCBsZXRzO1xuXHR9XG5cdHJldHVybiAkJHNjb3BlLmRpcnR5O1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3Nsb3RfYmFzZShcblx0c2xvdCxcblx0c2xvdF9kZWZpbml0aW9uLFxuXHRjdHgsXG5cdCQkc2NvcGUsXG5cdHNsb3RfY2hhbmdlcyxcblx0Z2V0X3Nsb3RfY29udGV4dF9mblxuKSB7XG5cdGlmIChzbG90X2NoYW5nZXMpIHtcblx0XHRjb25zdCBzbG90X2NvbnRleHQgPSBnZXRfc2xvdF9jb250ZXh0KHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcblx0XHRzbG90LnAoc2xvdF9jb250ZXh0LCBzbG90X2NoYW5nZXMpO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfc2xvdChcblx0c2xvdCxcblx0c2xvdF9kZWZpbml0aW9uLFxuXHRjdHgsXG5cdCQkc2NvcGUsXG5cdGRpcnR5LFxuXHRnZXRfc2xvdF9jaGFuZ2VzX2ZuLFxuXHRnZXRfc2xvdF9jb250ZXh0X2ZuXG4pIHtcblx0Y29uc3Qgc2xvdF9jaGFuZ2VzID0gZ2V0X3Nsb3RfY2hhbmdlcyhzbG90X2RlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBnZXRfc2xvdF9jaGFuZ2VzX2ZuKTtcblx0dXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbn1cblxuLyoqIEByZXR1cm5zIHthbnlbXSB8IC0xfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSgkJHNjb3BlKSB7XG5cdGlmICgkJHNjb3BlLmN0eC5sZW5ndGggPiAzMikge1xuXHRcdGNvbnN0IGRpcnR5ID0gW107XG5cdFx0Y29uc3QgbGVuZ3RoID0gJCRzY29wZS5jdHgubGVuZ3RoIC8gMzI7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0ZGlydHlbaV0gPSAtMTtcblx0XHR9XG5cdFx0cmV0dXJuIGRpcnR5O1xuXHR9XG5cdHJldHVybiAtMTtcbn1cblxuLyoqIEByZXR1cm5zIHt7fX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGNsdWRlX2ludGVybmFsX3Byb3BzKHByb3BzKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRmb3IgKGNvbnN0IGsgaW4gcHJvcHMpIGlmIChrWzBdICE9PSAnJCcpIHJlc3VsdFtrXSA9IHByb3BzW2tdO1xuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogQHJldHVybnMge3t9fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVfcmVzdF9wcm9wcyhwcm9wcywga2V5cykge1xuXHRjb25zdCByZXN0ID0ge307XG5cdGtleXMgPSBuZXcgU2V0KGtleXMpO1xuXHRmb3IgKGNvbnN0IGsgaW4gcHJvcHMpIGlmICgha2V5cy5oYXMoaykgJiYga1swXSAhPT0gJyQnKSByZXN0W2tdID0gcHJvcHNba107XG5cdHJldHVybiByZXN0O1xufVxuXG4vKiogQHJldHVybnMge3t9fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVfc2xvdHMoc2xvdHMpIHtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG5cdFx0cmVzdWx0W2tleV0gPSB0cnVlO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBAcmV0dXJucyB7KHRoaXM6IGFueSwgLi4uYXJnczogYW55W10pID0+IHZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gb25jZShmbikge1xuXHRsZXQgcmFuID0gZmFsc2U7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdGlmIChyYW4pIHJldHVybjtcblx0XHRyYW4gPSB0cnVlO1xuXHRcdGZuLmNhbGwodGhpcywgLi4uYXJncyk7XG5cdH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBudWxsX3RvX2VtcHR5KHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldF9zdG9yZV92YWx1ZShzdG9yZSwgcmV0LCB2YWx1ZSkge1xuXHRzdG9yZS5zZXQodmFsdWUpO1xuXHRyZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgY29uc3QgaGFzX3Byb3AgPSAob2JqLCBwcm9wKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFjdGlvbl9kZXN0cm95ZXIoYWN0aW9uX3Jlc3VsdCkge1xuXHRyZXR1cm4gYWN0aW9uX3Jlc3VsdCAmJiBpc19mdW5jdGlvbihhY3Rpb25fcmVzdWx0LmRlc3Ryb3kpID8gYWN0aW9uX3Jlc3VsdC5kZXN0cm95IDogbm9vcDtcbn1cblxuLyoqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge1tudW1iZXIsIHN0cmluZ119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdF9jc3NfdW5pdCh2YWx1ZSkge1xuXHRjb25zdCBzcGxpdCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubWF0Y2goL15cXHMqKC0/W1xcZC5dKykoW15cXHNdKilcXHMqJC8pO1xuXHRyZXR1cm4gc3BsaXQgPyBbcGFyc2VGbG9hdChzcGxpdFsxXSksIHNwbGl0WzJdIHx8ICdweCddIDogWy8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodmFsdWUpLCAncHgnXTtcbn1cblxuZXhwb3J0IGNvbnN0IGNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzID0gWycnLCB0cnVlLCAxLCAndHJ1ZScsICdjb250ZW50ZWRpdGFibGUnXTtcbiIsICIvKiogQHR5cGUge3R5cGVvZiBnbG9iYWxUaGlzfSAqL1xuZXhwb3J0IGNvbnN0IGdsb2JhbHMgPVxuXHR0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuXHRcdD8gd2luZG93XG5cdFx0OiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcblx0XHQ/IGdsb2JhbFRoaXNcblx0XHQ6IC8vIEB0cy1pZ25vcmUgTm9kZSB0eXBpbmdzIGhhdmUgdGhpc1xuXHRcdCAgZ2xvYmFsO1xuIiwgImltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuL2dsb2JhbHMuanMnO1xuXG4vKipcbiAqIFJlc2l6ZSBvYnNlcnZlciBzaW5nbGV0b24uXG4gKiBPbmUgbGlzdGVuZXIgcGVyIGVsZW1lbnQgb25seSFcbiAqIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZy9ibGluay1kZXYvYy96Nmllbk9OVWI1QS9tL0Y1LVZjVVp0QkFBSlxuICovXG5leHBvcnQgY2xhc3MgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24ge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHJlYWRvbmx5XG5cdCAqIEB0eXBlIHtXZWFrTWFwPEVsZW1lbnQsIGltcG9ydCgnLi9wcml2YXRlLmpzJykuTGlzdGVuZXI+fVxuXHQgKi9cblx0X2xpc3RlbmVycyA9ICdXZWFrTWFwJyBpbiBnbG9iYWxzID8gbmV3IFdlYWtNYXAoKSA6IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHR5cGUge1Jlc2l6ZU9ic2VydmVyfVxuXHQgKi9cblx0X29ic2VydmVyID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7UmVzaXplT2JzZXJ2ZXJPcHRpb25zfSAqL1xuXHRvcHRpb25zO1xuXG5cdC8qKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyT3B0aW9uc30gb3B0aW9ucyAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcblx0ICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkxpc3RlbmVyfSBsaXN0ZW5lclxuXHQgKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cblx0ICovXG5cdG9ic2VydmUoZWxlbWVudCwgbGlzdGVuZXIpIHtcblx0XHR0aGlzLl9saXN0ZW5lcnMuc2V0KGVsZW1lbnQsIGxpc3RlbmVyKTtcblx0XHR0aGlzLl9nZXRPYnNlcnZlcigpLm9ic2VydmUoZWxlbWVudCwgdGhpcy5vcHRpb25zKTtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0dGhpcy5fbGlzdGVuZXJzLmRlbGV0ZShlbGVtZW50KTtcblx0XHRcdHRoaXMuX29ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTsgLy8gdGhpcyBsaW5lIGNhbiBwcm9iYWJseSBiZSByZW1vdmVkXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldE9ic2VydmVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLl9vYnNlcnZlciA/P1xuXHRcdFx0KHRoaXMuX29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG5cdFx0XHRcdGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuXHRcdFx0XHRcdFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmVudHJpZXMuc2V0KGVudHJ5LnRhcmdldCwgZW50cnkpO1xuXHRcdFx0XHRcdHRoaXMuX2xpc3RlbmVycy5nZXQoZW50cnkudGFyZ2V0KT8uKGVudHJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSkpXG5cdFx0KTtcblx0fVxufVxuXG4vLyBOZWVkcyB0byBiZSB3cml0dGVuIGxpa2UgdGhpcyB0byBwYXNzIHRoZSB0cmVlLXNoYWtlLXRlc3RcblJlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmVudHJpZXMgPSAnV2Vha01hcCcgaW4gZ2xvYmFscyA/IG5ldyBXZWFrTWFwKCkgOiB1bmRlZmluZWQ7XG4iLCAiaW1wb3J0IHsgY29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMsIGhhc19wcm9wIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmltcG9ydCB7IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZlclNpbmdsZXRvbi5qcyc7XG5cbi8vIFRyYWNrIHdoaWNoIG5vZGVzIGFyZSBjbGFpbWVkIGR1cmluZyBoeWRyYXRpb24uIFVuY2xhaW1lZCBub2RlcyBjYW4gdGhlbiBiZSByZW1vdmVkIGZyb20gdGhlIERPTVxuLy8gYXQgdGhlIGVuZCBvZiBoeWRyYXRpb24gd2l0aG91dCB0b3VjaGluZyB0aGUgcmVtYWluaW5nIG5vZGVzLlxubGV0IGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRfaHlkcmF0aW5nKCkge1xuXHRpc19oeWRyYXRpbmcgPSB0cnVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5kX2h5ZHJhdGluZygpIHtcblx0aXNfaHlkcmF0aW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGxvd1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hcbiAqIEBwYXJhbSB7KGluZGV4OiBudW1iZXIpID0+IG51bWJlcn0ga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHVwcGVyX2JvdW5kKGxvdywgaGlnaCwga2V5LCB2YWx1ZSkge1xuXHQvLyBSZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUgbGFyZ2VyIHRoYW4gaW5wdXQgdmFsdWUgaW4gdGhlIHJhbmdlIFtsb3csIGhpZ2gpXG5cdHdoaWxlIChsb3cgPCBoaWdoKSB7XG5cdFx0Y29uc3QgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSA+PiAxKTtcblx0XHRpZiAoa2V5KG1pZCkgPD0gdmFsdWUpIHtcblx0XHRcdGxvdyA9IG1pZCArIDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhpZ2ggPSBtaWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBsb3c7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlRXh9IHRhcmdldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGluaXRfaHlkcmF0ZSh0YXJnZXQpIHtcblx0aWYgKHRhcmdldC5oeWRyYXRlX2luaXQpIHJldHVybjtcblx0dGFyZ2V0Lmh5ZHJhdGVfaW5pdCA9IHRydWU7XG5cdC8vIFdlIGtub3cgdGhhdCBhbGwgY2hpbGRyZW4gaGF2ZSBjbGFpbV9vcmRlciB2YWx1ZXMgc2luY2UgdGhlIHVuY2xhaW1lZCBoYXZlIGJlZW4gZGV0YWNoZWQgaWYgdGFyZ2V0IGlzIG5vdCA8aGVhZD5cblxuXHRsZXQgY2hpbGRyZW4gPSAvKiogQHR5cGUge0FycmF5TGlrZTxOb2RlRXgyPn0gKi8gKHRhcmdldC5jaGlsZE5vZGVzKTtcblx0Ly8gSWYgdGFyZ2V0IGlzIDxoZWFkPiwgdGhlcmUgbWF5IGJlIGNoaWxkcmVuIHdpdGhvdXQgY2xhaW1fb3JkZXJcblx0aWYgKHRhcmdldC5ub2RlTmFtZSA9PT0gJ0hFQUQnKSB7XG5cdFx0Y29uc3QgbXlfY2hpbGRyZW4gPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBub2RlID0gY2hpbGRyZW5baV07XG5cdFx0XHRpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG15X2NoaWxkcmVuLnB1c2gobm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNoaWxkcmVuID0gbXlfY2hpbGRyZW47XG5cdH1cblx0Lypcblx0ICogUmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseS5cblx0ICogV2UgY2FuIHJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkgYnkgZmluZGluZyB0aGUgbG9uZ2VzdCBzdWJzZXF1ZW5jZSBvZlxuXHQgKiBub2RlcyB0aGF0IGFyZSBhbHJlYWR5IGNsYWltZWQgaW4gb3JkZXIgYW5kIG9ubHkgbW92aW5nIHRoZSByZXN0LiBUaGUgbG9uZ2VzdFxuXHQgKiBzdWJzZXF1ZW5jZSBvZiBub2RlcyB0aGF0IGFyZSBjbGFpbWVkIGluIG9yZGVyIGNhbiBiZSBmb3VuZCBieVxuXHQgKiBjb21wdXRpbmcgdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiAuY2xhaW1fb3JkZXIgdmFsdWVzLlxuXHQgKlxuXHQgKiBUaGlzIGFsZ29yaXRobSBpcyBvcHRpbWFsIGluIGdlbmVyYXRpbmcgdGhlIGxlYXN0IGFtb3VudCBvZiByZW9yZGVyIG9wZXJhdGlvbnNcblx0ICogcG9zc2libGUuXG5cdCAqXG5cdCAqIFByb29mOlxuXHQgKiBXZSBrbm93IHRoYXQsIGdpdmVuIGEgc2V0IG9mIHJlb3JkZXJpbmcgb3BlcmF0aW9ucywgdGhlIG5vZGVzIHRoYXQgZG8gbm90IG1vdmVcblx0ICogYWx3YXlzIGZvcm0gYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSwgc2luY2UgdGhleSBkbyBub3QgbW92ZSBhbW9uZyBlYWNoIG90aGVyXG5cdCAqIG1lYW5pbmcgdGhhdCB0aGV5IG11c3QgYmUgYWxyZWFkeSBvcmRlcmVkIGFtb25nIGVhY2ggb3RoZXIuIFRodXMsIHRoZSBtYXhpbWFsXG5cdCAqIHNldCBvZiBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlIGZvcm0gYSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UuXG5cdCAqL1xuXHQvLyBDb21wdXRlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuXHQvLyBtOiBzdWJzZXF1ZW5jZSBsZW5ndGggaiA9PiBpbmRleCBrIG9mIHNtYWxsZXN0IHZhbHVlIHRoYXQgZW5kcyBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGxlbmd0aCBqXG5cdGNvbnN0IG0gPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGggKyAxKTtcblx0Ly8gUHJlZGVjZXNzb3IgaW5kaWNlcyArIDFcblx0Y29uc3QgcCA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCk7XG5cdG1bMF0gPSAtMTtcblx0bGV0IGxvbmdlc3QgPSAwO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgY3VycmVudCA9IGNoaWxkcmVuW2ldLmNsYWltX29yZGVyO1xuXHRcdC8vIEZpbmQgdGhlIGxhcmdlc3Qgc3Vic2VxdWVuY2UgbGVuZ3RoIHN1Y2ggdGhhdCBpdCBlbmRzIGluIGEgdmFsdWUgbGVzcyB0aGFuIG91ciBjdXJyZW50IHZhbHVlXG5cdFx0Ly8gdXBwZXJfYm91bmQgcmV0dXJucyBmaXJzdCBncmVhdGVyIHZhbHVlLCBzbyB3ZSBzdWJ0cmFjdCBvbmVcblx0XHQvLyB3aXRoIGZhc3QgcGF0aCBmb3Igd2hlbiB3ZSBhcmUgb24gdGhlIGN1cnJlbnQgbG9uZ2VzdCBzdWJzZXF1ZW5jZVxuXHRcdGNvbnN0IHNlcV9sZW4gPVxuXHRcdFx0KGxvbmdlc3QgPiAwICYmIGNoaWxkcmVuW21bbG9uZ2VzdF1dLmNsYWltX29yZGVyIDw9IGN1cnJlbnRcblx0XHRcdFx0PyBsb25nZXN0ICsgMVxuXHRcdFx0XHQ6IHVwcGVyX2JvdW5kKDEsIGxvbmdlc3QsIChpZHgpID0+IGNoaWxkcmVuW21baWR4XV0uY2xhaW1fb3JkZXIsIGN1cnJlbnQpKSAtIDE7XG5cdFx0cFtpXSA9IG1bc2VxX2xlbl0gKyAxO1xuXHRcdGNvbnN0IG5ld19sZW4gPSBzZXFfbGVuICsgMTtcblx0XHQvLyBXZSBjYW4gZ3VhcmFudGVlIHRoYXQgY3VycmVudCBpcyB0aGUgc21hbGxlc3QgdmFsdWUuIE90aGVyd2lzZSwgd2Ugd291bGQgaGF2ZSBnZW5lcmF0ZWQgYSBsb25nZXIgc2VxdWVuY2UuXG5cdFx0bVtuZXdfbGVuXSA9IGk7XG5cdFx0bG9uZ2VzdCA9IE1hdGgubWF4KG5ld19sZW4sIGxvbmdlc3QpO1xuXHR9XG5cdC8vIFRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgKGluaXRpYWxseSByZXZlcnNlZClcblxuXHQvKipcblx0ICogQHR5cGUge05vZGVFeDJbXX1cblx0ICovXG5cdGNvbnN0IGxpcyA9IFtdO1xuXHQvLyBUaGUgcmVzdCBvZiB0aGUgbm9kZXMsIG5vZGVzIHRoYXQgd2lsbCBiZSBtb3ZlZFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7Tm9kZUV4MltdfVxuXHQgKi9cblx0Y29uc3QgdG9fbW92ZSA9IFtdO1xuXHRsZXQgbGFzdCA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG5cdGZvciAobGV0IGN1ciA9IG1bbG9uZ2VzdF0gKyAxOyBjdXIgIT0gMDsgY3VyID0gcFtjdXIgLSAxXSkge1xuXHRcdGxpcy5wdXNoKGNoaWxkcmVuW2N1ciAtIDFdKTtcblx0XHRmb3IgKDsgbGFzdCA+PSBjdXI7IGxhc3QtLSkge1xuXHRcdFx0dG9fbW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcblx0XHR9XG5cdFx0bGFzdC0tO1xuXHR9XG5cdGZvciAoOyBsYXN0ID49IDA7IGxhc3QtLSkge1xuXHRcdHRvX21vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG5cdH1cblx0bGlzLnJldmVyc2UoKTtcblx0Ly8gV2Ugc29ydCB0aGUgbm9kZXMgYmVpbmcgbW92ZWQgdG8gZ3VhcmFudGVlIHRoYXQgdGhlaXIgaW5zZXJ0aW9uIG9yZGVyIG1hdGNoZXMgdGhlIGNsYWltIG9yZGVyXG5cdHRvX21vdmUuc29ydCgoYSwgYikgPT4gYS5jbGFpbV9vcmRlciAtIGIuY2xhaW1fb3JkZXIpO1xuXHQvLyBGaW5hbGx5LCB3ZSBtb3ZlIHRoZSBub2Rlc1xuXHRmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB0b19tb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0d2hpbGUgKGogPCBsaXMubGVuZ3RoICYmIHRvX21vdmVbaV0uY2xhaW1fb3JkZXIgPj0gbGlzW2pdLmNsYWltX29yZGVyKSB7XG5cdFx0XHRqKys7XG5cdFx0fVxuXHRcdGNvbnN0IGFuY2hvciA9IGogPCBsaXMubGVuZ3RoID8gbGlzW2pdIDogbnVsbDtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRvX21vdmVbaV0sIGFuY2hvcik7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZCh0YXJnZXQsIG5vZGUpIHtcblx0dGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVfc2hlZXRfaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kX3N0eWxlcyh0YXJnZXQsIHN0eWxlX3NoZWV0X2lkLCBzdHlsZXMpIHtcblx0Y29uc3QgYXBwZW5kX3N0eWxlc190byA9IGdldF9yb290X2Zvcl9zdHlsZSh0YXJnZXQpO1xuXHRpZiAoIWFwcGVuZF9zdHlsZXNfdG8uZ2V0RWxlbWVudEJ5SWQoc3R5bGVfc2hlZXRfaWQpKSB7XG5cdFx0Y29uc3Qgc3R5bGUgPSBlbGVtZW50KCdzdHlsZScpO1xuXHRcdHN0eWxlLmlkID0gc3R5bGVfc2hlZXRfaWQ7XG5cdFx0c3R5bGUudGV4dENvbnRlbnQgPSBzdHlsZXM7XG5cdFx0YXBwZW5kX3N0eWxlc2hlZXQoYXBwZW5kX3N0eWxlc190bywgc3R5bGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7U2hhZG93Um9vdCB8IERvY3VtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpIHtcblx0aWYgKCFub2RlKSByZXR1cm4gZG9jdW1lbnQ7XG5cdGNvbnN0IHJvb3QgPSBub2RlLmdldFJvb3ROb2RlID8gbm9kZS5nZXRSb290Tm9kZSgpIDogbm9kZS5vd25lckRvY3VtZW50O1xuXHRpZiAocm9vdCAmJiAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovIChyb290KS5ob3N0KSB7XG5cdFx0cmV0dXJuIC8qKiBAdHlwZSB7U2hhZG93Um9vdH0gKi8gKHJvb3QpO1xuXHR9XG5cdHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7Q1NTU3R5bGVTaGVldH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0KG5vZGUpIHtcblx0Y29uc3Qgc3R5bGVfZWxlbWVudCA9IGVsZW1lbnQoJ3N0eWxlJyk7XG5cdC8vIEZvciB0cmFuc2l0aW9ucyB0byB3b3JrIHdpdGhvdXQgJ3N0eWxlLXNyYzogdW5zYWZlLWlubGluZScgQ29udGVudCBTZWN1cml0eSBQb2xpY3ksXG5cdC8vIHRoZXNlIGVtcHR5IHRhZ3MgbmVlZCB0byBiZSBhbGxvd2VkIHdpdGggYSBoYXNoIGFzIGEgd29ya2Fyb3VuZCB1bnRpbCB3ZSBtb3ZlIHRvIHRoZSBXZWIgQW5pbWF0aW9ucyBBUEkuXG5cdC8vIFVzaW5nIHRoZSBoYXNoIGZvciB0aGUgZW1wdHkgc3RyaW5nIChmb3IgYW4gZW1wdHkgdGFnKSB3b3JrcyBpbiBhbGwgYnJvd3NlcnMgZXhjZXB0IFNhZmFyaS5cblx0Ly8gU28gYXMgYSB3b3JrYXJvdW5kIGZvciB0aGUgd29ya2Fyb3VuZCwgd2hlbiB3ZSBhcHBlbmQgZW1wdHkgc3R5bGUgdGFncyB3ZSBzZXQgdGhlaXIgY29udGVudCB0byAvKiBlbXB0eSAqLy5cblx0Ly8gVGhlIGhhc2ggJ3NoYTI1Ni05T2xOTzBETkVlYVZ6SEw0Ulp3Q0xzQkhBOFdCUTh0b0JwLzRGNVhWMm5jPScgd2lsbCB0aGVuIHdvcmsgZXZlbiBpbiBTYWZhcmkuXG5cdHN0eWxlX2VsZW1lbnQudGV4dENvbnRlbnQgPSAnLyogZW1wdHkgKi8nO1xuXHRhcHBlbmRfc3R5bGVzaGVldChnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSksIHN0eWxlX2VsZW1lbnQpO1xuXHRyZXR1cm4gc3R5bGVfZWxlbWVudC5zaGVldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NoYWRvd1Jvb3QgfCBEb2N1bWVudH0gbm9kZVxuICogQHBhcmFtIHtIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICogQHJldHVybnMge0NTU1N0eWxlU2hlZXR9XG4gKi9cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXNoZWV0KG5vZGUsIHN0eWxlKSB7XG5cdGFwcGVuZCgvKiogQHR5cGUge0RvY3VtZW50fSAqLyAobm9kZSkuaGVhZCB8fCBub2RlLCBzdHlsZSk7XG5cdHJldHVybiBzdHlsZS5zaGVldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGVFeH0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGVFeH0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSkge1xuXHRpZiAoaXNfaHlkcmF0aW5nKSB7XG5cdFx0aW5pdF9oeWRyYXRlKHRhcmdldCk7XG5cdFx0aWYgKFxuXHRcdFx0dGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0KHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsICYmIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLnBhcmVudE5vZGUgIT09IHRhcmdldClcblx0XHQpIHtcblx0XHRcdHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmZpcnN0Q2hpbGQ7XG5cdFx0fVxuXHRcdC8vIFNraXAgbm9kZXMgb2YgdW5kZWZpbmVkIG9yZGVyaW5nXG5cdFx0d2hpbGUgKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsICYmIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLmNsYWltX29yZGVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHRcdGlmIChub2RlICE9PSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCkge1xuXHRcdFx0Ly8gV2Ugb25seSBpbnNlcnQgaWYgdGhlIG9yZGVyaW5nIG9mIHRoaXMgbm9kZSBzaG91bGQgYmUgbW9kaWZpZWQgb3IgdGhlIHBhcmVudCBub2RlIGlzIG5vdCB0YXJnZXRcblx0XHRcdGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQgfHwgbm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQpIHtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gbm9kZS5uZXh0U2libGluZztcblx0XHR9XG5cdH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQgfHwgbm9kZS5uZXh0U2libGluZyAhPT0gbnVsbCkge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gW2FuY2hvcl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG5cdHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZUV4fSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZUV4fSBub2RlXG4gKiBAcGFyYW0ge05vZGVFeH0gW2FuY2hvcl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuXHRpZiAoaXNfaHlkcmF0aW5nICYmICFhbmNob3IpIHtcblx0XHRhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG5cdH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQgfHwgbm9kZS5uZXh0U2libGluZyAhPSBhbmNob3IpIHtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRhY2gobm9kZSkge1xuXHRpZiAobm9kZS5wYXJlbnROb2RlKSB7XG5cdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9lYWNoKGl0ZXJhdGlvbnMsIGRldGFjaGluZykge1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoaXRlcmF0aW9uc1tpXSkgaXRlcmF0aW9uc1tpXS5kKGRldGFjaGluZyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gS1xuICogQHBhcmFtIHtLfSBuYW1lXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRUYWdOYW1lTWFwW0tdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudChuYW1lKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwfSBLXG4gKiBAcGFyYW0ge0t9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpc1xuICogQHJldHVybnMge0hUTUxFbGVtZW50VGFnTmFtZU1hcFtLXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRfaXMobmFtZSwgaXMpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSwgeyBpcyB9KTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIHtrZXlvZiBUfSBLXG4gKiBAcGFyYW0ge1R9IG9ialxuICogQHBhcmFtIHtLW119IGV4Y2x1ZGVcbiAqIEByZXR1cm5zIHtQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcyhvYmosIGV4Y2x1ZGUpIHtcblx0Y29uc3QgdGFyZ2V0ID0gLyoqIEB0eXBlIHtQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+fSAqLyAoe30pO1xuXHRmb3IgKGNvbnN0IGsgaW4gb2JqKSB7XG5cdFx0aWYgKFxuXHRcdFx0aGFzX3Byb3Aob2JqLCBrKSAmJlxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0ZXhjbHVkZS5pbmRleE9mKGspID09PSAtMVxuXHRcdCkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0dGFyZ2V0W2tdID0gb2JqW2tdO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgU1ZHRWxlbWVudFRhZ05hbWVNYXB9IEtcbiAqIEBwYXJhbSB7S30gbmFtZVxuICogQHJldHVybnMge1NWR0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdmdfZWxlbWVudChuYW1lKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAqIEByZXR1cm5zIHtUZXh0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGV4dChkYXRhKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7VGV4dH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGFjZSgpIHtcblx0cmV0dXJuIHRleHQoJyAnKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7VGV4dH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eSgpIHtcblx0cmV0dXJuIHRleHQoJycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcmV0dXJucyB7Q29tbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1lbnQoY29udGVudCkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChjb250ZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdH0gaGFuZGxlclxuICogQHBhcmFtIHtib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMgfCBFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuXHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuXHRyZXR1cm4gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IGFueX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50X2RlZmF1bHQoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IGFueX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wX3Byb3BhZ2F0aW9uKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gYW55fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gdm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxmKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0aWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcykgZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiB2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRydXN0ZWQoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRpZiAoZXZlbnQuaXNUcnVzdGVkKSBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHRpZiAodmFsdWUgPT0gbnVsbCkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcblx0ZWxzZSBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKSAhPT0gdmFsdWUpIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuLyoqXG4gKiBMaXN0IG9mIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYWx3YXlzIGJlIHNldCB0aHJvdWdoIHRoZSBhdHRyIG1ldGhvZCxcbiAqIGJlY2F1c2UgdXBkYXRpbmcgdGhlbSB0aHJvdWdoIHRoZSBwcm9wZXJ0eSBzZXR0ZXIgZG9lc24ndCB3b3JrIHJlbGlhYmx5LlxuICogSW4gdGhlIGV4YW1wbGUgb2YgYHdpZHRoYC9gaGVpZ2h0YCwgdGhlIHByb2JsZW0gaXMgdGhhdCB0aGUgc2V0dGVyIG9ubHlcbiAqIGFjY2VwdHMgbnVtZXJpYyB2YWx1ZXMsIGJ1dCB0aGUgYXR0cmlidXRlIGNhbiBhbHNvIGJlIHNldCB0byBhIHN0cmluZyBsaWtlIGA1MCVgLlxuICogSWYgdGhpcyBsaXN0IGJlY29tZXMgdG9vIGJpZywgcmV0aGluayB0aGlzIGFwcHJvYWNoLlxuICovXG5jb25zdCBhbHdheXNfc2V0X3Rocm91Z2hfc2V0X2F0dHJpYnV0ZSA9IFsnd2lkdGgnLCAnaGVpZ2h0J107XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge3sgW3g6IHN0cmluZ106IHN0cmluZyB9fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG5vZGUuX19wcm90b19fKTtcblx0Zm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdGlmIChhdHRyaWJ1dGVzW2tleV0gPT0gbnVsbCkge1xuXHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuXHRcdFx0bm9kZS5zdHlsZS5jc3NUZXh0ID0gYXR0cmlidXRlc1trZXldO1xuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnX192YWx1ZScpIHtcblx0XHRcdC8qKiBAdHlwZSB7YW55fSAqLyAobm9kZSkudmFsdWUgPSBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdGRlc2NyaXB0b3JzW2tleV0gJiZcblx0XHRcdGRlc2NyaXB0b3JzW2tleV0uc2V0ICYmXG5cdFx0XHRhbHdheXNfc2V0X3Rocm91Z2hfc2V0X2F0dHJpYnV0ZS5pbmRleE9mKGtleSkgPT09IC0xXG5cdFx0KSB7XG5cdFx0XHRub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHt7IFt4OiBzdHJpbmddOiBzdHJpbmcgfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc3ZnX2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuXHRmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0YXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBkYXRhX21hcFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YV9tYXAobm9kZSwgZGF0YV9tYXApIHtcblx0T2JqZWN0LmtleXMoZGF0YV9tYXApLmZvckVhY2goKGtleSkgPT4ge1xuXHRcdHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIGtleSwgZGF0YV9tYXBba2V5XSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIHByb3AsIHZhbHVlKSB7XG5cdGNvbnN0IGxvd2VyID0gcHJvcC50b0xvd2VyQ2FzZSgpOyAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBiZWhhdmlvciB3ZSBkbyBsb3dlcmNhc2UgZmlyc3Rcblx0aWYgKGxvd2VyIGluIG5vZGUpIHtcblx0XHRub2RlW2xvd2VyXSA9IHR5cGVvZiBub2RlW2xvd2VyXSA9PT0gJ2Jvb2xlYW4nICYmIHZhbHVlID09PSAnJyA/IHRydWUgOiB2YWx1ZTtcblx0fSBlbHNlIGlmIChwcm9wIGluIG5vZGUpIHtcblx0XHRub2RlW3Byb3BdID0gdHlwZW9mIG5vZGVbcHJvcF0gPT09ICdib29sZWFuJyAmJiB2YWx1ZSA9PT0gJycgPyB0cnVlIDogdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0YXR0cihub2RlLCBwcm9wLCB2YWx1ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZHluYW1pY19lbGVtZW50X2RhdGEodGFnKSB7XG5cdHJldHVybiAvLS8udGVzdCh0YWcpID8gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGFfbWFwIDogc2V0X2F0dHJpYnV0ZXM7XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB4bGlua19hdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0bm9kZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfc3ZlbHRlX2RhdGFzZXQobm9kZSkge1xuXHRyZXR1cm4gbm9kZS5kYXRhc2V0LnN2ZWx0ZUg7XG59XG5cbi8qKlxuICogQHJldHVybnMge3Vua25vd25bXX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cF92YWx1ZShncm91cCwgX192YWx1ZSwgY2hlY2tlZCkge1xuXHRjb25zdCB2YWx1ZSA9IG5ldyBTZXQoKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChncm91cFtpXS5jaGVja2VkKSB2YWx1ZS5hZGQoZ3JvdXBbaV0uX192YWx1ZSk7XG5cdH1cblx0aWYgKCFjaGVja2VkKSB7XG5cdFx0dmFsdWUuZGVsZXRlKF9fdmFsdWUpO1xuXHR9XG5cdHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnRbXX0gZ3JvdXBcbiAqIEByZXR1cm5zIHt7IHAoLi4uaW5wdXRzOiBIVE1MSW5wdXRFbGVtZW50W10pOiB2b2lkOyByKCk6IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50W119ICovXG5cdGxldCBfaW5wdXRzO1xuXHRyZXR1cm4ge1xuXHRcdC8qIHB1c2ggKi8gcCguLi5pbnB1dHMpIHtcblx0XHRcdF9pbnB1dHMgPSBpbnB1dHM7XG5cdFx0XHRfaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBncm91cC5wdXNoKGlucHV0KSk7XG5cdFx0fSxcblx0XHQvKiByZW1vdmUgKi8gcigpIHtcblx0XHRcdF9pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IGdyb3VwLnNwbGljZShncm91cC5pbmRleE9mKGlucHV0KSwgMSkpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzXG4gKiBAcmV0dXJucyB7eyB1KG5ld19pbmRleGVzOiBudW1iZXJbXSk6IHZvaWQ7IHAoLi4uaW5wdXRzOiBIVE1MSW5wdXRFbGVtZW50W10pOiB2b2lkOyByOiAoKSA9PiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9iaW5kaW5nX2dyb3VwX2R5bmFtaWMoZ3JvdXAsIGluZGV4ZXMpIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50W119ICovXG5cdGxldCBfZ3JvdXAgPSBnZXRfYmluZGluZ19ncm91cChncm91cCk7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50W119ICovXG5cdGxldCBfaW5wdXRzO1xuXG5cdGZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwKGdyb3VwKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRncm91cCA9IGdyb3VwW2luZGV4ZXNbaV1dID0gZ3JvdXBbaW5kZXhlc1tpXV0gfHwgW107XG5cdFx0fVxuXHRcdHJldHVybiBncm91cDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gcHVzaCgpIHtcblx0XHRfaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBfZ3JvdXAucHVzaChpbnB1dCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiByZW1vdmUoKSB7XG5cdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gX2dyb3VwLnNwbGljZShfZ3JvdXAuaW5kZXhPZihpbnB1dCksIDEpKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdC8qIHVwZGF0ZSAqLyB1KG5ld19pbmRleGVzKSB7XG5cdFx0XHRpbmRleGVzID0gbmV3X2luZGV4ZXM7XG5cdFx0XHRjb25zdCBuZXdfZ3JvdXAgPSBnZXRfYmluZGluZ19ncm91cChncm91cCk7XG5cdFx0XHRpZiAobmV3X2dyb3VwICE9PSBfZ3JvdXApIHtcblx0XHRcdFx0cmVtb3ZlKCk7XG5cdFx0XHRcdF9ncm91cCA9IG5ld19ncm91cDtcblx0XHRcdFx0cHVzaCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyogcHVzaCAqLyBwKC4uLmlucHV0cykge1xuXHRcdFx0X2lucHV0cyA9IGlucHV0cztcblx0XHRcdHB1c2goKTtcblx0XHR9LFxuXHRcdC8qIHJlbW92ZSAqLyByOiByZW1vdmVcblx0fTtcbn1cblxuLyoqIEByZXR1cm5zIHtudW1iZXJ9ICovXG5leHBvcnQgZnVuY3Rpb24gdG9fbnVtYmVyKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSA9PT0gJycgPyBudWxsIDogK3ZhbHVlO1xufVxuXG4vKiogQHJldHVybnMge2FueVtdfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVfcmFuZ2VzX3RvX2FycmF5KHJhbmdlcykge1xuXHRjb25zdCBhcnJheSA9IFtdO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGFycmF5LnB1c2goeyBzdGFydDogcmFuZ2VzLnN0YXJ0KGkpLCBlbmQ6IHJhbmdlcy5lbmQoaSkgfSk7XG5cdH1cblx0cmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0NoaWxkTm9kZVtdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCkge1xuXHRyZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gaW5pdF9jbGFpbV9pbmZvKG5vZGVzKSB7XG5cdGlmIChub2Rlcy5jbGFpbV9pbmZvID09PSB1bmRlZmluZWQpIHtcblx0XHRub2Rlcy5jbGFpbV9pbmZvID0geyBsYXN0X2luZGV4OiAwLCB0b3RhbF9jbGFpbWVkOiAwIH07XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge0NoaWxkTm9kZUV4fSBSXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHBhcmFtIHsobm9kZTogQ2hpbGROb2RlRXgpID0+IG5vZGUgaXMgUn0gcHJlZGljYXRlXG4gKiBAcGFyYW0geyhub2RlOiBDaGlsZE5vZGVFeCkgPT4gQ2hpbGROb2RlRXggfCB1bmRlZmluZWR9IHByb2Nlc3Nfbm9kZVxuICogQHBhcmFtIHsoKSA9PiBSfSBjcmVhdGVfbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBkb250X3VwZGF0ZV9sYXN0X2luZGV4XG4gKiBAcmV0dXJucyB7Un1cbiAqL1xuZnVuY3Rpb24gY2xhaW1fbm9kZShub2RlcywgcHJlZGljYXRlLCBwcm9jZXNzX25vZGUsIGNyZWF0ZV9ub2RlLCBkb250X3VwZGF0ZV9sYXN0X2luZGV4ID0gZmFsc2UpIHtcblx0Ly8gVHJ5IHRvIGZpbmQgbm9kZXMgaW4gYW4gb3JkZXIgc3VjaCB0aGF0IHdlIGxlbmd0aGVuIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Vcblx0aW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcblx0Y29uc3QgcmVzdWx0X25vZGUgPSAoKCkgPT4ge1xuXHRcdC8vIFdlIGZpcnN0IHRyeSB0byBmaW5kIGFuIGVsZW1lbnQgYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZVxuXHRcdGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXg7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXHRcdFx0aWYgKHByZWRpY2F0ZShub2RlKSkge1xuXHRcdFx0XHRjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3Nfbm9kZShub2RlKTtcblx0XHRcdFx0aWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRub2Rlcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm9kZXNbaV0gPSByZXBsYWNlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWRvbnRfdXBkYXRlX2xhc3RfaW5kZXgpIHtcblx0XHRcdFx0XHRub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBPdGhlcndpc2UsIHdlIHRyeSB0byBmaW5kIG9uZSBiZWZvcmVcblx0XHQvLyBXZSBpdGVyYXRlIGluIHJldmVyc2Ugc28gdGhhdCB3ZSBkb24ndCBnbyB0b28gZmFyIGJhY2tcblx0XHRmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdGlmIChwcmVkaWNhdGUobm9kZSkpIHtcblx0XHRcdFx0Y29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzX25vZGUobm9kZSk7XG5cdFx0XHRcdGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0bm9kZXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFkb250X3VwZGF0ZV9sYXN0X2luZGV4KSB7XG5cdFx0XHRcdFx0bm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcblx0XHRcdFx0fSBlbHNlIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Ly8gU2luY2Ugd2Ugc3BsaWNlZCBiZWZvcmUgdGhlIGxhc3RfaW5kZXgsIHdlIGRlY3JlYXNlIGl0XG5cdFx0XHRcdFx0bm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIElmIHdlIGNhbid0IGZpbmQgYW55IG1hdGNoaW5nIG5vZGUsIHdlIGNyZWF0ZSBhIG5ldyBvbmVcblx0XHRyZXR1cm4gY3JlYXRlX25vZGUoKTtcblx0fSkoKTtcblx0cmVzdWx0X25vZGUuY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG5cdG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuXHRyZXR1cm4gcmVzdWx0X25vZGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3sgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9fSBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0geyhuYW1lOiBzdHJpbmcpID0+IEVsZW1lbnQgfCBTVkdFbGVtZW50fSBjcmVhdGVfZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnQgfCBTVkdFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGNyZWF0ZV9lbGVtZW50KSB7XG5cdHJldHVybiBjbGFpbV9ub2RlKFxuXHRcdG5vZGVzLFxuXHRcdC8qKiBAcmV0dXJucyB7bm9kZSBpcyBFbGVtZW50IHwgU1ZHRWxlbWVudH0gKi9cblx0XHQobm9kZSkgPT4gbm9kZS5ub2RlTmFtZSA9PT0gbmFtZSxcblx0XHQvKiogQHBhcmFtIHtFbGVtZW50fSBub2RlICovXG5cdFx0KG5vZGUpID0+IHtcblx0XHRcdGNvbnN0IHJlbW92ZSA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2pdO1xuXHRcdFx0XHRpZiAoIWF0dHJpYnV0ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG5cdFx0XHRcdFx0cmVtb3ZlLnB1c2goYXR0cmlidXRlLm5hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZW1vdmUuZm9yRWFjaCgodikgPT4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUodikpO1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9LFxuXHRcdCgpID0+IGNyZWF0ZV9lbGVtZW50KG5hbWUpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3sgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7RWxlbWVudCB8IFNWR0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG5cdHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge0VsZW1lbnQgfCBTVkdFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fc3ZnX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcblx0cmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgc3ZnX2VsZW1lbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcmV0dXJucyB7VGV4dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX3RleHQobm9kZXMsIGRhdGEpIHtcblx0cmV0dXJuIGNsYWltX25vZGUoXG5cdFx0bm9kZXMsXG5cdFx0LyoqIEByZXR1cm5zIHtub2RlIGlzIFRleHR9ICovXG5cdFx0KG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDMsXG5cdFx0LyoqIEBwYXJhbSB7VGV4dH0gbm9kZSAqL1xuXHRcdChub2RlKSA9PiB7XG5cdFx0XHRjb25zdCBkYXRhX3N0ciA9ICcnICsgZGF0YTtcblx0XHRcdGlmIChub2RlLmRhdGEuc3RhcnRzV2l0aChkYXRhX3N0cikpIHtcblx0XHRcdFx0aWYgKG5vZGUuZGF0YS5sZW5ndGggIT09IGRhdGFfc3RyLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlLnNwbGl0VGV4dChkYXRhX3N0ci5sZW5ndGgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLmRhdGEgPSBkYXRhX3N0cjtcblx0XHRcdH1cblx0XHR9LFxuXHRcdCgpID0+IHRleHQoZGF0YSksXG5cdFx0dHJ1ZSAvLyBUZXh0IG5vZGVzIHNob3VsZCBub3QgdXBkYXRlIGxhc3QgaW5kZXggc2luY2UgaXQgaXMgbGlrZWx5IG5vdCB3b3J0aCBpdCB0byBlbGltaW5hdGUgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBhY3R1YWwgZWxlbWVudHNcblx0KTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7VGV4dH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9zcGFjZShub2Rlcykge1xuXHRyZXR1cm4gY2xhaW1fdGV4dChub2RlcywgJyAnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHJldHVybnMge0NvbW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9jb21tZW50KG5vZGVzLCBkYXRhKSB7XG5cdHJldHVybiBjbGFpbV9ub2RlKFxuXHRcdG5vZGVzLFxuXHRcdC8qKiBAcmV0dXJucyB7bm9kZSBpcyBDb21tZW50fSAqL1xuXHRcdChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4LFxuXHRcdC8qKiBAcGFyYW0ge0NvbW1lbnR9IG5vZGUgKi9cblx0XHQobm9kZSkgPT4ge1xuXHRcdFx0bm9kZS5kYXRhID0gJycgKyBkYXRhO1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9LFxuXHRcdCgpID0+IGNvbW1lbnQoZGF0YSksXG5cdFx0dHJ1ZVxuXHQpO1xufVxuXG5mdW5jdGlvbiBnZXRfY29tbWVudF9pZHgobm9kZXMsIHRleHQsIHN0YXJ0KSB7XG5cdGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0Y29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXHRcdGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLyAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSA9PT0gdGV4dCkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzX3N2Z1xuICogQHJldHVybnMge0h0bWxUYWdIeWRyYXRpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9odG1sX3RhZyhub2RlcywgaXNfc3ZnKSB7XG5cdC8vIGZpbmQgaHRtbCBvcGVuaW5nIHRhZ1xuXHRjb25zdCBzdGFydF9pbmRleCA9IGdldF9jb21tZW50X2lkeChub2RlcywgJ0hUTUxfVEFHX1NUQVJUJywgMCk7XG5cdGNvbnN0IGVuZF9pbmRleCA9IGdldF9jb21tZW50X2lkeChub2RlcywgJ0hUTUxfVEFHX0VORCcsIHN0YXJ0X2luZGV4ICsgMSk7XG5cdGlmIChzdGFydF9pbmRleCA9PT0gLTEgfHwgZW5kX2luZGV4ID09PSAtMSkge1xuXHRcdHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihpc19zdmcpO1xuXHR9XG5cblx0aW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcblx0Y29uc3QgaHRtbF90YWdfbm9kZXMgPSBub2Rlcy5zcGxpY2Uoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSk7XG5cdGRldGFjaChodG1sX3RhZ19ub2Rlc1swXSk7XG5cdGRldGFjaChodG1sX3RhZ19ub2Rlc1todG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxXSk7XG5cdGNvbnN0IGNsYWltZWRfbm9kZXMgPSBodG1sX3RhZ19ub2Rlcy5zbGljZSgxLCBodG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxKTtcblx0aWYgKGNsYWltZWRfbm9kZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKGlzX3N2Zyk7XG5cdH1cblx0Zm9yIChjb25zdCBuIG9mIGNsYWltZWRfbm9kZXMpIHtcblx0XHRuLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuXHRcdG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuXHR9XG5cdHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihpc19zdmcsIGNsYWltZWRfbm9kZXMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhKHRleHQsIGRhdGEpIHtcblx0ZGF0YSA9ICcnICsgZGF0YTtcblx0aWYgKHRleHQuZGF0YSA9PT0gZGF0YSkgcmV0dXJuO1xuXHR0ZXh0LmRhdGEgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGRhdGEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhKSB7XG5cdGRhdGEgPSAnJyArIGRhdGE7XG5cdGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSkgcmV0dXJuO1xuXHR0ZXh0LmRhdGEgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGRhdGEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICogQHBhcmFtIHt1bmtub3dufSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cl92YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSwgYXR0cl92YWx1ZSkge1xuXHRpZiAofmNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzLmluZGV4T2YoYXR0cl92YWx1ZSkpIHtcblx0XHRzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSk7XG5cdH0gZWxzZSB7XG5cdFx0c2V0X2RhdGEodGV4dCwgZGF0YSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaW5wdXRfdmFsdWUoaW5wdXQsIHZhbHVlKSB7XG5cdGlucHV0LnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2lucHV0X3R5cGUoaW5wdXQsIHR5cGUpIHtcblx0dHJ5IHtcblx0XHRpbnB1dC50eXBlID0gdHlwZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIGRvIG5vdGhpbmdcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zdHlsZShub2RlLCBrZXksIHZhbHVlLCBpbXBvcnRhbnQpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG5cdH0gZWxzZSB7XG5cdFx0bm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlLCBpbXBvcnRhbnQgPyAnaW1wb3J0YW50JyA6ICcnKTtcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSwgbW91bnRpbmcpIHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuXHRcdGlmIChvcHRpb24uX192YWx1ZSA9PT0gdmFsdWUpIHtcblx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cdGlmICghbW91bnRpbmcgfHwgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gLTE7IC8vIG5vIG9wdGlvbiBzaG91bGQgYmUgc2VsZWN0ZWRcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9vcHRpb25zKHNlbGVjdCwgdmFsdWUpIHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuXHRcdG9wdGlvbi5zZWxlY3RlZCA9IH52YWx1ZS5pbmRleE9mKG9wdGlvbi5fX3ZhbHVlKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X3ZhbHVlKHNlbGVjdCkge1xuXHRjb25zdCBzZWxlY3RlZF9vcHRpb24gPSBzZWxlY3QucXVlcnlTZWxlY3RvcignOmNoZWNrZWQnKTtcblx0cmV0dXJuIHNlbGVjdGVkX29wdGlvbiAmJiBzZWxlY3RlZF9vcHRpb24uX192YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV92YWx1ZShzZWxlY3QpIHtcblx0cmV0dXJuIFtdLm1hcC5jYWxsKHNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKCc6Y2hlY2tlZCcpLCAob3B0aW9uKSA9PiBvcHRpb24uX192YWx1ZSk7XG59XG4vLyB1bmZvcnR1bmF0ZWx5IHRoaXMgY2FuJ3QgYmUgYSBjb25zdGFudCBhcyB0aGF0IHdvdWxkbid0IGJlIHRyZWUtc2hha2VhYmxlXG4vLyBzbyB3ZSBjYWNoZSB0aGUgcmVzdWx0IGluc3RlYWRcblxuLyoqXG4gKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbmxldCBjcm9zc29yaWdpbjtcblxuLyoqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19jcm9zc29yaWdpbigpIHtcblx0aWYgKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQpIHtcblx0XHRjcm9zc29yaWdpbiA9IGZhbHNlO1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBhcmVudCkge1xuXHRcdFx0XHR2b2lkIHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNyb3Nzb3JpZ2luID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGNyb3Nzb3JpZ2luO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2lmcmFtZV9yZXNpemVfbGlzdGVuZXIobm9kZSwgZm4pIHtcblx0Y29uc3QgY29tcHV0ZWRfc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRpZiAoY29tcHV0ZWRfc3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG5cdFx0bm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cdH1cblx0Y29uc3QgaWZyYW1lID0gZWxlbWVudCgnaWZyYW1lJyk7XG5cdGlmcmFtZS5zZXRBdHRyaWJ1dGUoXG5cdFx0J3N0eWxlJyxcblx0XHQnZGlzcGxheTogYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyAnICtcblx0XHRcdCdvdmVyZmxvdzogaGlkZGVuOyBib3JkZXI6IDA7IG9wYWNpdHk6IDA7IHBvaW50ZXItZXZlbnRzOiBub25lOyB6LWluZGV4OiAtMTsnXG5cdCk7XG5cdGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblx0aWZyYW1lLnRhYkluZGV4ID0gLTE7XG5cdGNvbnN0IGNyb3Nzb3JpZ2luID0gaXNfY3Jvc3NvcmlnaW4oKTtcblxuXHQvKipcblx0ICogQHR5cGUgeygpID0+IHZvaWR9XG5cdCAqL1xuXHRsZXQgdW5zdWJzY3JpYmU7XG5cdGlmIChjcm9zc29yaWdpbikge1xuXHRcdGlmcmFtZS5zcmMgPSBcImRhdGE6dGV4dC9odG1sLDxzY3JpcHQ+b25yZXNpemU9ZnVuY3Rpb24oKXtwYXJlbnQucG9zdE1lc3NhZ2UoMCwnKicpfTwvc2NyaXB0PlwiO1xuXHRcdHVuc3Vic2NyaWJlID0gbGlzdGVuKFxuXHRcdFx0d2luZG93LFxuXHRcdFx0J21lc3NhZ2UnLFxuXHRcdFx0LyoqIEBwYXJhbSB7TWVzc2FnZUV2ZW50fSBldmVudCAqLyAoZXZlbnQpID0+IHtcblx0XHRcdFx0aWYgKGV2ZW50LnNvdXJjZSA9PT0gaWZyYW1lLmNvbnRlbnRXaW5kb3cpIGZuKCk7XG5cdFx0XHR9XG5cdFx0KTtcblx0fSBlbHNlIHtcblx0XHRpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcblx0XHRpZnJhbWUub25sb2FkID0gKCkgPT4ge1xuXHRcdFx0dW5zdWJzY3JpYmUgPSBsaXN0ZW4oaWZyYW1lLmNvbnRlbnRXaW5kb3csICdyZXNpemUnLCBmbik7XG5cdFx0XHQvLyBtYWtlIHN1cmUgYW4gaW5pdGlhbCByZXNpemUgZXZlbnQgaXMgZmlyZWQgX2FmdGVyXyB0aGUgaWZyYW1lIGlzIGxvYWRlZCAod2hpY2ggaXMgYXN5bmNocm9ub3VzKVxuXHRcdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzQyMzNcblx0XHRcdGZuKCk7XG5cdFx0fTtcblx0fVxuXHRhcHBlbmQobm9kZSwgaWZyYW1lKTtcblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoY3Jvc3NvcmlnaW4pIHtcblx0XHRcdHVuc3Vic2NyaWJlKCk7XG5cdFx0fSBlbHNlIGlmICh1bnN1YnNjcmliZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuXHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHR9XG5cdFx0ZGV0YWNoKGlmcmFtZSk7XG5cdH07XG59XG5leHBvcnQgY29uc3QgcmVzaXplX29ic2VydmVyX2NvbnRlbnRfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7XG5cdGJveDogJ2NvbnRlbnQtYm94J1xufSk7XG5leHBvcnQgY29uc3QgcmVzaXplX29ic2VydmVyX2JvcmRlcl9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKHtcblx0Ym94OiAnYm9yZGVyLWJveCdcbn0pO1xuZXhwb3J0IGNvbnN0IHJlc2l6ZV9vYnNlcnZlcl9kZXZpY2VfcGl4ZWxfY29udGVudF9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKFxuXHR7IGJveDogJ2RldmljZS1waXhlbC1jb250ZW50LWJveCcgfVxuKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIH07XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlX2NsYXNzKGVsZW1lbnQsIG5hbWUsIHRvZ2dsZSkge1xuXHQvLyBUaGUgYCEhYCBpcyByZXF1aXJlZCBiZWNhdXNlIGFuIGB1bmRlZmluZWRgIGZsYWcgbWVhbnMgZmxpcHBpbmcgdGhlIGN1cnJlbnQgc3RhdGUuXG5cdGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShuYW1lLCAhIXRvZ2dsZSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1R9IFtkZXRhaWxdXG4gKiBAcGFyYW0ge3sgYnViYmxlcz86IGJvb2xlYW4sIGNhbmNlbGFibGU/OiBib29sZWFuIH19IFtvcHRpb25zXVxuICogQHJldHVybnMge0N1c3RvbUV2ZW50PFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBidWJibGVzID0gZmFsc2UsIGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pIHtcblx0cmV0dXJuIG5ldyBDdXN0b21FdmVudCh0eXBlLCB7IGRldGFpbCwgYnViYmxlcywgY2FuY2VsYWJsZSB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybnMge0NoaWxkTm9kZUFycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVlcnlfc2VsZWN0b3JfYWxsKHNlbGVjdG9yLCBwYXJlbnQgPSBkb2N1bWVudC5ib2R5KSB7XG5cdHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVJZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaGVhZFxuICogQHJldHVybnMge2FueVtdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGVhZF9zZWxlY3Rvcihub2RlSWQsIGhlYWQpIHtcblx0Y29uc3QgcmVzdWx0ID0gW107XG5cdGxldCBzdGFydGVkID0gMDtcblx0Zm9yIChjb25zdCBub2RlIG9mIGhlYWQuY2hpbGROb2Rlcykge1xuXHRcdGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLykge1xuXHRcdFx0Y29uc3QgY29tbWVudCA9IG5vZGUudGV4dENvbnRlbnQudHJpbSgpO1xuXHRcdFx0aWYgKGNvbW1lbnQgPT09IGBIRUFEXyR7bm9kZUlkfV9FTkRgKSB7XG5cdFx0XHRcdHN0YXJ0ZWQgLT0gMTtcblx0XHRcdFx0cmVzdWx0LnB1c2gobm9kZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGNvbW1lbnQgPT09IGBIRUFEXyR7bm9kZUlkfV9TVEFSVGApIHtcblx0XHRcdFx0c3RhcnRlZCArPSAxO1xuXHRcdFx0XHRyZXN1bHQucHVzaChub2RlKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHN0YXJ0ZWQgPiAwKSB7XG5cdFx0XHRyZXN1bHQucHVzaChub2RlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cbi8qKiAqL1xuZXhwb3J0IGNsYXNzIEh0bWxUYWcge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICovXG5cdGlzX3N2ZyA9IGZhbHNlO1xuXHQvKiogcGFyZW50IGZvciBjcmVhdGluZyBub2RlICovXG5cdGUgPSB1bmRlZmluZWQ7XG5cdC8qKiBodG1sIHRhZyBub2RlcyAqL1xuXHRuID0gdW5kZWZpbmVkO1xuXHQvKiogdGFyZ2V0ICovXG5cdHQgPSB1bmRlZmluZWQ7XG5cdC8qKiBhbmNob3IgKi9cblx0YSA9IHVuZGVmaW5lZDtcblx0Y29uc3RydWN0b3IoaXNfc3ZnID0gZmFsc2UpIHtcblx0XHR0aGlzLmlzX3N2ZyA9IGlzX3N2Zztcblx0XHR0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0YyhodG1sKSB7XG5cdFx0dGhpcy5oKGh0bWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50fSB0YXJnZXRcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9IGFuY2hvclxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdG0oaHRtbCwgdGFyZ2V0LCBhbmNob3IgPSBudWxsKSB7XG5cdFx0aWYgKCF0aGlzLmUpIHtcblx0XHRcdGlmICh0aGlzLmlzX3N2Zylcblx0XHRcdFx0dGhpcy5lID0gc3ZnX2VsZW1lbnQoLyoqIEB0eXBlIHtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcH0gKi8gKHRhcmdldC5ub2RlTmFtZSkpO1xuXHRcdFx0LyoqICM3MzY0ICB0YXJnZXQgZm9yIDx0ZW1wbGF0ZT4gbWF5IGJlIHByb3ZpZGVkIGFzICNkb2N1bWVudC1mcmFnbWVudCgxMSkgKi8gZWxzZVxuXHRcdFx0XHR0aGlzLmUgPSBlbGVtZW50KFxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7a2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwfSAqLyAoXG5cdFx0XHRcdFx0XHR0YXJnZXQubm9kZVR5cGUgPT09IDExID8gJ1RFTVBMQVRFJyA6IHRhcmdldC5ub2RlTmFtZVxuXHRcdFx0XHRcdClcblx0XHRcdFx0KTtcblx0XHRcdHRoaXMudCA9XG5cdFx0XHRcdHRhcmdldC50YWdOYW1lICE9PSAnVEVNUExBVEUnXG5cdFx0XHRcdFx0PyB0YXJnZXRcblx0XHRcdFx0XHQ6IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8gKHRhcmdldCkuY29udGVudDtcblx0XHRcdHRoaXMuYyhodG1sKTtcblx0XHR9XG5cdFx0dGhpcy5pKGFuY2hvcik7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRoKGh0bWwpIHtcblx0XHR0aGlzLmUuaW5uZXJIVE1MID0gaHRtbDtcblx0XHR0aGlzLm4gPSBBcnJheS5mcm9tKFxuXHRcdFx0dGhpcy5lLm5vZGVOYW1lID09PSAnVEVNUExBVEUnID8gdGhpcy5lLmNvbnRlbnQuY2hpbGROb2RlcyA6IHRoaXMuZS5jaGlsZE5vZGVzXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0aShhbmNob3IpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0aW5zZXJ0KHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdHAoaHRtbCkge1xuXHRcdHRoaXMuZCgpO1xuXHRcdHRoaXMuaChodG1sKTtcblx0XHR0aGlzLmkodGhpcy5hKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZCgpIHtcblx0XHR0aGlzLm4uZm9yRWFjaChkZXRhY2gpO1xuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBIdG1sVGFnSHlkcmF0aW9uIGV4dGVuZHMgSHRtbFRhZyB7XG5cdC8qKiBAdHlwZSB7RWxlbWVudFtdfSBoeWRyYXRpb24gY2xhaW1lZCBub2RlcyAqL1xuXHRsID0gdW5kZWZpbmVkO1xuXG5cdGNvbnN0cnVjdG9yKGlzX3N2ZyA9IGZhbHNlLCBjbGFpbWVkX25vZGVzKSB7XG5cdFx0c3VwZXIoaXNfc3ZnKTtcblx0XHR0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuXHRcdHRoaXMubCA9IGNsYWltZWRfbm9kZXM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRjKGh0bWwpIHtcblx0XHRpZiAodGhpcy5sKSB7XG5cdFx0XHR0aGlzLm4gPSB0aGlzLmw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN1cGVyLmMoaHRtbCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRpKGFuY2hvcikge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRpbnNlcnRfaHlkcmF0aW9uKHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TmFtZWROb2RlTWFwfSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7e319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyaWJ1dGVfdG9fb2JqZWN0KGF0dHJpYnV0ZXMpIHtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZXMpIHtcblx0XHRyZXN1bHRbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IGVzY2FwZWQgPSB7XG5cdCdcIic6ICcmcXVvdDsnLFxuXHQnJic6ICcmYW1wOycsXG5cdCc8JzogJyZsdDsnXG59O1xuXG5jb25zdCByZWdleF9hdHRyaWJ1dGVfY2hhcmFjdGVyc190b19lc2NhcGUgPSAvW1wiJjxdL2c7XG5cbi8qKlxuICogTm90ZSB0aGF0IHRoZSBhdHRyaWJ1dGUgaXRzZWxmIHNob3VsZCBiZSBzdXJyb3VuZGVkIGluIGRvdWJsZSBxdW90ZXNcbiAqIEBwYXJhbSB7YW55fSBhdHRyaWJ1dGVcbiAqL1xuZnVuY3Rpb24gZXNjYXBlX2F0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcblx0cmV0dXJuIFN0cmluZyhhdHRyaWJ1dGUpLnJlcGxhY2UocmVnZXhfYXR0cmlidXRlX2NoYXJhY3RlcnNfdG9fZXNjYXBlLCAobWF0Y2gpID0+IGVzY2FwZWRbbWF0Y2hdKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IGF0dHJpYnV0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeV9zcHJlYWQoYXR0cmlidXRlcykge1xuXHRsZXQgc3RyID0gJyAnO1xuXHRmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0aWYgKGF0dHJpYnV0ZXNba2V5XSAhPSBudWxsKSB7XG5cdFx0XHRzdHIgKz0gYCR7a2V5fT1cIiR7ZXNjYXBlX2F0dHJpYnV0ZShhdHRyaWJ1dGVzW2tleV0pfVwiIGA7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7e319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKGVsZW1lbnQpIHtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdGVsZW1lbnQuY2hpbGROb2Rlcy5mb3JFYWNoKFxuXHRcdC8qKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgKi8gKG5vZGUpID0+IHtcblx0XHRcdHJlc3VsdFtub2RlLnNsb3QgfHwgJ2RlZmF1bHQnXSA9IHRydWU7XG5cdFx0fVxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnQoY29tcG9uZW50LCBwcm9wcykge1xuXHRyZXR1cm4gbmV3IGNvbXBvbmVudChwcm9wcyk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge05vZGUgJiB7XG4gKiBcdGNsYWltX29yZGVyPzogbnVtYmVyO1xuICogXHRoeWRyYXRlX2luaXQ/OiB0cnVlO1xuICogXHRhY3R1YWxfZW5kX2NoaWxkPzogTm9kZUV4O1xuICogXHRjaGlsZE5vZGVzOiBOb2RlTGlzdE9mPE5vZGVFeD47XG4gKiB9fSBOb2RlRXhcbiAqL1xuXG4vKiogQHR5cGVkZWYge0NoaWxkTm9kZSAmIE5vZGVFeH0gQ2hpbGROb2RlRXggKi9cblxuLyoqIEB0eXBlZGVmIHtOb2RlRXggJiB7IGNsYWltX29yZGVyOiBudW1iZXIgfX0gTm9kZUV4MiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtDaGlsZE5vZGVFeFtdICYge1xuICogXHRjbGFpbV9pbmZvPzoge1xuICogXHRcdGxhc3RfaW5kZXg6IG51bWJlcjtcbiAqIFx0XHR0b3RhbF9jbGFpbWVkOiBudW1iZXI7XG4gKiBcdH07XG4gKiB9fSBDaGlsZE5vZGVBcnJheVxuICovXG4iLCAiaW1wb3J0IHsgY3VzdG9tX2V2ZW50IH0gZnJvbSAnLi9kb20uanMnO1xuXG5leHBvcnQgbGV0IGN1cnJlbnRfY29tcG9uZW50O1xuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCkge1xuXHRjdXJyZW50X2NvbXBvbmVudCA9IGNvbXBvbmVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldF9jdXJyZW50X2NvbXBvbmVudCgpIHtcblx0aWYgKCFjdXJyZW50X2NvbXBvbmVudCkgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsZWQgb3V0c2lkZSBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24nKTtcblx0cmV0dXJuIGN1cnJlbnRfY29tcG9uZW50O1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1cGRhdGVkIGFmdGVyIGFueSBzdGF0ZSBjaGFuZ2UuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBiZWZvcmUgdGhlIGluaXRpYWwgYG9uTW91bnRgXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2JlZm9yZXVwZGF0ZVxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShmbikge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5iZWZvcmVfdXBkYXRlLnB1c2goZm4pO1xufVxuXG4vKipcbiAqIFRoZSBgb25Nb3VudGAgZnVuY3Rpb24gc2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGFzIHNvb24gYXMgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIHRvIHRoZSBET00uXG4gKiBJdCBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgdGhlIGNvbXBvbmVudCdzIGluaXRpYWxpc2F0aW9uIChidXQgZG9lc24ndCBuZWVkIHRvIGxpdmUgKmluc2lkZSogdGhlIGNvbXBvbmVudDtcbiAqIGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBhbiBleHRlcm5hbCBtb2R1bGUpLlxuICpcbiAqIElmIGEgZnVuY3Rpb24gaXMgcmV0dXJuZWQgX3N5bmNocm9ub3VzbHlfIGZyb20gYG9uTW91bnRgLCBpdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICpcbiAqIGBvbk1vdW50YCBkb2VzIG5vdCBydW4gaW5zaWRlIGEgW3NlcnZlci1zaWRlIGNvbXBvbmVudF0oL2RvY3MjcnVuLXRpbWUtc2VydmVyLXNpZGUtY29tcG9uZW50LWFwaSkuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI29ubW91bnRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IGltcG9ydCgnLi9wcml2YXRlLmpzJykuTm90RnVuY3Rpb248VD4gfCBQcm9taXNlPGltcG9ydCgnLi9wcml2YXRlLmpzJykuTm90RnVuY3Rpb248VD4+IHwgKCgpID0+IGFueSl9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uTW91bnQoZm4pIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fbW91bnQucHVzaChmbik7XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gdXBkYXRlZC5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGFmdGVyIHRoZSBpbml0aWFsIGBvbk1vdW50YFxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNhZnRlcnVwZGF0ZVxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFmdGVyVXBkYXRlKGZuKSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmFmdGVyX3VwZGF0ZS5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICpcbiAqIE91dCBvZiBgb25Nb3VudGAsIGBiZWZvcmVVcGRhdGVgLCBgYWZ0ZXJVcGRhdGVgIGFuZCBgb25EZXN0cm95YCwgdGhpcyBpcyB0aGVcbiAqIG9ubHkgb25lIHRoYXQgcnVucyBpbnNpZGUgYSBzZXJ2ZXItc2lkZSBjb21wb25lbnQuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI29uZGVzdHJveVxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uRGVzdHJveShmbikge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9kZXN0cm95LnB1c2goZm4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXZlbnQgZGlzcGF0Y2hlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGRpc3BhdGNoIFtjb21wb25lbnQgZXZlbnRzXSgvZG9jcyN0ZW1wbGF0ZS1zeW50YXgtY29tcG9uZW50LWRpcmVjdGl2ZXMtb24tZXZlbnRuYW1lKS5cbiAqIEV2ZW50IGRpc3BhdGNoZXJzIGFyZSBmdW5jdGlvbnMgdGhhdCBjYW4gdGFrZSB0d28gYXJndW1lbnRzOiBgbmFtZWAgYW5kIGBkZXRhaWxgLlxuICpcbiAqIENvbXBvbmVudCBldmVudHMgY3JlYXRlZCB3aXRoIGBjcmVhdGVFdmVudERpc3BhdGNoZXJgIGNyZWF0ZSBhXG4gKiBbQ3VzdG9tRXZlbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudCkuXG4gKiBUaGVzZSBldmVudHMgZG8gbm90IFtidWJibGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTGVhcm4vSmF2YVNjcmlwdC9CdWlsZGluZ19ibG9ja3MvRXZlbnRzI0V2ZW50X2J1YmJsaW5nX2FuZF9jYXB0dXJlKS5cbiAqIFRoZSBgZGV0YWlsYCBhcmd1bWVudCBjb3JyZXNwb25kcyB0byB0aGUgW0N1c3RvbUV2ZW50LmRldGFpbF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L2RldGFpbClcbiAqIHByb3BlcnR5IGFuZCBjYW4gY29udGFpbiBhbnkgdHlwZSBvZiBkYXRhLlxuICpcbiAqIFRoZSBldmVudCBkaXNwYXRjaGVyIGNhbiBiZSB0eXBlZCB0byBuYXJyb3cgdGhlIGFsbG93ZWQgZXZlbnQgbmFtZXMgYW5kIHRoZSB0eXBlIG9mIHRoZSBgZGV0YWlsYCBhcmd1bWVudDpcbiAqIGBgYHRzXG4gKiBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcjx7XG4gKiAgbG9hZGVkOiBuZXZlcjsgLy8gZG9lcyBub3QgdGFrZSBhIGRldGFpbCBhcmd1bWVudFxuICogIGNoYW5nZTogc3RyaW5nOyAvLyB0YWtlcyBhIGRldGFpbCBhcmd1bWVudCBvZiB0eXBlIHN0cmluZywgd2hpY2ggaXMgcmVxdWlyZWRcbiAqICBvcHRpb25hbDogbnVtYmVyIHwgbnVsbDsgLy8gdGFrZXMgYW4gb3B0aW9uYWwgZGV0YWlsIGFyZ3VtZW50IG9mIHR5cGUgbnVtYmVyXG4gKiB9PigpO1xuICogYGBgXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2NyZWF0ZWV2ZW50ZGlzcGF0Y2hlclxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbRXZlbnRNYXA9YW55XVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5FdmVudERpc3BhdGNoZXI8RXZlbnRNYXA+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuXHRjb25zdCBjb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcblx0cmV0dXJuICh0eXBlLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkgPT4ge1xuXHRcdGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbdHlwZV07XG5cdFx0aWYgKGNhbGxiYWNrcykge1xuXHRcdFx0Ly8gVE9ETyBhcmUgdGhlcmUgc2l0dWF0aW9ucyB3aGVyZSBldmVudHMgY291bGQgYmUgZGlzcGF0Y2hlZFxuXHRcdFx0Ly8gaW4gYSBzZXJ2ZXIgKG5vbi1ET00pIGVudmlyb25tZW50P1xuXHRcdFx0Y29uc3QgZXZlbnQgPSBjdXN0b21fZXZlbnQoLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgZGV0YWlsLCB7IGNhbmNlbGFibGUgfSk7XG5cdFx0XHRjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKChmbikgPT4ge1xuXHRcdFx0XHRmbi5jYWxsKGNvbXBvbmVudCwgZXZlbnQpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xufVxuXG4vKipcbiAqIEFzc29jaWF0ZXMgYW4gYXJiaXRyYXJ5IGBjb250ZXh0YCBvYmplY3Qgd2l0aCB0aGUgY3VycmVudCBjb21wb25lbnQgYW5kIHRoZSBzcGVjaWZpZWQgYGtleWBcbiAqIGFuZCByZXR1cm5zIHRoYXQgb2JqZWN0LiBUaGUgY29udGV4dCBpcyB0aGVuIGF2YWlsYWJsZSB0byBjaGlsZHJlbiBvZiB0aGUgY29tcG9uZW50XG4gKiAoaW5jbHVkaW5nIHNsb3R0ZWQgY29udGVudCkgd2l0aCBgZ2V0Q29udGV4dGAuXG4gKlxuICogTGlrZSBsaWZlY3ljbGUgZnVuY3Rpb25zLCB0aGlzIG11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI3NldGNvbnRleHRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcGFyYW0ge1R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29udGV4dChrZXksIGNvbnRleHQpIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5zZXQoa2V5LCBjb250ZXh0KTtcblx0cmV0dXJuIGNvbnRleHQ7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBjb250ZXh0IHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50IHdpdGggdGhlIHNwZWNpZmllZCBga2V5YC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2dldGNvbnRleHRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRleHQoa2V5KSB7XG5cdHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmdldChrZXkpO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgd2hvbGUgY29udGV4dCBtYXAgdGhhdCBiZWxvbmdzIHRvIHRoZSBjbG9zZXN0IHBhcmVudCBjb21wb25lbnQuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLiBVc2VmdWwsIGZvciBleGFtcGxlLCBpZiB5b3VcbiAqIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgY29tcG9uZW50IGFuZCB3YW50IHRvIHBhc3MgdGhlIGV4aXN0aW5nIGNvbnRleHQgdG8gaXQuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2dldGFsbGNvbnRleHRzXG4gKiBAdGVtcGxhdGUge01hcDxhbnksIGFueT59IFtUPU1hcDxhbnksIGFueT5dXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbENvbnRleHRzKCkge1xuXHRyZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIGBrZXlgIGhhcyBiZWVuIHNldCBpbiB0aGUgY29udGV4dCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZSNoYXNjb250ZXh0XG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0NvbnRleHQoa2V5KSB7XG5cdHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmhhcyhrZXkpO1xufVxuXG4vLyBUT0RPIGZpZ3VyZSBvdXQgaWYgd2Ugc3RpbGwgd2FudCB0byBzdXBwb3J0XG4vLyBzaG9ydGhhbmQgZXZlbnRzLCBvciBpZiB3ZSB3YW50IHRvIGltcGxlbWVudFxuLy8gYSByZWFsIGJ1YmJsaW5nIG1lY2hhbmlzbVxuLyoqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKiBAcGFyYW0gZXZlbnRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnViYmxlKGNvbXBvbmVudCwgZXZlbnQpIHtcblx0Y29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1tldmVudC50eXBlXTtcblx0aWYgKGNhbGxiYWNrcykge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKChmbikgPT4gZm4uY2FsbCh0aGlzLCBldmVudCkpO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgcnVuX2FsbCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgY3VycmVudF9jb21wb25lbnQsIHNldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcblxuZXhwb3J0IGNvbnN0IGRpcnR5X2NvbXBvbmVudHMgPSBbXTtcbmV4cG9ydCBjb25zdCBpbnRyb3MgPSB7IGVuYWJsZWQ6IGZhbHNlIH07XG5leHBvcnQgY29uc3QgYmluZGluZ19jYWxsYmFja3MgPSBbXTtcblxubGV0IHJlbmRlcl9jYWxsYmFja3MgPSBbXTtcblxuY29uc3QgZmx1c2hfY2FsbGJhY2tzID0gW107XG5cbmNvbnN0IHJlc29sdmVkX3Byb21pc2UgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbmxldCB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2hlZHVsZV91cGRhdGUoKSB7XG5cdGlmICghdXBkYXRlX3NjaGVkdWxlZCkge1xuXHRcdHVwZGF0ZV9zY2hlZHVsZWQgPSB0cnVlO1xuXHRcdHJlc29sdmVkX3Byb21pc2UudGhlbihmbHVzaCk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpY2soKSB7XG5cdHNjaGVkdWxlX3VwZGF0ZSgpO1xuXHRyZXR1cm4gcmVzb2x2ZWRfcHJvbWlzZTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9yZW5kZXJfY2FsbGJhY2soZm4pIHtcblx0cmVuZGVyX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9mbHVzaF9jYWxsYmFjayhmbikge1xuXHRmbHVzaF9jYWxsYmFja3MucHVzaChmbik7XG59XG5cbi8vIGZsdXNoKCkgY2FsbHMgY2FsbGJhY2tzIGluIHRoaXMgb3JkZXI6XG4vLyAxLiBBbGwgYmVmb3JlVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuXG4vLyAyLiBBbGwgYmluZDp0aGlzIGNhbGxiYWNrcywgaW4gcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyAzLiBBbGwgYWZ0ZXJVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW4uIEVYQ0VQVFxuLy8gICAgZm9yIGFmdGVyVXBkYXRlcyBjYWxsZWQgZHVyaW5nIHRoZSBpbml0aWFsIG9uTW91bnQsIHdoaWNoIGFyZSBjYWxsZWQgaW5cbi8vICAgIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gU2luY2UgY2FsbGJhY2tzIG1pZ2h0IHVwZGF0ZSBjb21wb25lbnQgdmFsdWVzLCB3aGljaCBjb3VsZCB0cmlnZ2VyIGFub3RoZXJcbi8vIGNhbGwgdG8gZmx1c2goKSwgdGhlIGZvbGxvd2luZyBzdGVwcyBndWFyZCBhZ2FpbnN0IHRoaXM6XG4vLyAxLiBEdXJpbmcgYmVmb3JlVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyAgICBkaXJ0eV9jb21wb25lbnRzIGFycmF5IGFuZCB3aWxsIGNhdXNlIGEgcmVlbnRyYW50IGNhbGwgdG8gZmx1c2goKS4gQmVjYXVzZVxuLy8gICAgdGhlIGZsdXNoIGluZGV4IGlzIGtlcHQgb3V0c2lkZSB0aGUgZnVuY3Rpb24sIHRoZSByZWVudHJhbnQgY2FsbCB3aWxsIHBpY2tcbi8vICAgIHVwIHdoZXJlIHRoZSBlYXJsaWVyIGNhbGwgbGVmdCBvZmYgYW5kIGdvIHRocm91Z2ggYWxsIGRpcnR5IGNvbXBvbmVudHMuIFRoZVxuLy8gICAgY3VycmVudF9jb21wb25lbnQgdmFsdWUgaXMgc2F2ZWQgYW5kIHJlc3RvcmVkIHNvIHRoYXQgdGhlIHJlZW50cmFudCBjYWxsIHdpbGxcbi8vICAgIG5vdCBpbnRlcmZlcmUgd2l0aCB0aGUgXCJwYXJlbnRcIiBmbHVzaCgpIGNhbGwuXG4vLyAyLiBiaW5kOnRoaXMgY2FsbGJhY2tzIGNhbm5vdCB0cmlnZ2VyIG5ldyBmbHVzaCgpIGNhbGxzLlxuLy8gMy4gRHVyaW5nIGFmdGVyVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgTk9UIGhhdmUgdGhlaXIgYWZ0ZXJVcGRhdGVcbi8vICAgIGNhbGxiYWNrIGNhbGxlZCBhIHNlY29uZCB0aW1lOyB0aGUgc2Vlbl9jYWxsYmFja3Mgc2V0LCBvdXRzaWRlIHRoZSBmbHVzaCgpXG4vLyAgICBmdW5jdGlvbiwgZ3VhcmFudGVlcyB0aGlzIGJlaGF2aW9yLlxuY29uc3Qgc2Vlbl9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5cbmxldCBmbHVzaGlkeCA9IDA7IC8vIERvICpub3QqIG1vdmUgdGhpcyBpbnNpZGUgdGhlIGZsdXNoKCkgZnVuY3Rpb25cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoKCkge1xuXHQvLyBEbyBub3QgcmVlbnRlciBmbHVzaCB3aGlsZSBkaXJ0eSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBhcyB0aGlzIGNhblxuXHQvLyByZXN1bHQgaW4gYW4gaW5maW5pdGUgbG9vcC4gSW5zdGVhZCwgbGV0IHRoZSBpbm5lciBmbHVzaCBoYW5kbGUgaXQuXG5cdC8vIFJlZW50cmFuY3kgaXMgb2sgYWZ0ZXJ3YXJkcyBmb3IgYmluZGluZ3MgZXRjLlxuXHRpZiAoZmx1c2hpZHggIT09IDApIHtcblx0XHRyZXR1cm47XG5cdH1cblx0Y29uc3Qgc2F2ZWRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG5cdGRvIHtcblx0XHQvLyBmaXJzdCwgY2FsbCBiZWZvcmVVcGRhdGUgZnVuY3Rpb25zXG5cdFx0Ly8gYW5kIHVwZGF0ZSBjb21wb25lbnRzXG5cdFx0dHJ5IHtcblx0XHRcdHdoaWxlIChmbHVzaGlkeCA8IGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGNvbnN0IGNvbXBvbmVudCA9IGRpcnR5X2NvbXBvbmVudHNbZmx1c2hpZHhdO1xuXHRcdFx0XHRmbHVzaGlkeCsrO1xuXHRcdFx0XHRzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcblx0XHRcdFx0dXBkYXRlKGNvbXBvbmVudC4kJCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gcmVzZXQgZGlydHkgc3RhdGUgdG8gbm90IGVuZCB1cCBpbiBhIGRlYWRsb2NrZWQgc3RhdGUgYW5kIHRoZW4gcmV0aHJvd1xuXHRcdFx0ZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuXHRcdFx0Zmx1c2hpZHggPSAwO1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdFx0c2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuXHRcdGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcblx0XHRmbHVzaGlkeCA9IDA7XG5cdFx0d2hpbGUgKGJpbmRpbmdfY2FsbGJhY2tzLmxlbmd0aCkgYmluZGluZ19jYWxsYmFja3MucG9wKCkoKTtcblx0XHQvLyB0aGVuLCBvbmNlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGNhbGxcblx0XHQvLyBhZnRlclVwZGF0ZSBmdW5jdGlvbnMuIFRoaXMgbWF5IGNhdXNlXG5cdFx0Ly8gc3Vic2VxdWVudCB1cGRhdGVzLi4uXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRjb25zdCBjYWxsYmFjayA9IHJlbmRlcl9jYWxsYmFja3NbaV07XG5cdFx0XHRpZiAoIXNlZW5fY2FsbGJhY2tzLmhhcyhjYWxsYmFjaykpIHtcblx0XHRcdFx0Ly8gLi4uc28gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBsb29wc1xuXHRcdFx0XHRzZWVuX2NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZW5kZXJfY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG5cdH0gd2hpbGUgKGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKTtcblx0d2hpbGUgKGZsdXNoX2NhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRmbHVzaF9jYWxsYmFja3MucG9wKCkoKTtcblx0fVxuXHR1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5cdHNlZW5fY2FsbGJhY2tzLmNsZWFyKCk7XG5cdHNldF9jdXJyZW50X2NvbXBvbmVudChzYXZlZF9jb21wb25lbnQpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5mdW5jdGlvbiB1cGRhdGUoJCQpIHtcblx0aWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG5cdFx0JCQudXBkYXRlKCk7XG5cdFx0cnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcblx0XHRjb25zdCBkaXJ0eSA9ICQkLmRpcnR5O1xuXHRcdCQkLmRpcnR5ID0gWy0xXTtcblx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5wKCQkLmN0eCwgZGlydHkpO1xuXHRcdCQkLmFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xuXHR9XG59XG5cbi8qKlxuICogVXNlZnVsIGZvciBleGFtcGxlIHRvIGV4ZWN1dGUgcmVtYWluaW5nIGBhZnRlclVwZGF0ZWAgY2FsbGJhY2tzIGJlZm9yZSBleGVjdXRpbmcgYGRlc3Ryb3lgLlxuICogQHBhcmFtIHtGdW5jdGlvbltdfSBmbnNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hfcmVuZGVyX2NhbGxiYWNrcyhmbnMpIHtcblx0Y29uc3QgZmlsdGVyZWQgPSBbXTtcblx0Y29uc3QgdGFyZ2V0cyA9IFtdO1xuXHRyZW5kZXJfY2FsbGJhY2tzLmZvckVhY2goKGMpID0+IChmbnMuaW5kZXhPZihjKSA9PT0gLTEgPyBmaWx0ZXJlZC5wdXNoKGMpIDogdGFyZ2V0cy5wdXNoKGMpKSk7XG5cdHRhcmdldHMuZm9yRWFjaCgoYykgPT4gYygpKTtcblx0cmVuZGVyX2NhbGxiYWNrcyA9IGZpbHRlcmVkO1xufVxuIiwgImltcG9ydCB7IGlkZW50aXR5IGFzIGxpbmVhciwgaXNfZnVuY3Rpb24sIG5vb3AsIHJ1bl9hbGwgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IG5vdyB9IGZyb20gJy4vZW52aXJvbm1lbnQuanMnO1xuaW1wb3J0IHsgbG9vcCB9IGZyb20gJy4vbG9vcC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfcnVsZSwgZGVsZXRlX3J1bGUgfSBmcm9tICcuL3N0eWxlX21hbmFnZXIuanMnO1xuaW1wb3J0IHsgY3VzdG9tX2V2ZW50IH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgYWRkX3JlbmRlcl9jYWxsYmFjayB9IGZyb20gJy4vc2NoZWR1bGVyLmpzJztcblxuLyoqXG4gKiBAdHlwZSB7UHJvbWlzZTx2b2lkPiB8IG51bGx9XG4gKi9cbmxldCBwcm9taXNlO1xuXG4vKipcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5mdW5jdGlvbiB3YWl0KCkge1xuXHRpZiAoIXByb21pc2UpIHtcblx0XHRwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0cHJvbWlzZS50aGVuKCgpID0+IHtcblx0XHRcdHByb21pc2UgPSBudWxsO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBwcm9taXNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtJTlRSTyB8IE9VVFJPIHwgYm9vbGVhbn0gZGlyZWN0aW9uXG4gKiBAcGFyYW0geydzdGFydCcgfCAnZW5kJ30ga2luZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGRpc3BhdGNoKG5vZGUsIGRpcmVjdGlvbiwga2luZCkge1xuXHRub2RlLmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KGAke2RpcmVjdGlvbiA/ICdpbnRybycgOiAnb3V0cm8nfSR7a2luZH1gKSk7XG59XG5cbmNvbnN0IG91dHJvaW5nID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIEB0eXBlIHtPdXRyb31cbiAqL1xubGV0IG91dHJvcztcblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBncm91cF9vdXRyb3MoKSB7XG5cdG91dHJvcyA9IHtcblx0XHRyOiAwLFxuXHRcdGM6IFtdLFxuXHRcdHA6IG91dHJvcyAvLyBwYXJlbnQgZ3JvdXBcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja19vdXRyb3MoKSB7XG5cdGlmICghb3V0cm9zLnIpIHtcblx0XHRydW5fYWxsKG91dHJvcy5jKTtcblx0fVxuXHRvdXRyb3MgPSBvdXRyb3MucDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuRnJhZ21lbnR9IGJsb2NrXG4gKiBAcGFyYW0gezAgfCAxfSBbbG9jYWxdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zaXRpb25faW4oYmxvY2ssIGxvY2FsKSB7XG5cdGlmIChibG9jayAmJiBibG9jay5pKSB7XG5cdFx0b3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcblx0XHRibG9jay5pKGxvY2FsKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5GcmFnbWVudH0gYmxvY2tcbiAqIEBwYXJhbSB7MCB8IDF9IGxvY2FsXG4gKiBAcGFyYW0gezAgfCAxfSBbZGV0YWNoXVxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zaXRpb25fb3V0KGJsb2NrLCBsb2NhbCwgZGV0YWNoLCBjYWxsYmFjaykge1xuXHRpZiAoYmxvY2sgJiYgYmxvY2subykge1xuXHRcdGlmIChvdXRyb2luZy5oYXMoYmxvY2spKSByZXR1cm47XG5cdFx0b3V0cm9pbmcuYWRkKGJsb2NrKTtcblx0XHRvdXRyb3MuYy5wdXNoKCgpID0+IHtcblx0XHRcdG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0aWYgKGRldGFjaCkgYmxvY2suZCgxKTtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRibG9jay5vKGxvY2FsKTtcblx0fSBlbHNlIGlmIChjYWxsYmFjaykge1xuXHRcdGNhbGxiYWNrKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuLi90cmFuc2l0aW9uL3B1YmxpYy5qcycpLlRyYW5zaXRpb25Db25maWd9XG4gKi9cbmNvbnN0IG51bGxfdHJhbnNpdGlvbiA9IHsgZHVyYXRpb246IDAgfTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbkZufSBmblxuICogQHBhcmFtIHthbnl9IHBhcmFtc1xuICogQHJldHVybnMge3sgc3RhcnQoKTogdm9pZDsgaW52YWxpZGF0ZSgpOiB2b2lkOyBlbmQoKTogdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9pbl90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtUcmFuc2l0aW9uT3B0aW9uc30gKi9cblx0Y29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnaW4nIH07XG5cdGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuXHRsZXQgcnVubmluZyA9IGZhbHNlO1xuXHRsZXQgYW5pbWF0aW9uX25hbWU7XG5cdGxldCB0YXNrO1xuXHRsZXQgdWlkID0gMDtcblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGNsZWFudXAoKSB7XG5cdFx0aWYgKGFuaW1hdGlvbl9uYW1lKSBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGdvKCkge1xuXHRcdGNvbnN0IHtcblx0XHRcdGRlbGF5ID0gMCxcblx0XHRcdGR1cmF0aW9uID0gMzAwLFxuXHRcdFx0ZWFzaW5nID0gbGluZWFyLFxuXHRcdFx0dGljayA9IG5vb3AsXG5cdFx0XHRjc3Ncblx0XHR9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcblx0XHRpZiAoY3NzKSBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MsIHVpZCsrKTtcblx0XHR0aWNrKDAsIDEpO1xuXHRcdGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuXHRcdGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuXHRcdGlmICh0YXNrKSB0YXNrLmFib3J0KCk7XG5cdFx0cnVubmluZyA9IHRydWU7XG5cdFx0YWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCB0cnVlLCAnc3RhcnQnKSk7XG5cdFx0dGFzayA9IGxvb3AoKG5vdykgPT4ge1xuXHRcdFx0aWYgKHJ1bm5pbmcpIHtcblx0XHRcdFx0aWYgKG5vdyA+PSBlbmRfdGltZSkge1xuXHRcdFx0XHRcdHRpY2soMSwgMCk7XG5cdFx0XHRcdFx0ZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ2VuZCcpO1xuXHRcdFx0XHRcdGNsZWFudXAoKTtcblx0XHRcdFx0XHRyZXR1cm4gKHJ1bm5pbmcgPSBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG5cdFx0XHRcdFx0dGljayh0LCAxIC0gdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBydW5uaW5nO1xuXHRcdH0pO1xuXHR9XG5cdGxldCBzdGFydGVkID0gZmFsc2U7XG5cdHJldHVybiB7XG5cdFx0c3RhcnQoKSB7XG5cdFx0XHRpZiAoc3RhcnRlZCkgcmV0dXJuO1xuXHRcdFx0c3RhcnRlZCA9IHRydWU7XG5cdFx0XHRkZWxldGVfcnVsZShub2RlKTtcblx0XHRcdGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG5cdFx0XHRcdGNvbmZpZyA9IGNvbmZpZyhvcHRpb25zKTtcblx0XHRcdFx0d2FpdCgpLnRoZW4oZ28pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z28oKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGludmFsaWRhdGUoKSB7XG5cdFx0XHRzdGFydGVkID0gZmFsc2U7XG5cdFx0fSxcblx0XHRlbmQoKSB7XG5cdFx0XHRpZiAocnVubmluZykge1xuXHRcdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRcdHJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge1RyYW5zaXRpb25Gbn0gZm5cbiAqIEBwYXJhbSB7YW55fSBwYXJhbXNcbiAqIEByZXR1cm5zIHt7IGVuZChyZXNldDogYW55KTogdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG5cdC8qKiBAdHlwZSB7VHJhbnNpdGlvbk9wdGlvbnN9ICovXG5cdGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ291dCcgfTtcblx0bGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG5cdGxldCBydW5uaW5nID0gdHJ1ZTtcblx0bGV0IGFuaW1hdGlvbl9uYW1lO1xuXHRjb25zdCBncm91cCA9IG91dHJvcztcblx0Z3JvdXAuciArPSAxO1xuXHQvKiogQHR5cGUge2Jvb2xlYW59ICovXG5cdGxldCBvcmlnaW5hbF9pbmVydF92YWx1ZTtcblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGdvKCkge1xuXHRcdGNvbnN0IHtcblx0XHRcdGRlbGF5ID0gMCxcblx0XHRcdGR1cmF0aW9uID0gMzAwLFxuXHRcdFx0ZWFzaW5nID0gbGluZWFyLFxuXHRcdFx0dGljayA9IG5vb3AsXG5cdFx0XHRjc3Ncblx0XHR9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcblxuXHRcdGlmIChjc3MpIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMSwgMCwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG5cblx0XHRjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcblx0XHRjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcblx0XHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnc3RhcnQnKSk7XG5cblx0XHRpZiAoJ2luZXJ0JyBpbiBub2RlKSB7XG5cdFx0XHRvcmlnaW5hbF9pbmVydF92YWx1ZSA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChub2RlKS5pbmVydDtcblx0XHRcdG5vZGUuaW5lcnQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGxvb3AoKG5vdykgPT4ge1xuXHRcdFx0aWYgKHJ1bm5pbmcpIHtcblx0XHRcdFx0aWYgKG5vdyA+PSBlbmRfdGltZSkge1xuXHRcdFx0XHRcdHRpY2soMCwgMSk7XG5cdFx0XHRcdFx0ZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdlbmQnKTtcblx0XHRcdFx0XHRpZiAoIS0tZ3JvdXAucikge1xuXHRcdFx0XHRcdFx0Ly8gdGhpcyB3aWxsIHJlc3VsdCBpbiBgZW5kKClgIGJlaW5nIGNhbGxlZCxcblx0XHRcdFx0XHRcdC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gY2xlYW4gdXAgaGVyZVxuXHRcdFx0XHRcdFx0cnVuX2FsbChncm91cC5jKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuXHRcdFx0XHRcdGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuXHRcdFx0XHRcdHRpY2soMSAtIHQsIHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcnVubmluZztcblx0XHR9KTtcblx0fVxuXG5cdGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG5cdFx0d2FpdCgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0Y29uZmlnID0gY29uZmlnKG9wdGlvbnMpO1xuXHRcdFx0Z28oKTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRnbygpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRlbmQocmVzZXQpIHtcblx0XHRcdGlmIChyZXNldCAmJiAnaW5lcnQnIGluIG5vZGUpIHtcblx0XHRcdFx0bm9kZS5pbmVydCA9IG9yaWdpbmFsX2luZXJ0X3ZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJlc2V0ICYmIGNvbmZpZy50aWNrKSB7XG5cdFx0XHRcdGNvbmZpZy50aWNrKDEsIDApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJ1bm5pbmcpIHtcblx0XHRcdFx0aWYgKGFuaW1hdGlvbl9uYW1lKSBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG5cdFx0XHRcdHJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge1RyYW5zaXRpb25Gbn0gZm5cbiAqIEBwYXJhbSB7YW55fSBwYXJhbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW50cm9cbiAqIEByZXR1cm5zIHt7IHJ1bihiOiAwIHwgMSk6IHZvaWQ7IGVuZCgpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zLCBpbnRybykge1xuXHQvKipcblx0ICogQHR5cGUge1RyYW5zaXRpb25PcHRpb25zfSAqL1xuXHRjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdib3RoJyB9O1xuXHRsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcblx0bGV0IHQgPSBpbnRybyA/IDAgOiAxO1xuXG5cdC8qKlxuXHQgKiBAdHlwZSB7UHJvZ3JhbSB8IG51bGx9ICovXG5cdGxldCBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBAdHlwZSB7UGVuZGluZ1Byb2dyYW0gfCBudWxsfSAqL1xuXHRsZXQgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcblx0bGV0IGFuaW1hdGlvbl9uYW1lID0gbnVsbDtcblxuXHQvKiogQHR5cGUge2Jvb2xlYW59ICovXG5cdGxldCBvcmlnaW5hbF9pbmVydF92YWx1ZTtcblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIGNsZWFyX2FuaW1hdGlvbigpIHtcblx0XHRpZiAoYW5pbWF0aW9uX25hbWUpIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1BlbmRpbmdQcm9ncmFtfSBwcm9ncmFtXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxuXHQgKiBAcmV0dXJucyB7UHJvZ3JhbX1cblx0ICovXG5cdGZ1bmN0aW9uIGluaXQocHJvZ3JhbSwgZHVyYXRpb24pIHtcblx0XHRjb25zdCBkID0gLyoqIEB0eXBlIHtQcm9ncmFtWydkJ119ICovIChwcm9ncmFtLmIgLSB0KTtcblx0XHRkdXJhdGlvbiAqPSBNYXRoLmFicyhkKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0YTogdCxcblx0XHRcdGI6IHByb2dyYW0uYixcblx0XHRcdGQsXG5cdFx0XHRkdXJhdGlvbixcblx0XHRcdHN0YXJ0OiBwcm9ncmFtLnN0YXJ0LFxuXHRcdFx0ZW5kOiBwcm9ncmFtLnN0YXJ0ICsgZHVyYXRpb24sXG5cdFx0XHRncm91cDogcHJvZ3JhbS5ncm91cFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtJTlRSTyB8IE9VVFJPfSBiXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gZ28oYikge1xuXHRcdGNvbnN0IHtcblx0XHRcdGRlbGF5ID0gMCxcblx0XHRcdGR1cmF0aW9uID0gMzAwLFxuXHRcdFx0ZWFzaW5nID0gbGluZWFyLFxuXHRcdFx0dGljayA9IG5vb3AsXG5cdFx0XHRjc3Ncblx0XHR9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcblxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtQZW5kaW5nUHJvZ3JhbX0gKi9cblx0XHRjb25zdCBwcm9ncmFtID0ge1xuXHRcdFx0c3RhcnQ6IG5vdygpICsgZGVsYXksXG5cdFx0XHRiXG5cdFx0fTtcblxuXHRcdGlmICghYikge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3Ncblx0XHRcdHByb2dyYW0uZ3JvdXAgPSBvdXRyb3M7XG5cdFx0XHRvdXRyb3MuciArPSAxO1xuXHRcdH1cblxuXHRcdGlmICgnaW5lcnQnIGluIG5vZGUpIHtcblx0XHRcdGlmIChiKSB7XG5cdFx0XHRcdGlmIChvcmlnaW5hbF9pbmVydF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Ly8gYWJvcnRlZC9yZXZlcnNlZCBvdXRybyBcdTIwMTQgcmVzdG9yZSBwcmV2aW91cyBpbmVydCB2YWx1ZVxuXHRcdFx0XHRcdG5vZGUuaW5lcnQgPSBvcmlnaW5hbF9pbmVydF92YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3JpZ2luYWxfaW5lcnRfdmFsdWUgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAobm9kZSkuaW5lcnQ7XG5cdFx0XHRcdG5vZGUuaW5lcnQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKSB7XG5cdFx0XHRwZW5kaW5nX3Byb2dyYW0gPSBwcm9ncmFtO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpZiB0aGlzIGlzIGFuIGludHJvLCBhbmQgdGhlcmUncyBhIGRlbGF5LCB3ZSBuZWVkIHRvIGRvXG5cdFx0XHQvLyBhbiBpbml0aWFsIHRpY2sgYW5kL29yIGFwcGx5IENTUyBhbmltYXRpb24gaW1tZWRpYXRlbHlcblx0XHRcdGlmIChjc3MpIHtcblx0XHRcdFx0Y2xlYXJfYW5pbWF0aW9uKCk7XG5cdFx0XHRcdGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYikgdGljaygwLCAxKTtcblx0XHRcdHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocHJvZ3JhbSwgZHVyYXRpb24pO1xuXHRcdFx0YWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBiLCAnc3RhcnQnKSk7XG5cdFx0XHRsb29wKChub3cpID0+IHtcblx0XHRcdFx0aWYgKHBlbmRpbmdfcHJvZ3JhbSAmJiBub3cgPiBwZW5kaW5nX3Byb2dyYW0uc3RhcnQpIHtcblx0XHRcdFx0XHRydW5uaW5nX3Byb2dyYW0gPSBpbml0KHBlbmRpbmdfcHJvZ3JhbSwgZHVyYXRpb24pO1xuXHRcdFx0XHRcdHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG5cdFx0XHRcdFx0ZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdzdGFydCcpO1xuXHRcdFx0XHRcdGlmIChjc3MpIHtcblx0XHRcdFx0XHRcdGNsZWFyX2FuaW1hdGlvbigpO1xuXHRcdFx0XHRcdFx0YW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShcblx0XHRcdFx0XHRcdFx0bm9kZSxcblx0XHRcdFx0XHRcdFx0dCxcblx0XHRcdFx0XHRcdFx0cnVubmluZ19wcm9ncmFtLmIsXG5cdFx0XHRcdFx0XHRcdHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbixcblx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0ZWFzaW5nLFxuXHRcdFx0XHRcdFx0XHRjb25maWcuY3NzXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocnVubmluZ19wcm9ncmFtKSB7XG5cdFx0XHRcdFx0aWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uZW5kKSB7XG5cdFx0XHRcdFx0XHR0aWNrKCh0ID0gcnVubmluZ19wcm9ncmFtLmIpLCAxIC0gdCk7XG5cdFx0XHRcdFx0XHRkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ2VuZCcpO1xuXHRcdFx0XHRcdFx0aWYgKCFwZW5kaW5nX3Byb2dyYW0pIHtcblx0XHRcdFx0XHRcdFx0Ly8gd2UncmUgZG9uZVxuXHRcdFx0XHRcdFx0XHRpZiAocnVubmluZ19wcm9ncmFtLmIpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBpbnRybyBcdTIwMTQgd2UgY2FuIHRpZHkgdXAgaW1tZWRpYXRlbHlcblx0XHRcdFx0XHRcdFx0XHRjbGVhcl9hbmltYXRpb24oKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBvdXRybyBcdTIwMTQgbmVlZHMgdG8gYmUgY29vcmRpbmF0ZWRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIS0tcnVubmluZ19wcm9ncmFtLmdyb3VwLnIpIHJ1bl9hbGwocnVubmluZ19wcm9ncmFtLmdyb3VwLmMpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5zdGFydCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgcCA9IG5vdyAtIHJ1bm5pbmdfcHJvZ3JhbS5zdGFydDtcblx0XHRcdFx0XHRcdHQgPSBydW5uaW5nX3Byb2dyYW0uYSArIHJ1bm5pbmdfcHJvZ3JhbS5kICogZWFzaW5nKHAgLyBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24pO1xuXHRcdFx0XHRcdFx0dGljayh0LCAxIC0gdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAhIShydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4ge1xuXHRcdHJ1bihiKSB7XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuXHRcdFx0XHR3YWl0KCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qgb3B0cyA9IHsgZGlyZWN0aW9uOiBiID8gJ2luJyA6ICdvdXQnIH07XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdGNvbmZpZyA9IGNvbmZpZyhvcHRzKTtcblx0XHRcdFx0XHRnbyhiKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRnbyhiKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGVuZCgpIHtcblx0XHRcdGNsZWFyX2FuaW1hdGlvbigpO1xuXHRcdFx0cnVubmluZ19wcm9ncmFtID0gcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcblx0XHR9XG5cdH07XG59XG5cbi8qKiBAdHlwZWRlZiB7MX0gSU5UUk8gKi9cbi8qKiBAdHlwZWRlZiB7MH0gT1VUUk8gKi9cbi8qKiBAdHlwZWRlZiB7eyBkaXJlY3Rpb246ICdpbicgfCAnb3V0JyB8ICdib3RoJyB9fSBUcmFuc2l0aW9uT3B0aW9ucyAqL1xuLyoqIEB0eXBlZGVmIHsobm9kZTogRWxlbWVudCwgcGFyYW1zOiBhbnksIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zKSA9PiBpbXBvcnQoJy4uL3RyYW5zaXRpb24vcHVibGljLmpzJykuVHJhbnNpdGlvbkNvbmZpZ30gVHJhbnNpdGlvbkZuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3V0cm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9uW119IGNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQZW5kaW5nUHJvZ3JhbVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0XG4gKiBAcHJvcGVydHkge0lOVFJPfE9VVFJPfSBiXG4gKiBAcHJvcGVydHkge091dHJvfSBbZ3JvdXBdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9ncmFtXG4gKiBAcHJvcGVydHkge251bWJlcn0gYVxuICogQHByb3BlcnR5IHtJTlRST3xPVVRST30gYlxuICogQHByb3BlcnR5IHsxfC0xfSBkXG4gKiBAcHJvcGVydHkge251bWJlcn0gZHVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZFxuICogQHByb3BlcnR5IHtPdXRyb30gW2dyb3VwXVxuICovXG4iLCAiaW1wb3J0IHsgdHJhbnNpdGlvbl9pbiwgdHJhbnNpdGlvbl9vdXQgfSBmcm9tICcuL3RyYW5zaXRpb25zLmpzJztcbmltcG9ydCB7IHJ1bl9hbGwgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLy8gZ2VuZXJhbCBlYWNoIGZ1bmN0aW9uczpcblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZV9hcnJheV9saWtlKGFycmF5X2xpa2Vfb3JfaXRlcmF0b3IpIHtcblx0cmV0dXJuIGFycmF5X2xpa2Vfb3JfaXRlcmF0b3I/Lmxlbmd0aCAhPT0gdW5kZWZpbmVkXG5cdFx0PyBhcnJheV9saWtlX29yX2l0ZXJhdG9yXG5cdFx0OiBBcnJheS5mcm9tKGFycmF5X2xpa2Vfb3JfaXRlcmF0b3IpO1xufVxuXG4vLyBrZXllZCBlYWNoIGZ1bmN0aW9uczpcblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuXHRibG9jay5kKDEpO1xuXHRsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG5cdHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG5cdFx0bG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xuXHR9KTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpeF9hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG5cdGJsb2NrLmYoKTtcblx0ZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuXHRibG9jay5mKCk7XG5cdG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuXG4vKiogQHJldHVybnMge2FueVtdfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9rZXllZF9lYWNoKFxuXHRvbGRfYmxvY2tzLFxuXHRkaXJ0eSxcblx0Z2V0X2tleSxcblx0ZHluYW1pYyxcblx0Y3R4LFxuXHRsaXN0LFxuXHRsb29rdXAsXG5cdG5vZGUsXG5cdGRlc3Ryb3ksXG5cdGNyZWF0ZV9lYWNoX2Jsb2NrLFxuXHRuZXh0LFxuXHRnZXRfY29udGV4dFxuKSB7XG5cdGxldCBvID0gb2xkX2Jsb2Nrcy5sZW5ndGg7XG5cdGxldCBuID0gbGlzdC5sZW5ndGg7XG5cdGxldCBpID0gbztcblx0Y29uc3Qgb2xkX2luZGV4ZXMgPSB7fTtcblx0d2hpbGUgKGktLSkgb2xkX2luZGV4ZXNbb2xkX2Jsb2Nrc1tpXS5rZXldID0gaTtcblx0Y29uc3QgbmV3X2Jsb2NrcyA9IFtdO1xuXHRjb25zdCBuZXdfbG9va3VwID0gbmV3IE1hcCgpO1xuXHRjb25zdCBkZWx0YXMgPSBuZXcgTWFwKCk7XG5cdGNvbnN0IHVwZGF0ZXMgPSBbXTtcblx0aSA9IG47XG5cdHdoaWxlIChpLS0pIHtcblx0XHRjb25zdCBjaGlsZF9jdHggPSBnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpO1xuXHRcdGNvbnN0IGtleSA9IGdldF9rZXkoY2hpbGRfY3R4KTtcblx0XHRsZXQgYmxvY2sgPSBsb29rdXAuZ2V0KGtleSk7XG5cdFx0aWYgKCFibG9jaykge1xuXHRcdFx0YmxvY2sgPSBjcmVhdGVfZWFjaF9ibG9jayhrZXksIGNoaWxkX2N0eCk7XG5cdFx0XHRibG9jay5jKCk7XG5cdFx0fSBlbHNlIGlmIChkeW5hbWljKSB7XG5cdFx0XHQvLyBkZWZlciB1cGRhdGVzIHVudGlsIGFsbCB0aGUgRE9NIHNodWZmbGluZyBpcyBkb25lXG5cdFx0XHR1cGRhdGVzLnB1c2goKCkgPT4gYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KSk7XG5cdFx0fVxuXHRcdG5ld19sb29rdXAuc2V0KGtleSwgKG5ld19ibG9ja3NbaV0gPSBibG9jaykpO1xuXHRcdGlmIChrZXkgaW4gb2xkX2luZGV4ZXMpIGRlbHRhcy5zZXQoa2V5LCBNYXRoLmFicyhpIC0gb2xkX2luZGV4ZXNba2V5XSkpO1xuXHR9XG5cdGNvbnN0IHdpbGxfbW92ZSA9IG5ldyBTZXQoKTtcblx0Y29uc3QgZGlkX21vdmUgPSBuZXcgU2V0KCk7XG5cdC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gaW5zZXJ0KGJsb2NrKSB7XG5cdFx0dHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG5cdFx0YmxvY2subShub2RlLCBuZXh0KTtcblx0XHRsb29rdXAuc2V0KGJsb2NrLmtleSwgYmxvY2spO1xuXHRcdG5leHQgPSBibG9jay5maXJzdDtcblx0XHRuLS07XG5cdH1cblx0d2hpbGUgKG8gJiYgbikge1xuXHRcdGNvbnN0IG5ld19ibG9jayA9IG5ld19ibG9ja3NbbiAtIDFdO1xuXHRcdGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3NbbyAtIDFdO1xuXHRcdGNvbnN0IG5ld19rZXkgPSBuZXdfYmxvY2sua2V5O1xuXHRcdGNvbnN0IG9sZF9rZXkgPSBvbGRfYmxvY2sua2V5O1xuXHRcdGlmIChuZXdfYmxvY2sgPT09IG9sZF9ibG9jaykge1xuXHRcdFx0Ly8gZG8gbm90aGluZ1xuXHRcdFx0bmV4dCA9IG5ld19ibG9jay5maXJzdDtcblx0XHRcdG8tLTtcblx0XHRcdG4tLTtcblx0XHR9IGVsc2UgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfa2V5KSkge1xuXHRcdFx0Ly8gcmVtb3ZlIG9sZCBibG9ja1xuXHRcdFx0ZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG5cdFx0XHRvLS07XG5cdFx0fSBlbHNlIGlmICghbG9va3VwLmhhcyhuZXdfa2V5KSB8fCB3aWxsX21vdmUuaGFzKG5ld19rZXkpKSB7XG5cdFx0XHRpbnNlcnQobmV3X2Jsb2NrKTtcblx0XHR9IGVsc2UgaWYgKGRpZF9tb3ZlLmhhcyhvbGRfa2V5KSkge1xuXHRcdFx0by0tO1xuXHRcdH0gZWxzZSBpZiAoZGVsdGFzLmdldChuZXdfa2V5KSA+IGRlbHRhcy5nZXQob2xkX2tleSkpIHtcblx0XHRcdGRpZF9tb3ZlLmFkZChuZXdfa2V5KTtcblx0XHRcdGluc2VydChuZXdfYmxvY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aWxsX21vdmUuYWRkKG9sZF9rZXkpO1xuXHRcdFx0by0tO1xuXHRcdH1cblx0fVxuXHR3aGlsZSAoby0tKSB7XG5cdFx0Y29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvXTtcblx0XHRpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9ibG9jay5rZXkpKSBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcblx0fVxuXHR3aGlsZSAobikgaW5zZXJ0KG5ld19ibG9ja3NbbiAtIDFdKTtcblx0cnVuX2FsbCh1cGRhdGVzKTtcblx0cmV0dXJuIG5ld19ibG9ja3M7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2tleXMoY3R4LCBsaXN0LCBnZXRfY29udGV4dCwgZ2V0X2tleSkge1xuXHRjb25zdCBrZXlzID0gbmV3IE1hcCgpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBrZXkgPSBnZXRfa2V5KGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSkpO1xuXHRcdGlmIChrZXlzLmhhcyhrZXkpKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSAnJztcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhbHVlID0gYHdpdGggdmFsdWUgJyR7U3RyaW5nKGtleSl9JyBgO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBjYW4ndCBzdHJpbmdpZnlcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0YENhbm5vdCBoYXZlIGR1cGxpY2F0ZSBrZXlzIGluIGEga2V5ZWQgZWFjaDogS2V5cyBhdCBpbmRleCAke2tleXMuZ2V0KFxuXHRcdFx0XHRcdGtleVxuXHRcdFx0XHQpfSBhbmQgJHtpfSAke3ZhbHVlfWFyZSBkdXBsaWNhdGVzYFxuXHRcdFx0KTtcblx0XHR9XG5cdFx0a2V5cy5zZXQoa2V5LCBpKTtcblx0fVxufVxuIiwgIi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3NwcmVhZF91cGRhdGUobGV2ZWxzLCB1cGRhdGVzKSB7XG5cdGNvbnN0IHVwZGF0ZSA9IHt9O1xuXHRjb25zdCB0b19udWxsX291dCA9IHt9O1xuXHRjb25zdCBhY2NvdW50ZWRfZm9yID0geyAkJHNjb3BlOiAxIH07XG5cdGxldCBpID0gbGV2ZWxzLmxlbmd0aDtcblx0d2hpbGUgKGktLSkge1xuXHRcdGNvbnN0IG8gPSBsZXZlbHNbaV07XG5cdFx0Y29uc3QgbiA9IHVwZGF0ZXNbaV07XG5cdFx0aWYgKG4pIHtcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIG8pIHtcblx0XHRcdFx0aWYgKCEoa2V5IGluIG4pKSB0b19udWxsX291dFtrZXldID0gMTtcblx0XHRcdH1cblx0XHRcdGZvciAoY29uc3Qga2V5IGluIG4pIHtcblx0XHRcdFx0aWYgKCFhY2NvdW50ZWRfZm9yW2tleV0pIHtcblx0XHRcdFx0XHR1cGRhdGVba2V5XSA9IG5ba2V5XTtcblx0XHRcdFx0XHRhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsZXZlbHNbaV0gPSBuO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG5cdFx0XHRcdGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZvciAoY29uc3Qga2V5IGluIHRvX251bGxfb3V0KSB7XG5cdFx0aWYgKCEoa2V5IGluIHVwZGF0ZSkpIHVwZGF0ZVtrZXldID0gdW5kZWZpbmVkO1xuXHR9XG5cdHJldHVybiB1cGRhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfc3ByZWFkX29iamVjdChzcHJlYWRfcHJvcHMpIHtcblx0cmV0dXJuIHR5cGVvZiBzcHJlYWRfcHJvcHMgPT09ICdvYmplY3QnICYmIHNwcmVhZF9wcm9wcyAhPT0gbnVsbCA/IHNwcmVhZF9wcm9wcyA6IHt9O1xufVxuIiwgImNvbnN0IF9ib29sZWFuX2F0dHJpYnV0ZXMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuXHQnYWxsb3dmdWxsc2NyZWVuJyxcblx0J2FsbG93cGF5bWVudHJlcXVlc3QnLFxuXHQnYXN5bmMnLFxuXHQnYXV0b2ZvY3VzJyxcblx0J2F1dG9wbGF5Jyxcblx0J2NoZWNrZWQnLFxuXHQnY29udHJvbHMnLFxuXHQnZGVmYXVsdCcsXG5cdCdkZWZlcicsXG5cdCdkaXNhYmxlZCcsXG5cdCdmb3Jtbm92YWxpZGF0ZScsXG5cdCdoaWRkZW4nLFxuXHQnaW5lcnQnLFxuXHQnaXNtYXAnLFxuXHQnbG9vcCcsXG5cdCdtdWx0aXBsZScsXG5cdCdtdXRlZCcsXG5cdCdub21vZHVsZScsXG5cdCdub3ZhbGlkYXRlJyxcblx0J29wZW4nLFxuXHQncGxheXNpbmxpbmUnLFxuXHQncmVhZG9ubHknLFxuXHQncmVxdWlyZWQnLFxuXHQncmV2ZXJzZWQnLFxuXHQnc2VsZWN0ZWQnXG5dKTtcblxuLyoqXG4gKiBMaXN0IG9mIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzIChlLmcuIGA8aW5wdXQgZGlzYWJsZWQ+YCkuXG4gKiBTb3VyY2U6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbFxuICpcbiAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGJvb2xlYW5fYXR0cmlidXRlcyA9IG5ldyBTZXQoWy4uLl9ib29sZWFuX2F0dHJpYnV0ZXNdKTtcblxuLyoqIEB0eXBlZGVmIHt0eXBlb2YgX2Jvb2xlYW5fYXR0cmlidXRlc1tudW1iZXJdfSBCb29sZWFuQXR0cmlidXRlcyAqL1xuIiwgImltcG9ydCB7XG5cdGFkZF9yZW5kZXJfY2FsbGJhY2ssXG5cdGZsdXNoLFxuXHRmbHVzaF9yZW5kZXJfY2FsbGJhY2tzLFxuXHRzY2hlZHVsZV91cGRhdGUsXG5cdGRpcnR5X2NvbXBvbmVudHNcbn0gZnJvbSAnLi9zY2hlZHVsZXIuanMnO1xuaW1wb3J0IHsgY3VycmVudF9jb21wb25lbnQsIHNldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IGJsYW5rX29iamVjdCwgaXNfZW1wdHksIGlzX2Z1bmN0aW9uLCBydW4sIHJ1bl9hbGwsIG5vb3AgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdGNoaWxkcmVuLFxuXHRkZXRhY2gsXG5cdHN0YXJ0X2h5ZHJhdGluZyxcblx0ZW5kX2h5ZHJhdGluZyxcblx0Z2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyxcblx0aW5zZXJ0LFxuXHRlbGVtZW50LFxuXHRhdHRyXG59IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IHRyYW5zaXRpb25faW4gfSBmcm9tICcuL3RyYW5zaXRpb25zLmpzJztcblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmQoY29tcG9uZW50LCBuYW1lLCBjYWxsYmFjaykge1xuXHRjb25zdCBpbmRleCA9IGNvbXBvbmVudC4kJC5wcm9wc1tuYW1lXTtcblx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRjb21wb25lbnQuJCQuYm91bmRbaW5kZXhdID0gY2FsbGJhY2s7XG5cdFx0Y2FsbGJhY2soY29tcG9uZW50LiQkLmN0eFtpbmRleF0pO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfY29tcG9uZW50KGJsb2NrKSB7XG5cdGJsb2NrICYmIGJsb2NrLmMoKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX2NvbXBvbmVudChibG9jaywgcGFyZW50X25vZGVzKSB7XG5cdGJsb2NrICYmIGJsb2NrLmwocGFyZW50X25vZGVzKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yKSB7XG5cdGNvbnN0IHsgZnJhZ21lbnQsIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuXHRmcmFnbWVudCAmJiBmcmFnbWVudC5tKHRhcmdldCwgYW5jaG9yKTtcblx0Ly8gb25Nb3VudCBoYXBwZW5zIGJlZm9yZSB0aGUgaW5pdGlhbCBhZnRlclVwZGF0ZVxuXHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IHtcblx0XHRjb25zdCBuZXdfb25fZGVzdHJveSA9IGNvbXBvbmVudC4kJC5vbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuXHRcdC8vIGlmIHRoZSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseVxuXHRcdC8vIGl0IHdpbGwgdXBkYXRlIHRoZSBgJCQub25fZGVzdHJveWAgcmVmZXJlbmNlIHRvIGBudWxsYC5cblx0XHQvLyB0aGUgZGVzdHJ1Y3R1cmVkIG9uX2Rlc3Ryb3kgbWF5IHN0aWxsIHJlZmVyZW5jZSB0byB0aGUgb2xkIGFycmF5XG5cdFx0aWYgKGNvbXBvbmVudC4kJC5vbl9kZXN0cm95KSB7XG5cdFx0XHRjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKC4uLm5ld19vbl9kZXN0cm95KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRWRnZSBjYXNlIC0gY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHksXG5cdFx0XHQvLyBtb3N0IGxpa2VseSBhcyBhIHJlc3VsdCBvZiBhIGJpbmRpbmcgaW5pdGlhbGlzaW5nXG5cdFx0XHRydW5fYWxsKG5ld19vbl9kZXN0cm95KTtcblx0XHR9XG5cdFx0Y29tcG9uZW50LiQkLm9uX21vdW50ID0gW107XG5cdH0pO1xuXHRhZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfY29tcG9uZW50KGNvbXBvbmVudCwgZGV0YWNoaW5nKSB7XG5cdGNvbnN0ICQkID0gY29tcG9uZW50LiQkO1xuXHRpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcblx0XHRmbHVzaF9yZW5kZXJfY2FsbGJhY2tzKCQkLmFmdGVyX3VwZGF0ZSk7XG5cdFx0cnVuX2FsbCgkJC5vbl9kZXN0cm95KTtcblx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5kKGRldGFjaGluZyk7XG5cdFx0Ly8gVE9ETyBudWxsIG91dCBvdGhlciByZWZzLCBpbmNsdWRpbmcgY29tcG9uZW50LiQkIChidXQgbmVlZCB0b1xuXHRcdC8vIHByZXNlcnZlIGZpbmFsIHN0YXRlPylcblx0XHQkJC5vbl9kZXN0cm95ID0gJCQuZnJhZ21lbnQgPSBudWxsO1xuXHRcdCQkLmN0eCA9IFtdO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmZ1bmN0aW9uIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKSB7XG5cdGlmIChjb21wb25lbnQuJCQuZGlydHlbMF0gPT09IC0xKSB7XG5cdFx0ZGlydHlfY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG5cdFx0c2NoZWR1bGVfdXBkYXRlKCk7XG5cdFx0Y29tcG9uZW50LiQkLmRpcnR5LmZpbGwoMCk7XG5cdH1cblx0Y29tcG9uZW50LiQkLmRpcnR5WyhpIC8gMzEpIHwgMF0gfD0gMSA8PCBpICUgMzE7XG59XG5cbi8vIFRPRE86IERvY3VtZW50IHRoZSBvdGhlciBwYXJhbXNcbi8qKlxuICogQHBhcmFtIHtTdmVsdGVDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuQ29tcG9uZW50Q29uc3RydWN0b3JPcHRpb25zfSBvcHRpb25zXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vdXRpbHMuanMnKVsnbm90X2VxdWFsJ119IG5vdF9lcXVhbCBVc2VkIHRvIGNvbXBhcmUgcHJvcHMgYW5kIHN0YXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7KHRhcmdldDogRWxlbWVudCB8IFNoYWRvd1Jvb3QpID0+IHZvaWR9IFthcHBlbmRfc3R5bGVzXSBGdW5jdGlvbiB0aGF0IGFwcGVuZHMgc3R5bGVzIHRvIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGlzIGZpcnN0IGluaXRpYWxpc2VkLlxuICogVGhpcyB3aWxsIGJlIHRoZSBgYWRkX2Nzc2AgZnVuY3Rpb24gZnJvbSB0aGUgY29tcGlsZWQgY29tcG9uZW50LlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdChcblx0Y29tcG9uZW50LFxuXHRvcHRpb25zLFxuXHRpbnN0YW5jZSxcblx0Y3JlYXRlX2ZyYWdtZW50LFxuXHRub3RfZXF1YWwsXG5cdHByb3BzLFxuXHRhcHBlbmRfc3R5bGVzID0gbnVsbCxcblx0ZGlydHkgPSBbLTFdXG4pIHtcblx0Y29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuXHRzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlQkJH0gKi9cblx0Y29uc3QgJCQgPSAoY29tcG9uZW50LiQkID0ge1xuXHRcdGZyYWdtZW50OiBudWxsLFxuXHRcdGN0eDogW10sXG5cdFx0Ly8gc3RhdGVcblx0XHRwcm9wcyxcblx0XHR1cGRhdGU6IG5vb3AsXG5cdFx0bm90X2VxdWFsLFxuXHRcdGJvdW5kOiBibGFua19vYmplY3QoKSxcblx0XHQvLyBsaWZlY3ljbGVcblx0XHRvbl9tb3VudDogW10sXG5cdFx0b25fZGVzdHJveTogW10sXG5cdFx0b25fZGlzY29ubmVjdDogW10sXG5cdFx0YmVmb3JlX3VwZGF0ZTogW10sXG5cdFx0YWZ0ZXJfdXBkYXRlOiBbXSxcblx0XHRjb250ZXh0OiBuZXcgTWFwKG9wdGlvbnMuY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG5cdFx0Ly8gZXZlcnl0aGluZyBlbHNlXG5cdFx0Y2FsbGJhY2tzOiBibGFua19vYmplY3QoKSxcblx0XHRkaXJ0eSxcblx0XHRza2lwX2JvdW5kOiBmYWxzZSxcblx0XHRyb290OiBvcHRpb25zLnRhcmdldCB8fCBwYXJlbnRfY29tcG9uZW50LiQkLnJvb3Rcblx0fSk7XG5cdGFwcGVuZF9zdHlsZXMgJiYgYXBwZW5kX3N0eWxlcygkJC5yb290KTtcblx0bGV0IHJlYWR5ID0gZmFsc2U7XG5cdCQkLmN0eCA9IGluc3RhbmNlXG5cdFx0PyBpbnN0YW5jZShjb21wb25lbnQsIG9wdGlvbnMucHJvcHMgfHwge30sIChpLCByZXQsIC4uLnJlc3QpID0+IHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSByZXN0Lmxlbmd0aCA/IHJlc3RbMF0gOiByZXQ7XG5cdFx0XHRcdGlmICgkJC5jdHggJiYgbm90X2VxdWFsKCQkLmN0eFtpXSwgKCQkLmN0eFtpXSA9IHZhbHVlKSkpIHtcblx0XHRcdFx0XHRpZiAoISQkLnNraXBfYm91bmQgJiYgJCQuYm91bmRbaV0pICQkLmJvdW5kW2ldKHZhbHVlKTtcblx0XHRcdFx0XHRpZiAocmVhZHkpIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdCAgfSlcblx0XHQ6IFtdO1xuXHQkJC51cGRhdGUoKTtcblx0cmVhZHkgPSB0cnVlO1xuXHRydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuXHQvLyBgZmFsc2VgIGFzIGEgc3BlY2lhbCBjYXNlIG9mIG5vIERPTSBjb21wb25lbnRcblx0JCQuZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnQgPyBjcmVhdGVfZnJhZ21lbnQoJCQuY3R4KSA6IGZhbHNlO1xuXHRpZiAob3B0aW9ucy50YXJnZXQpIHtcblx0XHRpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG5cdFx0XHRzdGFydF9oeWRyYXRpbmcoKTtcblx0XHRcdC8vIFRPRE86IHdoYXQgaXMgdGhlIGNvcnJlY3QgdHlwZSBoZXJlP1xuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0Y29uc3Qgbm9kZXMgPSBjaGlsZHJlbihvcHRpb25zLnRhcmdldCk7XG5cdFx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5sKG5vZGVzKTtcblx0XHRcdG5vZGVzLmZvckVhY2goZGV0YWNoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cblx0XHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmMoKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuaW50cm8pIHRyYW5zaXRpb25faW4oY29tcG9uZW50LiQkLmZyYWdtZW50KTtcblx0XHRtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IpO1xuXHRcdGVuZF9oeWRyYXRpbmcoKTtcblx0XHRmbHVzaCgpO1xuXHR9XG5cdHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbn1cblxuZXhwb3J0IGxldCBTdmVsdGVFbGVtZW50O1xuXG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFN2ZWx0ZUVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcblx0XHQvKiogVGhlIFN2ZWx0ZSBjb21wb25lbnQgY29uc3RydWN0b3IgKi9cblx0XHQkJGN0b3I7XG5cdFx0LyoqIFNsb3RzICovXG5cdFx0JCRzO1xuXHRcdC8qKiBUaGUgU3ZlbHRlIGNvbXBvbmVudCBpbnN0YW5jZSAqL1xuXHRcdCQkYztcblx0XHQvKiogV2hldGhlciBvciBub3QgdGhlIGN1c3RvbSBlbGVtZW50IGlzIGNvbm5lY3RlZCAqL1xuXHRcdCQkY24gPSBmYWxzZTtcblx0XHQvKiogQ29tcG9uZW50IHByb3BzIGRhdGEgKi9cblx0XHQkJGQgPSB7fTtcblx0XHQvKiogYHRydWVgIGlmIGN1cnJlbnRseSBpbiB0aGUgcHJvY2VzcyBvZiByZWZsZWN0aW5nIGNvbXBvbmVudCBwcm9wcyBiYWNrIHRvIGF0dHJpYnV0ZXMgKi9cblx0XHQkJHIgPSBmYWxzZTtcblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvbj59IFByb3BzIGRlZmluaXRpb24gKG5hbWUsIHJlZmxlY3RlZCwgdHlwZSBldGMpICovXG5cdFx0JCRwX2QgPSB7fTtcblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEZ1bmN0aW9uW10+fSBFdmVudCBsaXN0ZW5lcnMgKi9cblx0XHQkJGwgPSB7fTtcblx0XHQvKiogQHR5cGUge01hcDxGdW5jdGlvbiwgRnVuY3Rpb24+fSBFdmVudCBsaXN0ZW5lciB1bnN1YnNjcmliZSBmdW5jdGlvbnMgKi9cblx0XHQkJGxfdSA9IG5ldyBNYXAoKTtcblxuXHRcdGNvbnN0cnVjdG9yKCQkY29tcG9uZW50Q3RvciwgJCRzbG90cywgdXNlX3NoYWRvd19kb20pIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLiQkY3RvciA9ICQkY29tcG9uZW50Q3Rvcjtcblx0XHRcdHRoaXMuJCRzID0gJCRzbG90cztcblx0XHRcdGlmICh1c2Vfc2hhZG93X2RvbSkge1xuXHRcdFx0XHR0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG5cdFx0XHQvLyBXZSBjYW4ndCBkZXRlcm1pbmUgdXBmcm9udCBpZiB0aGUgZXZlbnQgaXMgYSBjdXN0b20gZXZlbnQgb3Igbm90LCBzbyB3ZSBoYXZlIHRvXG5cdFx0XHQvLyBsaXN0ZW4gdG8gYm90aC4gSWYgc29tZW9uZSB1c2VzIGEgY3VzdG9tIGV2ZW50IHdpdGggdGhlIHNhbWUgbmFtZSBhcyBhIHJlZ3VsYXJcblx0XHRcdC8vIGJyb3dzZXIgZXZlbnQsIHRoaXMgZmlyZXMgdHdpY2UgLSB3ZSBjYW4ndCBhdm9pZCB0aGF0LlxuXHRcdFx0dGhpcy4kJGxbdHlwZV0gPSB0aGlzLiQkbFt0eXBlXSB8fCBbXTtcblx0XHRcdHRoaXMuJCRsW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuXHRcdFx0aWYgKHRoaXMuJCRjKSB7XG5cdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGMuJG9uKHR5cGUsIGxpc3RlbmVyKTtcblx0XHRcdFx0dGhpcy4kJGxfdS5zZXQobGlzdGVuZXIsIHVuc3ViKTtcblx0XHRcdH1cblx0XHRcdHN1cGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcblx0XHRcdHN1cGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKHRoaXMuJCRjKSB7XG5cdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGxfdS5nZXQobGlzdGVuZXIpO1xuXHRcdFx0XHRpZiAodW5zdWIpIHtcblx0XHRcdFx0XHR1bnN1YigpO1xuXHRcdFx0XHRcdHRoaXMuJCRsX3UuZGVsZXRlKGxpc3RlbmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFzeW5jIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuXHRcdFx0dGhpcy4kJGNuID0gdHJ1ZTtcblx0XHRcdGlmICghdGhpcy4kJGMpIHtcblx0XHRcdFx0Ly8gV2Ugd2FpdCBvbmUgdGljayB0byBsZXQgcG9zc2libGUgY2hpbGQgc2xvdCBlbGVtZW50cyBiZSBjcmVhdGVkL21vdW50ZWRcblx0XHRcdFx0YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHRcdGlmICghdGhpcy4kJGNuKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmN0aW9uIGNyZWF0ZV9zbG90KG5hbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IG5vZGU7XG5cdFx0XHRcdFx0XHRjb25zdCBvYmogPSB7XG5cdFx0XHRcdFx0XHRcdGM6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbWVudCgnc2xvdCcpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChuYW1lICE9PSAnZGVmYXVsdCcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGF0dHIobm9kZSwgJ25hbWUnLCBuYW1lKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdFx0XHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcblx0XHRcdFx0XHRcdFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2FuY2hvcl1cblx0XHRcdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0XHRcdG06IGZ1bmN0aW9uIG1vdW50KHRhcmdldCwgYW5jaG9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZDogZnVuY3Rpb24gZGVzdHJveShkZXRhY2hpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZGV0YWNoaW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZXRhY2gobm9kZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0ICQkc2xvdHMgPSB7fTtcblx0XHRcdFx0Y29uc3QgZXhpc3Rpbmdfc2xvdHMgPSBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKHRoaXMpO1xuXHRcdFx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy4kJHMpIHtcblx0XHRcdFx0XHRpZiAobmFtZSBpbiBleGlzdGluZ19zbG90cykge1xuXHRcdFx0XHRcdFx0JCRzbG90c1tuYW1lXSA9IFtjcmVhdGVfc2xvdChuYW1lKV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoY29uc3QgYXR0cmlidXRlIG9mIHRoaXMuYXR0cmlidXRlcykge1xuXHRcdFx0XHRcdC8vIHRoaXMuJCRkYXRhIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzLmF0dHJpYnV0ZXNcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gdGhpcy4kJGdfcChhdHRyaWJ1dGUubmFtZSk7XG5cdFx0XHRcdFx0aWYgKCEobmFtZSBpbiB0aGlzLiQkZCkpIHtcblx0XHRcdFx0XHRcdHRoaXMuJCRkW25hbWVdID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKG5hbWUsIGF0dHJpYnV0ZS52YWx1ZSwgdGhpcy4kJHBfZCwgJ3RvUHJvcCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBQb3J0IG92ZXIgcHJvcHMgdGhhdCB3ZXJlIHNldCBwcm9ncmFtbWF0aWNhbGx5IGJlZm9yZSBjZSB3YXMgaW5pdGlhbGl6ZWRcblx0XHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gdGhpcy4kJHBfZCkge1xuXHRcdFx0XHRcdGlmICghKGtleSBpbiB0aGlzLiQkZCkgJiYgdGhpc1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRoaXMuJCRkW2tleV0gPSB0aGlzW2tleV07IC8vIGRvbid0IHRyYW5zZm9ybSwgdGhlc2Ugd2VyZSBzZXQgdGhyb3VnaCBKYXZhU2NyaXB0XG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpc1trZXldOyAvLyByZW1vdmUgdGhlIHByb3BlcnR5IHRoYXQgc2hhZG93cyB0aGUgZ2V0dGVyL3NldHRlclxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLiQkYyA9IG5ldyB0aGlzLiQkY3Rvcih7XG5cdFx0XHRcdFx0dGFyZ2V0OiB0aGlzLnNoYWRvd1Jvb3QgfHwgdGhpcyxcblx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0Li4udGhpcy4kJGQsXG5cdFx0XHRcdFx0XHQkJHNsb3RzLFxuXHRcdFx0XHRcdFx0JCRzY29wZToge1xuXHRcdFx0XHRcdFx0XHRjdHg6IFtdXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBSZWZsZWN0IGNvbXBvbmVudCBwcm9wcyBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdGNvbnN0IHJlZmxlY3RfYXR0cmlidXRlcyA9ICgpID0+IHtcblx0XHRcdFx0XHR0aGlzLiQkciA9IHRydWU7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gdGhpcy4kJHBfZCkge1xuXHRcdFx0XHRcdFx0dGhpcy4kJGRba2V5XSA9IHRoaXMuJCRjLiQkLmN0eFt0aGlzLiQkYy4kJC5wcm9wc1trZXldXTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLiQkcF9kW2tleV0ucmVmbGVjdCkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVfdmFsdWUgPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUoXG5cdFx0XHRcdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuJCRkW2tleV0sXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy4kJHBfZCxcblx0XHRcdFx0XHRcdFx0XHQndG9BdHRyaWJ1dGUnXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGlmIChhdHRyaWJ1dGVfdmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRlKHRoaXMuJCRwX2Rba2V5XS5hdHRyaWJ1dGUgfHwga2V5KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSh0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlIHx8IGtleSwgYXR0cmlidXRlX3ZhbHVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLiQkciA9IGZhbHNlO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLiQkYy4kJC5hZnRlcl91cGRhdGUucHVzaChyZWZsZWN0X2F0dHJpYnV0ZXMpO1xuXHRcdFx0XHRyZWZsZWN0X2F0dHJpYnV0ZXMoKTsgLy8gb25jZSBpbml0aWFsbHkgYmVjYXVzZSBhZnRlcl91cGRhdGUgaXMgYWRkZWQgdG9vIGxhdGUgZm9yIGZpcnN0IHJlbmRlclxuXG5cdFx0XHRcdGZvciAoY29uc3QgdHlwZSBpbiB0aGlzLiQkbCkge1xuXHRcdFx0XHRcdGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4kJGxbdHlwZV0pIHtcblx0XHRcdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGMuJG9uKHR5cGUsIGxpc3RlbmVyKTtcblx0XHRcdFx0XHRcdHRoaXMuJCRsX3Uuc2V0KGxpc3RlbmVyLCB1bnN1Yik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuJCRsID0ge307XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gV2UgZG9uJ3QgbmVlZCB0aGlzIHdoZW4gd29ya2luZyB3aXRoaW4gU3ZlbHRlIGNvZGUsIGJ1dCBmb3IgY29tcGF0aWJpbGl0eSBvZiBwZW9wbGUgdXNpbmcgdGhpcyBvdXRzaWRlIG9mIFN2ZWx0ZVxuXHRcdC8vIGFuZCBzZXR0aW5nIGF0dHJpYnV0ZXMgdGhyb3VnaCBzZXRBdHRyaWJ1dGUgZXRjLCB0aGlzIGlzIGhlbHBmdWxcblx0XHRhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgX29sZFZhbHVlLCBuZXdWYWx1ZSkge1xuXHRcdFx0aWYgKHRoaXMuJCRyKSByZXR1cm47XG5cdFx0XHRhdHRyID0gdGhpcy4kJGdfcChhdHRyKTtcblx0XHRcdHRoaXMuJCRkW2F0dHJdID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKGF0dHIsIG5ld1ZhbHVlLCB0aGlzLiQkcF9kLCAndG9Qcm9wJyk7XG5cdFx0XHR0aGlzLiQkYz8uJHNldCh7IFthdHRyXTogdGhpcy4kJGRbYXR0cl0gfSk7XG5cdFx0fVxuXG5cdFx0ZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cdFx0XHR0aGlzLiQkY24gPSBmYWxzZTtcblx0XHRcdC8vIEluIGEgbWljcm90YXNrLCBiZWNhdXNlIHRoaXMgY291bGQgYmUgYSBtb3ZlIHdpdGhpbiB0aGUgRE9NXG5cdFx0XHRQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHRcdFx0aWYgKCF0aGlzLiQkY24pIHtcblx0XHRcdFx0XHR0aGlzLiQkYy4kZGVzdHJveSgpO1xuXHRcdFx0XHRcdHRoaXMuJCRjID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQkJGdfcChhdHRyaWJ1dGVfbmFtZSkge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0T2JqZWN0LmtleXModGhpcy4kJHBfZCkuZmluZChcblx0XHRcdFx0XHQoa2V5KSA9PlxuXHRcdFx0XHRcdFx0dGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSA9PT0gYXR0cmlidXRlX25hbWUgfHxcblx0XHRcdFx0XHRcdCghdGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gYXR0cmlidXRlX25hbWUpXG5cdFx0XHRcdCkgfHwgYXR0cmlidXRlX25hbWVcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gcHJvcHNfZGVmaW5pdGlvblxuICogQHBhcmFtIHsndG9BdHRyaWJ1dGUnIHwgJ3RvUHJvcCd9IFt0cmFuc2Zvcm1dXG4gKi9cbmZ1bmN0aW9uIGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShwcm9wLCB2YWx1ZSwgcHJvcHNfZGVmaW5pdGlvbiwgdHJhbnNmb3JtKSB7XG5cdGNvbnN0IHR5cGUgPSBwcm9wc19kZWZpbml0aW9uW3Byb3BdPy50eXBlO1xuXHR2YWx1ZSA9IHR5cGUgPT09ICdCb29sZWFuJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJyA/IHZhbHVlICE9IG51bGwgOiB2YWx1ZTtcblx0aWYgKCF0cmFuc2Zvcm0gfHwgIXByb3BzX2RlZmluaXRpb25bcHJvcF0pIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0gZWxzZSBpZiAodHJhbnNmb3JtID09PSAndG9BdHRyaWJ1dGUnKSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJycgOiBudWxsO1xuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBudWxsIDogdmFsdWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnT2JqZWN0Jzpcblx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlICYmIEpTT04ucGFyc2UodmFsdWUpO1xuXHRcdFx0Y2FzZSAnQm9vbGVhbic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTsgLy8gY29udmVyc2lvbiBhbHJlYWR5IGhhbmRsZWQgYWJvdmVcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAhPSBudWxsID8gK3ZhbHVlIDogdmFsdWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKlxuICogVHVybiBhIFN2ZWx0ZSBjb21wb25lbnQgaW50byBhIGN1c3RvbSBlbGVtZW50LlxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuQ29tcG9uZW50VHlwZX0gQ29tcG9uZW50ICBBIFN2ZWx0ZSBjb21wb25lbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gcHJvcHNfZGVmaW5pdGlvbiAgVGhlIHByb3BzIHRvIG9ic2VydmVcbiAqIEBwYXJhbSB7c3RyaW5nW119IHNsb3RzICBUaGUgc2xvdHMgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhY2Nlc3NvcnMgIE90aGVyIGFjY2Vzc29ycyBiZXNpZGVzIHRoZSBvbmVzIGZvciBwcm9wcyB0aGUgY29tcG9uZW50IGhhc1xuICogQHBhcmFtIHtib29sZWFufSB1c2Vfc2hhZG93X2RvbSAgV2hldGhlciB0byB1c2Ugc2hhZG93IERPTVxuICogQHBhcmFtIHsoY2U6IG5ldyAoKSA9PiBIVE1MRWxlbWVudCkgPT4gbmV3ICgpID0+IEhUTUxFbGVtZW50fSBbZXh0ZW5kXVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2N1c3RvbV9lbGVtZW50KFxuXHRDb21wb25lbnQsXG5cdHByb3BzX2RlZmluaXRpb24sXG5cdHNsb3RzLFxuXHRhY2Nlc3NvcnMsXG5cdHVzZV9zaGFkb3dfZG9tLFxuXHRleHRlbmRcbikge1xuXHRsZXQgQ2xhc3MgPSBjbGFzcyBleHRlbmRzIFN2ZWx0ZUVsZW1lbnQge1xuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0c3VwZXIoQ29tcG9uZW50LCBzbG90cywgdXNlX3NoYWRvd19kb20pO1xuXHRcdFx0dGhpcy4kJHBfZCA9IHByb3BzX2RlZmluaXRpb247XG5cdFx0fVxuXHRcdHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKHByb3BzX2RlZmluaXRpb24pLm1hcCgoa2V5KSA9PlxuXHRcdFx0XHQocHJvcHNfZGVmaW5pdGlvbltrZXldLmF0dHJpYnV0ZSB8fCBrZXkpLnRvTG93ZXJDYXNlKClcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xuXHRPYmplY3Qua2V5cyhwcm9wc19kZWZpbml0aW9uKS5mb3JFYWNoKChwcm9wKSA9PiB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgcHJvcCwge1xuXHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy4kJGMgJiYgcHJvcCBpbiB0aGlzLiQkYyA/IHRoaXMuJCRjW3Byb3BdIDogdGhpcy4kJGRbcHJvcF07XG5cdFx0XHR9LFxuXHRcdFx0c2V0KHZhbHVlKSB7XG5cdFx0XHRcdHZhbHVlID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKHByb3AsIHZhbHVlLCBwcm9wc19kZWZpbml0aW9uKTtcblx0XHRcdFx0dGhpcy4kJGRbcHJvcF0gPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy4kJGM/LiRzZXQoeyBbcHJvcF06IHZhbHVlIH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0YWNjZXNzb3JzLmZvckVhY2goKGFjY2Vzc29yKSA9PiB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgYWNjZXNzb3IsIHtcblx0XHRcdGdldCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuJCRjPy5bYWNjZXNzb3JdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0aWYgKGV4dGVuZCkge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgLSBhc3NpZ25pbmcgaGVyZSBpcyBmaW5lXG5cdFx0Q2xhc3MgPSBleHRlbmQoQ2xhc3MpO1xuXHR9XG5cdENvbXBvbmVudC5lbGVtZW50ID0gLyoqIEB0eXBlIHthbnl9ICovIChDbGFzcyk7XG5cdHJldHVybiBDbGFzcztcbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cy4gVXNlZCB3aGVuIGRldj1mYWxzZS5cbiAqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtQcm9wcz1hbnldXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtFdmVudHM9YW55XVxuICovXG5leHBvcnQgY2xhc3MgU3ZlbHRlQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqICMjIyBQUklWQVRFIEFQSVxuXHQgKlxuXHQgKiBEbyBub3QgdXNlLCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lXG5cdCAqXG5cdCAqIEB0eXBlIHthbnl9XG5cdCAqL1xuXHQkJCA9IHVuZGVmaW5lZDtcblx0LyoqXG5cdCAqICMjIyBQUklWQVRFIEFQSVxuXHQgKlxuXHQgKiBEbyBub3QgdXNlLCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lXG5cdCAqXG5cdCAqIEB0eXBlIHthbnl9XG5cdCAqL1xuXHQkJHNldCA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHJldHVybnMge3ZvaWR9ICovXG5cdCRkZXN0cm95KCkge1xuXHRcdGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuXHRcdHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0ZW1wbGF0ZSB7RXh0cmFjdDxrZXlvZiBFdmVudHMsIHN0cmluZz59IEtcblx0ICogQHBhcmFtIHtLfSB0eXBlXG5cdCAqIEBwYXJhbSB7KChlOiBFdmVudHNbS10pID0+IHZvaWQpIHwgbnVsbCB8IHVuZGVmaW5lZH0gY2FsbGJhY2tcblx0ICogQHJldHVybnMgeygpID0+IHZvaWR9XG5cdCAqL1xuXHQkb24odHlwZSwgY2FsbGJhY2spIHtcblx0XHRpZiAoIWlzX2Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuXHRcdFx0cmV0dXJuIG5vb3A7XG5cdFx0fVxuXHRcdGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKTtcblx0XHRjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1BhcnRpYWw8UHJvcHM+fSBwcm9wc1xuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdCRzZXQocHJvcHMpIHtcblx0XHRpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkocHJvcHMpKSB7XG5cdFx0XHR0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuXHRcdFx0dGhpcy4kJHNldChwcm9wcyk7XG5cdFx0XHR0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXR0cmlidXRlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVmbGVjdF1cbiAqIEBwcm9wZXJ0eSB7J1N0cmluZyd8J0Jvb2xlYW4nfCdOdW1iZXInfCdBcnJheSd8J09iamVjdCd9IFt0eXBlXVxuICovXG4iLCAiLy8gZ2VuZXJhdGVkIGR1cmluZyByZWxlYXNlLCBkbyBub3QgbW9kaWZ5XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgdmVyc2lvbiwgYXMgc2V0IGluIHBhY2thZ2UuanNvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtY29tcGlsZXIjc3ZlbHRlLXZlcnNpb25cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzQuMi45JztcbmV4cG9ydCBjb25zdCBQVUJMSUNfVkVSU0lPTiA9ICc0JztcbiIsICJpbXBvcnQgeyBQVUJMSUNfVkVSU0lPTiB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC92ZXJzaW9uLmpzJztcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxuXHQvLyBAdHMtaWdub3JlXG5cdCh3aW5kb3cuX19zdmVsdGUgfHwgKHdpbmRvdy5fX3N2ZWx0ZSA9IHsgdjogbmV3IFNldCgpIH0pKS52LmFkZChQVUJMSUNfVkVSU0lPTik7XG4iLCAiaW1wb3J0IHtcblx0cnVuX2FsbCxcblx0c3Vic2NyaWJlLFxuXHRub29wLFxuXHRzYWZlX25vdF9lcXVhbCxcblx0aXNfZnVuY3Rpb24sXG5cdGdldF9zdG9yZV92YWx1ZVxufSBmcm9tICcuLi9pbnRlcm5hbC9pbmRleC5qcyc7XG5cbmNvbnN0IHN1YnNjcmliZXJfcXVldWUgPSBbXTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYFJlYWRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjcmVhZGFibGVcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IFt2YWx1ZV0gaW5pdGlhbCB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuU3RhcnRTdG9wTm90aWZpZXI8VD59IFtzdGFydF1cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuUmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkYWJsZSh2YWx1ZSwgc3RhcnQpIHtcblx0cmV0dXJuIHtcblx0XHRzdWJzY3JpYmU6IHdyaXRhYmxlKHZhbHVlLCBzdGFydCkuc3Vic2NyaWJlXG5cdH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFdyaXRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyBib3RoIHVwZGF0aW5nIGFuZCByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjd3JpdGFibGVcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IFt2YWx1ZV0gaW5pdGlhbCB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuU3RhcnRTdG9wTm90aWZpZXI8VD59IFtzdGFydF1cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuV3JpdGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQgPSBub29wKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlVuc3Vic2NyaWJlcn0gKi9cblx0bGV0IHN0b3A7XG5cdC8qKiBAdHlwZSB7U2V0PGltcG9ydCgnLi9wcml2YXRlLmpzJykuU3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlPFQ+Pn0gKi9cblx0Y29uc3Qgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG5cdC8qKiBAcGFyYW0ge1R9IG5ld192YWx1ZVxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIHNldChuZXdfdmFsdWUpIHtcblx0XHRpZiAoc2FmZV9ub3RfZXF1YWwodmFsdWUsIG5ld192YWx1ZSkpIHtcblx0XHRcdHZhbHVlID0gbmV3X3ZhbHVlO1xuXHRcdFx0aWYgKHN0b3ApIHtcblx0XHRcdFx0Ly8gc3RvcmUgaXMgcmVhZHlcblx0XHRcdFx0Y29uc3QgcnVuX3F1ZXVlID0gIXN1YnNjcmliZXJfcXVldWUubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGNvbnN0IHN1YnNjcmliZXIgb2Ygc3Vic2NyaWJlcnMpIHtcblx0XHRcdFx0XHRzdWJzY3JpYmVyWzFdKCk7XG5cdFx0XHRcdFx0c3Vic2NyaWJlcl9xdWV1ZS5wdXNoKHN1YnNjcmliZXIsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocnVuX3F1ZXVlKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlW2ldWzBdKHN1YnNjcmliZXJfcXVldWVbaSArIDFdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGggPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlVwZGF0ZXI8VD59IGZuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlKGZuKSB7XG5cdFx0c2V0KGZuKHZhbHVlKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuU3Vic2NyaWJlcjxUPn0gcnVuXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5JbnZhbGlkYXRvcjxUPn0gW2ludmFsaWRhdGVdXG5cdCAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuVW5zdWJzY3JpYmVyfVxuXHQgKi9cblx0ZnVuY3Rpb24gc3Vic2NyaWJlKHJ1biwgaW52YWxpZGF0ZSA9IG5vb3ApIHtcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuU3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlPFQ+fSAqL1xuXHRcdGNvbnN0IHN1YnNjcmliZXIgPSBbcnVuLCBpbnZhbGlkYXRlXTtcblx0XHRzdWJzY3JpYmVycy5hZGQoc3Vic2NyaWJlcik7XG5cdFx0aWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDEpIHtcblx0XHRcdHN0b3AgPSBzdGFydChzZXQsIHVwZGF0ZSkgfHwgbm9vcDtcblx0XHR9XG5cdFx0cnVuKHZhbHVlKTtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0c3Vic2NyaWJlcnMuZGVsZXRlKHN1YnNjcmliZXIpO1xuXHRcdFx0aWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDAgJiYgc3RvcCkge1xuXHRcdFx0XHRzdG9wKCk7XG5cdFx0XHRcdHN0b3AgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0cmV0dXJuIHsgc2V0LCB1cGRhdGUsIHN1YnNjcmliZSB9O1xufVxuXG4vKipcbiAqIERlcml2ZWQgdmFsdWUgc3RvcmUgYnkgc3luY2hyb25pemluZyBvbmUgb3IgbW9yZSByZWFkYWJsZSBzdG9yZXMgYW5kXG4gKiBhcHBseWluZyBhbiBhZ2dyZWdhdGlvbiBmdW5jdGlvbiBvdmVyIGl0cyBpbnB1dCB2YWx1ZXMuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI2Rlcml2ZWRcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7U30gc3RvcmVzIC0gaW5wdXQgc3RvcmVzXG4gKiBAcGFyYW0geyh2YWx1ZXM6IGltcG9ydCgnLi9wcml2YXRlLmpzJykuU3RvcmVzVmFsdWVzPFM+LCBzZXQ6ICh2YWx1ZTogVCkgPT4gdm9pZCwgdXBkYXRlOiAoZm46IGltcG9ydCgnLi9wdWJsaWMuanMnKS5VcGRhdGVyPFQ+KSA9PiB2b2lkKSA9PiBpbXBvcnQoJy4vcHVibGljLmpzJykuVW5zdWJzY3JpYmVyIHwgdm9pZH0gZm4gLSBmdW5jdGlvbiBjYWxsYmFjayB0aGF0IGFnZ3JlZ2F0ZXMgdGhlIHZhbHVlc1xuICogQHBhcmFtIHtUfSBbaW5pdGlhbF92YWx1ZV0gLSBpbml0aWFsIHZhbHVlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fVxuICovXG5cbi8qKlxuICogRGVyaXZlZCB2YWx1ZSBzdG9yZSBieSBzeW5jaHJvbml6aW5nIG9uZSBvciBtb3JlIHJlYWRhYmxlIHN0b3JlcyBhbmRcbiAqIGFwcGx5aW5nIGFuIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uIG92ZXIgaXRzIGlucHV0IHZhbHVlcy5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjZGVyaXZlZFxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlN0b3Jlc30gU1xuICogQHRlbXBsYXRlIFRcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtTfSBzdG9yZXMgLSBpbnB1dCBzdG9yZXNcbiAqIEBwYXJhbSB7KHZhbHVlczogaW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdG9yZXNWYWx1ZXM8Uz4pID0+IFR9IGZuIC0gZnVuY3Rpb24gY2FsbGJhY2sgdGhhdCBhZ2dyZWdhdGVzIHRoZSB2YWx1ZXNcbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdIC0gaW5pdGlhbCB2YWx1ZVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn1cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N9IHN0b3Jlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZChzdG9yZXMsIGZuLCBpbml0aWFsX3ZhbHVlKSB7XG5cdGNvbnN0IHNpbmdsZSA9ICFBcnJheS5pc0FycmF5KHN0b3Jlcyk7XG5cdC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPGFueT4+fSAqL1xuXHRjb25zdCBzdG9yZXNfYXJyYXkgPSBzaW5nbGUgPyBbc3RvcmVzXSA6IHN0b3Jlcztcblx0aWYgKCFzdG9yZXNfYXJyYXkuZXZlcnkoQm9vbGVhbikpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Rlcml2ZWQoKSBleHBlY3RzIHN0b3JlcyBhcyBpbnB1dCwgZ290IGEgZmFsc3kgdmFsdWUnKTtcblx0fVxuXHRjb25zdCBhdXRvID0gZm4ubGVuZ3RoIDwgMjtcblx0cmV0dXJuIHJlYWRhYmxlKGluaXRpYWxfdmFsdWUsIChzZXQsIHVwZGF0ZSkgPT4ge1xuXHRcdGxldCBzdGFydGVkID0gZmFsc2U7XG5cdFx0Y29uc3QgdmFsdWVzID0gW107XG5cdFx0bGV0IHBlbmRpbmcgPSAwO1xuXHRcdGxldCBjbGVhbnVwID0gbm9vcDtcblx0XHRjb25zdCBzeW5jID0gKCkgPT4ge1xuXHRcdFx0aWYgKHBlbmRpbmcpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gZm4oc2luZ2xlID8gdmFsdWVzWzBdIDogdmFsdWVzLCBzZXQsIHVwZGF0ZSk7XG5cdFx0XHRpZiAoYXV0bykge1xuXHRcdFx0XHRzZXQocmVzdWx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsZWFudXAgPSBpc19mdW5jdGlvbihyZXN1bHQpID8gcmVzdWx0IDogbm9vcDtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGNvbnN0IHVuc3Vic2NyaWJlcnMgPSBzdG9yZXNfYXJyYXkubWFwKChzdG9yZSwgaSkgPT5cblx0XHRcdHN1YnNjcmliZShcblx0XHRcdFx0c3RvcmUsXG5cdFx0XHRcdCh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHZhbHVlc1tpXSA9IHZhbHVlO1xuXHRcdFx0XHRcdHBlbmRpbmcgJj0gfigxIDw8IGkpO1xuXHRcdFx0XHRcdGlmIChzdGFydGVkKSB7XG5cdFx0XHRcdFx0XHRzeW5jKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQoKSA9PiB7XG5cdFx0XHRcdFx0cGVuZGluZyB8PSAxIDw8IGk7XG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHQpO1xuXHRcdHN0YXJ0ZWQgPSB0cnVlO1xuXHRcdHN5bmMoKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gc3RvcCgpIHtcblx0XHRcdHJ1bl9hbGwodW5zdWJzY3JpYmVycyk7XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHQvLyBXZSBuZWVkIHRvIHNldCB0aGlzIHRvIGZhbHNlIGJlY2F1c2UgY2FsbGJhY2tzIGNhbiBzdGlsbCBoYXBwZW4gZGVzcGl0ZSBoYXZpbmcgdW5zdWJzY3JpYmVkOlxuXHRcdFx0Ly8gQ2FsbGJhY2tzIG1pZ2h0IGFscmVhZHkgYmUgcGxhY2VkIGluIHRoZSBxdWV1ZSB3aGljaCBkb2Vzbid0IGtub3cgaXQgc2hvdWxkIG5vIGxvbmdlclxuXHRcdFx0Ly8gaW52b2tlIHRoaXMgZGVyaXZlZCBzdG9yZS5cblx0XHRcdHN0YXJ0ZWQgPSBmYWxzZTtcblx0XHR9O1xuXHR9KTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHN0b3JlIGFuZCByZXR1cm5zIGEgbmV3IG9uZSBkZXJpdmVkIGZyb20gdGhlIG9sZCBvbmUgdGhhdCBpcyByZWFkYWJsZS5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjcmVhZG9ubHlcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn0gc3RvcmUgIC0gc3RvcmUgdG8gbWFrZSByZWFkb25seVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRvbmx5KHN0b3JlKSB7XG5cdHJldHVybiB7XG5cdFx0c3Vic2NyaWJlOiBzdG9yZS5zdWJzY3JpYmUuYmluZChzdG9yZSlcblx0fTtcbn1cblxuZXhwb3J0IHsgZ2V0X3N0b3JlX3ZhbHVlIGFzIGdldCB9O1xuIiwgIi8vIDo6LSBQZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhbiBvcmRlcmVkIG1hcHBpbmcgZnJvbVxuLy8gc3RyaW5ncyB0byB2YWx1ZXMsIHdpdGggc29tZSBjb252ZW5pZW50IHVwZGF0ZSBtZXRob2RzLlxuZnVuY3Rpb24gT3JkZXJlZE1hcChjb250ZW50KSB7XG4gIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG59XG5cbk9yZGVyZWRNYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogT3JkZXJlZE1hcCxcblxuICBmaW5kOiBmdW5jdGlvbihrZXkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIGlmICh0aGlzLmNvbnRlbnRbaV0gPT09IGtleSkgcmV0dXJuIGlcbiAgICByZXR1cm4gLTFcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nKSBcdTIxOTIgP2FueVxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWUgc3RvcmVkIHVuZGVyIGBrZXlgLCBvciByZXR1cm4gdW5kZWZpbmVkIHdoZW5cbiAgLy8gbm8gc3VjaCBrZXkgZXhpc3RzLlxuICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZChrZXkpO1xuICAgIHJldHVybiBmb3VuZCA9PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMuY29udGVudFtmb3VuZCArIDFdXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgYW55LCA/c3RyaW5nKSBcdTIxOTIgT3JkZXJlZE1hcFxuICAvLyBDcmVhdGUgYSBuZXcgbWFwIGJ5IHJlcGxhY2luZyB0aGUgdmFsdWUgb2YgYGtleWAgd2l0aCBhIG5ld1xuICAvLyB2YWx1ZSwgb3IgYWRkaW5nIGEgYmluZGluZyB0byB0aGUgZW5kIG9mIHRoZSBtYXAuIElmIGBuZXdLZXlgIGlzXG4gIC8vIGdpdmVuLCB0aGUga2V5IG9mIHRoZSBiaW5kaW5nIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGF0IGtleS5cbiAgdXBkYXRlOiBmdW5jdGlvbihrZXksIHZhbHVlLCBuZXdLZXkpIHtcbiAgICB2YXIgc2VsZiA9IG5ld0tleSAmJiBuZXdLZXkgIT0ga2V5ID8gdGhpcy5yZW1vdmUobmV3S2V5KSA6IHRoaXM7XG4gICAgdmFyIGZvdW5kID0gc2VsZi5maW5kKGtleSksIGNvbnRlbnQgPSBzZWxmLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBpZiAoZm91bmQgPT0gLTEpIHtcbiAgICAgIGNvbnRlbnQucHVzaChuZXdLZXkgfHwga2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnRbZm91bmQgKyAxXSA9IHZhbHVlO1xuICAgICAgaWYgKG5ld0tleSkgY29udGVudFtmb3VuZF0gPSBuZXdLZXk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcpIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIFJldHVybiBhIG1hcCB3aXRoIHRoZSBnaXZlbiBrZXkgcmVtb3ZlZCwgaWYgaXQgZXhpc3RlZC5cbiAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmZpbmQoa2V5KTtcbiAgICBpZiAoZm91bmQgPT0gLTEpIHJldHVybiB0aGlzXG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBjb250ZW50LnNwbGljZShmb3VuZCwgMik7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgYW55KSBcdTIxOTIgT3JkZXJlZE1hcFxuICAvLyBBZGQgYSBuZXcga2V5IHRvIHRoZSBzdGFydCBvZiB0aGUgbWFwLlxuICBhZGRUb1N0YXJ0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKFtrZXksIHZhbHVlXS5jb25jYXQodGhpcy5yZW1vdmUoa2V5KS5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnkpIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIG5ldyBrZXkgdG8gdGhlIGVuZCBvZiB0aGUgbWFwLlxuICBhZGRUb0VuZDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBjb250ZW50ID0gdGhpcy5yZW1vdmUoa2V5KS5jb250ZW50LnNsaWNlKCk7XG4gICAgY29udGVudC5wdXNoKGtleSwgdmFsdWUpO1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcsIHN0cmluZywgYW55KSBcdTIxOTIgT3JkZXJlZE1hcFxuICAvLyBBZGQgYSBrZXkgYWZ0ZXIgdGhlIGdpdmVuIGtleS4gSWYgYHBsYWNlYCBpcyBub3QgZm91bmQsIHRoZSBuZXdcbiAgLy8ga2V5IGlzIGFkZGVkIHRvIHRoZSBlbmQuXG4gIGFkZEJlZm9yZTogZnVuY3Rpb24ocGxhY2UsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgd2l0aG91dCA9IHRoaXMucmVtb3ZlKGtleSksIGNvbnRlbnQgPSB3aXRob3V0LmNvbnRlbnQuc2xpY2UoKTtcbiAgICB2YXIgZm91bmQgPSB3aXRob3V0LmZpbmQocGxhY2UpO1xuICAgIGNvbnRlbnQuc3BsaWNlKGZvdW5kID09IC0xID8gY29udGVudC5sZW5ndGggOiBmb3VuZCwgMCwga2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkpXG4gIC8vIENhbGwgdGhlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyIGluIHRoZSBtYXAsIGluXG4gIC8vIG9yZGVyLlxuICBmb3JFYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpICs9IDIpXG4gICAgICBmKHRoaXMuY29udGVudFtpXSwgdGhpcy5jb250ZW50W2kgKyAxXSk7XG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgcHJlcGVuZGluZyB0aGUga2V5cyBpbiB0aGlzIG1hcCB0aGF0IGRvbid0XG4gIC8vIGFwcGVhciBpbiBgbWFwYCBiZWZvcmUgdGhlIGtleXMgaW4gYG1hcGAuXG4gIHByZXBlbmQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGlmICghbWFwLnNpemUpIHJldHVybiB0aGlzXG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKG1hcC5jb250ZW50LmNvbmNhdCh0aGlzLnN1YnRyYWN0KG1hcCkuY29udGVudCkpXG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgYXBwZW5kaW5nIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgIGFmdGVyIHRoZSBrZXlzIGluIGBtYXBgLlxuICBhcHBlbmQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGlmICghbWFwLnNpemUpIHJldHVybiB0aGlzXG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKHRoaXMuc3VidHJhY3QobWFwKS5jb250ZW50LmNvbmNhdChtYXAuY29udGVudCkpXG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG1hcCBjb250YWluaW5nIGFsbCB0aGUga2V5cyBpbiB0aGlzIG1hcCB0aGF0IGRvbid0XG4gIC8vIGFwcGVhciBpbiBgbWFwYC5cbiAgc3VidHJhY3Q6IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmNvbnRlbnQubGVuZ3RoOyBpICs9IDIpXG4gICAgICByZXN1bHQgPSByZXN1bHQucmVtb3ZlKG1hcC5jb250ZW50W2ldKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG5cbiAgLy8gOjogKCkgXHUyMTkyIE9iamVjdFxuICAvLyBUdXJuIG9yZGVyZWQgbWFwIGludG8gYSBwbGFpbiBvYmplY3QuXG4gIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsgcmVzdWx0W2tleV0gPSB2YWx1ZTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9LFxuXG4gIC8vIDo6IG51bWJlclxuICAvLyBUaGUgYW1vdW50IG9mIGtleXMgaW4gdGhpcyBtYXAuXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID4+IDFcbiAgfVxufTtcblxuLy8gOjogKD91bmlvbjxPYmplY3QsIE9yZGVyZWRNYXA+KSBcdTIxOTIgT3JkZXJlZE1hcFxuLy8gUmV0dXJuIGEgbWFwIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuIElmIG51bGwsIGNyZWF0ZSBhbiBlbXB0eVxuLy8gbWFwLiBJZiBnaXZlbiBhbiBvcmRlcmVkIG1hcCwgcmV0dXJuIHRoYXQgbWFwIGl0c2VsZi4gSWYgZ2l2ZW4gYW5cbi8vIG9iamVjdCwgY3JlYXRlIGEgbWFwIGZyb20gdGhlIG9iamVjdCdzIHByb3BlcnRpZXMuXG5PcmRlcmVkTWFwLmZyb20gPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPcmRlcmVkTWFwKSByZXR1cm4gdmFsdWVcbiAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgaWYgKHZhbHVlKSBmb3IgKHZhciBwcm9wIGluIHZhbHVlKSBjb250ZW50LnB1c2gocHJvcCwgdmFsdWVbcHJvcF0pO1xuICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE9yZGVyZWRNYXA7XG4iLCAiaW1wb3J0IE9yZGVyZWRNYXAgZnJvbSAnb3JkZXJlZG1hcCc7XG5cbmZ1bmN0aW9uIGZpbmREaWZmU3RhcnQoYSwgYiwgcG9zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT0gYS5jaGlsZENvdW50IHx8IGkgPT0gYi5jaGlsZENvdW50KVxuICAgICAgICAgICAgcmV0dXJuIGEuY2hpbGRDb3VudCA9PSBiLmNoaWxkQ291bnQgPyBudWxsIDogcG9zO1xuICAgICAgICBsZXQgY2hpbGRBID0gYS5jaGlsZChpKSwgY2hpbGRCID0gYi5jaGlsZChpKTtcbiAgICAgICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgICAgICAgIHBvcyArPSBjaGlsZEEubm9kZVNpemU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoaWxkQS5zYW1lTWFya3VwKGNoaWxkQikpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICBpZiAoY2hpbGRBLmlzVGV4dCAmJiBjaGlsZEEudGV4dCAhPSBjaGlsZEIudGV4dCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGNoaWxkQS50ZXh0W2pdID09IGNoaWxkQi50ZXh0W2pdOyBqKyspXG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEEuY29udGVudC5zaXplIHx8IGNoaWxkQi5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGZpbmREaWZmU3RhcnQoY2hpbGRBLmNvbnRlbnQsIGNoaWxkQi5jb250ZW50LCBwb3MgKyAxKTtcbiAgICAgICAgICAgIGlmIChpbm5lciAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gY2hpbGRBLm5vZGVTaXplO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmREaWZmRW5kKGEsIGIsIHBvc0EsIHBvc0IpIHtcbiAgICBmb3IgKGxldCBpQSA9IGEuY2hpbGRDb3VudCwgaUIgPSBiLmNoaWxkQ291bnQ7Oykge1xuICAgICAgICBpZiAoaUEgPT0gMCB8fCBpQiA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGlBID09IGlCID8gbnVsbCA6IHsgYTogcG9zQSwgYjogcG9zQiB9O1xuICAgICAgICBsZXQgY2hpbGRBID0gYS5jaGlsZCgtLWlBKSwgY2hpbGRCID0gYi5jaGlsZCgtLWlCKSwgc2l6ZSA9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgICAgICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgICAgICAgIHBvc0EgLT0gc2l6ZTtcbiAgICAgICAgICAgIHBvc0IgLT0gc2l6ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hpbGRBLnNhbWVNYXJrdXAoY2hpbGRCKSlcbiAgICAgICAgICAgIHJldHVybiB7IGE6IHBvc0EsIGI6IHBvc0IgfTtcbiAgICAgICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgICAgICAgIGxldCBzYW1lID0gMCwgbWluU2l6ZSA9IE1hdGgubWluKGNoaWxkQS50ZXh0Lmxlbmd0aCwgY2hpbGRCLnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIHdoaWxlIChzYW1lIDwgbWluU2l6ZSAmJiBjaGlsZEEudGV4dFtjaGlsZEEudGV4dC5sZW5ndGggLSBzYW1lIC0gMV0gPT0gY2hpbGRCLnRleHRbY2hpbGRCLnRleHQubGVuZ3RoIC0gc2FtZSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgc2FtZSsrO1xuICAgICAgICAgICAgICAgIHBvc0EtLTtcbiAgICAgICAgICAgICAgICBwb3NCLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBhOiBwb3NBLCBiOiBwb3NCIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkQS5jb250ZW50LnNpemUgfHwgY2hpbGRCLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZERpZmZFbmQoY2hpbGRBLmNvbnRlbnQsIGNoaWxkQi5jb250ZW50LCBwb3NBIC0gMSwgcG9zQiAtIDEpO1xuICAgICAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBwb3NBIC09IHNpemU7XG4gICAgICAgIHBvc0IgLT0gc2l6ZTtcbiAgICB9XG59XG5cbi8qKlxuQSBmcmFnbWVudCByZXByZXNlbnRzIGEgbm9kZSdzIGNvbGxlY3Rpb24gb2YgY2hpbGQgbm9kZXMuXG5cbkxpa2Ugbm9kZXMsIGZyYWdtZW50cyBhcmUgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZXMsIGFuZCB5b3VcbnNob3VsZCBub3QgbXV0YXRlIHRoZW0gb3IgdGhlaXIgY29udGVudC4gUmF0aGVyLCB5b3UgY3JlYXRlIG5ld1xuaW5zdGFuY2VzIHdoZW5ldmVyIG5lZWRlZC4gVGhlIEFQSSB0cmllcyB0byBtYWtlIHRoaXMgZWFzeS5cbiovXG5jbGFzcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnRlbnQsIHNpemUpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZSB8fCAwO1xuICAgICAgICBpZiAoc2l6ZSA9PSBudWxsKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSArPSBjb250ZW50W2ldLm5vZGVTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBJbnZva2UgYSBjYWxsYmFjayBmb3IgYWxsIGRlc2NlbmRhbnQgbm9kZXMgYmV0d2VlbiB0aGUgZ2l2ZW4gdHdvXG4gICAgcG9zaXRpb25zIChyZWxhdGl2ZSB0byBzdGFydCBvZiB0aGlzIGZyYWdtZW50KS4gRG9lc24ndCBkZXNjZW5kXG4gICAgaW50byBhIG5vZGUgd2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLlxuICAgICovXG4gICAgbm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBub2RlU3RhcnQgPSAwLCBwYXJlbnQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IHBvcyA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY29udGVudFtpXSwgZW5kID0gcG9zICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoZW5kID4gZnJvbSAmJiBmKGNoaWxkLCBub2RlU3RhcnQgKyBwb3MsIHBhcmVudCB8fCBudWxsLCBpKSAhPT0gZmFsc2UgJiYgY2hpbGQuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICBjaGlsZC5ub2Rlc0JldHdlZW4oTWF0aC5tYXgoMCwgZnJvbSAtIHN0YXJ0KSwgTWF0aC5taW4oY2hpbGQuY29udGVudC5zaXplLCB0byAtIHN0YXJ0KSwgZiwgbm9kZVN0YXJ0ICsgc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBldmVyeSBkZXNjZW5kYW50IG5vZGUuIGBwb3NgIHdpbGwgYmVcbiAgICByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50LiBUaGUgY2FsbGJhY2sgbWF5IHJldHVyblxuICAgIGBmYWxzZWAgdG8gcHJldmVudCB0cmF2ZXJzYWwgb2YgYSBnaXZlbiBub2RlJ3MgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBkZXNjZW5kYW50cyhmKSB7XG4gICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKDAsIHRoaXMuc2l6ZSwgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dHJhY3QgdGhlIHRleHQgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuIFNlZSB0aGUgc2FtZSBtZXRob2Qgb25cbiAgICBbYE5vZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS50ZXh0QmV0d2VlbikuXG4gICAgKi9cbiAgICB0ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIiwgZmlyc3QgPSB0cnVlO1xuICAgICAgICB0aGlzLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgbGV0IG5vZGVUZXh0ID0gbm9kZS5pc1RleHQgPyBub2RlLnRleHQuc2xpY2UoTWF0aC5tYXgoZnJvbSwgcG9zKSAtIHBvcywgdG8gLSBwb3MpXG4gICAgICAgICAgICAgICAgOiAhbm9kZS5pc0xlYWYgPyBcIlwiXG4gICAgICAgICAgICAgICAgICAgIDogbGVhZlRleHQgPyAodHlwZW9mIGxlYWZUZXh0ID09PSBcImZ1bmN0aW9uXCIgPyBsZWFmVGV4dChub2RlKSA6IGxlYWZUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBub2RlLnR5cGUuc3BlYy5sZWFmVGV4dCA/IG5vZGUudHlwZS5zcGVjLmxlYWZUZXh0KG5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNCbG9jayAmJiAobm9kZS5pc0xlYWYgJiYgbm9kZVRleHQgfHwgbm9kZS5pc1RleHRibG9jaykgJiYgYmxvY2tTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IGJsb2NrU2VwYXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dCArPSBub2RlVGV4dDtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgY29tYmluZWQgY29udGVudCBvZiB0aGlzXG4gICAgZnJhZ21lbnQgYW5kIHRoZSBvdGhlci5cbiAgICAqL1xuICAgIGFwcGVuZChvdGhlcikge1xuICAgICAgICBpZiAoIW90aGVyLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5sYXN0Q2hpbGQsIGZpcnN0ID0gb3RoZXIuZmlyc3RDaGlsZCwgY29udGVudCA9IHRoaXMuY29udGVudC5zbGljZSgpLCBpID0gMDtcbiAgICAgICAgaWYgKGxhc3QuaXNUZXh0ICYmIGxhc3Quc2FtZU1hcmt1cChmaXJzdCkpIHtcbiAgICAgICAgICAgIGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSA9IGxhc3Qud2l0aFRleHQobGFzdC50ZXh0ICsgZmlyc3QudGV4dCk7XG4gICAgICAgICAgICBpID0gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IG90aGVyLmNvbnRlbnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjb250ZW50LnB1c2gob3RoZXIuY29udGVudFtpXSk7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCwgdGhpcy5zaXplICsgb3RoZXIuc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEN1dCBvdXQgdGhlIHN1Yi1mcmFnbWVudCBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgY3V0KGZyb20sIHRvID0gdGhpcy5zaXplKSB7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgc2l6ZSA9IDA7XG4gICAgICAgIGlmICh0byA+IGZyb20pXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY29udGVudFtpXSwgZW5kID0gcG9zICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20gfHwgZW5kID4gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5pc1RleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jdXQoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyksIE1hdGgubWluKGNoaWxkLnRleHQubGVuZ3RoLCB0byAtIHBvcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY3V0KE1hdGgubWF4KDAsIGZyb20gLSBwb3MgLSAxKSwgTWF0aC5taW4oY2hpbGQuY29udGVudC5zaXplLCB0byAtIHBvcyAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChyZXN1bHQsIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGN1dEJ5SW5kZXgoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPT0gdG8pXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMuY29udGVudC5zbGljZShmcm9tLCB0bykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgaW4gd2hpY2ggdGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4IGlzXG4gICAgcmVwbGFjZWQgYnkgdGhlIGdpdmVuIG5vZGUuXG4gICAgKi9cbiAgICByZXBsYWNlQ2hpbGQoaW5kZXgsIG5vZGUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmNvbnRlbnRbaW5kZXhdO1xuICAgICAgICBpZiAoY3VycmVudCA9PSBub2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBjb3B5ID0gdGhpcy5jb250ZW50LnNsaWNlKCk7XG4gICAgICAgIGxldCBzaXplID0gdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSAtIGN1cnJlbnQubm9kZVNpemU7XG4gICAgICAgIGNvcHlbaW5kZXhdID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb3B5LCBzaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGJ5IHByZXBlbmRpbmcgdGhlIGdpdmVuIG5vZGUgdG8gdGhpc1xuICAgIGZyYWdtZW50LlxuICAgICovXG4gICAgYWRkVG9TdGFydChub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoW25vZGVdLmNvbmNhdCh0aGlzLmNvbnRlbnQpLCB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGJ5IGFwcGVuZGluZyB0aGUgZ2l2ZW4gbm9kZSB0byB0aGlzXG4gICAgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBhZGRUb0VuZChub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5jb250ZW50LmNvbmNhdChub2RlKSwgdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBmcmFnbWVudCB0byBhbm90aGVyIG9uZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoICE9IG90aGVyLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250ZW50W2ldLmVxKG90aGVyLmNvbnRlbnRbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgZnJhZ21lbnQsIG9yIGBudWxsYCBpZiBpdCBpcyBlbXB0eS5cbiAgICAqL1xuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudFswXSA6IG51bGw7IH1cbiAgICAvKipcbiAgICBUaGUgbGFzdCBjaGlsZCBvZiB0aGUgZnJhZ21lbnQsIG9yIGBudWxsYCBpZiBpdCBpcyBlbXB0eS5cbiAgICAqL1xuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSA6IG51bGw7IH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIGNoaWxkIG5vZGVzIGluIHRoaXMgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBnZXQgY2hpbGRDb3VudCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LiBSYWlzZSBhbiBlcnJvciB3aGVuIHRoZVxuICAgIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAqL1xuICAgIGNoaWxkKGluZGV4KSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuY29udGVudFtpbmRleF07XG4gICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IFwiICsgaW5kZXggKyBcIiBvdXQgb2YgcmFuZ2UgZm9yIFwiICsgdGhpcyk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgaXQgZXhpc3RzLlxuICAgICovXG4gICAgbWF5YmVDaGlsZChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50W2luZGV4XSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBDYWxsIGBmYCBmb3IgZXZlcnkgY2hpbGQgbm9kZSwgcGFzc2luZyB0aGUgbm9kZSwgaXRzIG9mZnNldFxuICAgIGludG8gdGhpcyBwYXJlbnQgbm9kZSwgYW5kIGl0cyBpbmRleC5cbiAgICAqL1xuICAgIGZvckVhY2goZikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcCA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY29udGVudFtpXTtcbiAgICAgICAgICAgIGYoY2hpbGQsIHAsIGkpO1xuICAgICAgICAgICAgcCArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBmaXJzdCBwb3NpdGlvbiBhdCB3aGljaCB0aGlzIGZyYWdtZW50IGFuZCBhbm90aGVyXG4gICAgZnJhZ21lbnQgZGlmZmVyLCBvciBgbnVsbGAgaWYgdGhleSBhcmUgdGhlIHNhbWUuXG4gICAgKi9cbiAgICBmaW5kRGlmZlN0YXJ0KG90aGVyLCBwb3MgPSAwKSB7XG4gICAgICAgIHJldHVybiBmaW5kRGlmZlN0YXJ0KHRoaXMsIG90aGVyLCBwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBmaXJzdCBwb3NpdGlvbiwgc2VhcmNoaW5nIGZyb20gdGhlIGVuZCwgYXQgd2hpY2ggdGhpc1xuICAgIGZyYWdtZW50IGFuZCB0aGUgZ2l2ZW4gZnJhZ21lbnQgZGlmZmVyLCBvciBgbnVsbGAgaWYgdGhleSBhcmVcbiAgICB0aGUgc2FtZS4gU2luY2UgdGhpcyBwb3NpdGlvbiB3aWxsIG5vdCBiZSB0aGUgc2FtZSBpbiBib3RoXG4gICAgbm9kZXMsIGFuIG9iamVjdCB3aXRoIHR3byBzZXBhcmF0ZSBwb3NpdGlvbnMgaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBmaW5kRGlmZkVuZChvdGhlciwgcG9zID0gdGhpcy5zaXplLCBvdGhlclBvcyA9IG90aGVyLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZpbmREaWZmRW5kKHRoaXMsIG90aGVyLCBwb3MsIG90aGVyUG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgaW5kZXggYW5kIGlubmVyIG9mZnNldCBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gcmVsYXRpdmVcbiAgICBwb3NpdGlvbiBpbiB0aGlzIGZyYWdtZW50LiBUaGUgcmVzdWx0IG9iamVjdCB3aWxsIGJlIHJldXNlZFxuICAgIChvdmVyd3JpdHRlbikgdGhlIG5leHQgdGltZSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLiAoTm90IHB1YmxpYy4pXG4gICAgKi9cbiAgICBmaW5kSW5kZXgocG9zLCByb3VuZCA9IC0xKSB7XG4gICAgICAgIGlmIChwb3MgPT0gMClcbiAgICAgICAgICAgIHJldHVybiByZXRJbmRleCgwLCBwb3MpO1xuICAgICAgICBpZiAocG9zID09IHRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiByZXRJbmRleCh0aGlzLmNvbnRlbnQubGVuZ3RoLCBwb3MpO1xuICAgICAgICBpZiAocG9zID4gdGhpcy5zaXplIHx8IHBvcyA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUG9zaXRpb24gJHtwb3N9IG91dHNpZGUgb2YgZnJhZ21lbnQgKCR7dGhpc30pYCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjdXJQb3MgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcy5jaGlsZChpKSwgZW5kID0gY3VyUG9zICsgY3VyLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID09IHBvcyB8fCByb3VuZCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXRJbmRleChpICsgMSwgZW5kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgoaSwgY3VyUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1clBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBkZWJ1Z2dpbmcgc3RyaW5nIHRoYXQgZGVzY3JpYmVzIHRoaXMgZnJhZ21lbnQuXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIFwiPFwiICsgdGhpcy50b1N0cmluZ0lubmVyKCkgKyBcIj5cIjsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmdJbm5lcigpIHsgcmV0dXJuIHRoaXMuY29udGVudC5qb2luKFwiLCBcIik7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnQubWFwKG4gPT4gbi50b0pTT04oKSkgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIGZyYWdtZW50IGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBGcmFnbWVudC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh2YWx1ZS5tYXAoc2NoZW1hLm5vZGVGcm9tSlNPTikpO1xuICAgIH1cbiAgICAvKipcbiAgICBCdWlsZCBhIGZyYWdtZW50IGZyb20gYW4gYXJyYXkgb2Ygbm9kZXMuIEVuc3VyZXMgdGhhdCBhZGphY2VudFxuICAgIHRleHQgbm9kZXMgd2l0aCB0aGUgc2FtZSBtYXJrcyBhcmUgam9pbmVkIHRvZ2V0aGVyLlxuICAgICovXG4gICAgc3RhdGljIGZyb21BcnJheShhcnJheSkge1xuICAgICAgICBpZiAoIWFycmF5Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgbGV0IGpvaW5lZCwgc2l6ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gYXJyYXlbaV07XG4gICAgICAgICAgICBzaXplICs9IG5vZGUubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoaSAmJiBub2RlLmlzVGV4dCAmJiBhcnJheVtpIC0gMV0uc2FtZU1hcmt1cChub2RlKSkge1xuICAgICAgICAgICAgICAgIGlmICgham9pbmVkKVxuICAgICAgICAgICAgICAgICAgICBqb2luZWQgPSBhcnJheS5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBqb2luZWRbam9pbmVkLmxlbmd0aCAtIDFdID0gbm9kZVxuICAgICAgICAgICAgICAgICAgICAud2l0aFRleHQoam9pbmVkW2pvaW5lZC5sZW5ndGggLSAxXS50ZXh0ICsgbm9kZS50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGpvaW5lZCkge1xuICAgICAgICAgICAgICAgIGpvaW5lZC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoam9pbmVkIHx8IGFycmF5LCBzaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZnJhZ21lbnQgZnJvbSBzb21ldGhpbmcgdGhhdCBjYW4gYmUgaW50ZXJwcmV0ZWQgYXMgYVxuICAgIHNldCBvZiBub2Rlcy4gRm9yIGBudWxsYCwgaXQgcmV0dXJucyB0aGUgZW1wdHkgZnJhZ21lbnQuIEZvciBhXG4gICAgZnJhZ21lbnQsIHRoZSBmcmFnbWVudCBpdHNlbGYuIEZvciBhIG5vZGUgb3IgYXJyYXkgb2Ygbm9kZXMsIGFcbiAgICBmcmFnbWVudCBjb250YWluaW5nIHRob3NlIG5vZGVzLlxuICAgICovXG4gICAgc3RhdGljIGZyb20obm9kZXMpIHtcbiAgICAgICAgaWYgKCFub2RlcylcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgaWYgKG5vZGVzIGluc3RhbmNlb2YgRnJhZ21lbnQpXG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21BcnJheShub2Rlcyk7XG4gICAgICAgIGlmIChub2Rlcy5hdHRycylcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoW25vZGVzXSwgbm9kZXMubm9kZVNpemUpO1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbiBub3QgY29udmVydCBcIiArIG5vZGVzICsgXCIgdG8gYSBGcmFnbWVudFwiICtcbiAgICAgICAgICAgIChub2Rlcy5ub2Rlc0JldHdlZW4gPyBcIiAobG9va3MgbGlrZSBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBwcm9zZW1pcnJvci1tb2RlbCB3ZXJlIGxvYWRlZClcIiA6IFwiXCIpKTtcbiAgICB9XG59XG4vKipcbkFuIGVtcHR5IGZyYWdtZW50LiBJbnRlbmRlZCB0byBiZSByZXVzZWQgd2hlbmV2ZXIgYSBub2RlIGRvZXNuJ3RcbmNvbnRhaW4gYW55dGhpbmcgKHJhdGhlciB0aGFuIGFsbG9jYXRpbmcgYSBuZXcgZW1wdHkgZnJhZ21lbnQgZm9yXG5lYWNoIGxlYWYgbm9kZSkuXG4qL1xuRnJhZ21lbnQuZW1wdHkgPSBuZXcgRnJhZ21lbnQoW10sIDApO1xuY29uc3QgZm91bmQgPSB7IGluZGV4OiAwLCBvZmZzZXQ6IDAgfTtcbmZ1bmN0aW9uIHJldEluZGV4KGluZGV4LCBvZmZzZXQpIHtcbiAgICBmb3VuZC5pbmRleCA9IGluZGV4O1xuICAgIGZvdW5kLm9mZnNldCA9IG9mZnNldDtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVEZWVwKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCEoYSAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiKSB8fFxuICAgICAgICAhKGIgJiYgdHlwZW9mIGIgPT0gXCJvYmplY3RcIikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYXJyYXkgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGIpICE9IGFycmF5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGFycmF5KSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFjb21wYXJlRGVlcChhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBwIGluIGEpXG4gICAgICAgICAgICBpZiAoIShwIGluIGIpIHx8ICFjb21wYXJlRGVlcChhW3BdLCBiW3BdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHAgaW4gYilcbiAgICAgICAgICAgIGlmICghKHAgaW4gYSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG5BIG1hcmsgaXMgYSBwaWVjZSBvZiBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIG5vZGUsXG5zdWNoIGFzIGl0IGJlaW5nIGVtcGhhc2l6ZWQsIGluIGNvZGUgZm9udCwgb3IgYSBsaW5rLiBJdCBoYXMgYVxudHlwZSBhbmQgb3B0aW9uYWxseSBhIHNldCBvZiBhdHRyaWJ1dGVzIHRoYXQgcHJvdmlkZSBmdXJ0aGVyXG5pbmZvcm1hdGlvbiAoc3VjaCBhcyB0aGUgdGFyZ2V0IG9mIHRoZSBsaW5rKS4gTWFya3MgYXJlIGNyZWF0ZWRcbnRocm91Z2ggYSBgU2NoZW1hYCwgd2hpY2ggY29udHJvbHMgd2hpY2ggdHlwZXMgZXhpc3QgYW5kIHdoaWNoXG5hdHRyaWJ1dGVzIHRoZXkgaGF2ZS5cbiovXG5jbGFzcyBNYXJrIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIHRoaXMgbWFyay5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoZSBhdHRyaWJ1dGVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hcmsuXG4gICAgKi9cbiAgICBhdHRycykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgfVxuICAgIC8qKlxuICAgIEdpdmVuIGEgc2V0IG9mIG1hcmtzLCBjcmVhdGUgYSBuZXcgc2V0IHdoaWNoIGNvbnRhaW5zIHRoaXMgb25lIGFzXG4gICAgd2VsbCwgaW4gdGhlIHJpZ2h0IHBvc2l0aW9uLiBJZiB0aGlzIG1hcmsgaXMgYWxyZWFkeSBpbiB0aGUgc2V0LFxuICAgIHRoZSBzZXQgaXRzZWxmIGlzIHJldHVybmVkLiBJZiBhbnkgbWFya3MgdGhhdCBhcmUgc2V0IHRvIGJlXG4gICAgW2V4Y2x1c2l2ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtTcGVjLmV4Y2x1ZGVzKSB3aXRoIHRoaXMgbWFyayBhcmUgcHJlc2VudCxcbiAgICB0aG9zZSBhcmUgcmVwbGFjZWQgYnkgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhZGRUb1NldChzZXQpIHtcbiAgICAgICAgbGV0IGNvcHksIHBsYWNlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG90aGVyID0gc2V0W2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlLmV4Y2x1ZGVzKG90aGVyLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc2V0LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3RoZXIudHlwZS5leGNsdWRlcyh0aGlzLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghcGxhY2VkICYmIG90aGVyLnR5cGUucmFuayA+IHRoaXMudHlwZS5yYW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzZXQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkucHVzaChvdGhlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgY29weSA9IHNldC5zbGljZSgpO1xuICAgICAgICBpZiAoIXBsYWNlZClcbiAgICAgICAgICAgIGNvcHkucHVzaCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSB0aGlzIG1hcmsgZnJvbSB0aGUgZ2l2ZW4gc2V0LCByZXR1cm5pbmcgYSBuZXcgc2V0LiBJZiB0aGlzXG4gICAgbWFyayBpcyBub3QgaW4gdGhlIHNldCwgdGhlIHNldCBpdHNlbGYgaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICByZW1vdmVGcm9tU2V0KHNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKHNldFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldC5zbGljZSgwLCBpKS5jb25jYXQoc2V0LnNsaWNlKGkgKyAxKSk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGlzIG1hcmsgaXMgaW4gdGhlIGdpdmVuIHNldCBvZiBtYXJrcy5cbiAgICAqL1xuICAgIGlzSW5TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuZXEoc2V0W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhpcyBtYXJrIGhhcyB0aGUgc2FtZSB0eXBlIGFuZCBhdHRyaWJ1dGVzIGFzXG4gICAgYW5vdGhlciBtYXJrLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgICh0aGlzLnR5cGUgPT0gb3RoZXIudHlwZSAmJiBjb21wYXJlRGVlcCh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoaXMgbWFyayB0byBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG9iaiA9IHsgdHlwZTogdGhpcy50eXBlLm5hbWUgfTtcbiAgICAgICAgZm9yIChsZXQgXyBpbiB0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICBvYmouYXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBtYXJrIGZyb20gSlNPTi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBNYXJrLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgdHlwZSA9IHNjaGVtYS5tYXJrc1tqc29uLnR5cGVdO1xuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlcmUgaXMgbm8gbWFyayB0eXBlICR7anNvbi50eXBlfSBpbiB0aGlzIHNjaGVtYWApO1xuICAgICAgICByZXR1cm4gdHlwZS5jcmVhdGUoanNvbi5hdHRycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0d28gc2V0cyBvZiBtYXJrcyBhcmUgaWRlbnRpY2FsLlxuICAgICovXG4gICAgc3RhdGljIHNhbWVTZXQoYSwgYikge1xuICAgICAgICBpZiAoYSA9PSBiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFhW2ldLmVxKGJbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHByb3Blcmx5IHNvcnRlZCBtYXJrIHNldCBmcm9tIG51bGwsIGEgc2luZ2xlIG1hcmssIG9yIGFuXG4gICAgdW5zb3J0ZWQgYXJyYXkgb2YgbWFya3MuXG4gICAgKi9cbiAgICBzdGF0aWMgc2V0RnJvbShtYXJrcykge1xuICAgICAgICBpZiAoIW1hcmtzIHx8IEFycmF5LmlzQXJyYXkobWFya3MpICYmIG1hcmtzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIE1hcmsubm9uZTtcbiAgICAgICAgaWYgKG1hcmtzIGluc3RhbmNlb2YgTWFyaylcbiAgICAgICAgICAgIHJldHVybiBbbWFya3NdO1xuICAgICAgICBsZXQgY29weSA9IG1hcmtzLnNsaWNlKCk7XG4gICAgICAgIGNvcHkuc29ydCgoYSwgYikgPT4gYS50eXBlLnJhbmsgLSBiLnR5cGUucmFuayk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBtYXJrcy5cbiovXG5NYXJrLm5vbmUgPSBbXTtcblxuLyoqXG5FcnJvciB0eXBlIHJhaXNlZCBieSBbYE5vZGUucmVwbGFjZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnJlcGxhY2UpIHdoZW5cbmdpdmVuIGFuIGludmFsaWQgcmVwbGFjZW1lbnQuXG4qL1xuY2xhc3MgUmVwbGFjZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuLypcblJlcGxhY2VFcnJvciA9IGZ1bmN0aW9uKHRoaXM6IGFueSwgbWVzc2FnZTogc3RyaW5nKSB7XG4gIGxldCBlcnIgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpXG4gIDsoZXJyIGFzIGFueSkuX19wcm90b19fID0gUmVwbGFjZUVycm9yLnByb3RvdHlwZVxuICByZXR1cm4gZXJyXG59IGFzIGFueVxuXG5SZXBsYWNlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpXG5SZXBsYWNlRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVwbGFjZUVycm9yXG5SZXBsYWNlRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlJlcGxhY2VFcnJvclwiXG4qL1xuLyoqXG5BIHNsaWNlIHJlcHJlc2VudHMgYSBwaWVjZSBjdXQgb3V0IG9mIGEgbGFyZ2VyIGRvY3VtZW50LiBJdFxuc3RvcmVzIG5vdCBvbmx5IGEgZnJhZ21lbnQsIGJ1dCBhbHNvIHRoZSBkZXB0aCB1cCB0byB3aGljaCBub2RlcyBvblxuYm90aCBzaWRlIGFyZSBcdTIwMThvcGVuXHUyMDE5IChjdXQgdGhyb3VnaCkuXG4qL1xuY2xhc3MgU2xpY2Uge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNsaWNlLiBXaGVuIHNwZWNpZnlpbmcgYSBub24temVybyBvcGVuIGRlcHRoLCB5b3UgbXVzdFxuICAgIG1ha2Ugc3VyZSB0aGF0IHRoZXJlIGFyZSBub2RlcyBvZiBhdCBsZWFzdCB0aGF0IGRlcHRoIGF0IHRoZVxuICAgIGFwcHJvcHJpYXRlIHNpZGUgb2YgdGhlIGZyYWdtZW50XHUyMDE0aS5lLiBpZiB0aGUgZnJhZ21lbnQgaXMgYW5cbiAgICBlbXB0eSBwYXJhZ3JhcGggbm9kZSwgYG9wZW5TdGFydGAgYW5kIGBvcGVuRW5kYCBjYW4ndCBiZSBncmVhdGVyXG4gICAgdGhhbiAxLlxuICAgIFxuICAgIEl0IGlzIG5vdCBuZWNlc3NhcnkgZm9yIHRoZSBjb250ZW50IG9mIG9wZW4gbm9kZXMgdG8gY29uZm9ybSB0b1xuICAgIHRoZSBzY2hlbWEncyBjb250ZW50IGNvbnN0cmFpbnRzLCB0aG91Z2ggaXQgc2hvdWxkIGJlIGEgdmFsaWRcbiAgICBzdGFydC9lbmQvbWlkZGxlIGZvciBzdWNoIGEgbm9kZSwgZGVwZW5kaW5nIG9uIHdoaWNoIHNpZGVzIGFyZVxuICAgIG9wZW4uXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc2xpY2UncyBjb250ZW50LlxuICAgICovXG4gICAgY29udGVudCwgXG4gICAgLyoqXG4gICAgVGhlIG9wZW4gZGVwdGggYXQgdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudC5cbiAgICAqL1xuICAgIG9wZW5TdGFydCwgXG4gICAgLyoqXG4gICAgVGhlIG9wZW4gZGVwdGggYXQgdGhlIGVuZC5cbiAgICAqL1xuICAgIG9wZW5FbmQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQ7XG4gICAgICAgIHRoaXMub3BlbkVuZCA9IG9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzaXplIHRoaXMgc2xpY2Ugd291bGQgYWRkIHdoZW4gaW5zZXJ0ZWQgaW50byBhIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuc2l6ZSAtIHRoaXMub3BlblN0YXJ0IC0gdGhpcy5vcGVuRW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGluc2VydEF0KHBvcywgZnJhZ21lbnQpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBpbnNlcnRJbnRvKHRoaXMuY29udGVudCwgcG9zICsgdGhpcy5vcGVuU3RhcnQsIGZyYWdtZW50KTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQgJiYgbmV3IFNsaWNlKGNvbnRlbnQsIHRoaXMub3BlblN0YXJ0LCB0aGlzLm9wZW5FbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlbW92ZUJldHdlZW4oZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShyZW1vdmVSYW5nZSh0aGlzLmNvbnRlbnQsIGZyb20gKyB0aGlzLm9wZW5TdGFydCwgdG8gKyB0aGlzLm9wZW5TdGFydCksIHRoaXMub3BlblN0YXJ0LCB0aGlzLm9wZW5FbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0cyB3aGV0aGVyIHRoaXMgc2xpY2UgaXMgZXF1YWwgdG8gYW5vdGhlciBzbGljZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZXEob3RoZXIuY29udGVudCkgJiYgdGhpcy5vcGVuU3RhcnQgPT0gb3RoZXIub3BlblN0YXJ0ICYmIHRoaXMub3BlbkVuZCA9PSBvdGhlci5vcGVuRW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50ICsgXCIoXCIgKyB0aGlzLm9wZW5TdGFydCArIFwiLFwiICsgdGhpcy5vcGVuRW5kICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgYSBzbGljZSB0byBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBqc29uID0geyBjb250ZW50OiB0aGlzLmNvbnRlbnQudG9KU09OKCkgfTtcbiAgICAgICAgaWYgKHRoaXMub3BlblN0YXJ0ID4gMClcbiAgICAgICAgICAgIGpzb24ub3BlblN0YXJ0ID0gdGhpcy5vcGVuU3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLm9wZW5FbmQgPiAwKVxuICAgICAgICAgICAganNvbi5vcGVuRW5kID0gdGhpcy5vcGVuRW5kO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzbGljZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICByZXR1cm4gU2xpY2UuZW1wdHk7XG4gICAgICAgIGxldCBvcGVuU3RhcnQgPSBqc29uLm9wZW5TdGFydCB8fCAwLCBvcGVuRW5kID0ganNvbi5vcGVuRW5kIHx8IDA7XG4gICAgICAgIGlmICh0eXBlb2Ygb3BlblN0YXJ0ICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIG9wZW5FbmQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU2xpY2UuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbUpTT04oc2NoZW1hLCBqc29uLmNvbnRlbnQpLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzbGljZSBmcm9tIGEgZnJhZ21lbnQgYnkgdGFraW5nIHRoZSBtYXhpbXVtIHBvc3NpYmxlXG4gICAgb3BlbiB2YWx1ZSBvbiBib3RoIHNpZGUgb2YgdGhlIGZyYWdtZW50LlxuICAgICovXG4gICAgc3RhdGljIG1heE9wZW4oZnJhZ21lbnQsIG9wZW5Jc29sYXRpbmcgPSB0cnVlKSB7XG4gICAgICAgIGxldCBvcGVuU3RhcnQgPSAwLCBvcGVuRW5kID0gMDtcbiAgICAgICAgZm9yIChsZXQgbiA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7IG4gJiYgIW4uaXNMZWFmICYmIChvcGVuSXNvbGF0aW5nIHx8ICFuLnR5cGUuc3BlYy5pc29sYXRpbmcpOyBuID0gbi5maXJzdENoaWxkKVxuICAgICAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgIGZvciAobGV0IG4gPSBmcmFnbWVudC5sYXN0Q2hpbGQ7IG4gJiYgIW4uaXNMZWFmICYmIChvcGVuSXNvbGF0aW5nIHx8ICFuLnR5cGUuc3BlYy5pc29sYXRpbmcpOyBuID0gbi5sYXN0Q2hpbGQpXG4gICAgICAgICAgICBvcGVuRW5kKys7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoZnJhZ21lbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2xpY2UuXG4qL1xuU2xpY2UuZW1wdHkgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZW1wdHksIDAsIDApO1xuZnVuY3Rpb24gcmVtb3ZlUmFuZ2UoY29udGVudCwgZnJvbSwgdG8pIHtcbiAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBjb250ZW50LmZpbmRJbmRleChmcm9tKSwgY2hpbGQgPSBjb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgIGxldCB7IGluZGV4OiBpbmRleFRvLCBvZmZzZXQ6IG9mZnNldFRvIH0gPSBjb250ZW50LmZpbmRJbmRleCh0byk7XG4gICAgaWYgKG9mZnNldCA9PSBmcm9tIHx8IGNoaWxkLmlzVGV4dCkge1xuICAgICAgICBpZiAob2Zmc2V0VG8gIT0gdG8gJiYgIWNvbnRlbnQuY2hpbGQoaW5kZXhUbykuaXNUZXh0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZW1vdmluZyBub24tZmxhdCByYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQuY3V0KDAsIGZyb20pLmFwcGVuZChjb250ZW50LmN1dCh0bykpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT0gaW5kZXhUbylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZW1vdmluZyBub24tZmxhdCByYW5nZVwiKTtcbiAgICByZXR1cm4gY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGNoaWxkLmNvcHkocmVtb3ZlUmFuZ2UoY2hpbGQuY29udGVudCwgZnJvbSAtIG9mZnNldCAtIDEsIHRvIC0gb2Zmc2V0IC0gMSkpKTtcbn1cbmZ1bmN0aW9uIGluc2VydEludG8oY29udGVudCwgZGlzdCwgaW5zZXJ0LCBwYXJlbnQpIHtcbiAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBjb250ZW50LmZpbmRJbmRleChkaXN0KSwgY2hpbGQgPSBjb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgIGlmIChvZmZzZXQgPT0gZGlzdCB8fCBjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4LCBpbnNlcnQpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBjb250ZW50LmN1dCgwLCBkaXN0KS5hcHBlbmQoaW5zZXJ0KS5hcHBlbmQoY29udGVudC5jdXQoZGlzdCkpO1xuICAgIH1cbiAgICBsZXQgaW5uZXIgPSBpbnNlcnRJbnRvKGNoaWxkLmNvbnRlbnQsIGRpc3QgLSBvZmZzZXQgLSAxLCBpbnNlcnQpO1xuICAgIHJldHVybiBpbm5lciAmJiBjb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgY2hpbGQuY29weShpbm5lcikpO1xufVxuZnVuY3Rpb24gcmVwbGFjZSgkZnJvbSwgJHRvLCBzbGljZSkge1xuICAgIGlmIChzbGljZS5vcGVuU3RhcnQgPiAkZnJvbS5kZXB0aClcbiAgICAgICAgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkluc2VydGVkIGNvbnRlbnQgZGVlcGVyIHRoYW4gaW5zZXJ0aW9uIHBvc2l0aW9uXCIpO1xuICAgIGlmICgkZnJvbS5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCAhPSAkdG8uZGVwdGggLSBzbGljZS5vcGVuRW5kKVxuICAgICAgICB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiSW5jb25zaXN0ZW50IG9wZW4gZGVwdGhzXCIpO1xuICAgIHJldHVybiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIDApO1xufVxuZnVuY3Rpb24gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCBkZXB0aCkge1xuICAgIGxldCBpbmRleCA9ICRmcm9tLmluZGV4KGRlcHRoKSwgbm9kZSA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgIGlmIChpbmRleCA9PSAkdG8uaW5kZXgoZGVwdGgpICYmIGRlcHRoIDwgJGZyb20uZGVwdGggLSBzbGljZS5vcGVuU3RhcnQpIHtcbiAgICAgICAgbGV0IGlubmVyID0gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCBkZXB0aCArIDEpO1xuICAgICAgICByZXR1cm4gbm9kZS5jb3B5KG5vZGUuY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGlubmVyKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFzbGljZS5jb250ZW50LnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlKG5vZGUsIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXNsaWNlLm9wZW5TdGFydCAmJiAhc2xpY2Uub3BlbkVuZCAmJiAkZnJvbS5kZXB0aCA9PSBkZXB0aCAmJiAkdG8uZGVwdGggPT0gZGVwdGgpIHsgLy8gU2ltcGxlLCBmbGF0IGNhc2VcbiAgICAgICAgbGV0IHBhcmVudCA9ICRmcm9tLnBhcmVudCwgY29udGVudCA9IHBhcmVudC5jb250ZW50O1xuICAgICAgICByZXR1cm4gY2xvc2UocGFyZW50LCBjb250ZW50LmN1dCgwLCAkZnJvbS5wYXJlbnRPZmZzZXQpLmFwcGVuZChzbGljZS5jb250ZW50KS5hcHBlbmQoY29udGVudC5jdXQoJHRvLnBhcmVudE9mZnNldCkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHByZXBhcmVTbGljZUZvclJlcGxhY2Uoc2xpY2UsICRmcm9tKTtcbiAgICAgICAgcmV0dXJuIGNsb3NlKG5vZGUsIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgc3RhcnQsIGVuZCwgJHRvLCBkZXB0aCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrSm9pbihtYWluLCBzdWIpIHtcbiAgICBpZiAoIXN1Yi50eXBlLmNvbXBhdGlibGVDb250ZW50KG1haW4udHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJDYW5ub3Qgam9pbiBcIiArIHN1Yi50eXBlLm5hbWUgKyBcIiBvbnRvIFwiICsgbWFpbi50eXBlLm5hbWUpO1xufVxuZnVuY3Rpb24gam9pbmFibGUoJGJlZm9yZSwgJGFmdGVyLCBkZXB0aCkge1xuICAgIGxldCBub2RlID0gJGJlZm9yZS5ub2RlKGRlcHRoKTtcbiAgICBjaGVja0pvaW4obm9kZSwgJGFmdGVyLm5vZGUoZGVwdGgpKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGFkZE5vZGUoY2hpbGQsIHRhcmdldCkge1xuICAgIGxldCBsYXN0ID0gdGFyZ2V0Lmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3QgPj0gMCAmJiBjaGlsZC5pc1RleHQgJiYgY2hpbGQuc2FtZU1hcmt1cCh0YXJnZXRbbGFzdF0pKVxuICAgICAgICB0YXJnZXRbbGFzdF0gPSBjaGlsZC53aXRoVGV4dCh0YXJnZXRbbGFzdF0udGV4dCArIGNoaWxkLnRleHQpO1xuICAgIGVsc2VcbiAgICAgICAgdGFyZ2V0LnB1c2goY2hpbGQpO1xufVxuZnVuY3Rpb24gYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgdGFyZ2V0KSB7XG4gICAgbGV0IG5vZGUgPSAoJGVuZCB8fCAkc3RhcnQpLm5vZGUoZGVwdGgpO1xuICAgIGxldCBzdGFydEluZGV4ID0gMCwgZW5kSW5kZXggPSAkZW5kID8gJGVuZC5pbmRleChkZXB0aCkgOiBub2RlLmNoaWxkQ291bnQ7XG4gICAgaWYgKCRzdGFydCkge1xuICAgICAgICBzdGFydEluZGV4ID0gJHN0YXJ0LmluZGV4KGRlcHRoKTtcbiAgICAgICAgaWYgKCRzdGFydC5kZXB0aCA+IGRlcHRoKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJHN0YXJ0LnRleHRPZmZzZXQpIHtcbiAgICAgICAgICAgIGFkZE5vZGUoJHN0YXJ0Lm5vZGVBZnRlciwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspXG4gICAgICAgIGFkZE5vZGUobm9kZS5jaGlsZChpKSwgdGFyZ2V0KTtcbiAgICBpZiAoJGVuZCAmJiAkZW5kLmRlcHRoID09IGRlcHRoICYmICRlbmQudGV4dE9mZnNldClcbiAgICAgICAgYWRkTm9kZSgkZW5kLm5vZGVCZWZvcmUsIHRhcmdldCk7XG59XG5mdW5jdGlvbiBjbG9zZShub2RlLCBjb250ZW50KSB7XG4gICAgbm9kZS50eXBlLmNoZWNrQ29udGVudChjb250ZW50KTtcbiAgICByZXR1cm4gbm9kZS5jb3B5KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVRocmVlV2F5KCRmcm9tLCAkc3RhcnQsICRlbmQsICR0bywgZGVwdGgpIHtcbiAgICBsZXQgb3BlblN0YXJ0ID0gJGZyb20uZGVwdGggPiBkZXB0aCAmJiBqb2luYWJsZSgkZnJvbSwgJHN0YXJ0LCBkZXB0aCArIDEpO1xuICAgIGxldCBvcGVuRW5kID0gJHRvLmRlcHRoID4gZGVwdGggJiYgam9pbmFibGUoJGVuZCwgJHRvLCBkZXB0aCArIDEpO1xuICAgIGxldCBjb250ZW50ID0gW107XG4gICAgYWRkUmFuZ2UobnVsbCwgJGZyb20sIGRlcHRoLCBjb250ZW50KTtcbiAgICBpZiAob3BlblN0YXJ0ICYmIG9wZW5FbmQgJiYgJHN0YXJ0LmluZGV4KGRlcHRoKSA9PSAkZW5kLmluZGV4KGRlcHRoKSkge1xuICAgICAgICBjaGVja0pvaW4ob3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgYWRkTm9kZShjbG9zZShvcGVuU3RhcnQsIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgJHN0YXJ0LCAkZW5kLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChvcGVuU3RhcnQpXG4gICAgICAgICAgICBhZGROb2RlKGNsb3NlKG9wZW5TdGFydCwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHN0YXJ0LCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgICAgIGFkZFJhbmdlKCRzdGFydCwgJGVuZCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgICAgICBpZiAob3BlbkVuZClcbiAgICAgICAgICAgIGFkZE5vZGUoY2xvc2Uob3BlbkVuZCwgcmVwbGFjZVR3b1dheSgkZW5kLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICB9XG4gICAgYWRkUmFuZ2UoJHRvLCBudWxsLCBkZXB0aCwgY29udGVudCk7XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGgpIHtcbiAgICBsZXQgY29udGVudCA9IFtdO1xuICAgIGFkZFJhbmdlKG51bGwsICRmcm9tLCBkZXB0aCwgY29udGVudCk7XG4gICAgaWYgKCRmcm9tLmRlcHRoID4gZGVwdGgpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBqb2luYWJsZSgkZnJvbSwgJHRvLCBkZXB0aCArIDEpO1xuICAgICAgICBhZGROb2RlKGNsb3NlKHR5cGUsIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcHJlcGFyZVNsaWNlRm9yUmVwbGFjZShzbGljZSwgJGFsb25nKSB7XG4gICAgbGV0IGV4dHJhID0gJGFsb25nLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0LCBwYXJlbnQgPSAkYWxvbmcubm9kZShleHRyYSk7XG4gICAgbGV0IG5vZGUgPSBwYXJlbnQuY29weShzbGljZS5jb250ZW50KTtcbiAgICBmb3IgKGxldCBpID0gZXh0cmEgLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgbm9kZSA9ICRhbG9uZy5ub2RlKGkpLmNvcHkoRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IG5vZGUucmVzb2x2ZU5vQ2FjaGUoc2xpY2Uub3BlblN0YXJ0ICsgZXh0cmEpLFxuICAgICAgICBlbmQ6IG5vZGUucmVzb2x2ZU5vQ2FjaGUobm9kZS5jb250ZW50LnNpemUgLSBzbGljZS5vcGVuRW5kIC0gZXh0cmEpIH07XG59XG5cbi8qKlxuWW91IGNhbiBbX3Jlc29sdmVfXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5yZXNvbHZlKSBhIHBvc2l0aW9uIHRvIGdldCBtb3JlXG5pbmZvcm1hdGlvbiBhYm91dCBpdC4gT2JqZWN0cyBvZiB0aGlzIGNsYXNzIHJlcHJlc2VudCBzdWNoIGFcbnJlc29sdmVkIHBvc2l0aW9uLCBwcm92aWRpbmcgdmFyaW91cyBwaWVjZXMgb2YgY29udGV4dFxuaW5mb3JtYXRpb24sIGFuZCBzb21lIGhlbHBlciBtZXRob2RzLlxuXG5UaHJvdWdob3V0IHRoaXMgaW50ZXJmYWNlLCBtZXRob2RzIHRoYXQgdGFrZSBhbiBvcHRpb25hbCBgZGVwdGhgXG5wYXJhbWV0ZXIgd2lsbCBpbnRlcnByZXQgdW5kZWZpbmVkIGFzIGB0aGlzLmRlcHRoYCBhbmQgbmVnYXRpdmVcbm51bWJlcnMgYXMgYHRoaXMuZGVwdGggKyB2YWx1ZWAuXG4qL1xuY2xhc3MgUmVzb2x2ZWRQb3Mge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIHRoYXQgd2FzIHJlc29sdmVkLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHBhdGgsIFxuICAgIC8qKlxuICAgIFRoZSBvZmZzZXQgdGhpcyBwb3NpdGlvbiBoYXMgaW50byBpdHMgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBwYXJlbnRPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMucGFyZW50T2Zmc2V0ID0gcGFyZW50T2Zmc2V0O1xuICAgICAgICB0aGlzLmRlcHRoID0gcGF0aC5sZW5ndGggLyAzIC0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNvbHZlRGVwdGgodmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcHRoO1xuICAgICAgICBpZiAodmFsIDwgMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcHRoICsgdmFsO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgcGFyZW50IG5vZGUgdGhhdCB0aGUgcG9zaXRpb24gcG9pbnRzIGludG8uIE5vdGUgdGhhdCBldmVuIGlmXG4gICAgYSBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgdGhhdCBub2RlIGlzIG5vdCBjb25zaWRlcmVkXG4gICAgdGhlIHBhcmVudFx1MjAxNHRleHQgbm9kZXMgYXJlIFx1MjAxOGZsYXRcdTIwMTkgaW4gdGhpcyBtb2RlbCwgYW5kIGhhdmUgbm8gY29udGVudC5cbiAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7IHJldHVybiB0aGlzLm5vZGUodGhpcy5kZXB0aCk7IH1cbiAgICAvKipcbiAgICBUaGUgcm9vdCBub2RlIGluIHdoaWNoIHRoZSBwb3NpdGlvbiB3YXMgcmVzb2x2ZWQuXG4gICAgKi9cbiAgICBnZXQgZG9jKCkgeyByZXR1cm4gdGhpcy5ub2RlKDApOyB9XG4gICAgLyoqXG4gICAgVGhlIGFuY2VzdG9yIG5vZGUgYXQgdGhlIGdpdmVuIGxldmVsLiBgcC5ub2RlKHAuZGVwdGgpYCBpcyB0aGVcbiAgICBzYW1lIGFzIGBwLnBhcmVudGAuXG4gICAgKi9cbiAgICBub2RlKGRlcHRoKSB7IHJldHVybiB0aGlzLnBhdGhbdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpICogM107IH1cbiAgICAvKipcbiAgICBUaGUgaW5kZXggaW50byB0aGUgYW5jZXN0b3IgYXQgdGhlIGdpdmVuIGxldmVsLiBJZiB0aGlzIHBvaW50c1xuICAgIGF0IHRoZSAzcmQgbm9kZSBpbiB0aGUgMm5kIHBhcmFncmFwaCBvbiB0aGUgdG9wIGxldmVsLCBmb3JcbiAgICBleGFtcGxlLCBgcC5pbmRleCgwKWAgaXMgMSBhbmQgYHAuaW5kZXgoMSlgIGlzIDIuXG4gICAgKi9cbiAgICBpbmRleChkZXB0aCkgeyByZXR1cm4gdGhpcy5wYXRoW3RoaXMucmVzb2x2ZURlcHRoKGRlcHRoKSAqIDMgKyAxXTsgfVxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBwb2ludGluZyBhZnRlciB0aGlzIHBvc2l0aW9uIGludG8gdGhlIGFuY2VzdG9yIGF0IHRoZVxuICAgIGdpdmVuIGxldmVsLlxuICAgICovXG4gICAgaW5kZXhBZnRlcihkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXgoZGVwdGgpICsgKGRlcHRoID09IHRoaXMuZGVwdGggJiYgIXRoaXMudGV4dE9mZnNldCA/IDAgOiAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlblxuICAgIGxldmVsLlxuICAgICovXG4gICAgc3RhcnQoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIHJldHVybiBkZXB0aCA9PSAwID8gMCA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuXG4gICAgbGV2ZWwuXG4gICAgKi9cbiAgICBlbmQoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KGRlcHRoKSArIHRoaXMubm9kZShkZXB0aCkuY29udGVudC5zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBkaXJlY3RseSBiZWZvcmUgdGhlIHdyYXBwaW5nIG5vZGUgYXQgdGhlXG4gICAgZ2l2ZW4gbGV2ZWwsIG9yLCB3aGVuIGBkZXB0aGAgaXMgYHRoaXMuZGVwdGggKyAxYCwgdGhlIG9yaWdpbmFsXG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICBiZWZvcmUoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlIGlzIG5vIHBvc2l0aW9uIGJlZm9yZSB0aGUgdG9wLWxldmVsIG5vZGVcIik7XG4gICAgICAgIHJldHVybiBkZXB0aCA9PSB0aGlzLmRlcHRoICsgMSA/IHRoaXMucG9zIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBkaXJlY3RseSBhZnRlciB0aGUgd3JhcHBpbmcgbm9kZSBhdCB0aGVcbiAgICBnaXZlbiBsZXZlbCwgb3IgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIHdoZW4gYGRlcHRoYCBpcyBgdGhpcy5kZXB0aCArIDFgLlxuICAgICovXG4gICAgYWZ0ZXIoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlIGlzIG5vIHBvc2l0aW9uIGFmdGVyIHRoZSB0b3AtbGV2ZWwgbm9kZVwiKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IHRoaXMuZGVwdGggKyAxID8gdGhpcy5wb3MgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyB0aGlzLnBhdGhbZGVwdGggKiAzXS5ub2RlU2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hlbiB0aGlzIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCB0aGlzIHJldHVybnMgdGhlXG4gICAgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9zaXRpb24gYW5kIHRoZSBzdGFydCBvZiB0aGUgdGV4dCBub2RlLlxuICAgIFdpbGwgYmUgemVybyBmb3IgcG9zaXRpb25zIHRoYXQgcG9pbnQgYmV0d2VlbiBub2Rlcy5cbiAgICAqL1xuICAgIGdldCB0ZXh0T2Zmc2V0KCkgeyByZXR1cm4gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBub2RlIGRpcmVjdGx5IGFmdGVyIHRoZSBwb3NpdGlvbiwgaWYgYW55LiBJZiB0aGUgcG9zaXRpb25cbiAgICBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgb25seSB0aGUgcGFydCBvZiB0aGF0IG5vZGUgYWZ0ZXIgdGhlXG4gICAgcG9zaXRpb24gaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBnZXQgbm9kZUFmdGVyKCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQsIGluZGV4ID0gdGhpcy5pbmRleCh0aGlzLmRlcHRoKTtcbiAgICAgICAgaWYgKGluZGV4ID09IHBhcmVudC5jaGlsZENvdW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBkT2ZmID0gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdLCBjaGlsZCA9IHBhcmVudC5jaGlsZChpbmRleCk7XG4gICAgICAgIHJldHVybiBkT2ZmID8gcGFyZW50LmNoaWxkKGluZGV4KS5jdXQoZE9mZikgOiBjaGlsZDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBub2RlIGRpcmVjdGx5IGJlZm9yZSB0aGUgcG9zaXRpb24sIGlmIGFueS4gSWYgdGhlXG4gICAgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIG9ubHkgdGhlIHBhcnQgb2YgdGhhdCBub2RlXG4gICAgYmVmb3JlIHRoZSBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGdldCBub2RlQmVmb3JlKCkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmluZGV4KHRoaXMuZGVwdGgpO1xuICAgICAgICBsZXQgZE9mZiA9IHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGRPZmYpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGQoaW5kZXgpLmN1dCgwLCBkT2ZmKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09IDAgPyBudWxsIDogdGhpcy5wYXJlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIHBhcmVudCBub2RlIGF0IHRoZVxuICAgIGdpdmVuIGRlcHRoICh3aGljaCBkZWZhdWx0cyB0byBgdGhpcy5kZXB0aGApLlxuICAgICovXG4gICAgcG9zQXRJbmRleChpbmRleCwgZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5wYXRoW2RlcHRoICogM10sIHBvcyA9IGRlcHRoID09IDAgPyAwIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuICAgICAgICAgICAgcG9zICs9IG5vZGUuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWFya3MgYXQgdGhpcyBwb3NpdGlvbiwgZmFjdG9yaW5nIGluIHRoZSBzdXJyb3VuZGluZ1xuICAgIG1hcmtzJyBbYGluY2x1c2l2ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrU3BlYy5pbmNsdXNpdmUpIHByb3BlcnR5LiBJZiB0aGVcbiAgICBwb3NpdGlvbiBpcyBhdCB0aGUgc3RhcnQgb2YgYSBub24tZW1wdHkgbm9kZSwgdGhlIG1hcmtzIG9mIHRoZVxuICAgIG5vZGUgYWZ0ZXIgaXQgKGlmIGFueSkgYXJlIHJldHVybmVkLlxuICAgICovXG4gICAgbWFya3MoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudCwgaW5kZXggPSB0aGlzLmluZGV4KCk7XG4gICAgICAgIC8vIEluIGFuIGVtcHR5IHBhcmVudCwgcmV0dXJuIHRoZSBlbXB0eSBhcnJheVxuICAgICAgICBpZiAocGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIE1hcmsubm9uZTtcbiAgICAgICAgLy8gV2hlbiBpbnNpZGUgYSB0ZXh0IG5vZGUsIGp1c3QgcmV0dXJuIHRoZSB0ZXh0IG5vZGUncyBtYXJrc1xuICAgICAgICBpZiAodGhpcy50ZXh0T2Zmc2V0KVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZChpbmRleCkubWFya3M7XG4gICAgICAgIGxldCBtYWluID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXggLSAxKSwgb3RoZXIgPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgIC8vIElmIHRoZSBgYWZ0ZXJgIGZsYWcgaXMgdHJ1ZSBvZiB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSwgbWFrZVxuICAgICAgICAvLyB0aGUgbm9kZSBhZnRlciB0aGlzIHBvc2l0aW9uIHRoZSBtYWluIHJlZmVyZW5jZS5cbiAgICAgICAgaWYgKCFtYWluKSB7XG4gICAgICAgICAgICBsZXQgdG1wID0gbWFpbjtcbiAgICAgICAgICAgIG1haW4gPSBvdGhlcjtcbiAgICAgICAgICAgIG90aGVyID0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBhbGwgbWFya3MgaW4gdGhlIG1haW4gbm9kZSwgZXhjZXB0IHRob3NlIHRoYXQgaGF2ZVxuICAgICAgICAvLyBgaW5jbHVzaXZlYCBzZXQgdG8gZmFsc2UgYW5kIGFyZSBub3QgcHJlc2VudCBpbiB0aGUgb3RoZXIgbm9kZS5cbiAgICAgICAgbGV0IG1hcmtzID0gbWFpbi5tYXJrcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChtYXJrc1tpXS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSAmJiAoIW90aGVyIHx8ICFtYXJrc1tpXS5pc0luU2V0KG90aGVyLm1hcmtzKSkpXG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrc1tpLS1dLnJlbW92ZUZyb21TZXQobWFya3MpO1xuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWFya3MgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGlmIGFueSwgZXhjZXB0IHRob3NlXG4gICAgdGhhdCBhcmUgbm9uLWluY2x1c2l2ZSBhbmQgbm90IHByZXNlbnQgYXQgcG9zaXRpb24gYCRlbmRgLiBUaGlzXG4gICAgaXMgbW9zdGx5IHVzZWZ1bCBmb3IgZ2V0dGluZyB0aGUgc2V0IG9mIG1hcmtzIHRvIHByZXNlcnZlIGFmdGVyIGFcbiAgICBkZWxldGlvbi4gV2lsbCByZXR1cm4gYG51bGxgIGlmIHRoaXMgcG9zaXRpb24gaXMgYXQgdGhlIGVuZCBvZlxuICAgIGl0cyBwYXJlbnQgbm9kZSBvciBpdHMgcGFyZW50IG5vZGUgaXNuJ3QgYSB0ZXh0YmxvY2sgKGluIHdoaWNoXG4gICAgY2FzZSBubyBtYXJrcyBzaG91bGQgYmUgcHJlc2VydmVkKS5cbiAgICAqL1xuICAgIG1hcmtzQWNyb3NzKCRlbmQpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5wYXJlbnQubWF5YmVDaGlsZCh0aGlzLmluZGV4KCkpO1xuICAgICAgICBpZiAoIWFmdGVyIHx8ICFhZnRlci5pc0lubGluZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbWFya3MgPSBhZnRlci5tYXJrcywgbmV4dCA9ICRlbmQucGFyZW50Lm1heWJlQ2hpbGQoJGVuZC5pbmRleCgpKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChtYXJrc1tpXS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSAmJiAoIW5leHQgfHwgIW1hcmtzW2ldLmlzSW5TZXQobmV4dC5tYXJrcykpKVxuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3NbaS0tXS5yZW1vdmVGcm9tU2V0KG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZGVwdGggdXAgdG8gd2hpY2ggdGhpcyBwb3NpdGlvbiBhbmQgdGhlIGdpdmVuIChub24tcmVzb2x2ZWQpXG4gICAgcG9zaXRpb24gc2hhcmUgdGhlIHNhbWUgcGFyZW50IG5vZGVzLlxuICAgICovXG4gICAgc2hhcmVkRGVwdGgocG9zKSB7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gdGhpcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aC0tKVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnQoZGVwdGgpIDw9IHBvcyAmJiB0aGlzLmVuZChkZXB0aCkgPj0gcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXB0aDtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSByYW5nZSBiYXNlZCBvbiB0aGUgcGxhY2Ugd2hlcmUgdGhpcyBwb3NpdGlvbiBhbmQgdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb24gZGl2ZXJnZSBhcm91bmQgYmxvY2sgY29udGVudC4gSWYgYm90aCBwb2ludCBpbnRvXG4gICAgdGhlIHNhbWUgdGV4dGJsb2NrLCBmb3IgZXhhbXBsZSwgYSByYW5nZSBhcm91bmQgdGhhdCB0ZXh0YmxvY2tcbiAgICB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGV5IHBvaW50IGludG8gZGlmZmVyZW50IGJsb2NrcywgdGhlIHJhbmdlXG4gICAgYXJvdW5kIHRob3NlIGJsb2NrcyBpbiB0aGVpciBzaGFyZWQgYW5jZXN0b3IgaXMgcmV0dXJuZWQuIFlvdSBjYW5cbiAgICBwYXNzIGluIGFuIG9wdGlvbmFsIHByZWRpY2F0ZSB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYSBwYXJlbnRcbiAgICBub2RlIHRvIHNlZSBpZiBhIHJhbmdlIGludG8gdGhhdCBwYXJlbnQgaXMgYWNjZXB0YWJsZS5cbiAgICAqL1xuICAgIGJsb2NrUmFuZ2Uob3RoZXIgPSB0aGlzLCBwcmVkKSB7XG4gICAgICAgIGlmIChvdGhlci5wb3MgPCB0aGlzLnBvcylcbiAgICAgICAgICAgIHJldHVybiBvdGhlci5ibG9ja1JhbmdlKHRoaXMpO1xuICAgICAgICBmb3IgKGxldCBkID0gdGhpcy5kZXB0aCAtICh0aGlzLnBhcmVudC5pbmxpbmVDb250ZW50IHx8IHRoaXMucG9zID09IG90aGVyLnBvcyA/IDEgOiAwKTsgZCA+PSAwOyBkLS0pXG4gICAgICAgICAgICBpZiAob3RoZXIucG9zIDw9IHRoaXMuZW5kKGQpICYmICghcHJlZCB8fCBwcmVkKHRoaXMubm9kZShkKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVJhbmdlKHRoaXMsIG90aGVyLCBkKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhlIGdpdmVuIHBvc2l0aW9uIHNoYXJlcyB0aGUgc2FtZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIHNhbWVQYXJlbnQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5wYXJlbnRPZmZzZXQgPT0gb3RoZXIucG9zIC0gb3RoZXIucGFyZW50T2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIGdyZWF0ZXIgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbWF4KG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5wb3MgPiB0aGlzLnBvcyA/IG90aGVyIDogdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBzbWFsbGVyIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIG1pbihvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIucG9zIDwgdGhpcy5wb3MgPyBvdGhlciA6IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBzdHIgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzLmRlcHRoOyBpKyspXG4gICAgICAgICAgICBzdHIgKz0gKHN0ciA/IFwiL1wiIDogXCJcIikgKyB0aGlzLm5vZGUoaSkudHlwZS5uYW1lICsgXCJfXCIgKyB0aGlzLmluZGV4KGkgLSAxKTtcbiAgICAgICAgcmV0dXJuIHN0ciArIFwiOlwiICsgdGhpcy5wYXJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHJlc29sdmUoZG9jLCBwb3MpIHtcbiAgICAgICAgaWYgKCEocG9zID49IDAgJiYgcG9zIDw9IGRvYy5jb250ZW50LnNpemUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJQb3NpdGlvbiBcIiArIHBvcyArIFwiIG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgbGV0IHBhdGggPSBbXTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMCwgcGFyZW50T2Zmc2V0ID0gcG9zO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gZG9jOzspIHtcbiAgICAgICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgocGFyZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIGxldCByZW0gPSBwYXJlbnRPZmZzZXQgLSBvZmZzZXQ7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSwgaW5kZXgsIHN0YXJ0ICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICghcmVtKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gcmVtIC0gMTtcbiAgICAgICAgICAgIHN0YXJ0ICs9IG9mZnNldCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFBvcyhwb3MsIHBhdGgsIHBhcmVudE9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHJlc29sdmVDYWNoZWQoZG9jLCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlQ2FjaGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjYWNoZWQgPSByZXNvbHZlQ2FjaGVbaV07XG4gICAgICAgICAgICBpZiAoY2FjaGVkLnBvcyA9PSBwb3MgJiYgY2FjaGVkLmRvYyA9PSBkb2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gcmVzb2x2ZUNhY2hlW3Jlc29sdmVDYWNoZVBvc10gPSBSZXNvbHZlZFBvcy5yZXNvbHZlKGRvYywgcG9zKTtcbiAgICAgICAgcmVzb2x2ZUNhY2hlUG9zID0gKHJlc29sdmVDYWNoZVBvcyArIDEpICUgcmVzb2x2ZUNhY2hlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5sZXQgcmVzb2x2ZUNhY2hlID0gW10sIHJlc29sdmVDYWNoZVBvcyA9IDAsIHJlc29sdmVDYWNoZVNpemUgPSAxMjtcbi8qKlxuUmVwcmVzZW50cyBhIGZsYXQgcmFuZ2Ugb2YgY29udGVudCwgaS5lLiBvbmUgdGhhdCBzdGFydHMgYW5kXG5lbmRzIGluIHRoZSBzYW1lIG5vZGUuXG4qL1xuY2xhc3MgTm9kZVJhbmdlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBub2RlIHJhbmdlLiBgJGZyb21gIGFuZCBgJHRvYCBzaG91bGQgcG9pbnQgaW50byB0aGVcbiAgICBzYW1lIG5vZGUgdW50aWwgYXQgbGVhc3QgdGhlIGdpdmVuIGBkZXB0aGAsIHNpbmNlIGEgbm9kZSByYW5nZVxuICAgIGRlbm90ZXMgYW4gYWRqYWNlbnQgc2V0IG9mIG5vZGVzIGluIGEgc2luZ2xlIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQSByZXNvbHZlZCBwb3NpdGlvbiBhbG9uZyB0aGUgc3RhcnQgb2YgdGhlIGNvbnRlbnQuIE1heSBoYXZlIGFcbiAgICBgZGVwdGhgIGdyZWF0ZXIgdGhhbiB0aGlzIG9iamVjdCdzIGBkZXB0aGAgcHJvcGVydHksIHNpbmNlXG4gICAgdGhlc2UgYXJlIHRoZSBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgcmFuZ2UsXG4gICAgbm90IHJlLXJlc29sdmVkIHBvc2l0aW9ucyBkaXJlY3RseSBhdCBpdHMgYm91bmRhcmllcy5cbiAgICAqL1xuICAgICRmcm9tLCBcbiAgICAvKipcbiAgICBBIHBvc2l0aW9uIGFsb25nIHRoZSBlbmQgb2YgdGhlIGNvbnRlbnQuIFNlZVxuICAgIGNhdmVhdCBmb3IgW2AkZnJvbWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlUmFuZ2UuJGZyb20pLlxuICAgICovXG4gICAgJHRvLCBcbiAgICAvKipcbiAgICBUaGUgZGVwdGggb2YgdGhlIG5vZGUgdGhhdCB0aGlzIHJhbmdlIHBvaW50cyBpbnRvLlxuICAgICovXG4gICAgZGVwdGgpIHtcbiAgICAgICAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICAgICAgICB0aGlzLiR0byA9ICR0bztcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuJGZyb20uYmVmb3JlKHRoaXMuZGVwdGggKyAxKTsgfVxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLiR0by5hZnRlcih0aGlzLmRlcHRoICsgMSk7IH1cbiAgICAvKipcbiAgICBUaGUgcGFyZW50IG5vZGUgdGhhdCB0aGUgcmFuZ2UgcG9pbnRzIGludG8uXG4gICAgKi9cbiAgICBnZXQgcGFyZW50KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5ub2RlKHRoaXMuZGVwdGgpOyB9XG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSByYW5nZSBpbiB0aGUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBnZXQgc3RhcnRJbmRleCgpIHsgcmV0dXJuIHRoaXMuJGZyb20uaW5kZXgodGhpcy5kZXB0aCk7IH1cbiAgICAvKipcbiAgICBUaGUgZW5kIGluZGV4IG9mIHRoZSByYW5nZSBpbiB0aGUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBnZXQgZW5kSW5kZXgoKSB7IHJldHVybiB0aGlzLiR0by5pbmRleEFmdGVyKHRoaXMuZGVwdGgpOyB9XG59XG5cbmNvbnN0IGVtcHR5QXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5UaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBub2RlIGluIHRoZSB0cmVlIHRoYXQgbWFrZXMgdXAgYVxuUHJvc2VNaXJyb3IgZG9jdW1lbnQuIFNvIGEgZG9jdW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgYE5vZGVgLCB3aXRoXG5jaGlsZHJlbiB0aGF0IGFyZSBhbHNvIGluc3RhbmNlcyBvZiBgTm9kZWAuXG5cbk5vZGVzIGFyZSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlcy4gSW5zdGVhZCBvZiBjaGFuZ2luZyB0aGVtLCB5b3VcbmNyZWF0ZSBuZXcgb25lcyB3aXRoIHRoZSBjb250ZW50IHlvdSB3YW50LiBPbGQgb25lcyBrZWVwIHBvaW50aW5nXG5hdCB0aGUgb2xkIGRvY3VtZW50IHNoYXBlLiBUaGlzIGlzIG1hZGUgY2hlYXBlciBieSBzaGFyaW5nXG5zdHJ1Y3R1cmUgYmV0d2VlbiB0aGUgb2xkIGFuZCBuZXcgZGF0YSBhcyBtdWNoIGFzIHBvc3NpYmxlLCB3aGljaCBhXG50cmVlIHNoYXBlIGxpa2UgdGhpcyAod2l0aG91dCBiYWNrIHBvaW50ZXJzKSBtYWtlcyBlYXN5LlxuXG4qKkRvIG5vdCoqIGRpcmVjdGx5IG11dGF0ZSB0aGUgcHJvcGVydGllcyBvZiBhIGBOb2RlYCBvYmplY3QuIFNlZVxuW3RoZSBndWlkZV0oL2RvY3MvZ3VpZGUvI2RvYykgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4qL1xuY2xhc3MgTm9kZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiBub2RlIHRoYXQgdGhpcyBpcy5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIEFuIG9iamVjdCBtYXBwaW5nIGF0dHJpYnV0ZSBuYW1lcyB0byB2YWx1ZXMuIFRoZSBraW5kIG9mXG4gICAgYXR0cmlidXRlcyBhbGxvd2VkIGFuZCByZXF1aXJlZCBhcmVcbiAgICBbZGV0ZXJtaW5lZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmF0dHJzKSBieSB0aGUgbm9kZSB0eXBlLlxuICAgICovXG4gICAgYXR0cnMsIFxuICAgIC8vIEEgZnJhZ21lbnQgaG9sZGluZyB0aGUgbm9kZSdzIGNoaWxkcmVuLlxuICAgIGNvbnRlbnQsIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrcyAodGhpbmdzIGxpa2Ugd2hldGhlciBpdCBpcyBlbXBoYXNpemVkIG9yIHBhcnQgb2YgYVxuICAgIGxpbmspIGFwcGxpZWQgdG8gdGhpcyBub2RlLlxuICAgICovXG4gICAgbWFya3MgPSBNYXJrLm5vbmUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQgfHwgRnJhZ21lbnQuZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzaXplIG9mIHRoaXMgbm9kZSwgYXMgZGVmaW5lZCBieSB0aGUgaW50ZWdlci1iYXNlZCBbaW5kZXhpbmdcbiAgICBzY2hlbWVdKC9kb2NzL2d1aWRlLyNkb2MuaW5kZXhpbmcpLiBGb3IgdGV4dCBub2RlcywgdGhpcyBpcyB0aGVcbiAgICBhbW91bnQgb2YgY2hhcmFjdGVycy4gRm9yIG90aGVyIGxlYWYgbm9kZXMsIGl0IGlzIG9uZS4gRm9yXG4gICAgbm9uLWxlYWYgbm9kZXMsIGl0IGlzIHRoZSBzaXplIG9mIHRoZSBjb250ZW50IHBsdXMgdHdvICh0aGVcbiAgICBzdGFydCBhbmQgZW5kIHRva2VuKS5cbiAgICAqL1xuICAgIGdldCBub2RlU2l6ZSgpIHsgcmV0dXJuIHRoaXMuaXNMZWFmID8gMSA6IDIgKyB0aGlzLmNvbnRlbnQuc2l6ZTsgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCB0aGUgbm9kZSBoYXMuXG4gICAgKi9cbiAgICBnZXQgY2hpbGRDb3VudCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5jaGlsZENvdW50OyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC4gUmFpc2VzIGFuIGVycm9yIHdoZW4gdGhlXG4gICAgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgICovXG4gICAgY2hpbGQoaW5kZXgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5jaGlsZChpbmRleCk7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBpdCBleGlzdHMuXG4gICAgKi9cbiAgICBtYXliZUNoaWxkKGluZGV4KSB7IHJldHVybiB0aGlzLmNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7IH1cbiAgICAvKipcbiAgICBDYWxsIGBmYCBmb3IgZXZlcnkgY2hpbGQgbm9kZSwgcGFzc2luZyB0aGUgbm9kZSwgaXRzIG9mZnNldFxuICAgIGludG8gdGhpcyBwYXJlbnQgbm9kZSwgYW5kIGl0cyBpbmRleC5cbiAgICAqL1xuICAgIGZvckVhY2goZikgeyB0aGlzLmNvbnRlbnQuZm9yRWFjaChmKTsgfVxuICAgIC8qKlxuICAgIEludm9rZSBhIGNhbGxiYWNrIGZvciBhbGwgZGVzY2VuZGFudCBub2RlcyByZWN1cnNpdmVseSBiZXR3ZWVuXG4gICAgdGhlIGdpdmVuIHR3byBwb3NpdGlvbnMgdGhhdCBhcmUgcmVsYXRpdmUgdG8gc3RhcnQgb2YgdGhpc1xuICAgIG5vZGUncyBjb250ZW50LiBUaGUgY2FsbGJhY2sgaXMgaW52b2tlZCB3aXRoIHRoZSBub2RlLCBpdHNcbiAgICBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgb3JpZ2luYWwgbm9kZSAobWV0aG9kIHJlY2VpdmVyKSxcbiAgICBpdHMgcGFyZW50IG5vZGUsIGFuZCBpdHMgY2hpbGQgaW5kZXguIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnNcbiAgICBmYWxzZSBmb3IgYSBnaXZlbiBub2RlLCB0aGF0IG5vZGUncyBjaGlsZHJlbiB3aWxsIG5vdCBiZVxuICAgIHJlY3Vyc2VkIG92ZXIuIFRoZSBsYXN0IHBhcmFtZXRlciBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGFcbiAgICBzdGFydGluZyBwb3NpdGlvbiB0byBjb3VudCBmcm9tLlxuICAgICovXG4gICAgbm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBzdGFydFBvcyA9IDApIHtcbiAgICAgICAgdGhpcy5jb250ZW50Lm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgc3RhcnRQb3MsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDYWxsIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgZXZlcnkgZGVzY2VuZGFudCBub2RlLiBEb2Vzbid0XG4gICAgZGVzY2VuZCBpbnRvIGEgbm9kZSB3aGVuIHRoZSBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAuXG4gICAgKi9cbiAgICBkZXNjZW5kYW50cyhmKSB7XG4gICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKDAsIHRoaXMuY29udGVudC5zaXplLCBmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uY2F0ZW5hdGVzIGFsbCB0aGUgdGV4dCBub2RlcyBmb3VuZCBpbiB0aGlzIGZyYWdtZW50IGFuZCBpdHNcbiAgICBjaGlsZHJlbi5cbiAgICAqL1xuICAgIGdldCB0ZXh0Q29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzTGVhZiAmJiB0aGlzLnR5cGUuc3BlYy5sZWFmVGV4dClcbiAgICAgICAgICAgID8gdGhpcy50eXBlLnNwZWMubGVhZlRleHQodGhpcylcbiAgICAgICAgICAgIDogdGhpcy50ZXh0QmV0d2VlbigwLCB0aGlzLmNvbnRlbnQuc2l6ZSwgXCJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhbGwgdGV4dCBiZXR3ZWVuIHBvc2l0aW9ucyBgZnJvbWAgYW5kIGB0b2AuIFdoZW5cbiAgICBgYmxvY2tTZXBhcmF0b3JgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIGluc2VydGVkIHRvIHNlcGFyYXRlIHRleHRcbiAgICBmcm9tIGRpZmZlcmVudCBibG9jayBub2Rlcy4gSWYgYGxlYWZUZXh0YCBpcyBnaXZlbiwgaXQnbGwgYmVcbiAgICBpbnNlcnRlZCBmb3IgZXZlcnkgbm9uLXRleHQgbGVhZiBub2RlIGVuY291bnRlcmVkLCBvdGhlcndpc2VcbiAgICBbYGxlYWZUZXh0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjXmxlYWZUZXh0KSB3aWxsIGJlIHVzZWQuXG4gICAgKi9cbiAgICB0ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQudGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQsIG9yIGBudWxsYCBpZiB0aGVyZSBhcmUgbm9cbiAgICBjaGlsZHJlbi5cbiAgICAqL1xuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmZpcnN0Q2hpbGQ7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQsIG9yIGBudWxsYCBpZiB0aGVyZSBhcmUgbm9cbiAgICBjaGlsZHJlbi5cbiAgICAqL1xuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGFzdENoaWxkOyB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHR3byBub2RlcyByZXByZXNlbnQgdGhlIHNhbWUgcGllY2Ugb2YgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCAodGhpcy5zYW1lTWFya3VwKG90aGVyKSAmJiB0aGlzLmNvbnRlbnQuZXEob3RoZXIuY29udGVudCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoZSBtYXJrdXAgKHR5cGUsIGF0dHJpYnV0ZXMsIGFuZCBtYXJrcykgb2YgdGhpcyBub2RlIHRvXG4gICAgdGhvc2Ugb2YgYW5vdGhlci4gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBoYXZlIHRoZSBzYW1lIG1hcmt1cC5cbiAgICAqL1xuICAgIHNhbWVNYXJrdXAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzTWFya3VwKG90aGVyLnR5cGUsIG90aGVyLmF0dHJzLCBvdGhlci5tYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhpcyBub2RlJ3MgbWFya3VwIGNvcnJlc3BvbmQgdG8gdGhlIGdpdmVuIHR5cGUsXG4gICAgYXR0cmlidXRlcywgYW5kIG1hcmtzLlxuICAgICovXG4gICAgaGFzTWFya3VwKHR5cGUsIGF0dHJzLCBtYXJrcykge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IHR5cGUgJiZcbiAgICAgICAgICAgIGNvbXBhcmVEZWVwKHRoaXMuYXR0cnMsIGF0dHJzIHx8IHR5cGUuZGVmYXVsdEF0dHJzIHx8IGVtcHR5QXR0cnMpICYmXG4gICAgICAgICAgICBNYXJrLnNhbWVTZXQodGhpcy5tYXJrcywgbWFya3MgfHwgTWFyay5ub25lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG5vZGUgd2l0aCB0aGUgc2FtZSBtYXJrdXAgYXMgdGhpcyBub2RlLCBjb250YWluaW5nXG4gICAgdGhlIGdpdmVuIGNvbnRlbnQgKG9yIGVtcHR5LCBpZiBubyBjb250ZW50IGlzIGdpdmVuKS5cbiAgICAqL1xuICAgIGNvcHkoY29udGVudCA9IG51bGwpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT0gdGhpcy5jb250ZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIGNvbnRlbnQsIHRoaXMubWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgbm9kZSwgd2l0aCB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzIGluc3RlYWRcbiAgICBvZiB0aGUgbm9kZSdzIG93biBtYXJrcy5cbiAgICAqL1xuICAgIG1hcmsobWFya3MpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtzID09IHRoaXMubWFya3MgPyB0aGlzIDogbmV3IE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0aGlzLmNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUgd2l0aCBvbmx5IHRoZSBjb250ZW50IGJldHdlZW4gdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb25zLiBJZiBgdG9gIGlzIG5vdCBnaXZlbiwgaXQgZGVmYXVsdHMgdG8gdGhlIGVuZCBvZlxuICAgIHRoZSBub2RlLlxuICAgICovXG4gICAgY3V0KGZyb20sIHRvID0gdGhpcy5jb250ZW50LnNpemUpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KHRoaXMuY29udGVudC5jdXQoZnJvbSwgdG8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3V0IG91dCB0aGUgcGFydCBvZiB0aGUgZG9jdW1lbnQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zLCBhbmRcbiAgICByZXR1cm4gaXQgYXMgYSBgU2xpY2VgIG9iamVjdC5cbiAgICAqL1xuICAgIHNsaWNlKGZyb20sIHRvID0gdGhpcy5jb250ZW50LnNpemUsIGluY2x1ZGVQYXJlbnRzID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gdG8pXG4gICAgICAgICAgICByZXR1cm4gU2xpY2UuZW1wdHk7XG4gICAgICAgIGxldCAkZnJvbSA9IHRoaXMucmVzb2x2ZShmcm9tKSwgJHRvID0gdGhpcy5yZXNvbHZlKHRvKTtcbiAgICAgICAgbGV0IGRlcHRoID0gaW5jbHVkZVBhcmVudHMgPyAwIDogJGZyb20uc2hhcmVkRGVwdGgodG8pO1xuICAgICAgICBsZXQgc3RhcnQgPSAkZnJvbS5zdGFydChkZXB0aCksIG5vZGUgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBub2RlLmNvbnRlbnQuY3V0KCRmcm9tLnBvcyAtIHN0YXJ0LCAkdG8ucG9zIC0gc3RhcnQpO1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGNvbnRlbnQsICRmcm9tLmRlcHRoIC0gZGVwdGgsICR0by5kZXB0aCAtIGRlcHRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgcGFydCBvZiB0aGUgZG9jdW1lbnQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zIHdpdGhcbiAgICB0aGUgZ2l2ZW4gc2xpY2UuIFRoZSBzbGljZSBtdXN0ICdmaXQnLCBtZWFuaW5nIGl0cyBvcGVuIHNpZGVzXG4gICAgbXVzdCBiZSBhYmxlIHRvIGNvbm5lY3QgdG8gdGhlIHN1cnJvdW5kaW5nIGNvbnRlbnQsIGFuZCBpdHNcbiAgICBjb250ZW50IG5vZGVzIG11c3QgYmUgdmFsaWQgY2hpbGRyZW4gZm9yIHRoZSBub2RlIHRoZXkgYXJlIHBsYWNlZFxuICAgIGludG8uIElmIGFueSBvZiB0aGlzIGlzIHZpb2xhdGVkLCBhbiBlcnJvciBvZiB0eXBlXG4gICAgW2BSZXBsYWNlRXJyb3JgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUmVwbGFjZUVycm9yKSBpcyB0aHJvd24uXG4gICAgKi9cbiAgICByZXBsYWNlKGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZSh0aGlzLnJlc29sdmUoZnJvbSksIHRoaXMucmVzb2x2ZSh0byksIHNsaWNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgbm9kZSBkaXJlY3RseSBhZnRlciB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBub2RlQXQocG9zKSB7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSBwb3MgfHwgbm9kZS5pc1RleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICBwb3MgLT0gb2Zmc2V0ICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSAoZGlyZWN0KSBjaGlsZCBub2RlIGFmdGVyIHRoZSBnaXZlbiBvZmZzZXQsIGlmIGFueSxcbiAgICBhbmQgcmV0dXJuIGl0IGFsb25nIHdpdGggaXRzIGluZGV4IGFuZCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhpc1xuICAgIG5vZGUuXG4gICAgKi9cbiAgICBjaGlsZEFmdGVyKHBvcykge1xuICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSB0aGlzLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KSwgaW5kZXgsIG9mZnNldCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSAoZGlyZWN0KSBjaGlsZCBub2RlIGJlZm9yZSB0aGUgZ2l2ZW4gb2Zmc2V0LCBpZiBhbnksXG4gICAgYW5kIHJldHVybiBpdCBhbG9uZyB3aXRoIGl0cyBpbmRleCBhbmQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoaXNcbiAgICBub2RlLlxuICAgICovXG4gICAgY2hpbGRCZWZvcmUocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IG51bGwsIGluZGV4OiAwLCBvZmZzZXQ6IDAgfTtcbiAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gdGhpcy5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgcG9zKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50LmNoaWxkKGluZGV4KSwgaW5kZXgsIG9mZnNldCB9O1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuY29udGVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgICAgICByZXR1cm4geyBub2RlLCBpbmRleDogaW5kZXggLSAxLCBvZmZzZXQ6IG9mZnNldCAtIG5vZGUubm9kZVNpemUgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzb2x2ZSB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LCByZXR1cm5pbmcgYW5cbiAgICBbb2JqZWN0XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUmVzb2x2ZWRQb3MpIHdpdGggaW5mb3JtYXRpb24gYWJvdXQgaXRzIGNvbnRleHQuXG4gICAgKi9cbiAgICByZXNvbHZlKHBvcykgeyByZXR1cm4gUmVzb2x2ZWRQb3MucmVzb2x2ZUNhY2hlZCh0aGlzLCBwb3MpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNvbHZlTm9DYWNoZShwb3MpIHsgcmV0dXJuIFJlc29sdmVkUG9zLnJlc29sdmUodGhpcywgcG9zKTsgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciBhIGdpdmVuIG1hcmsgb3IgbWFyayB0eXBlIG9jY3VycyBpbiB0aGlzIGRvY3VtZW50XG4gICAgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIHJhbmdlSGFzTWFyayhmcm9tLCB0bywgdHlwZSkge1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRvID4gZnJvbSlcbiAgICAgICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBub2RlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5pc0luU2V0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFmb3VuZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgYmxvY2sgKG5vbi1pbmxpbmUgbm9kZSlcbiAgICAqL1xuICAgIGdldCBpc0Jsb2NrKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzQmxvY2s7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIHRleHRibG9jayBub2RlLCBhIGJsb2NrIG5vZGUgd2l0aCBpbmxpbmVcbiAgICBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzVGV4dGJsb2NrKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzVGV4dGJsb2NrOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBhbGxvd3MgaW5saW5lIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaW5saW5lQ29udGVudCgpIHsgcmV0dXJuIHRoaXMudHlwZS5pbmxpbmVDb250ZW50OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYW4gaW5saW5lIG5vZGUgKGEgdGV4dCBub2RlIG9yIGEgbm9kZSB0aGF0IGNhblxuICAgIGFwcGVhciBhbW9uZyB0ZXh0KS5cbiAgICAqL1xuICAgIGdldCBpc0lubGluZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0lubGluZTsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgdGV4dCBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzVGV4dCgpIHsgcmV0dXJuIHRoaXMudHlwZS5pc1RleHQ7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIGxlYWYgbm9kZS5cbiAgICAqL1xuICAgIGdldCBpc0xlYWYoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNMZWFmOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYW4gYXRvbSwgaS5lLiB3aGVuIGl0IGRvZXMgbm90IGhhdmUgZGlyZWN0bHlcbiAgICBlZGl0YWJsZSBjb250ZW50LiBUaGlzIGlzIHVzdWFsbHkgdGhlIHNhbWUgYXMgYGlzTGVhZmAsIGJ1dCBjYW5cbiAgICBiZSBjb25maWd1cmVkIHdpdGggdGhlIFtgYXRvbWAgcHJvcGVydHldKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5hdG9tKVxuICAgIG9uIGEgbm9kZSdzIHNwZWMgKHR5cGljYWxseSB1c2VkIHdoZW4gdGhlIG5vZGUgaXMgZGlzcGxheWVkIGFzXG4gICAgYW4gdW5lZGl0YWJsZSBbbm9kZSB2aWV3XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5Ob2RlVmlldykpLlxuICAgICovXG4gICAgZ2V0IGlzQXRvbSgpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0F0b207IH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBub2RlIGZvciBkZWJ1Z2dpbmdcbiAgICBwdXJwb3Nlcy5cbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKHRoaXMpO1xuICAgICAgICBsZXQgbmFtZSA9IHRoaXMudHlwZS5uYW1lO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICBuYW1lICs9IFwiKFwiICsgdGhpcy5jb250ZW50LnRvU3RyaW5nSW5uZXIoKSArIFwiKVwiO1xuICAgICAgICByZXR1cm4gd3JhcE1hcmtzKHRoaXMubWFya3MsIG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbnRlbnQgbWF0Y2ggaW4gdGhpcyBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAqL1xuICAgIGNvbnRlbnRNYXRjaEF0KGluZGV4KSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudCh0aGlzLmNvbnRlbnQsIDAsIGluZGV4KTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCBjb250ZW50TWF0Y2hBdCBvbiBhIG5vZGUgd2l0aCBpbnZhbGlkIGNvbnRlbnRcIik7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHJlcGxhY2luZyB0aGUgcmFuZ2UgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AgKGJ5XG4gICAgY2hpbGQgaW5kZXgpIHdpdGggdGhlIGdpdmVuIHJlcGxhY2VtZW50IGZyYWdtZW50ICh3aGljaCBkZWZhdWx0c1xuICAgIHRvIHRoZSBlbXB0eSBmcmFnbWVudCkgd291bGQgbGVhdmUgdGhlIG5vZGUncyBjb250ZW50IHZhbGlkLiBZb3VcbiAgICBjYW4gb3B0aW9uYWxseSBwYXNzIGBzdGFydGAgYW5kIGBlbmRgIGluZGljZXMgaW50byB0aGVcbiAgICByZXBsYWNlbWVudCBmcmFnbWVudC5cbiAgICAqL1xuICAgIGNhblJlcGxhY2UoZnJvbSwgdG8sIHJlcGxhY2VtZW50ID0gRnJhZ21lbnQuZW1wdHksIHN0YXJ0ID0gMCwgZW5kID0gcmVwbGFjZW1lbnQuY2hpbGRDb3VudCkge1xuICAgICAgICBsZXQgb25lID0gdGhpcy5jb250ZW50TWF0Y2hBdChmcm9tKS5tYXRjaEZyYWdtZW50KHJlcGxhY2VtZW50LCBzdGFydCwgZW5kKTtcbiAgICAgICAgbGV0IHR3byA9IG9uZSAmJiBvbmUubWF0Y2hGcmFnbWVudCh0aGlzLmNvbnRlbnQsIHRvKTtcbiAgICAgICAgaWYgKCF0d28gfHwgIXR3by52YWxpZEVuZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMudHlwZS5hbGxvd3NNYXJrcyhyZXBsYWNlbWVudC5jaGlsZChpKS5tYXJrcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHJlcGxhY2luZyB0aGUgcmFuZ2UgYGZyb21gIHRvIGB0b2AgKGJ5IGluZGV4KSB3aXRoXG4gICAgYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIHdvdWxkIGxlYXZlIHRoZSBub2RlJ3MgY29udGVudCB2YWxpZC5cbiAgICAqL1xuICAgIGNhblJlcGxhY2VXaXRoKGZyb20sIHRvLCB0eXBlLCBtYXJrcykge1xuICAgICAgICBpZiAobWFya3MgJiYgIXRoaXMudHlwZS5hbGxvd3NNYXJrcyhtYXJrcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuY29udGVudE1hdGNoQXQoZnJvbSkubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgICBsZXQgZW5kID0gc3RhcnQgJiYgc3RhcnQubWF0Y2hGcmFnbWVudCh0aGlzLmNvbnRlbnQsIHRvKTtcbiAgICAgICAgcmV0dXJuIGVuZCA/IGVuZC52YWxpZEVuZCA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIG5vZGUncyBjb250ZW50IGNvdWxkIGJlIGFwcGVuZGVkIHRvIHRoaXNcbiAgICBub2RlLiBJZiB0aGF0IG5vZGUgaXMgZW1wdHksIHRoaXMgd2lsbCBvbmx5IHJldHVybiB0cnVlIGlmIHRoZXJlXG4gICAgaXMgYXQgbGVhc3Qgb25lIG5vZGUgdHlwZSB0aGF0IGNhbiBhcHBlYXIgaW4gYm90aCBub2RlcyAodG8gYXZvaWRcbiAgICBtZXJnaW5nIGNvbXBsZXRlbHkgaW5jb21wYXRpYmxlIG5vZGVzKS5cbiAgICAqL1xuICAgIGNhbkFwcGVuZChvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FuUmVwbGFjZSh0aGlzLmNoaWxkQ291bnQsIHRoaXMuY2hpbGRDb3VudCwgb3RoZXIuY29udGVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQob3RoZXIudHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhpcyBub2RlIGFuZCBpdHMgZGVzY2VuZGFudHMgY29uZm9ybSB0byB0aGVcbiAgICBzY2hlbWEsIGFuZCByYWlzZSBlcnJvciB3aGVuIHRoZXkgZG8gbm90LlxuICAgICovXG4gICAgY2hlY2soKSB7XG4gICAgICAgIHRoaXMudHlwZS5jaGVja0NvbnRlbnQodGhpcy5jb250ZW50KTtcbiAgICAgICAgbGV0IGNvcHkgPSBNYXJrLm5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNvcHkgPSB0aGlzLm1hcmtzW2ldLmFkZFRvU2V0KGNvcHkpO1xuICAgICAgICBpZiAoIU1hcmsuc2FtZVNldChjb3B5LCB0aGlzLm1hcmtzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNvbGxlY3Rpb24gb2YgbWFya3MgZm9yIG5vZGUgJHt0aGlzLnR5cGUubmFtZX06ICR7dGhpcy5tYXJrcy5tYXAobSA9PiBtLnR5cGUubmFtZSl9YCk7XG4gICAgICAgIHRoaXMuY29udGVudC5mb3JFYWNoKG5vZGUgPT4gbm9kZS5jaGVjaygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG9iaiA9IHsgdHlwZTogdGhpcy50eXBlLm5hbWUgfTtcbiAgICAgICAgZm9yIChsZXQgXyBpbiB0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICBvYmouYXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgb2JqLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQudG9KU09OKCk7XG4gICAgICAgIGlmICh0aGlzLm1hcmtzLmxlbmd0aClcbiAgICAgICAgICAgIG9iai5tYXJrcyA9IHRoaXMubWFya3MubWFwKG4gPT4gbi50b0pTT04oKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbm9kZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE5vZGUuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCBtYXJrcyA9IG51bGw7XG4gICAgICAgIGlmIChqc29uLm1hcmtzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbi5tYXJrcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG1hcmsgZGF0YSBmb3IgTm9kZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgICAgIG1hcmtzID0ganNvbi5tYXJrcy5tYXAoc2NoZW1hLm1hcmtGcm9tSlNPTik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24udHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uLnRleHQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdGV4dCBub2RlIGluIEpTT05cIik7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLnRleHQoanNvbi50ZXh0LCBtYXJrcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tSlNPTihzY2hlbWEsIGpzb24uY29udGVudCk7XG4gICAgICAgIHJldHVybiBzY2hlbWEubm9kZVR5cGUoanNvbi50eXBlKS5jcmVhdGUoanNvbi5hdHRycywgY29udGVudCwgbWFya3MpO1xuICAgIH1cbn1cbk5vZGUucHJvdG90eXBlLnRleHQgPSB1bmRlZmluZWQ7XG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIE5vZGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IodHlwZSwgYXR0cnMsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIGF0dHJzLCBudWxsLCBtYXJrcyk7XG4gICAgICAgIGlmICghY29udGVudClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRW1wdHkgdGV4dCBub2RlcyBhcmUgbm90IGFsbG93ZWRcIik7XG4gICAgICAgIHRoaXMudGV4dCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKHRoaXMpO1xuICAgICAgICByZXR1cm4gd3JhcE1hcmtzKHRoaXMubWFya3MsIEpTT04uc3RyaW5naWZ5KHRoaXMudGV4dCkpO1xuICAgIH1cbiAgICBnZXQgdGV4dENvbnRlbnQoKSB7IHJldHVybiB0aGlzLnRleHQ7IH1cbiAgICB0ZXh0QmV0d2Vlbihmcm9tLCB0bykgeyByZXR1cm4gdGhpcy50ZXh0LnNsaWNlKGZyb20sIHRvKTsgfVxuICAgIGdldCBub2RlU2l6ZSgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBtYXJrKG1hcmtzKSB7XG4gICAgICAgIHJldHVybiBtYXJrcyA9PSB0aGlzLm1hcmtzID8gdGhpcyA6IG5ldyBUZXh0Tm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRoaXMudGV4dCwgbWFya3MpO1xuICAgIH1cbiAgICB3aXRoVGV4dCh0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0ID09IHRoaXMudGV4dClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGV4dCwgdGhpcy5tYXJrcyk7XG4gICAgfVxuICAgIGN1dChmcm9tID0gMCwgdG8gPSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoVGV4dCh0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy50ZXh0ID09IG90aGVyLnRleHQ7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGJhc2UgPSBzdXBlci50b0pTT04oKTtcbiAgICAgICAgYmFzZS50ZXh0ID0gdGhpcy50ZXh0O1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwTWFya3MobWFya3MsIHN0cikge1xuICAgIGZvciAobGV0IGkgPSBtYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgc3RyID0gbWFya3NbaV0udHlwZS5uYW1lICsgXCIoXCIgKyBzdHIgKyBcIilcIjtcbiAgICByZXR1cm4gc3RyO1xufVxuXG4vKipcbkluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIHJlcHJlc2VudCBhIG1hdGNoIHN0YXRlIG9mIGEgbm9kZSB0eXBlJ3Ncbltjb250ZW50IGV4cHJlc3Npb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5jb250ZW50KSwgYW5kIGNhbiBiZSB1c2VkIHRvXG5maW5kIG91dCB3aGV0aGVyIGZ1cnRoZXIgY29udGVudCBtYXRjaGVzIGhlcmUsIGFuZCB3aGV0aGVyIGEgZ2l2ZW5cbnBvc2l0aW9uIGlzIGEgdmFsaWQgZW5kIG9mIHRoZSBub2RlLlxuKi9cbmNsYXNzIENvbnRlbnRNYXRjaCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBtYXRjaCBzdGF0ZSByZXByZXNlbnRzIGEgdmFsaWQgZW5kIG9mIHRoZSBub2RlLlxuICAgICovXG4gICAgdmFsaWRFbmQpIHtcbiAgICAgICAgdGhpcy52YWxpZEVuZCA9IHZhbGlkRW5kO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubmV4dCA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMud3JhcENhY2hlID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHBhcnNlKHN0cmluZywgbm9kZVR5cGVzKSB7XG4gICAgICAgIGxldCBzdHJlYW0gPSBuZXcgVG9rZW5TdHJlYW0oc3RyaW5nLCBub2RlVHlwZXMpO1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBDb250ZW50TWF0Y2guZW1wdHk7XG4gICAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0cmVhbSk7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dClcbiAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRyYWlsaW5nIHRleHRcIik7XG4gICAgICAgIGxldCBtYXRjaCA9IGRmYShuZmEoZXhwcikpO1xuICAgICAgICBjaGVja0ZvckRlYWRFbmRzKG1hdGNoLCBzdHJlYW0pO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hdGNoIGEgbm9kZSB0eXBlLCByZXR1cm5pbmcgYSBtYXRjaCBhZnRlciB0aGF0IG5vZGUgaWZcbiAgICBzdWNjZXNzZnVsLlxuICAgICovXG4gICAgbWF0Y2hUeXBlKHR5cGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0W2ldLm5leHQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gbWF0Y2ggYSBmcmFnbWVudC4gUmV0dXJucyB0aGUgcmVzdWx0aW5nIG1hdGNoIHdoZW5cbiAgICBzdWNjZXNzZnVsLlxuICAgICovXG4gICAgbWF0Y2hGcmFnbWVudChmcmFnLCBzdGFydCA9IDAsIGVuZCA9IGZyYWcuY2hpbGRDb3VudCkge1xuICAgICAgICBsZXQgY3VyID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBjdXIgJiYgaSA8IGVuZDsgaSsrKVxuICAgICAgICAgICAgY3VyID0gY3VyLm1hdGNoVHlwZShmcmFnLmNoaWxkKGkpLnR5cGUpO1xuICAgICAgICByZXR1cm4gY3VyO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpbmxpbmVDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Lmxlbmd0aCAhPSAwICYmIHRoaXMubmV4dFswXS50eXBlLmlzSW5saW5lO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGZpcnN0IG1hdGNoaW5nIG5vZGUgdHlwZSBhdCB0aGlzIG1hdGNoIHBvc2l0aW9uIHRoYXQgY2FuXG4gICAgYmUgZ2VuZXJhdGVkLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRUeXBlKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgdHlwZSB9ID0gdGhpcy5uZXh0W2ldO1xuICAgICAgICAgICAgaWYgKCEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhdGlibGUob3RoZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG90aGVyLm5leHQubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dFtpXS50eXBlID09IG90aGVyLm5leHRbal0udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIG1hdGNoIHRoZSBnaXZlbiBmcmFnbWVudCwgYW5kIGlmIHRoYXQgZmFpbHMsIHNlZSBpZiBpdCBjYW5cbiAgICBiZSBtYWRlIHRvIG1hdGNoIGJ5IGluc2VydGluZyBub2RlcyBpbiBmcm9udCBvZiBpdC4gV2hlblxuICAgIHN1Y2Nlc3NmdWwsIHJldHVybiBhIGZyYWdtZW50IG9mIGluc2VydGVkIG5vZGVzICh3aGljaCBtYXkgYmVcbiAgICBlbXB0eSBpZiBub3RoaW5nIGhhZCB0byBiZSBpbnNlcnRlZCkuIFdoZW4gYHRvRW5kYCBpcyB0cnVlLCBvbmx5XG4gICAgcmV0dXJuIGEgZnJhZ21lbnQgaWYgdGhlIHJlc3VsdGluZyBtYXRjaCBnb2VzIHRvIHRoZSBlbmQgb2YgdGhlXG4gICAgY29udGVudCBleHByZXNzaW9uLlxuICAgICovXG4gICAgZmlsbEJlZm9yZShhZnRlciwgdG9FbmQgPSBmYWxzZSwgc3RhcnRJbmRleCA9IDApIHtcbiAgICAgICAgbGV0IHNlZW4gPSBbdGhpc107XG4gICAgICAgIGZ1bmN0aW9uIHNlYXJjaChtYXRjaCwgdHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IG1hdGNoLm1hdGNoRnJhZ21lbnQoYWZ0ZXIsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkICYmICghdG9FbmQgfHwgZmluaXNoZWQudmFsaWRFbmQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKHR5cGVzLm1hcCh0cCA9PiB0cC5jcmVhdGVBbmRGaWxsKCkpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2gubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IG1hdGNoLm5leHRbaV07XG4gICAgICAgICAgICAgICAgaWYgKCEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpICYmIHNlZW4uaW5kZXhPZihuZXh0KSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzZWVuLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IHNlYXJjaChuZXh0LCB0eXBlcy5jb25jYXQodHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlYXJjaCh0aGlzLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgYSBzZXQgb2Ygd3JhcHBpbmcgbm9kZSB0eXBlcyB0aGF0IHdvdWxkIGFsbG93IGEgbm9kZSBvZiB0aGVcbiAgICBnaXZlbiB0eXBlIHRvIGFwcGVhciBhdCB0aGlzIHBvc2l0aW9uLiBUaGUgcmVzdWx0IG1heSBiZSBlbXB0eVxuICAgICh3aGVuIGl0IGZpdHMgZGlyZWN0bHkpIGFuZCB3aWxsIGJlIG51bGwgd2hlbiBubyBzdWNoIHdyYXBwaW5nXG4gICAgZXhpc3RzLlxuICAgICovXG4gICAgZmluZFdyYXBwaW5nKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud3JhcENhY2hlLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKHRoaXMud3JhcENhY2hlW2ldID09IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwQ2FjaGVbaSArIDFdO1xuICAgICAgICBsZXQgY29tcHV0ZWQgPSB0aGlzLmNvbXB1dGVXcmFwcGluZyh0YXJnZXQpO1xuICAgICAgICB0aGlzLndyYXBDYWNoZS5wdXNoKHRhcmdldCwgY29tcHV0ZWQpO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcHV0ZVdyYXBwaW5nKHRhcmdldCkge1xuICAgICAgICBsZXQgc2VlbiA9IE9iamVjdC5jcmVhdGUobnVsbCksIGFjdGl2ZSA9IFt7IG1hdGNoOiB0aGlzLCB0eXBlOiBudWxsLCB2aWE6IG51bGwgfV07XG4gICAgICAgIHdoaWxlIChhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGFjdGl2ZS5zaGlmdCgpLCBtYXRjaCA9IGN1cnJlbnQubWF0Y2g7XG4gICAgICAgICAgICBpZiAobWF0Y2gubWF0Y2hUeXBlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb2JqID0gY3VycmVudDsgb2JqLnR5cGU7IG9iaiA9IG9iai52aWEpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iai50eXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2gubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IG1hdGNoLm5leHRbaV07XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlLmlzTGVhZiAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkgJiYgISh0eXBlLm5hbWUgaW4gc2VlbikgJiYgKCFjdXJyZW50LnR5cGUgfHwgbmV4dC52YWxpZEVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlLnB1c2goeyBtYXRjaDogdHlwZS5jb250ZW50TWF0Y2gsIHR5cGUsIHZpYTogY3VycmVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2Vlblt0eXBlLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2Ygb3V0Z29pbmcgZWRnZXMgdGhpcyBub2RlIGhhcyBpbiB0aGUgZmluaXRlXG4gICAgYXV0b21hdG9uIHRoYXQgZGVzY3JpYmVzIHRoZSBjb250ZW50IGV4cHJlc3Npb24uXG4gICAgKi9cbiAgICBnZXQgZWRnZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBfbl9cdTIwMEJ0aCBvdXRnb2luZyBlZGdlIGZyb20gdGhpcyBub2RlIGluIHRoZSBmaW5pdGVcbiAgICBhdXRvbWF0b24gdGhhdCBkZXNjcmliZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbi5cbiAgICAqL1xuICAgIGVkZ2Uobikge1xuICAgICAgICBpZiAobiA+PSB0aGlzLm5leHQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZXJlJ3Mgbm8gJHtufXRoIGVkZ2UgaW4gdGhpcyBjb250ZW50IG1hdGNoYCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRbbl07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBzZWVuID0gW107XG4gICAgICAgIGZ1bmN0aW9uIHNjYW4obSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKG0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihtLm5leHRbaV0ubmV4dCkgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNjYW4obS5uZXh0W2ldLm5leHQpO1xuICAgICAgICB9XG4gICAgICAgIHNjYW4odGhpcyk7XG4gICAgICAgIHJldHVybiBzZWVuLm1hcCgobSwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IG91dCA9IGkgKyAobS52YWxpZEVuZCA/IFwiKlwiIDogXCIgXCIpICsgXCIgXCI7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG0ubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBvdXQgKz0gKGkgPyBcIiwgXCIgOiBcIlwiKSArIG0ubmV4dFtpXS50eXBlLm5hbWUgKyBcIi0+XCIgKyBzZWVuLmluZGV4T2YobS5uZXh0W2ldLm5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSkuam9pbihcIlxcblwiKTtcbiAgICB9XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbkNvbnRlbnRNYXRjaC5lbXB0eSA9IG5ldyBDb250ZW50TWF0Y2godHJ1ZSk7XG5jbGFzcyBUb2tlblN0cmVhbSB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5nLCBub2RlVHlwZXMpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMubm9kZVR5cGVzID0gbm9kZVR5cGVzO1xuICAgICAgICB0aGlzLmlubGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBzdHJpbmcuc3BsaXQoL1xccyooPz1cXGJ8XFxXfCQpLyk7XG4gICAgICAgIGlmICh0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXSA9PSBcIlwiKVxuICAgICAgICAgICAgdGhpcy50b2tlbnMucG9wKCk7XG4gICAgICAgIGlmICh0aGlzLnRva2Vuc1swXSA9PSBcIlwiKVxuICAgICAgICAgICAgdGhpcy50b2tlbnMuc2hpZnQoKTtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnBvc107IH1cbiAgICBlYXQodG9rKSB7IHJldHVybiB0aGlzLm5leHQgPT0gdG9rICYmICh0aGlzLnBvcysrIHx8IHRydWUpOyB9XG4gICAgZXJyKHN0cikgeyB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3RyICsgXCIgKGluIGNvbnRlbnQgZXhwcmVzc2lvbiAnXCIgKyB0aGlzLnN0cmluZyArIFwiJylcIik7IH1cbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcihzdHJlYW0pIHtcbiAgICBsZXQgZXhwcnMgPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIGV4cHJzLnB1c2gocGFyc2VFeHByU2VxKHN0cmVhbSkpO1xuICAgIH0gd2hpbGUgKHN0cmVhbS5lYXQoXCJ8XCIpKTtcbiAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHsgdHlwZTogXCJjaG9pY2VcIiwgZXhwcnMgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwclNlcShzdHJlYW0pIHtcbiAgICBsZXQgZXhwcnMgPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIGV4cHJzLnB1c2gocGFyc2VFeHByU3Vic2NyaXB0KHN0cmVhbSkpO1xuICAgIH0gd2hpbGUgKHN0cmVhbS5uZXh0ICYmIHN0cmVhbS5uZXh0ICE9IFwiKVwiICYmIHN0cmVhbS5uZXh0ICE9IFwifFwiKTtcbiAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHsgdHlwZTogXCJzZXFcIiwgZXhwcnMgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwclN1YnNjcmlwdChzdHJlYW0pIHtcbiAgICBsZXQgZXhwciA9IHBhcnNlRXhwckF0b20oc3RyZWFtKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFwiK1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSB7IHR5cGU6IFwicGx1c1wiLCBleHByIH07XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKVxuICAgICAgICAgICAgZXhwciA9IHsgdHlwZTogXCJzdGFyXCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIj9cIikpXG4gICAgICAgICAgICBleHByID0geyB0eXBlOiBcIm9wdFwiLCBleHByIH07XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCJ7XCIpKVxuICAgICAgICAgICAgZXhwciA9IHBhcnNlRXhwclJhbmdlKHN0cmVhbSwgZXhwcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbn1cbmZ1bmN0aW9uIHBhcnNlTnVtKHN0cmVhbSkge1xuICAgIGlmICgvXFxELy50ZXN0KHN0cmVhbS5uZXh0KSlcbiAgICAgICAgc3RyZWFtLmVycihcIkV4cGVjdGVkIG51bWJlciwgZ290ICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpO1xuICAgIGxldCByZXN1bHQgPSBOdW1iZXIoc3RyZWFtLm5leHQpO1xuICAgIHN0cmVhbS5wb3MrKztcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByUmFuZ2Uoc3RyZWFtLCBleHByKSB7XG4gICAgbGV0IG1pbiA9IHBhcnNlTnVtKHN0cmVhbSksIG1heCA9IG1pbjtcbiAgICBpZiAoc3RyZWFtLmVhdChcIixcIikpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0ICE9IFwifVwiKVxuICAgICAgICAgICAgbWF4ID0gcGFyc2VOdW0oc3RyZWFtKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWF4ID0gLTE7XG4gICAgfVxuICAgIGlmICghc3RyZWFtLmVhdChcIn1cIikpXG4gICAgICAgIHN0cmVhbS5lcnIoXCJVbmNsb3NlZCBicmFjZWQgcmFuZ2VcIik7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJyYW5nZVwiLCBtaW4sIG1heCwgZXhwciB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZU5hbWUoc3RyZWFtLCBuYW1lKSB7XG4gICAgbGV0IHR5cGVzID0gc3RyZWFtLm5vZGVUeXBlcywgdHlwZSA9IHR5cGVzW25hbWVdO1xuICAgIGlmICh0eXBlKVxuICAgICAgICByZXR1cm4gW3R5cGVdO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB0eXBlTmFtZSBpbiB0eXBlcykge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW3R5cGVOYW1lXTtcbiAgICAgICAgaWYgKHR5cGUuZ3JvdXBzLmluZGV4T2YobmFtZSkgPiAtMSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHR5cGUpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PSAwKVxuICAgICAgICBzdHJlYW0uZXJyKFwiTm8gbm9kZSB0eXBlIG9yIGdyb3VwICdcIiArIG5hbWUgKyBcIicgZm91bmRcIik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwckF0b20oc3RyZWFtKSB7XG4gICAgaWYgKHN0cmVhbS5lYXQoXCIoXCIpKSB7XG4gICAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0cmVhbSk7XG4gICAgICAgIGlmICghc3RyZWFtLmVhdChcIilcIikpXG4gICAgICAgICAgICBzdHJlYW0uZXJyKFwiTWlzc2luZyBjbG9zaW5nIHBhcmVuXCIpO1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoIS9cXFcvLnRlc3Qoc3RyZWFtLm5leHQpKSB7XG4gICAgICAgIGxldCBleHBycyA9IHJlc29sdmVOYW1lKHN0cmVhbSwgc3RyZWFtLm5leHQpLm1hcCh0eXBlID0+IHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uaW5saW5lID09IG51bGwpXG4gICAgICAgICAgICAgICAgc3RyZWFtLmlubGluZSA9IHR5cGUuaXNJbmxpbmU7XG4gICAgICAgICAgICBlbHNlIGlmIChzdHJlYW0uaW5saW5lICE9IHR5cGUuaXNJbmxpbmUpXG4gICAgICAgICAgICAgICAgc3RyZWFtLmVycihcIk1peGluZyBpbmxpbmUgYW5kIGJsb2NrIGNvbnRlbnRcIik7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIm5hbWVcIiwgdmFsdWU6IHR5cGUgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbS5wb3MrKztcbiAgICAgICAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7IHR5cGU6IFwiY2hvaWNlXCIsIGV4cHJzIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHJlYW0uZXJyKFwiVW5leHBlY3RlZCB0b2tlbiAnXCIgKyBzdHJlYW0ubmV4dCArIFwiJ1wiKTtcbiAgICB9XG59XG4vKipcbkNvbnN0cnVjdCBhbiBORkEgZnJvbSBhbiBleHByZXNzaW9uIGFzIHJldHVybmVkIGJ5IHRoZSBwYXJzZXIuIFRoZVxuTkZBIGlzIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIHN0YXRlcywgd2hpY2ggYXJlIHRoZW1zZWx2ZXNcbmFycmF5cyBvZiBlZGdlcywgd2hpY2ggYXJlIGB7dGVybSwgdG99YCBvYmplY3RzLiBUaGUgZmlyc3Qgc3RhdGUgaXNcbnRoZSBlbnRyeSBzdGF0ZSBhbmQgdGhlIGxhc3Qgbm9kZSBpcyB0aGUgc3VjY2VzcyBzdGF0ZS5cblxuTm90ZSB0aGF0IHVubGlrZSB0eXBpY2FsIE5GQXMsIHRoZSBlZGdlIG9yZGVyaW5nIGluIHRoaXMgb25lIGlzXG5zaWduaWZpY2FudCwgaW4gdGhhdCBpdCBpcyB1c2VkIHRvIGNvbnRydWN0IGZpbGxlciBjb250ZW50IHdoZW5cbm5lY2Vzc2FyeS5cbiovXG5mdW5jdGlvbiBuZmEoZXhwcikge1xuICAgIGxldCBuZmEgPSBbW11dO1xuICAgIGNvbm5lY3QoY29tcGlsZShleHByLCAwKSwgbm9kZSgpKTtcbiAgICByZXR1cm4gbmZhO1xuICAgIGZ1bmN0aW9uIG5vZGUoKSB7IHJldHVybiBuZmEucHVzaChbXSkgLSAxOyB9XG4gICAgZnVuY3Rpb24gZWRnZShmcm9tLCB0bywgdGVybSkge1xuICAgICAgICBsZXQgZWRnZSA9IHsgdGVybSwgdG8gfTtcbiAgICAgICAgbmZhW2Zyb21dLnB1c2goZWRnZSk7XG4gICAgICAgIHJldHVybiBlZGdlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb25uZWN0KGVkZ2VzLCB0bykge1xuICAgICAgICBlZGdlcy5mb3JFYWNoKGVkZ2UgPT4gZWRnZS50byA9IHRvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGlsZShleHByLCBmcm9tKSB7XG4gICAgICAgIGlmIChleHByLnR5cGUgPT0gXCJjaG9pY2VcIikge1xuICAgICAgICAgICAgcmV0dXJuIGV4cHIuZXhwcnMucmVkdWNlKChvdXQsIGV4cHIpID0+IG91dC5jb25jYXQoY29tcGlsZShleHByLCBmcm9tKSksIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJzZXFcIikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNvbXBpbGUoZXhwci5leHByc1tpXSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gZXhwci5leHBycy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICBjb25uZWN0KG5leHQsIGZyb20gPSBub2RlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInN0YXJcIikge1xuICAgICAgICAgICAgbGV0IGxvb3AgPSBub2RlKCk7XG4gICAgICAgICAgICBlZGdlKGZyb20sIGxvb3ApO1xuICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgbG9vcCksIGxvb3ApO1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGxvb3ApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJwbHVzXCIpIHtcbiAgICAgICAgICAgIGxldCBsb29wID0gbm9kZSgpO1xuICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgZnJvbSksIGxvb3ApO1xuICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgbG9vcCksIGxvb3ApO1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGxvb3ApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJvcHRcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGZyb20pXS5jb25jYXQoY29tcGlsZShleHByLmV4cHIsIGZyb20pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJyYW5nZVwiKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwci5taW47IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZSgpO1xuICAgICAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIG5leHQpO1xuICAgICAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwci5tYXggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGV4cHIubWluOyBpIDwgZXhwci5tYXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgZWRnZShjdXIsIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UoY3VyKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwibmFtZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UoZnJvbSwgdW5kZWZpbmVkLCBleHByLnZhbHVlKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGV4cHIgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNtcChhLCBiKSB7IHJldHVybiBiIC0gYTsgfVxuLy8gR2V0IHRoZSBzZXQgb2Ygbm9kZXMgcmVhY2hhYmxlIGJ5IG51bGwgZWRnZXMgZnJvbSBgbm9kZWAuIE9taXRcbi8vIG5vZGVzIHdpdGggb25seSBhIHNpbmdsZSBudWxsLW91dC1lZGdlLCBzaW5jZSB0aGV5IG1heSBsZWFkIHRvXG4vLyBuZWVkbGVzcyBkdXBsaWNhdGVkIG5vZGVzLlxuZnVuY3Rpb24gbnVsbEZyb20obmZhLCBub2RlKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIHNjYW4obm9kZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5zb3J0KGNtcCk7XG4gICAgZnVuY3Rpb24gc2Nhbihub2RlKSB7XG4gICAgICAgIGxldCBlZGdlcyA9IG5mYVtub2RlXTtcbiAgICAgICAgaWYgKGVkZ2VzLmxlbmd0aCA9PSAxICYmICFlZGdlc1swXS50ZXJtKVxuICAgICAgICAgICAgcmV0dXJuIHNjYW4oZWRnZXNbMF0udG8pO1xuICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgdGVybSwgdG8gfSA9IGVkZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKCF0ZXJtICYmIHJlc3VsdC5pbmRleE9mKHRvKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBzY2FuKHRvKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIENvbXBpbGVzIGFuIE5GQSBhcyBwcm9kdWNlZCBieSBgbmZhYCBpbnRvIGEgREZBLCBtb2RlbGVkIGFzIGEgc2V0XG4vLyBvZiBzdGF0ZSBvYmplY3RzIChgQ29udGVudE1hdGNoYCBpbnN0YW5jZXMpIHdpdGggdHJhbnNpdGlvbnNcbi8vIGJldHdlZW4gdGhlbS5cbmZ1bmN0aW9uIGRmYShuZmEpIHtcbiAgICBsZXQgbGFiZWxlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuIGV4cGxvcmUobnVsbEZyb20obmZhLCAwKSk7XG4gICAgZnVuY3Rpb24gZXhwbG9yZShzdGF0ZXMpIHtcbiAgICAgICAgbGV0IG91dCA9IFtdO1xuICAgICAgICBzdGF0ZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIG5mYVtub2RlXS5mb3JFYWNoKCh7IHRlcm0sIHRvIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRlcm0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBsZXQgc2V0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0W2ldWzBdID09IHRlcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQgPSBvdXRbaV1bMV07XG4gICAgICAgICAgICAgICAgbnVsbEZyb20obmZhLCB0bykuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChbdGVybSwgc2V0ID0gW11dKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldC5pbmRleE9mKG5vZGUpID09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBzdGF0ZSA9IGxhYmVsZWRbc3RhdGVzLmpvaW4oXCIsXCIpXSA9IG5ldyBDb250ZW50TWF0Y2goc3RhdGVzLmluZGV4T2YobmZhLmxlbmd0aCAtIDEpID4gLTEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXRlcyA9IG91dFtpXVsxXS5zb3J0KGNtcCk7XG4gICAgICAgICAgICBzdGF0ZS5uZXh0LnB1c2goeyB0eXBlOiBvdXRbaV1bMF0sIG5leHQ6IGxhYmVsZWRbc3RhdGVzLmpvaW4oXCIsXCIpXSB8fCBleHBsb3JlKHN0YXRlcykgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSkge1xuICAgIGZvciAobGV0IGkgPSAwLCB3b3JrID0gW21hdGNoXTsgaSA8IHdvcmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHN0YXRlID0gd29ya1tpXSwgZGVhZCA9ICFzdGF0ZS52YWxpZEVuZCwgbm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0ZS5uZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBzdGF0ZS5uZXh0W2pdO1xuICAgICAgICAgICAgbm9kZXMucHVzaCh0eXBlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGRlYWQgJiYgISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkpXG4gICAgICAgICAgICAgICAgZGVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHdvcmsuaW5kZXhPZihuZXh0KSA9PSAtMSlcbiAgICAgICAgICAgICAgICB3b3JrLnB1c2gobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlYWQpXG4gICAgICAgICAgICBzdHJlYW0uZXJyKFwiT25seSBub24tZ2VuZXJhdGFibGUgbm9kZXMgKFwiICsgbm9kZXMuam9pbihcIiwgXCIpICsgXCIpIGluIGEgcmVxdWlyZWQgcG9zaXRpb24gKHNlZSBodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL2d1aWRlLyNnZW5lcmF0YWJsZSlcIik7XG4gICAgfVxufVxuXG4vLyBGb3Igbm9kZSB0eXBlcyB3aGVyZSBhbGwgYXR0cnMgaGF2ZSBhIGRlZmF1bHQgdmFsdWUgKG9yIHdoaWNoIGRvbid0XG4vLyBoYXZlIGFueSBhdHRyaWJ1dGVzKSwgYnVpbGQgdXAgYSBzaW5nbGUgcmV1c2FibGUgZGVmYXVsdCBhdHRyaWJ1dGVcbi8vIG9iamVjdCwgYW5kIHVzZSBpdCBmb3IgYWxsIG5vZGVzIHRoYXQgZG9uJ3Qgc3BlY2lmeSBzcGVjaWZpY1xuLy8gYXR0cmlidXRlcy5cbmZ1bmN0aW9uIGRlZmF1bHRBdHRycyhhdHRycykge1xuICAgIGxldCBkZWZhdWx0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgYXR0ck5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHIgPSBhdHRyc1thdHRyTmFtZV07XG4gICAgICAgIGlmICghYXR0ci5oYXNEZWZhdWx0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGRlZmF1bHRzW2F0dHJOYW1lXSA9IGF0dHIuZGVmYXVsdDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xufVxuZnVuY3Rpb24gY29tcHV0ZUF0dHJzKGF0dHJzLCB2YWx1ZSkge1xuICAgIGxldCBidWlsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycykge1xuICAgICAgICBsZXQgZ2l2ZW4gPSB2YWx1ZSAmJiB2YWx1ZVtuYW1lXTtcbiAgICAgICAgaWYgKGdpdmVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBhdHRyID0gYXR0cnNbbmFtZV07XG4gICAgICAgICAgICBpZiAoYXR0ci5oYXNEZWZhdWx0KVxuICAgICAgICAgICAgICAgIGdpdmVuID0gYXR0ci5kZWZhdWx0O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gdmFsdWUgc3VwcGxpZWQgZm9yIGF0dHJpYnV0ZSBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWx0W25hbWVdID0gZ2l2ZW47XG4gICAgfVxuICAgIHJldHVybiBidWlsdDtcbn1cbmZ1bmN0aW9uIGluaXRBdHRycyhhdHRycykge1xuICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChhdHRycylcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycylcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IG5ldyBBdHRyaWJ1dGUoYXR0cnNbbmFtZV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbk5vZGUgdHlwZXMgYXJlIG9iamVjdHMgYWxsb2NhdGVkIG9uY2UgcGVyIGBTY2hlbWFgIGFuZCB1c2VkIHRvXG5bdGFnXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS50eXBlKSBgTm9kZWAgaW5zdGFuY2VzLiBUaGV5IGNvbnRhaW4gaW5mb3JtYXRpb25cbmFib3V0IHRoZSBub2RlIHR5cGUsIHN1Y2ggYXMgaXRzIG5hbWUgYW5kIHdoYXQga2luZCBvZiBub2RlIGl0XG5yZXByZXNlbnRzLlxuKi9cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIHRoZSBub2RlIHR5cGUgaGFzIGluIHRoaXMgc2NoZW1hLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQSBsaW5rIGJhY2sgdG8gdGhlIGBTY2hlbWFgIHRoZSBub2RlIHR5cGUgYmVsb25ncyB0by5cbiAgICAqL1xuICAgIHNjaGVtYSwgXG4gICAgLyoqXG4gICAgVGhlIHNwZWMgdGhhdCB0aGlzIHR5cGUgaXMgYmFzZWQgb25cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc2V0IG9mIG1hcmtzIGFsbG93ZWQgaW4gdGhpcyBub2RlLiBgbnVsbGAgbWVhbnMgYWxsIG1hcmtzXG4gICAgICAgIGFyZSBhbGxvd2VkLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcmtTZXQgPSBudWxsO1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHNwZWMuZ3JvdXAgPyBzcGVjLmdyb3VwLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB0aGlzLmF0dHJzID0gaW5pdEF0dHJzKHNwZWMuYXR0cnMpO1xuICAgICAgICB0aGlzLmRlZmF1bHRBdHRycyA9IGRlZmF1bHRBdHRycyh0aGlzLmF0dHJzKTtcbiAgICAgICAgdGhpcy5jb250ZW50TWF0Y2ggPSBudWxsO1xuICAgICAgICB0aGlzLmlubGluZUNvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQmxvY2sgPSAhKHNwZWMuaW5saW5lIHx8IG5hbWUgPT0gXCJ0ZXh0XCIpO1xuICAgICAgICB0aGlzLmlzVGV4dCA9IG5hbWUgPT0gXCJ0ZXh0XCI7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgdGhpcyBpcyBhbiBpbmxpbmUgdHlwZS5cbiAgICAqL1xuICAgIGdldCBpc0lubGluZSgpIHsgcmV0dXJuICF0aGlzLmlzQmxvY2s7IH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHRoaXMgaXMgYSB0ZXh0YmxvY2sgdHlwZSwgYSBibG9jayB0aGF0IGNvbnRhaW5zIGlubGluZVxuICAgIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0YmxvY2soKSB7IHJldHVybiB0aGlzLmlzQmxvY2sgJiYgdGhpcy5pbmxpbmVDb250ZW50OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSBmb3Igbm9kZSB0eXBlcyB0aGF0IGFsbG93IG5vIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNMZWFmKCkgeyByZXR1cm4gdGhpcy5jb250ZW50TWF0Y2ggPT0gQ29udGVudE1hdGNoLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBhbiBhdG9tLCBpLmUuIHdoZW4gaXQgZG9lcyBub3QgaGF2ZVxuICAgIGRpcmVjdGx5IGVkaXRhYmxlIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNBdG9tKCkgeyByZXR1cm4gdGhpcy5pc0xlYWYgfHwgISF0aGlzLnNwZWMuYXRvbTsgfVxuICAgIC8qKlxuICAgIFRoZSBub2RlIHR5cGUncyBbd2hpdGVzcGFjZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLndoaXRlc3BhY2UpIG9wdGlvbi5cbiAgICAqL1xuICAgIGdldCB3aGl0ZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLndoaXRlc3BhY2UgfHwgKHRoaXMuc3BlYy5jb2RlID8gXCJwcmVcIiA6IFwibm9ybWFsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGlzIG5vZGUgdHlwZSBoYXMgYW55IHJlcXVpcmVkIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBoYXNSZXF1aXJlZEF0dHJzKCkge1xuICAgICAgICBmb3IgKGxldCBuIGluIHRoaXMuYXR0cnMpXG4gICAgICAgICAgICBpZiAodGhpcy5hdHRyc1tuXS5pc1JlcXVpcmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgbm9kZSBhbGxvd3Mgc29tZSBvZiB0aGUgc2FtZSBjb250ZW50IGFzXG4gICAgdGhlIGdpdmVuIG5vZGUgdHlwZS5cbiAgICAqL1xuICAgIGNvbXBhdGlibGVDb250ZW50KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29udGVudE1hdGNoLmNvbXBhdGlibGUob3RoZXIuY29udGVudE1hdGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wdXRlQXR0cnMoYXR0cnMpIHtcbiAgICAgICAgaWYgKCFhdHRycyAmJiB0aGlzLmRlZmF1bHRBdHRycylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRBdHRycztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGVBdHRycyh0aGlzLmF0dHJzLCBhdHRycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGBOb2RlYCBvZiB0aGlzIHR5cGUuIFRoZSBnaXZlbiBhdHRyaWJ1dGVzIGFyZVxuICAgIGNoZWNrZWQgYW5kIGRlZmF1bHRlZCAoeW91IGNhbiBwYXNzIGBudWxsYCB0byB1c2UgdGhlIHR5cGUnc1xuICAgIGRlZmF1bHRzIGVudGlyZWx5LCBpZiBubyByZXF1aXJlZCBhdHRyaWJ1dGVzIGV4aXN0KS4gYGNvbnRlbnRgXG4gICAgbWF5IGJlIGEgYEZyYWdtZW50YCwgYSBub2RlLCBhbiBhcnJheSBvZiBub2Rlcywgb3JcbiAgICBgbnVsbGAuIFNpbWlsYXJseSBgbWFya3NgIG1heSBiZSBgbnVsbGAgdG8gZGVmYXVsdCB0byB0aGUgZW1wdHlcbiAgICBzZXQgb2YgbWFya3MuXG4gICAgKi9cbiAgICBjcmVhdGUoYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBpZiAodGhpcy5pc1RleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlVHlwZS5jcmVhdGUgY2FuJ3QgY29uc3RydWN0IHRleHQgbm9kZXNcIik7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyksIEZyYWdtZW50LmZyb20oY29udGVudCksIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgY3JlYXRlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVUeXBlLmNyZWF0ZSksIGJ1dCBjaGVjayB0aGUgZ2l2ZW4gY29udGVudFxuICAgIGFnYWluc3QgdGhlIG5vZGUgdHlwZSdzIGNvbnRlbnQgcmVzdHJpY3Rpb25zLCBhbmQgdGhyb3cgYW4gZXJyb3JcbiAgICBpZiBpdCBkb2Vzbid0IG1hdGNoLlxuICAgICovXG4gICAgY3JlYXRlQ2hlY2tlZChhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKGNvbnRlbnQpO1xuICAgICAgICB0aGlzLmNoZWNrQ29udGVudChjb250ZW50KTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKSwgY29udGVudCwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIExpa2UgW2BjcmVhdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUuY3JlYXRlKSwgYnV0IHNlZSBpZiBpdCBpc1xuICAgIG5lY2Vzc2FyeSB0byBhZGQgbm9kZXMgdG8gdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgZ2l2ZW4gZnJhZ21lbnRcbiAgICB0byBtYWtlIGl0IGZpdCB0aGUgbm9kZS4gSWYgbm8gZml0dGluZyB3cmFwcGluZyBjYW4gYmUgZm91bmQsXG4gICAgcmV0dXJuIG51bGwuIE5vdGUgdGhhdCwgZHVlIHRvIHRoZSBmYWN0IHRoYXQgcmVxdWlyZWQgbm9kZXMgY2FuXG4gICAgYWx3YXlzIGJlIGNyZWF0ZWQsIHRoaXMgd2lsbCBhbHdheXMgc3VjY2VlZCBpZiB5b3UgcGFzcyBudWxsIG9yXG4gICAgYEZyYWdtZW50LmVtcHR5YCBhcyBjb250ZW50LlxuICAgICovXG4gICAgY3JlYXRlQW5kRmlsbChhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGF0dHJzID0gdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpO1xuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbShjb250ZW50KTtcbiAgICAgICAgaWYgKGNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHRoaXMuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoY29udGVudCk7XG4gICAgICAgICAgICBpZiAoIWJlZm9yZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBiZWZvcmUuYXBwZW5kKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXRjaGVkID0gdGhpcy5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgICAgbGV0IGFmdGVyID0gbWF0Y2hlZCAmJiBtYXRjaGVkLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgICBpZiAoIWFmdGVyKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCBhdHRycywgY29udGVudC5hcHBlbmQoYWZ0ZXIpLCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmcmFnbWVudCBpcyB2YWxpZCBjb250ZW50IGZvciB0aGlzIG5vZGVcbiAgICB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICB2YWxpZENvbnRlbnQoY29udGVudCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC52YWxpZEVuZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrcyhjb250ZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaHJvd3MgYSBSYW5nZUVycm9yIGlmIHRoZSBnaXZlbiBmcmFnbWVudCBpcyBub3QgdmFsaWQgY29udGVudCBmb3IgdGhpc1xuICAgIG5vZGUgdHlwZS5cbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoZWNrQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZENvbnRlbnQoY29udGVudCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjb250ZW50IGZvciBub2RlICR7dGhpcy5uYW1lfTogJHtjb250ZW50LnRvU3RyaW5nKCkuc2xpY2UoMCwgNTApfWApO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBtYXJrIHR5cGUgaXMgYWxsb3dlZCBpbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBhbGxvd3NNYXJrVHlwZShtYXJrVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXJrU2V0ID09IG51bGwgfHwgdGhpcy5tYXJrU2V0LmluZGV4T2YobWFya1R5cGUpID4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzIGFyZSBhbGxvd2VkIGluIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIGFsbG93c01hcmtzKG1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtTZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtUeXBlKG1hcmtzW2ldLnR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZXMgdGhlIG1hcmtzIHRoYXQgYXJlIG5vdCBhbGxvd2VkIGluIHRoaXMgbm9kZSBmcm9tIHRoZSBnaXZlbiBzZXQuXG4gICAgKi9cbiAgICBhbGxvd2VkTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya1NldCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgICAgICBsZXQgY29weTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtUeXBlKG1hcmtzW2ldLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gbWFya3Muc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3B5KSB7XG4gICAgICAgICAgICAgICAgY29weS5wdXNoKG1hcmtzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWNvcHkgPyBtYXJrcyA6IGNvcHkubGVuZ3RoID8gY29weSA6IE1hcmsubm9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGlsZShub2Rlcywgc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKChuYW1lLCBzcGVjKSA9PiByZXN1bHRbbmFtZV0gPSBuZXcgTm9kZVR5cGUobmFtZSwgc2NoZW1hLCBzcGVjKSk7XG4gICAgICAgIGxldCB0b3BUeXBlID0gc2NoZW1hLnNwZWMudG9wTm9kZSB8fCBcImRvY1wiO1xuICAgICAgICBpZiAoIXJlc3VsdFt0b3BUeXBlXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2NoZW1hIGlzIG1pc3NpbmcgaXRzIHRvcCBub2RlIHR5cGUgKCdcIiArIHRvcFR5cGUgKyBcIicpXCIpO1xuICAgICAgICBpZiAoIXJlc3VsdC50ZXh0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFdmVyeSBzY2hlbWEgbmVlZHMgYSAndGV4dCcgdHlwZVwiKTtcbiAgICAgICAgZm9yIChsZXQgXyBpbiByZXN1bHQudGV4dC5hdHRycylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHRleHQgbm9kZSB0eXBlIHNob3VsZCBub3QgaGF2ZSBhdHRyaWJ1dGVzXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIEF0dHJpYnV0ZSBkZXNjcmlwdG9yc1xuY2xhc3MgQXR0cmlidXRlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaGFzRGVmYXVsdCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcImRlZmF1bHRcIik7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IG9wdGlvbnMuZGVmYXVsdDtcbiAgICB9XG4gICAgZ2V0IGlzUmVxdWlyZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5oYXNEZWZhdWx0O1xuICAgIH1cbn1cbi8vIE1hcmtzXG4vKipcbkxpa2Ugbm9kZXMsIG1hcmtzICh3aGljaCBhcmUgYXNzb2NpYXRlZCB3aXRoIG5vZGVzIHRvIHNpZ25pZnlcbnRoaW5ncyBsaWtlIGVtcGhhc2lzIG9yIGJlaW5nIHBhcnQgb2YgYSBsaW5rKSBhcmVcblt0YWdnZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrLnR5cGUpIHdpdGggdHlwZSBvYmplY3RzLCB3aGljaCBhcmVcbmluc3RhbnRpYXRlZCBvbmNlIHBlciBgU2NoZW1hYC5cbiovXG5jbGFzcyBNYXJrVHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSBvZiB0aGUgbWFyayB0eXBlLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByYW5rLCBcbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIHRoYXQgdGhpcyBtYXJrIHR5cGUgaW5zdGFuY2UgaXMgcGFydCBvZi5cbiAgICAqL1xuICAgIHNjaGVtYSwgXG4gICAgLyoqXG4gICAgVGhlIHNwZWMgb24gd2hpY2ggdGhlIHR5cGUgaXMgYmFzZWQuXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucmFuayA9IHJhbms7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICB0aGlzLmF0dHJzID0gaW5pdEF0dHJzKHNwZWMuYXR0cnMpO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVkID0gbnVsbDtcbiAgICAgICAgbGV0IGRlZmF1bHRzID0gZGVmYXVsdEF0dHJzKHRoaXMuYXR0cnMpO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gZGVmYXVsdHMgPyBuZXcgTWFyayh0aGlzLCBkZWZhdWx0cykgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIG9mIHRoaXMgdHlwZS4gYGF0dHJzYCBtYXkgYmUgYG51bGxgIG9yIGFuIG9iamVjdFxuICAgIGNvbnRhaW5pbmcgb25seSBzb21lIG9mIHRoZSBtYXJrJ3MgYXR0cmlidXRlcy4gVGhlIG90aGVycywgaWZcbiAgICB0aGV5IGhhdmUgZGVmYXVsdHMsIHdpbGwgYmUgYWRkZWQuXG4gICAgKi9cbiAgICBjcmVhdGUoYXR0cnMgPSBudWxsKSB7XG4gICAgICAgIGlmICghYXR0cnMgJiYgdGhpcy5pbnN0YW5jZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICAgICAgICByZXR1cm4gbmV3IE1hcmsodGhpcywgY29tcHV0ZUF0dHJzKHRoaXMuYXR0cnMsIGF0dHJzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNvbXBpbGUobWFya3MsIHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcmFuayA9IDA7XG4gICAgICAgIG1hcmtzLmZvckVhY2goKG5hbWUsIHNwZWMpID0+IHJlc3VsdFtuYW1lXSA9IG5ldyBNYXJrVHlwZShuYW1lLCByYW5rKyssIHNjaGVtYSwgc3BlYykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGVuIHRoZXJlIGlzIGEgbWFyayBvZiB0aGlzIHR5cGUgaW4gdGhlIGdpdmVuIHNldCwgYSBuZXcgc2V0XG4gICAgd2l0aG91dCBpdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCB0aGUgaW5wdXQgc2V0IGlzIHJldHVybmVkLlxuICAgICovXG4gICAgcmVtb3ZlRnJvbVNldChzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHNldCA9IHNldC5zbGljZSgwLCBpKS5jb25jYXQoc2V0LnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0cyB3aGV0aGVyIHRoZXJlIGlzIGEgbWFyayBvZiB0aGlzIHR5cGUgaW4gdGhlIGdpdmVuIHNldC5cbiAgICAqL1xuICAgIGlzSW5TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHNldFtpXS50eXBlID09IHRoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFtpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcmllcyB3aGV0aGVyIGEgZ2l2ZW4gbWFyayB0eXBlIGlzXG4gICAgW2V4Y2x1ZGVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuZXhjbHVkZXMpIGJ5IHRoaXMgb25lLlxuICAgICovXG4gICAgZXhjbHVkZXMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhjbHVkZWQuaW5kZXhPZihvdGhlcikgPiAtMTtcbiAgICB9XG59XG4vKipcbkEgZG9jdW1lbnQgc2NoZW1hLiBIb2xkcyBbbm9kZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVUeXBlKSBhbmQgW21hcmtcbnR5cGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrVHlwZSkgb2JqZWN0cyBmb3IgdGhlIG5vZGVzIGFuZCBtYXJrcyB0aGF0IG1heVxub2NjdXIgaW4gY29uZm9ybWluZyBkb2N1bWVudHMsIGFuZCBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvclxuY3JlYXRpbmcgYW5kIGRlc2VyaWFsaXppbmcgc3VjaCBkb2N1bWVudHMuXG5cbldoZW4gZ2l2ZW4sIHRoZSB0eXBlIHBhcmFtZXRlcnMgcHJvdmlkZSB0aGUgbmFtZXMgb2YgdGhlIG5vZGVzIGFuZFxubWFya3MgaW4gdGhpcyBzY2hlbWEuXG4qL1xuY2xhc3MgU2NoZW1hIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBzY2hlbWEgZnJvbSBhIHNjaGVtYSBbc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlNjaGVtYVNwZWMpLlxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICAvKipcbiAgICAgICAgQW4gb2JqZWN0IGZvciBzdG9yaW5nIHdoYXRldmVyIHZhbHVlcyBtb2R1bGVzIG1heSB3YW50IHRvXG4gICAgICAgIGNvbXB1dGUgYW5kIGNhY2hlIHBlciBzY2hlbWEuIChJZiB5b3Ugd2FudCB0byBzdG9yZSBzb21ldGhpbmdcbiAgICAgICAgaW4gaXQsIHRyeSB0byB1c2UgcHJvcGVydHkgbmFtZXMgdW5saWtlbHkgdG8gY2xhc2guKVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhY2hlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBpbnN0YW5jZVNwZWMgPSB0aGlzLnNwZWMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKVxuICAgICAgICAgICAgaW5zdGFuY2VTcGVjW3Byb3BdID0gc3BlY1twcm9wXTtcbiAgICAgICAgaW5zdGFuY2VTcGVjLm5vZGVzID0gT3JkZXJlZE1hcC5mcm9tKHNwZWMubm9kZXMpLFxuICAgICAgICAgICAgaW5zdGFuY2VTcGVjLm1hcmtzID0gT3JkZXJlZE1hcC5mcm9tKHNwZWMubWFya3MgfHwge30pLFxuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IE5vZGVUeXBlLmNvbXBpbGUodGhpcy5zcGVjLm5vZGVzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5tYXJrcyA9IE1hcmtUeXBlLmNvbXBpbGUodGhpcy5zcGVjLm1hcmtzLCB0aGlzKTtcbiAgICAgICAgbGV0IGNvbnRlbnRFeHByQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIHRoaXMubWFya3MpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IocHJvcCArIFwiIGNhbiBub3QgYmUgYm90aCBhIG5vZGUgYW5kIGEgbWFya1wiKTtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5ub2Rlc1twcm9wXSwgY29udGVudEV4cHIgPSB0eXBlLnNwZWMuY29udGVudCB8fCBcIlwiLCBtYXJrRXhwciA9IHR5cGUuc3BlYy5tYXJrcztcbiAgICAgICAgICAgIHR5cGUuY29udGVudE1hdGNoID0gY29udGVudEV4cHJDYWNoZVtjb250ZW50RXhwcl0gfHxcbiAgICAgICAgICAgICAgICAoY29udGVudEV4cHJDYWNoZVtjb250ZW50RXhwcl0gPSBDb250ZW50TWF0Y2gucGFyc2UoY29udGVudEV4cHIsIHRoaXMubm9kZXMpKTtcbiAgICAgICAgICAgIHR5cGUuaW5saW5lQ29udGVudCA9IHR5cGUuY29udGVudE1hdGNoLmlubGluZUNvbnRlbnQ7XG4gICAgICAgICAgICB0eXBlLm1hcmtTZXQgPSBtYXJrRXhwciA9PSBcIl9cIiA/IG51bGwgOlxuICAgICAgICAgICAgICAgIG1hcmtFeHByID8gZ2F0aGVyTWFya3ModGhpcywgbWFya0V4cHIuc3BsaXQoXCIgXCIpKSA6XG4gICAgICAgICAgICAgICAgICAgIG1hcmtFeHByID09IFwiXCIgfHwgIXR5cGUuaW5saW5lQ29udGVudCA/IFtdIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHRoaXMubWFya3MpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5tYXJrc1twcm9wXSwgZXhjbCA9IHR5cGUuc3BlYy5leGNsdWRlcztcbiAgICAgICAgICAgIHR5cGUuZXhjbHVkZWQgPSBleGNsID09IG51bGwgPyBbdHlwZV0gOiBleGNsID09IFwiXCIgPyBbXSA6IGdhdGhlck1hcmtzKHRoaXMsIGV4Y2wuc3BsaXQoXCIgXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVGcm9tSlNPTiA9IHRoaXMubm9kZUZyb21KU09OLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubWFya0Zyb21KU09OID0gdGhpcy5tYXJrRnJvbUpTT04uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50b3BOb2RlVHlwZSA9IHRoaXMubm9kZXNbdGhpcy5zcGVjLnRvcE5vZGUgfHwgXCJkb2NcIl07XG4gICAgICAgIHRoaXMuY2FjaGVkLndyYXBwaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5vZGUgaW4gdGhpcyBzY2hlbWEuIFRoZSBgdHlwZWAgbWF5IGJlIGEgc3RyaW5nIG9yIGFcbiAgICBgTm9kZVR5cGVgIGluc3RhbmNlLiBBdHRyaWJ1dGVzIHdpbGwgYmUgZXh0ZW5kZWQgd2l0aCBkZWZhdWx0cyxcbiAgICBgY29udGVudGAgbWF5IGJlIGEgYEZyYWdtZW50YCwgYG51bGxgLCBhIGBOb2RlYCwgb3IgYW4gYXJyYXkgb2ZcbiAgICBub2Rlcy5cbiAgICAqL1xuICAgIG5vZGUodHlwZSwgYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLm5vZGVUeXBlKHR5cGUpO1xuICAgICAgICBlbHNlIGlmICghKHR5cGUgaW5zdGFuY2VvZiBOb2RlVHlwZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbm9kZSB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICBlbHNlIGlmICh0eXBlLnNjaGVtYSAhPSB0aGlzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJOb2RlIHR5cGUgZnJvbSBkaWZmZXJlbnQgc2NoZW1hIHVzZWQgKFwiICsgdHlwZS5uYW1lICsgXCIpXCIpO1xuICAgICAgICByZXR1cm4gdHlwZS5jcmVhdGVDaGVja2VkKGF0dHJzLCBjb250ZW50LCBtYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRleHQgbm9kZSBpbiB0aGUgc2NoZW1hLiBFbXB0eSB0ZXh0IG5vZGVzIGFyZSBub3RcbiAgICBhbGxvd2VkLlxuICAgICovXG4gICAgdGV4dCh0ZXh0LCBtYXJrcykge1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMubm9kZXMudGV4dDtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0eXBlLCB0eXBlLmRlZmF1bHRBdHRycywgdGV4dCwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIG1hcmsodHlwZSwgYXR0cnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0eXBlID0gdGhpcy5tYXJrc1t0eXBlXTtcbiAgICAgICAgcmV0dXJuIHR5cGUuY3JlYXRlKGF0dHJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBub2RlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFRoaXMgbWV0aG9kIGlzXG4gICAgYm91bmQuXG4gICAgKi9cbiAgICBub2RlRnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gTm9kZS5mcm9tSlNPTih0aGlzLCBqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBtYXJrIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFRoaXMgbWV0aG9kIGlzXG4gICAgYm91bmQuXG4gICAgKi9cbiAgICBtYXJrRnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gTWFyay5mcm9tSlNPTih0aGlzLCBqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBub2RlVHlwZShuYW1lKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMubm9kZXNbbmFtZV07XG4gICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVua25vd24gbm9kZSB0eXBlOiBcIiArIG5hbWUpO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2F0aGVyTWFya3Moc2NoZW1hLCBtYXJrcykge1xuICAgIGxldCBmb3VuZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5hbWUgPSBtYXJrc1tpXSwgbWFyayA9IHNjaGVtYS5tYXJrc1tuYW1lXSwgb2sgPSBtYXJrO1xuICAgICAgICBpZiAobWFyaykge1xuICAgICAgICAgICAgZm91bmQucHVzaChtYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gc2NoZW1hLm1hcmtzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmsgPSBzY2hlbWEubWFya3NbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJfXCIgfHwgKG1hcmsuc3BlYy5ncm91cCAmJiBtYXJrLnNwZWMuZ3JvdXAuc3BsaXQoXCIgXCIpLmluZGV4T2YobmFtZSkgPiAtMSkpXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnB1c2gob2sgPSBtYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9rKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5rbm93biBtYXJrIHR5cGU6ICdcIiArIG1hcmtzW2ldICsgXCInXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbi8qKlxuQSBET00gcGFyc2VyIHJlcHJlc2VudHMgYSBzdHJhdGVneSBmb3IgcGFyc2luZyBET00gY29udGVudCBpbnRvIGFcblByb3NlTWlycm9yIGRvY3VtZW50IGNvbmZvcm1pbmcgdG8gYSBnaXZlbiBzY2hlbWEuIEl0cyBiZWhhdmlvciBpc1xuZGVmaW5lZCBieSBhbiBhcnJheSBvZiBbcnVsZXNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5QYXJzZVJ1bGUpLlxuKi9cbmNsYXNzIERPTVBhcnNlciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGFyc2VyIHRoYXQgdGFyZ2V0cyB0aGUgZ2l2ZW4gc2NoZW1hLCB1c2luZyB0aGUgZ2l2ZW5cbiAgICBwYXJzaW5nIHJ1bGVzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHNjaGVtYSBpbnRvIHdoaWNoIHRoZSBwYXJzZXIgcGFyc2VzLlxuICAgICovXG4gICAgc2NoZW1hLCBcbiAgICAvKipcbiAgICBUaGUgc2V0IG9mIFtwYXJzZSBydWxlc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlBhcnNlUnVsZSkgdGhhdCB0aGUgcGFyc2VyXG4gICAgdXNlcywgaW4gb3JkZXIgb2YgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIHJ1bGVzKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWdzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdHlsZXMgPSBbXTtcbiAgICAgICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgICAgIGlmIChydWxlLnRhZylcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3MucHVzaChydWxlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUuc3R5bGUpXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZXMucHVzaChydWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE9ubHkgbm9ybWFsaXplIGxpc3QgZWxlbWVudHMgd2hlbiBsaXN0cyBpbiB0aGUgc2NoZW1hIGNhbid0IGRpcmVjdGx5IGNvbnRhaW4gdGhlbXNlbHZlc1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUxpc3RzID0gIXRoaXMudGFncy5zb21lKHIgPT4ge1xuICAgICAgICAgICAgaWYgKCEvXih1bHxvbClcXGIvLnRlc3Qoci50YWcpIHx8ICFyLm5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBzY2hlbWEubm9kZXNbci5ub2RlXTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnRlbnRNYXRjaC5tYXRjaFR5cGUobm9kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBQYXJzZSBhIGRvY3VtZW50IGZyb20gdGhlIGNvbnRlbnQgb2YgYSBET00gbm9kZS5cbiAgICAqL1xuICAgIHBhcnNlKGRvbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dCh0aGlzLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICAgIGNvbnRleHQuYWRkQWxsKGRvbSwgb3B0aW9ucy5mcm9tLCBvcHRpb25zLnRvKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZmluaXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFBhcnNlcyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUsIGxpa2VcbiAgICBbYHBhcnNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTVBhcnNlci5wYXJzZSksIGFuZCB0YWtlcyB0aGUgc2FtZSBzZXQgb2ZcbiAgICBvcHRpb25zLiBCdXQgdW5saWtlIHRoYXQgbWV0aG9kLCB3aGljaCBwcm9kdWNlcyBhIHdob2xlIG5vZGUsXG4gICAgdGhpcyBvbmUgcmV0dXJucyBhIHNsaWNlIHRoYXQgaXMgb3BlbiBhdCB0aGUgc2lkZXMsIG1lYW5pbmcgdGhhdFxuICAgIHRoZSBzY2hlbWEgY29uc3RyYWludHMgYXJlbid0IGFwcGxpZWQgdG8gdGhlIHN0YXJ0IG9mIG5vZGVzIHRvXG4gICAgdGhlIGxlZnQgb2YgdGhlIGlucHV0IGFuZCB0aGUgZW5kIG9mIG5vZGVzIGF0IHRoZSBlbmQuXG4gICAgKi9cbiAgICBwYXJzZVNsaWNlKGRvbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dCh0aGlzLCBvcHRpb25zLCB0cnVlKTtcbiAgICAgICAgY29udGV4dC5hZGRBbGwoZG9tLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICAgICAgICByZXR1cm4gU2xpY2UubWF4T3Blbihjb250ZXh0LmZpbmlzaCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXRjaFRhZyhkb20sIGNvbnRleHQsIGFmdGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhZnRlciA/IHRoaXMudGFncy5pbmRleE9mKGFmdGVyKSArIDEgOiAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMudGFnc1tpXTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKGRvbSwgcnVsZS50YWcpICYmXG4gICAgICAgICAgICAgICAgKHJ1bGUubmFtZXNwYWNlID09PSB1bmRlZmluZWQgfHwgZG9tLm5hbWVzcGFjZVVSSSA9PSBydWxlLm5hbWVzcGFjZSkgJiZcbiAgICAgICAgICAgICAgICAoIXJ1bGUuY29udGV4dCB8fCBjb250ZXh0Lm1hdGNoZXNDb250ZXh0KHJ1bGUuY29udGV4dCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuZ2V0QXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJ1bGUuZ2V0QXR0cnMoZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5hdHRycyA9IHJlc3VsdCB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF0Y2hTdHlsZShwcm9wLCB2YWx1ZSwgY29udGV4dCwgYWZ0ZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFmdGVyID8gdGhpcy5zdHlsZXMuaW5kZXhPZihhZnRlcikgKyAxIDogMDsgaSA8IHRoaXMuc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMuc3R5bGVzW2ldLCBzdHlsZSA9IHJ1bGUuc3R5bGU7XG4gICAgICAgICAgICBpZiAoc3R5bGUuaW5kZXhPZihwcm9wKSAhPSAwIHx8XG4gICAgICAgICAgICAgICAgcnVsZS5jb250ZXh0ICYmICFjb250ZXh0Lm1hdGNoZXNDb250ZXh0KHJ1bGUuY29udGV4dCkgfHxcbiAgICAgICAgICAgICAgICAvLyBUZXN0IHRoYXQgdGhlIHN0eWxlIHN0cmluZyBlaXRoZXIgcHJlY2lzZWx5IG1hdGNoZXMgdGhlIHByb3AsXG4gICAgICAgICAgICAgICAgLy8gb3IgaGFzIGFuICc9JyBzaWduIGFmdGVyIHRoZSBwcm9wLCBmb2xsb3dlZCBieSB0aGUgZ2l2ZW5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICBzdHlsZS5sZW5ndGggPiBwcm9wLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAoc3R5bGUuY2hhckNvZGVBdChwcm9wLmxlbmd0aCkgIT0gNjEgfHwgc3R5bGUuc2xpY2UocHJvcC5sZW5ndGggKyAxKSAhPSB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocnVsZS5nZXRBdHRycykge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBydWxlLmdldEF0dHJzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcnVsZS5hdHRycyA9IHJlc3VsdCB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBzY2hlbWFSdWxlcyhzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBpbnNlcnQocnVsZSkge1xuICAgICAgICAgICAgbGV0IHByaW9yaXR5ID0gcnVsZS5wcmlvcml0eSA9PSBudWxsID8gNTAgOiBydWxlLnByaW9yaXR5LCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSByZXN1bHRbaV0sIG5leHRQcmlvcml0eSA9IG5leHQucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogbmV4dC5wcmlvcml0eTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFByaW9yaXR5IDwgcHJpb3JpdHkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnNwbGljZShpLCAwLCBydWxlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHNjaGVtYS5tYXJrcykge1xuICAgICAgICAgICAgbGV0IHJ1bGVzID0gc2NoZW1hLm1hcmtzW25hbWVdLnNwZWMucGFyc2VET007XG4gICAgICAgICAgICBpZiAocnVsZXMpXG4gICAgICAgICAgICAgICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KHJ1bGUgPSBjb3B5KHJ1bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocnVsZS5tYXJrIHx8IHJ1bGUuaWdub3JlIHx8IHJ1bGUuY2xlYXJNYXJrKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUubWFyayA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBzY2hlbWEubm9kZXMpIHtcbiAgICAgICAgICAgIGxldCBydWxlcyA9IHNjaGVtYS5ub2Rlc1tuYW1lXS5zcGVjLnBhcnNlRE9NO1xuICAgICAgICAgICAgaWYgKHJ1bGVzKVxuICAgICAgICAgICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydChydWxlID0gY29weShydWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJ1bGUubm9kZSB8fCBydWxlLmlnbm9yZSB8fCBydWxlLm1hcmspKVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5ub2RlID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBET00gcGFyc2VyIHVzaW5nIHRoZSBwYXJzaW5nIHJ1bGVzIGxpc3RlZCBpbiBhXG4gICAgc2NoZW1hJ3MgW25vZGUgc3BlY3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5wYXJzZURPTSksIHJlb3JkZXJlZCBieVxuICAgIFtwcmlvcml0eV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlBhcnNlUnVsZS5wcmlvcml0eSkuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyIHx8XG4gICAgICAgICAgICAoc2NoZW1hLmNhY2hlZC5kb21QYXJzZXIgPSBuZXcgRE9NUGFyc2VyKHNjaGVtYSwgRE9NUGFyc2VyLnNjaGVtYVJ1bGVzKHNjaGVtYSkpKTtcbiAgICB9XG59XG5jb25zdCBibG9ja1RhZ3MgPSB7XG4gICAgYWRkcmVzczogdHJ1ZSwgYXJ0aWNsZTogdHJ1ZSwgYXNpZGU6IHRydWUsIGJsb2NrcXVvdGU6IHRydWUsIGNhbnZhczogdHJ1ZSxcbiAgICBkZDogdHJ1ZSwgZGl2OiB0cnVlLCBkbDogdHJ1ZSwgZmllbGRzZXQ6IHRydWUsIGZpZ2NhcHRpb246IHRydWUsIGZpZ3VyZTogdHJ1ZSxcbiAgICBmb290ZXI6IHRydWUsIGZvcm06IHRydWUsIGgxOiB0cnVlLCBoMjogdHJ1ZSwgaDM6IHRydWUsIGg0OiB0cnVlLCBoNTogdHJ1ZSxcbiAgICBoNjogdHJ1ZSwgaGVhZGVyOiB0cnVlLCBoZ3JvdXA6IHRydWUsIGhyOiB0cnVlLCBsaTogdHJ1ZSwgbm9zY3JpcHQ6IHRydWUsIG9sOiB0cnVlLFxuICAgIG91dHB1dDogdHJ1ZSwgcDogdHJ1ZSwgcHJlOiB0cnVlLCBzZWN0aW9uOiB0cnVlLCB0YWJsZTogdHJ1ZSwgdGZvb3Q6IHRydWUsIHVsOiB0cnVlXG59O1xuY29uc3QgaWdub3JlVGFncyA9IHtcbiAgICBoZWFkOiB0cnVlLCBub3NjcmlwdDogdHJ1ZSwgb2JqZWN0OiB0cnVlLCBzY3JpcHQ6IHRydWUsIHN0eWxlOiB0cnVlLCB0aXRsZTogdHJ1ZVxufTtcbmNvbnN0IGxpc3RUYWdzID0geyBvbDogdHJ1ZSwgdWw6IHRydWUgfTtcbi8vIFVzaW5nIGEgYml0ZmllbGQgZm9yIG5vZGUgY29udGV4dCBvcHRpb25zXG5jb25zdCBPUFRfUFJFU0VSVkVfV1MgPSAxLCBPUFRfUFJFU0VSVkVfV1NfRlVMTCA9IDIsIE9QVF9PUEVOX0xFRlQgPSA0O1xuZnVuY3Rpb24gd3NPcHRpb25zRm9yKHR5cGUsIHByZXNlcnZlV2hpdGVzcGFjZSwgYmFzZSkge1xuICAgIGlmIChwcmVzZXJ2ZVdoaXRlc3BhY2UgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIChwcmVzZXJ2ZVdoaXRlc3BhY2UgPyBPUFRfUFJFU0VSVkVfV1MgOiAwKSB8XG4gICAgICAgICAgICAocHJlc2VydmVXaGl0ZXNwYWNlID09PSBcImZ1bGxcIiA/IE9QVF9QUkVTRVJWRV9XU19GVUxMIDogMCk7XG4gICAgcmV0dXJuIHR5cGUgJiYgdHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIgPyBPUFRfUFJFU0VSVkVfV1MgfCBPUFRfUFJFU0VSVkVfV1NfRlVMTCA6IGJhc2UgJiB+T1BUX09QRU5fTEVGVDtcbn1cbmNsYXNzIE5vZGVDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBhdHRycywgXG4gICAgLy8gTWFya3MgYXBwbGllZCB0byB0aGlzIG5vZGUgaXRzZWxmXG4gICAgbWFya3MsIFxuICAgIC8vIE1hcmtzIHRoYXQgY2FuJ3QgYXBwbHkgaGVyZSwgYnV0IHdpbGwgYmUgdXNlZCBpbiBjaGlsZHJlbiBpZiBwb3NzaWJsZVxuICAgIHBlbmRpbmdNYXJrcywgc29saWQsIG1hdGNoLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLnBlbmRpbmdNYXJrcyA9IHBlbmRpbmdNYXJrcztcbiAgICAgICAgdGhpcy5zb2xpZCA9IHNvbGlkO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgLy8gTWFya3MgYXBwbGllZCB0byB0aGUgbm9kZSdzIGNoaWxkcmVuXG4gICAgICAgIHRoaXMuYWN0aXZlTWFya3MgPSBNYXJrLm5vbmU7XG4gICAgICAgIC8vIE5lc3RlZCBNYXJrcyB3aXRoIHNhbWUgdHlwZVxuICAgICAgICB0aGlzLnN0YXNoTWFya3MgPSBbXTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IG1hdGNoIHx8IChvcHRpb25zICYgT1BUX09QRU5fTEVGVCA/IG51bGwgOiB0eXBlLmNvbnRlbnRNYXRjaCk7XG4gICAgfVxuICAgIGZpbmRXcmFwcGluZyhub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXRjaCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgbGV0IGZpbGwgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoZmlsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLCB3cmFwO1xuICAgICAgICAgICAgICAgIGlmICh3cmFwID0gc3RhcnQuZmluZFdyYXBwaW5nKG5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaC5maW5kV3JhcHBpbmcobm9kZS50eXBlKTtcbiAgICB9XG4gICAgZmluaXNoKG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKCEodGhpcy5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTKSkgeyAvLyBTdHJpcCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0sIG07XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0LmlzVGV4dCAmJiAobSA9IC9bIFxcdFxcclxcblxcdTAwMGNdKyQvLmV4ZWMobGFzdC50ZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QudGV4dC5sZW5ndGggPT0gbVswXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5wb3AoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gPSB0ZXh0LndpdGhUZXh0KHRleHQudGV4dC5zbGljZSgwLCB0ZXh0LnRleHQubGVuZ3RoIC0gbVswXS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmZyb20odGhpcy5jb250ZW50KTtcbiAgICAgICAgaWYgKCFvcGVuRW5kICYmIHRoaXMubWF0Y2gpXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5hcHBlbmQodGhpcy5tYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPyB0aGlzLnR5cGUuY3JlYXRlKHRoaXMuYXR0cnMsIGNvbnRlbnQsIHRoaXMubWFya3MpIDogY29udGVudDtcbiAgICB9XG4gICAgcG9wRnJvbVN0YXNoTWFyayhtYXJrKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXNoTWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBpZiAobWFyay5lcSh0aGlzLnN0YXNoTWFya3NbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXNoTWFya3Muc3BsaWNlKGksIDEpWzBdO1xuICAgIH1cbiAgICBhcHBseVBlbmRpbmcobmV4dFR5cGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdNYXJrczsgaSA8IHBlbmRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrID0gcGVuZGluZ1tpXTtcbiAgICAgICAgICAgIGlmICgodGhpcy50eXBlID8gdGhpcy50eXBlLmFsbG93c01hcmtUeXBlKG1hcmsudHlwZSkgOiBtYXJrTWF5QXBwbHkobWFyay50eXBlLCBuZXh0VHlwZSkpICYmXG4gICAgICAgICAgICAgICAgIW1hcmsuaXNJblNldCh0aGlzLmFjdGl2ZU1hcmtzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlTWFya3MgPSBtYXJrLmFkZFRvU2V0KHRoaXMuYWN0aXZlTWFya3MpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KHRoaXMucGVuZGluZ01hcmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmxpbmVDb250ZXh0KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuaW5saW5lQ29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50WzBdLmlzSW5saW5lO1xuICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlICYmICFibG9ja1RhZ3MuaGFzT3duUHJvcGVydHkobm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbn1cbmNsYXNzIFBhcnNlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIHBhcnNlciB3ZSBhcmUgdXNpbmcuXG4gICAgcGFyc2VyLCBcbiAgICAvLyBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhpcyBwYXJzZS5cbiAgICBvcHRpb25zLCBpc09wZW4pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gaXNPcGVuO1xuICAgICAgICB0aGlzLm9wZW4gPSAwO1xuICAgICAgICBsZXQgdG9wTm9kZSA9IG9wdGlvbnMudG9wTm9kZSwgdG9wQ29udGV4dDtcbiAgICAgICAgbGV0IHRvcE9wdGlvbnMgPSB3c09wdGlvbnNGb3IobnVsbCwgb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsIDApIHwgKGlzT3BlbiA/IE9QVF9PUEVOX0xFRlQgOiAwKTtcbiAgICAgICAgaWYgKHRvcE5vZGUpXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KHRvcE5vZGUudHlwZSwgdG9wTm9kZS5hdHRycywgTWFyay5ub25lLCBNYXJrLm5vbmUsIHRydWUsIG9wdGlvbnMudG9wTWF0Y2ggfHwgdG9wTm9kZS50eXBlLmNvbnRlbnRNYXRjaCwgdG9wT3B0aW9ucyk7XG4gICAgICAgIGVsc2UgaWYgKGlzT3BlbilcbiAgICAgICAgICAgIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQobnVsbCwgbnVsbCwgTWFyay5ub25lLCBNYXJrLm5vbmUsIHRydWUsIG51bGwsIHRvcE9wdGlvbnMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KHBhcnNlci5zY2hlbWEudG9wTm9kZVR5cGUsIG51bGwsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFt0b3BDb250ZXh0XTtcbiAgICAgICAgdGhpcy5maW5kID0gb3B0aW9ucy5maW5kUG9zaXRpb25zO1xuICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbdGhpcy5vcGVuXTtcbiAgICB9XG4gICAgLy8gQWRkIGEgRE9NIG5vZGUgdG8gdGhlIGNvbnRlbnQuIFRleHQgaXMgaW5zZXJ0ZWQgYXMgdGV4dCBub2RlLFxuICAgIC8vIG90aGVyd2lzZSwgdGhlIG5vZGUgaXMgcGFzc2VkIHRvIGBhZGRFbGVtZW50YCBvciwgaWYgaXQgaGFzIGFcbiAgICAvLyBgc3R5bGVgIGF0dHJpYnV0ZSwgYGFkZEVsZW1lbnRXaXRoU3R5bGVzYC5cbiAgICBhZGRET00oZG9tKSB7XG4gICAgICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHRoaXMuYWRkVGV4dE5vZGUoZG9tKTtcbiAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZG9tKTtcbiAgICB9XG4gICAgd2l0aFN0eWxlUnVsZXMoZG9tLCBmKSB7XG4gICAgICAgIGxldCBzdHlsZSA9IGRvbS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgICAgICAgaWYgKCFzdHlsZSlcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIGxldCBtYXJrcyA9IHRoaXMucmVhZFN0eWxlcyhwYXJzZVN0eWxlcyhzdHlsZSkpO1xuICAgICAgICBpZiAoIW1hcmtzKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBBIHN0eWxlIHdpdGggaWdub3JlOiB0cnVlXG4gICAgICAgIGxldCBbYWRkTWFya3MsIHJlbW92ZU1hcmtzXSA9IG1hcmtzLCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUGVuZGluZ01hcmsocmVtb3ZlTWFya3NbaV0sIHRvcCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkTWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdNYXJrKGFkZE1hcmtzW2ldKTtcbiAgICAgICAgZigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZE1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVQZW5kaW5nTWFyayhhZGRNYXJrc1tpXSwgdG9wKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuYWRkUGVuZGluZ01hcmsocmVtb3ZlTWFya3NbaV0pO1xuICAgIH1cbiAgICBhZGRUZXh0Tm9kZShkb20pIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZG9tLm5vZGVWYWx1ZTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgICBpZiAodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1NfRlVMTCB8fFxuICAgICAgICAgICAgdG9wLmlubGluZUNvbnRleHQoZG9tKSB8fFxuICAgICAgICAgICAgL1teIFxcdFxcclxcblxcdTAwMGNdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCEodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bIFxcdFxcclxcblxcdTAwMGNdKy9nLCBcIiBcIik7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBzdGFydHMgd2l0aCB3aGl0ZXNwYWNlLCBhbmQgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUgaXQsIG9yXG4gICAgICAgICAgICAgICAgLy8gYSBoYXJkIGJyZWFrLCBvciBhIHRleHQgbm9kZSB0aGF0IGVuZHMgd2l0aCB3aGl0ZXNwYWNlLCBzdHJpcCB0aGVcbiAgICAgICAgICAgICAgICAvLyBsZWFkaW5nIHNwYWNlLlxuICAgICAgICAgICAgICAgIGlmICgvXlsgXFx0XFxyXFxuXFx1MDAwY10vLnRlc3QodmFsdWUpICYmIHRoaXMub3BlbiA9PSB0aGlzLm5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVCZWZvcmUgPSB0b3AuY29udGVudFt0b3AuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRvbU5vZGVCZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVCZWZvcmUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChkb21Ob2RlQmVmb3JlICYmIGRvbU5vZGVCZWZvcmUubm9kZU5hbWUgPT0gJ0JSJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChub2RlQmVmb3JlLmlzVGV4dCAmJiAvWyBcXHRcXHJcXG5cXHUwMDBjXSQvLnRlc3Qobm9kZUJlZm9yZS50ZXh0KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1NfRlVMTCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccj9cXG58XFxyL2csIFwiIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydE5vZGUodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQodmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMuZmluZEluVGV4dChkb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gdGFnIGFuZCB1c2UgdGhhdCB0byBwYXJzZS4gSWZcbiAgICAvLyBub25lIGlzIGZvdW5kLCB0aGUgZWxlbWVudCdzIGNvbnRlbnQgbm9kZXMgYXJlIGFkZGVkIGRpcmVjdGx5LlxuICAgIGFkZEVsZW1lbnQoZG9tLCBtYXRjaEFmdGVyKSB7XG4gICAgICAgIGxldCBuYW1lID0gZG9tLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHJ1bGVJRDtcbiAgICAgICAgaWYgKGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHRoaXMucGFyc2VyLm5vcm1hbGl6ZUxpc3RzKVxuICAgICAgICAgICAgbm9ybWFsaXplTGlzdChkb20pO1xuICAgICAgICBsZXQgcnVsZSA9ICh0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlICYmIHRoaXMub3B0aW9ucy5ydWxlRnJvbU5vZGUoZG9tKSkgfHxcbiAgICAgICAgICAgIChydWxlSUQgPSB0aGlzLnBhcnNlci5tYXRjaFRhZyhkb20sIHRoaXMsIG1hdGNoQWZ0ZXIpKTtcbiAgICAgICAgaWYgKHJ1bGUgPyBydWxlLmlnbm9yZSA6IGlnbm9yZVRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVGYWxsYmFjayhkb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFydWxlIHx8IHJ1bGUuc2tpcCB8fCBydWxlLmNsb3NlUGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocnVsZSAmJiBydWxlLmNsb3NlUGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9IE1hdGgubWF4KDAsIHRoaXMub3BlbiAtIDEpO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVsZSAmJiBydWxlLnNraXAubm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgZG9tID0gcnVsZS5za2lwO1xuICAgICAgICAgICAgbGV0IHN5bmMsIHRvcCA9IHRoaXMudG9wLCBvbGROZWVkc0Jsb2NrID0gdGhpcy5uZWVkc0Jsb2NrO1xuICAgICAgICAgICAgaWYgKGJsb2NrVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmICh0b3AuY29udGVudC5sZW5ndGggJiYgdG9wLmNvbnRlbnRbMF0uaXNJbmxpbmUgJiYgdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3Blbi0tO1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0b3AudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFkb20uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bGUgJiYgcnVsZS5za2lwKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQWxsKGRvbSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy53aXRoU3R5bGVSdWxlcyhkb20sICgpID0+IHRoaXMuYWRkQWxsKGRvbSkpO1xuICAgICAgICAgICAgaWYgKHN5bmMpXG4gICAgICAgICAgICAgICAgdGhpcy5zeW5jKHRvcCk7XG4gICAgICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSBvbGROZWVkc0Jsb2NrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53aXRoU3R5bGVSdWxlcyhkb20sICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRCeVJ1bGUoZG9tLCBydWxlLCBydWxlLmNvbnN1bWluZyA9PT0gZmFsc2UgPyBydWxlSUQgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FsbGVkIGZvciBsZWFmIERPTSBub2RlcyB0aGF0IHdvdWxkIG90aGVyd2lzZSBiZSBpZ25vcmVkXG4gICAgbGVhZkZhbGxiYWNrKGRvbSkge1xuICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiB0aGlzLnRvcC50eXBlICYmIHRoaXMudG9wLnR5cGUuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgIHRoaXMuYWRkVGV4dE5vZGUoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cIikpO1xuICAgIH1cbiAgICAvLyBDYWxsZWQgZm9yIGlnbm9yZWQgbm9kZXNcbiAgICBpZ25vcmVGYWxsYmFjayhkb20pIHtcbiAgICAgICAgLy8gSWdub3JlZCBCUiBub2RlcyBzaG91bGQgYXQgbGVhc3QgY3JlYXRlIGFuIGlubGluZSBjb250ZXh0XG4gICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmICghdGhpcy50b3AudHlwZSB8fCAhdGhpcy50b3AudHlwZS5pbmxpbmVDb250ZW50KSlcbiAgICAgICAgICAgIHRoaXMuZmluZFBsYWNlKHRoaXMucGFyc2VyLnNjaGVtYS50ZXh0KFwiLVwiKSk7XG4gICAgfVxuICAgIC8vIFJ1biBhbnkgc3R5bGUgcGFyc2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZSdzIHN0eWxlcy4gRWl0aGVyXG4gICAgLy8gcmV0dXJuIGFuIGFycmF5IG9mIG1hcmtzLCBvciBudWxsIHRvIGluZGljYXRlIHNvbWUgb2YgdGhlIHN0eWxlc1xuICAgIC8vIGhhZCBhIHJ1bGUgd2l0aCBgaWdub3JlYCBzZXQuXG4gICAgcmVhZFN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgbGV0IGFkZCA9IE1hcmsubm9uZSwgcmVtb3ZlID0gTWFyay5ub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgZm9yIChsZXQgYWZ0ZXIgPSB1bmRlZmluZWQ7Oykge1xuICAgICAgICAgICAgICAgIGxldCBydWxlID0gdGhpcy5wYXJzZXIubWF0Y2hTdHlsZShzdHlsZXNbaV0sIHN0eWxlc1tpICsgMV0sIHRoaXMsIGFmdGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmlnbm9yZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuY2xlYXJNYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9wLnBlbmRpbmdNYXJrcy5jb25jYXQodGhpcy50b3AuYWN0aXZlTWFya3MpLmZvckVhY2gobSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5jbGVhck1hcmsobSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlID0gbS5hZGRUb1NldChyZW1vdmUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZCA9IHRoaXMucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdLmNyZWF0ZShydWxlLmF0dHJzKS5hZGRUb1NldChhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVsZS5jb25zdW1pbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBhZnRlciA9IHJ1bGU7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2FkZCwgcmVtb3ZlXTtcbiAgICB9XG4gICAgLy8gTG9vayB1cCBhIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBub2RlLiBJZiBub25lIGFyZSBmb3VuZCwgcmV0dXJuXG4gICAgLy8gZmFsc2UuIE90aGVyd2lzZSwgYXBwbHkgaXQsIHVzZSBpdHMgcmV0dXJuIHZhbHVlIHRvIGRyaXZlIHRoZSB3YXlcbiAgICAvLyB0aGUgbm9kZSdzIGNvbnRlbnQgaXMgd3JhcHBlZCwgYW5kIHJldHVybiB0cnVlLlxuICAgIGFkZEVsZW1lbnRCeVJ1bGUoZG9tLCBydWxlLCBjb250aW51ZUFmdGVyKSB7XG4gICAgICAgIGxldCBzeW5jLCBub2RlVHlwZSwgbWFyaztcbiAgICAgICAgaWYgKHJ1bGUubm9kZSkge1xuICAgICAgICAgICAgbm9kZVR5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXNbcnVsZS5ub2RlXTtcbiAgICAgICAgICAgIGlmICghbm9kZVR5cGUuaXNMZWFmKSB7XG4gICAgICAgICAgICAgICAgc3luYyA9IHRoaXMuZW50ZXIobm9kZVR5cGUsIHJ1bGUuYXR0cnMgfHwgbnVsbCwgcnVsZS5wcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuaW5zZXJ0Tm9kZShub2RlVHlwZS5jcmVhdGUocnVsZS5hdHRycykpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFmRmFsbGJhY2soZG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXJrVHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdO1xuICAgICAgICAgICAgbWFyayA9IG1hcmtUeXBlLmNyZWF0ZShydWxlLmF0dHJzKTtcbiAgICAgICAgICAgIHRoaXMuYWRkUGVuZGluZ01hcmsobWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0SW4gPSB0aGlzLnRvcDtcbiAgICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlLmlzTGVhZikge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGludWVBZnRlcikge1xuICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50KGRvbSwgY29udGludWVBZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVsZS5nZXRDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgICAgIHJ1bGUuZ2V0Q29udGVudChkb20sIHRoaXMucGFyc2VyLnNjaGVtYSkuZm9yRWFjaChub2RlID0+IHRoaXMuaW5zZXJ0Tm9kZShub2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGVudERPTSA9IGRvbTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZS5jb250ZW50RWxlbWVudCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBkb20ucXVlcnlTZWxlY3RvcihydWxlLmNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBydWxlLmNvbnRlbnRFbGVtZW50ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gcnVsZS5jb250ZW50RWxlbWVudChkb20pO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5jb250ZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gcnVsZS5jb250ZW50RWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluZEFyb3VuZChkb20sIGNvbnRlbnRET00sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5hZGRBbGwoY29udGVudERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN5bmMgJiYgdGhpcy5zeW5jKHN0YXJ0SW4pKVxuICAgICAgICAgICAgdGhpcy5vcGVuLS07XG4gICAgICAgIGlmIChtYXJrKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVQZW5kaW5nTWFyayhtYXJrLCBzdGFydEluKTtcbiAgICB9XG4gICAgLy8gQWRkIGFsbCBjaGlsZCBub2RlcyBiZXR3ZWVuIGBzdGFydEluZGV4YCBhbmQgYGVuZEluZGV4YCAob3IgdGhlXG4gICAgLy8gd2hvbGUgbm9kZSwgaWYgbm90IGdpdmVuKS4gSWYgYHN5bmNgIGlzIHBhc3NlZCwgdXNlIGl0IHRvXG4gICAgLy8gc3luY2hyb25pemUgYWZ0ZXIgZXZlcnkgYmxvY2sgZWxlbWVudC5cbiAgICBhZGRBbGwocGFyZW50LCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgICBsZXQgaW5kZXggPSBzdGFydEluZGV4IHx8IDA7XG4gICAgICAgIGZvciAobGV0IGRvbSA9IHN0YXJ0SW5kZXggPyBwYXJlbnQuY2hpbGROb2Rlc1tzdGFydEluZGV4XSA6IHBhcmVudC5maXJzdENoaWxkLCBlbmQgPSBlbmRJbmRleCA9PSBudWxsID8gbnVsbCA6IHBhcmVudC5jaGlsZE5vZGVzW2VuZEluZGV4XTsgZG9tICE9IGVuZDsgZG9tID0gZG9tLm5leHRTaWJsaW5nLCArK2luZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRBdFBvaW50KHBhcmVudCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5hZGRET00oZG9tKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmRBdFBvaW50KHBhcmVudCwgaW5kZXgpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIHdheSB0byBmaXQgdGhlIGdpdmVuIG5vZGUgdHlwZSBpbnRvIHRoZSBjdXJyZW50XG4gICAgLy8gY29udGV4dC4gTWF5IGFkZCBpbnRlcm1lZGlhdGUgd3JhcHBlcnMgYW5kL29yIGxlYXZlIG5vbi1zb2xpZFxuICAgIC8vIG5vZGVzIHRoYXQgd2UncmUgaW4uXG4gICAgZmluZFBsYWNlKG5vZGUpIHtcbiAgICAgICAgbGV0IHJvdXRlLCBzeW5jO1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IHRoaXMub3BlbjsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICAgICAgbGV0IGN4ID0gdGhpcy5ub2Rlc1tkZXB0aF07XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBjeC5maW5kV3JhcHBpbmcobm9kZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgJiYgKCFyb3V0ZSB8fCByb3V0ZS5sZW5ndGggPiBmb3VuZC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgcm91dGUgPSBmb3VuZDtcbiAgICAgICAgICAgICAgICBzeW5jID0gY3g7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN4LnNvbGlkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcm91dGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3luYyhzeW5jKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuZW50ZXJJbm5lcihyb3V0ZVtpXSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGluc2VydCB0aGUgZ2l2ZW4gbm9kZSwgYWRqdXN0aW5nIHRoZSBjb250ZXh0IHdoZW4gbmVlZGVkLlxuICAgIGluc2VydE5vZGUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5pc0lubGluZSAmJiB0aGlzLm5lZWRzQmxvY2sgJiYgIXRoaXMudG9wLnR5cGUpIHtcbiAgICAgICAgICAgIGxldCBibG9jayA9IHRoaXMudGV4dGJsb2NrRnJvbUNvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChibG9jaylcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVySW5uZXIoYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbmRQbGFjZShub2RlKSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50b3A7XG4gICAgICAgICAgICB0b3AuYXBwbHlQZW5kaW5nKG5vZGUudHlwZSk7XG4gICAgICAgICAgICBpZiAodG9wLm1hdGNoKVxuICAgICAgICAgICAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaC5tYXRjaFR5cGUobm9kZS50eXBlKTtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IHRvcC5hY3RpdmVNYXJrcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5tYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoIXRvcC50eXBlIHx8IHRvcC50eXBlLmFsbG93c01hcmtUeXBlKG5vZGUubWFya3NbaV0udHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIG1hcmtzID0gbm9kZS5tYXJrc1tpXS5hZGRUb1NldChtYXJrcyk7XG4gICAgICAgICAgICB0b3AuY29udGVudC5wdXNoKG5vZGUubWFyayhtYXJrcykpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gc3RhcnQgYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlLCBhZGp1c3RpbmcgdGhlIGNvbnRleHQgd2hlblxuICAgIC8vIG5lY2Vzc2FyeS5cbiAgICBlbnRlcih0eXBlLCBhdHRycywgcHJlc2VydmVXUykge1xuICAgICAgICBsZXQgb2sgPSB0aGlzLmZpbmRQbGFjZSh0eXBlLmNyZWF0ZShhdHRycykpO1xuICAgICAgICBpZiAob2spXG4gICAgICAgICAgICB0aGlzLmVudGVySW5uZXIodHlwZSwgYXR0cnMsIHRydWUsIHByZXNlcnZlV1MpO1xuICAgICAgICByZXR1cm4gb2s7XG4gICAgfVxuICAgIC8vIE9wZW4gYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlXG4gICAgZW50ZXJJbm5lcih0eXBlLCBhdHRycyA9IG51bGwsIHNvbGlkID0gZmFsc2UsIHByZXNlcnZlV1MpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgdG9wLmFwcGx5UGVuZGluZyh0eXBlKTtcbiAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoICYmIHRvcC5tYXRjaC5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIGxldCBvcHRpb25zID0gd3NPcHRpb25zRm9yKHR5cGUsIHByZXNlcnZlV1MsIHRvcC5vcHRpb25zKTtcbiAgICAgICAgaWYgKCh0b3Aub3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQpICYmIHRvcC5jb250ZW50Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgb3B0aW9ucyB8PSBPUFRfT1BFTl9MRUZUO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IE5vZGVDb250ZXh0KHR5cGUsIGF0dHJzLCB0b3AuYWN0aXZlTWFya3MsIHRvcC5wZW5kaW5nTWFya3MsIHNvbGlkLCBudWxsLCBvcHRpb25zKSk7XG4gICAgICAgIHRoaXMub3BlbisrO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgYWxsIG5vZGVzIGFib3ZlIHRoaXMub3BlbiBhcmUgZmluaXNoZWQgYW5kIGFkZGVkIHRvXG4gICAgLy8gdGhlaXIgcGFyZW50c1xuICAgIGNsb3NlRXh0cmEob3BlbkVuZCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaSA+IHRoaXMub3Blbikge1xuICAgICAgICAgICAgZm9yICg7IGkgPiB0aGlzLm9wZW47IGktLSlcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzW2kgLSAxXS5jb250ZW50LnB1c2godGhpcy5ub2Rlc1tpXS5maW5pc2gob3BlbkVuZCkpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5sZW5ndGggPSB0aGlzLm9wZW4gKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy5vcGVuID0gMDtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKHRoaXMuaXNPcGVuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF0uZmluaXNoKHRoaXMuaXNPcGVuIHx8IHRoaXMub3B0aW9ucy50b3BPcGVuKTtcbiAgICB9XG4gICAgc3luYyh0bykge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2ldID09IHRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFBvcygpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLm5vZGVzW2ldLmNvbnRlbnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gY29udGVudC5sZW5ndGggLSAxOyBqID49IDA7IGotLSlcbiAgICAgICAgICAgICAgICBwb3MgKz0gY29udGVudFtqXS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIGZpbmRBdFBvaW50KHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ubm9kZSA9PSBwYXJlbnQgJiYgdGhpcy5maW5kW2ldLm9mZnNldCA9PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRJbnNpZGUocGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ucG9zID09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09IDEgJiYgcGFyZW50LmNvbnRhaW5zKHRoaXMuZmluZFtpXS5ub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZmluZEFyb3VuZChwYXJlbnQsIGNvbnRlbnQsIGJlZm9yZSkge1xuICAgICAgICBpZiAocGFyZW50ICE9IGNvbnRlbnQgJiYgdGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLnBvcyA9PSBudWxsICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxICYmIHBhcmVudC5jb250YWlucyh0aGlzLmZpbmRbaV0ubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IGNvbnRlbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcy5maW5kW2ldLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zICYgKGJlZm9yZSA/IDIgOiA0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kSW5UZXh0KHRleHROb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ubm9kZSA9PSB0ZXh0Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcyAtICh0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoIC0gdGhpcy5maW5kW2ldLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIC8vIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gY29udGV4dCBzdHJpbmcgbWF0Y2hlcyB0aGlzIGNvbnRleHQuXG4gICAgbWF0Y2hlc0NvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dC5pbmRleE9mKFwifFwiKSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuc3BsaXQoL1xccypcXHxcXHMqLykuc29tZSh0aGlzLm1hdGNoZXNDb250ZXh0LCB0aGlzKTtcbiAgICAgICAgbGV0IHBhcnRzID0gY29udGV4dC5zcGxpdChcIi9cIik7XG4gICAgICAgIGxldCBvcHRpb24gPSB0aGlzLm9wdGlvbnMuY29udGV4dDtcbiAgICAgICAgbGV0IHVzZVJvb3QgPSAhdGhpcy5pc09wZW4gJiYgKCFvcHRpb24gfHwgb3B0aW9uLnBhcmVudC50eXBlID09IHRoaXMubm9kZXNbMF0udHlwZSk7XG4gICAgICAgIGxldCBtaW5EZXB0aCA9IC0ob3B0aW9uID8gb3B0aW9uLmRlcHRoICsgMSA6IDApICsgKHVzZVJvb3QgPyAwIDogMSk7XG4gICAgICAgIGxldCBtYXRjaCA9IChpLCBkZXB0aCkgPT4ge1xuICAgICAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGFydCA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IHBhcnRzLmxlbmd0aCAtIDEgfHwgaSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBkZXB0aCA+PSBtaW5EZXB0aDsgZGVwdGgtLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaChpIC0gMSwgZGVwdGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGRlcHRoID4gMCB8fCAoZGVwdGggPT0gMCAmJiB1c2VSb290KSA/IHRoaXMubm9kZXNbZGVwdGhdLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0aW9uICYmIGRlcHRoID49IG1pbkRlcHRoID8gb3B0aW9uLm5vZGUoZGVwdGggLSBtaW5EZXB0aCkudHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IChuZXh0Lm5hbWUgIT0gcGFydCAmJiBuZXh0Lmdyb3Vwcy5pbmRleE9mKHBhcnQpID09IC0xKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1hdGNoKHBhcnRzLmxlbmd0aCAtIDEsIHRoaXMub3Blbik7XG4gICAgfVxuICAgIHRleHRibG9ja0Zyb21Db250ZXh0KCkge1xuICAgICAgICBsZXQgJGNvbnRleHQgPSB0aGlzLm9wdGlvbnMuY29udGV4dDtcbiAgICAgICAgaWYgKCRjb250ZXh0KVxuICAgICAgICAgICAgZm9yIChsZXQgZCA9ICRjb250ZXh0LmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgICAgIGxldCBkZWZsdCA9ICRjb250ZXh0Lm5vZGUoZCkuY29udGVudE1hdGNoQXQoJGNvbnRleHQuaW5kZXhBZnRlcihkKSkuZGVmYXVsdFR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmx0ICYmIGRlZmx0LmlzVGV4dGJsb2NrICYmIGRlZmx0LmRlZmF1bHRBdHRycylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmx0O1xuICAgICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlcykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiB0eXBlLmRlZmF1bHRBdHRycylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRQZW5kaW5nTWFyayhtYXJrKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IGZpbmRTYW1lTWFya0luU2V0KG1hcmssIHRoaXMudG9wLnBlbmRpbmdNYXJrcyk7XG4gICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgIHRoaXMudG9wLnN0YXNoTWFya3MucHVzaChmb3VuZCk7XG4gICAgICAgIHRoaXMudG9wLnBlbmRpbmdNYXJrcyA9IG1hcmsuYWRkVG9TZXQodGhpcy50b3AucGVuZGluZ01hcmtzKTtcbiAgICB9XG4gICAgcmVtb3ZlUGVuZGluZ01hcmsobWFyaywgdXB0bykge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IHRoaXMub3BlbjsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICAgICAgbGV0IGxldmVsID0gdGhpcy5ub2Rlc1tkZXB0aF07XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBsZXZlbC5wZW5kaW5nTWFya3MubGFzdEluZGV4T2YobWFyayk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgICAgIGxldmVsLnBlbmRpbmdNYXJrcyA9IG1hcmsucmVtb3ZlRnJvbVNldChsZXZlbC5wZW5kaW5nTWFya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwuYWN0aXZlTWFya3MgPSBtYXJrLnJlbW92ZUZyb21TZXQobGV2ZWwuYWN0aXZlTWFya3MpO1xuICAgICAgICAgICAgICAgIGxldCBzdGFzaE1hcmsgPSBsZXZlbC5wb3BGcm9tU3Rhc2hNYXJrKG1hcmspO1xuICAgICAgICAgICAgICAgIGlmIChzdGFzaE1hcmsgJiYgbGV2ZWwudHlwZSAmJiBsZXZlbC50eXBlLmFsbG93c01hcmtUeXBlKHN0YXNoTWFyay50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwuYWN0aXZlTWFya3MgPSBzdGFzaE1hcmsuYWRkVG9TZXQobGV2ZWwuYWN0aXZlTWFya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxldmVsID09IHVwdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgZGlyZWN0bHkgbmVzdGVkIGxpc3Qgbm9kZXMgcHJvZHVjZWQgYnkgc29tZVxuLy8gdG9vbHMgYW5kIGFsbG93ZWQgYnkgYnJvd3NlcnMgdG8gbWVhbiB0aGF0IHRoZSBuZXN0ZWQgbGlzdCBpc1xuLy8gYWN0dWFsbHkgcGFydCBvZiB0aGUgbGlzdCBpdGVtIGFib3ZlIGl0LlxuZnVuY3Rpb24gbm9ybWFsaXplTGlzdChkb20pIHtcbiAgICBmb3IgKGxldCBjaGlsZCA9IGRvbS5maXJzdENoaWxkLCBwcmV2SXRlbSA9IG51bGw7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGxldCBuYW1lID0gY2hpbGQubm9kZVR5cGUgPT0gMSA/IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgICAgICBpZiAobmFtZSAmJiBsaXN0VGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBwcmV2SXRlbSkge1xuICAgICAgICAgICAgcHJldkl0ZW0uYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgY2hpbGQgPSBwcmV2SXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09IFwibGlcIikge1xuICAgICAgICAgICAgcHJldkl0ZW0gPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBwcmV2SXRlbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBBcHBseSBhIENTUyBzZWxlY3Rvci5cbmZ1bmN0aW9uIG1hdGNoZXMoZG9tLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiAoZG9tLm1hdGNoZXMgfHwgZG9tLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGRvbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZG9tLm1vek1hdGNoZXNTZWxlY3RvcikuY2FsbChkb20sIHNlbGVjdG9yKTtcbn1cbi8vIFRva2VuaXplIGEgc3R5bGUgYXR0cmlidXRlIGludG8gcHJvcGVydHkvdmFsdWUgcGFpcnMuXG5mdW5jdGlvbiBwYXJzZVN0eWxlcyhzdHlsZSkge1xuICAgIGxldCByZSA9IC9cXHMqKFtcXHctXSspXFxzKjpcXHMqKFteO10rKS9nLCBtLCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAobSA9IHJlLmV4ZWMoc3R5bGUpKVxuICAgICAgICByZXN1bHQucHVzaChtWzFdLCBtWzJdLnRyaW0oKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgbGV0IGNvcHkgPSB7fTtcbiAgICBmb3IgKGxldCBwcm9wIGluIG9iailcbiAgICAgICAgY29weVtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICByZXR1cm4gY29weTtcbn1cbi8vIFVzZWQgd2hlbiBmaW5kaW5nIGEgbWFyayBhdCB0aGUgdG9wIGxldmVsIG9mIGEgZnJhZ21lbnQgcGFyc2UuXG4vLyBDaGVja3Mgd2hldGhlciBpdCB3b3VsZCBiZSByZWFzb25hYmxlIHRvIGFwcGx5IGEgZ2l2ZW4gbWFyayB0eXBlIHRvXG4vLyBhIGdpdmVuIG5vZGUsIGJ5IGxvb2tpbmcgYXQgdGhlIHdheSB0aGUgbWFyayBvY2N1cnMgaW4gdGhlIHNjaGVtYS5cbmZ1bmN0aW9uIG1hcmtNYXlBcHBseShtYXJrVHlwZSwgbm9kZVR5cGUpIHtcbiAgICBsZXQgbm9kZXMgPSBub2RlVHlwZS5zY2hlbWEubm9kZXM7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBub2Rlcykge1xuICAgICAgICBsZXQgcGFyZW50ID0gbm9kZXNbbmFtZV07XG4gICAgICAgIGlmICghcGFyZW50LmFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgc2VlbiA9IFtdLCBzY2FuID0gKG1hdGNoKSA9PiB7XG4gICAgICAgICAgICBzZWVuLnB1c2gobWF0Y2gpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IG1hdGNoLmVkZ2UoaSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gbm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YobmV4dCkgPCAwICYmIHNjYW4obmV4dCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2NhbihwYXJlbnQuY29udGVudE1hdGNoKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRTYW1lTWFya0luU2V0KG1hcmssIHNldCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChtYXJrLmVxKHNldFtpXSkpXG4gICAgICAgICAgICByZXR1cm4gc2V0W2ldO1xuICAgIH1cbn1cblxuLyoqXG5BIERPTSBzZXJpYWxpemVyIGtub3dzIGhvdyB0byBjb252ZXJ0IFByb3NlTWlycm9yIG5vZGVzIGFuZFxubWFya3Mgb2YgdmFyaW91cyB0eXBlcyB0byBET00gbm9kZXMuXG4qL1xuY2xhc3MgRE9NU2VyaWFsaXplciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VyaWFsaXplci4gYG5vZGVzYCBzaG91bGQgbWFwIG5vZGUgbmFtZXMgdG8gZnVuY3Rpb25zXG4gICAgdGhhdCB0YWtlIGEgbm9kZSBhbmQgcmV0dXJuIGEgZGVzY3JpcHRpb24gb2YgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICBET00uIGBtYXJrc2AgZG9lcyB0aGUgc2FtZSBmb3IgbWFyayBuYW1lcywgYnV0IGFsc28gZ2V0cyBhblxuICAgIGFyZ3VtZW50IHRoYXQgdGVsbHMgaXQgd2hldGhlciB0aGUgbWFyaydzIGNvbnRlbnQgaXMgYmxvY2sgb3JcbiAgICBpbmxpbmUgY29udGVudCAoZm9yIHR5cGljYWwgdXNlLCBpdCdsbCBhbHdheXMgYmUgaW5saW5lKS4gQSBtYXJrXG4gICAgc2VyaWFsaXplciBtYXkgYmUgYG51bGxgIHRvIGluZGljYXRlIHRoYXQgbWFya3Mgb2YgdGhhdCB0eXBlXG4gICAgc2hvdWxkIG5vdCBiZSBzZXJpYWxpemVkLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5vZGUgc2VyaWFsaXphdGlvbiBmdW5jdGlvbnMuXG4gICAgKi9cbiAgICBub2RlcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgc2VyaWFsaXphdGlvbiBmdW5jdGlvbnMuXG4gICAgKi9cbiAgICBtYXJrcykge1xuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoZSBjb250ZW50IG9mIHRoaXMgZnJhZ21lbnQgdG8gYSBET00gZnJhZ21lbnQuIFdoZW5cbiAgICBub3QgaW4gdGhlIGJyb3dzZXIsIHRoZSBgZG9jdW1lbnRgIG9wdGlvbiwgY29udGFpbmluZyBhIERPTVxuICAgIGRvY3VtZW50LCBzaG91bGQgYmUgcGFzc2VkIHNvIHRoYXQgdGhlIHNlcmlhbGl6ZXIgY2FuIGNyZWF0ZVxuICAgIG5vZGVzLlxuICAgICovXG4gICAgc2VyaWFsaXplRnJhZ21lbnQoZnJhZ21lbnQsIG9wdGlvbnMgPSB7fSwgdGFyZ2V0KSB7XG4gICAgICAgIGlmICghdGFyZ2V0KVxuICAgICAgICAgICAgdGFyZ2V0ID0gZG9jKG9wdGlvbnMpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgbGV0IHRvcCA9IHRhcmdldCwgYWN0aXZlID0gW107XG4gICAgICAgIGZyYWdtZW50LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCB8fCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBrZWVwID0gMCwgcmVuZGVyZWQgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChrZWVwIDwgYWN0aXZlLmxlbmd0aCAmJiByZW5kZXJlZCA8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5tYXJrc1tyZW5kZXJlZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXJrc1tuZXh0LnR5cGUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQuZXEoYWN0aXZlW2tlZXBdWzBdKSB8fCBuZXh0LnR5cGUuc3BlYy5zcGFubmluZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoa2VlcCA8IGFjdGl2ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IGFjdGl2ZS5wb3AoKVsxXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVuZGVyZWQgPCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkID0gbm9kZS5tYXJrc1tyZW5kZXJlZCsrXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmtET00gPSB0aGlzLnNlcmlhbGl6ZU1hcmsoYWRkLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtET00pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKFthZGQsIHRvcF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLmFwcGVuZENoaWxkKG1hcmtET00uZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IG1hcmtET00uY29udGVudERPTSB8fCBtYXJrRE9NLmRvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvcC5hcHBlbmRDaGlsZCh0aGlzLnNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCB7IGRvbSwgY29udGVudERPTSB9ID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvYyhvcHRpb25zKSwgdGhpcy5ub2Rlc1tub2RlLnR5cGUubmFtZV0obm9kZSkpO1xuICAgICAgICBpZiAoY29udGVudERPTSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ29udGVudCBob2xlIG5vdCBhbGxvd2VkIGluIGEgbGVhZiBub2RlIHNwZWNcIik7XG4gICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZUZyYWdtZW50KG5vZGUuY29udGVudCwgb3B0aW9ucywgY29udGVudERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgbm9kZSB0byBhIERPTSBub2RlLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3VcbiAgICBuZWVkIHRvIHNlcmlhbGl6ZSBhIHBhcnQgb2YgYSBkb2N1bWVudCwgYXMgb3Bwb3NlZCB0byB0aGUgd2hvbGVcbiAgICBkb2N1bWVudC4gVG8gc2VyaWFsaXplIGEgd2hvbGUgZG9jdW1lbnQsIHVzZVxuICAgIFtgc2VyaWFsaXplRnJhZ21lbnRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuRE9NU2VyaWFsaXplci5zZXJpYWxpemVGcmFnbWVudCkgb25cbiAgICBpdHMgW2NvbnRlbnRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLmNvbnRlbnQpLlxuICAgICovXG4gICAgc2VyaWFsaXplTm9kZShub2RlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGRvbSA9IHRoaXMuc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gbm9kZS5tYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHdyYXAgPSB0aGlzLnNlcmlhbGl6ZU1hcmsobm9kZS5tYXJrc1tpXSwgbm9kZS5pc0lubGluZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAod3JhcCkge1xuICAgICAgICAgICAgICAgICh3cmFwLmNvbnRlbnRET00gfHwgd3JhcC5kb20pLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgICAgICAgICAgICAgZG9tID0gd3JhcC5kb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXJpYWxpemVNYXJrKG1hcmssIGlubGluZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB0b0RPTSA9IHRoaXMubWFya3NbbWFyay50eXBlLm5hbWVdO1xuICAgICAgICByZXR1cm4gdG9ET00gJiYgRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvYyhvcHRpb25zKSwgdG9ET00obWFyaywgaW5saW5lKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbmRlciBhbiBbb3V0cHV0IHNwZWNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5ET01PdXRwdXRTcGVjKSB0byBhIERPTSBub2RlLiBJZlxuICAgIHRoZSBzcGVjIGhhcyBhIGhvbGUgKHplcm8pIGluIGl0LCBgY29udGVudERPTWAgd2lsbCBwb2ludCBhdCB0aGVcbiAgICBub2RlIHdpdGggdGhlIGhvbGUuXG4gICAgKi9cbiAgICBzdGF0aWMgcmVuZGVyU3BlYyhkb2MsIHN0cnVjdHVyZSwgeG1sTlMgPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RydWN0dXJlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4geyBkb206IGRvYy5jcmVhdGVUZXh0Tm9kZShzdHJ1Y3R1cmUpIH07XG4gICAgICAgIGlmIChzdHJ1Y3R1cmUubm9kZVR5cGUgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB7IGRvbTogc3RydWN0dXJlIH07XG4gICAgICAgIGlmIChzdHJ1Y3R1cmUuZG9tICYmIHN0cnVjdHVyZS5kb20ubm9kZVR5cGUgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmU7XG4gICAgICAgIGxldCB0YWdOYW1lID0gc3RydWN0dXJlWzBdLCBzcGFjZSA9IHRhZ05hbWUuaW5kZXhPZihcIiBcIik7XG4gICAgICAgIGlmIChzcGFjZSA+IDApIHtcbiAgICAgICAgICAgIHhtbE5TID0gdGFnTmFtZS5zbGljZSgwLCBzcGFjZSk7XG4gICAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS5zbGljZShzcGFjZSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50RE9NO1xuICAgICAgICBsZXQgZG9tID0gKHhtbE5TID8gZG9jLmNyZWF0ZUVsZW1lbnROUyh4bWxOUywgdGFnTmFtZSkgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWdOYW1lKSk7XG4gICAgICAgIGxldCBhdHRycyA9IHN0cnVjdHVyZVsxXSwgc3RhcnQgPSAxO1xuICAgICAgICBpZiAoYXR0cnMgJiYgdHlwZW9mIGF0dHJzID09IFwib2JqZWN0XCIgJiYgYXR0cnMubm9kZVR5cGUgPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShhdHRycykpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMjtcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlID0gbmFtZS5pbmRleE9mKFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwYWNlID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNsaWNlKDAsIHNwYWNlKSwgbmFtZS5zbGljZShzcGFjZSArIDEpLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdHJ1Y3R1cmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHN0cnVjdHVyZVtpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgc3RydWN0dXJlLmxlbmd0aCAtIDEgfHwgaSA+IHN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNvbnRlbnQgaG9sZSBtdXN0IGJlIHRoZSBvbmx5IGNoaWxkIG9mIGl0cyBwYXJlbnQgbm9kZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkb20sIGNvbnRlbnRET006IGRvbSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZG9tOiBpbm5lciwgY29udGVudERPTTogaW5uZXJDb250ZW50IH0gPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jLCBjaGlsZCwgeG1sTlMpO1xuICAgICAgICAgICAgICAgIGRvbS5hcHBlbmRDaGlsZChpbm5lcik7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTXVsdGlwbGUgY29udGVudCBob2xlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudERPTSA9IGlubmVyQ29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9tLCBjb250ZW50RE9NIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgc2VyaWFsaXplciB1c2luZyB0aGUgW2B0b0RPTWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy50b0RPTSlcbiAgICBwcm9wZXJ0aWVzIGluIGEgc2NoZW1hJ3Mgbm9kZSBhbmQgbWFyayBzcGVjcy5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmNhY2hlZC5kb21TZXJpYWxpemVyIHx8XG4gICAgICAgICAgICAoc2NoZW1hLmNhY2hlZC5kb21TZXJpYWxpemVyID0gbmV3IERPTVNlcmlhbGl6ZXIodGhpcy5ub2Rlc0Zyb21TY2hlbWEoc2NoZW1hKSwgdGhpcy5tYXJrc0Zyb21TY2hlbWEoc2NoZW1hKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBHYXRoZXIgdGhlIHNlcmlhbGl6ZXJzIGluIGEgc2NoZW1hJ3Mgbm9kZSBzcGVjcyBpbnRvIGFuIG9iamVjdC5cbiAgICBUaGlzIGNhbiBiZSB1c2VmdWwgYXMgYSBiYXNlIHRvIGJ1aWxkIGEgY3VzdG9tIHNlcmlhbGl6ZXIgZnJvbS5cbiAgICAqL1xuICAgIHN0YXRpYyBub2Rlc0Zyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBnYXRoZXJUb0RPTShzY2hlbWEubm9kZXMpO1xuICAgICAgICBpZiAoIXJlc3VsdC50ZXh0KVxuICAgICAgICAgICAgcmVzdWx0LnRleHQgPSBub2RlID0+IG5vZGUudGV4dDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2F0aGVyIHRoZSBzZXJpYWxpemVycyBpbiBhIHNjaGVtYSdzIG1hcmsgc3BlY3MgaW50byBhbiBvYmplY3QuXG4gICAgKi9cbiAgICBzdGF0aWMgbWFya3NGcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gZ2F0aGVyVG9ET00oc2NoZW1hLm1hcmtzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnYXRoZXJUb0RPTShvYmopIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgbmFtZSBpbiBvYmopIHtcbiAgICAgICAgbGV0IHRvRE9NID0gb2JqW25hbWVdLnNwZWMudG9ET007XG4gICAgICAgIGlmICh0b0RPTSlcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHRvRE9NO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZG9jKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5kb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQ7XG59XG5cbmV4cG9ydCB7IENvbnRlbnRNYXRjaCwgRE9NUGFyc2VyLCBET01TZXJpYWxpemVyLCBGcmFnbWVudCwgTWFyaywgTWFya1R5cGUsIE5vZGUsIE5vZGVSYW5nZSwgTm9kZVR5cGUsIFJlcGxhY2VFcnJvciwgUmVzb2x2ZWRQb3MsIFNjaGVtYSwgU2xpY2UgfTtcbiIsICJpbXBvcnQgeyBSZXBsYWNlRXJyb3IsIFNsaWNlLCBGcmFnbWVudCwgTWFya1R5cGUsIE1hcmsgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5cbi8vIFJlY292ZXJ5IHZhbHVlcyBlbmNvZGUgYSByYW5nZSBpbmRleCBhbmQgYW4gb2Zmc2V0LiBUaGV5IGFyZVxuLy8gcmVwcmVzZW50ZWQgYXMgbnVtYmVycywgYmVjYXVzZSB0b25zIG9mIHRoZW0gd2lsbCBiZSBjcmVhdGVkIHdoZW5cbi8vIG1hcHBpbmcsIGZvciBleGFtcGxlLCBhIGxhcmdlIG51bWJlciBvZiBkZWNvcmF0aW9ucy4gVGhlIG51bWJlcidzXG4vLyBsb3dlciAxNiBiaXRzIHByb3ZpZGUgdGhlIGluZGV4LCB0aGUgcmVtYWluaW5nIGJpdHMgdGhlIG9mZnNldC5cbi8vXG4vLyBOb3RlOiBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBiaXQgc2hpZnQgb3BlcmF0b3JzIHRvIGVuLSBhbmRcbi8vIGRlY29kZSB0aGVzZSwgc2luY2UgdGhvc2UgY2xpcCB0byAzMiBiaXRzLCB3aGljaCB3ZSBtaWdodCBpbiByYXJlXG4vLyBjYXNlcyB3YW50IHRvIG92ZXJmbG93LiBBIDY0LWJpdCBmbG9hdCBjYW4gcmVwcmVzZW50IDQ4LWJpdFxuLy8gaW50ZWdlcnMgcHJlY2lzZWx5LlxuY29uc3QgbG93ZXIxNiA9IDB4ZmZmZjtcbmNvbnN0IGZhY3RvcjE2ID0gTWF0aC5wb3coMiwgMTYpO1xuZnVuY3Rpb24gbWFrZVJlY292ZXIoaW5kZXgsIG9mZnNldCkgeyByZXR1cm4gaW5kZXggKyBvZmZzZXQgKiBmYWN0b3IxNjsgfVxuZnVuY3Rpb24gcmVjb3ZlckluZGV4KHZhbHVlKSB7IHJldHVybiB2YWx1ZSAmIGxvd2VyMTY7IH1cbmZ1bmN0aW9uIHJlY292ZXJPZmZzZXQodmFsdWUpIHsgcmV0dXJuICh2YWx1ZSAtICh2YWx1ZSAmIGxvd2VyMTYpKSAvIGZhY3RvcjE2OyB9XG5jb25zdCBERUxfQkVGT1JFID0gMSwgREVMX0FGVEVSID0gMiwgREVMX0FDUk9TUyA9IDQsIERFTF9TSURFID0gODtcbi8qKlxuQW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIG1hcHBlZCBwb3NpdGlvbiB3aXRoIGV4dHJhXG5pbmZvcm1hdGlvbi5cbiovXG5jbGFzcyBNYXBSZXN1bHQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG1hcHBlZCB2ZXJzaW9uIG9mIHRoZSBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkZWxJbmZvLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXIpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZGVsSW5mbyA9IGRlbEluZm87XG4gICAgICAgIHRoaXMucmVjb3ZlciA9IHJlY292ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoZSBwb3NpdGlvbiB3YXMgZGVsZXRlZCwgdGhhdCBpcywgd2hldGhlciB0aGVcbiAgICBzdGVwIHJlbW92ZWQgdGhlIHRva2VuIG9uIHRoZSBzaWRlIHF1ZXJpZWQgKHZpYSB0aGUgYGFzc29jYClcbiAgICBhcmd1bWVudCBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIERFTF9TSURFKSA+IDA7IH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGUgdG9rZW4gYmVmb3JlIHRoZSBtYXBwZWQgcG9zaXRpb24gd2FzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZEJlZm9yZSgpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiAoREVMX0JFRk9SRSB8IERFTF9BQ1JPU1MpKSA+IDA7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhlIHRva2VuIGFmdGVyIHRoZSBtYXBwZWQgcG9zaXRpb24gd2FzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZEFmdGVyKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIChERUxfQUZURVIgfCBERUxfQUNST1NTKSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVGVsbHMgd2hldGhlciBhbnkgb2YgdGhlIHN0ZXBzIG1hcHBlZCB0aHJvdWdoIGRlbGV0ZXMgYWNyb3NzIHRoZVxuICAgIHBvc2l0aW9uIChpbmNsdWRpbmcgYm90aCB0aGUgdG9rZW4gYmVmb3JlIGFuZCBhZnRlciB0aGVcbiAgICBwb3NpdGlvbikuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZEFjcm9zcygpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiBERUxfQUNST1NTKSA+IDA7IH1cbn1cbi8qKlxuQSBtYXAgZGVzY3JpYmluZyB0aGUgZGVsZXRpb25zIGFuZCBpbnNlcnRpb25zIG1hZGUgYnkgYSBzdGVwLCB3aGljaFxuY2FuIGJlIHVzZWQgdG8gZmluZCB0aGUgY29ycmVzcG9uZGVuY2UgYmV0d2VlbiBwb3NpdGlvbnMgaW4gdGhlXG5wcmUtc3RlcCB2ZXJzaW9uIG9mIGEgZG9jdW1lbnQgYW5kIHRoZSBzYW1lIHBvc2l0aW9uIGluIHRoZVxucG9zdC1zdGVwIHZlcnNpb24uXG4qL1xuY2xhc3MgU3RlcE1hcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcG9zaXRpb24gbWFwLiBUaGUgbW9kaWZpY2F0aW9ucyB0byB0aGUgZG9jdW1lbnQgYXJlXG4gICAgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2YgbnVtYmVycywgaW4gd2hpY2ggZWFjaCBncm91cCBvZiB0aHJlZVxuICAgIHJlcHJlc2VudHMgYSBtb2RpZmllZCBjaHVuayBhcyBgW3N0YXJ0LCBvbGRTaXplLCBuZXdTaXplXWAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJhbmdlcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnZlcnRlZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmludmVydGVkID0gaW52ZXJ0ZWQ7XG4gICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aCAmJiBTdGVwTWFwLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3Zlcih2YWx1ZSkge1xuICAgICAgICBsZXQgZGlmZiA9IDAsIGluZGV4ID0gcmVjb3ZlckluZGV4KHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLmludmVydGVkKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuICAgICAgICAgICAgICAgIGRpZmYgKz0gdGhpcy5yYW5nZXNbaSAqIDMgKyAyXSAtIHRoaXMucmFuZ2VzW2kgKiAzICsgMV07XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1tpbmRleCAqIDNdICsgZGlmZiArIHJlY292ZXJPZmZzZXQodmFsdWUpO1xuICAgIH1cbiAgICBtYXBSZXN1bHQocG9zLCBhc3NvYyA9IDEpIHsgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCBmYWxzZSk7IH1cbiAgICBtYXAocG9zLCBhc3NvYyA9IDEpIHsgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgX21hcChwb3MsIGFzc29jLCBzaW1wbGUpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSwgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzW2ldIC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIG5ld1NpemUgPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdLCBlbmQgPSBzdGFydCArIG9sZFNpemU7XG4gICAgICAgICAgICBpZiAocG9zIDw9IGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBzaWRlID0gIW9sZFNpemUgPyBhc3NvYyA6IHBvcyA9PSBzdGFydCA/IC0xIDogcG9zID09IGVuZCA/IDEgOiBhc3NvYztcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gc3RhcnQgKyBkaWZmICsgKHNpZGUgPCAwID8gMCA6IG5ld1NpemUpO1xuICAgICAgICAgICAgICAgIGlmIChzaW1wbGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgbGV0IHJlY292ZXIgPSBwb3MgPT0gKGFzc29jIDwgMCA/IHN0YXJ0IDogZW5kKSA/IG51bGwgOiBtYWtlUmVjb3ZlcihpIC8gMywgcG9zIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgIGxldCBkZWwgPSBwb3MgPT0gc3RhcnQgPyBERUxfQUZURVIgOiBwb3MgPT0gZW5kID8gREVMX0JFRk9SRSA6IERFTF9BQ1JPU1M7XG4gICAgICAgICAgICAgICAgaWYgKGFzc29jIDwgMCA/IHBvcyAhPSBzdGFydCA6IHBvcyAhPSBlbmQpXG4gICAgICAgICAgICAgICAgICAgIGRlbCB8PSBERUxfU0lERTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hcFJlc3VsdChyZXN1bHQsIGRlbCwgcmVjb3Zlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaWZmICs9IG5ld1NpemUgLSBvbGRTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW1wbGUgPyBwb3MgKyBkaWZmIDogbmV3IE1hcFJlc3VsdChwb3MgKyBkaWZmLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b3VjaGVzKHBvcywgcmVjb3Zlcikge1xuICAgICAgICBsZXQgZGlmZiA9IDAsIGluZGV4ID0gcmVjb3ZlckluZGV4KHJlY292ZXIpO1xuICAgICAgICBsZXQgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLCBlbmQgPSBzdGFydCArIG9sZFNpemU7XG4gICAgICAgICAgICBpZiAocG9zIDw9IGVuZCAmJiBpID09IGluZGV4ICogMylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGRpZmYgKz0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XSAtIG9sZFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBDYWxscyB0aGUgZ2l2ZW4gZnVuY3Rpb24gb24gZWFjaCBvZiB0aGUgY2hhbmdlZCByYW5nZXMgaW5jbHVkZWQgaW5cbiAgICB0aGlzIG1hcC5cbiAgICAqL1xuICAgIGZvckVhY2goZikge1xuICAgICAgICBsZXQgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgZGlmZiA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0sIG9sZFN0YXJ0ID0gc3RhcnQgLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKSwgbmV3U3RhcnQgPSBzdGFydCArICh0aGlzLmludmVydGVkID8gMCA6IGRpZmYpO1xuICAgICAgICAgICAgbGV0IG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLCBuZXdTaXplID0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XTtcbiAgICAgICAgICAgIGYob2xkU3RhcnQsIG9sZFN0YXJ0ICsgb2xkU2l6ZSwgbmV3U3RhcnQsIG5ld1N0YXJ0ICsgbmV3U2l6ZSk7XG4gICAgICAgICAgICBkaWZmICs9IG5ld1NpemUgLSBvbGRTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoaXMgbWFwLiBUaGUgcmVzdWx0IGNhbiBiZSB1c2VkIHRvXG4gICAgbWFwIHBvc2l0aW9ucyBpbiB0aGUgcG9zdC1zdGVwIGRvY3VtZW50IHRvIHRoZSBwcmUtc3RlcCBkb2N1bWVudC5cbiAgICAqL1xuICAgIGludmVydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKHRoaXMucmFuZ2VzLCAhdGhpcy5pbnZlcnRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pbnZlcnRlZCA/IFwiLVwiIDogXCJcIikgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnJhbmdlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcCB0aGF0IG1vdmVzIGFsbCBwb3NpdGlvbnMgYnkgb2Zmc2V0IGBuYCAod2hpY2ggbWF5IGJlXG4gICAgbmVnYXRpdmUpLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBhcHBseWluZyBzdGVwcyBtZWFudCBmb3IgYVxuICAgIHN1Yi1kb2N1bWVudCB0byBhIGxhcmdlciBkb2N1bWVudCwgb3IgdmljZS12ZXJzYS5cbiAgICAqL1xuICAgIHN0YXRpYyBvZmZzZXQobikge1xuICAgICAgICByZXR1cm4gbiA9PSAwID8gU3RlcE1hcC5lbXB0eSA6IG5ldyBTdGVwTWFwKG4gPCAwID8gWzAsIC1uLCAwXSA6IFswLCAwLCBuXSk7XG4gICAgfVxufVxuLyoqXG5BIFN0ZXBNYXAgdGhhdCBjb250YWlucyBubyBjaGFuZ2VkIHJhbmdlcy5cbiovXG5TdGVwTWFwLmVtcHR5ID0gbmV3IFN0ZXBNYXAoW10pO1xuLyoqXG5BIG1hcHBpbmcgcmVwcmVzZW50cyBhIHBpcGVsaW5lIG9mIHplcm8gb3IgbW9yZSBbc3RlcFxubWFwc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwTWFwKS4gSXQgaGFzIHNwZWNpYWwgcHJvdmlzaW9ucyBmb3IgbG9zc2xlc3NseVxuaGFuZGxpbmcgbWFwcGluZyBwb3NpdGlvbnMgdGhyb3VnaCBhIHNlcmllcyBvZiBzdGVwcyBpbiB3aGljaCBzb21lXG5zdGVwcyBhcmUgaW52ZXJ0ZWQgdmVyc2lvbnMgb2YgZWFybGllciBzdGVwcy4gKFRoaXMgY29tZXMgdXAgd2hlblxuXHUyMDE4W3JlYmFzaW5nXSgvZG9jcy9ndWlkZS8jdHJhbnNmb3JtLnJlYmFzaW5nKVx1MjAxOSBzdGVwcyBmb3JcbmNvbGxhYm9yYXRpb24gb3IgaGlzdG9yeSBtYW5hZ2VtZW50LilcbiovXG5jbGFzcyBNYXBwaW5nIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgbWFwcGluZyB3aXRoIHRoZSBnaXZlbiBwb3NpdGlvbiBtYXBzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0ZXAgbWFwcyBpbiB0aGlzIG1hcHBpbmcuXG4gICAgKi9cbiAgICBtYXBzID0gW10sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWlycm9yLCBcbiAgICAvKipcbiAgICBUaGUgc3RhcnRpbmcgcG9zaXRpb24gaW4gdGhlIGBtYXBzYCBhcnJheSwgdXNlZCB3aGVuIGBtYXBgIG9yXG4gICAgYG1hcFJlc3VsdGAgaXMgY2FsbGVkLlxuICAgICovXG4gICAgZnJvbSA9IDAsIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gaW4gdGhlIGBtYXBzYCBhcnJheS5cbiAgICAqL1xuICAgIHRvID0gbWFwcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5tYXBzID0gbWFwcztcbiAgICAgICAgdGhpcy5taXJyb3IgPSBtaXJyb3I7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFwcGluZyB0aGF0IG1hcHMgb25seSB0aHJvdWdoIGEgcGFydCBvZiB0aGlzIG9uZS5cbiAgICAqL1xuICAgIHNsaWNlKGZyb20gPSAwLCB0byA9IHRoaXMubWFwcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXBwaW5nKHRoaXMubWFwcywgdGhpcy5taXJyb3IsIGZyb20sIHRvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hcHBpbmcodGhpcy5tYXBzLnNsaWNlKCksIHRoaXMubWlycm9yICYmIHRoaXMubWlycm9yLnNsaWNlKCksIHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIHN0ZXAgbWFwIHRvIHRoZSBlbmQgb2YgdGhpcyBtYXBwaW5nLiBJZiBgbWlycm9yc2AgaXNcbiAgICBnaXZlbiwgaXQgc2hvdWxkIGJlIHRoZSBpbmRleCBvZiB0aGUgc3RlcCBtYXAgdGhhdCBpcyB0aGUgbWlycm9yXG4gICAgaW1hZ2Ugb2YgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhcHBlbmRNYXAobWFwLCBtaXJyb3JzKSB7XG4gICAgICAgIHRoaXMudG8gPSB0aGlzLm1hcHMucHVzaChtYXApO1xuICAgICAgICBpZiAobWlycm9ycyAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zZXRNaXJyb3IodGhpcy5tYXBzLmxlbmd0aCAtIDEsIG1pcnJvcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYWxsIHRoZSBzdGVwIG1hcHMgaW4gYSBnaXZlbiBtYXBwaW5nIHRvIHRoaXMgb25lIChwcmVzZXJ2aW5nXG4gICAgbWlycm9yaW5nIGluZm9ybWF0aW9uKS5cbiAgICAqL1xuICAgIGFwcGVuZE1hcHBpbmcobWFwcGluZykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgc3RhcnRTaXplID0gdGhpcy5tYXBzLmxlbmd0aDsgaSA8IG1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1pcnIgPSBtYXBwaW5nLmdldE1pcnJvcihpKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTWFwKG1hcHBpbmcubWFwc1tpXSwgbWlyciAhPSBudWxsICYmIG1pcnIgPCBpID8gc3RhcnRTaXplICsgbWlyciA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZHMgdGhlIG9mZnNldCBvZiB0aGUgc3RlcCBtYXAgdGhhdCBtaXJyb3JzIHRoZSBtYXAgYXQgdGhlXG4gICAgZ2l2ZW4gb2Zmc2V0LCBpbiB0aGlzIG1hcHBpbmcgKGFzIHBlciB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvXG4gICAgYGFwcGVuZE1hcGApLlxuICAgICovXG4gICAgZ2V0TWlycm9yKG4pIHtcbiAgICAgICAgaWYgKHRoaXMubWlycm9yKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1pcnJvci5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taXJyb3JbaV0gPT0gbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWlycm9yW2kgKyAoaSAlIDIgPyAtMSA6IDEpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXRNaXJyb3IobiwgbSkge1xuICAgICAgICBpZiAoIXRoaXMubWlycm9yKVxuICAgICAgICAgICAgdGhpcy5taXJyb3IgPSBbXTtcbiAgICAgICAgdGhpcy5taXJyb3IucHVzaChuLCBtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwZW5kIHRoZSBpbnZlcnNlIG9mIHRoZSBnaXZlbiBtYXBwaW5nIHRvIHRoaXMgb25lLlxuICAgICovXG4gICAgYXBwZW5kTWFwcGluZ0ludmVydGVkKG1hcHBpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG1hcHBpbmcubWFwcy5sZW5ndGggLSAxLCB0b3RhbFNpemUgPSB0aGlzLm1hcHMubGVuZ3RoICsgbWFwcGluZy5tYXBzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBtaXJyID0gbWFwcGluZy5nZXRNaXJyb3IoaSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZE1hcChtYXBwaW5nLm1hcHNbaV0uaW52ZXJ0KCksIG1pcnIgIT0gbnVsbCAmJiBtaXJyID4gaSA/IHRvdGFsU2l6ZSAtIG1pcnIgLSAxIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW52ZXJ0ZWQgdmVyc2lvbiBvZiB0aGlzIG1hcHBpbmcuXG4gICAgKi9cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIGxldCBpbnZlcnNlID0gbmV3IE1hcHBpbmc7XG4gICAgICAgIGludmVyc2UuYXBwZW5kTWFwcGluZ0ludmVydGVkKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW52ZXJzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGEgcG9zaXRpb24gdGhyb3VnaCB0aGlzIG1hcHBpbmcuXG4gICAgKi9cbiAgICBtYXAocG9zLCBhc3NvYyA9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMubWlycm9yKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCB0cnVlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJvbTsgaSA8IHRoaXMudG87IGkrKylcbiAgICAgICAgICAgIHBvcyA9IHRoaXMubWFwc1tpXS5tYXAocG9zLCBhc3NvYyk7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRocm91Z2ggdGhpcyBtYXBwaW5nLCByZXR1cm5pbmcgYSBtYXBwaW5nXG4gICAgcmVzdWx0LlxuICAgICovXG4gICAgbWFwUmVzdWx0KHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgZmFsc2UpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBfbWFwKHBvcywgYXNzb2MsIHNpbXBsZSkge1xuICAgICAgICBsZXQgZGVsSW5mbyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyb207IGkgPCB0aGlzLnRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXAgPSB0aGlzLm1hcHNbaV0sIHJlc3VsdCA9IG1hcC5tYXBSZXN1bHQocG9zLCBhc3NvYyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlY292ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBjb3JyID0gdGhpcy5nZXRNaXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvcnIgIT0gbnVsbCAmJiBjb3JyID4gaSAmJiBjb3JyIDwgdGhpcy50bykge1xuICAgICAgICAgICAgICAgICAgICBpID0gY29ycjtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gdGhpcy5tYXBzW2NvcnJdLnJlY292ZXIocmVzdWx0LnJlY292ZXIpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxJbmZvIHw9IHJlc3VsdC5kZWxJbmZvO1xuICAgICAgICAgICAgcG9zID0gcmVzdWx0LnBvcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2ltcGxlID8gcG9zIDogbmV3IE1hcFJlc3VsdChwb3MsIGRlbEluZm8sIG51bGwpO1xuICAgIH1cbn1cblxuY29uc3Qgc3RlcHNCeUlEID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuQSBzdGVwIG9iamVjdCByZXByZXNlbnRzIGFuIGF0b21pYyBjaGFuZ2UuIEl0IGdlbmVyYWxseSBhcHBsaWVzXG5vbmx5IHRvIHRoZSBkb2N1bWVudCBpdCB3YXMgY3JlYXRlZCBmb3IsIHNpbmNlIHRoZSBwb3NpdGlvbnNcbnN0b3JlZCBpbiBpdCB3aWxsIG9ubHkgbWFrZSBzZW5zZSBmb3IgdGhhdCBkb2N1bWVudC5cblxuTmV3IHN0ZXBzIGFyZSBkZWZpbmVkIGJ5IGNyZWF0aW5nIGNsYXNzZXMgdGhhdCBleHRlbmQgYFN0ZXBgLFxub3ZlcnJpZGluZyB0aGUgYGFwcGx5YCwgYGludmVydGAsIGBtYXBgLCBgZ2V0TWFwYCBhbmQgYGZyb21KU09OYFxubWV0aG9kcywgYW5kIHJlZ2lzdGVyaW5nIHlvdXIgY2xhc3Mgd2l0aCBhIHVuaXF1ZVxuSlNPTi1zZXJpYWxpemF0aW9uIGlkZW50aWZpZXIgdXNpbmdcbltgU3RlcC5qc29uSURgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXBeanNvbklEKS5cbiovXG5jbGFzcyBTdGVwIHtcbiAgICAvKipcbiAgICBHZXQgdGhlIHN0ZXAgbWFwIHRoYXQgcmVwcmVzZW50cyB0aGUgY2hhbmdlcyBtYWRlIGJ5IHRoaXMgc3RlcCxcbiAgICBhbmQgd2hpY2ggY2FuIGJlIHVzZWQgdG8gdHJhbnNmb3JtIGJldHdlZW4gcG9zaXRpb25zIGluIHRoZSBvbGRcbiAgICBhbmQgdGhlIG5ldyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldE1hcCgpIHsgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7IH1cbiAgICAvKipcbiAgICBUcnkgdG8gbWVyZ2UgdGhpcyBzdGVwIHdpdGggYW5vdGhlciBvbmUsIHRvIGJlIGFwcGxpZWQgZGlyZWN0bHlcbiAgICBhZnRlciBpdC4gUmV0dXJucyB0aGUgbWVyZ2VkIHN0ZXAgd2hlbiBwb3NzaWJsZSwgbnVsbCBpZiB0aGVcbiAgICBzdGVwcyBjYW4ndCBiZSBtZXJnZWQuXG4gICAgKi9cbiAgICBtZXJnZShvdGhlcikgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgc3RlcCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBXaWxsIGNhbGxcbiAgICB0aHJvdWdoIHRvIHRoZSBzdGVwIGNsYXNzJyBvd24gaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCAhanNvbi5zdGVwVHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgbGV0IHR5cGUgPSBzdGVwc0J5SURbanNvbi5zdGVwVHlwZV07XG4gICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBObyBzdGVwIHR5cGUgJHtqc29uLnN0ZXBUeXBlfSBkZWZpbmVkYCk7XG4gICAgICAgIHJldHVybiB0eXBlLmZyb21KU09OKHNjaGVtYSwganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRvIGJlIGFibGUgdG8gc2VyaWFsaXplIHN0ZXBzIHRvIEpTT04sIGVhY2ggc3RlcCBuZWVkcyBhIHN0cmluZ1xuICAgIElEIHRvIGF0dGFjaCB0byBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVXNlIHRoaXMgbWV0aG9kIHRvXG4gICAgcmVnaXN0ZXIgYW4gSUQgZm9yIHlvdXIgc3RlcCBjbGFzc2VzLiBUcnkgdG8gcGljayBzb21ldGhpbmdcbiAgICB0aGF0J3MgdW5saWtlbHkgdG8gY2xhc2ggd2l0aCBzdGVwcyBmcm9tIG90aGVyIG1vZHVsZXMuXG4gICAgKi9cbiAgICBzdGF0aWMganNvbklEKGlkLCBzdGVwQ2xhc3MpIHtcbiAgICAgICAgaWYgKGlkIGluIHN0ZXBzQnlJRClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRHVwbGljYXRlIHVzZSBvZiBzdGVwIEpTT04gSUQgXCIgKyBpZCk7XG4gICAgICAgIHN0ZXBzQnlJRFtpZF0gPSBzdGVwQ2xhc3M7XG4gICAgICAgIHN0ZXBDbGFzcy5wcm90b3R5cGUuanNvbklEID0gaWQ7XG4gICAgICAgIHJldHVybiBzdGVwQ2xhc3M7XG4gICAgfVxufVxuLyoqXG5UaGUgcmVzdWx0IG9mIFthcHBseWluZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwLmFwcGx5KSBhIHN0ZXAuIENvbnRhaW5zIGVpdGhlciBhXG5uZXcgZG9jdW1lbnQgb3IgYSBmYWlsdXJlIHZhbHVlLlxuKi9cbmNsYXNzIFN0ZXBSZXN1bHQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHRyYW5zZm9ybWVkIGRvY3VtZW50LCBpZiBzdWNjZXNzZnVsLlxuICAgICovXG4gICAgZG9jLCBcbiAgICAvKipcbiAgICBUaGUgZmFpbHVyZSBtZXNzYWdlLCBpZiB1bnN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBmYWlsZWQpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMuZmFpbGVkID0gZmFpbGVkO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzdWNjZXNzZnVsIHN0ZXAgcmVzdWx0LlxuICAgICovXG4gICAgc3RhdGljIG9rKGRvYykgeyByZXR1cm4gbmV3IFN0ZXBSZXN1bHQoZG9jLCBudWxsKTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGZhaWxlZCBzdGVwIHJlc3VsdC5cbiAgICAqL1xuICAgIHN0YXRpYyBmYWlsKG1lc3NhZ2UpIHsgcmV0dXJuIG5ldyBTdGVwUmVzdWx0KG51bGwsIG1lc3NhZ2UpOyB9XG4gICAgLyoqXG4gICAgQ2FsbCBbYE5vZGUucmVwbGFjZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnJlcGxhY2UpIHdpdGggdGhlIGdpdmVuXG4gICAgYXJndW1lbnRzLiBDcmVhdGUgYSBzdWNjZXNzZnVsIHJlc3VsdCBpZiBpdCBzdWNjZWVkcywgYW5kIGFcbiAgICBmYWlsZWQgb25lIGlmIGl0IHRocm93cyBhIGBSZXBsYWNlRXJyb3JgLlxuICAgICovXG4gICAgc3RhdGljIGZyb21SZXBsYWNlKGRvYywgZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5vayhkb2MucmVwbGFjZShmcm9tLCB0bywgc2xpY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSZXBsYWNlRXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFwRnJhZ21lbnQoZnJhZ21lbnQsIGYsIHBhcmVudCkge1xuICAgIGxldCBtYXBwZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYWdtZW50LmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBmcmFnbWVudC5jaGlsZChpKTtcbiAgICAgICAgaWYgKGNoaWxkLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY29weShtYXBGcmFnbWVudChjaGlsZC5jb250ZW50LCBmLCBjaGlsZCkpO1xuICAgICAgICBpZiAoY2hpbGQuaXNJbmxpbmUpXG4gICAgICAgICAgICBjaGlsZCA9IGYoY2hpbGQsIHBhcmVudCwgaSk7XG4gICAgICAgIG1hcHBlZC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIEZyYWdtZW50LmZyb21BcnJheShtYXBwZWQpO1xufVxuLyoqXG5BZGQgYSBtYXJrIHRvIGFsbCBpbmxpbmUgY29udGVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMuXG4qL1xuY2xhc3MgQWRkTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIG1hcmtlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIG1hcmtlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byBhZGQuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBvbGRTbGljZSA9IGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pLCAkZnJvbSA9IGRvYy5yZXNvbHZlKHRoaXMuZnJvbSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSAkZnJvbS5ub2RlKCRmcm9tLnNoYXJlZERlcHRoKHRoaXMudG8pKTtcbiAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKG1hcEZyYWdtZW50KG9sZFNsaWNlLmNvbnRlbnQsIChub2RlLCBwYXJlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghbm9kZS5pc0F0b20gfHwgIXBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKHRoaXMubWFyay50eXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm1hcmsodGhpcy5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICAgICAgfSwgcGFyZW50KSwgb2xkU2xpY2Uub3BlblN0YXJ0LCBvbGRTbGljZS5vcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHNsaWNlKTtcbiAgICB9XG4gICAgaW52ZXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgICAgaWYgKGZyb20uZGVsZXRlZCAmJiB0by5kZWxldGVkIHx8IGZyb20ucG9zID49IHRvLnBvcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKGZyb20ucG9zLCB0by5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIEFkZE1hcmtTdGVwICYmXG4gICAgICAgICAgICBvdGhlci5tYXJrLmVxKHRoaXMubWFyaykgJiZcbiAgICAgICAgICAgIHRoaXMuZnJvbSA8PSBvdGhlci50byAmJiB0aGlzLnRvID49IG90aGVyLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKE1hdGgubWluKHRoaXMuZnJvbSwgb3RoZXIuZnJvbSksIE1hdGgubWF4KHRoaXMudG8sIG90aGVyLnRvKSwgdGhpcy5tYXJrKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwiYWRkTWFya1wiLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCksXG4gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEFkZE1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKGpzb24uZnJvbSwganNvbi50bywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImFkZE1hcmtcIiwgQWRkTWFya1N0ZXApO1xuLyoqXG5SZW1vdmUgYSBtYXJrIGZyb20gYWxsIGlubGluZSBjb250ZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucy5cbiovXG5jbGFzcyBSZW1vdmVNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmstcmVtb3Zpbmcgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgdW5tYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSB1bm1hcmtlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byByZW1vdmUuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBvbGRTbGljZSA9IGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgICAgICBsZXQgc2xpY2UgPSBuZXcgU2xpY2UobWFwRnJhZ21lbnQob2xkU2xpY2UuY29udGVudCwgbm9kZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5tYXJrKHRoaXMubWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKTtcbiAgICAgICAgfSwgZG9jKSwgb2xkU2xpY2Uub3BlblN0YXJ0LCBvbGRTbGljZS5vcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHNsaWNlKTtcbiAgICB9XG4gICAgaW52ZXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgICAgaWYgKGZyb20uZGVsZXRlZCAmJiB0by5kZWxldGVkIHx8IGZyb20ucG9zID49IHRvLnBvcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKGZyb20ucG9zLCB0by5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFJlbW92ZU1hcmtTdGVwICYmXG4gICAgICAgICAgICBvdGhlci5tYXJrLmVxKHRoaXMubWFyaykgJiZcbiAgICAgICAgICAgIHRoaXMuZnJvbSA8PSBvdGhlci50byAmJiB0aGlzLnRvID49IG90aGVyLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKE1hdGgubWluKHRoaXMuZnJvbSwgb3RoZXIuZnJvbSksIE1hdGgubWF4KHRoaXMudG8sIG90aGVyLnRvKSwgdGhpcy5tYXJrKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwicmVtb3ZlTWFya1wiLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCksXG4gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlbW92ZU1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKGpzb24uZnJvbSwganNvbi50bywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcInJlbW92ZU1hcmtcIiwgUmVtb3ZlTWFya1N0ZXApO1xuLyoqXG5BZGQgYSBtYXJrIHRvIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBBZGROb2RlTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIG1hcmsgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIGFkZC5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiTm8gbm9kZSBhdCBtYXJrIHN0ZXAncyBwb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBub2RlLnR5cGUuY3JlYXRlKG5vZGUuYXR0cnMsIG51bGwsIHRoaXMubWFyay5hZGRUb1NldChub2RlLm1hcmtzKSk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5wb3MsIHRoaXMucG9zICsgMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odXBkYXRlZCksIDAsIG5vZGUuaXNMZWFmID8gMCA6IDEpKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbGV0IG5ld1NldCA9IHRoaXMubWFyay5hZGRUb1NldChub2RlLm1hcmtzKTtcbiAgICAgICAgICAgIGlmIChuZXdTZXQubGVuZ3RoID09IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUubWFya3NbaV0uaXNJblNldChuZXdTZXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAodGhpcy5wb3MsIG5vZGUubWFya3NbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKHRoaXMucG9zLCB0aGlzLm1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHRoaXMucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgcG9zID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5wb3MsIDEpO1xuICAgICAgICByZXR1cm4gcG9zLmRlbGV0ZWRBZnRlciA/IG51bGwgOiBuZXcgQWRkTm9kZU1hcmtTdGVwKHBvcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwiYWRkTm9kZU1hcmtcIiwgcG9zOiB0aGlzLnBvcywgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEFkZE5vZGVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAoanNvbi5wb3MsIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJhZGROb2RlTWFya1wiLCBBZGROb2RlTWFya1N0ZXApO1xuLyoqXG5SZW1vdmUgYSBtYXJrIGZyb20gYSBzcGVjaWZpYyBub2RlLlxuKi9cbmNsYXNzIFJlbW92ZU5vZGVNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmstcmVtb3Zpbmcgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIHJlbW92ZS5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiTm8gbm9kZSBhdCBtYXJrIHN0ZXAncyBwb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBub2RlLnR5cGUuY3JlYXRlKG5vZGUuYXR0cnMsIG51bGwsIHRoaXMubWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSB8fCAhdGhpcy5tYXJrLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAocG9zLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJyZW1vdmVOb2RlTWFya1wiLCBwb3M6IHRoaXMucG9zLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVtb3ZlTm9kZU1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU5vZGVNYXJrU3RlcChqc29uLnBvcywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcInJlbW92ZU5vZGVNYXJrXCIsIFJlbW92ZU5vZGVNYXJrU3RlcCk7XG5cbi8qKlxuUmVwbGFjZSBhIHBhcnQgb2YgdGhlIGRvY3VtZW50IHdpdGggYSBzbGljZSBvZiBuZXcgY29udGVudC5cbiovXG5jbGFzcyBSZXBsYWNlU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIFRoZSBnaXZlbiBgc2xpY2VgIHNob3VsZCBmaXQgdGhlICdnYXAnIGJldHdlZW4gYGZyb21gIGFuZFxuICAgIGB0b2BcdTIwMTR0aGUgZGVwdGhzIG11c3QgbGluZSB1cCwgYW5kIHRoZSBzdXJyb3VuZGluZyBub2RlcyBtdXN0IGJlXG4gICAgYWJsZSB0byBiZSBqb2luZWQgd2l0aCB0aGUgb3BlbiBzaWRlcyBvZiB0aGUgc2xpY2UuIFdoZW5cbiAgICBgc3RydWN0dXJlYCBpcyB0cnVlLCB0aGUgc3RlcCB3aWxsIGZhaWwgaWYgdGhlIGNvbnRlbnQgYmV0d2VlblxuICAgIGZyb20gYW5kIHRvIGlzIG5vdCBqdXN0IGEgc2VxdWVuY2Ugb2YgY2xvc2luZyBhbmQgdGhlbiBvcGVuaW5nXG4gICAgdG9rZW5zICh0aGlzIGlzIHRvIGd1YXJkIGFnYWluc3QgcmViYXNlZCByZXBsYWNlIHN0ZXBzXG4gICAgb3ZlcndyaXRpbmcgc29tZXRoaW5nIHRoZXkgd2VyZW4ndCBzdXBwb3NlZCB0bykuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHNsaWNlIHRvIGluc2VydC5cbiAgICAqL1xuICAgIHNsaWNlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0cnVjdHVyZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5zbGljZSA9IHNsaWNlO1xuICAgICAgICB0aGlzLnN0cnVjdHVyZSA9IHN0cnVjdHVyZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSAmJiBjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZnJvbSwgdGhpcy50bykpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiU3RydWN0dXJlIHJlcGxhY2Ugd291bGQgb3ZlcndyaXRlIGNvbnRlbnRcIik7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLnNsaWNlKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXBNYXAoW3RoaXMuZnJvbSwgdGhpcy50byAtIHRoaXMuZnJvbSwgdGhpcy5zbGljZS5zaXplXSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCh0aGlzLmZyb20sIHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSwgZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50bykpO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkQWNyb3NzICYmIHRvLmRlbGV0ZWRBY3Jvc3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChmcm9tLnBvcywgTWF0aC5tYXgoZnJvbS5wb3MsIHRvLnBvcyksIHRoaXMuc2xpY2UpO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwKSB8fCBvdGhlci5zdHJ1Y3R1cmUgfHwgdGhpcy5zdHJ1Y3R1cmUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSA9PSBvdGhlci5mcm9tICYmICF0aGlzLnNsaWNlLm9wZW5FbmQgJiYgIW90aGVyLnNsaWNlLm9wZW5TdGFydCkge1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gdGhpcy5zbGljZS5zaXplICsgb3RoZXIuc2xpY2Uuc2l6ZSA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbGljZSh0aGlzLnNsaWNlLmNvbnRlbnQuYXBwZW5kKG90aGVyLnNsaWNlLmNvbnRlbnQpLCB0aGlzLnNsaWNlLm9wZW5TdGFydCwgb3RoZXIuc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKHRoaXMuZnJvbSwgdGhpcy50byArIChvdGhlci50byAtIG90aGVyLmZyb20pLCBzbGljZSwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG90aGVyLnRvID09IHRoaXMuZnJvbSAmJiAhdGhpcy5zbGljZS5vcGVuU3RhcnQgJiYgIW90aGVyLnNsaWNlLm9wZW5FbmQpIHtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IHRoaXMuc2xpY2Uuc2l6ZSArIG90aGVyLnNsaWNlLnNpemUgPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgICAgICAgICAgICAgOiBuZXcgU2xpY2Uob3RoZXIuc2xpY2UuY29udGVudC5hcHBlbmQodGhpcy5zbGljZS5jb250ZW50KSwgb3RoZXIuc2xpY2Uub3BlblN0YXJ0LCB0aGlzLnNsaWNlLm9wZW5FbmQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChvdGhlci5mcm9tLCB0aGlzLnRvLCBzbGljZSwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQganNvbiA9IHsgc3RlcFR5cGU6IFwicmVwbGFjZVwiLCBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvIH07XG4gICAgICAgIGlmICh0aGlzLnNsaWNlLnNpemUpXG4gICAgICAgICAgICBqc29uLnNsaWNlID0gdGhpcy5zbGljZS50b0pTT04oKTtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlKVxuICAgICAgICAgICAganNvbi5zdHJ1Y3R1cmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVwbGFjZVN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBTbGljZS5mcm9tSlNPTihzY2hlbWEsIGpzb24uc2xpY2UpLCAhIWpzb24uc3RydWN0dXJlKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcInJlcGxhY2VcIiwgUmVwbGFjZVN0ZXApO1xuLyoqXG5SZXBsYWNlIGEgcGFydCBvZiB0aGUgZG9jdW1lbnQgd2l0aCBhIHNsaWNlIG9mIGNvbnRlbnQsIGJ1dFxucHJlc2VydmUgYSByYW5nZSBvZiB0aGUgcmVwbGFjZWQgY29udGVudCBieSBtb3ZpbmcgaXQgaW50byB0aGVcbnNsaWNlLlxuKi9cbmNsYXNzIFJlcGxhY2VBcm91bmRTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmVwbGFjZS1hcm91bmQgc3RlcCB3aXRoIHRoZSBnaXZlbiByYW5nZSBhbmQgZ2FwLlxuICAgIGBpbnNlcnRgIHNob3VsZCBiZSB0aGUgcG9pbnQgaW4gdGhlIHNsaWNlIGludG8gd2hpY2ggdGhlIGNvbnRlbnRcbiAgICBvZiB0aGUgZ2FwIHNob3VsZCBiZSBtb3ZlZC4gYHN0cnVjdHVyZWAgaGFzIHRoZSBzYW1lIG1lYW5pbmcgYXNcbiAgICBpdCBoYXMgaW4gdGhlIFtgUmVwbGFjZVN0ZXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlJlcGxhY2VTdGVwKSBjbGFzcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgcHJlc2VydmVkIHJhbmdlLlxuICAgICovXG4gICAgZ2FwRnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiBwcmVzZXJ2ZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBnYXBUbywgXG4gICAgLyoqXG4gICAgVGhlIHNsaWNlIHRvIGluc2VydC5cbiAgICAqL1xuICAgIHNsaWNlLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gaW4gdGhlIHNsaWNlIHdoZXJlIHRoZSBwcmVzZXJ2ZWQgcmFuZ2Ugc2hvdWxkIGJlXG4gICAgaW5zZXJ0ZWQuXG4gICAgKi9cbiAgICBpbnNlcnQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RydWN0dXJlID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmdhcEZyb20gPSBnYXBGcm9tO1xuICAgICAgICB0aGlzLmdhcFRvID0gZ2FwVG87XG4gICAgICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgICAgICAgdGhpcy5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgICAgIHRoaXMuc3RydWN0dXJlID0gc3RydWN0dXJlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlICYmIChjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZnJvbSwgdGhpcy5nYXBGcm9tKSB8fFxuICAgICAgICAgICAgY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmdhcFRvLCB0aGlzLnRvKSkpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiU3RydWN0dXJlIGdhcC1yZXBsYWNlIHdvdWxkIG92ZXJ3cml0ZSBjb250ZW50XCIpO1xuICAgICAgICBsZXQgZ2FwID0gZG9jLnNsaWNlKHRoaXMuZ2FwRnJvbSwgdGhpcy5nYXBUbyk7XG4gICAgICAgIGlmIChnYXAub3BlblN0YXJ0IHx8IGdhcC5vcGVuRW5kKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIkdhcCBpcyBub3QgYSBmbGF0IHJhbmdlXCIpO1xuICAgICAgICBsZXQgaW5zZXJ0ZWQgPSB0aGlzLnNsaWNlLmluc2VydEF0KHRoaXMuaW5zZXJ0LCBnYXAuY29udGVudCk7XG4gICAgICAgIGlmICghaW5zZXJ0ZWQpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiQ29udGVudCBkb2VzIG5vdCBmaXQgaW4gZ2FwXCIpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcChbdGhpcy5mcm9tLCB0aGlzLmdhcEZyb20gLSB0aGlzLmZyb20sIHRoaXMuaW5zZXJ0LFxuICAgICAgICAgICAgdGhpcy5nYXBUbywgdGhpcy50byAtIHRoaXMuZ2FwVG8sIHRoaXMuc2xpY2Uuc2l6ZSAtIHRoaXMuaW5zZXJ0XSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IGdhcCA9IHRoaXMuZ2FwVG8gLSB0aGlzLmdhcEZyb207XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAodGhpcy5mcm9tLCB0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUgKyBnYXAsIHRoaXMuZnJvbSArIHRoaXMuaW5zZXJ0LCB0aGlzLmZyb20gKyB0aGlzLmluc2VydCArIGdhcCwgZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50bykucmVtb3ZlQmV0d2Vlbih0aGlzLmdhcEZyb20gLSB0aGlzLmZyb20sIHRoaXMuZ2FwVG8gLSB0aGlzLmZyb20pLCB0aGlzLmdhcEZyb20gLSB0aGlzLmZyb20sIHRoaXMuc3RydWN0dXJlKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgICAgbGV0IGdhcEZyb20gPSBtYXBwaW5nLm1hcCh0aGlzLmdhcEZyb20sIC0xKSwgZ2FwVG8gPSBtYXBwaW5nLm1hcCh0aGlzLmdhcFRvLCAxKTtcbiAgICAgICAgaWYgKChmcm9tLmRlbGV0ZWRBY3Jvc3MgJiYgdG8uZGVsZXRlZEFjcm9zcykgfHwgZ2FwRnJvbSA8IGZyb20ucG9zIHx8IGdhcFRvID4gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoZnJvbS5wb3MsIHRvLnBvcywgZ2FwRnJvbSwgZ2FwVG8sIHRoaXMuc2xpY2UsIHRoaXMuaW5zZXJ0LCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGpzb24gPSB7IHN0ZXBUeXBlOiBcInJlcGxhY2VBcm91bmRcIiwgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byxcbiAgICAgICAgICAgIGdhcEZyb206IHRoaXMuZ2FwRnJvbSwgZ2FwVG86IHRoaXMuZ2FwVG8sIGluc2VydDogdGhpcy5pbnNlcnQgfTtcbiAgICAgICAgaWYgKHRoaXMuc2xpY2Uuc2l6ZSlcbiAgICAgICAgICAgIGpzb24uc2xpY2UgPSB0aGlzLnNsaWNlLnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUpXG4gICAgICAgICAgICBqc29uLnN0cnVjdHVyZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiIHx8XG4gICAgICAgICAgICB0eXBlb2YganNvbi5nYXBGcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uZ2FwVG8gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5pbnNlcnQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVwbGFjZUFyb3VuZFN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBqc29uLmdhcEZyb20sIGpzb24uZ2FwVG8sIFNsaWNlLmZyb21KU09OKHNjaGVtYSwganNvbi5zbGljZSksIGpzb24uaW5zZXJ0LCAhIWpzb24uc3RydWN0dXJlKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcInJlcGxhY2VBcm91bmRcIiwgUmVwbGFjZUFyb3VuZFN0ZXApO1xuZnVuY3Rpb24gY29udGVudEJldHdlZW4oZG9jLCBmcm9tLCB0bykge1xuICAgIGxldCAkZnJvbSA9IGRvYy5yZXNvbHZlKGZyb20pLCBkaXN0ID0gdG8gLSBmcm9tLCBkZXB0aCA9ICRmcm9tLmRlcHRoO1xuICAgIHdoaWxlIChkaXN0ID4gMCAmJiBkZXB0aCA+IDAgJiYgJGZyb20uaW5kZXhBZnRlcihkZXB0aCkgPT0gJGZyb20ubm9kZShkZXB0aCkuY2hpbGRDb3VudCkge1xuICAgICAgICBkZXB0aC0tO1xuICAgICAgICBkaXN0LS07XG4gICAgfVxuICAgIGlmIChkaXN0ID4gMCkge1xuICAgICAgICBsZXQgbmV4dCA9ICRmcm9tLm5vZGUoZGVwdGgpLm1heWJlQ2hpbGQoJGZyb20uaW5kZXhBZnRlcihkZXB0aCkpO1xuICAgICAgICB3aGlsZSAoZGlzdCA+IDApIHtcbiAgICAgICAgICAgIGlmICghbmV4dCB8fCBuZXh0LmlzTGVhZilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBkaXN0LS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRNYXJrKHRyLCBmcm9tLCB0bywgbWFyaykge1xuICAgIGxldCByZW1vdmVkID0gW10sIGFkZGVkID0gW107XG4gICAgbGV0IHJlbW92aW5nLCBhZGRpbmc7XG4gICAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcywgcGFyZW50KSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5pc0lubGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1hcmtzID0gbm9kZS5tYXJrcztcbiAgICAgICAgaWYgKCFtYXJrLmlzSW5TZXQobWFya3MpICYmIHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG1hcmsudHlwZSkpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHBvcywgZnJvbSksIGVuZCA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgIGxldCBuZXdTZXQgPSBtYXJrLmFkZFRvU2V0KG1hcmtzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hcmtzW2ldLmlzSW5TZXQobmV3U2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZpbmcgJiYgcmVtb3ZpbmcudG8gPT0gc3RhcnQgJiYgcmVtb3ZpbmcubWFyay5lcShtYXJrc1tpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmluZy50byA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKHJlbW92aW5nID0gbmV3IFJlbW92ZU1hcmtTdGVwKHN0YXJ0LCBlbmQsIG1hcmtzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkZGluZyAmJiBhZGRpbmcudG8gPT0gc3RhcnQpXG4gICAgICAgICAgICAgICAgYWRkaW5nLnRvID0gZW5kO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFkZGVkLnB1c2goYWRkaW5nID0gbmV3IEFkZE1hcmtTdGVwKHN0YXJ0LCBlbmQsIG1hcmspKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJlbW92ZWQuZm9yRWFjaChzID0+IHRyLnN0ZXAocykpO1xuICAgIGFkZGVkLmZvckVhY2gocyA9PiB0ci5zdGVwKHMpKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU1hcmsodHIsIGZyb20sIHRvLCBtYXJrKSB7XG4gICAgbGV0IG1hdGNoZWQgPSBbXSwgc3RlcCA9IDA7XG4gICAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAoIW5vZGUuaXNJbmxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN0ZXArKztcbiAgICAgICAgbGV0IHRvUmVtb3ZlID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcmsgaW5zdGFuY2VvZiBNYXJrVHlwZSkge1xuICAgICAgICAgICAgbGV0IHNldCA9IG5vZGUubWFya3MsIGZvdW5kO1xuICAgICAgICAgICAgd2hpbGUgKGZvdW5kID0gbWFyay5pc0luU2V0KHNldCkpIHtcbiAgICAgICAgICAgICAgICAodG9SZW1vdmUgfHwgKHRvUmVtb3ZlID0gW10pKS5wdXNoKGZvdW5kKTtcbiAgICAgICAgICAgICAgICBzZXQgPSBmb3VuZC5yZW1vdmVGcm9tU2V0KHNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFyaykge1xuICAgICAgICAgICAgaWYgKG1hcmsuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgICAgICB0b1JlbW92ZSA9IFttYXJrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvUmVtb3ZlID0gbm9kZS5tYXJrcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9SZW1vdmUgJiYgdG9SZW1vdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IHRvUmVtb3ZlW2ldLCBmb3VuZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdGNoZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBtYXRjaGVkW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobS5zdGVwID09IHN0ZXAgLSAxICYmIHN0eWxlLmVxKG1hdGNoZWRbal0uc3R5bGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQudG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnN0ZXAgPSBzdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKHsgc3R5bGUsIGZyb206IE1hdGgubWF4KHBvcywgZnJvbSksIHRvOiBlbmQsIHN0ZXAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgbWF0Y2hlZC5mb3JFYWNoKG0gPT4gdHIuc3RlcChuZXcgUmVtb3ZlTWFya1N0ZXAobS5mcm9tLCBtLnRvLCBtLnN0eWxlKSkpO1xufVxuZnVuY3Rpb24gY2xlYXJJbmNvbXBhdGlibGUodHIsIHBvcywgcGFyZW50VHlwZSwgbWF0Y2ggPSBwYXJlbnRUeXBlLmNvbnRlbnRNYXRjaCkge1xuICAgIGxldCBub2RlID0gdHIuZG9jLm5vZGVBdChwb3MpO1xuICAgIGxldCByZXBsU3RlcHMgPSBbXSwgY3VyID0gcG9zICsgMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IG5vZGUuY2hpbGQoaSksIGVuZCA9IGN1ciArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBsZXQgYWxsb3dlZCA9IG1hdGNoLm1hdGNoVHlwZShjaGlsZC50eXBlKTtcbiAgICAgICAgaWYgKCFhbGxvd2VkKSB7XG4gICAgICAgICAgICByZXBsU3RlcHMucHVzaChuZXcgUmVwbGFjZVN0ZXAoY3VyLCBlbmQsIFNsaWNlLmVtcHR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IGFsbG93ZWQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkLm1hcmtzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50VHlwZS5hbGxvd3NNYXJrVHlwZShjaGlsZC5tYXJrc1tqXS50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgdHIuc3RlcChuZXcgUmVtb3ZlTWFya1N0ZXAoY3VyLCBlbmQsIGNoaWxkLm1hcmtzW2pdKSk7XG4gICAgICAgICAgICBpZiAoY2hpbGQuaXNUZXh0ICYmICFwYXJlbnRUeXBlLnNwZWMuY29kZSkge1xuICAgICAgICAgICAgICAgIGxldCBtLCBuZXdsaW5lID0gL1xccj9cXG58XFxyL2csIHNsaWNlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChtID0gbmV3bGluZS5leGVjKGNoaWxkLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2xpY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBzbGljZSA9IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHBhcmVudFR5cGUuc2NoZW1hLnRleHQoXCIgXCIsIHBhcmVudFR5cGUuYWxsb3dlZE1hcmtzKGNoaWxkLm1hcmtzKSkpLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVwbFN0ZXBzLnB1c2gobmV3IFJlcGxhY2VTdGVwKGN1ciArIG0uaW5kZXgsIGN1ciArIG0uaW5kZXggKyBtWzBdLmxlbmd0aCwgc2xpY2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VyID0gZW5kO1xuICAgIH1cbiAgICBpZiAoIW1hdGNoLnZhbGlkRW5kKSB7XG4gICAgICAgIGxldCBmaWxsID0gbWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgICAgIHRyLnJlcGxhY2UoY3VyLCBjdXIsIG5ldyBTbGljZShmaWxsLCAwLCAwKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSByZXBsU3RlcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHRyLnN0ZXAocmVwbFN0ZXBzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2FuQ3V0KG5vZGUsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKHN0YXJ0ID09IDAgfHwgbm9kZS5jYW5SZXBsYWNlKHN0YXJ0LCBub2RlLmNoaWxkQ291bnQpKSAmJlxuICAgICAgICAoZW5kID09IG5vZGUuY2hpbGRDb3VudCB8fCBub2RlLmNhblJlcGxhY2UoMCwgZW5kKSk7XG59XG4vKipcblRyeSB0byBmaW5kIGEgdGFyZ2V0IGRlcHRoIHRvIHdoaWNoIHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZVxuY2FuIGJlIGxpZnRlZC4gV2lsbCBub3QgZ28gYWNyb3NzXG5baXNvbGF0aW5nXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuaXNvbGF0aW5nKSBwYXJlbnQgbm9kZXMuXG4qL1xuZnVuY3Rpb24gbGlmdFRhcmdldChyYW5nZSkge1xuICAgIGxldCBwYXJlbnQgPSByYW5nZS5wYXJlbnQ7XG4gICAgbGV0IGNvbnRlbnQgPSBwYXJlbnQuY29udGVudC5jdXRCeUluZGV4KHJhbmdlLnN0YXJ0SW5kZXgsIHJhbmdlLmVuZEluZGV4KTtcbiAgICBmb3IgKGxldCBkZXB0aCA9IHJhbmdlLmRlcHRoOzsgLS1kZXB0aCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJhbmdlLiRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICBsZXQgaW5kZXggPSByYW5nZS4kZnJvbS5pbmRleChkZXB0aCksIGVuZEluZGV4ID0gcmFuZ2UuJHRvLmluZGV4QWZ0ZXIoZGVwdGgpO1xuICAgICAgICBpZiAoZGVwdGggPCByYW5nZS5kZXB0aCAmJiBub2RlLmNhblJlcGxhY2UoaW5kZXgsIGVuZEluZGV4LCBjb250ZW50KSlcbiAgICAgICAgICAgIHJldHVybiBkZXB0aDtcbiAgICAgICAgaWYgKGRlcHRoID09IDAgfHwgbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8ICFjYW5DdXQobm9kZSwgaW5kZXgsIGVuZEluZGV4KSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGxpZnQodHIsIHJhbmdlLCB0YXJnZXQpIHtcbiAgICBsZXQgeyAkZnJvbSwgJHRvLCBkZXB0aCB9ID0gcmFuZ2U7XG4gICAgbGV0IGdhcFN0YXJ0ID0gJGZyb20uYmVmb3JlKGRlcHRoICsgMSksIGdhcEVuZCA9ICR0by5hZnRlcihkZXB0aCArIDEpO1xuICAgIGxldCBzdGFydCA9IGdhcFN0YXJ0LCBlbmQgPSBnYXBFbmQ7XG4gICAgbGV0IGJlZm9yZSA9IEZyYWdtZW50LmVtcHR5LCBvcGVuU3RhcnQgPSAwO1xuICAgIGZvciAobGV0IGQgPSBkZXB0aCwgc3BsaXR0aW5nID0gZmFsc2U7IGQgPiB0YXJnZXQ7IGQtLSlcbiAgICAgICAgaWYgKHNwbGl0dGluZyB8fCAkZnJvbS5pbmRleChkKSA+IDApIHtcbiAgICAgICAgICAgIHNwbGl0dGluZyA9IHRydWU7XG4gICAgICAgICAgICBiZWZvcmUgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoZCkuY29weShiZWZvcmUpKTtcbiAgICAgICAgICAgIG9wZW5TdGFydCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQtLTtcbiAgICAgICAgfVxuICAgIGxldCBhZnRlciA9IEZyYWdtZW50LmVtcHR5LCBvcGVuRW5kID0gMDtcbiAgICBmb3IgKGxldCBkID0gZGVwdGgsIHNwbGl0dGluZyA9IGZhbHNlOyBkID4gdGFyZ2V0OyBkLS0pXG4gICAgICAgIGlmIChzcGxpdHRpbmcgfHwgJHRvLmFmdGVyKGQgKyAxKSA8ICR0by5lbmQoZCkpIHtcbiAgICAgICAgICAgIHNwbGl0dGluZyA9IHRydWU7XG4gICAgICAgICAgICBhZnRlciA9IEZyYWdtZW50LmZyb20oJHRvLm5vZGUoZCkuY29weShhZnRlcikpO1xuICAgICAgICAgICAgb3BlbkVuZCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCwgZW5kLCBnYXBTdGFydCwgZ2FwRW5kLCBuZXcgU2xpY2UoYmVmb3JlLmFwcGVuZChhZnRlciksIG9wZW5TdGFydCwgb3BlbkVuZCksIGJlZm9yZS5zaXplIC0gb3BlblN0YXJ0LCB0cnVlKSk7XG59XG4vKipcblRyeSB0byBmaW5kIGEgdmFsaWQgd2F5IHRvIHdyYXAgdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlIGluIGFcbm5vZGUgb2YgdGhlIGdpdmVuIHR5cGUuIE1heSBpbnRyb2R1Y2UgZXh0cmEgbm9kZXMgYXJvdW5kIGFuZCBpbnNpZGVcbnRoZSB3cmFwcGVyIG5vZGUsIGlmIG5lY2Vzc2FyeS4gUmV0dXJucyBudWxsIGlmIG5vIHZhbGlkIHdyYXBwaW5nXG5jb3VsZCBiZSBmb3VuZC4gV2hlbiBgaW5uZXJSYW5nZWAgaXMgZ2l2ZW4sIHRoYXQgcmFuZ2UncyBjb250ZW50IGlzXG51c2VkIGFzIHRoZSBjb250ZW50IHRvIGZpdCBpbnRvIHRoZSB3cmFwcGluZywgaW5zdGVhZCBvZiB0aGVcbmNvbnRlbnQgb2YgYHJhbmdlYC5cbiovXG5mdW5jdGlvbiBmaW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycyA9IG51bGwsIGlubmVyUmFuZ2UgPSByYW5nZSkge1xuICAgIGxldCBhcm91bmQgPSBmaW5kV3JhcHBpbmdPdXRzaWRlKHJhbmdlLCBub2RlVHlwZSk7XG4gICAgbGV0IGlubmVyID0gYXJvdW5kICYmIGZpbmRXcmFwcGluZ0luc2lkZShpbm5lclJhbmdlLCBub2RlVHlwZSk7XG4gICAgaWYgKCFpbm5lcilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGFyb3VuZC5tYXAod2l0aEF0dHJzKVxuICAgICAgICAuY29uY2F0KHsgdHlwZTogbm9kZVR5cGUsIGF0dHJzIH0pLmNvbmNhdChpbm5lci5tYXAod2l0aEF0dHJzKSk7XG59XG5mdW5jdGlvbiB3aXRoQXR0cnModHlwZSkgeyByZXR1cm4geyB0eXBlLCBhdHRyczogbnVsbCB9OyB9XG5mdW5jdGlvbiBmaW5kV3JhcHBpbmdPdXRzaWRlKHJhbmdlLCB0eXBlKSB7XG4gICAgbGV0IHsgcGFyZW50LCBzdGFydEluZGV4LCBlbmRJbmRleCB9ID0gcmFuZ2U7XG4gICAgbGV0IGFyb3VuZCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChzdGFydEluZGV4KS5maW5kV3JhcHBpbmcodHlwZSk7XG4gICAgaWYgKCFhcm91bmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBvdXRlciA9IGFyb3VuZC5sZW5ndGggPyBhcm91bmRbMF0gOiB0eXBlO1xuICAgIHJldHVybiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoc3RhcnRJbmRleCwgZW5kSW5kZXgsIG91dGVyKSA/IGFyb3VuZCA6IG51bGw7XG59XG5mdW5jdGlvbiBmaW5kV3JhcHBpbmdJbnNpZGUocmFuZ2UsIHR5cGUpIHtcbiAgICBsZXQgeyBwYXJlbnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSByYW5nZTtcbiAgICBsZXQgaW5uZXIgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCk7XG4gICAgbGV0IGluc2lkZSA9IHR5cGUuY29udGVudE1hdGNoLmZpbmRXcmFwcGluZyhpbm5lci50eXBlKTtcbiAgICBpZiAoIWluc2lkZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGxhc3RUeXBlID0gaW5zaWRlLmxlbmd0aCA/IGluc2lkZVtpbnNpZGUubGVuZ3RoIC0gMV0gOiB0eXBlO1xuICAgIGxldCBpbm5lck1hdGNoID0gbGFzdFR5cGUuY29udGVudE1hdGNoO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpbm5lck1hdGNoICYmIGkgPCBlbmRJbmRleDsgaSsrKVxuICAgICAgICBpbm5lck1hdGNoID0gaW5uZXJNYXRjaC5tYXRjaFR5cGUocGFyZW50LmNoaWxkKGkpLnR5cGUpO1xuICAgIGlmICghaW5uZXJNYXRjaCB8fCAhaW5uZXJNYXRjaC52YWxpZEVuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGluc2lkZTtcbn1cbmZ1bmN0aW9uIHdyYXAodHIsIHJhbmdlLCB3cmFwcGVycykge1xuICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yIChsZXQgaSA9IHdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChjb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHdyYXBwZXJzW2ldLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoIHx8ICFtYXRjaC52YWxpZEVuZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIldyYXBwZXIgdHlwZSBnaXZlbiB0byBUcmFuc2Zvcm0ud3JhcCBkb2VzIG5vdCBmb3JtIHZhbGlkIGNvbnRlbnQgb2YgaXRzIHBhcmVudCB3cmFwcGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHdyYXBwZXJzW2ldLnR5cGUuY3JlYXRlKHdyYXBwZXJzW2ldLmF0dHJzLCBjb250ZW50KSk7XG4gICAgfVxuICAgIGxldCBzdGFydCA9IHJhbmdlLnN0YXJ0LCBlbmQgPSByYW5nZS5lbmQ7XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQsIGVuZCwgc3RhcnQsIGVuZCwgbmV3IFNsaWNlKGNvbnRlbnQsIDAsIDApLCB3cmFwcGVycy5sZW5ndGgsIHRydWUpKTtcbn1cbmZ1bmN0aW9uIHNldEJsb2NrVHlwZSh0ciwgZnJvbSwgdG8sIHR5cGUsIGF0dHJzKSB7XG4gICAgaWYgKCF0eXBlLmlzVGV4dGJsb2NrKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlR5cGUgZ2l2ZW4gdG8gc2V0QmxvY2tUeXBlIHNob3VsZCBiZSBhIHRleHRibG9ja1wiKTtcbiAgICBsZXQgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aDtcbiAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmIChub2RlLmlzVGV4dGJsb2NrICYmICFub2RlLmhhc01hcmt1cCh0eXBlLCBhdHRycykgJiYgY2FuQ2hhbmdlVHlwZSh0ci5kb2MsIHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyksIHR5cGUpKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgYWxsIG1hcmt1cCB0aGF0IGlzbid0IGFsbG93ZWQgaW4gdGhlIG5ldyBub2RlIHR5cGUgaXMgY2xlYXJlZFxuICAgICAgICAgICAgdHIuY2xlYXJJbmNvbXBhdGlibGUodHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zLCAxKSwgdHlwZSk7XG4gICAgICAgICAgICBsZXQgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgICAgICBsZXQgc3RhcnRNID0gbWFwcGluZy5tYXAocG9zLCAxKSwgZW5kTSA9IG1hcHBpbmcubWFwKHBvcyArIG5vZGUubm9kZVNpemUsIDEpO1xuICAgICAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnRNLCBlbmRNLCBzdGFydE0gKyAxLCBlbmRNIC0gMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXR0cnMsIG51bGwsIG5vZGUubWFya3MpKSwgMCwgMCksIDEsIHRydWUpKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY2FuQ2hhbmdlVHlwZShkb2MsIHBvcywgdHlwZSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgcmV0dXJuICRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIHR5cGUpO1xufVxuLyoqXG5DaGFuZ2UgdGhlIHR5cGUsIGF0dHJpYnV0ZXMsIGFuZC9vciBtYXJrcyBvZiB0aGUgbm9kZSBhdCBgcG9zYC5cbldoZW4gYHR5cGVgIGlzbid0IGdpdmVuLCB0aGUgZXhpc3Rpbmcgbm9kZSB0eXBlIGlzIHByZXNlcnZlZCxcbiovXG5mdW5jdGlvbiBzZXROb2RlTWFya3VwKHRyLCBwb3MsIHR5cGUsIGF0dHJzLCBtYXJrcykge1xuICAgIGxldCBub2RlID0gdHIuZG9jLm5vZGVBdChwb3MpO1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXCIpO1xuICAgIGlmICghdHlwZSlcbiAgICAgICAgdHlwZSA9IG5vZGUudHlwZTtcbiAgICBsZXQgbmV3Tm9kZSA9IHR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBtYXJrcyB8fCBub2RlLm1hcmtzKTtcbiAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgIHJldHVybiB0ci5yZXBsYWNlV2l0aChwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIG5ld05vZGUpO1xuICAgIGlmICghdHlwZS52YWxpZENvbnRlbnQobm9kZS5jb250ZW50KSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNvbnRlbnQgZm9yIG5vZGUgdHlwZSBcIiArIHR5cGUubmFtZSk7XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBwb3MgKyAxLCBwb3MgKyBub2RlLm5vZGVTaXplIC0gMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obmV3Tm9kZSksIDAsIDApLCAxLCB0cnVlKSk7XG59XG4vKipcbkNoZWNrIHdoZXRoZXIgc3BsaXR0aW5nIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBpcyBhbGxvd2VkLlxuKi9cbmZ1bmN0aW9uIGNhblNwbGl0KGRvYywgcG9zLCBkZXB0aCA9IDEsIHR5cGVzQWZ0ZXIpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGJhc2UgPSAkcG9zLmRlcHRoIC0gZGVwdGg7XG4gICAgbGV0IGlubmVyVHlwZSA9ICh0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbdHlwZXNBZnRlci5sZW5ndGggLSAxXSkgfHwgJHBvcy5wYXJlbnQ7XG4gICAgaWYgKGJhc2UgPCAwIHx8ICRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcgfHxcbiAgICAgICAgISRwb3MucGFyZW50LmNhblJlcGxhY2UoJHBvcy5pbmRleCgpLCAkcG9zLnBhcmVudC5jaGlsZENvdW50KSB8fFxuICAgICAgICAhaW5uZXJUeXBlLnR5cGUudmFsaWRDb250ZW50KCRwb3MucGFyZW50LmNvbnRlbnQuY3V0QnlJbmRleCgkcG9zLmluZGV4KCksICRwb3MucGFyZW50LmNoaWxkQ291bnQpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMSwgaSA9IGRlcHRoIC0gMjsgZCA+IGJhc2U7IGQtLSwgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gJHBvcy5ub2RlKGQpLCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgIGlmIChub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCByZXN0ID0gbm9kZS5jb250ZW50LmN1dEJ5SW5kZXgoaW5kZXgsIG5vZGUuY2hpbGRDb3VudCk7XG4gICAgICAgIGxldCBvdmVycmlkZUNoaWxkID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2kgKyAxXTtcbiAgICAgICAgaWYgKG92ZXJyaWRlQ2hpbGQpXG4gICAgICAgICAgICByZXN0ID0gcmVzdC5yZXBsYWNlQ2hpbGQoMCwgb3ZlcnJpZGVDaGlsZC50eXBlLmNyZWF0ZShvdmVycmlkZUNoaWxkLmF0dHJzKSk7XG4gICAgICAgIGxldCBhZnRlciA9ICh0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaV0pIHx8IG5vZGU7XG4gICAgICAgIGlmICghbm9kZS5jYW5SZXBsYWNlKGluZGV4ICsgMSwgbm9kZS5jaGlsZENvdW50KSB8fCAhYWZ0ZXIudHlwZS52YWxpZENvbnRlbnQocmVzdCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXhBZnRlcihiYXNlKTtcbiAgICBsZXQgYmFzZVR5cGUgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbMF07XG4gICAgcmV0dXJuICRwb3Mubm9kZShiYXNlKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIGJhc2VUeXBlID8gYmFzZVR5cGUudHlwZSA6ICRwb3Mubm9kZShiYXNlICsgMSkudHlwZSk7XG59XG5mdW5jdGlvbiBzcGxpdCh0ciwgcG9zLCBkZXB0aCA9IDEsIHR5cGVzQWZ0ZXIpIHtcbiAgICBsZXQgJHBvcyA9IHRyLmRvYy5yZXNvbHZlKHBvcyksIGJlZm9yZSA9IEZyYWdtZW50LmVtcHR5LCBhZnRlciA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoLCBlID0gJHBvcy5kZXB0aCAtIGRlcHRoLCBpID0gZGVwdGggLSAxOyBkID4gZTsgZC0tLCBpLS0pIHtcbiAgICAgICAgYmVmb3JlID0gRnJhZ21lbnQuZnJvbSgkcG9zLm5vZGUoZCkuY29weShiZWZvcmUpKTtcbiAgICAgICAgbGV0IHR5cGVBZnRlciA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpXTtcbiAgICAgICAgYWZ0ZXIgPSBGcmFnbWVudC5mcm9tKHR5cGVBZnRlciA/IHR5cGVBZnRlci50eXBlLmNyZWF0ZSh0eXBlQWZ0ZXIuYXR0cnMsIGFmdGVyKSA6ICRwb3Mubm9kZShkKS5jb3B5KGFmdGVyKSk7XG4gICAgfVxuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VTdGVwKHBvcywgcG9zLCBuZXcgU2xpY2UoYmVmb3JlLmFwcGVuZChhZnRlciksIGRlcHRoLCBkZXB0aCksIHRydWUpKTtcbn1cbi8qKlxuVGVzdCB3aGV0aGVyIHRoZSBibG9ja3MgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIHBvc2l0aW9uIGNhbiBiZVxuam9pbmVkLlxuKi9cbmZ1bmN0aW9uIGNhbkpvaW4oZG9jLCBwb3MpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgIHJldHVybiBqb2luYWJsZSgkcG9zLm5vZGVCZWZvcmUsICRwb3Mubm9kZUFmdGVyKSAmJlxuICAgICAgICAkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpO1xufVxuZnVuY3Rpb24gam9pbmFibGUoYSwgYikge1xuICAgIHJldHVybiAhIShhICYmIGIgJiYgIWEuaXNMZWFmICYmIGEuY2FuQXBwZW5kKGIpKTtcbn1cbi8qKlxuRmluZCBhbiBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gcG9zaXRpb24gdGhhdCBjYW4gYmUgam9pbmVkIHRvIHRoZVxuYmxvY2sgYmVmb3JlIChvciBhZnRlciBpZiBgZGlyYCBpcyBwb3NpdGl2ZSkuIFJldHVybnMgdGhlIGpvaW5hYmxlXG5wb2ludCwgaWYgYW55LlxuKi9cbmZ1bmN0aW9uIGpvaW5Qb2ludChkb2MsIHBvcywgZGlyID0gLTEpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7OyBkLS0pIHtcbiAgICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXIsIGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICAgICAgaWYgKGQgPT0gJHBvcy5kZXB0aCkge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlO1xuICAgICAgICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBiZWZvcmUgPSAkcG9zLm5vZGUoZCArIDEpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlKGQpLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlKGQpLm1heWJlQ2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlKGQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVmb3JlICYmICFiZWZvcmUuaXNUZXh0YmxvY2sgJiYgam9pbmFibGUoYmVmb3JlLCBhZnRlcikgJiZcbiAgICAgICAgICAgICRwb3Mubm9kZShkKS5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgaWYgKGQgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBwb3MgPSBkaXIgPCAwID8gJHBvcy5iZWZvcmUoZCkgOiAkcG9zLmFmdGVyKGQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGpvaW4odHIsIHBvcywgZGVwdGgpIHtcbiAgICBsZXQgc3RlcCA9IG5ldyBSZXBsYWNlU3RlcChwb3MgLSBkZXB0aCwgcG9zICsgZGVwdGgsIFNsaWNlLmVtcHR5LCB0cnVlKTtcbiAgICB0ci5zdGVwKHN0ZXApO1xufVxuLyoqXG5UcnkgdG8gZmluZCBhIHBvaW50IHdoZXJlIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSBjYW4gYmUgaW5zZXJ0ZWRcbm5lYXIgYHBvc2AsIGJ5IHNlYXJjaGluZyB1cCB0aGUgbm9kZSBoaWVyYXJjaHkgd2hlbiBgcG9zYCBpdHNlbGZcbmlzbid0IGEgdmFsaWQgcGxhY2UgYnV0IGlzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBub2RlLiBSZXR1cm5cbm51bGwgaWYgbm8gcG9zaXRpb24gd2FzIGZvdW5kLlxuKi9cbmZ1bmN0aW9uIGluc2VydFBvaW50KGRvYywgcG9zLCBub2RlVHlwZSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoJHBvcy5pbmRleCgpLCAkcG9zLmluZGV4KCksIG5vZGVUeXBlKSlcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBpZiAoJHBvcy5wYXJlbnRPZmZzZXQgPT0gMClcbiAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICAgICAgICAgIGlmICgkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBub2RlVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuYmVmb3JlKGQgKyAxKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICBpZiAoJHBvcy5wYXJlbnRPZmZzZXQgPT0gJHBvcy5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoZCk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGQpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgbm9kZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmFmdGVyKGQgKyAxKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA8ICRwb3Mubm9kZShkKS5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbkZpbmRzIGEgcG9zaXRpb24gYXQgb3IgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbiB3aGVyZSB0aGUgZ2l2ZW5cbnNsaWNlIGNhbiBiZSBpbnNlcnRlZC4gV2lsbCBsb29rIGF0IHBhcmVudCBub2RlcycgbmVhcmVzdCBib3VuZGFyeVxuYW5kIHRyeSB0aGVyZSwgZXZlbiBpZiB0aGUgb3JpZ2luYWwgcG9zaXRpb24gd2Fzbid0IGRpcmVjdGx5IGF0IHRoZVxuc3RhcnQgb3IgZW5kIG9mIHRoYXQgbm9kZS4gUmV0dXJucyBudWxsIHdoZW4gbm8gcG9zaXRpb24gd2FzIGZvdW5kLlxuKi9cbmZ1bmN0aW9uIGRyb3BQb2ludChkb2MsIHBvcywgc2xpY2UpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCFzbGljZS5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgbGV0IGNvbnRlbnQgPSBzbGljZS5jb250ZW50O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpY2Uub3BlblN0YXJ0OyBpKyspXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICBmb3IgKGxldCBwYXNzID0gMTsgcGFzcyA8PSAoc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uuc2l6ZSA/IDIgOiAxKTsgcGFzcysrKSB7XG4gICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgbGV0IGJpYXMgPSBkID09ICRwb3MuZGVwdGggPyAwIDogJHBvcy5wb3MgPD0gKCRwb3Muc3RhcnQoZCArIDEpICsgJHBvcy5lbmQoZCArIDEpKSAvIDIgPyAtMSA6IDE7XG4gICAgICAgICAgICBsZXQgaW5zZXJ0UG9zID0gJHBvcy5pbmRleChkKSArIChiaWFzID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLm5vZGUoZCksIGZpdHMgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChwYXNzID09IDEpIHtcbiAgICAgICAgICAgICAgICBmaXRzID0gcGFyZW50LmNhblJlcGxhY2UoaW5zZXJ0UG9zLCBpbnNlcnRQb3MsIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXBwaW5nID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KGluc2VydFBvcykuZmluZFdyYXBwaW5nKGNvbnRlbnQuZmlyc3RDaGlsZC50eXBlKTtcbiAgICAgICAgICAgICAgICBmaXRzID0gd3JhcHBpbmcgJiYgcGFyZW50LmNhblJlcGxhY2VXaXRoKGluc2VydFBvcywgaW5zZXJ0UG9zLCB3cmFwcGluZ1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZml0cylcbiAgICAgICAgICAgICAgICByZXR1cm4gYmlhcyA9PSAwID8gJHBvcy5wb3MgOiBiaWFzIDwgMCA/ICRwb3MuYmVmb3JlKGQgKyAxKSA6ICRwb3MuYWZ0ZXIoZCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcblx1MjAxOEZpdFx1MjAxOSBhIHNsaWNlIGludG8gYSBnaXZlbiBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQsIHByb2R1Y2luZyBhXG5bc3RlcF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwKSB0aGF0IGluc2VydHMgaXQuIFdpbGwgcmV0dXJuIG51bGwgaWZcbnRoZXJlJ3Mgbm8gbWVhbmluZ2Z1bCB3YXkgdG8gaW5zZXJ0IHRoZSBzbGljZSBoZXJlLCBvciBpbnNlcnRpbmcgaXRcbndvdWxkIGJlIGEgbm8tb3AgKGFuIGVtcHR5IHNsaWNlIG92ZXIgYW4gZW1wdHkgcmFuZ2UpLlxuKi9cbmZ1bmN0aW9uIHJlcGxhY2VTdGVwKGRvYywgZnJvbSwgdG8gPSBmcm9tLCBzbGljZSA9IFNsaWNlLmVtcHR5KSB7XG4gICAgaWYgKGZyb20gPT0gdG8gJiYgIXNsaWNlLnNpemUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCAkZnJvbSA9IGRvYy5yZXNvbHZlKGZyb20pLCAkdG8gPSBkb2MucmVzb2x2ZSh0byk7XG4gICAgLy8gT3B0aW1pemF0aW9uIC0tIGF2b2lkIHdvcmsgaWYgaXQncyBvYnZpb3VzIHRoYXQgaXQncyBub3QgbmVlZGVkLlxuICAgIGlmIChmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSlcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChmcm9tLCB0bywgc2xpY2UpO1xuICAgIHJldHVybiBuZXcgRml0dGVyKCRmcm9tLCAkdG8sIHNsaWNlKS5maXQoKTtcbn1cbmZ1bmN0aW9uIGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpIHtcbiAgICByZXR1cm4gIXNsaWNlLm9wZW5TdGFydCAmJiAhc2xpY2Uub3BlbkVuZCAmJiAkZnJvbS5zdGFydCgpID09ICR0by5zdGFydCgpICYmXG4gICAgICAgICRmcm9tLnBhcmVudC5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KCksICR0by5pbmRleCgpLCBzbGljZS5jb250ZW50KTtcbn1cbi8vIEFsZ29yaXRobSBmb3IgJ3BsYWNpbmcnIHRoZSBlbGVtZW50cyBvZiBhIHNsaWNlIGludG8gYSBnYXA6XG4vL1xuLy8gV2UgY29uc2lkZXIgdGhlIGNvbnRlbnQgb2YgZWFjaCBub2RlIHRoYXQgaXMgb3BlbiB0byB0aGUgbGVmdCB0byBiZVxuLy8gaW5kZXBlbmRlbnRseSBwbGFjZWFibGUuIEkuZS4gaW4gPHAoXCJmb29cIiksIHAoXCJiYXJcIik+LCB3aGVuIHRoZVxuLy8gcGFyYWdyYXBoIG9uIHRoZSBsZWZ0IGlzIG9wZW4sIFwiZm9vXCIgY2FuIGJlIHBsYWNlZCAoc29tZXdoZXJlIG9uXG4vLyB0aGUgbGVmdCBzaWRlIG9mIHRoZSByZXBsYWNlbWVudCBnYXApIGluZGVwZW5kZW50bHkgZnJvbSBwKFwiYmFyXCIpLlxuLy9cbi8vIFRoaXMgY2xhc3MgdHJhY2tzIHRoZSBzdGF0ZSBvZiB0aGUgcGxhY2VtZW50IHByb2dyZXNzIGluIHRoZVxuLy8gZm9sbG93aW5nIHByb3BlcnRpZXM6XG4vL1xuLy8gIC0gYGZyb250aWVyYCBob2xkcyBhIHN0YWNrIG9mIGB7dHlwZSwgbWF0Y2h9YCBvYmplY3RzIHRoYXRcbi8vICAgIHJlcHJlc2VudCB0aGUgb3BlbiBzaWRlIG9mIHRoZSByZXBsYWNlbWVudC4gSXQgc3RhcnRzIGF0XG4vLyAgICBgJGZyb21gLCB0aGVuIG1vdmVzIGZvcndhcmQgYXMgY29udGVudCBpcyBwbGFjZWQsIGFuZCBpcyBmaW5hbGx5XG4vLyAgICByZWNvbmNpbGVkIHdpdGggYCR0b2AuXG4vL1xuLy8gIC0gYHVucGxhY2VkYCBpcyBhIHNsaWNlIHRoYXQgcmVwcmVzZW50cyB0aGUgY29udGVudCB0aGF0IGhhc24ndFxuLy8gICAgYmVlbiBwbGFjZWQgeWV0LlxuLy9cbi8vICAtIGBwbGFjZWRgIGlzIGEgZnJhZ21lbnQgb2YgcGxhY2VkIGNvbnRlbnQuIEl0cyBvcGVuLXN0YXJ0IHZhbHVlXG4vLyAgICBpcyBpbXBsaWNpdCBpbiBgJGZyb21gLCBhbmQgaXRzIG9wZW4tZW5kIHZhbHVlIGluIGBmcm9udGllcmAuXG5jbGFzcyBGaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCRmcm9tLCAkdG8sIHVucGxhY2VkKSB7XG4gICAgICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICAgICAgdGhpcy4kdG8gPSAkdG87XG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSB1bnBsYWNlZDtcbiAgICAgICAgdGhpcy5mcm9udGllciA9IFtdO1xuICAgICAgICB0aGlzLnBsYWNlZCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAkZnJvbS5kZXB0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9ICRmcm9tLm5vZGUoaSk7XG4gICAgICAgICAgICB0aGlzLmZyb250aWVyLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgICAgICAgICBtYXRjaDogbm9kZS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKGkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9ICRmcm9tLmRlcHRoOyBpID4gMDsgaS0tKVxuICAgICAgICAgICAgdGhpcy5wbGFjZWQgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoaSkuY29weSh0aGlzLnBsYWNlZCkpO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7IHJldHVybiB0aGlzLmZyb250aWVyLmxlbmd0aCAtIDE7IH1cbiAgICBmaXQoKSB7XG4gICAgICAgIC8vIEFzIGxvbmcgYXMgdGhlcmUncyB1bnBsYWNlZCBjb250ZW50LCB0cnkgdG8gcGxhY2Ugc29tZSBvZiBpdC5cbiAgICAgICAgLy8gSWYgdGhhdCBmYWlscywgZWl0aGVyIGluY3JlYXNlIHRoZSBvcGVuIHNjb3JlIG9mIHRoZSB1bnBsYWNlZFxuICAgICAgICAvLyBzbGljZSwgb3IgZHJvcCBub2RlcyBmcm9tIGl0LCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgICAgIHdoaWxlICh0aGlzLnVucGxhY2VkLnNpemUpIHtcbiAgICAgICAgICAgIGxldCBmaXQgPSB0aGlzLmZpbmRGaXR0YWJsZSgpO1xuICAgICAgICAgICAgaWYgKGZpdClcbiAgICAgICAgICAgICAgICB0aGlzLnBsYWNlTm9kZXMoZml0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5Nb3JlKCkgfHwgdGhpcy5kcm9wTm9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlcmUncyBpbmxpbmUgY29udGVudCBkaXJlY3RseSBhZnRlciB0aGUgZnJvbnRpZXIgX2FuZF9cbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgYHRoaXMuJHRvYCwgd2UgbXVzdCBnZW5lcmF0ZSBhIGBSZXBsYWNlQXJvdW5kYFxuICAgICAgICAvLyBzdGVwIHRoYXQgcHVsbHMgdGhhdCBjb250ZW50IGludG8gdGhlIG5vZGUgYWZ0ZXIgdGhlIGZyb250aWVyLlxuICAgICAgICAvLyBUaGF0IG1lYW5zIHRoZSBmaXR0aW5nIG11c3QgYmUgZG9uZSB0byB0aGUgZW5kIG9mIHRoZSB0ZXh0YmxvY2tcbiAgICAgICAgLy8gbm9kZSBhZnRlciBgdGhpcy4kdG9gLCBub3QgYHRoaXMuJHRvYCBpdHNlbGYuXG4gICAgICAgIGxldCBtb3ZlSW5saW5lID0gdGhpcy5tdXN0TW92ZUlubGluZSgpLCBwbGFjZWRTaXplID0gdGhpcy5wbGFjZWQuc2l6ZSAtIHRoaXMuZGVwdGggLSB0aGlzLiRmcm9tLmRlcHRoO1xuICAgICAgICBsZXQgJGZyb20gPSB0aGlzLiRmcm9tLCAkdG8gPSB0aGlzLmNsb3NlKG1vdmVJbmxpbmUgPCAwID8gdGhpcy4kdG8gOiAkZnJvbS5kb2MucmVzb2x2ZShtb3ZlSW5saW5lKSk7XG4gICAgICAgIGlmICghJHRvKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIElmIGNsb3NpbmcgdG8gYCR0b2Agc3VjY2VlZGVkLCBjcmVhdGUgYSBzdGVwXG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5wbGFjZWQsIG9wZW5TdGFydCA9ICRmcm9tLmRlcHRoLCBvcGVuRW5kID0gJHRvLmRlcHRoO1xuICAgICAgICB3aGlsZSAob3BlblN0YXJ0ICYmIG9wZW5FbmQgJiYgY29udGVudC5jaGlsZENvdW50ID09IDEpIHsgLy8gTm9ybWFsaXplIGJ5IGRyb3BwaW5nIG9wZW4gcGFyZW50IG5vZGVzXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgICAgICAgICBvcGVuU3RhcnQtLTtcbiAgICAgICAgICAgIG9wZW5FbmQtLTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2xpY2UgPSBuZXcgU2xpY2UoY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgaWYgKG1vdmVJbmxpbmUgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGZyb20ucG9zLCBtb3ZlSW5saW5lLCB0aGlzLiR0by5wb3MsIHRoaXMuJHRvLmVuZCgpLCBzbGljZSwgcGxhY2VkU2l6ZSk7XG4gICAgICAgIGlmIChzbGljZS5zaXplIHx8ICRmcm9tLnBvcyAhPSB0aGlzLiR0by5wb3MpIC8vIERvbid0IGdlbmVyYXRlIG5vLW9wIHN0ZXBzXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKCRmcm9tLnBvcywgJHRvLnBvcywgc2xpY2UpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gRmluZCBhIHBvc2l0aW9uIG9uIHRoZSBzdGFydCBzcGluZSBvZiBgdGhpcy51bnBsYWNlZGAgdGhhdCBoYXNcbiAgICAvLyBjb250ZW50IHRoYXQgY2FuIGJlIG1vdmVkIHNvbWV3aGVyZSBvbiB0aGUgZnJvbnRpZXIuIFJldHVybnMgdHdvXG4gICAgLy8gZGVwdGhzLCBvbmUgZm9yIHRoZSBzbGljZSBhbmQgb25lIGZvciB0aGUgZnJvbnRpZXIuXG4gICAgZmluZEZpdHRhYmxlKCkge1xuICAgICAgICBsZXQgc3RhcnREZXB0aCA9IHRoaXMudW5wbGFjZWQub3BlblN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBjdXIgPSB0aGlzLnVucGxhY2VkLmNvbnRlbnQsIGQgPSAwLCBvcGVuRW5kID0gdGhpcy51bnBsYWNlZC5vcGVuRW5kOyBkIDwgc3RhcnREZXB0aDsgZCsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGN1ci5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKGN1ci5jaGlsZENvdW50ID4gMSlcbiAgICAgICAgICAgICAgICBvcGVuRW5kID0gMDtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcgJiYgb3BlbkVuZCA8PSBkKSB7XG4gICAgICAgICAgICAgICAgc3RhcnREZXB0aCA9IGQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSB0cnkgd3JhcHBpbmcgbm9kZXMgKHBhc3MgMikgYWZ0ZXIgZmluZGluZyBhIHBsYWNlIHdpdGhvdXRcbiAgICAgICAgLy8gd3JhcHBpbmcgZmFpbGVkLlxuICAgICAgICBmb3IgKGxldCBwYXNzID0gMTsgcGFzcyA8PSAyOyBwYXNzKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNsaWNlRGVwdGggPSBwYXNzID09IDEgPyBzdGFydERlcHRoIDogdGhpcy51bnBsYWNlZC5vcGVuU3RhcnQ7IHNsaWNlRGVwdGggPj0gMDsgc2xpY2VEZXB0aC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyYWdtZW50LCBwYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzbGljZURlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGNvbnRlbnRBdCh0aGlzLnVucGxhY2VkLmNvbnRlbnQsIHNsaWNlRGVwdGggLSAxKS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHBhcmVudC5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLnVucGxhY2VkLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZnJvbnRpZXJEZXB0aCA9IHRoaXMuZGVwdGg7IGZyb250aWVyRGVwdGggPj0gMDsgZnJvbnRpZXJEZXB0aC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG1hdGNoIH0gPSB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdLCB3cmFwLCBpbmplY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBwYXNzIDEsIGlmIHRoZSBuZXh0IG5vZGUgbWF0Y2hlcywgb3IgdGhlcmUgaXMgbm8gbmV4dFxuICAgICAgICAgICAgICAgICAgICAvLyBub2RlIGJ1dCB0aGUgcGFyZW50cyBsb29rIGNvbXBhdGlibGUsIHdlJ3ZlIGZvdW5kIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXNzID09IDEgJiYgKGZpcnN0ID8gbWF0Y2gubWF0Y2hUeXBlKGZpcnN0LnR5cGUpIHx8IChpbmplY3QgPSBtYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmZyb20oZmlyc3QpLCBmYWxzZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmVudCAmJiB0eXBlLmNvbXBhdGlibGVDb250ZW50KHBhcmVudC50eXBlKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzbGljZURlcHRoLCBmcm9udGllckRlcHRoLCBwYXJlbnQsIGluamVjdCB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBwYXNzIDIsIGxvb2sgZm9yIGEgc2V0IG9mIHdyYXBwaW5nIG5vZGVzIHRoYXQgbWFrZVxuICAgICAgICAgICAgICAgICAgICAvLyBgZmlyc3RgIGZpdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXNzID09IDIgJiYgZmlyc3QgJiYgKHdyYXAgPSBtYXRjaC5maW5kV3JhcHBpbmcoZmlyc3QudHlwZSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc2xpY2VEZXB0aCwgZnJvbnRpZXJEZXB0aCwgcGFyZW50LCB3cmFwIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvbnRpbnVlIGxvb2tpbmcgZnVydGhlciB1cCBpZiB0aGUgcGFyZW50IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd291bGQgZml0IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgbWF0Y2gubWF0Y2hUeXBlKHBhcmVudC50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBvcGVuTW9yZSgpIHtcbiAgICAgICAgbGV0IHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSB0aGlzLnVucGxhY2VkO1xuICAgICAgICBsZXQgaW5uZXIgPSBjb250ZW50QXQoY29udGVudCwgb3BlblN0YXJ0KTtcbiAgICAgICAgaWYgKCFpbm5lci5jaGlsZENvdW50IHx8IGlubmVyLmZpcnN0Q2hpbGQuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVucGxhY2VkID0gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCArIDEsIE1hdGgubWF4KG9wZW5FbmQsIGlubmVyLnNpemUgKyBvcGVuU3RhcnQgPj0gY29udGVudC5zaXplIC0gb3BlbkVuZCA/IG9wZW5TdGFydCArIDEgOiAwKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkcm9wTm9kZSgpIHtcbiAgICAgICAgbGV0IHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSB0aGlzLnVucGxhY2VkO1xuICAgICAgICBsZXQgaW5uZXIgPSBjb250ZW50QXQoY29udGVudCwgb3BlblN0YXJ0KTtcbiAgICAgICAgaWYgKGlubmVyLmNoaWxkQ291bnQgPD0gMSAmJiBvcGVuU3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgb3BlbkF0RW5kID0gY29udGVudC5zaXplIC0gb3BlblN0YXJ0IDw9IG9wZW5TdGFydCArIGlubmVyLnNpemU7XG4gICAgICAgICAgICB0aGlzLnVucGxhY2VkID0gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoY29udGVudCwgb3BlblN0YXJ0IC0gMSwgMSksIG9wZW5TdGFydCAtIDEsIG9wZW5BdEVuZCA/IG9wZW5TdGFydCAtIDEgOiBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChjb250ZW50LCBvcGVuU3RhcnQsIDEpLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1vdmUgY29udGVudCBmcm9tIHRoZSB1bnBsYWNlZCBzbGljZSBhdCBgc2xpY2VEZXB0aGAgdG8gdGhlXG4gICAgLy8gZnJvbnRpZXIgbm9kZSBhdCBgZnJvbnRpZXJEZXB0aGAuIENsb3NlIHRoYXQgZnJvbnRpZXIgbm9kZSB3aGVuXG4gICAgLy8gYXBwbGljYWJsZS5cbiAgICBwbGFjZU5vZGVzKHsgc2xpY2VEZXB0aCwgZnJvbnRpZXJEZXB0aCwgcGFyZW50LCBpbmplY3QsIHdyYXAgfSkge1xuICAgICAgICB3aGlsZSAodGhpcy5kZXB0aCA+IGZyb250aWVyRGVwdGgpXG4gICAgICAgICAgICB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICAgIGlmICh3cmFwKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbkZyb250aWVyTm9kZSh3cmFwW2ldKTtcbiAgICAgICAgbGV0IHNsaWNlID0gdGhpcy51bnBsYWNlZCwgZnJhZ21lbnQgPSBwYXJlbnQgPyBwYXJlbnQuY29udGVudCA6IHNsaWNlLmNvbnRlbnQ7XG4gICAgICAgIGxldCBvcGVuU3RhcnQgPSBzbGljZS5vcGVuU3RhcnQgLSBzbGljZURlcHRoO1xuICAgICAgICBsZXQgdGFrZW4gPSAwLCBhZGQgPSBbXTtcbiAgICAgICAgbGV0IHsgbWF0Y2gsIHR5cGUgfSA9IHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF07XG4gICAgICAgIGlmIChpbmplY3QpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5qZWN0LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgICAgICAgICBhZGQucHVzaChpbmplY3QuY2hpbGQoaSkpO1xuICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaC5tYXRjaEZyYWdtZW50KGluamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZXMgdGhlIGFtb3VudCBvZiAoZW5kKSBvcGVuIG5vZGVzIGF0IHRoZSBlbmQgb2YgdGhlXG4gICAgICAgIC8vIGZyYWdtZW50LiBXaGVuIDAsIHRoZSBwYXJlbnQgaXMgb3BlbiwgYnV0IG5vIG1vcmUuIFdoZW5cbiAgICAgICAgLy8gbmVnYXRpdmUsIG5vdGhpbmcgaXMgb3Blbi5cbiAgICAgICAgbGV0IG9wZW5FbmRDb3VudCA9IChmcmFnbWVudC5zaXplICsgc2xpY2VEZXB0aCkgLSAoc2xpY2UuY29udGVudC5zaXplIC0gc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIC8vIFNjYW4gb3ZlciB0aGUgZnJhZ21lbnQsIGZpdHRpbmcgYXMgbWFueSBjaGlsZCBub2RlcyBhc1xuICAgICAgICAvLyBwb3NzaWJsZS5cbiAgICAgICAgd2hpbGUgKHRha2VuIDwgZnJhZ21lbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBmcmFnbWVudC5jaGlsZCh0YWtlbiksIG1hdGNoZXMgPSBtYXRjaC5tYXRjaFR5cGUobmV4dC50eXBlKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRha2VuKys7XG4gICAgICAgICAgICBpZiAodGFrZW4gPiAxIHx8IG9wZW5TdGFydCA9PSAwIHx8IG5leHQuY29udGVudC5zaXplKSB7IC8vIERyb3AgZW1wdHkgb3BlbiBub2Rlc1xuICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlcztcbiAgICAgICAgICAgICAgICBhZGQucHVzaChjbG9zZU5vZGVTdGFydChuZXh0Lm1hcmsodHlwZS5hbGxvd2VkTWFya3MobmV4dC5tYXJrcykpLCB0YWtlbiA9PSAxID8gb3BlblN0YXJ0IDogMCwgdGFrZW4gPT0gZnJhZ21lbnQuY2hpbGRDb3VudCA/IG9wZW5FbmRDb3VudCA6IC0xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvRW5kID0gdGFrZW4gPT0gZnJhZ21lbnQuY2hpbGRDb3VudDtcbiAgICAgICAgaWYgKCF0b0VuZClcbiAgICAgICAgICAgIG9wZW5FbmRDb3VudCA9IC0xO1xuICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIGZyb250aWVyRGVwdGgsIEZyYWdtZW50LmZyb20oYWRkKSk7XG4gICAgICAgIHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0ubWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgLy8gSWYgdGhlIHBhcmVudCB0eXBlcyBtYXRjaCwgYW5kIHRoZSBlbnRpcmUgbm9kZSB3YXMgbW92ZWQsIGFuZFxuICAgICAgICAvLyBpdCdzIG5vdCBvcGVuLCBjbG9zZSB0aGlzIGZyb250aWVyIG5vZGUgcmlnaHQgYXdheS5cbiAgICAgICAgaWYgKHRvRW5kICYmIG9wZW5FbmRDb3VudCA8IDAgJiYgcGFyZW50ICYmIHBhcmVudC50eXBlID09IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF0udHlwZSAmJiB0aGlzLmZyb250aWVyLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICAgIC8vIEFkZCBuZXcgZnJvbnRpZXIgbm9kZXMgZm9yIGFueSBvcGVuIG5vZGVzIGF0IHRoZSBlbmQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjdXIgPSBmcmFnbWVudDsgaSA8IG9wZW5FbmRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGN1ci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmZyb250aWVyLnB1c2goeyB0eXBlOiBub2RlLnR5cGUsIG1hdGNoOiBub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudCkgfSk7XG4gICAgICAgICAgICBjdXIgPSBub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIGB0aGlzLnVucGxhY2VkYC4gRHJvcCB0aGUgZW50aXJlIG5vZGUgZnJvbSB3aGljaCB3ZVxuICAgICAgICAvLyBwbGFjZWQgaXQgd2UgZ290IHRvIGl0cyBlbmQsIG90aGVyd2lzZSBqdXN0IGRyb3AgdGhlIHBsYWNlZFxuICAgICAgICAvLyBub2Rlcy5cbiAgICAgICAgdGhpcy51bnBsYWNlZCA9ICF0b0VuZCA/IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIHNsaWNlRGVwdGgsIHRha2VuKSwgc2xpY2Uub3BlblN0YXJ0LCBzbGljZS5vcGVuRW5kKVxuICAgICAgICAgICAgOiBzbGljZURlcHRoID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoc2xpY2UuY29udGVudCwgc2xpY2VEZXB0aCAtIDEsIDEpLCBzbGljZURlcHRoIC0gMSwgb3BlbkVuZENvdW50IDwgMCA/IHNsaWNlLm9wZW5FbmQgOiBzbGljZURlcHRoIC0gMSk7XG4gICAgfVxuICAgIG11c3RNb3ZlSW5saW5lKCkge1xuICAgICAgICBpZiAoIXRoaXMuJHRvLnBhcmVudC5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF0sIGxldmVsO1xuICAgICAgICBpZiAoIXRvcC50eXBlLmlzVGV4dGJsb2NrIHx8ICFjb250ZW50QWZ0ZXJGaXRzKHRoaXMuJHRvLCB0aGlzLiR0by5kZXB0aCwgdG9wLnR5cGUsIHRvcC5tYXRjaCwgZmFsc2UpIHx8XG4gICAgICAgICAgICAodGhpcy4kdG8uZGVwdGggPT0gdGhpcy5kZXB0aCAmJiAobGV2ZWwgPSB0aGlzLmZpbmRDbG9zZUxldmVsKHRoaXMuJHRvKSkgJiYgbGV2ZWwuZGVwdGggPT0gdGhpcy5kZXB0aCkpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCB7IGRlcHRoIH0gPSB0aGlzLiR0bywgYWZ0ZXIgPSB0aGlzLiR0by5hZnRlcihkZXB0aCk7XG4gICAgICAgIHdoaWxlIChkZXB0aCA+IDEgJiYgYWZ0ZXIgPT0gdGhpcy4kdG8uZW5kKC0tZGVwdGgpKVxuICAgICAgICAgICAgKythZnRlcjtcbiAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgIH1cbiAgICBmaW5kQ2xvc2VMZXZlbCgkdG8pIHtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgaSA9IE1hdGgubWluKHRoaXMuZGVwdGgsICR0by5kZXB0aCk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgeyBtYXRjaCwgdHlwZSB9ID0gdGhpcy5mcm9udGllcltpXTtcbiAgICAgICAgICAgIGxldCBkcm9wSW5uZXIgPSBpIDwgJHRvLmRlcHRoICYmICR0by5lbmQoaSArIDEpID09ICR0by5wb3MgKyAoJHRvLmRlcHRoIC0gKGkgKyAxKSk7XG4gICAgICAgICAgICBsZXQgZml0ID0gY29udGVudEFmdGVyRml0cygkdG8sIGksIHR5cGUsIG1hdGNoLCBkcm9wSW5uZXIpO1xuICAgICAgICAgICAgaWYgKCFmaXQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gaSAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbWF0Y2gsIHR5cGUgfSA9IHRoaXMuZnJvbnRpZXJbZF07XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoZXMgPSBjb250ZW50QWZ0ZXJGaXRzKCR0bywgZCwgdHlwZSwgbWF0Y2gsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkZXB0aDogaSwgZml0LCBtb3ZlOiBkcm9wSW5uZXIgPyAkdG8uZG9jLnJlc29sdmUoJHRvLmFmdGVyKGkgKyAxKSkgOiAkdG8gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZSgkdG8pIHtcbiAgICAgICAgbGV0IGNsb3NlID0gdGhpcy5maW5kQ2xvc2VMZXZlbCgkdG8pO1xuICAgICAgICBpZiAoIWNsb3NlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmRlcHRoID4gY2xvc2UuZGVwdGgpXG4gICAgICAgICAgICB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICAgIGlmIChjbG9zZS5maXQuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgY2xvc2UuZGVwdGgsIGNsb3NlLmZpdCk7XG4gICAgICAgICR0byA9IGNsb3NlLm1vdmU7XG4gICAgICAgIGZvciAobGV0IGQgPSBjbG9zZS5kZXB0aCArIDE7IGQgPD0gJHRvLmRlcHRoOyBkKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gJHRvLm5vZGUoZCksIGFkZCA9IG5vZGUudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShub2RlLmNvbnRlbnQsIHRydWUsICR0by5pbmRleChkKSk7XG4gICAgICAgICAgICB0aGlzLm9wZW5Gcm9udGllck5vZGUobm9kZS50eXBlLCBub2RlLmF0dHJzLCBhZGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdG87XG4gICAgfVxuICAgIG9wZW5Gcm9udGllck5vZGUodHlwZSwgYXR0cnMgPSBudWxsLCBjb250ZW50KSB7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdO1xuICAgICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2gubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIHRoaXMuZGVwdGgsIEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXR0cnMsIGNvbnRlbnQpKSk7XG4gICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7IHR5cGUsIG1hdGNoOiB0eXBlLmNvbnRlbnRNYXRjaCB9KTtcbiAgICB9XG4gICAgY2xvc2VGcm9udGllck5vZGUoKSB7XG4gICAgICAgIGxldCBvcGVuID0gdGhpcy5mcm9udGllci5wb3AoKTtcbiAgICAgICAgbGV0IGFkZCA9IG9wZW4ubWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgICAgIGlmIChhZGQuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgdGhpcy5mcm9udGllci5sZW5ndGgsIGFkZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZHJvcEZyb21GcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIGNvdW50KSB7XG4gICAgaWYgKGRlcHRoID09IDApXG4gICAgICAgIHJldHVybiBmcmFnbWVudC5jdXRCeUluZGV4KGNvdW50LCBmcmFnbWVudC5jaGlsZENvdW50KTtcbiAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKDAsIGZyYWdtZW50LmZpcnN0Q2hpbGQuY29weShkcm9wRnJvbUZyYWdtZW50KGZyYWdtZW50LmZpcnN0Q2hpbGQuY29udGVudCwgZGVwdGggLSAxLCBjb3VudCkpKTtcbn1cbmZ1bmN0aW9uIGFkZFRvRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBjb250ZW50KSB7XG4gICAgaWYgKGRlcHRoID09IDApXG4gICAgICAgIHJldHVybiBmcmFnbWVudC5hcHBlbmQoY29udGVudCk7XG4gICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZChmcmFnbWVudC5jaGlsZENvdW50IC0gMSwgZnJhZ21lbnQubGFzdENoaWxkLmNvcHkoYWRkVG9GcmFnbWVudChmcmFnbWVudC5sYXN0Q2hpbGQuY29udGVudCwgZGVwdGggLSAxLCBjb250ZW50KSkpO1xufVxuZnVuY3Rpb24gY29udGVudEF0KGZyYWdtZW50LCBkZXB0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwdGg7IGkrKylcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gY2xvc2VOb2RlU3RhcnQobm9kZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgaWYgKG9wZW5TdGFydCA8PSAwKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICBsZXQgZnJhZyA9IG5vZGUuY29udGVudDtcbiAgICBpZiAob3BlblN0YXJ0ID4gMSlcbiAgICAgICAgZnJhZyA9IGZyYWcucmVwbGFjZUNoaWxkKDAsIGNsb3NlTm9kZVN0YXJ0KGZyYWcuZmlyc3RDaGlsZCwgb3BlblN0YXJ0IC0gMSwgZnJhZy5jaGlsZENvdW50ID09IDEgPyBvcGVuRW5kIC0gMSA6IDApKTtcbiAgICBpZiAob3BlblN0YXJ0ID4gMCkge1xuICAgICAgICBmcmFnID0gbm9kZS50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKGZyYWcpLmFwcGVuZChmcmFnKTtcbiAgICAgICAgaWYgKG9wZW5FbmQgPD0gMClcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnLmFwcGVuZChub2RlLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoZnJhZykuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5jb3B5KGZyYWcpO1xufVxuZnVuY3Rpb24gY29udGVudEFmdGVyRml0cygkdG8sIGRlcHRoLCB0eXBlLCBtYXRjaCwgb3Blbikge1xuICAgIGxldCBub2RlID0gJHRvLm5vZGUoZGVwdGgpLCBpbmRleCA9IG9wZW4gPyAkdG8uaW5kZXhBZnRlcihkZXB0aCkgOiAkdG8uaW5kZXgoZGVwdGgpO1xuICAgIGlmIChpbmRleCA9PSBub2RlLmNoaWxkQ291bnQgJiYgIXR5cGUuY29tcGF0aWJsZUNvbnRlbnQobm9kZS50eXBlKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZpdCA9IG1hdGNoLmZpbGxCZWZvcmUobm9kZS5jb250ZW50LCB0cnVlLCBpbmRleCk7XG4gICAgcmV0dXJuIGZpdCAmJiAhaW52YWxpZE1hcmtzKHR5cGUsIG5vZGUuY29udGVudCwgaW5kZXgpID8gZml0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGludmFsaWRNYXJrcyh0eXBlLCBmcmFnbWVudCwgc3RhcnQpIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBmcmFnbWVudC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgIGlmICghdHlwZS5hbGxvd3NNYXJrcyhmcmFnbWVudC5jaGlsZChpKS5tYXJrcykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZWZpbmVzQ29udGVudCh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUuc3BlYy5kZWZpbmluZyB8fCB0eXBlLnNwZWMuZGVmaW5pbmdGb3JDb250ZW50O1xufVxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlKHRyLCBmcm9tLCB0bywgc2xpY2UpIHtcbiAgICBpZiAoIXNsaWNlLnNpemUpXG4gICAgICAgIHJldHVybiB0ci5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gICAgbGV0ICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksICR0byA9IHRyLmRvYy5yZXNvbHZlKHRvKTtcbiAgICBpZiAoZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkpXG4gICAgICAgIHJldHVybiB0ci5zdGVwKG5ldyBSZXBsYWNlU3RlcChmcm9tLCB0bywgc2xpY2UpKTtcbiAgICBsZXQgdGFyZ2V0RGVwdGhzID0gY292ZXJlZERlcHRocygkZnJvbSwgdHIuZG9jLnJlc29sdmUodG8pKTtcbiAgICAvLyBDYW4ndCByZXBsYWNlIHRoZSB3aG9sZSBkb2N1bWVudCwgc28gcmVtb3ZlIDAgaWYgaXQncyBwcmVzZW50XG4gICAgaWYgKHRhcmdldERlcHRoc1t0YXJnZXREZXB0aHMubGVuZ3RoIC0gMV0gPT0gMClcbiAgICAgICAgdGFyZ2V0RGVwdGhzLnBvcCgpO1xuICAgIC8vIE5lZ2F0aXZlIG51bWJlcnMgcmVwcmVzZW50IG5vdCBleHBhbnNpb24gb3ZlciB0aGUgd2hvbGUgbm9kZSBhdFxuICAgIC8vIHRoYXQgZGVwdGgsIGJ1dCByZXBsYWNpbmcgZnJvbSAkZnJvbS5iZWZvcmUoLUQpIHRvICR0by5wb3MuXG4gICAgbGV0IHByZWZlcnJlZFRhcmdldCA9IC0oJGZyb20uZGVwdGggKyAxKTtcbiAgICB0YXJnZXREZXB0aHMudW5zaGlmdChwcmVmZXJyZWRUYXJnZXQpO1xuICAgIC8vIFRoaXMgbG9vcCBwaWNrcyBhIHByZWZlcnJlZCB0YXJnZXQgZGVwdGgsIGlmIG9uZSBvZiB0aGUgY292ZXJpbmdcbiAgICAvLyBkZXB0aHMgaXMgbm90IG91dHNpZGUgb2YgYSBkZWZpbmluZyBub2RlLCBhbmQgYWRkcyBuZWdhdGl2ZVxuICAgIC8vIGRlcHRocyBmb3IgYW55IGRlcHRoIHRoYXQgaGFzICRmcm9tIGF0IGl0cyBzdGFydCBhbmQgZG9lcyBub3RcbiAgICAvLyBjcm9zcyBhIGRlZmluaW5nIG5vZGUuXG4gICAgZm9yIChsZXQgZCA9ICRmcm9tLmRlcHRoLCBwb3MgPSAkZnJvbS5wb3MgLSAxOyBkID4gMDsgZC0tLCBwb3MtLSkge1xuICAgICAgICBsZXQgc3BlYyA9ICRmcm9tLm5vZGUoZCkudHlwZS5zcGVjO1xuICAgICAgICBpZiAoc3BlYy5kZWZpbmluZyB8fCBzcGVjLmRlZmluaW5nQXNDb250ZXh0IHx8IHNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICh0YXJnZXREZXB0aHMuaW5kZXhPZihkKSA+IC0xKVxuICAgICAgICAgICAgcHJlZmVycmVkVGFyZ2V0ID0gZDtcbiAgICAgICAgZWxzZSBpZiAoJGZyb20uYmVmb3JlKGQpID09IHBvcylcbiAgICAgICAgICAgIHRhcmdldERlcHRocy5zcGxpY2UoMSwgMCwgLWQpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gZml0IGVhY2ggcG9zc2libGUgZGVwdGggb2YgdGhlIHNsaWNlIGludG8gZWFjaCBwb3NzaWJsZVxuICAgIC8vIHRhcmdldCBkZXB0aCwgc3RhcnRpbmcgd2l0aCB0aGUgcHJlZmVycmVkIGRlcHRocy5cbiAgICBsZXQgcHJlZmVycmVkVGFyZ2V0SW5kZXggPSB0YXJnZXREZXB0aHMuaW5kZXhPZihwcmVmZXJyZWRUYXJnZXQpO1xuICAgIGxldCBsZWZ0Tm9kZXMgPSBbXSwgcHJlZmVycmVkRGVwdGggPSBzbGljZS5vcGVuU3RhcnQ7XG4gICAgZm9yIChsZXQgY29udGVudCA9IHNsaWNlLmNvbnRlbnQsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBsZWZ0Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgaWYgKGkgPT0gc2xpY2Uub3BlblN0YXJ0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnRlbnQgPSBub2RlLmNvbnRlbnQ7XG4gICAgfVxuICAgIC8vIEJhY2sgdXAgcHJlZmVycmVkRGVwdGggdG8gY292ZXIgZGVmaW5pbmcgdGV4dGJsb2NrcyBkaXJlY3RseVxuICAgIC8vIGFib3ZlIGl0LCBwb3NzaWJseSBza2lwcGluZyBhIG5vbi1kZWZpbmluZyB0ZXh0YmxvY2suXG4gICAgZm9yIChsZXQgZCA9IHByZWZlcnJlZERlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IGxlZnROb2RlID0gbGVmdE5vZGVzW2RdLCBkZWYgPSBkZWZpbmVzQ29udGVudChsZWZ0Tm9kZS50eXBlKTtcbiAgICAgICAgaWYgKGRlZiAmJiAhbGVmdE5vZGUuc2FtZU1hcmt1cCgkZnJvbS5ub2RlKE1hdGguYWJzKHByZWZlcnJlZFRhcmdldCkgLSAxKSkpXG4gICAgICAgICAgICBwcmVmZXJyZWREZXB0aCA9IGQ7XG4gICAgICAgIGVsc2UgaWYgKGRlZiB8fCAhbGVmdE5vZGUudHlwZS5pc1RleHRibG9jaylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gc2xpY2Uub3BlblN0YXJ0OyBqID49IDA7IGotLSkge1xuICAgICAgICBsZXQgb3BlbkRlcHRoID0gKGogKyBwcmVmZXJyZWREZXB0aCArIDEpICUgKHNsaWNlLm9wZW5TdGFydCArIDEpO1xuICAgICAgICBsZXQgaW5zZXJ0ID0gbGVmdE5vZGVzW29wZW5EZXB0aF07XG4gICAgICAgIGlmICghaW5zZXJ0KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0RGVwdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBMb29wIG92ZXIgcG9zc2libGUgZXhwYW5zaW9uIGxldmVscywgc3RhcnRpbmcgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIHByZWZlcnJlZCBvbmVcbiAgICAgICAgICAgIGxldCB0YXJnZXREZXB0aCA9IHRhcmdldERlcHRoc1soaSArIHByZWZlcnJlZFRhcmdldEluZGV4KSAlIHRhcmdldERlcHRocy5sZW5ndGhdLCBleHBhbmQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRhcmdldERlcHRoIDwgMCkge1xuICAgICAgICAgICAgICAgIGV4cGFuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRhcmdldERlcHRoID0gLXRhcmdldERlcHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRmcm9tLm5vZGUodGFyZ2V0RGVwdGggLSAxKSwgaW5kZXggPSAkZnJvbS5pbmRleCh0YXJnZXREZXB0aCAtIDEpO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIGluc2VydC50eXBlLCBpbnNlcnQubWFya3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0ci5yZXBsYWNlKCRmcm9tLmJlZm9yZSh0YXJnZXREZXB0aCksIGV4cGFuZCA/ICR0by5hZnRlcih0YXJnZXREZXB0aCkgOiB0bywgbmV3IFNsaWNlKGNsb3NlRnJhZ21lbnQoc2xpY2UuY29udGVudCwgMCwgc2xpY2Uub3BlblN0YXJ0LCBvcGVuRGVwdGgpLCBvcGVuRGVwdGgsIHNsaWNlLm9wZW5FbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhcnRTdGVwcyA9IHRyLnN0ZXBzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gdGFyZ2V0RGVwdGhzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRyLnJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgICAgaWYgKHRyLnN0ZXBzLmxlbmd0aCA+IHN0YXJ0U3RlcHMpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGRlcHRoID0gdGFyZ2V0RGVwdGhzW2ldO1xuICAgICAgICBpZiAoZGVwdGggPCAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZyb20gPSAkZnJvbS5iZWZvcmUoZGVwdGgpO1xuICAgICAgICB0byA9ICR0by5hZnRlcihkZXB0aCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvc2VGcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIG9sZE9wZW4sIG5ld09wZW4sIHBhcmVudCkge1xuICAgIGlmIChkZXB0aCA8IG9sZE9wZW4pIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoMCwgZmlyc3QuY29weShjbG9zZUZyYWdtZW50KGZpcnN0LmNvbnRlbnQsIGRlcHRoICsgMSwgb2xkT3BlbiwgbmV3T3BlbiwgZmlyc3QpKSk7XG4gICAgfVxuICAgIGlmIChkZXB0aCA+IG5ld09wZW4pIHtcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KDApO1xuICAgICAgICBsZXQgc3RhcnQgPSBtYXRjaC5maWxsQmVmb3JlKGZyYWdtZW50KS5hcHBlbmQoZnJhZ21lbnQpO1xuICAgICAgICBmcmFnbWVudCA9IHN0YXJ0LmFwcGVuZChtYXRjaC5tYXRjaEZyYWdtZW50KHN0YXJ0KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VSYW5nZVdpdGgodHIsIGZyb20sIHRvLCBub2RlKSB7XG4gICAgaWYgKCFub2RlLmlzSW5saW5lICYmIGZyb20gPT0gdG8gJiYgdHIuZG9jLnJlc29sdmUoZnJvbSkucGFyZW50LmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICBsZXQgcG9pbnQgPSBpbnNlcnRQb2ludCh0ci5kb2MsIGZyb20sIG5vZGUudHlwZSk7XG4gICAgICAgIGlmIChwb2ludCAhPSBudWxsKVxuICAgICAgICAgICAgZnJvbSA9IHRvID0gcG9pbnQ7XG4gICAgfVxuICAgIHRyLnJlcGxhY2VSYW5nZShmcm9tLCB0bywgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obm9kZSksIDAsIDApKTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVJhbmdlKHRyLCBmcm9tLCB0bykge1xuICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0ci5kb2MucmVzb2x2ZSh0byk7XG4gICAgbGV0IGNvdmVyZWQgPSBjb3ZlcmVkRGVwdGhzKCRmcm9tLCAkdG8pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY292ZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZGVwdGggPSBjb3ZlcmVkW2ldLCBsYXN0ID0gaSA9PSBjb3ZlcmVkLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmICgobGFzdCAmJiBkZXB0aCA9PSAwKSB8fCAkZnJvbS5ub2RlKGRlcHRoKS50eXBlLmNvbnRlbnRNYXRjaC52YWxpZEVuZClcbiAgICAgICAgICAgIHJldHVybiB0ci5kZWxldGUoJGZyb20uc3RhcnQoZGVwdGgpLCAkdG8uZW5kKGRlcHRoKSk7XG4gICAgICAgIGlmIChkZXB0aCA+IDAgJiYgKGxhc3QgfHwgJGZyb20ubm9kZShkZXB0aCAtIDEpLmNhblJlcGxhY2UoJGZyb20uaW5kZXgoZGVwdGggLSAxKSwgJHRvLmluZGV4QWZ0ZXIoZGVwdGggLSAxKSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZSgkZnJvbS5iZWZvcmUoZGVwdGgpLCAkdG8uYWZ0ZXIoZGVwdGgpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgZCA9IDE7IGQgPD0gJGZyb20uZGVwdGggJiYgZCA8PSAkdG8uZGVwdGg7IGQrKykge1xuICAgICAgICBpZiAoZnJvbSAtICRmcm9tLnN0YXJ0KGQpID09ICRmcm9tLmRlcHRoIC0gZCAmJiB0byA+ICRmcm9tLmVuZChkKSAmJiAkdG8uZW5kKGQpIC0gdG8gIT0gJHRvLmRlcHRoIC0gZClcbiAgICAgICAgICAgIHJldHVybiB0ci5kZWxldGUoJGZyb20uYmVmb3JlKGQpLCB0byk7XG4gICAgfVxuICAgIHRyLmRlbGV0ZShmcm9tLCB0byk7XG59XG4vLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBkZXB0aHMgZm9yIHdoaWNoICRmcm9tIC0gJHRvIHNwYW5zIHRoZVxuLy8gd2hvbGUgY29udGVudCBvZiB0aGUgbm9kZXMgYXQgdGhhdCBkZXB0aC5cbmZ1bmN0aW9uIGNvdmVyZWREZXB0aHMoJGZyb20sICR0bykge1xuICAgIGxldCByZXN1bHQgPSBbXSwgbWluRGVwdGggPSBNYXRoLm1pbigkZnJvbS5kZXB0aCwgJHRvLmRlcHRoKTtcbiAgICBmb3IgKGxldCBkID0gbWluRGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBzdGFydCA9ICRmcm9tLnN0YXJ0KGQpO1xuICAgICAgICBpZiAoc3RhcnQgPCAkZnJvbS5wb3MgLSAoJGZyb20uZGVwdGggLSBkKSB8fFxuICAgICAgICAgICAgJHRvLmVuZChkKSA+ICR0by5wb3MgKyAoJHRvLmRlcHRoIC0gZCkgfHxcbiAgICAgICAgICAgICRmcm9tLm5vZGUoZCkudHlwZS5zcGVjLmlzb2xhdGluZyB8fFxuICAgICAgICAgICAgJHRvLm5vZGUoZCkudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoc3RhcnQgPT0gJHRvLnN0YXJ0KGQpIHx8XG4gICAgICAgICAgICAoZCA9PSAkZnJvbS5kZXB0aCAmJiBkID09ICR0by5kZXB0aCAmJiAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCAmJiAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQgJiZcbiAgICAgICAgICAgICAgICBkICYmICR0by5zdGFydChkIC0gMSkgPT0gc3RhcnQgLSAxKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcblVwZGF0ZSBhbiBhdHRyaWJ1dGUgaW4gYSBzcGVjaWZpYyBub2RlLlxuKi9cbmNsYXNzIEF0dHJTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGFuIGF0dHJpYnV0ZSBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAgKi9cbiAgICBhdHRyLCBcbiAgICAvLyBUaGUgYXR0cmlidXRlJ3MgbmV3IHZhbHVlLlxuICAgIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmF0dHIgPSBhdHRyO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiTm8gbm9kZSBhdCBhdHRyaWJ1dGUgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIG5vZGUuYXR0cnMpXG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IG5vZGUuYXR0cnNbbmFtZV07XG4gICAgICAgIGF0dHJzW3RoaXMuYXR0cl0gPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUoYXR0cnMsIG51bGwsIG5vZGUubWFya3MpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyU3RlcCh0aGlzLnBvcywgdGhpcy5hdHRyLCBkb2Mubm9kZUF0KHRoaXMucG9zKS5hdHRyc1t0aGlzLmF0dHJdKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IEF0dHJTdGVwKHBvcy5wb3MsIHRoaXMuYXR0ciwgdGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwiYXR0clwiLCBwb3M6IHRoaXMucG9zLCBhdHRyOiB0aGlzLmF0dHIsIHZhbHVlOiB0aGlzLnZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmF0dHIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQXR0clN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQXR0clN0ZXAoanNvbi5wb3MsIGpzb24uYXR0ciwganNvbi52YWx1ZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJhdHRyXCIsIEF0dHJTdGVwKTtcbi8qKlxuVXBkYXRlIGFuIGF0dHJpYnV0ZSBpbiB0aGUgZG9jIG5vZGUuXG4qL1xuY2xhc3MgRG9jQXR0clN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYW4gYXR0cmlidXRlIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgYXR0cmlidXRlIHRvIHNldC5cbiAgICAqL1xuICAgIGF0dHIsIFxuICAgIC8vIFRoZSBhdHRyaWJ1dGUncyBuZXcgdmFsdWUuXG4gICAgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hdHRyID0gYXR0cjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBkb2MuYXR0cnMpXG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IGRvYy5hdHRyc1tuYW1lXTtcbiAgICAgICAgYXR0cnNbdGhpcy5hdHRyXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZG9jLnR5cGUuY3JlYXRlKGF0dHJzLCBkb2MuY29udGVudCwgZG9jLm1hcmtzKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQub2sodXBkYXRlZCk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2NBdHRyU3RlcCh0aGlzLmF0dHIsIGRvYy5hdHRyc1t0aGlzLmF0dHJdKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwiZG9jQXR0clwiLCBhdHRyOiB0aGlzLmF0dHIsIHZhbHVlOiB0aGlzLnZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmF0dHIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRG9jQXR0clN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgRG9jQXR0clN0ZXAoanNvbi5hdHRyLCBqc29uLnZhbHVlKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImRvY0F0dHJcIiwgRG9jQXR0clN0ZXApO1xuXG4vKipcbkBpbnRlcm5hbFxuKi9cbmxldCBUcmFuc2Zvcm1FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xufTtcblRyYW5zZm9ybUVycm9yID0gZnVuY3Rpb24gVHJhbnNmb3JtRXJyb3IobWVzc2FnZSkge1xuICAgIGxldCBlcnIgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIGVyci5fX3Byb3RvX18gPSBUcmFuc2Zvcm1FcnJvci5wcm90b3R5cGU7XG4gICAgcmV0dXJuIGVycjtcbn07XG5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmFuc2Zvcm1FcnJvcjtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJUcmFuc2Zvcm1FcnJvclwiO1xuLyoqXG5BYnN0cmFjdGlvbiB0byBidWlsZCB1cCBhbmQgdHJhY2sgYW4gYXJyYXkgb2ZcbltzdGVwc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwKSByZXByZXNlbnRpbmcgYSBkb2N1bWVudCB0cmFuc2Zvcm1hdGlvbi5cblxuTW9zdCB0cmFuc2Zvcm1pbmcgbWV0aG9kcyByZXR1cm4gdGhlIGBUcmFuc2Zvcm1gIG9iamVjdCBpdHNlbGYsIHNvXG50aGF0IHRoZXkgY2FuIGJlIGNoYWluZWQuXG4qL1xuY2xhc3MgVHJhbnNmb3JtIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0cmFuc2Zvcm0gdGhhdCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBkb2N1bWVudCAodGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgc3RlcHMgaW4gdGhlXG4gICAgdHJhbnNmb3JtKS5cbiAgICAqL1xuICAgIGRvYykge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBzdGVwcyBpbiB0aGlzIHRyYW5zZm9ybS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGVwcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGRvY3VtZW50cyBiZWZvcmUgZWFjaCBvZiB0aGUgc3RlcHMuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZG9jcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQSBtYXBwaW5nIHdpdGggdGhlIG1hcHMgZm9yIGVhY2ggb2YgdGhlIHN0ZXBzIGluIHRoaXMgdHJhbnNmb3JtLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcHBpbmcgPSBuZXcgTWFwcGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0aW5nIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGJlZm9yZSgpIHsgcmV0dXJuIHRoaXMuZG9jcy5sZW5ndGggPyB0aGlzLmRvY3NbMF0gOiB0aGlzLmRvYzsgfVxuICAgIC8qKlxuICAgIEFwcGx5IGEgbmV3IHN0ZXAgaW4gdGhpcyB0cmFuc2Zvcm0sIHNhdmluZyB0aGUgcmVzdWx0LiBUaHJvd3MgYW5cbiAgICBlcnJvciB3aGVuIHRoZSBzdGVwIGZhaWxzLlxuICAgICovXG4gICAgc3RlcChzdGVwKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLm1heWJlU3RlcChzdGVwKTtcbiAgICAgICAgaWYgKHJlc3VsdC5mYWlsZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNmb3JtRXJyb3IocmVzdWx0LmZhaWxlZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gYXBwbHkgYSBzdGVwIGluIHRoaXMgdHJhbnNmb3JtYXRpb24sIGlnbm9yaW5nIGl0IGlmIGl0XG4gICAgZmFpbHMuIFJldHVybnMgdGhlIHN0ZXAgcmVzdWx0LlxuICAgICovXG4gICAgbWF5YmVTdGVwKHN0ZXApIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN0ZXAuYXBwbHkodGhpcy5kb2MpO1xuICAgICAgICBpZiAoIXJlc3VsdC5mYWlsZWQpXG4gICAgICAgICAgICB0aGlzLmFkZFN0ZXAoc3RlcCwgcmVzdWx0LmRvYyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gY2hhbmdlZCAod2hlbiB0aGVyZSBhcmUgYW55XG4gICAgc3RlcHMpLlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkU3RlcChzdGVwLCBkb2MpIHtcbiAgICAgICAgdGhpcy5kb2NzLnB1c2godGhpcy5kb2MpO1xuICAgICAgICB0aGlzLnN0ZXBzLnB1c2goc3RlcCk7XG4gICAgICAgIHRoaXMubWFwcGluZy5hcHBlbmRNYXAoc3RlcC5nZXRNYXAoKSk7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYCB3aXRoIHRoZVxuICAgIGdpdmVuIGBzbGljZWAuXG4gICAgKi9cbiAgICByZXBsYWNlKGZyb20sIHRvID0gZnJvbSwgc2xpY2UgPSBTbGljZS5lbXB0eSkge1xuICAgICAgICBsZXQgc3RlcCA9IHJlcGxhY2VTdGVwKHRoaXMuZG9jLCBmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgICBpZiAoc3RlcClcbiAgICAgICAgICAgIHRoaXMuc3RlcChzdGVwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGdpdmVuIHJhbmdlIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQsIHdoaWNoIG1heSBiZSBhXG4gICAgZnJhZ21lbnQsIG5vZGUsIG9yIGFycmF5IG9mIG5vZGVzLlxuICAgICovXG4gICAgcmVwbGFjZVdpdGgoZnJvbSwgdG8sIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZShmcm9tLCB0bywgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oY29udGVudCksIDAsIDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIGRlbGV0ZShmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKGZyb20sIHRvLCBTbGljZS5lbXB0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEluc2VydCB0aGUgZ2l2ZW4gY29udGVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBpbnNlcnQocG9zLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VXaXRoKHBvcywgcG9zLCBjb250ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSBhIHJhbmdlIG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgZ2l2ZW4gc2xpY2UsIHVzaW5nXG4gICAgYGZyb21gLCBgdG9gLCBhbmQgdGhlIHNsaWNlJ3NcbiAgICBbYG9wZW5TdGFydGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5TbGljZS5vcGVuU3RhcnQpIHByb3BlcnR5IGFzIGhpbnRzLCByYXRoZXJcbiAgICB0aGFuIGZpeGVkIHN0YXJ0IGFuZCBlbmQgcG9pbnRzLiBUaGlzIG1ldGhvZCBtYXkgZ3JvdyB0aGVcbiAgICByZXBsYWNlZCBhcmVhIG9yIGNsb3NlIG9wZW4gbm9kZXMgaW4gdGhlIHNsaWNlIGluIG9yZGVyIHRvIGdldCBhXG4gICAgZml0IHRoYXQgaXMgbW9yZSBpbiBsaW5lIHdpdGggV1lTSVdZRyBleHBlY3RhdGlvbnMsIGJ5IGRyb3BwaW5nXG4gICAgZnVsbHkgY292ZXJlZCBwYXJlbnQgbm9kZXMgb2YgdGhlIHJlcGxhY2VkIHJlZ2lvbiB3aGVuIHRoZXkgYXJlXG4gICAgbWFya2VkIFtub24tZGVmaW5pbmcgYXNcbiAgICBjb250ZXh0XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuZGVmaW5pbmdBc0NvbnRleHQpLCBvciBpbmNsdWRpbmcgYW5cbiAgICBvcGVuIHBhcmVudCBub2RlIGZyb20gdGhlIHNsaWNlIHRoYXQgX2lzXyBtYXJrZWQgYXMgW2RlZmluaW5nXG4gICAgaXRzIGNvbnRlbnRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5kZWZpbmluZ0ZvckNvbnRlbnQpLlxuICAgIFxuICAgIFRoaXMgaXMgdGhlIG1ldGhvZCwgZm9yIGV4YW1wbGUsIHRvIGhhbmRsZSBwYXN0ZS4gVGhlIHNpbWlsYXJcbiAgICBbYHJlcGxhY2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlRyYW5zZm9ybS5yZXBsYWNlKSBtZXRob2QgaXMgYSBtb3JlXG4gICAgcHJpbWl0aXZlIHRvb2wgd2hpY2ggd2lsbCBfbm90XyBtb3ZlIHRoZSBzdGFydCBhbmQgZW5kIG9mIGl0cyBnaXZlblxuICAgIHJhbmdlLCBhbmQgaXMgdXNlZnVsIGluIHNpdHVhdGlvbnMgd2hlcmUgeW91IG5lZWQgbW9yZSBwcmVjaXNlXG4gICAgY29udHJvbCBvdmVyIHdoYXQgaGFwcGVucy5cbiAgICAqL1xuICAgIHJlcGxhY2VSYW5nZShmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgcmVwbGFjZVJhbmdlKHRoaXMsIGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBnaXZlbiByYW5nZSB3aXRoIGEgbm9kZSwgYnV0IHVzZSBgZnJvbWAgYW5kIGB0b2AgYXNcbiAgICBoaW50cywgcmF0aGVyIHRoYW4gcHJlY2lzZSBwb3NpdGlvbnMuIFdoZW4gZnJvbSBhbmQgdG8gYXJlIHRoZSBzYW1lXG4gICAgYW5kIGFyZSBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgcGFyZW50IG5vZGUgaW4gd2hpY2ggdGhlIGdpdmVuXG4gICAgbm9kZSBkb2Vzbid0IGZpdCwgdGhpcyBtZXRob2QgbWF5IF9tb3ZlXyB0aGVtIG91dCB0b3dhcmRzIGEgcGFyZW50XG4gICAgdGhhdCBkb2VzIGFsbG93IHRoZSBnaXZlbiBub2RlIHRvIGJlIHBsYWNlZC4gV2hlbiB0aGUgZ2l2ZW4gcmFuZ2VcbiAgICBjb21wbGV0ZWx5IGNvdmVycyBhIHBhcmVudCBub2RlLCB0aGlzIG1ldGhvZCBtYXkgY29tcGxldGVseSByZXBsYWNlXG4gICAgdGhhdCBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIHJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIG5vZGUpIHtcbiAgICAgICAgcmVwbGFjZVJhbmdlV2l0aCh0aGlzLCBmcm9tLCB0bywgbm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgdGhlIGdpdmVuIHJhbmdlLCBleHBhbmRpbmcgaXQgdG8gY292ZXIgZnVsbHkgY292ZXJlZFxuICAgIHBhcmVudCBub2RlcyB1bnRpbCBhIHZhbGlkIHJlcGxhY2UgaXMgZm91bmQuXG4gICAgKi9cbiAgICBkZWxldGVSYW5nZShmcm9tLCB0bykge1xuICAgICAgICBkZWxldGVSYW5nZSh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTcGxpdCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2Ugb2ZmIGZyb20gaXRzIHBhcmVudCwgaWYgdGhlcmVcbiAgICBpcyBzaWJsaW5nIGNvbnRlbnQgYmVmb3JlIG9yIGFmdGVyIGl0LCBhbmQgbW92ZSBpdCB1cCB0aGUgdHJlZSB0b1xuICAgIHRoZSBkZXB0aCBzcGVjaWZpZWQgYnkgYHRhcmdldGAuIFlvdSdsbCBwcm9iYWJseSB3YW50IHRvIHVzZVxuICAgIFtgbGlmdFRhcmdldGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0ubGlmdFRhcmdldCkgdG8gY29tcHV0ZSBgdGFyZ2V0YCwgdG8gbWFrZVxuICAgIHN1cmUgdGhlIGxpZnQgaXMgdmFsaWQuXG4gICAgKi9cbiAgICBsaWZ0KHJhbmdlLCB0YXJnZXQpIHtcbiAgICAgICAgbGlmdCh0aGlzLCByYW5nZSwgdGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEpvaW4gdGhlIGJsb2NrcyBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uLiBJZiBkZXB0aCBpcyAyLCB0aGVpclxuICAgIGxhc3QgYW5kIGZpcnN0IHNpYmxpbmdzIGFyZSBhbHNvIGpvaW5lZCwgYW5kIHNvIG9uLlxuICAgICovXG4gICAgam9pbihwb3MsIGRlcHRoID0gMSkge1xuICAgICAgICBqb2luKHRoaXMsIHBvcywgZGVwdGgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgV3JhcCB0aGUgZ2l2ZW4gW3JhbmdlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVJhbmdlKSBpbiB0aGUgZ2l2ZW4gc2V0IG9mIHdyYXBwZXJzLlxuICAgIFRoZSB3cmFwcGVycyBhcmUgYXNzdW1lZCB0byBiZSB2YWxpZCBpbiB0aGlzIHBvc2l0aW9uLCBhbmQgc2hvdWxkXG4gICAgcHJvYmFibHkgYmUgY29tcHV0ZWQgd2l0aCBbYGZpbmRXcmFwcGluZ2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uZmluZFdyYXBwaW5nKS5cbiAgICAqL1xuICAgIHdyYXAocmFuZ2UsIHdyYXBwZXJzKSB7XG4gICAgICAgIHdyYXAodGhpcywgcmFuZ2UsIHdyYXBwZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCB0aGUgdHlwZSBvZiBhbGwgdGV4dGJsb2NrcyAocGFydGx5KSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYCB0b1xuICAgIHRoZSBnaXZlbiBub2RlIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIHNldEJsb2NrVHlwZShmcm9tLCB0byA9IGZyb20sIHR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgICAgICBzZXRCbG9ja1R5cGUodGhpcywgZnJvbSwgdG8sIHR5cGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIENoYW5nZSB0aGUgdHlwZSwgYXR0cmlidXRlcywgYW5kL29yIG1hcmtzIG9mIHRoZSBub2RlIGF0IGBwb3NgLlxuICAgIFdoZW4gYHR5cGVgIGlzbid0IGdpdmVuLCB0aGUgZXhpc3Rpbmcgbm9kZSB0eXBlIGlzIHByZXNlcnZlZCxcbiAgICAqL1xuICAgIHNldE5vZGVNYXJrdXAocG9zLCB0eXBlLCBhdHRycyA9IG51bGwsIG1hcmtzKSB7XG4gICAgICAgIHNldE5vZGVNYXJrdXAodGhpcywgcG9zLCB0eXBlLCBhdHRycywgbWFya3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IGEgc2luZ2xlIGF0dHJpYnV0ZSBvbiBhIGdpdmVuIG5vZGUgdG8gYSBuZXcgdmFsdWUuXG4gICAgVGhlIGBwb3NgIGFkZHJlc3NlcyB0aGUgZG9jdW1lbnQgY29udGVudC4gVXNlIGBzZXREb2NBdHRyaWJ1dGVgXG4gICAgdG8gc2V0IGF0dHJpYnV0ZXMgb24gdGhlIGRvY3VtZW50IGl0c2VsZi5cbiAgICAqL1xuICAgIHNldE5vZGVBdHRyaWJ1dGUocG9zLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0ZXAobmV3IEF0dHJTdGVwKHBvcywgYXR0ciwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCBhIHNpbmdsZSBhdHRyaWJ1dGUgb24gdGhlIGRvY3VtZW50IHRvIGEgbmV3IHZhbHVlLlxuICAgICovXG4gICAgc2V0RG9jQXR0cmlidXRlKGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RlcChuZXcgRG9jQXR0clN0ZXAoYXR0ciwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIG1hcmsgdG8gdGhlIG5vZGUgYXQgcG9zaXRpb24gYHBvc2AuXG4gICAgKi9cbiAgICBhZGROb2RlTWFyayhwb3MsIG1hcmspIHtcbiAgICAgICAgdGhpcy5zdGVwKG5ldyBBZGROb2RlTWFya1N0ZXAocG9zLCBtYXJrKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgYSBtYXJrIChvciBhIG1hcmsgb2YgdGhlIGdpdmVuIHR5cGUpIGZyb20gdGhlIG5vZGUgYXRcbiAgICBwb3NpdGlvbiBgcG9zYC5cbiAgICAqL1xuICAgIHJlbW92ZU5vZGVNYXJrKHBvcywgbWFyaykge1xuICAgICAgICBpZiAoIShtYXJrIGluc3RhbmNlb2YgTWFyaykpIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5kb2Mubm9kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGF0IHBvc2l0aW9uIFwiICsgcG9zKTtcbiAgICAgICAgICAgIG1hcmsgPSBtYXJrLmlzSW5TZXQobm9kZS5tYXJrcyk7XG4gICAgICAgICAgICBpZiAoIW1hcmspXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGVwKG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAocG9zLCBtYXJrKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTcGxpdCB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGFuZCBvcHRpb25hbGx5LCBpZiBgZGVwdGhgIGlzXG4gICAgZ3JlYXRlciB0aGFuIG9uZSwgYW55IG51bWJlciBvZiBub2RlcyBhYm92ZSB0aGF0LiBCeSBkZWZhdWx0LCB0aGVcbiAgICBwYXJ0cyBzcGxpdCBvZmYgd2lsbCBpbmhlcml0IHRoZSBub2RlIHR5cGUgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAgVGhpcyBjYW4gYmUgY2hhbmdlZCBieSBwYXNzaW5nIGFuIGFycmF5IG9mIHR5cGVzIGFuZCBhdHRyaWJ1dGVzIHRvXG4gICAgdXNlIGFmdGVyIHRoZSBzcGxpdC5cbiAgICAqL1xuICAgIHNwbGl0KHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgICAgIHNwbGl0KHRoaXMsIHBvcywgZGVwdGgsIHR5cGVzQWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIHRoZSBnaXZlbiBtYXJrIHRvIHRoZSBpbmxpbmUgY29udGVudCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC5cbiAgICAqL1xuICAgIGFkZE1hcmsoZnJvbSwgdG8sIG1hcmspIHtcbiAgICAgICAgYWRkTWFyayh0aGlzLCBmcm9tLCB0bywgbWFyayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgbWFya3MgZnJvbSBpbmxpbmUgbm9kZXMgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuIFdoZW5cbiAgICBgbWFya2AgaXMgYSBzaW5nbGUgbWFyaywgcmVtb3ZlIHByZWNpc2VseSB0aGF0IG1hcmsuIFdoZW4gaXQgaXNcbiAgICBhIG1hcmsgdHlwZSwgcmVtb3ZlIGFsbCBtYXJrcyBvZiB0aGF0IHR5cGUuIFdoZW4gaXQgaXMgbnVsbCxcbiAgICByZW1vdmUgYWxsIG1hcmtzIG9mIGFueSB0eXBlLlxuICAgICovXG4gICAgcmVtb3ZlTWFyayhmcm9tLCB0bywgbWFyaykge1xuICAgICAgICByZW1vdmVNYXJrKHRoaXMsIGZyb20sIHRvLCBtYXJrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZXMgYWxsIG1hcmtzIGFuZCBub2RlcyBmcm9tIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIGF0XG4gICAgYHBvc2AgdGhhdCBkb24ndCBtYXRjaCB0aGUgZ2l2ZW4gbmV3IHBhcmVudCBub2RlIHR5cGUuIEFjY2VwdHNcbiAgICBhbiBvcHRpb25hbCBzdGFydGluZyBbY29udGVudCBtYXRjaF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkNvbnRlbnRNYXRjaCkgYXNcbiAgICB0aGlyZCBhcmd1bWVudC5cbiAgICAqL1xuICAgIGNsZWFySW5jb21wYXRpYmxlKHBvcywgcGFyZW50VHlwZSwgbWF0Y2gpIHtcbiAgICAgICAgY2xlYXJJbmNvbXBhdGlibGUodGhpcywgcG9zLCBwYXJlbnRUeXBlLCBtYXRjaCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQWRkTWFya1N0ZXAsIEFkZE5vZGVNYXJrU3RlcCwgQXR0clN0ZXAsIERvY0F0dHJTdGVwLCBNYXBSZXN1bHQsIE1hcHBpbmcsIFJlbW92ZU1hcmtTdGVwLCBSZW1vdmVOb2RlTWFya1N0ZXAsIFJlcGxhY2VBcm91bmRTdGVwLCBSZXBsYWNlU3RlcCwgU3RlcCwgU3RlcE1hcCwgU3RlcFJlc3VsdCwgVHJhbnNmb3JtLCBUcmFuc2Zvcm1FcnJvciwgY2FuSm9pbiwgY2FuU3BsaXQsIGRyb3BQb2ludCwgZmluZFdyYXBwaW5nLCBpbnNlcnRQb2ludCwgam9pblBvaW50LCBsaWZ0VGFyZ2V0LCByZXBsYWNlU3RlcCB9O1xuIiwgImltcG9ydCB7IFNsaWNlLCBGcmFnbWVudCwgTWFyaywgTm9kZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IFJlcGxhY2VTdGVwLCBSZXBsYWNlQXJvdW5kU3RlcCwgVHJhbnNmb3JtIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcblxuY29uc3QgY2xhc3Nlc0J5SWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5TdXBlcmNsYXNzIGZvciBlZGl0b3Igc2VsZWN0aW9ucy4gRXZlcnkgc2VsZWN0aW9uIHR5cGUgc2hvdWxkXG5leHRlbmQgdGhpcy4gU2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4qL1xuY2xhc3MgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBJbml0aWFsaXplIGEgc2VsZWN0aW9uIHdpdGggdGhlIGhlYWQgYW5kIGFuY2hvciBhbmQgcmFuZ2VzLiBJZiBub1xuICAgIHJhbmdlcyBhcmUgZ2l2ZW4sIGNvbnN0cnVjdHMgYSBzaW5nbGUgcmFuZ2UgYWNyb3NzIGAkYW5jaG9yYCBhbmRcbiAgICBgJGhlYWRgLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHJlc29sdmVkIGFuY2hvciBvZiB0aGUgc2VsZWN0aW9uICh0aGUgc2lkZSB0aGF0IHN0YXlzIGluXG4gICAgcGxhY2Ugd2hlbiB0aGUgc2VsZWN0aW9uIGlzIG1vZGlmaWVkKS5cbiAgICAqL1xuICAgICRhbmNob3IsIFxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCBoZWFkIG9mIHRoZSBzZWxlY3Rpb24gKHRoZSBzaWRlIHRoYXQgbW92ZXMgd2hlblxuICAgIHRoZSBzZWxlY3Rpb24gaXMgbW9kaWZpZWQpLlxuICAgICovXG4gICAgJGhlYWQsIHJhbmdlcykge1xuICAgICAgICB0aGlzLiRhbmNob3IgPSAkYW5jaG9yO1xuICAgICAgICB0aGlzLiRoZWFkID0gJGhlYWQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzIHx8IFtuZXcgU2VsZWN0aW9uUmFuZ2UoJGFuY2hvci5taW4oJGhlYWQpLCAkYW5jaG9yLm1heCgkaGVhZCkpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNlbGVjdGlvbidzIGFuY2hvciwgYXMgYW4gdW5yZXNvbHZlZCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBhbmNob3IoKSB7IHJldHVybiB0aGlzLiRhbmNob3IucG9zOyB9XG4gICAgLyoqXG4gICAgVGhlIHNlbGVjdGlvbidzIGhlYWQuXG4gICAgKi9cbiAgICBnZXQgaGVhZCgpIHsgcmV0dXJuIHRoaXMuJGhlYWQucG9zOyB9XG4gICAgLyoqXG4gICAgVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLiRmcm9tLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSB1cHBlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuJHRvLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCBsb3dlciAgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgJGZyb20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1swXS4kZnJvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHJlc29sdmVkIHVwcGVyIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxuICAgICovXG4gICAgZ2V0ICR0bygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzWzBdLiR0bztcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBjb250YWlucyBhbnkgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMucmFuZ2VzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChyYW5nZXNbaV0uJGZyb20ucG9zICE9IHJhbmdlc1tpXS4kdG8ucG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGVudCBvZiB0aGlzIHNlbGVjdGlvbiBhcyBhIHNsaWNlLlxuICAgICovXG4gICAgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGZyb20uZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50bywgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgc2xpY2Ugb3IsIGlmIG5vIHNsaWNlIGlzIGdpdmVuLFxuICAgIGRlbGV0ZSB0aGUgc2VsZWN0aW9uLiBXaWxsIGFwcGVuZCB0byB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgLy8gUHV0IHRoZSBuZXcgc2VsZWN0aW9uIGF0IHRoZSBwb3NpdGlvbiBhZnRlciB0aGUgaW5zZXJ0ZWRcbiAgICAgICAgLy8gY29udGVudC4gV2hlbiB0aGF0IGVuZGVkIGluIGFuIGlubGluZSBub2RlLCBzZWFyY2ggYmFja3dhcmRzLFxuICAgICAgICAvLyB0byBnZXQgdGhlIHBvc2l0aW9uIGFmdGVyIHRoYXQgbm9kZS4gSWYgbm90LCBzZWFyY2ggZm9yd2FyZC5cbiAgICAgICAgbGV0IGxhc3ROb2RlID0gY29udGVudC5jb250ZW50Lmxhc3RDaGlsZCwgbGFzdFBhcmVudCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5vcGVuRW5kOyBpKyspIHtcbiAgICAgICAgICAgIGxhc3RQYXJlbnQgPSBsYXN0Tm9kZTtcbiAgICAgICAgICAgIGxhc3ROb2RlID0gbGFzdE5vZGUubGFzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoLCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXSwgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgICAgICB0ci5yZXBsYWNlUmFuZ2UobWFwcGluZy5tYXAoJGZyb20ucG9zKSwgbWFwcGluZy5tYXAoJHRvLnBvcyksIGkgPyBTbGljZS5lbXB0eSA6IGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKGkgPT0gMClcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgbWFwRnJvbSwgKGxhc3ROb2RlID8gbGFzdE5vZGUuaXNJbmxpbmUgOiBsYXN0UGFyZW50ICYmIGxhc3RQYXJlbnQuaXNUZXh0YmxvY2spID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gbm9kZSwgYXBwZW5kaW5nIHRoZSBjaGFuZ2VzXG4gICAgdG8gdGhlIGdpdmVuIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgcmVwbGFjZVdpdGgodHIsIG5vZGUpIHtcbiAgICAgICAgbGV0IG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGgsIHJhbmdlcyA9IHRoaXMucmFuZ2VzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldLCBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAoJGZyb20ucG9zKSwgdG8gPSBtYXBwaW5nLm1hcCgkdG8ucG9zKTtcbiAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHIucmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgbm9kZSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIG1hcEZyb20sIG5vZGUuaXNJbmxpbmUgPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgYSB2YWxpZCBjdXJzb3Igb3IgbGVhZiBub2RlIHNlbGVjdGlvbiBzdGFydGluZyBhdCB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbiBhbmQgc2VhcmNoaW5nIGJhY2sgaWYgYGRpcmAgaXMgbmVnYXRpdmUsIGFuZCBmb3J3YXJkIGlmXG4gICAgcG9zaXRpdmUuIFdoZW4gYHRleHRPbmx5YCBpcyB0cnVlLCBvbmx5IGNvbnNpZGVyIGN1cnNvclxuICAgIHNlbGVjdGlvbnMuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiBubyB2YWxpZCBzZWxlY3Rpb24gcG9zaXRpb24gaXNcbiAgICBmb3VuZC5cbiAgICAqL1xuICAgIHN0YXRpYyBmaW5kRnJvbSgkcG9zLCBkaXIsIHRleHRPbmx5ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGlubmVyID0gJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCA/IG5ldyBUZXh0U2VsZWN0aW9uKCRwb3MpXG4gICAgICAgICAgICA6IGZpbmRTZWxlY3Rpb25JbigkcG9zLm5vZGUoMCksICRwb3MucGFyZW50LCAkcG9zLnBvcywgJHBvcy5pbmRleCgpLCBkaXIsIHRleHRPbmx5KTtcbiAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9ICRwb3MuZGVwdGggLSAxOyBkZXB0aCA+PSAwOyBkZXB0aC0tKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBkaXIgPCAwXG4gICAgICAgICAgICAgICAgPyBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLm5vZGUoZGVwdGgpLCAkcG9zLmJlZm9yZShkZXB0aCArIDEpLCAkcG9zLmluZGV4KGRlcHRoKSwgZGlyLCB0ZXh0T25seSlcbiAgICAgICAgICAgICAgICA6IGZpbmRTZWxlY3Rpb25JbigkcG9zLm5vZGUoMCksICRwb3Mubm9kZShkZXB0aCksICRwb3MuYWZ0ZXIoZGVwdGggKyAxKSwgJHBvcy5pbmRleChkZXB0aCkgKyAxLCBkaXIsIHRleHRPbmx5KTtcbiAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgYSB2YWxpZCBjdXJzb3Igb3IgbGVhZiBub2RlIHNlbGVjdGlvbiBuZWFyIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLiBTZWFyY2hlcyBmb3J3YXJkIGZpcnN0IGJ5IGRlZmF1bHQsIGJ1dCBpZiBgYmlhc2AgaXNcbiAgICBuZWdhdGl2ZSwgaXQgd2lsbCBzZWFyY2ggYmFja3dhcmRzIGZpcnN0LlxuICAgICovXG4gICAgc3RhdGljIG5lYXIoJHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEZyb20oJHBvcywgYmlhcykgfHwgdGhpcy5maW5kRnJvbSgkcG9zLCAtYmlhcykgfHwgbmV3IEFsbFNlbGVjdGlvbigkcG9zLm5vZGUoMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjdXJzb3Igb3IgbGVhZiBub2RlIHNlbGVjdGlvbiBjbG9zZXN0IHRvIHRoZSBzdGFydCBvZlxuICAgIHRoZSBnaXZlbiBkb2N1bWVudC4gV2lsbCByZXR1cm4gYW5cbiAgICBbYEFsbFNlbGVjdGlvbmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5BbGxTZWxlY3Rpb24pIGlmIG5vIHZhbGlkIHBvc2l0aW9uXG4gICAgZXhpc3RzLlxuICAgICovXG4gICAgc3RhdGljIGF0U3RhcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBkb2MsIDAsIDAsIDEpIHx8IG5ldyBBbGxTZWxlY3Rpb24oZG9jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gY2xvc2VzdCB0byB0aGUgZW5kIG9mIHRoZVxuICAgIGdpdmVuIGRvY3VtZW50LlxuICAgICovXG4gICAgc3RhdGljIGF0RW5kKGRvYykge1xuICAgICAgICByZXR1cm4gZmluZFNlbGVjdGlvbkluKGRvYywgZG9jLCBkb2MuY29udGVudC5zaXplLCBkb2MuY2hpbGRDb3VudCwgLTEpIHx8IG5ldyBBbGxTZWxlY3Rpb24oZG9jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBzZWxlY3Rpb24uIE11c3QgYmVcbiAgICBpbXBsZW1lbnRlZCBmb3IgY3VzdG9tIGNsYXNzZXMgKGFzIGEgc3RhdGljIGNsYXNzIG1ldGhvZCkuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCAhanNvbi50eXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTZWxlY3Rpb24uZnJvbUpTT05cIik7XG4gICAgICAgIGxldCBjbHMgPSBjbGFzc2VzQnlJZFtqc29uLnR5cGVdO1xuICAgICAgICBpZiAoIWNscylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBObyBzZWxlY3Rpb24gdHlwZSAke2pzb24udHlwZX0gZGVmaW5lZGApO1xuICAgICAgICByZXR1cm4gY2xzLmZyb21KU09OKGRvYywganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRvIGJlIGFibGUgdG8gZGVzZXJpYWxpemUgc2VsZWN0aW9ucyBmcm9tIEpTT04sIGN1c3RvbSBzZWxlY3Rpb25cbiAgICBjbGFzc2VzIG11c3QgcmVnaXN0ZXIgdGhlbXNlbHZlcyB3aXRoIGFuIElEIHN0cmluZywgc28gdGhhdCB0aGV5XG4gICAgY2FuIGJlIGRpc2FtYmlndWF0ZWQuIFRyeSB0byBwaWNrIHNvbWV0aGluZyB0aGF0J3MgdW5saWtlbHkgdG9cbiAgICBjbGFzaCB3aXRoIGNsYXNzZXMgZnJvbSBvdGhlciBtb2R1bGVzLlxuICAgICovXG4gICAgc3RhdGljIGpzb25JRChpZCwgc2VsZWN0aW9uQ2xhc3MpIHtcbiAgICAgICAgaWYgKGlkIGluIGNsYXNzZXNCeUlkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEdXBsaWNhdGUgdXNlIG9mIHNlbGVjdGlvbiBKU09OIElEIFwiICsgaWQpO1xuICAgICAgICBjbGFzc2VzQnlJZFtpZF0gPSBzZWxlY3Rpb25DbGFzcztcbiAgICAgICAgc2VsZWN0aW9uQ2xhc3MucHJvdG90eXBlLmpzb25JRCA9IGlkO1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uQ2xhc3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFtib29rbWFya10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbkJvb2ttYXJrKSBmb3IgdGhpcyBzZWxlY3Rpb24sXG4gICAgd2hpY2ggaXMgYSB2YWx1ZSB0aGF0IGNhbiBiZSBtYXBwZWQgd2l0aG91dCBoYXZpbmcgYWNjZXNzIHRvIGFcbiAgICBjdXJyZW50IGRvY3VtZW50LCBhbmQgbGF0ZXIgcmVzb2x2ZWQgdG8gYSByZWFsIHNlbGVjdGlvbiBmb3IgYVxuICAgIGdpdmVuIGRvY3VtZW50IGFnYWluLiAoVGhpcyBpcyB1c2VkIG1vc3RseSBieSB0aGUgaGlzdG9yeSB0b1xuICAgIHRyYWNrIGFuZCByZXN0b3JlIG9sZCBzZWxlY3Rpb25zLikgVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2ZcbiAgICB0aGlzIG1ldGhvZCBqdXN0IGNvbnZlcnRzIHRoZSBzZWxlY3Rpb24gdG8gYSB0ZXh0IHNlbGVjdGlvbiBhbmRcbiAgICByZXR1cm5zIHRoZSBib29rbWFyayBmb3IgdGhhdC5cbiAgICAqL1xuICAgIGdldEJvb2ttYXJrKCkge1xuICAgICAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKHRoaXMuJGFuY2hvciwgdGhpcy4kaGVhZCkuZ2V0Qm9va21hcmsoKTtcbiAgICB9XG59XG5TZWxlY3Rpb24ucHJvdG90eXBlLnZpc2libGUgPSB0cnVlO1xuLyoqXG5SZXByZXNlbnRzIGEgc2VsZWN0ZWQgcmFuZ2UgaW4gYSBkb2N1bWVudC5cbiovXG5jbGFzcyBTZWxlY3Rpb25SYW5nZSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmFuZ2UuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbG93ZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgJGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSB1cHBlciBib3VuZCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICAkdG8pIHtcbiAgICAgICAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICAgICAgICB0aGlzLiR0byA9ICR0bztcbiAgICB9XG59XG5sZXQgd2FybmVkQWJvdXRUZXh0U2VsZWN0aW9uID0gZmFsc2U7XG5mdW5jdGlvbiBjaGVja1RleHRTZWxlY3Rpb24oJHBvcykge1xuICAgIGlmICghd2FybmVkQWJvdXRUZXh0U2VsZWN0aW9uICYmICEkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIHdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnNvbGVbXCJ3YXJuXCJdKFwiVGV4dFNlbGVjdGlvbiBlbmRwb2ludCBub3QgcG9pbnRpbmcgaW50byBhIG5vZGUgd2l0aCBpbmxpbmUgY29udGVudCAoXCIgKyAkcG9zLnBhcmVudC50eXBlLm5hbWUgKyBcIilcIik7XG4gICAgfVxufVxuLyoqXG5BIHRleHQgc2VsZWN0aW9uIHJlcHJlc2VudHMgYSBjbGFzc2ljYWwgZWRpdG9yIHNlbGVjdGlvbiwgd2l0aCBhXG5oZWFkICh0aGUgbW92aW5nIHNpZGUpIGFuZCBhbmNob3IgKGltbW9iaWxlIHNpZGUpLCBib3RoIG9mIHdoaWNoXG5wb2ludCBpbnRvIHRleHRibG9jayBub2Rlcy4gSXQgY2FuIGJlIGVtcHR5IChhIHJlZ3VsYXIgY3Vyc29yXG5wb3NpdGlvbikuXG4qL1xuY2xhc3MgVGV4dFNlbGVjdGlvbiBleHRlbmRzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgdGV4dCBzZWxlY3Rpb24gYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnRzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoJGFuY2hvciwgJGhlYWQgPSAkYW5jaG9yKSB7XG4gICAgICAgIGNoZWNrVGV4dFNlbGVjdGlvbigkYW5jaG9yKTtcbiAgICAgICAgY2hlY2tUZXh0U2VsZWN0aW9uKCRoZWFkKTtcbiAgICAgICAgc3VwZXIoJGFuY2hvciwgJGhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGEgcmVzb2x2ZWQgcG9zaXRpb24gaWYgdGhpcyBpcyBhIGN1cnNvciBzZWxlY3Rpb24gKGFuXG4gICAgZW1wdHkgdGV4dCBzZWxlY3Rpb24pLCBhbmQgbnVsbCBvdGhlcndpc2UuXG4gICAgKi9cbiAgICBnZXQgJGN1cnNvcigpIHsgcmV0dXJuIHRoaXMuJGFuY2hvci5wb3MgPT0gdGhpcy4kaGVhZC5wb3MgPyB0aGlzLiRoZWFkIDogbnVsbDsgfVxuICAgIG1hcChkb2MsIG1hcHBpbmcpIHtcbiAgICAgICAgbGV0ICRoZWFkID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy5oZWFkKSk7XG4gICAgICAgIGlmICghJGhlYWQucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJGhlYWQpO1xuICAgICAgICBsZXQgJGFuY2hvciA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuYW5jaG9yKSk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbigkYW5jaG9yLnBhcmVudC5pbmxpbmVDb250ZW50ID8gJGFuY2hvciA6ICRoZWFkLCAkaGVhZCk7XG4gICAgfVxuICAgIHJlcGxhY2UodHIsIGNvbnRlbnQgPSBTbGljZS5lbXB0eSkge1xuICAgICAgICBzdXBlci5yZXBsYWNlKHRyLCBjb250ZW50KTtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IHRoaXMuJGZyb20ubWFya3NBY3Jvc3ModGhpcy4kdG8pO1xuICAgICAgICAgICAgaWYgKG1hcmtzKVxuICAgICAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmIG90aGVyLmFuY2hvciA9PSB0aGlzLmFuY2hvciAmJiBvdGhlci5oZWFkID09IHRoaXMuaGVhZDtcbiAgICB9XG4gICAgZ2V0Qm9va21hcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEJvb2ttYXJrKHRoaXMuYW5jaG9yLCB0aGlzLmhlYWQpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwidGV4dFwiLCBhbmNob3I6IHRoaXMuYW5jaG9yLCBoZWFkOiB0aGlzLmhlYWQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5oZWFkICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFRleHRTZWxlY3Rpb24uZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbihkb2MucmVzb2x2ZShqc29uLmFuY2hvciksIGRvYy5yZXNvbHZlKGpzb24uaGVhZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB0ZXh0IHNlbGVjdGlvbiBmcm9tIG5vbi1yZXNvbHZlZCBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRvYywgYW5jaG9yLCBoZWFkID0gYW5jaG9yKSB7XG4gICAgICAgIGxldCAkYW5jaG9yID0gZG9jLnJlc29sdmUoYW5jaG9yKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKCRhbmNob3IsIGhlYWQgPT0gYW5jaG9yID8gJGFuY2hvciA6IGRvYy5yZXNvbHZlKGhlYWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgdGV4dCBzZWxlY3Rpb24gdGhhdCBzcGFucyB0aGUgZ2l2ZW4gcG9zaXRpb25zIG9yLCBpZlxuICAgIHRoZXkgYXJlbid0IHRleHQgcG9zaXRpb25zLCBmaW5kIGEgdGV4dCBzZWxlY3Rpb24gbmVhciB0aGVtLlxuICAgIGBiaWFzYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG1ldGhvZCBzZWFyY2hlcyBmb3J3YXJkIChkZWZhdWx0KVxuICAgIG9yIGJhY2t3YXJkcyAobmVnYXRpdmUgbnVtYmVyKSBmaXJzdC4gV2lsbCBmYWxsIGJhY2sgdG8gY2FsbGluZ1xuICAgIFtgU2VsZWN0aW9uLm5lYXJgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uXm5lYXIpIHdoZW4gdGhlIGRvY3VtZW50XG4gICAgZG9lc24ndCBjb250YWluIGEgdmFsaWQgdGV4dCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBiZXR3ZWVuKCRhbmNob3IsICRoZWFkLCBiaWFzKSB7XG4gICAgICAgIGxldCBkUG9zID0gJGFuY2hvci5wb3MgLSAkaGVhZC5wb3M7XG4gICAgICAgIGlmICghYmlhcyB8fCBkUG9zKVxuICAgICAgICAgICAgYmlhcyA9IGRQb3MgPj0gMCA/IDEgOiAtMTtcbiAgICAgICAgaWYgKCEkaGVhZC5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gU2VsZWN0aW9uLmZpbmRGcm9tKCRoZWFkLCBiaWFzLCB0cnVlKSB8fCBTZWxlY3Rpb24uZmluZEZyb20oJGhlYWQsIC1iaWFzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAkaGVhZCA9IGZvdW5kLiRoZWFkO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkaGVhZCwgYmlhcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkYW5jaG9yLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoZFBvcyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgJGFuY2hvciA9ICRoZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgJGFuY2hvciA9IChTZWxlY3Rpb24uZmluZEZyb20oJGFuY2hvciwgLWJpYXMsIHRydWUpIHx8IFNlbGVjdGlvbi5maW5kRnJvbSgkYW5jaG9yLCBiaWFzLCB0cnVlKSkuJGFuY2hvcjtcbiAgICAgICAgICAgICAgICBpZiAoKCRhbmNob3IucG9zIDwgJGhlYWQucG9zKSAhPSAoZFBvcyA8IDApKVxuICAgICAgICAgICAgICAgICAgICAkYW5jaG9yID0gJGhlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0U2VsZWN0aW9uKCRhbmNob3IsICRoZWFkKTtcbiAgICB9XG59XG5TZWxlY3Rpb24uanNvbklEKFwidGV4dFwiLCBUZXh0U2VsZWN0aW9uKTtcbmNsYXNzIFRleHRCb29rbWFyayB7XG4gICAgY29uc3RydWN0b3IoYW5jaG9yLCBoZWFkKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgICAgICB0aGlzLmhlYWQgPSBoZWFkO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRCb29rbWFyayhtYXBwaW5nLm1hcCh0aGlzLmFuY2hvciksIG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgIH1cbiAgICByZXNvbHZlKGRvYykge1xuICAgICAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKGRvYy5yZXNvbHZlKHRoaXMuYW5jaG9yKSwgZG9jLnJlc29sdmUodGhpcy5oZWFkKSk7XG4gICAgfVxufVxuLyoqXG5BIG5vZGUgc2VsZWN0aW9uIGlzIGEgc2VsZWN0aW9uIHRoYXQgcG9pbnRzIGF0IGEgc2luZ2xlIG5vZGUuIEFsbFxubm9kZXMgbWFya2VkIFtzZWxlY3RhYmxlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuc2VsZWN0YWJsZSkgY2FuIGJlIHRoZVxudGFyZ2V0IG9mIGEgbm9kZSBzZWxlY3Rpb24uIEluIHN1Y2ggYSBzZWxlY3Rpb24sIGBmcm9tYCBhbmQgYHRvYFxucG9pbnQgZGlyZWN0bHkgYmVmb3JlIGFuZCBhZnRlciB0aGUgc2VsZWN0ZWQgbm9kZSwgYGFuY2hvcmAgZXF1YWxzXG5gZnJvbWAsIGFuZCBgaGVhZGAgZXF1YWxzIGB0b2AuLlxuKi9cbmNsYXNzIE5vZGVTZWxlY3Rpb24gZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5vZGUgc2VsZWN0aW9uLiBEb2VzIG5vdCB2ZXJpZnkgdGhlIHZhbGlkaXR5IG9mIGl0c1xuICAgIGFyZ3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoJHBvcykge1xuICAgICAgICBsZXQgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgICBsZXQgJGVuZCA9ICRwb3Mubm9kZSgwKS5yZXNvbHZlKCRwb3MucG9zICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgICAgIHN1cGVyKCRwb3MsICRlbmQpO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cbiAgICBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCB7IGRlbGV0ZWQsIHBvcyB9ID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5hbmNob3IpO1xuICAgICAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICAgIGlmIChkZWxldGVkKVxuICAgICAgICAgICAgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oJHBvcyk7XG4gICAgfVxuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh0aGlzLm5vZGUpLCAwLCAwKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBvdGhlci5hbmNob3IgPT0gdGhpcy5hbmNob3I7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJub2RlXCIsIGFuY2hvcjogdGhpcy5hbmNob3IgfTtcbiAgICB9XG4gICAgZ2V0Qm9va21hcmsoKSB7IHJldHVybiBuZXcgTm9kZUJvb2ttYXJrKHRoaXMuYW5jaG9yKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE5vZGVTZWxlY3Rpb24uZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbihkb2MucmVzb2x2ZShqc29uLmFuY2hvcikpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIHNlbGVjdGlvbiBmcm9tIG5vbi1yZXNvbHZlZCBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRvYywgZnJvbSkge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oZG9jLnJlc29sdmUoZnJvbSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIG5vZGUgbWF5IGJlIHNlbGVjdGVkIGFzIGEgbm9kZVxuICAgIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBpc1NlbGVjdGFibGUobm9kZSkge1xuICAgICAgICByZXR1cm4gIW5vZGUuaXNUZXh0ICYmIG5vZGUudHlwZS5zcGVjLnNlbGVjdGFibGUgIT09IGZhbHNlO1xuICAgIH1cbn1cbk5vZGVTZWxlY3Rpb24ucHJvdG90eXBlLnZpc2libGUgPSBmYWxzZTtcblNlbGVjdGlvbi5qc29uSUQoXCJub2RlXCIsIE5vZGVTZWxlY3Rpb24pO1xuY2xhc3MgTm9kZUJvb2ttYXJrIHtcbiAgICBjb25zdHJ1Y3RvcihhbmNob3IpIHtcbiAgICAgICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCB7IGRlbGV0ZWQsIHBvcyB9ID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5hbmNob3IpO1xuICAgICAgICByZXR1cm4gZGVsZXRlZCA/IG5ldyBUZXh0Qm9va21hcmsocG9zLCBwb3MpIDogbmV3IE5vZGVCb29rbWFyayhwb3MpO1xuICAgIH1cbiAgICByZXNvbHZlKGRvYykge1xuICAgICAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHRoaXMuYW5jaG9yKSwgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgICBpZiAobm9kZSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKTtcbiAgICAgICAgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbn1cbi8qKlxuQSBzZWxlY3Rpb24gdHlwZSB0aGF0IHJlcHJlc2VudHMgc2VsZWN0aW5nIHRoZSB3aG9sZSBkb2N1bWVudFxuKHdoaWNoIGNhbiBub3QgbmVjZXNzYXJpbHkgYmUgZXhwcmVzc2VkIHdpdGggYSB0ZXh0IHNlbGVjdGlvbiwgd2hlblxudGhlcmUgYXJlIGZvciBleGFtcGxlIGxlYWYgYmxvY2sgbm9kZXMgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGVcbmRvY3VtZW50KS5cbiovXG5jbGFzcyBBbGxTZWxlY3Rpb24gZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBhbGwtc2VsZWN0aW9uIG92ZXIgdGhlIGdpdmVuIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoZG9jKSB7XG4gICAgICAgIHN1cGVyKGRvYy5yZXNvbHZlKDApLCBkb2MucmVzb2x2ZShkb2MuY29udGVudC5zaXplKSk7XG4gICAgfVxuICAgIHJlcGxhY2UodHIsIGNvbnRlbnQgPSBTbGljZS5lbXB0eSkge1xuICAgICAgICBpZiAoY29udGVudCA9PSBTbGljZS5lbXB0eSkge1xuICAgICAgICAgICAgdHIuZGVsZXRlKDAsIHRyLmRvYy5jb250ZW50LnNpemUpO1xuICAgICAgICAgICAgbGV0IHNlbCA9IFNlbGVjdGlvbi5hdFN0YXJ0KHRyLmRvYyk7XG4gICAgICAgICAgICBpZiAoIXNlbC5lcSh0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIucmVwbGFjZSh0ciwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkgeyByZXR1cm4geyB0eXBlOiBcImFsbFwiIH07IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MpIHsgcmV0dXJuIG5ldyBBbGxTZWxlY3Rpb24oZG9jKTsgfVxuICAgIG1hcChkb2MpIHsgcmV0dXJuIG5ldyBBbGxTZWxlY3Rpb24oZG9jKTsgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbjsgfVxuICAgIGdldEJvb2ttYXJrKCkgeyByZXR1cm4gQWxsQm9va21hcms7IH1cbn1cblNlbGVjdGlvbi5qc29uSUQoXCJhbGxcIiwgQWxsU2VsZWN0aW9uKTtcbmNvbnN0IEFsbEJvb2ttYXJrID0ge1xuICAgIG1hcCgpIHsgcmV0dXJuIHRoaXM7IH0sXG4gICAgcmVzb2x2ZShkb2MpIHsgcmV0dXJuIG5ldyBBbGxTZWxlY3Rpb24oZG9jKTsgfVxufTtcbi8vIEZJWE1FIHdlJ2xsIG5lZWQgc29tZSBhd2FyZW5lc3Mgb2YgdGV4dCBkaXJlY3Rpb24gd2hlbiBzY2FubmluZyBmb3Igc2VsZWN0aW9uc1xuLy8gVHJ5IHRvIGZpbmQgYSBzZWxlY3Rpb24gaW5zaWRlIHRoZSBnaXZlbiBub2RlLiBgcG9zYCBwb2ludHMgYXQgdGhlXG4vLyBwb3NpdGlvbiB3aGVyZSB0aGUgc2VhcmNoIHN0YXJ0cy4gV2hlbiBgdGV4dGAgaXMgdHJ1ZSwgb25seSByZXR1cm5cbi8vIHRleHQgc2VsZWN0aW9ucy5cbmZ1bmN0aW9uIGZpbmRTZWxlY3Rpb25Jbihkb2MsIG5vZGUsIHBvcywgaW5kZXgsIGRpciwgdGV4dCA9IGZhbHNlKSB7XG4gICAgaWYgKG5vZGUuaW5saW5lQ29udGVudClcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgcG9zKTtcbiAgICBmb3IgKGxldCBpID0gaW5kZXggLSAoZGlyID4gMCA/IDAgOiAxKTsgZGlyID4gMCA/IGkgPCBub2RlLmNoaWxkQ291bnQgOiBpID49IDA7IGkgKz0gZGlyKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IG5vZGUuY2hpbGQoaSk7XG4gICAgICAgIGlmICghY2hpbGQuaXNBdG9tKSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBmaW5kU2VsZWN0aW9uSW4oZG9jLCBjaGlsZCwgcG9zICsgZGlyLCBkaXIgPCAwID8gY2hpbGQuY2hpbGRDb3VudCA6IDAsIGRpciwgdGV4dCk7XG4gICAgICAgICAgICBpZiAoaW5uZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0ZXh0ICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGNoaWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVTZWxlY3Rpb24uY3JlYXRlKGRvYywgcG9zIC0gKGRpciA8IDAgPyBjaGlsZC5ub2RlU2l6ZSA6IDApKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gY2hpbGQubm9kZVNpemUgKiBkaXI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIHN0YXJ0TGVuLCBiaWFzKSB7XG4gICAgbGV0IGxhc3QgPSB0ci5zdGVwcy5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0IDwgc3RhcnRMZW4pXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgc3RlcCA9IHRyLnN0ZXBzW2xhc3RdO1xuICAgIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCB8fCBzdGVwIGluc3RhbmNlb2YgUmVwbGFjZUFyb3VuZFN0ZXApKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IG1hcCA9IHRyLm1hcHBpbmcubWFwc1tsYXN0XSwgZW5kO1xuICAgIG1hcC5mb3JFYWNoKChfZnJvbSwgX3RvLCBfbmV3RnJvbSwgbmV3VG8pID0+IHsgaWYgKGVuZCA9PSBudWxsKVxuICAgICAgICBlbmQgPSBuZXdUbzsgfSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKGVuZCksIGJpYXMpKTtcbn1cblxuY29uc3QgVVBEQVRFRF9TRUwgPSAxLCBVUERBVEVEX01BUktTID0gMiwgVVBEQVRFRF9TQ1JPTEwgPSA0O1xuLyoqXG5BbiBlZGl0b3Igc3RhdGUgdHJhbnNhY3Rpb24sIHdoaWNoIGNhbiBiZSBhcHBsaWVkIHRvIGEgc3RhdGUgdG9cbmNyZWF0ZSBhbiB1cGRhdGVkIHN0YXRlLiBVc2VcbltgRWRpdG9yU3RhdGUudHJgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudHIpIHRvIGNyZWF0ZSBhbiBpbnN0YW5jZS5cblxuVHJhbnNhY3Rpb25zIHRyYWNrIGNoYW5nZXMgdG8gdGhlIGRvY3VtZW50ICh0aGV5IGFyZSBhIHN1YmNsYXNzIG9mXG5bYFRyYW5zZm9ybWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uVHJhbnNmb3JtKSksIGJ1dCBhbHNvIG90aGVyIHN0YXRlIGNoYW5nZXMsXG5saWtlIHNlbGVjdGlvbiB1cGRhdGVzIGFuZCBhZGp1c3RtZW50cyBvZiB0aGUgc2V0IG9mIFtzdG9yZWRcbm1hcmtzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuc3RvcmVkTWFya3MpLiBJbiBhZGRpdGlvbiwgeW91IGNhbiBzdG9yZVxubWV0YWRhdGEgcHJvcGVydGllcyBpbiBhIHRyYW5zYWN0aW9uLCB3aGljaCBhcmUgZXh0cmEgcGllY2VzIG9mXG5pbmZvcm1hdGlvbiB0aGF0IGNsaWVudCBjb2RlIG9yIHBsdWdpbnMgY2FuIHVzZSB0byBkZXNjcmliZSB3aGF0IGFcbnRyYW5zYWN0aW9uIHJlcHJlc2VudHMsIHNvIHRoYXQgdGhleSBjYW4gdXBkYXRlIHRoZWlyIFtvd25cbnN0YXRlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuU3RhdGVGaWVsZCkgYWNjb3JkaW5nbHkuXG5cblRoZSBbZWRpdG9yIHZpZXddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcpIHVzZXMgYSBmZXcgbWV0YWRhdGFcbnByb3BlcnRpZXM6IGl0IHdpbGwgYXR0YWNoIGEgcHJvcGVydHkgYFwicG9pbnRlclwiYCB3aXRoIHRoZSB2YWx1ZVxuYHRydWVgIHRvIHNlbGVjdGlvbiB0cmFuc2FjdGlvbnMgZGlyZWN0bHkgY2F1c2VkIGJ5IG1vdXNlIG9yIHRvdWNoXG5pbnB1dCwgYSBgXCJjb21wb3NpdGlvblwiYCBwcm9wZXJ0eSBob2xkaW5nIGFuIElEIGlkZW50aWZ5aW5nIHRoZVxuY29tcG9zaXRpb24gdGhhdCBjYXVzZWQgaXQgdG8gdHJhbnNhY3Rpb25zIGNhdXNlZCBieSBjb21wb3NlZCBET01cbmlucHV0LCBhbmQgYSBgXCJ1aUV2ZW50XCJgIHByb3BlcnR5IG9mIHRoYXQgbWF5IGJlIGBcInBhc3RlXCJgLFxuYFwiY3V0XCJgLCBvciBgXCJkcm9wXCJgLlxuKi9cbmNsYXNzIFRyYW5zYWN0aW9uIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKHN0YXRlLmRvYyk7XG4gICAgICAgIC8vIFRoZSBzdGVwIGNvdW50IGZvciB3aGljaCB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgdmFsaWQuXG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gMDtcbiAgICAgICAgLy8gQml0ZmllbGQgdG8gdHJhY2sgd2hpY2ggYXNwZWN0cyBvZiB0aGUgc3RhdGUgd2VyZSB1cGRhdGVkIGJ5XG4gICAgICAgIC8vIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICAgIHRoaXMudXBkYXRlZCA9IDA7XG4gICAgICAgIC8vIE9iamVjdCB1c2VkIHRvIHN0b3JlIG1ldGFkYXRhIHByb3BlcnRpZXMgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgdGhpcy5tZXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy50aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIHRoaXMuc3RvcmVkTWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHRyYW5zYWN0aW9uJ3MgY3VycmVudCBzZWxlY3Rpb24uIFRoaXMgZGVmYXVsdHMgdG8gdGhlIGVkaXRvclxuICAgIHNlbGVjdGlvbiBbbWFwcGVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uLm1hcCkgdGhyb3VnaCB0aGUgc3RlcHMgaW4gdGhlXG4gICAgdHJhbnNhY3Rpb24sIGJ1dCBjYW4gYmUgb3ZlcndyaXR0ZW4gd2l0aFxuICAgIFtgc2V0U2VsZWN0aW9uYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNldFNlbGVjdGlvbikuXG4gICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJTZWxlY3Rpb25Gb3IgPCB0aGlzLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb24gPSB0aGlzLmN1clNlbGVjdGlvbi5tYXAodGhpcy5kb2MsIHRoaXMubWFwcGluZy5zbGljZSh0aGlzLmN1clNlbGVjdGlvbkZvcikpO1xuICAgICAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb25Gb3IgPSB0aGlzLnN0ZXBzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJTZWxlY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdHJhbnNhY3Rpb24ncyBjdXJyZW50IHNlbGVjdGlvbi4gV2lsbCBkZXRlcm1pbmUgdGhlXG4gICAgc2VsZWN0aW9uIHRoYXQgdGhlIGVkaXRvciBnZXRzIHdoZW4gdGhlIHRyYW5zYWN0aW9uIGlzIGFwcGxpZWQuXG4gICAgKi9cbiAgICBzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChzZWxlY3Rpb24uJGZyb20uZG9jICE9IHRoaXMuZG9jKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTZWxlY3Rpb24gcGFzc2VkIHRvIHNldFNlbGVjdGlvbiBtdXN0IHBvaW50IGF0IHRoZSBjdXJyZW50IGRvY3VtZW50XCIpO1xuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb25Gb3IgPSB0aGlzLnN0ZXBzLmxlbmd0aDtcbiAgICAgICAgdGhpcy51cGRhdGVkID0gKHRoaXMudXBkYXRlZCB8IFVQREFURURfU0VMKSAmIH5VUERBVEVEX01BUktTO1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiB3YXMgZXhwbGljaXRseSB1cGRhdGVkIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uU2V0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfU0VMKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCB0aGUgY3VycmVudCBzdG9yZWQgbWFya3MuXG4gICAgKi9cbiAgICBzZXRTdG9yZWRNYXJrcyhtYXJrcykge1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gbWFya3M7XG4gICAgICAgIHRoaXMudXBkYXRlZCB8PSBVUERBVEVEX01BUktTO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgTWFrZSBzdXJlIHRoZSBjdXJyZW50IHN0b3JlZCBtYXJrcyBvciwgaWYgdGhhdCBpcyBudWxsLCB0aGUgbWFya3NcbiAgICBhdCB0aGUgc2VsZWN0aW9uLCBtYXRjaCB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzLiBEb2VzIG5vdGhpbmcgaWZcbiAgICB0aGlzIGlzIGFscmVhZHkgdGhlIGNhc2UuXG4gICAgKi9cbiAgICBlbnN1cmVNYXJrcyhtYXJrcykge1xuICAgICAgICBpZiAoIU1hcmsuc2FtZVNldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCksIG1hcmtzKSlcbiAgICAgICAgICAgIHRoaXMuc2V0U3RvcmVkTWFya3MobWFya3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgbWFyayB0byB0aGUgc2V0IG9mIHN0b3JlZCBtYXJrcy5cbiAgICAqL1xuICAgIGFkZFN0b3JlZE1hcmsobWFyaykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVNYXJrcyhtYXJrLmFkZFRvU2V0KHRoaXMuc3RvcmVkTWFya3MgfHwgdGhpcy5zZWxlY3Rpb24uJGhlYWQubWFya3MoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgYSBtYXJrIG9yIG1hcmsgdHlwZSBmcm9tIHRoZSBzZXQgb2Ygc3RvcmVkIG1hcmtzLlxuICAgICovXG4gICAgcmVtb3ZlU3RvcmVkTWFyayhtYXJrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZU1hcmtzKG1hcmsucmVtb3ZlRnJvbVNldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc3RvcmVkIG1hcmtzIHdlcmUgZXhwbGljaXRseSBzZXQgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBnZXQgc3RvcmVkTWFya3NTZXQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9NQVJLUykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZFN0ZXAoc3RlcCwgZG9jKSB7XG4gICAgICAgIHN1cGVyLmFkZFN0ZXAoc3RlcCwgZG9jKTtcbiAgICAgICAgdGhpcy51cGRhdGVkID0gdGhpcy51cGRhdGVkICYgflVQREFURURfTUFSS1M7XG4gICAgICAgIHRoaXMuc3RvcmVkTWFya3MgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHRpbWVzdGFtcCBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgc2V0VGltZSh0aW1lKSB7XG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB3aXRoIHRoZSBnaXZlbiBzbGljZS5cbiAgICAqL1xuICAgIHJlcGxhY2VTZWxlY3Rpb24oc2xpY2UpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ucmVwbGFjZSh0aGlzLCBzbGljZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gbm9kZS4gV2hlbiBgaW5oZXJpdE1hcmtzYCBpc1xuICAgIHRydWUgYW5kIHRoZSBjb250ZW50IGlzIGlubGluZSwgaXQgaW5oZXJpdHMgdGhlIG1hcmtzIGZyb20gdGhlXG4gICAgcGxhY2Ugd2hlcmUgaXQgaXMgaW5zZXJ0ZWQuXG4gICAgKi9cbiAgICByZXBsYWNlU2VsZWN0aW9uV2l0aChub2RlLCBpbmhlcml0TWFya3MgPSB0cnVlKSB7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKGluaGVyaXRNYXJrcylcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm1hcmsodGhpcy5zdG9yZWRNYXJrcyB8fCAoc2VsZWN0aW9uLmVtcHR5ID8gc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkgOiAoc2VsZWN0aW9uLiRmcm9tLm1hcmtzQWNyb3NzKHNlbGVjdGlvbi4kdG8pIHx8IE1hcmsubm9uZSkpKTtcbiAgICAgICAgc2VsZWN0aW9uLnJlcGxhY2VXaXRoKHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIHRoZSBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBkZWxldGVTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlcGxhY2UodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBnaXZlbiByYW5nZSwgb3IgdGhlIHNlbGVjdGlvbiBpZiBubyByYW5nZSBpcyBnaXZlbixcbiAgICB3aXRoIGEgdGV4dCBub2RlIGNvbnRhaW5pbmcgdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIGluc2VydFRleHQodGV4dCwgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IHNjaGVtYSA9IHRoaXMuZG9jLnR5cGUuc2NoZW1hO1xuICAgICAgICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIXRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlU2VsZWN0aW9uV2l0aChzY2hlbWEudGV4dCh0ZXh0KSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0byA9IGZyb207XG4gICAgICAgICAgICB0byA9IHRvID09IG51bGwgPyBmcm9tIDogdG87XG4gICAgICAgICAgICBpZiAoIXRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICAgICAgbGV0IG1hcmtzID0gdGhpcy5zdG9yZWRNYXJrcztcbiAgICAgICAgICAgIGlmICghbWFya3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgJGZyb20gPSB0aGlzLmRvYy5yZXNvbHZlKGZyb20pO1xuICAgICAgICAgICAgICAgIG1hcmtzID0gdG8gPT0gZnJvbSA/ICRmcm9tLm1hcmtzKCkgOiAkZnJvbS5tYXJrc0Fjcm9zcyh0aGlzLmRvYy5yZXNvbHZlKHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIHNjaGVtYS50ZXh0KHRleHQsIG1hcmtzKSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmVtcHR5KVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRoaXMuc2VsZWN0aW9uLiR0bykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgU3RvcmUgYSBtZXRhZGF0YSBwcm9wZXJ0eSBpbiB0aGlzIHRyYW5zYWN0aW9uLCBrZXllZCBlaXRoZXIgYnlcbiAgICBuYW1lIG9yIGJ5IHBsdWdpbi5cbiAgICAqL1xuICAgIHNldE1ldGEoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm1ldGFbdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiID8ga2V5IDoga2V5LmtleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlIGEgbWV0YWRhdGEgcHJvcGVydHkgZm9yIGEgZ2l2ZW4gbmFtZSBvciBwbHVnaW4uXG4gICAgKi9cbiAgICBnZXRNZXRhKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRhW3R5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiA/IGtleSA6IGtleS5rZXldO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBkb2Vzbid0IGNvbnRhaW4gYW55IG1ldGFkYXRhLFxuICAgIGFuZCBjYW4gdGh1cyBzYWZlbHkgYmUgZXh0ZW5kZWQuXG4gICAgKi9cbiAgICBnZXQgaXNHZW5lcmljKCkge1xuICAgICAgICBmb3IgKGxldCBfIGluIHRoaXMubWV0YSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlIHRoYXQgdGhlIGVkaXRvciBzaG91bGQgc2Nyb2xsIHRoZSBzZWxlY3Rpb24gaW50byB2aWV3XG4gICAgd2hlbiB1cGRhdGVkIHRvIHRoZSBzdGF0ZSBwcm9kdWNlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgc2Nyb2xsSW50b1ZpZXcoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlZCB8PSBVUERBVEVEX1NDUk9MTDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBoYWQgYHNjcm9sbEludG9WaWV3YCBjYWxsZWQgb24gaXQuXG4gICAgKi9cbiAgICBnZXQgc2Nyb2xsZWRJbnRvVmlldygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnVwZGF0ZWQgJiBVUERBVEVEX1NDUk9MTCkgPiAwO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYmluZChmLCBzZWxmKSB7XG4gICAgcmV0dXJuICFzZWxmIHx8ICFmID8gZiA6IGYuYmluZChzZWxmKTtcbn1cbmNsYXNzIEZpZWxkRGVzYyB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgZGVzYywgc2VsZikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmluaXQgPSBiaW5kKGRlc2MuaW5pdCwgc2VsZik7XG4gICAgICAgIHRoaXMuYXBwbHkgPSBiaW5kKGRlc2MuYXBwbHksIHNlbGYpO1xuICAgIH1cbn1cbmNvbnN0IGJhc2VGaWVsZHMgPSBbXG4gICAgbmV3IEZpZWxkRGVzYyhcImRvY1wiLCB7XG4gICAgICAgIGluaXQoY29uZmlnKSB7IHJldHVybiBjb25maWcuZG9jIHx8IGNvbmZpZy5zY2hlbWEudG9wTm9kZVR5cGUuY3JlYXRlQW5kRmlsbCgpOyB9LFxuICAgICAgICBhcHBseSh0cikgeyByZXR1cm4gdHIuZG9jOyB9XG4gICAgfSksXG4gICAgbmV3IEZpZWxkRGVzYyhcInNlbGVjdGlvblwiLCB7XG4gICAgICAgIGluaXQoY29uZmlnLCBpbnN0YW5jZSkgeyByZXR1cm4gY29uZmlnLnNlbGVjdGlvbiB8fCBTZWxlY3Rpb24uYXRTdGFydChpbnN0YW5jZS5kb2MpOyB9LFxuICAgICAgICBhcHBseSh0cikgeyByZXR1cm4gdHIuc2VsZWN0aW9uOyB9XG4gICAgfSksXG4gICAgbmV3IEZpZWxkRGVzYyhcInN0b3JlZE1hcmtzXCIsIHtcbiAgICAgICAgaW5pdChjb25maWcpIHsgcmV0dXJuIGNvbmZpZy5zdG9yZWRNYXJrcyB8fCBudWxsOyB9LFxuICAgICAgICBhcHBseSh0ciwgX21hcmtzLCBfb2xkLCBzdGF0ZSkgeyByZXR1cm4gc3RhdGUuc2VsZWN0aW9uLiRjdXJzb3IgPyB0ci5zdG9yZWRNYXJrcyA6IG51bGw7IH1cbiAgICB9KSxcbiAgICBuZXcgRmllbGREZXNjKFwic2Nyb2xsVG9TZWxlY3Rpb25cIiwge1xuICAgICAgICBpbml0KCkgeyByZXR1cm4gMDsgfSxcbiAgICAgICAgYXBwbHkodHIsIHByZXYpIHsgcmV0dXJuIHRyLnNjcm9sbGVkSW50b1ZpZXcgPyBwcmV2ICsgMSA6IHByZXY7IH1cbiAgICB9KVxuXTtcbi8vIE9iamVjdCB3cmFwcGluZyB0aGUgcGFydCBvZiBhIHN0YXRlIG9iamVjdCB0aGF0IHN0YXlzIHRoZSBzYW1lXG4vLyBhY3Jvc3MgdHJhbnNhY3Rpb25zLiBTdG9yZWQgaW4gdGhlIHN0YXRlJ3MgYGNvbmZpZ2AgcHJvcGVydHkuXG5jbGFzcyBDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIHBsdWdpbnMpIHtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpbnNCeUtleSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuZmllbGRzID0gYmFzZUZpZWxkcy5zbGljZSgpO1xuICAgICAgICBpZiAocGx1Z2lucylcbiAgICAgICAgICAgIHBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBsdWdpbnNCeUtleVtwbHVnaW4ua2V5XSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBZGRpbmcgZGlmZmVyZW50IGluc3RhbmNlcyBvZiBhIGtleWVkIHBsdWdpbiAoXCIgKyBwbHVnaW4ua2V5ICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5zQnlLZXlbcGx1Z2luLmtleV0gPSBwbHVnaW47XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLnN0YXRlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKG5ldyBGaWVsZERlc2MocGx1Z2luLmtleSwgcGx1Z2luLnNwZWMuc3RhdGUsIHBsdWdpbikpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG5UaGUgc3RhdGUgb2YgYSBQcm9zZU1pcnJvciBlZGl0b3IgaXMgcmVwcmVzZW50ZWQgYnkgYW4gb2JqZWN0IG9mXG50aGlzIHR5cGUuIEEgc3RhdGUgaXMgYSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlXHUyMDE0aXQgaXNuJ3RcbnVwZGF0ZWQsIGJ1dCByYXRoZXIgYSBuZXcgc3RhdGUgdmFsdWUgaXMgY29tcHV0ZWQgZnJvbSBhbiBvbGQgb25lXG51c2luZyB0aGUgW2BhcHBseWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5hcHBseSkgbWV0aG9kLlxuXG5BIHN0YXRlIGhvbGRzIGEgbnVtYmVyIG9mIGJ1aWx0LWluIGZpZWxkcywgYW5kIHBsdWdpbnMgY2FuXG5bZGVmaW5lXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuUGx1Z2luU3BlYy5zdGF0ZSkgYWRkaXRpb25hbCBmaWVsZHMuXG4qL1xuY2xhc3MgRWRpdG9yU3RhdGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzY2hlbWEgb2YgdGhlIHN0YXRlJ3MgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuc2NoZW1hO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgcGx1Z2lucyB0aGF0IGFyZSBhY3RpdmUgaW4gdGhpcyBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBwbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcucGx1Z2lucztcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgdGhlIGdpdmVuIHRyYW5zYWN0aW9uIHRvIHByb2R1Y2UgYSBuZXcgc3RhdGUuXG4gICAgKi9cbiAgICBhcHBseSh0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseVRyYW5zYWN0aW9uKHRyKS5zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaWx0ZXJUcmFuc2FjdGlvbih0ciwgaWdub3JlID0gLTEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGkgIT0gaWdub3JlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuY29uZmlnLnBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uICYmICFwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbi5jYWxsKHBsdWdpbiwgdHIsIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBWZXJib3NlIHZhcmlhbnQgb2YgW2BhcHBseWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5hcHBseSkgdGhhdFxuICAgIHJldHVybnMgdGhlIHByZWNpc2UgdHJhbnNhY3Rpb25zIHRoYXQgd2VyZSBhcHBsaWVkICh3aGljaCBtaWdodFxuICAgIGJlIGluZmx1ZW5jZWQgYnkgdGhlIFt0cmFuc2FjdGlvblxuICAgIGhvb2tzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuUGx1Z2luU3BlYy5maWx0ZXJUcmFuc2FjdGlvbikgb2ZcbiAgICBwbHVnaW5zKSBhbG9uZyB3aXRoIHRoZSBuZXcgc3RhdGUuXG4gICAgKi9cbiAgICBhcHBseVRyYW5zYWN0aW9uKHJvb3RUcikge1xuICAgICAgICBpZiAoIXRoaXMuZmlsdGVyVHJhbnNhY3Rpb24ocm9vdFRyKSlcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiB0aGlzLCB0cmFuc2FjdGlvbnM6IFtdIH07XG4gICAgICAgIGxldCB0cnMgPSBbcm9vdFRyXSwgbmV3U3RhdGUgPSB0aGlzLmFwcGx5SW5uZXIocm9vdFRyKSwgc2VlbiA9IG51bGw7XG4gICAgICAgIC8vIFRoaXMgbG9vcCByZXBlYXRlZGx5IGdpdmVzIHBsdWdpbnMgYSBjaGFuY2UgdG8gcmVzcG9uZCB0b1xuICAgICAgICAvLyB0cmFuc2FjdGlvbnMgYXMgbmV3IHRyYW5zYWN0aW9ucyBhcmUgYWRkZWQsIG1ha2luZyBzdXJlIHRvIG9ubHlcbiAgICAgICAgLy8gcGFzcyB0aGUgdHJhbnNhY3Rpb25zIHRoZSBwbHVnaW4gZGlkIG5vdCBzZWUgYmVmb3JlLlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgaGF2ZU5ldyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuY29uZmlnLnBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuID0gc2VlbiA/IHNlZW5baV0ubiA6IDAsIG9sZFN0YXRlID0gc2VlbiA/IHNlZW5baV0uc3RhdGUgOiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHIgPSBuIDwgdHJzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLnNwZWMuYXBwZW5kVHJhbnNhY3Rpb24uY2FsbChwbHVnaW4sIG4gPyB0cnMuc2xpY2UobikgOiB0cnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ciAmJiBuZXdTdGF0ZS5maWx0ZXJUcmFuc2FjdGlvbih0ciwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJhcHBlbmRlZFRyYW5zYWN0aW9uXCIsIHJvb3RUcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVuID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVuLnB1c2goaiA8IGkgPyB7IHN0YXRlOiBuZXdTdGF0ZSwgbjogdHJzLmxlbmd0aCB9IDogeyBzdGF0ZTogdGhpcywgbjogMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRycy5wdXNoKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gbmV3U3RhdGUuYXBwbHlJbm5lcih0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlTmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW5baV0gPSB7IHN0YXRlOiBuZXdTdGF0ZSwgbjogdHJzLmxlbmd0aCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGF2ZU5ldylcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogbmV3U3RhdGUsIHRyYW5zYWN0aW9uczogdHJzIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhcHBseUlubmVyKHRyKSB7XG4gICAgICAgIGlmICghdHIuYmVmb3JlLmVxKHRoaXMuZG9jKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXBwbHlpbmcgYSBtaXNtYXRjaGVkIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICBsZXQgbmV3SW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUodGhpcy5jb25maWcpLCBmaWVsZHMgPSB0aGlzLmNvbmZpZy5maWVsZHM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgICAgICBuZXdJbnN0YW5jZVtmaWVsZC5uYW1lXSA9IGZpZWxkLmFwcGx5KHRyLCB0aGlzW2ZpZWxkLm5hbWVdLCB0aGlzLCBuZXdJbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0luc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGFydCBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uKSBmcm9tIHRoaXMgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgdHIoKSB7IHJldHVybiBuZXcgVHJhbnNhY3Rpb24odGhpcyk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGNvbmZpZykge1xuICAgICAgICBsZXQgJGNvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKGNvbmZpZy5kb2MgPyBjb25maWcuZG9jLnR5cGUuc2NoZW1hIDogY29uZmlnLnNjaGVtYSwgY29uZmlnLnBsdWdpbnMpO1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgJGNvbmZpZy5maWVsZHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpbnN0YW5jZVskY29uZmlnLmZpZWxkc1tpXS5uYW1lXSA9ICRjb25maWcuZmllbGRzW2ldLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHN0YXRlIGJhc2VkIG9uIHRoaXMgb25lLCBidXQgd2l0aCBhbiBhZGp1c3RlZCBzZXRcbiAgICBvZiBhY3RpdmUgcGx1Z2lucy4gU3RhdGUgZmllbGRzIHRoYXQgZXhpc3QgaW4gYm90aCBzZXRzIG9mXG4gICAgcGx1Z2lucyBhcmUga2VwdCB1bmNoYW5nZWQuIFRob3NlIHRoYXQgbm8gbG9uZ2VyIGV4aXN0IGFyZVxuICAgIGRyb3BwZWQsIGFuZCB0aG9zZSB0aGF0IGFyZSBuZXcgYXJlIGluaXRpYWxpemVkIHVzaW5nIHRoZWlyXG4gICAgW2Bpbml0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRmllbGQuaW5pdCkgbWV0aG9kLCBwYXNzaW5nIGluIHRoZSBuZXdcbiAgICBjb25maWd1cmF0aW9uIG9iamVjdC4uXG4gICAgKi9cbiAgICByZWNvbmZpZ3VyZShjb25maWcpIHtcbiAgICAgICAgbGV0ICRjb25maWcgPSBuZXcgQ29uZmlndXJhdGlvbih0aGlzLnNjaGVtYSwgY29uZmlnLnBsdWdpbnMpO1xuICAgICAgICBsZXQgZmllbGRzID0gJGNvbmZpZy5maWVsZHMsIGluc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKCRjb25maWcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBmaWVsZHNbaV0ubmFtZTtcbiAgICAgICAgICAgIGluc3RhbmNlW25hbWVdID0gdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHRoaXNbbmFtZV0gOiBmaWVsZHNbaV0uaW5pdChjb25maWcsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIHN0YXRlIHRvIEpTT04uIElmIHlvdSB3YW50IHRvIHNlcmlhbGl6ZSB0aGUgc3RhdGVcbiAgICBvZiBwbHVnaW5zLCBwYXNzIGFuIG9iamVjdCBtYXBwaW5nIHByb3BlcnR5IG5hbWVzIHRvIHVzZSBpbiB0aGVcbiAgICByZXN1bHRpbmcgSlNPTiBvYmplY3QgdG8gcGx1Z2luIG9iamVjdHMuIFRoZSBhcmd1bWVudCBtYXkgYWxzbyBiZVxuICAgIGEgc3RyaW5nIG9yIG51bWJlciwgaW4gd2hpY2ggY2FzZSBpdCBpcyBpZ25vcmVkLCB0byBzdXBwb3J0IHRoZVxuICAgIHdheSBgSlNPTi5zdHJpbmdpZnlgIGNhbGxzIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgICAqL1xuICAgIHRvSlNPTihwbHVnaW5GaWVsZHMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgZG9jOiB0aGlzLmRvYy50b0pTT04oKSwgc2VsZWN0aW9uOiB0aGlzLnNlbGVjdGlvbi50b0pTT04oKSB9O1xuICAgICAgICBpZiAodGhpcy5zdG9yZWRNYXJrcylcbiAgICAgICAgICAgIHJlc3VsdC5zdG9yZWRNYXJrcyA9IHRoaXMuc3RvcmVkTWFya3MubWFwKG0gPT4gbS50b0pTT04oKSk7XG4gICAgICAgIGlmIChwbHVnaW5GaWVsZHMgJiYgdHlwZW9mIHBsdWdpbkZpZWxkcyA9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gcGx1Z2luRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT0gXCJkb2NcIiB8fCBwcm9wID09IFwic2VsZWN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIEpTT04gZmllbGRzIGBkb2NgIGFuZCBgc2VsZWN0aW9uYCBhcmUgcmVzZXJ2ZWRcIik7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHBsdWdpbkZpZWxkc1twcm9wXSwgc3RhdGUgPSBwbHVnaW4uc3BlYy5zdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9KU09OKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSBzdGF0ZS50b0pTT04uY2FsbChwbHVnaW4sIHRoaXNbcGx1Z2luLmtleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBzdGF0ZS4gYGNvbmZpZ2Agc2hvdWxkXG4gICAgaGF2ZSBhdCBsZWFzdCBhIGBzY2hlbWFgIGZpZWxkLCBhbmQgc2hvdWxkIGNvbnRhaW4gYXJyYXkgb2ZcbiAgICBwbHVnaW5zIHRvIGluaXRpYWxpemUgdGhlIHN0YXRlIHdpdGguIGBwbHVnaW5GaWVsZHNgIGNhbiBiZSB1c2VkXG4gICAgdG8gZGVzZXJpYWxpemUgdGhlIHN0YXRlIG9mIHBsdWdpbnMsIGJ5IGFzc29jaWF0aW5nIHBsdWdpblxuICAgIGluc3RhbmNlcyB3aXRoIHRoZSBwcm9wZXJ0eSBuYW1lcyB0aGV5IHVzZSBpbiB0aGUgSlNPTiBvYmplY3QuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oY29uZmlnLCBqc29uLCBwbHVnaW5GaWVsZHMpIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBFZGl0b3JTdGF0ZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgaWYgKCFjb25maWcuc2NoZW1hKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZXF1aXJlZCBjb25maWcgZmllbGQgJ3NjaGVtYScgbWlzc2luZ1wiKTtcbiAgICAgICAgbGV0ICRjb25maWcgPSBuZXcgQ29uZmlndXJhdGlvbihjb25maWcuc2NoZW1hLCBjb25maWcucGx1Z2lucyk7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcbiAgICAgICAgJGNvbmZpZy5maWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGQubmFtZSA9PSBcImRvY1wiKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZG9jID0gTm9kZS5mcm9tSlNPTihjb25maWcuc2NoZW1hLCBqc29uLmRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5uYW1lID09IFwic2VsZWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZWxlY3Rpb24gPSBTZWxlY3Rpb24uZnJvbUpTT04oaW5zdGFuY2UuZG9jLCBqc29uLnNlbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5uYW1lID09IFwic3RvcmVkTWFya3NcIikge1xuICAgICAgICAgICAgICAgIGlmIChqc29uLnN0b3JlZE1hcmtzKVxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdG9yZWRNYXJrcyA9IGpzb24uc3RvcmVkTWFya3MubWFwKGNvbmZpZy5zY2hlbWEubWFya0Zyb21KU09OKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5GaWVsZHMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gcGx1Z2luRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gcGx1Z2luRmllbGRzW3Byb3BdLCBzdGF0ZSA9IHBsdWdpbi5zcGVjLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5rZXkgPT0gZmllbGQubmFtZSAmJiBzdGF0ZSAmJiBzdGF0ZS5mcm9tSlNPTiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChqc29uLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlW2ZpZWxkLm5hbWVdID0gc3RhdGUuZnJvbUpTT04uY2FsbChwbHVnaW4sIGNvbmZpZywganNvbltwcm9wXSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RhbmNlW2ZpZWxkLm5hbWVdID0gZmllbGQuaW5pdChjb25maWcsIGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRQcm9wcyhvYmosIHNlbGYsIHRhcmdldCkge1xuICAgIGZvciAobGV0IHByb3AgaW4gb2JqKSB7XG4gICAgICAgIGxldCB2YWwgPSBvYmpbcHJvcF07XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICAgIHZhbCA9IHZhbC5iaW5kKHNlbGYpO1xuICAgICAgICBlbHNlIGlmIChwcm9wID09IFwiaGFuZGxlRE9NRXZlbnRzXCIpXG4gICAgICAgICAgICB2YWwgPSBiaW5kUHJvcHModmFsLCBzZWxmLCB7fSk7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuUGx1Z2lucyBidW5kbGUgZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBhZGRlZCB0byBhbiBlZGl0b3IuXG5UaGV5IGFyZSBwYXJ0IG9mIHRoZSBbZWRpdG9yIHN0YXRlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUpIGFuZFxubWF5IGluZmx1ZW5jZSB0aGF0IHN0YXRlIGFuZCB0aGUgdmlldyB0aGF0IGNvbnRhaW5zIGl0LlxuKi9cbmNsYXNzIFBsdWdpbiB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBsdWdpbidzIFtzcGVjIG9iamVjdF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMpLlxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIFtwcm9wc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMpIGV4cG9ydGVkIGJ5IHRoaXMgcGx1Z2luLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BzID0ge307XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgYmluZFByb3BzKHNwZWMucHJvcHMsIHRoaXMsIHRoaXMucHJvcHMpO1xuICAgICAgICB0aGlzLmtleSA9IHNwZWMua2V5ID8gc3BlYy5rZXkua2V5IDogY3JlYXRlS2V5KFwicGx1Z2luXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRyYWN0IHRoZSBwbHVnaW4ncyBzdGF0ZSBmaWVsZCBmcm9tIGFuIGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIGdldFN0YXRlKHN0YXRlKSB7IHJldHVybiBzdGF0ZVt0aGlzLmtleV07IH1cbn1cbmNvbnN0IGtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gY3JlYXRlS2V5KG5hbWUpIHtcbiAgICBpZiAobmFtZSBpbiBrZXlzKVxuICAgICAgICByZXR1cm4gbmFtZSArIFwiJFwiICsgKytrZXlzW25hbWVdO1xuICAgIGtleXNbbmFtZV0gPSAwO1xuICAgIHJldHVybiBuYW1lICsgXCIkXCI7XG59XG4vKipcbkEga2V5IGlzIHVzZWQgdG8gW3RhZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMua2V5KSBwbHVnaW5zIGluIGEgd2F5XG50aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvIGZpbmQgdGhlbSwgZ2l2ZW4gYW4gZWRpdG9yIHN0YXRlLlxuQXNzaWduaW5nIGEga2V5IGRvZXMgbWVhbiBvbmx5IG9uZSBwbHVnaW4gb2YgdGhhdCB0eXBlIGNhbiBiZVxuYWN0aXZlIGluIGEgc3RhdGUuXG4qL1xuY2xhc3MgUGx1Z2luS2V5IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwbHVnaW4ga2V5LlxuICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSA9IFwia2V5XCIpIHsgdGhpcy5rZXkgPSBjcmVhdGVLZXkobmFtZSk7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGFjdGl2ZSBwbHVnaW4gd2l0aCB0aGlzIGtleSwgaWYgYW55LCBmcm9tIGFuIGVkaXRvclxuICAgIHN0YXRlLlxuICAgICovXG4gICAgZ2V0KHN0YXRlKSB7IHJldHVybiBzdGF0ZS5jb25maWcucGx1Z2luc0J5S2V5W3RoaXMua2V5XTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcGx1Z2luJ3Mgc3RhdGUgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBnZXRTdGF0ZShzdGF0ZSkgeyByZXR1cm4gc3RhdGVbdGhpcy5rZXldOyB9XG59XG5cbmV4cG9ydCB7IEFsbFNlbGVjdGlvbiwgRWRpdG9yU3RhdGUsIE5vZGVTZWxlY3Rpb24sIFBsdWdpbiwgUGx1Z2luS2V5LCBTZWxlY3Rpb24sIFNlbGVjdGlvblJhbmdlLCBUZXh0U2VsZWN0aW9uLCBUcmFuc2FjdGlvbiB9O1xuIiwgImltcG9ydCB7IFRleHRTZWxlY3Rpb24sIE5vZGVTZWxlY3Rpb24sIEFsbFNlbGVjdGlvbiwgU2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgRE9NU2VyaWFsaXplciwgRnJhZ21lbnQsIE1hcmssIFNsaWNlLCBET01QYXJzZXIgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBkcm9wUG9pbnQgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuXG5jb25zdCBkb21JbmRleCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOzsgaW5kZXgrKykge1xuICAgICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59O1xuY29uc3QgcGFyZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbGV0IHBhcmVudCA9IG5vZGUuYXNzaWduZWRTbG90IHx8IG5vZGUucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxMSA/IHBhcmVudC5ob3N0IDogcGFyZW50O1xufTtcbmxldCByZXVzZWRSYW5nZSA9IG51bGw7XG4vLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgcmFuZ2UsIGJlY2F1c2UgRE9NIHJhbmdlXG4vLyBvYmplY3RzIGFyZSBldmVyeSBleHBlbnNpdmUsIGFuZCBrZWVwIHNsb3dpbmcgZG93biBzdWJzZXF1ZW50IERPTVxuLy8gdXBkYXRlcywgZm9yIHNvbWUgcmVhc29uLlxuY29uc3QgdGV4dFJhbmdlID0gZnVuY3Rpb24gKG5vZGUsIGZyb20sIHRvKSB7XG4gICAgbGV0IHJhbmdlID0gcmV1c2VkUmFuZ2UgfHwgKHJldXNlZFJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSk7XG4gICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIHRvID09IG51bGwgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiB0byk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgZnJvbSB8fCAwKTtcbiAgICByZXR1cm4gcmFuZ2U7XG59O1xuLy8gU2NhbnMgZm9yd2FyZCBhbmQgYmFja3dhcmQgdGhyb3VnaCBET00gcG9zaXRpb25zIGVxdWl2YWxlbnQgdG8gdGhlXG4vLyBnaXZlbiBvbmUgdG8gc2VlIGlmIHRoZSB0d28gYXJlIGluIHRoZSBzYW1lIHBsYWNlIChpLmUuIGFmdGVyIGFcbi8vIHRleHQgbm9kZSB2cyBhdCB0aGUgZW5kIG9mIHRoYXQgdGV4dCBub2RlKVxuY29uc3QgaXNFcXVpdmFsZW50UG9zaXRpb24gPSBmdW5jdGlvbiAobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYpIHtcbiAgICByZXR1cm4gdGFyZ2V0Tm9kZSAmJiAoc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgLTEpIHx8XG4gICAgICAgIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIDEpKTtcbn07XG5jb25zdCBhdG9tRWxlbWVudHMgPSAvXihpbWd8YnJ8aW5wdXR8dGV4dGFyZWF8aHIpJC9pO1xuZnVuY3Rpb24gc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgZGlyKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZSA9PSB0YXJnZXROb2RlICYmIG9mZiA9PSB0YXJnZXRPZmYpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG9mZiA9PSAoZGlyIDwgMCA/IDAgOiBub2RlU2l6ZShub2RlKSkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZVR5cGUgIT0gMSB8fCBoYXNCbG9ja0Rlc2Mobm9kZSkgfHwgYXRvbUVsZW1lbnRzLnRlc3Qobm9kZS5ub2RlTmFtZSkgfHxcbiAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZG9tSW5kZXgobm9kZSkgKyAoZGlyIDwgMCA/IDAgOiAxKTtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZiArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRpciA8IDAgPyBub2RlU2l6ZShub2RlKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBub2RlU2l6ZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc09uRWRnZShub2RlLCBvZmZzZXQsIHBhcmVudCkge1xuICAgIGZvciAobGV0IGF0U3RhcnQgPSBvZmZzZXQgPT0gMCwgYXRFbmQgPSBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSk7IGF0U3RhcnQgfHwgYXRFbmQ7KSB7XG4gICAgICAgIGlmIChub2RlID09IHBhcmVudClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgaW5kZXggPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBhdFN0YXJ0ID0gYXRTdGFydCAmJiBpbmRleCA9PSAwO1xuICAgICAgICBhdEVuZCA9IGF0RW5kICYmIGluZGV4ID09IG5vZGVTaXplKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0Jsb2NrRGVzYyhkb20pIHtcbiAgICBsZXQgZGVzYztcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpXG4gICAgICAgIGlmIChkZXNjID0gY3VyLnBtVmlld0Rlc2MpXG4gICAgICAgICAgICBicmVhaztcbiAgICByZXR1cm4gZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2sgJiYgKGRlc2MuZG9tID09IGRvbSB8fCBkZXNjLmNvbnRlbnRET00gPT0gZG9tKTtcbn1cbi8vIFdvcmsgYXJvdW5kIENocm9tZSBpc3N1ZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDc1MjNcbi8vIChpc0NvbGxhcHNlZCBpbmFwcHJvcHJpYXRlbHkgcmV0dXJucyB0cnVlIGluIHNoYWRvdyBkb20pXG5jb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBmdW5jdGlvbiAoZG9tU2VsKSB7XG4gICAgcmV0dXJuIGRvbVNlbC5mb2N1c05vZGUgJiYgaXNFcXVpdmFsZW50UG9zaXRpb24oZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG59O1xuZnVuY3Rpb24ga2V5RXZlbnQoa2V5Q29kZSwga2V5KSB7XG4gICAgbGV0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBldmVudC5pbml0RXZlbnQoXCJrZXlkb3duXCIsIHRydWUsIHRydWUpO1xuICAgIGV2ZW50LmtleUNvZGUgPSBrZXlDb2RlO1xuICAgIGV2ZW50LmtleSA9IGV2ZW50LmNvZGUgPSBrZXk7XG4gICAgcmV0dXJuIGV2ZW50O1xufVxuZnVuY3Rpb24gZGVlcEFjdGl2ZUVsZW1lbnQoZG9jKSB7XG4gICAgbGV0IGVsdCA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgIHdoaWxlIChlbHQgJiYgZWx0LnNoYWRvd1Jvb3QpXG4gICAgICAgIGVsdCA9IGVsdC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgcmV0dXJuIGVsdDtcbn1cbmZ1bmN0aW9uIGNhcmV0RnJvbVBvaW50KGRvYywgeCwgeSkge1xuICAgIGlmIChkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkge1xuICAgICAgICB0cnkgeyAvLyBGaXJlZm94IHRocm93cyBmb3IgdGhpcyBjYWxsIGluIGhhcmQtdG8tcHJlZGljdCBjaXJjdW1zdGFuY2VzICgjOTk0KVxuICAgICAgICAgICAgbGV0IHBvcyA9IGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlOiBwb3Mub2Zmc2V0Tm9kZSwgb2Zmc2V0OiBwb3Mub2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgIH1cbiAgICBpZiAoZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBvZmZzZXQ6IHJhbmdlLnN0YXJ0T2Zmc2V0IH07XG4gICAgfVxufVxuXG5jb25zdCBuYXYgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyBuYXZpZ2F0b3IgOiBudWxsO1xuY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IG51bGw7XG5jb25zdCBhZ2VudCA9IChuYXYgJiYgbmF2LnVzZXJBZ2VudCkgfHwgXCJcIjtcbmNvbnN0IGllX2VkZ2UgPSAvRWRnZVxcLyhcXGQrKS8uZXhlYyhhZ2VudCk7XG5jb25zdCBpZV91cHRvMTAgPSAvTVNJRSBcXGQvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWVfMTF1cCA9IC9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhhZ2VudCk7XG5jb25zdCBpZSA9ICEhKGllX3VwdG8xMCB8fCBpZV8xMXVwIHx8IGllX2VkZ2UpO1xuY29uc3QgaWVfdmVyc2lvbiA9IGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IGllXzExdXAgPyAraWVfMTF1cFsxXSA6IGllX2VkZ2UgPyAraWVfZWRnZVsxXSA6IDA7XG5jb25zdCBnZWNrbyA9ICFpZSAmJiAvZ2Vja29cXC8oXFxkKykvaS50ZXN0KGFnZW50KTtcbmdlY2tvICYmICsoL0ZpcmVmb3hcXC8oXFxkKykvLmV4ZWMoYWdlbnQpIHx8IFswLCAwXSlbMV07XG5jb25zdCBfY2hyb21lID0gIWllICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgY2hyb21lID0gISFfY2hyb21lO1xuY29uc3QgY2hyb21lX3ZlcnNpb24gPSBfY2hyb21lID8gK19jaHJvbWVbMV0gOiAwO1xuY29uc3Qgc2FmYXJpID0gIWllICYmICEhbmF2ICYmIC9BcHBsZSBDb21wdXRlci8udGVzdChuYXYudmVuZG9yKTtcbi8vIElzIHRydWUgZm9yIGJvdGggaU9TIGFuZCBpUGFkT1MgZm9yIGNvbnZlbmllbmNlXG5jb25zdCBpb3MgPSBzYWZhcmkgJiYgKC9Nb2JpbGVcXC9cXHcrLy50ZXN0KGFnZW50KSB8fCAhIW5hdiAmJiBuYXYubWF4VG91Y2hQb2ludHMgPiAyKTtcbmNvbnN0IG1hYyA9IGlvcyB8fCAobmF2ID8gL01hYy8udGVzdChuYXYucGxhdGZvcm0pIDogZmFsc2UpO1xuY29uc3Qgd2luZG93cyA9IG5hdiA/IC9XaW4vLnRlc3QobmF2LnBsYXRmb3JtKSA6IGZhbHNlO1xuY29uc3QgYW5kcm9pZCA9IC9BbmRyb2lkIFxcZC8udGVzdChhZ2VudCk7XG5jb25zdCB3ZWJraXQgPSAhIWRvYyAmJiBcIndlYmtpdEZvbnRTbW9vdGhpbmdcIiBpbiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuY29uc3Qgd2Via2l0X3ZlcnNpb24gPSB3ZWJraXQgPyArKC9cXGJBcHBsZVdlYktpdFxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMDtcblxuZnVuY3Rpb24gd2luZG93UmVjdChkb2MpIHtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgdG9wOiAwLCBib3R0b206IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IH07XG59XG5mdW5jdGlvbiBnZXRTaWRlKHZhbHVlLCBzaWRlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gdmFsdWUgOiB2YWx1ZVtzaWRlXTtcbn1cbmZ1bmN0aW9uIGNsaWVudFJlY3Qobm9kZSkge1xuICAgIGxldCByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyBBZGp1c3QgZm9yIGVsZW1lbnRzIHdpdGggc3R5bGUgXCJ0cmFuc2Zvcm06IHNjYWxlKClcIlxuICAgIGxldCBzY2FsZVggPSAocmVjdC53aWR0aCAvIG5vZGUub2Zmc2V0V2lkdGgpIHx8IDE7XG4gICAgbGV0IHNjYWxlWSA9IChyZWN0LmhlaWdodCAvIG5vZGUub2Zmc2V0SGVpZ2h0KSB8fCAxO1xuICAgIC8vIE1ha2Ugc3VyZSBzY3JvbGxiYXIgd2lkdGggaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIHJlY3RhbmdsZVxuICAgIHJldHVybiB7IGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QubGVmdCArIG5vZGUuY2xpZW50V2lkdGggKiBzY2FsZVgsXG4gICAgICAgIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBub2RlLmNsaWVudEhlaWdodCAqIHNjYWxlWSB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsUmVjdEludG9WaWV3KHZpZXcsIHJlY3QsIHN0YXJ0RE9NKSB7XG4gICAgbGV0IHNjcm9sbFRocmVzaG9sZCA9IHZpZXcuc29tZVByb3AoXCJzY3JvbGxUaHJlc2hvbGRcIikgfHwgMCwgc2Nyb2xsTWFyZ2luID0gdmlldy5zb21lUHJvcChcInNjcm9sbE1hcmdpblwiKSB8fCA1O1xuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50O1xuICAgIGZvciAobGV0IHBhcmVudCA9IHN0YXJ0RE9NIHx8IHZpZXcuZG9tOzsgcGFyZW50ID0gcGFyZW50Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgZWx0ID0gcGFyZW50O1xuICAgICAgICBsZXQgYXRUb3AgPSBlbHQgPT0gZG9jLmJvZHk7XG4gICAgICAgIGxldCBib3VuZGluZyA9IGF0VG9wID8gd2luZG93UmVjdChkb2MpIDogY2xpZW50UmVjdChlbHQpO1xuICAgICAgICBsZXQgbW92ZVggPSAwLCBtb3ZlWSA9IDA7XG4gICAgICAgIGlmIChyZWN0LnRvcCA8IGJvdW5kaW5nLnRvcCArIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcInRvcFwiKSlcbiAgICAgICAgICAgIG1vdmVZID0gLShib3VuZGluZy50b3AgLSByZWN0LnRvcCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInRvcFwiKSk7XG4gICAgICAgIGVsc2UgaWYgKHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tIC0gZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwiYm90dG9tXCIpKVxuICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wID4gYm91bmRpbmcuYm90dG9tIC0gYm91bmRpbmcudG9wXG4gICAgICAgICAgICAgICAgPyByZWN0LnRvcCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInRvcFwiKSAtIGJvdW5kaW5nLnRvcFxuICAgICAgICAgICAgICAgIDogcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJib3R0b21cIik7XG4gICAgICAgIGlmIChyZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0ICsgZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwibGVmdFwiKSlcbiAgICAgICAgICAgIG1vdmVYID0gLShib3VuZGluZy5sZWZ0IC0gcmVjdC5sZWZ0ICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwibGVmdFwiKSk7XG4gICAgICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcInJpZ2h0XCIpKVxuICAgICAgICAgICAgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJyaWdodFwiKTtcbiAgICAgICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICAgICAgICBpZiAoYXRUb3ApIHtcbiAgICAgICAgICAgICAgICBkb2MuZGVmYXVsdFZpZXcuc2Nyb2xsQnkobW92ZVgsIG1vdmVZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFggPSBlbHQuc2Nyb2xsTGVmdCwgc3RhcnRZID0gZWx0LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBpZiAobW92ZVkpXG4gICAgICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxUb3AgKz0gbW92ZVk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVYKVxuICAgICAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsTGVmdCArPSBtb3ZlWDtcbiAgICAgICAgICAgICAgICBsZXQgZFggPSBlbHQuc2Nyb2xsTGVmdCAtIHN0YXJ0WCwgZFkgPSBlbHQuc2Nyb2xsVG9wIC0gc3RhcnRZO1xuICAgICAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IHJlY3QubGVmdCAtIGRYLCB0b3A6IHJlY3QudG9wIC0gZFksIHJpZ2h0OiByZWN0LnJpZ2h0IC0gZFgsIGJvdHRvbTogcmVjdC5ib3R0b20gLSBkWSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhdFRvcCB8fCAvXihmaXhlZHxzdGlja3kpJC8udGVzdChnZXRDb21wdXRlZFN0eWxlKHBhcmVudCkucG9zaXRpb24pKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuLy8gU3RvcmUgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWRpdG9yJ3MgcGFyZW50IG5vZGVzLCBhbG9uZyB3aXRoXG4vLyB0aGUgdG9wIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgbmVhciB0aGUgdG9wIG9mIHRoZSBlZGl0b3IsIHdoaWNoXG4vLyB3aWxsIGJlIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSB2aXNpYmxlIHZpZXdwb3J0IHJlbWFpbnMgc3RhYmxlIGV2ZW5cbi8vIHdoZW4gdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgYWJvdmUgY2hhbmdlcy5cbmZ1bmN0aW9uIHN0b3JlU2Nyb2xsUG9zKHZpZXcpIHtcbiAgICBsZXQgcmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzdGFydFkgPSBNYXRoLm1heCgwLCByZWN0LnRvcCk7XG4gICAgbGV0IHJlZkRPTSwgcmVmVG9wO1xuICAgIGZvciAobGV0IHggPSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLCB5ID0gc3RhcnRZICsgMTsgeSA8IE1hdGgubWluKGlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7IHkgKz0gNSkge1xuICAgICAgICBsZXQgZG9tID0gdmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmICghZG9tIHx8IGRvbSA9PSB2aWV3LmRvbSB8fCAhdmlldy5kb20uY29udGFpbnMoZG9tKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgbG9jYWxSZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobG9jYWxSZWN0LnRvcCA+PSBzdGFydFkgLSAyMCkge1xuICAgICAgICAgICAgcmVmRE9NID0gZG9tO1xuICAgICAgICAgICAgcmVmVG9wID0gbG9jYWxSZWN0LnRvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHJlZkRPTTogcmVmRE9NLCByZWZUb3A6IHJlZlRvcCwgc3RhY2s6IHNjcm9sbFN0YWNrKHZpZXcuZG9tKSB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsU3RhY2soZG9tKSB7XG4gICAgbGV0IHN0YWNrID0gW10sIGRvYyA9IGRvbS5vd25lckRvY3VtZW50O1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBwYXJlbnROb2RlKGN1cikpIHtcbiAgICAgICAgc3RhY2sucHVzaCh7IGRvbTogY3VyLCB0b3A6IGN1ci5zY3JvbGxUb3AsIGxlZnQ6IGN1ci5zY3JvbGxMZWZ0IH0pO1xuICAgICAgICBpZiAoZG9tID09IGRvYylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2s7XG59XG4vLyBSZXNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBlZGl0b3IncyBwYXJlbnQgbm9kZXMgdG8gdGhhdCB3aGF0XG4vLyBpdCB3YXMgYmVmb3JlLCB3aGVuIHN0b3JlU2Nyb2xsUG9zIHdhcyBjYWxsZWQuXG5mdW5jdGlvbiByZXNldFNjcm9sbFBvcyh7IHJlZkRPTSwgcmVmVG9wLCBzdGFjayB9KSB7XG4gICAgbGV0IG5ld1JlZlRvcCA9IHJlZkRPTSA/IHJlZkRPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgOiAwO1xuICAgIHJlc3RvcmVTY3JvbGxTdGFjayhzdGFjaywgbmV3UmVmVG9wID09IDAgPyAwIDogbmV3UmVmVG9wIC0gcmVmVG9wKTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JvbGxTdGFjayhzdGFjaywgZFRvcCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgZG9tLCB0b3AsIGxlZnQgfSA9IHN0YWNrW2ldO1xuICAgICAgICBpZiAoZG9tLnNjcm9sbFRvcCAhPSB0b3AgKyBkVG9wKVxuICAgICAgICAgICAgZG9tLnNjcm9sbFRvcCA9IHRvcCArIGRUb3A7XG4gICAgICAgIGlmIChkb20uc2Nyb2xsTGVmdCAhPSBsZWZ0KVxuICAgICAgICAgICAgZG9tLnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgIH1cbn1cbmxldCBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gbnVsbDtcbi8vIEZlYXR1cmUtZGV0ZWN0cyBzdXBwb3J0IGZvciAuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KSwgYW5kIHVzZXNcbi8vIGEgZmFsbGJhY2sga2x1ZGdlIHdoZW4gbm90IHN1cHBvcnRlZC5cbmZ1bmN0aW9uIGZvY3VzUHJldmVudFNjcm9sbChkb20pIHtcbiAgICBpZiAoZG9tLnNldEFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGRvbS5zZXRBY3RpdmUoKTsgLy8gaW4gSUVcbiAgICBpZiAocHJldmVudFNjcm9sbFN1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKTtcbiAgICBsZXQgc3RvcmVkID0gc2Nyb2xsU3RhY2soZG9tKTtcbiAgICBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCA9PSBudWxsID8ge1xuICAgICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSB7IHByZXZlbnRTY3JvbGw6IHRydWUgfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmVzdG9yZVNjcm9sbFN0YWNrKHN0b3JlZCwgMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZE9mZnNldEluTm9kZShub2RlLCBjb29yZHMpIHtcbiAgICBsZXQgY2xvc2VzdCwgZHhDbG9zZXN0ID0gMmU4LCBjb29yZHNDbG9zZXN0LCBvZmZzZXQgPSAwO1xuICAgIGxldCByb3dCb3QgPSBjb29yZHMudG9wLCByb3dUb3AgPSBjb29yZHMudG9wO1xuICAgIGxldCBmaXJzdEJlbG93LCBjb29yZHNCZWxvdztcbiAgICBmb3IgKGxldCBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCwgY2hpbGRJbmRleCA9IDA7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nLCBjaGlsZEluZGV4KyspIHtcbiAgICAgICAgbGV0IHJlY3RzO1xuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHJlY3RzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJlY3RzID0gdGV4dFJhbmdlKGNoaWxkKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChyZWN0LnRvcCA8PSByb3dCb3QgJiYgcmVjdC5ib3R0b20gPj0gcm93VG9wKSB7XG4gICAgICAgICAgICAgICAgcm93Qm90ID0gTWF0aC5tYXgocmVjdC5ib3R0b20sIHJvd0JvdCk7XG4gICAgICAgICAgICAgICAgcm93VG9wID0gTWF0aC5taW4ocmVjdC50b3AsIHJvd1RvcCk7XG4gICAgICAgICAgICAgICAgbGV0IGR4ID0gcmVjdC5sZWZ0ID4gY29vcmRzLmxlZnQgPyByZWN0LmxlZnQgLSBjb29yZHMubGVmdFxuICAgICAgICAgICAgICAgICAgICA6IHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCA/IGNvb3Jkcy5sZWZ0IC0gcmVjdC5yaWdodCA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKGR4IDwgZHhDbG9zZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgZHhDbG9zZXN0ID0gZHg7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc0Nsb3Nlc3QgPSBkeCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDMgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjb29yZHMudG9wXG4gICAgICAgICAgICAgICAgICAgIH0gOiBjb29yZHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxICYmIGR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gY2hpbGRJbmRleCArIChjb29yZHMubGVmdCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWN0LnRvcCA+IGNvb3Jkcy50b3AgJiYgIWZpcnN0QmVsb3cgJiYgcmVjdC5sZWZ0IDw9IGNvb3Jkcy5sZWZ0ICYmIHJlY3QucmlnaHQgPj0gY29vcmRzLmxlZnQpIHtcbiAgICAgICAgICAgICAgICBmaXJzdEJlbG93ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgY29vcmRzQmVsb3cgPSB7IGxlZnQ6IE1hdGgubWF4KHJlY3QubGVmdCwgTWF0aC5taW4ocmVjdC5yaWdodCwgY29vcmRzLmxlZnQpKSwgdG9wOiByZWN0LnRvcCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjbG9zZXN0ICYmIChjb29yZHMubGVmdCA+PSByZWN0LnJpZ2h0ICYmIGNvb3Jkcy50b3AgPj0gcmVjdC50b3AgfHxcbiAgICAgICAgICAgICAgICBjb29yZHMubGVmdCA+PSByZWN0LmxlZnQgJiYgY29vcmRzLnRvcCA+PSByZWN0LmJvdHRvbSkpXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gY2hpbGRJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjbG9zZXN0ICYmIGZpcnN0QmVsb3cpIHtcbiAgICAgICAgY2xvc2VzdCA9IGZpcnN0QmVsb3c7XG4gICAgICAgIGNvb3Jkc0Nsb3Nlc3QgPSBjb29yZHNCZWxvdztcbiAgICAgICAgZHhDbG9zZXN0ID0gMDtcbiAgICB9XG4gICAgaWYgKGNsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICByZXR1cm4gZmluZE9mZnNldEluVGV4dChjbG9zZXN0LCBjb29yZHNDbG9zZXN0KTtcbiAgICBpZiAoIWNsb3Nlc3QgfHwgKGR4Q2xvc2VzdCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDEpKVxuICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQgfTtcbiAgICByZXR1cm4gZmluZE9mZnNldEluTm9kZShjbG9zZXN0LCBjb29yZHNDbG9zZXN0KTtcbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXRJblRleHQobm9kZSwgY29vcmRzKSB7XG4gICAgbGV0IGxlbiA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIGkgKyAxKTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgaSk7XG4gICAgICAgIGxldCByZWN0ID0gc2luZ2xlUmVjdChyYW5nZSwgMSk7XG4gICAgICAgIGlmIChyZWN0LnRvcCA9PSByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGkgKyAoY29vcmRzLmxlZnQgPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAwKSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IDAgfTtcbn1cbmZ1bmN0aW9uIGluUmVjdChjb29yZHMsIHJlY3QpIHtcbiAgICByZXR1cm4gY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0IC0gMSAmJiBjb29yZHMubGVmdCA8PSByZWN0LnJpZ2h0ICsgMSAmJlxuICAgICAgICBjb29yZHMudG9wID49IHJlY3QudG9wIC0gMSAmJiBjb29yZHMudG9wIDw9IHJlY3QuYm90dG9tICsgMTtcbn1cbmZ1bmN0aW9uIHRhcmdldEtsdWRnZShkb20sIGNvb3Jkcykge1xuICAgIGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50ICYmIC9ebGkkL2kudGVzdChwYXJlbnQubm9kZU5hbWUpICYmIGNvb3Jkcy5sZWZ0IDwgZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpXG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgcmV0dXJuIGRvbTtcbn1cbmZ1bmN0aW9uIHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKSB7XG4gICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSBmaW5kT2Zmc2V0SW5Ob2RlKGVsdCwgY29vcmRzKSwgYmlhcyA9IC0xO1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgIW5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBsZXQgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGJpYXMgPSByZWN0LmxlZnQgIT0gcmVjdC5yaWdodCAmJiBjb29yZHMubGVmdCA+IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogLTE7XG4gICAgfVxuICAgIHJldHVybiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIGJpYXMpO1xufVxuZnVuY3Rpb24gcG9zRnJvbUNhcmV0KHZpZXcsIG5vZGUsIG9mZnNldCwgY29vcmRzKSB7XG4gICAgLy8gQnJvd3NlciAoaW4gY2FyZXRQb3NpdGlvbi9SYW5nZUZyb21Qb2ludCkgd2lsbCBhZ3Jlc3NpdmVseVxuICAgIC8vIG5vcm1hbGl6ZSB0b3dhcmRzIG5lYXJieSBpbmxpbmUgbm9kZXMuIFNpbmNlIHdlIGFyZSBpbnRlcmVzdGVkIGluXG4gICAgLy8gcG9zaXRpb25zIGJldHdlZW4gYmxvY2sgbm9kZXMgdG9vLCB3ZSBmaXJzdCB3YWxrIHVwIHRoZSBoaWVyYXJjaHlcbiAgICAvLyBvZiBub2RlcyB0byBzZWUgaWYgdGhlcmUgYXJlIGJsb2NrIG5vZGVzIHRoYXQgdGhlIGNvb3JkaW5hdGVzXG4gICAgLy8gZmFsbCBvdXRzaWRlIG9mLiBJZiBzbywgd2UgdGFrZSB0aGUgcG9zaXRpb24gYmVmb3JlL2FmdGVyIHRoYXRcbiAgICAvLyBibG9jay4gSWYgbm90LCB3ZSBjYWxsIGBwb3NGcm9tRE9NYCBvbiB0aGUgcmF3IG5vZGUvb2Zmc2V0LlxuICAgIGxldCBvdXRzaWRlQmxvY2sgPSAtMTtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlLCBzYXdCbG9jayA9IGZhbHNlOzspIHtcbiAgICAgICAgaWYgKGN1ciA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhjdXIsIHRydWUpO1xuICAgICAgICBpZiAoIWRlc2MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGRlc2MuZG9tLm5vZGVUeXBlID09IDEgJiYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50ICYmICFzYXdCbG9jayB8fCAhZGVzYy5jb250ZW50RE9NKSkge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBkZXNjLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGlmIChkZXNjLm5vZGUuaXNCbG9jayAmJiBkZXNjLnBhcmVudCAmJiAhc2F3QmxvY2spIHtcbiAgICAgICAgICAgICAgICBzYXdCbG9jayA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0IHx8IHJlY3QudG9wID4gY29vcmRzLnRvcClcbiAgICAgICAgICAgICAgICAgICAgb3V0c2lkZUJsb2NrID0gZGVzYy5wb3NCZWZvcmU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjdC5yaWdodCA8IGNvb3Jkcy5sZWZ0IHx8IHJlY3QuYm90dG9tIDwgY29vcmRzLnRvcClcbiAgICAgICAgICAgICAgICAgICAgb3V0c2lkZUJsb2NrID0gZGVzYy5wb3NBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGVzYy5jb250ZW50RE9NICYmIG91dHNpZGVCbG9jayA8IDAgJiYgIWRlc2Mubm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgaW5zaWRlIGEgbGVhZiwgcmV0dXJuIHRoZSBzaWRlIG9mIHRoZSBsZWFmIGNsb3NlciB0byB0aGUgY29vcmRzXG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IGRlc2Mubm9kZS5pc0Jsb2NrID8gY29vcmRzLnRvcCA8IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDJcbiAgICAgICAgICAgICAgICAgICAgOiBjb29yZHMubGVmdCA8IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlZm9yZSA/IGRlc2MucG9zQmVmb3JlIDogZGVzYy5wb3NBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBkZXNjLmRvbS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gb3V0c2lkZUJsb2NrID4gLTEgPyBvdXRzaWRlQmxvY2sgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIC0xKTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRGcm9tUG9pbnQoZWxlbWVudCwgY29vcmRzLCBib3gpIHtcbiAgICBsZXQgbGVuID0gZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICBpZiAobGVuICYmIGJveC50b3AgPCBib3guYm90dG9tKSB7XG4gICAgICAgIGZvciAobGV0IHN0YXJ0SSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxlbiAtIDEsIE1hdGguZmxvb3IobGVuICogKGNvb3Jkcy50b3AgLSBib3gudG9wKSAvIChib3guYm90dG9tIC0gYm94LnRvcCkpIC0gMikpLCBpID0gc3RhcnRJOzspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3RzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpblJlY3QoY29vcmRzLCByZWN0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50RnJvbVBvaW50KGNoaWxkLCBjb29yZHMsIHJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSA9IChpICsgMSkgJSBsZW4pID09IHN0YXJ0SSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbi8vIEdpdmVuIGFuIHgseSBwb3NpdGlvbiBvbiB0aGUgZWRpdG9yLCBnZXQgdGhlIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudC5cbmZ1bmN0aW9uIHBvc0F0Q29vcmRzKHZpZXcsIGNvb3Jkcykge1xuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50LCBub2RlLCBvZmZzZXQgPSAwO1xuICAgIGxldCBjYXJldCA9IGNhcmV0RnJvbVBvaW50KGRvYywgY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApO1xuICAgIGlmIChjYXJldClcbiAgICAgICAgKHsgbm9kZSwgb2Zmc2V0IH0gPSBjYXJldCk7XG4gICAgbGV0IGVsdCA9ICh2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCA/IHZpZXcucm9vdCA6IGRvYylcbiAgICAgICAgLmVsZW1lbnRGcm9tUG9pbnQoY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApO1xuICAgIGxldCBwb3M7XG4gICAgaWYgKCFlbHQgfHwgIXZpZXcuZG9tLmNvbnRhaW5zKGVsdC5ub2RlVHlwZSAhPSAxID8gZWx0LnBhcmVudE5vZGUgOiBlbHQpKSB7XG4gICAgICAgIGxldCBib3ggPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKCFpblJlY3QoY29vcmRzLCBib3gpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGVsdCA9IGVsZW1lbnRGcm9tUG9pbnQodmlldy5kb20sIGNvb3JkcywgYm94KTtcbiAgICAgICAgaWYgKCFlbHQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gU2FmYXJpJ3MgY2FyZXRSYW5nZUZyb21Qb2ludCByZXR1cm5zIG5vbnNlbnNlIHdoZW4gb24gYSBkcmFnZ2FibGUgZWxlbWVudFxuICAgIGlmIChzYWZhcmkpIHtcbiAgICAgICAgZm9yIChsZXQgcCA9IGVsdDsgbm9kZSAmJiBwOyBwID0gcGFyZW50Tm9kZShwKSlcbiAgICAgICAgICAgIGlmIChwLmRyYWdnYWJsZSlcbiAgICAgICAgICAgICAgICBub2RlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHQgPSB0YXJnZXRLbHVkZ2UoZWx0LCBjb29yZHMpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICAgIGlmIChnZWNrbyAmJiBub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggd2lsbCBzb21ldGltZXMgcmV0dXJuIG9mZnNldHMgaW50byA8aW5wdXQ+IG5vZGVzLCB3aGljaFxuICAgICAgICAgICAgLy8gaGF2ZSBubyBhY3R1YWwgY2hpbGRyZW4sIGZyb20gY2FyZXRQb3NpdGlvbkZyb21Qb2ludCAoIzk1MylcbiAgICAgICAgICAgIG9mZnNldCA9IE1hdGgubWluKG9mZnNldCwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAvLyBJdCdsbCBhbHNvIG1vdmUgdGhlIHJldHVybmVkIHBvc2l0aW9uIGJlZm9yZSBpbWFnZSBub2RlcyxcbiAgICAgICAgICAgIC8vIGV2ZW4gaWYgdGhvc2UgYXJlIGJlaGluZCBpdC5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSwgYm94O1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Lm5vZGVOYW1lID09IFwiSU1HXCIgJiYgKGJveCA9IG5leHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLnJpZ2h0IDw9IGNvb3Jkcy5sZWZ0ICYmXG4gICAgICAgICAgICAgICAgICAgIGJveC5ib3R0b20gPiBjb29yZHMudG9wKVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJldjtcbiAgICAgICAgLy8gV2hlbiBjbGlja2luZyBhYm92ZSB0aGUgcmlnaHQgc2lkZSBvZiBhbiB1bmVkaXRhYmxlIG5vZGUsIENocm9tZSB3aWxsIHJlcG9ydCBhIGN1cnNvciBwb3NpdGlvbiBhZnRlciB0aGF0IG5vZGUuXG4gICAgICAgIGlmICh3ZWJraXQgJiYgb2Zmc2V0ICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJiAocHJldiA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXSkubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgcHJldi5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiICYmIHByZXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wID49IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgLy8gU3VzcGljaW91c2x5IHNwZWNpZmljIGtsdWRnZSB0byB3b3JrIGFyb3VuZCBjYXJldCpGcm9tUG9pbnRcbiAgICAgICAgLy8gbmV2ZXIgcmV0dXJuaW5nIGEgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnRcbiAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20gJiYgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxICYmIG5vZGUubGFzdENoaWxkLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgICAgIGNvb3Jkcy50b3AgPiBub2RlLmxhc3RDaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20pXG4gICAgICAgICAgICBwb3MgPSB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemU7XG4gICAgICAgIC8vIElnbm9yZSBwb3NpdGlvbnMgZGlyZWN0bHkgYWZ0ZXIgYSBCUiwgc2luY2UgY2FyZXQqRnJvbVBvaW50XG4gICAgICAgIC8vICdyb3VuZCB1cCcgcG9zaXRpb25zIHRoYXQgd291bGQgYmUgbW9yZSBhY2N1cmF0ZWx5IHBsYWNlZFxuICAgICAgICAvLyBiZWZvcmUgdGhlIEJSIG5vZGUuXG4gICAgICAgIGVsc2UgaWYgKG9mZnNldCA9PSAwIHx8IG5vZGUubm9kZVR5cGUgIT0gMSB8fCBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0ubm9kZU5hbWUgIT0gXCJCUlwiKVxuICAgICAgICAgICAgcG9zID0gcG9zRnJvbUNhcmV0KHZpZXcsIG5vZGUsIG9mZnNldCwgY29vcmRzKTtcbiAgICB9XG4gICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICBwb3MgPSBwb3NGcm9tRWxlbWVudCh2aWV3LCBlbHQsIGNvb3Jkcyk7XG4gICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZWx0LCB0cnVlKTtcbiAgICByZXR1cm4geyBwb3MsIGluc2lkZTogZGVzYyA/IGRlc2MucG9zQXRTdGFydCAtIGRlc2MuYm9yZGVyIDogLTEgfTtcbn1cbmZ1bmN0aW9uIG5vblplcm8ocmVjdCkge1xuICAgIHJldHVybiByZWN0LnRvcCA8IHJlY3QuYm90dG9tIHx8IHJlY3QubGVmdCA8IHJlY3QucmlnaHQ7XG59XG5mdW5jdGlvbiBzaW5nbGVSZWN0KHRhcmdldCwgYmlhcykge1xuICAgIGxldCByZWN0cyA9IHRhcmdldC5nZXRDbGllbnRSZWN0cygpO1xuICAgIGlmIChyZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gcmVjdHNbYmlhcyA8IDAgPyAwIDogcmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChub25aZXJvKGZpcnN0KSlcbiAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwocmVjdHMsIG5vblplcm8pIHx8IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cbmNvbnN0IEJJREkgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY10vO1xuLy8gR2l2ZW4gYSBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQgbW9kZWwsIGdldCBhIGJvdW5kaW5nIGJveCBvZiB0aGVcbi8vIGNoYXJhY3RlciBhdCB0aGF0IHBvc2l0aW9uLCByZWxhdGl2ZSB0byB0aGUgd2luZG93LlxuZnVuY3Rpb24gY29vcmRzQXRQb3ModmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IHsgbm9kZSwgb2Zmc2V0LCBhdG9tIH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIHNpZGUgPCAwID8gLTEgOiAxKTtcbiAgICBsZXQgc3VwcG9ydEVtcHR5UmFuZ2UgPSB3ZWJraXQgfHwgZ2Vja287XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAvLyBUaGVzZSBicm93c2VycyBzdXBwb3J0IHF1ZXJ5aW5nIGVtcHR5IHRleHQgcmFuZ2VzLiBQcmVmZXIgdGhhdCBpblxuICAgICAgICAvLyBiaWRpIGNvbnRleHQgb3Igd2hlbiBhdCB0aGUgZW5kIG9mIGEgbm9kZS5cbiAgICAgICAgaWYgKHN1cHBvcnRFbXB0eVJhbmdlICYmIChCSURJLnRlc3Qobm9kZS5ub2RlVmFsdWUpIHx8IChzaWRlIDwgMCA/ICFvZmZzZXQgOiBvZmZzZXQgPT0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSkpIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgb2Zmc2V0LCBvZmZzZXQpLCBzaWRlKTtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggcmV0dXJucyBiYWQgcmVzdWx0cyAodGhlIHBvc2l0aW9uIGJlZm9yZSB0aGUgc3BhY2UpXG4gICAgICAgICAgICAvLyB3aGVuIHF1ZXJ5aW5nIGEgcG9zaXRpb24gZGlyZWN0bHkgYWZ0ZXIgbGluZS1icm9rZW5cbiAgICAgICAgICAgIC8vIHdoaXRlc3BhY2UuIERldGVjdCB0aGlzIHNpdHVhdGlvbiBhbmQgYW5kIGtsdWRnZSBhcm91bmQgaXRcbiAgICAgICAgICAgIGlmIChnZWNrbyAmJiBvZmZzZXQgJiYgL1xccy8udGVzdChub2RlLm5vZGVWYWx1ZVtvZmZzZXQgLSAxXSkgJiYgb2Zmc2V0IDwgbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3RCZWZvcmUgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQgLSAxLCBvZmZzZXQgLSAxKSwgLTEpO1xuICAgICAgICAgICAgICAgIGlmIChyZWN0QmVmb3JlLnRvcCA9PSByZWN0LnRvcCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdEFmdGVyID0gc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgb2Zmc2V0LCBvZmZzZXQgKyAxKSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdEFmdGVyLnRvcCAhPSByZWN0LnRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihyZWN0QWZ0ZXIsIHJlY3RBZnRlci5sZWZ0IDwgcmVjdEJlZm9yZS5sZWZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gb2Zmc2V0LCB0byA9IG9mZnNldCwgdGFrZVNpZGUgPSBzaWRlIDwgMCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGlmIChzaWRlIDwgMCAmJiAhb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgICAgICB0YWtlU2lkZSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2lkZSA+PSAwICYmIG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmcm9tLS07XG4gICAgICAgICAgICAgICAgdGFrZVNpZGUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2lkZSA8IDApIHtcbiAgICAgICAgICAgICAgICBmcm9tLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5WKHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIGZyb20sIHRvKSwgdGFrZVNpZGUpLCB0YWtlU2lkZSA8IDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCAkZG9tID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MgLSAoYXRvbSB8fCAwKSk7XG4gICAgLy8gUmV0dXJuIGEgaG9yaXpvbnRhbCBsaW5lIGluIGJsb2NrIGNvbnRleHRcbiAgICBpZiAoISRkb20ucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgJiYgKHNpZGUgPCAwIHx8IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKSkpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5IKGJlZm9yZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0IDwgbm9kZVNpemUobm9kZSkpIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGFmdGVyLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5IKGFmdGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhdHRlbkgobm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc2lkZSA+PSAwKTtcbiAgICB9XG4gICAgLy8gSW5saW5lLCBub3QgaW4gdGV4dCBub2RlICh0aGlzIGlzIG5vdCBCaWRpLXNhZmUpXG4gICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgJiYgKHNpZGUgPCAwIHx8IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKSkpIHtcbiAgICAgICAgbGV0IGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgbGV0IHRhcmdldCA9IGJlZm9yZS5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKGJlZm9yZSwgbm9kZVNpemUoYmVmb3JlKSAtIChzdXBwb3J0RW1wdHlSYW5nZSA/IDAgOiAxKSlcbiAgICAgICAgICAgIC8vIEJSIG5vZGVzIHRlbmQgdG8gb25seSByZXR1cm4gdGhlIHJlY3RhbmdsZSBiZWZvcmUgdGhlbS5cbiAgICAgICAgICAgIC8vIE9ubHkgdXNlIHRoZW0gaWYgdGhleSBhcmUgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGVpciBwYXJlbnRcbiAgICAgICAgICAgIDogYmVmb3JlLm5vZGVUeXBlID09IDEgJiYgKGJlZm9yZS5ub2RlTmFtZSAhPSBcIkJSXCIgfHwgIWJlZm9yZS5uZXh0U2libGluZykgPyBiZWZvcmUgOiBudWxsO1xuICAgICAgICBpZiAodGFyZ2V0KVxuICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5WKHNpbmdsZVJlY3QodGFyZ2V0LCAxKSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCA8IG5vZGVTaXplKG5vZGUpKSB7XG4gICAgICAgIGxldCBhZnRlciA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICB3aGlsZSAoYWZ0ZXIucG1WaWV3RGVzYyAmJiBhZnRlci5wbVZpZXdEZXNjLmlnbm9yZUZvckNvb3JkcylcbiAgICAgICAgICAgIGFmdGVyID0gYWZ0ZXIubmV4dFNpYmxpbmc7XG4gICAgICAgIGxldCB0YXJnZXQgPSAhYWZ0ZXIgPyBudWxsIDogYWZ0ZXIubm9kZVR5cGUgPT0gMyA/IHRleHRSYW5nZShhZnRlciwgMCwgKHN1cHBvcnRFbXB0eVJhbmdlID8gMCA6IDEpKVxuICAgICAgICAgICAgOiBhZnRlci5ub2RlVHlwZSA9PSAxID8gYWZ0ZXIgOiBudWxsO1xuICAgICAgICBpZiAodGFyZ2V0KVxuICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5WKHNpbmdsZVJlY3QodGFyZ2V0LCAtMSksIHRydWUpO1xuICAgIH1cbiAgICAvLyBBbGwgZWxzZSBmYWlsZWQsIGp1c3QgdHJ5IHRvIGdldCBhIHJlY3RhbmdsZSBmb3IgdGhlIHRhcmdldCBub2RlXG4gICAgcmV0dXJuIGZsYXR0ZW5WKHNpbmdsZVJlY3Qobm9kZS5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKG5vZGUpIDogbm9kZSwgLXNpZGUpLCBzaWRlID49IDApO1xufVxuZnVuY3Rpb24gZmxhdHRlblYocmVjdCwgbGVmdCkge1xuICAgIGlmIChyZWN0LndpZHRoID09IDApXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIGxldCB4ID0gbGVmdCA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQ7XG4gICAgcmV0dXJuIHsgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LmJvdHRvbSwgbGVmdDogeCwgcmlnaHQ6IHggfTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5IKHJlY3QsIHRvcCkge1xuICAgIGlmIChyZWN0LmhlaWdodCA9PSAwKVxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICBsZXQgeSA9IHRvcCA/IHJlY3QudG9wIDogcmVjdC5ib3R0b207XG4gICAgcmV0dXJuIHsgdG9wOiB5LCBib3R0b206IHksIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQgfTtcbn1cbmZ1bmN0aW9uIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsIGYpIHtcbiAgICBsZXQgdmlld1N0YXRlID0gdmlldy5zdGF0ZSwgYWN0aXZlID0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKHZpZXdTdGF0ZSAhPSBzdGF0ZSlcbiAgICAgICAgdmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgaWYgKGFjdGl2ZSAhPSB2aWV3LmRvbSlcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmKCk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBpZiAodmlld1N0YXRlICE9IHN0YXRlKVxuICAgICAgICAgICAgdmlldy51cGRhdGVTdGF0ZSh2aWV3U3RhdGUpO1xuICAgICAgICBpZiAoYWN0aXZlICE9IHZpZXcuZG9tICYmIGFjdGl2ZSlcbiAgICAgICAgICAgIGFjdGl2ZS5mb2N1cygpO1xuICAgIH1cbn1cbi8vIFdoZXRoZXIgdmVydGljYWwgcG9zaXRpb24gbW90aW9uIGluIGEgZ2l2ZW4gZGlyZWN0aW9uXG4vLyBmcm9tIGEgcG9zaXRpb24gd291bGQgbGVhdmUgYSB0ZXh0IGJsb2NrLlxuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2tWZXJ0aWNhbCh2aWV3LCBzdGF0ZSwgZGlyKSB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgJHBvcyA9IGRpciA9PSBcInVwXCIgPyBzZWwuJGZyb20gOiBzZWwuJHRvO1xuICAgIHJldHVybiB3aXRoRmx1c2hlZFN0YXRlKHZpZXcsIHN0YXRlLCAoKSA9PiB7XG4gICAgICAgIGxldCB7IG5vZGU6IGRvbSB9ID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MoJHBvcy5wb3MsIGRpciA9PSBcInVwXCIgPyAtMSA6IDEpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmVhcmVzdCA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhkb20sIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFuZWFyZXN0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKG5lYXJlc3Qubm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgZG9tID0gbmVhcmVzdC5jb250ZW50RE9NIHx8IG5lYXJlc3QuZG9tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tID0gbmVhcmVzdC5kb20ucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29vcmRzID0gY29vcmRzQXRQb3ModmlldywgJHBvcy5wb3MsIDEpO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCA9IGRvbS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgbGV0IGJveGVzO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAgYm94ZXMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICBib3hlcyA9IHRleHRSYW5nZShjaGlsZCwgMCwgY2hpbGQubm9kZVZhbHVlLmxlbmd0aCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYm94ID0gYm94ZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGJveC5ib3R0b20gPiBib3gudG9wICsgMSAmJlxuICAgICAgICAgICAgICAgICAgICAoZGlyID09IFwidXBcIiA/IGNvb3Jkcy50b3AgLSBib3gudG9wID4gKGJveC5ib3R0b20gLSBjb29yZHMudG9wKSAqIDJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYm94LmJvdHRvbSAtIGNvb3Jkcy5ib3R0b20gPiAoY29vcmRzLmJvdHRvbSAtIGJveC50b3ApICogMikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbn1cbmNvbnN0IG1heWJlUlRMID0gL1tcXHUwNTkwLVxcdTA4YWNdLztcbmZ1bmN0aW9uIGVuZE9mVGV4dGJsb2NrSG9yaXpvbnRhbCh2aWV3LCBzdGF0ZSwgZGlyKSB7XG4gICAgbGV0IHsgJGhlYWQgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRoZWFkLnBhcmVudC5pc1RleHRibG9jaylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSAkaGVhZC5wYXJlbnRPZmZzZXQsIGF0U3RhcnQgPSAhb2Zmc2V0LCBhdEVuZCA9IG9mZnNldCA9PSAkaGVhZC5wYXJlbnQuY29udGVudC5zaXplO1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICAgIC8vIElmIHRoZSB0ZXh0YmxvY2sgaXMgYWxsIExUUiwgb3IgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0XG4gICAgLy8gU2VsZWN0aW9uLm1vZGlmeSAoRWRnZSksIGZhbGwgYmFjayB0byBhIHByaW1pdGl2ZSBhcHByb2FjaFxuICAgIGlmICghbWF5YmVSVEwudGVzdCgkaGVhZC5wYXJlbnQudGV4dENvbnRlbnQpIHx8ICFzZWwubW9kaWZ5KVxuICAgICAgICByZXR1cm4gZGlyID09IFwibGVmdFwiIHx8IGRpciA9PSBcImJhY2t3YXJkXCIgPyBhdFN0YXJ0IDogYXRFbmQ7XG4gICAgcmV0dXJuIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsICgpID0+IHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGh1Z2UgaGFjaywgYnV0IGFwcGVhcnMgdG8gYmUgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGN1cnJlbnRseSBkbzogdXNlIGBTZWxlY3Rpb24ubW9kaWZ5YCB0byBtb3ZlIHRoZSBzZWxlY3Rpb24gYnlcbiAgICAgICAgLy8gb25lIGNoYXJhY3RlciwgYW5kIHNlZSBpZiB0aGF0IG1vdmVzIHRoZSBjdXJzb3Igb3V0IG9mIHRoZVxuICAgICAgICAvLyB0ZXh0YmxvY2sgKG9yIGRvZXNuJ3QgbW92ZSBpdCBhdCBhbGwsIHdoZW4gYXQgdGhlIHN0YXJ0L2VuZCBvZlxuICAgICAgICAvLyB0aGUgZG9jdW1lbnQpLlxuICAgICAgICBsZXQgeyBmb2N1c05vZGU6IG9sZE5vZGUsIGZvY3VzT2Zmc2V0OiBvbGRPZmYsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCB9ID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgb2xkQmlkaUxldmVsID0gc2VsLmNhcmV0QmlkaUxldmVsIC8vIE9ubHkgZm9yIEZpcmVmb3hcbiAgICAgICAgO1xuICAgICAgICBzZWwubW9kaWZ5KFwibW92ZVwiLCBkaXIsIFwiY2hhcmFjdGVyXCIpO1xuICAgICAgICBsZXQgcGFyZW50RE9NID0gJGhlYWQuZGVwdGggPyB2aWV3LmRvY1ZpZXcuZG9tQWZ0ZXJQb3MoJGhlYWQuYmVmb3JlKCkpIDogdmlldy5kb207XG4gICAgICAgIGxldCB7IGZvY3VzTm9kZTogbmV3Tm9kZSwgZm9jdXNPZmZzZXQ6IG5ld09mZiB9ID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3Tm9kZSAmJiAhcGFyZW50RE9NLmNvbnRhaW5zKG5ld05vZGUubm9kZVR5cGUgPT0gMSA/IG5ld05vZGUgOiBuZXdOb2RlLnBhcmVudE5vZGUpIHx8XG4gICAgICAgICAgICAob2xkTm9kZSA9PSBuZXdOb2RlICYmIG9sZE9mZiA9PSBuZXdPZmYpO1xuICAgICAgICAvLyBSZXN0b3JlIHRoZSBwcmV2aW91cyBzZWxlY3Rpb25cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlbC5jb2xsYXBzZShhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG9sZE5vZGUgJiYgKG9sZE5vZGUgIT0gYW5jaG9yTm9kZSB8fCBvbGRPZmYgIT0gYW5jaG9yT2Zmc2V0KSAmJiBzZWwuZXh0ZW5kKVxuICAgICAgICAgICAgICAgIHNlbC5leHRlbmQob2xkTm9kZSwgb2xkT2ZmKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgIGlmIChvbGRCaWRpTGV2ZWwgIT0gbnVsbClcbiAgICAgICAgICAgIHNlbC5jYXJldEJpZGlMZXZlbCA9IG9sZEJpZGlMZXZlbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbn1cbmxldCBjYWNoZWRTdGF0ZSA9IG51bGw7XG5sZXQgY2FjaGVkRGlyID0gbnVsbDtcbmxldCBjYWNoZWRSZXN1bHQgPSBmYWxzZTtcbmZ1bmN0aW9uIGVuZE9mVGV4dGJsb2NrKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBpZiAoY2FjaGVkU3RhdGUgPT0gc3RhdGUgJiYgY2FjaGVkRGlyID09IGRpcilcbiAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgICBjYWNoZWRTdGF0ZSA9IHN0YXRlO1xuICAgIGNhY2hlZERpciA9IGRpcjtcbiAgICByZXR1cm4gY2FjaGVkUmVzdWx0ID0gZGlyID09IFwidXBcIiB8fCBkaXIgPT0gXCJkb3duXCJcbiAgICAgICAgPyBlbmRPZlRleHRibG9ja1ZlcnRpY2FsKHZpZXcsIHN0YXRlLCBkaXIpXG4gICAgICAgIDogZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsKHZpZXcsIHN0YXRlLCBkaXIpO1xufVxuXG4vLyBWaWV3IGRlc2NyaXB0aW9ucyBhcmUgZGF0YSBzdHJ1Y3R1cmVzIHRoYXQgZGVzY3JpYmUgdGhlIERPTSB0aGF0IGlzXG4vLyB1c2VkIHRvIHJlcHJlc2VudCB0aGUgZWRpdG9yJ3MgY29udGVudC4gVGhleSBhcmUgdXNlZCBmb3I6XG4vL1xuLy8gLSBJbmNyZW1lbnRhbCByZWRyYXdpbmcgd2hlbiB0aGUgZG9jdW1lbnQgY2hhbmdlc1xuLy9cbi8vIC0gRmlndXJpbmcgb3V0IHdoYXQgcGFydCBvZiB0aGUgZG9jdW1lbnQgYSBnaXZlbiBET00gcG9zaXRpb25cbi8vICAgY29ycmVzcG9uZHMgdG9cbi8vXG4vLyAtIFdpcmluZyBpbiBjdXN0b20gaW1wbGVtZW50YXRpb25zIG9mIHRoZSBlZGl0aW5nIGludGVyZmFjZSBmb3IgYVxuLy8gICBnaXZlbiBub2RlXG4vL1xuLy8gVGhleSBmb3JtIGEgZG91Ymx5LWxpbmtlZCBtdXRhYmxlIHRyZWUsIHN0YXJ0aW5nIGF0IGB2aWV3LmRvY1ZpZXdgLlxuY29uc3QgTk9UX0RJUlRZID0gMCwgQ0hJTERfRElSVFkgPSAxLCBDT05URU5UX0RJUlRZID0gMiwgTk9ERV9ESVJUWSA9IDM7XG4vLyBTdXBlcmNsYXNzIGZvciB0aGUgdmFyaW91cyBraW5kcyBvZiBkZXNjcmlwdGlvbnMuIERlZmluZXMgdGhlaXJcbi8vIGJhc2ljIHN0cnVjdHVyZSBhbmQgc2hhcmVkIG1ldGhvZHMuXG5jbGFzcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBjaGlsZHJlbiwgZG9tLCBcbiAgICAvLyBUaGlzIGlzIHRoZSBub2RlIHRoYXQgaG9sZHMgdGhlIGNoaWxkIHZpZXdzLiBJdCBtYXkgYmUgbnVsbCBmb3JcbiAgICAvLyBkZXNjcyB0aGF0IGRvbid0IGhhdmUgY2hpbGRyZW4uXG4gICAgY29udGVudERPTSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NID0gY29udGVudERPTTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgLy8gQW4gZXhwYW5kbyBwcm9wZXJ0eSBvbiB0aGUgRE9NIG5vZGUgcHJvdmlkZXMgYSBsaW5rIGJhY2sgdG8gaXRzXG4gICAgICAgIC8vIGRlc2NyaXB0aW9uLlxuICAgICAgICBkb20ucG1WaWV3RGVzYyA9IHRoaXM7XG4gICAgfVxuICAgIC8vIFVzZWQgdG8gY2hlY2sgd2hldGhlciBhIGdpdmVuIGRlc2NyaXB0aW9uIGNvcnJlc3BvbmRzIHRvIGFcbiAgICAvLyB3aWRnZXQvbWFyay9ub2RlLlxuICAgIG1hdGNoZXNXaWRnZXQod2lkZ2V0KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1hdGNoZXNNYXJrKG1hcmspIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbWF0Y2hlc0hhY2sobm9kZU5hbWUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLy8gV2hlbiBwYXJzaW5nIGluLWVkaXRvciBjb250ZW50IChpbiBkb21jaGFuZ2UuanMpLCB3ZSBhbGxvd1xuICAgIC8vIGRlc2NyaXB0aW9ucyB0byBkZXRlcm1pbmUgdGhlIHBhcnNlIHJ1bGVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG9cbiAgICAvLyBwYXJzZSB0aGVtLlxuICAgIHBhcnNlUnVsZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAvLyBVc2VkIGJ5IHRoZSBlZGl0b3IncyBldmVudCBoYW5kbGVyIHRvIGlnbm9yZSBldmVudHMgdGhhdCBjb21lXG4gICAgLy8gZnJvbSBjZXJ0YWluIGRlc2NzLlxuICAgIHN0b3BFdmVudChldmVudCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgY29udGVudCByZXByZXNlbnRlZCBieSB0aGlzIGRlc2MuXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgc2l6ZSArPSB0aGlzLmNoaWxkcmVuW2ldLnNpemU7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICAvLyBGb3IgYmxvY2sgbm9kZXMsIHRoaXMgcmVwcmVzZW50cyB0aGUgc3BhY2UgdGFrZW4gdXAgYnkgdGhlaXJcbiAgICAvLyBzdGFydC9lbmQgdG9rZW5zLlxuICAgIGdldCBib3JkZXIoKSB7IHJldHVybiAwOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLmRvbS5wbVZpZXdEZXNjID09IHRoaXMpXG4gICAgICAgICAgICB0aGlzLmRvbS5wbVZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgcG9zQmVmb3JlQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHRoaXMucG9zQXRTdGFydDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY3VyID09IGNoaWxkKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gY3VyLnNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHBvc0JlZm9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnBvc0JlZm9yZUNoaWxkKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgcG9zQXRTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQucG9zQmVmb3JlQ2hpbGQodGhpcykgKyB0aGlzLmJvcmRlciA6IDA7XG4gICAgfVxuICAgIGdldCBwb3NBZnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQmVmb3JlICsgdGhpcy5zaXplO1xuICAgIH1cbiAgICBnZXQgcG9zQXRFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyB0aGlzLnNpemUgLSAyICogdGhpcy5ib3JkZXI7XG4gICAgfVxuICAgIGxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcykge1xuICAgICAgICAvLyBJZiB0aGUgRE9NIHBvc2l0aW9uIGlzIGluIHRoZSBjb250ZW50LCB1c2UgdGhlIGNoaWxkIGRlc2MgYWZ0ZXJcbiAgICAgICAgLy8gaXQgdG8gZmlndXJlIG91dCBhIHBvc2l0aW9uLlxuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTS5jb250YWlucyhkb20ubm9kZVR5cGUgPT0gMSA/IGRvbSA6IGRvbS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgaWYgKGJpYXMgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRvbUJlZm9yZSwgZGVzYztcbiAgICAgICAgICAgICAgICBpZiAoZG9tID09IHRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgICAgICBkb21CZWZvcmUgPSBkb20uY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChkb20ucGFyZW50Tm9kZSAhPSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20gPSBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZG9tQmVmb3JlID0gZG9tLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbUJlZm9yZSAmJiAhKChkZXNjID0gZG9tQmVmb3JlLnBtVmlld0Rlc2MpICYmIGRlc2MucGFyZW50ID09IHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICBkb21CZWZvcmUgPSBkb21CZWZvcmUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb21CZWZvcmUgPyB0aGlzLnBvc0JlZm9yZUNoaWxkKGRlc2MpICsgZGVzYy5zaXplIDogdGhpcy5wb3NBdFN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGRvbUFmdGVyLCBkZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkb20gPT0gdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUFmdGVyID0gZG9tLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChkb20ucGFyZW50Tm9kZSAhPSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20gPSBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChkb21BZnRlciAmJiAhKChkZXNjID0gZG9tQWZ0ZXIucG1WaWV3RGVzYykgJiYgZGVzYy5wYXJlbnQgPT0gdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIGRvbUFmdGVyID0gZG9tQWZ0ZXIubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUFmdGVyID8gdGhpcy5wb3NCZWZvcmVDaGlsZChkZXNjKSA6IHRoaXMucG9zQXRFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB1c2UgdmFyaW91cyBoZXVyaXN0aWNzLCBmYWxsaW5nIGJhY2sgb24gdGhlIGJpYXNcbiAgICAgICAgLy8gcGFyYW1ldGVyLCB0byBkZXRlcm1pbmUgd2hldGhlciB0byByZXR1cm4gdGhlIHBvc2l0aW9uIGF0IHRoZVxuICAgICAgICAvLyBzdGFydCBvciBhdCB0aGUgZW5kIG9mIHRoaXMgdmlldyBkZXNjLlxuICAgICAgICBsZXQgYXRFbmQ7XG4gICAgICAgIGlmIChkb20gPT0gdGhpcy5kb20gJiYgdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICBhdEVuZCA9IG9mZnNldCA+IGRvbUluZGV4KHRoaXMuY29udGVudERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTSAhPSB0aGlzLmRvbSAmJiB0aGlzLmRvbS5jb250YWlucyh0aGlzLmNvbnRlbnRET00pKSB7XG4gICAgICAgICAgICBhdEVuZCA9IGRvbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzLmNvbnRlbnRET00pICYgMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRvbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IDApXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2VhcmNoID0gZG9tOzsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaCA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2gucHJldmlvdXNTaWJsaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0RW5kID09IG51bGwgJiYgb2Zmc2V0ID09IGRvbS5jaGlsZE5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSBkb207OyBzZWFyY2ggPSBzZWFyY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdEVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYXRFbmQgPT0gbnVsbCA/IGJpYXMgPiAwIDogYXRFbmQpID8gdGhpcy5wb3NBdEVuZCA6IHRoaXMucG9zQXRTdGFydDtcbiAgICB9XG4gICAgbmVhcmVzdERlc2MoZG9tLCBvbmx5Tm9kZXMgPSBmYWxzZSkge1xuICAgICAgICBmb3IgKGxldCBmaXJzdCA9IHRydWUsIGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbGV0IGRlc2MgPSB0aGlzLmdldERlc2MoY3VyKSwgbm9kZURPTTtcbiAgICAgICAgICAgIGlmIChkZXNjICYmICghb25seU5vZGVzIHx8IGRlc2Mubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBkb20gaXMgb3V0c2lkZSBvZiB0aGlzIGRlc2MncyBub2RlRE9NLCBkb24ndCBjb3VudCBpdC5cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QgJiYgKG5vZGVET00gPSBkZXNjLm5vZGVET00pICYmXG4gICAgICAgICAgICAgICAgICAgICEobm9kZURPTS5ub2RlVHlwZSA9PSAxID8gbm9kZURPTS5jb250YWlucyhkb20ubm9kZVR5cGUgPT0gMSA/IGRvbSA6IGRvbS5wYXJlbnROb2RlKSA6IG5vZGVET00gPT0gZG9tKSlcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldERlc2MoZG9tKSB7XG4gICAgICAgIGxldCBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IGRlc2M7IGN1cjsgY3VyID0gY3VyLnBhcmVudClcbiAgICAgICAgICAgIGlmIChjdXIgPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICB9XG4gICAgcG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcykge1xuICAgICAgICBmb3IgKGxldCBzY2FuID0gZG9tOyBzY2FuOyBzY2FuID0gc2Nhbi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZ2V0RGVzYyhzY2FuKTtcbiAgICAgICAgICAgIGlmIChkZXNjKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjLmxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBkZXNjIGZvciB0aGUgbm9kZSBhZnRlciB0aGUgZ2l2ZW4gcG9zLCBpZiBhbnkuIChXaGVuIGFcbiAgICAvLyBwYXJlbnQgbm9kZSBvdmVycm9kZSByZW5kZXJpbmcsIHRoZXJlIG1pZ2h0IG5vdCBiZSBvbmUuKVxuICAgIGRlc2NBdChwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSBwb3MgJiYgZW5kICE9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICghY2hpbGQuYm9yZGVyICYmIGNoaWxkLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDwgZW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5kZXNjQXQocG9zIC0gb2Zmc2V0IC0gY2hpbGQuYm9yZGVyKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcywgc2lkZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuZG9tLCBvZmZzZXQ6IDAsIGF0b206IHBvcyArIDEgfTtcbiAgICAgICAgLy8gRmlyc3QgZmluZCB0aGUgcG9zaXRpb24gaW4gdGhlIGNoaWxkIGFycmF5XG4gICAgICAgIGxldCBpID0gMCwgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgY3VyUG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IGN1clBvcyArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAoZW5kID4gcG9zIHx8IGNoaWxkIGluc3RhbmNlb2YgVHJhaWxpbmdIYWNrVmlld0Rlc2MpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwb3MgLSBjdXJQb3M7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJQb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhpcyBwb2ludHMgaW50byB0aGUgbWlkZGxlIG9mIGEgY2hpbGQsIGNhbGwgdGhyb3VnaFxuICAgICAgICBpZiAob2Zmc2V0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baV0uZG9tRnJvbVBvcyhvZmZzZXQgLSB0aGlzLmNoaWxkcmVuW2ldLmJvcmRlciwgc2lkZSk7XG4gICAgICAgIC8vIEdvIGJhY2sgaWYgdGhlcmUgd2VyZSBhbnkgemVyby1sZW5ndGggd2lkZ2V0cyB3aXRoIHNpZGUgPj0gMCBiZWZvcmUgdGhpcyBwb2ludFxuICAgICAgICBmb3IgKGxldCBwcmV2OyBpICYmICEocHJldiA9IHRoaXMuY2hpbGRyZW5baSAtIDFdKS5zaXplICYmIHByZXYgaW5zdGFuY2VvZiBXaWRnZXRWaWV3RGVzYyAmJiBwcmV2LnNpZGUgPj0gMDsgaS0tKSB7IH1cbiAgICAgICAgLy8gU2NhbiB0b3dhcmRzIHRoZSBmaXJzdCB1c2VhYmxlIG5vZGVcbiAgICAgICAgaWYgKHNpZGUgPD0gMCkge1xuICAgICAgICAgICAgbGV0IHByZXYsIGVudGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoOzsgaS0tLCBlbnRlciA9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IGkgPyB0aGlzLmNoaWxkcmVuW2kgLSAxXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2IHx8IHByZXYuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2ICYmIHNpZGUgJiYgZW50ZXIgJiYgIXByZXYuYm9yZGVyICYmICFwcmV2LmRvbUF0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXYuZG9tRnJvbVBvcyhwcmV2LnNpemUsIHNpZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBvZmZzZXQ6IHByZXYgPyBkb21JbmRleChwcmV2LmRvbSkgKyAxIDogMCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5leHQsIGVudGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoOzsgaSsrLCBlbnRlciA9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA/IHRoaXMuY2hpbGRyZW5baV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dCB8fCBuZXh0LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCAmJiBlbnRlciAmJiAhbmV4dC5ib3JkZXIgJiYgIW5leHQuZG9tQXRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dC5kb21Gcm9tUG9zKDAsIHNpZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBvZmZzZXQ6IG5leHQgPyBkb21JbmRleChuZXh0LmRvbSkgOiB0aGlzLmNvbnRlbnRET00uY2hpbGROb2Rlcy5sZW5ndGggfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2VkIHRvIGZpbmQgYSBET00gcmFuZ2UgaW4gYSBzaW5nbGUgcGFyZW50IGZvciBhIGdpdmVuIGNoYW5nZWRcbiAgICAvLyByYW5nZS5cbiAgICBwYXJzZVJhbmdlKGZyb20sIHRvLCBiYXNlID0gMCkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgZnJvbSwgdG8sIGZyb21PZmZzZXQ6IDAsIHRvT2Zmc2V0OiB0aGlzLmNvbnRlbnRET00uY2hpbGROb2Rlcy5sZW5ndGggfTtcbiAgICAgICAgbGV0IGZyb21PZmZzZXQgPSAtMSwgdG9PZmZzZXQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgb2Zmc2V0ID0gYmFzZSwgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAoZnJvbU9mZnNldCA9PSAtMSAmJiBmcm9tIDw9IGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZEJhc2UgPSBvZmZzZXQgKyBjaGlsZC5ib3JkZXI7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgbWF5YmUgZGVzY2VuZCBtYXJrIHZpZXdzIHRvIHBhcnNlIGEgbmFycm93ZXIgcmFuZ2U/XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPj0gY2hpbGRCYXNlICYmIHRvIDw9IGVuZCAtIGNoaWxkLmJvcmRlciAmJiBjaGlsZC5ub2RlICYmXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKGNoaWxkLmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQucGFyc2VSYW5nZShmcm9tLCB0bywgY2hpbGRCYXNlKTtcbiAgICAgICAgICAgICAgICBmcm9tID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmV2ID0gdGhpcy5jaGlsZHJlbltqIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2LnNpemUgJiYgcHJldi5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIXByZXYuZW1wdHlDaGlsZEF0KDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tT2Zmc2V0ID0gZG9tSW5kZXgocHJldi5kb20pICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZyb20gLT0gcHJldi5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZnJvbU9mZnNldCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZnJvbU9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbU9mZnNldCA+IC0xICYmIChlbmQgPiB0byB8fCBpID09IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICB0byA9IGVuZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5jaGlsZHJlbltqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuc2l6ZSAmJiBuZXh0LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSAmJiAhbmV4dC5lbXB0eUNoaWxkQXQoLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b09mZnNldCA9IGRvbUluZGV4KG5leHQuZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRvICs9IG5leHQuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRvT2Zmc2V0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0b09mZnNldCA9IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIGZyb20sIHRvLCBmcm9tT2Zmc2V0LCB0b09mZnNldCB9O1xuICAgIH1cbiAgICBlbXB0eUNoaWxkQXQoc2lkZSkge1xuICAgICAgICBpZiAodGhpcy5ib3JkZXIgfHwgIXRoaXMuY29udGVudERPTSB8fCAhdGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bc2lkZSA8IDAgPyAwIDogdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIGNoaWxkLnNpemUgPT0gMCB8fCBjaGlsZC5lbXB0eUNoaWxkQXQoc2lkZSk7XG4gICAgfVxuICAgIGRvbUFmdGVyUG9zKHBvcykge1xuICAgICAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IHRoaXMuZG9tRnJvbVBvcyhwb3MsIDApO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxIHx8IG9mZnNldCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGFmdGVyIHBvcyBcIiArIHBvcyk7XG4gICAgICAgIHJldHVybiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICB9XG4gICAgLy8gVmlldyBkZXNjcyBhcmUgcmVzcG9uc2libGUgZm9yIHNldHRpbmcgYW55IHNlbGVjdGlvbiB0aGF0IGZhbGxzXG4gICAgLy8gZW50aXJlbHkgaW5zaWRlIG9mIHRoZW0sIHNvIHRoYXQgY3VzdG9tIGltcGxlbWVudGF0aW9ucyBjYW4gZG9cbiAgICAvLyBjdXN0b20gdGhpbmdzIHdpdGggdGhlIHNlbGVjdGlvbi4gTm90ZSB0aGF0IHRoaXMgZmFsbHMgYXBhcnQgd2hlblxuICAgIC8vIGEgc2VsZWN0aW9uIHN0YXJ0cyBpbiBzdWNoIGEgbm9kZSBhbmQgZW5kcyBpbiBhbm90aGVyLCBpbiB3aGljaFxuICAgIC8vIGNhc2Ugd2UganVzdCB1c2Ugd2hhdGV2ZXIgZG9tRnJvbVBvcyBwcm9kdWNlcyBhcyBhIGJlc3QgZWZmb3J0LlxuICAgIHNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHJvb3QsIGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBmYWxscyBlbnRpcmVseSBpbiBhIGNoaWxkLCBnaXZlIGl0IHRvIHRoYXQgY2hpbGRcbiAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihhbmNob3IsIGhlYWQpLCB0byA9IE1hdGgubWF4KGFuY2hvciwgaGVhZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChmcm9tID4gb2Zmc2V0ICYmIHRvIDwgZW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5zZXRTZWxlY3Rpb24oYW5jaG9yIC0gb2Zmc2V0IC0gY2hpbGQuYm9yZGVyLCBoZWFkIC0gb2Zmc2V0IC0gY2hpbGQuYm9yZGVyLCByb290LCBmb3JjZSk7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFuY2hvckRPTSA9IHRoaXMuZG9tRnJvbVBvcyhhbmNob3IsIGFuY2hvciA/IC0xIDogMSk7XG4gICAgICAgIGxldCBoZWFkRE9NID0gaGVhZCA9PSBhbmNob3IgPyBhbmNob3JET00gOiB0aGlzLmRvbUZyb21Qb3MoaGVhZCwgaGVhZCA/IC0xIDogMSk7XG4gICAgICAgIGxldCBkb21TZWwgPSByb290LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBsZXQgYnJLbHVkZ2UgPSBmYWxzZTtcbiAgICAgICAgLy8gT24gRmlyZWZveCwgdXNpbmcgU2VsZWN0aW9uLmNvbGxhcHNlIHRvIHB1dCB0aGUgY3Vyc29yIGFmdGVyIGFcbiAgICAgICAgLy8gQlIgbm9kZSBmb3Igc29tZSByZWFzb24gZG9lc24ndCBhbHdheXMgd29yayAoIzEwNzMpLiBPbiBTYWZhcmksXG4gICAgICAgIC8vIHRoZSBjdXJzb3Igc29tZXRpbWVzIGluZXhwbGljYWJsZSB2aXN1YWxseSBsYWdzIGJlaGluZCBpdHNcbiAgICAgICAgLy8gcmVwb3J0ZWQgcG9zaXRpb24gaW4gc3VjaCBzaXR1YXRpb25zICgjMTA5MikuXG4gICAgICAgIGlmICgoZ2Vja28gfHwgc2FmYXJpKSAmJiBhbmNob3IgPT0gaGVhZCkge1xuICAgICAgICAgICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSBhbmNob3JET007XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgYnJLbHVkZ2UgPSAhIShvZmZzZXQgJiYgbm9kZS5ub2RlVmFsdWVbb2Zmc2V0IC0gMV0gPT0gXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgLy8gSXNzdWUgIzExMjhcbiAgICAgICAgICAgICAgICBpZiAoYnJLbHVkZ2UgJiYgb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzY2FuID0gbm9kZSwgYWZ0ZXI7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZnRlciA9IHNjYW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIubm9kZU5hbWUgPT0gXCJCUlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JET00gPSBoZWFkRE9NID0geyBub2RlOiBhZnRlci5wYXJlbnROb2RlLCBvZmZzZXQ6IGRvbUluZGV4KGFmdGVyKSArIDEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZXNjID0gc2Nhbi5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgYnJLbHVkZ2UgPSBwcmV2ICYmIChwcmV2Lm5vZGVOYW1lID09IFwiQlJcIiB8fCBwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpcmVmb3ggY2FuIGFjdCBzdHJhbmdlbHkgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGluIGZyb250IG9mIGFuXG4gICAgICAgIC8vIHVuZWRpdGFibGUgbm9kZS4gU2VlICMxMTYzIGFuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzA5NTM2XG4gICAgICAgIGlmIChnZWNrbyAmJiBkb21TZWwuZm9jdXNOb2RlICYmIGRvbVNlbC5mb2N1c05vZGUgIT0gaGVhZERPTS5ub2RlICYmIGRvbVNlbC5mb2N1c05vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gZG9tU2VsLmZvY3VzTm9kZS5jaGlsZE5vZGVzW2RvbVNlbC5mb2N1c09mZnNldF07XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgJiYgYWZ0ZXIuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZm9yY2UgfHwgYnJLbHVkZ2UgJiYgc2FmYXJpKSAmJlxuICAgICAgICAgICAgaXNFcXVpdmFsZW50UG9zaXRpb24oYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KSAmJlxuICAgICAgICAgICAgaXNFcXVpdmFsZW50UG9zaXRpb24oaGVhZERPTS5ub2RlLCBoZWFkRE9NLm9mZnNldCwgZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gU2VsZWN0aW9uLmV4dGVuZCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gJ2ludmVydGVkJyBzZWxlY3Rpb25cbiAgICAgICAgLy8gKG9uZSB3aGVyZSB0aGUgZm9jdXMgaXMgYmVmb3JlIHRoZSBhbmNob3IpLCBidXQgbm90IGFsbFxuICAgICAgICAvLyBicm93c2VycyBzdXBwb3J0IGl0IHlldC5cbiAgICAgICAgbGV0IGRvbVNlbEV4dGVuZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICgoZG9tU2VsLmV4dGVuZCB8fCBhbmNob3IgPT0gaGVhZCkgJiYgIWJyS2x1ZGdlKSB7XG4gICAgICAgICAgICBkb21TZWwuY29sbGFwc2UoYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yICE9IGhlYWQpXG4gICAgICAgICAgICAgICAgICAgIGRvbVNlbC5leHRlbmQoaGVhZERPTS5ub2RlLCBoZWFkRE9NLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZG9tU2VsRXh0ZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzIHdpdGggQ2hyb21lIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYWZ0ZXIgY2FsbGluZ1xuICAgICAgICAgICAgICAgIC8vIGNvbGxhcHNlLCBldmVuIHdoZW4gaXQgc2hvdWxkIGJlIHZhbGlkLiBUaGlzIGFwcGVhcnMgdG8gYmUgYSBidWcsIGJ1dFxuICAgICAgICAgICAgICAgIC8vIGl0IGlzIGRpZmZpY3VsdCB0byBpc29sYXRlLiBJZiB0aGlzIGhhcHBlbnMgZmFsbGJhY2sgdG8gdGhlIG9sZCBwYXRoXG4gICAgICAgICAgICAgICAgLy8gd2l0aG91dCB1c2luZyBleHRlbmQuXG4gICAgICAgICAgICAgICAgLy8gU2ltaWxhcmx5LCB0aGlzIGNvdWxkIGNyYXNoIG9uIFNhZmFyaSBpZiB0aGUgZWRpdG9yIGlzIGhpZGRlbiwgYW5kXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgd2FzIG5vIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRvbVNlbEV4dGVuZGVkKSB7XG4gICAgICAgICAgICBpZiAoYW5jaG9yID4gaGVhZCkge1xuICAgICAgICAgICAgICAgIGxldCB0bXAgPSBhbmNob3JET007XG4gICAgICAgICAgICAgICAgYW5jaG9yRE9NID0gaGVhZERPTTtcbiAgICAgICAgICAgICAgICBoZWFkRE9NID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLnNldEVuZChoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0KTtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0KTtcbiAgICAgICAgICAgIGRvbVNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIGRvbVNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbnRlbnRET00gJiYgbXV0YXRpb24udHlwZSAhPSBcInNlbGVjdGlvblwiO1xuICAgIH1cbiAgICBnZXQgY29udGVudExvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NICE9IHRoaXMuZG9tICYmICF0aGlzLmRvbS5jb250YWlucyh0aGlzLmNvbnRlbnRET00pO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgYSBzdWJ0cmVlIG9mIHRoZSBlbGVtZW50IHRyZWUgdGhhdCBoYXMgYmVlbiB0b3VjaGVkXG4gICAgLy8gYnkgYSBET00gY2hhbmdlLCBzbyB0aGF0IHRoZSBuZXh0IHVwZGF0ZSB3aWxsIHJlZHJhdyBpdC5cbiAgICBtYXJrRGlydHkoZnJvbSwgdG8pIHtcbiAgICAgICAgZm9yIChsZXQgb2Zmc2V0ID0gMCwgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSBlbmQgPyBmcm9tIDw9IGVuZCAmJiB0byA+PSBvZmZzZXQgOiBmcm9tIDwgZW5kICYmIHRvID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5zaWRlID0gb2Zmc2V0ICsgY2hpbGQuYm9yZGVyLCBlbmRJbnNpZGUgPSBlbmQgLSBjaGlsZC5ib3JkZXI7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPj0gc3RhcnRJbnNpZGUgJiYgdG8gPD0gZW5kSW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmcm9tID09IG9mZnNldCB8fCB0byA9PSBlbmQgPyBDT05URU5UX0RJUlRZIDogQ0hJTERfRElSVFk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID09IHN0YXJ0SW5zaWRlICYmIHRvID09IGVuZEluc2lkZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGNoaWxkLmNvbnRlbnRMb3N0IHx8IGNoaWxkLmRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5kaXJ0eSA9IE5PREVfRElSVFk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLm1hcmtEaXJ0eShmcm9tIC0gc3RhcnRJbnNpZGUsIHRvIC0gc3RhcnRJbnNpZGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kaXJ0eSA9IGNoaWxkLmRvbSA9PSBjaGlsZC5jb250ZW50RE9NICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSAmJiAhY2hpbGQuY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICA/IENPTlRFTlRfRElSVFkgOiBOT0RFX0RJUlRZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICB9XG4gICAgbWFya1BhcmVudHNEaXJ0eSgpIHtcbiAgICAgICAgbGV0IGxldmVsID0gMTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHRoaXMucGFyZW50OyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnQsIGxldmVsKyspIHtcbiAgICAgICAgICAgIGxldCBkaXJ0eSA9IGxldmVsID09IDEgPyBDT05URU5UX0RJUlRZIDogQ0hJTERfRElSVFk7XG4gICAgICAgICAgICBpZiAobm9kZS5kaXJ0eSA8IGRpcnR5KVxuICAgICAgICAgICAgICAgIG5vZGUuZGlydHkgPSBkaXJ0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlnbm9yZUZvckNvb3JkcygpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG4vLyBBIHdpZGdldCBkZXNjIHJlcHJlc2VudHMgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggaXMgYSBET00gbm9kZVxuLy8gZHJhd24gYmV0d2VlbiB0aGUgZG9jdW1lbnQgbm9kZXMuXG5jbGFzcyBXaWRnZXRWaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHdpZGdldCwgdmlldywgcG9zKSB7XG4gICAgICAgIGxldCBzZWxmLCBkb20gPSB3aWRnZXQudHlwZS50b0RPTTtcbiAgICAgICAgaWYgKHR5cGVvZiBkb20gPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgZG9tID0gZG9tKHZpZXcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucGFyZW50KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wYXJlbnQucG9zQmVmb3JlQ2hpbGQoc2VsZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF3aWRnZXQudHlwZS5zcGVjLnJhdykge1xuICAgICAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgICAgICB3cmFwLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgICAgICAgICAgICAgZG9tID0gd3JhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgICAgICBkb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLXdpZGdldFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihwYXJlbnQsIFtdLCBkb20sIG51bGwpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHNlbGYgPSB0aGlzO1xuICAgIH1cbiAgICBtYXRjaGVzV2lkZ2V0KHdpZGdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJ0eSA9PSBOT1RfRElSVFkgJiYgd2lkZ2V0LnR5cGUuZXEodGhpcy53aWRnZXQudHlwZSk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHsgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07IH1cbiAgICBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgbGV0IHN0b3AgPSB0aGlzLndpZGdldC5zcGVjLnN0b3BFdmVudDtcbiAgICAgICAgcmV0dXJuIHN0b3AgPyBzdG9wKGV2ZW50KSA6IGZhbHNlO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gbXV0YXRpb24udHlwZSAhPSBcInNlbGVjdGlvblwiIHx8IHRoaXMud2lkZ2V0LnNwZWMuaWdub3JlU2VsZWN0aW9uO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLndpZGdldC50eXBlLmRlc3Ryb3kodGhpcy5kb20pO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBzaWRlKCkgeyByZXR1cm4gdGhpcy53aWRnZXQudHlwZS5zaWRlOyB9XG59XG5jbGFzcyBDb21wb3NpdGlvblZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgZG9tLCB0ZXh0RE9NLCB0ZXh0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgbnVsbCk7XG4gICAgICAgIHRoaXMudGV4dERPTSA9IHRleHRET007XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIGxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCkge1xuICAgICAgICBpZiAoZG9tICE9IHRoaXMudGV4dERPTSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyAob2Zmc2V0ID8gdGhpcy5zaXplIDogMCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyBvZmZzZXQ7XG4gICAgfVxuICAgIGRvbUZyb21Qb3MocG9zKSB7XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMudGV4dERPTSwgb2Zmc2V0OiBwb3MgfTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0KSB7XG4gICAgICAgIHJldHVybiBtdXQudHlwZSA9PT0gJ2NoYXJhY3RlckRhdGEnICYmIG11dC50YXJnZXQubm9kZVZhbHVlID09IG11dC5vbGRWYWx1ZTtcbiAgICB9XG59XG4vLyBBIG1hcmsgZGVzYyByZXByZXNlbnRzIGEgbWFyay4gTWF5IGhhdmUgbXVsdGlwbGUgY2hpbGRyZW4sXG4vLyBkZXBlbmRpbmcgb24gaG93IHRoZSBtYXJrIGlzIHNwbGl0LiBOb3RlIHRoYXQgbWFya3MgYXJlIGRyYXduIHVzaW5nXG4vLyBhIGZpeGVkIG5lc3Rpbmcgb3JkZXIsIGZvciBzaW1wbGljaXR5IGFuZCBwcmVkaWN0YWJpbGl0eSwgc28gaW5cbi8vIHNvbWUgY2FzZXMgdGhleSB3aWxsIGJlIHNwbGl0IG1vcmUgb2Z0ZW4gdGhhbiB3b3VsZCBhcHBlYXJcbi8vIG5lY2Vzc2FyeS5cbmNsYXNzIE1hcmtWaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG1hcmssIGRvbSwgY29udGVudERPTSkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIFtdLCBkb20sIGNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHBhcmVudCwgbWFyaywgaW5saW5lLCB2aWV3KSB7XG4gICAgICAgIGxldCBjdXN0b20gPSB2aWV3Lm5vZGVWaWV3c1ttYXJrLnR5cGUubmFtZV07XG4gICAgICAgIGxldCBzcGVjID0gY3VzdG9tICYmIGN1c3RvbShtYXJrLCB2aWV3LCBpbmxpbmUpO1xuICAgICAgICBpZiAoIXNwZWMgfHwgIXNwZWMuZG9tKVxuICAgICAgICAgICAgc3BlYyA9IERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2N1bWVudCwgbWFyay50eXBlLnNwZWMudG9ET00obWFyaywgaW5saW5lKSk7XG4gICAgICAgIHJldHVybiBuZXcgTWFya1ZpZXdEZXNjKHBhcmVudCwgbWFyaywgc3BlYy5kb20sIHNwZWMuY29udGVudERPTSB8fCBzcGVjLmRvbSk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgaWYgKCh0aGlzLmRpcnR5ICYgTk9ERV9ESVJUWSkgfHwgdGhpcy5tYXJrLnR5cGUuc3BlYy5yZXBhcnNlSW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB7IG1hcms6IHRoaXMubWFyay50eXBlLm5hbWUsIGF0dHJzOiB0aGlzLm1hcmsuYXR0cnMsIGNvbnRlbnRFbGVtZW50OiB0aGlzLmNvbnRlbnRET00gfTtcbiAgICB9XG4gICAgbWF0Y2hlc01hcmsobWFyaykgeyByZXR1cm4gdGhpcy5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHRoaXMubWFyay5lcShtYXJrKTsgfVxuICAgIG1hcmtEaXJ0eShmcm9tLCB0bykge1xuICAgICAgICBzdXBlci5tYXJrRGlydHkoZnJvbSwgdG8pO1xuICAgICAgICAvLyBNb3ZlIGRpcnR5IGluZm8gdG8gbmVhcmVzdCBub2RlIHZpZXdcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAoIXBhcmVudC5ub2RlKVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAocGFyZW50LmRpcnR5IDwgdGhpcy5kaXJ0eSlcbiAgICAgICAgICAgICAgICBwYXJlbnQuZGlydHkgPSB0aGlzLmRpcnR5O1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzbGljZShmcm9tLCB0bywgdmlldykge1xuICAgICAgICBsZXQgY29weSA9IE1hcmtWaWV3RGVzYy5jcmVhdGUodGhpcy5wYXJlbnQsIHRoaXMubWFyaywgdHJ1ZSwgdmlldyk7XG4gICAgICAgIGxldCBub2RlcyA9IHRoaXMuY2hpbGRyZW4sIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIGlmICh0byA8IHNpemUpXG4gICAgICAgICAgICBub2RlcyA9IHJlcGxhY2VOb2Rlcyhub2RlcywgdG8sIHNpemUsIHZpZXcpO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICBub2RlcyA9IHJlcGxhY2VOb2Rlcyhub2RlcywgMCwgZnJvbSwgdmlldyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBub2Rlc1tpXS5wYXJlbnQgPSBjb3B5O1xuICAgICAgICBjb3B5LmNoaWxkcmVuID0gbm9kZXM7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbn1cbi8vIE5vZGUgdmlldyBkZXNjcyBhcmUgdGhlIG1haW4sIG1vc3QgY29tbW9uIHR5cGUgb2YgdmlldyBkZXNjLCBhbmRcbi8vIGNvcnJlc3BvbmQgdG8gYW4gYWN0dWFsIG5vZGUgaW4gdGhlIGRvY3VtZW50LiBVbmxpa2UgbWFyayBkZXNjcyxcbi8vIHRoZXkgcG9wdWxhdGUgdGhlaXIgY2hpbGQgYXJyYXkgdGhlbXNlbHZlcy5cbmNsYXNzIE5vZGVWaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00sIG5vZGVET00sIHZpZXcsIHBvcykge1xuICAgICAgICBzdXBlcihwYXJlbnQsIFtdLCBkb20sIGNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm91dGVyRGVjbyA9IG91dGVyRGVjbztcbiAgICAgICAgdGhpcy5pbm5lckRlY28gPSBpbm5lckRlY287XG4gICAgICAgIHRoaXMubm9kZURPTSA9IG5vZGVET007XG4gICAgfVxuICAgIC8vIEJ5IGRlZmF1bHQsIGEgbm9kZSBpcyByZW5kZXJlZCB1c2luZyB0aGUgYHRvRE9NYCBtZXRob2QgZnJvbSB0aGVcbiAgICAvLyBub2RlIHR5cGUgc3BlYy4gQnV0IGNsaWVudCBjb2RlIGNhbiB1c2UgdGhlIGBub2RlVmlld3NgIHNwZWMgdG9cbiAgICAvLyBzdXBwbHkgYSBjdXN0b20gbm9kZSB2aWV3LCB3aGljaCBjYW4gaW5mbHVlbmNlIHZhcmlvdXMgYXNwZWN0cyBvZlxuICAgIC8vIHRoZSB3YXkgdGhlIG5vZGUgd29ya3MuXG4gICAgLy9cbiAgICAvLyAoVXNpbmcgc3ViY2xhc3NpbmcgZm9yIHRoaXMgd2FzIGludGVudGlvbmFsbHkgZGVjaWRlZCBhZ2FpbnN0LFxuICAgIC8vIHNpbmNlIGl0J2QgcmVxdWlyZSBleHBvc2luZyBhIHdob2xlIHNsZXcgb2YgZmluaWNreVxuICAgIC8vIGltcGxlbWVudGF0aW9uIGRldGFpbHMgdG8gdGhlIHVzZXIgY29kZSB0aGF0IHRoZXkgcHJvYmFibHkgd2lsbFxuICAgIC8vIG5ldmVyIG5lZWQuKVxuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSB7XG4gICAgICAgIGxldCBjdXN0b20gPSB2aWV3Lm5vZGVWaWV3c1tub2RlLnR5cGUubmFtZV0sIGRlc2NPYmo7XG4gICAgICAgIGxldCBzcGVjID0gY3VzdG9tICYmIGN1c3RvbShub2RlLCB2aWV3LCAoKSA9PiB7XG4gICAgICAgICAgICAvLyAoVGhpcyBpcyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRoZSBjdXN0b20gdmlldyB0byBmaW5kIGl0c1xuICAgICAgICAgICAgLy8gb3duIHBvc2l0aW9uKVxuICAgICAgICAgICAgaWYgKCFkZXNjT2JqKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBpZiAoZGVzY09iai5wYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NPYmoucGFyZW50LnBvc0JlZm9yZUNoaWxkKGRlc2NPYmopO1xuICAgICAgICB9LCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICAgIGxldCBkb20gPSBzcGVjICYmIHNwZWMuZG9tLCBjb250ZW50RE9NID0gc3BlYyAmJiBzcGVjLmNvbnRlbnRET007XG4gICAgICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgaWYgKCFkb20pXG4gICAgICAgICAgICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS50ZXh0KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSAhPSAzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGV4dCBtdXN0IGJlIHJlbmRlcmVkIGFzIGEgRE9NIHRleHQgbm9kZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZG9tKSB7XG4gICAgICAgICAgICAoeyBkb20sIGNvbnRlbnRET00gfSA9IERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2N1bWVudCwgbm9kZS50eXBlLnNwZWMudG9ET00obm9kZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRlbnRET00gJiYgIW5vZGUuaXNUZXh0ICYmIGRvbS5ub2RlTmFtZSAhPSBcIkJSXCIpIHsgLy8gQ2hyb21lIGdldHMgY29uZnVzZWQgYnkgPGJyIGNvbnRlbnRlZGl0YWJsZT1mYWxzZT5cbiAgICAgICAgICAgIGlmICghZG9tLmhhc0F0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSlcbiAgICAgICAgICAgICAgICBkb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSlcbiAgICAgICAgICAgICAgICBkb20uZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZURPTSA9IGRvbTtcbiAgICAgICAgZG9tID0gYXBwbHlPdXRlckRlY28oZG9tLCBvdXRlckRlY28sIG5vZGUpO1xuICAgICAgICBpZiAoc3BlYylcbiAgICAgICAgICAgIHJldHVybiBkZXNjT2JqID0gbmV3IEN1c3RvbU5vZGVWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00gfHwgbnVsbCwgbm9kZURPTSwgc3BlYywgdmlldywgcG9zICsgMSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0Vmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBub2RlRE9NLCB2aWV3KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlVmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NIHx8IG51bGwsIG5vZGVET00sIHZpZXcsIHBvcyArIDEpO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7XG4gICAgICAgIC8vIEV4cGVyaW1lbnRhbCBrbHVkZ2UgdG8gYWxsb3cgb3B0LWluIHJlLXBhcnNpbmcgb2Ygbm9kZXNcbiAgICAgICAgaWYgKHRoaXMubm9kZS50eXBlLnNwZWMucmVwYXJzZUluVmlldylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBGSVhNRSB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgY2FuIGFsd2F5cyByZXR1cm4gdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gYXR0cnMgbWVhbnMgdGhhdCBpZiB0aGUgdXNlciBzb21laG93IG1hbmFnZXMgdG8gY2hhbmdlIHRoZVxuICAgICAgICAvLyBhdHRycyBpbiB0aGUgZG9tLCB0aGF0IHdvbid0IGJlIHBpY2tlZCB1cC4gTm90IGVudGlyZWx5IHN1cmVcbiAgICAgICAgLy8gd2hldGhlciB0aGlzIGlzIGEgcHJvYmxlbVxuICAgICAgICBsZXQgcnVsZSA9IHsgbm9kZTogdGhpcy5ub2RlLnR5cGUubmFtZSwgYXR0cnM6IHRoaXMubm9kZS5hdHRycyB9O1xuICAgICAgICBpZiAodGhpcy5ub2RlLnR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiKVxuICAgICAgICAgICAgcnVsZS5wcmVzZXJ2ZVdoaXRlc3BhY2UgPSBcImZ1bGxcIjtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIHJ1bGUuZ2V0Q29udGVudCA9ICgpID0+IHRoaXMubm9kZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmNvbnRlbnRMb3N0KSB7XG4gICAgICAgICAgICBydWxlLmNvbnRlbnRFbGVtZW50ID0gdGhpcy5jb250ZW50RE9NO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2hyb21lIGxpa2VzIHRvIHJhbmRvbWx5IHJlY3JlYXRlIHBhcmVudCBub2RlcyB3aGVuXG4gICAgICAgICAgICAvLyBiYWNrc3BhY2luZyB0aGluZ3MuIFdoZW4gdGhhdCBoYXBwZW5zLCB0aGlzIHRyaWVzIHRvIGZpbmQgdGhlXG4gICAgICAgICAgICAvLyBuZXcgcGFyZW50LlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvbS5jb250YWlucyhjaGlsZC5kb20ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5jb250ZW50RWxlbWVudCA9IGNoaWxkLmRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJ1bGUuY29udGVudEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50ID0gKCkgPT4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfVxuICAgIG1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiBub2RlLmVxKHRoaXMubm9kZSkgJiZcbiAgICAgICAgICAgIHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCB0aGlzLm91dGVyRGVjbykgJiYgaW5uZXJEZWNvLmVxKHRoaXMuaW5uZXJEZWNvKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLm5vZGUubm9kZVNpemU7IH1cbiAgICBnZXQgYm9yZGVyKCkgeyByZXR1cm4gdGhpcy5ub2RlLmlzTGVhZiA/IDAgOiAxOyB9XG4gICAgLy8gU3luY3MgYHRoaXMuY2hpbGRyZW5gIHRvIG1hdGNoIGB0aGlzLm5vZGUuY29udGVudGAgYW5kIHRoZSBsb2NhbFxuICAgIC8vIGRlY29yYXRpb25zLCBwb3NzaWJseSBpbnRyb2R1Y2luZyBuZXN0aW5nIGZvciBtYXJrcy4gVGhlbiwgaW4gYVxuICAgIC8vIHNlcGFyYXRlIHN0ZXAsIHN5bmNzIHRoZSBET00gaW5zaWRlIGB0aGlzLmNvbnRlbnRET01gIHRvXG4gICAgLy8gYHRoaXMuY2hpbGRyZW5gLlxuICAgIHVwZGF0ZUNoaWxkcmVuKHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgaW5saW5lID0gdGhpcy5ub2RlLmlubGluZUNvbnRlbnQsIG9mZiA9IHBvcztcbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uID0gdmlldy5jb21wb3NpbmcgPyB0aGlzLmxvY2FsQ29tcG9zaXRpb25JbmZvKHZpZXcsIHBvcykgOiBudWxsO1xuICAgICAgICBsZXQgbG9jYWxDb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnBvcyA+IC0xID8gY29tcG9zaXRpb24gOiBudWxsO1xuICAgICAgICBsZXQgY29tcG9zaXRpb25JbkNoaWxkID0gY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ucG9zIDwgMDtcbiAgICAgICAgbGV0IHVwZGF0ZXIgPSBuZXcgVmlld1RyZWVVcGRhdGVyKHRoaXMsIGxvY2FsQ29tcG9zaXRpb24gJiYgbG9jYWxDb21wb3NpdGlvbi5ub2RlLCB2aWV3KTtcbiAgICAgICAgaXRlckRlY28odGhpcy5ub2RlLCB0aGlzLmlubmVyRGVjbywgKHdpZGdldCwgaSwgaW5zaWRlTm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHdpZGdldC5zcGVjLm1hcmtzKVxuICAgICAgICAgICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3Mod2lkZ2V0LnNwZWMubWFya3MsIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICBlbHNlIGlmICh3aWRnZXQudHlwZS5zaWRlID49IDAgJiYgIWluc2lkZU5vZGUpXG4gICAgICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhpID09IHRoaXMubm9kZS5jaGlsZENvdW50ID8gTWFyay5ub25lIDogdGhpcy5ub2RlLmNoaWxkKGkpLm1hcmtzLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIG5leHQgbm9kZSBpcyBhIGRlc2MgbWF0Y2hpbmcgdGhpcyB3aWRnZXQsIHJldXNlIGl0LFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGluc2VydCB0aGUgd2lkZ2V0IGFzIGEgbmV3IHZpZXcgZGVzYy5cbiAgICAgICAgICAgIHVwZGF0ZXIucGxhY2VXaWRnZXQod2lkZ2V0LCB2aWV3LCBvZmYpO1xuICAgICAgICB9LCAoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpKSA9PiB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHdyYXBwaW5nIG1hcmsgZGVzY3MgbWF0Y2ggdGhlIG5vZGUncyBtYXJrcy5cbiAgICAgICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoY2hpbGQubWFya3MsIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAvLyBUcnkgc2V2ZXJhbCBzdHJhdGVnaWVzIGZvciBkcmF3aW5nIHRoaXMgbm9kZVxuICAgICAgICAgICAgbGV0IGNvbXBJbmRleDtcbiAgICAgICAgICAgIGlmICh1cGRhdGVyLmZpbmROb2RlTWF0Y2goY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpKSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoY29tcG9zaXRpb25JbkNoaWxkICYmIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPiBvZmYgJiZcbiAgICAgICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byA8IG9mZiArIGNoaWxkLm5vZGVTaXplICYmXG4gICAgICAgICAgICAgICAgKGNvbXBJbmRleCA9IHVwZGF0ZXIuZmluZEluZGV4V2l0aENoaWxkKGNvbXBvc2l0aW9uLm5vZGUpKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgdXBkYXRlci51cGRhdGVOb2RlQXQoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBjb21wSW5kZXgsIHZpZXcpKSA7XG4gICAgICAgICAgICBlbHNlIGlmICh1cGRhdGVyLnVwZGF0ZU5leHROb2RlKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgaSwgb2ZmKSkgO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGl0IGFzIGEgbmV3IHZpZXdcbiAgICAgICAgICAgICAgICB1cGRhdGVyLmFkZE5vZGUoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBvZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRHJvcCBhbGwgcmVtYWluaW5nIGRlc2NzIGFmdGVyIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKFtdLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICBpZiAodGhpcy5ub2RlLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgdXBkYXRlci5hZGRUZXh0YmxvY2tIYWNrcygpO1xuICAgICAgICB1cGRhdGVyLmRlc3Ryb3lSZXN0KCk7XG4gICAgICAgIC8vIFN5bmMgdGhlIERPTSBpZiBhbnl0aGluZyBjaGFuZ2VkXG4gICAgICAgIGlmICh1cGRhdGVyLmNoYW5nZWQgfHwgdGhpcy5kaXJ0eSA9PSBDT05URU5UX0RJUlRZKSB7XG4gICAgICAgICAgICAvLyBNYXkgaGF2ZSB0byBwcm90ZWN0IGZvY3VzZWQgRE9NIGZyb20gYmVpbmcgY2hhbmdlZCBpZiBhIGNvbXBvc2l0aW9uIGlzIGFjdGl2ZVxuICAgICAgICAgICAgaWYgKGxvY2FsQ29tcG9zaXRpb24pXG4gICAgICAgICAgICAgICAgdGhpcy5wcm90ZWN0TG9jYWxDb21wb3NpdGlvbih2aWV3LCBsb2NhbENvbXBvc2l0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlckRlc2NzKHRoaXMuY29udGVudERPTSwgdGhpcy5jaGlsZHJlbiwgdmlldyk7XG4gICAgICAgICAgICBpZiAoaW9zKVxuICAgICAgICAgICAgICAgIGlvc0hhY2tzKHRoaXMuZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2NhbENvbXBvc2l0aW9uSW5mbyh2aWV3LCBwb3MpIHtcbiAgICAgICAgLy8gT25seSBkbyBzb21ldGhpbmcgaWYgYm90aCB0aGUgc2VsZWN0aW9uIGFuZCBhIGZvY3VzZWQgdGV4dCBub2RlXG4gICAgICAgIC8vIGFyZSBpbnNpZGUgb2YgdGhpcyBub2RlXG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKCEodmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB8fCBmcm9tIDwgcG9zIHx8IHRvID4gcG9zICsgdGhpcy5ub2RlLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgdGV4dE5vZGUgPSBuZWFyYnlUZXh0Tm9kZShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgICAgICBpZiAoIXRleHROb2RlIHx8ICF0aGlzLmRvbS5jb250YWlucyh0ZXh0Tm9kZS5wYXJlbnROb2RlKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5ub2RlLmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRleHQgaW4gdGhlIGZvY3VzZWQgbm9kZSBpbiB0aGUgbm9kZSwgc3RvcCBpZiBpdCdzIG5vdFxuICAgICAgICAgICAgLy8gdGhlcmUgKG1heSBoYXZlIGJlZW4gbW9kaWZpZWQgdGhyb3VnaCBvdGhlciBtZWFucywgaW4gd2hpY2hcbiAgICAgICAgICAgIC8vIGNhc2UgaXQgc2hvdWxkIG92ZXJ3cml0dGVuKVxuICAgICAgICAgICAgbGV0IHRleHQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICBsZXQgdGV4dFBvcyA9IGZpbmRUZXh0SW5GcmFnbWVudCh0aGlzLm5vZGUuY29udGVudCwgdGV4dCwgZnJvbSAtIHBvcywgdG8gLSBwb3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRleHRQb3MgPCAwID8gbnVsbCA6IHsgbm9kZTogdGV4dE5vZGUsIHBvczogdGV4dFBvcywgdGV4dCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGV4dE5vZGUsIHBvczogLTEsIHRleHQ6IFwiXCIgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm90ZWN0TG9jYWxDb21wb3NpdGlvbih2aWV3LCB7IG5vZGUsIHBvcywgdGV4dCB9KSB7XG4gICAgICAgIC8vIFRoZSBub2RlIGlzIGFscmVhZHkgcGFydCBvZiBhIGxvY2FsIHZpZXcgZGVzYywgbGVhdmUgaXQgdGhlcmVcbiAgICAgICAgaWYgKHRoaXMuZ2V0RGVzYyhub2RlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29tcG9zaXRpb24gdmlldyBmb3IgdGhlIG9ycGhhbmVkIG5vZGVzXG4gICAgICAgIGxldCB0b3BOb2RlID0gbm9kZTtcbiAgICAgICAgZm9yICg7OyB0b3BOb2RlID0gdG9wTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAodG9wTm9kZS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHdoaWxlICh0b3BOb2RlLnByZXZpb3VzU2libGluZylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgd2hpbGUgKHRvcE5vZGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgdG9wTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRvcE5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgaWYgKHRvcE5vZGUucG1WaWV3RGVzYylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlc2MgPSBuZXcgQ29tcG9zaXRpb25WaWV3RGVzYyh0aGlzLCB0b3BOb2RlLCBub2RlLCB0ZXh0KTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLnB1c2goZGVzYyk7XG4gICAgICAgIC8vIFBhdGNoIHVwIHRoaXMuY2hpbGRyZW4gdG8gY29udGFpbiB0aGUgY29tcG9zaXRpb24gdmlld1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gcmVwbGFjZU5vZGVzKHRoaXMuY2hpbGRyZW4sIHBvcywgcG9zICsgdGV4dC5sZW5ndGgsIHZpZXcsIGRlc2MpO1xuICAgIH1cbiAgICAvLyBJZiB0aGlzIGRlc2MgbXVzdCBiZSB1cGRhdGVkIHRvIG1hdGNoIHRoZSBnaXZlbiBub2RlIGRlY29yYXRpb24sXG4gICAgLy8gZG8gc28gYW5kIHJldHVybiB0cnVlLlxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8XG4gICAgICAgICAgICAhbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgdGhpcy51cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5pbm5lckRlY28gPSBpbm5lckRlY287XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKHZpZXcsIHRoaXMucG9zQXRTdGFydCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgfVxuICAgIHVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pIHtcbiAgICAgICAgaWYgKHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCB0aGlzLm91dGVyRGVjbykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBuZWVkc1dyYXAgPSB0aGlzLm5vZGVET00ubm9kZVR5cGUgIT0gMTtcbiAgICAgICAgbGV0IG9sZERPTSA9IHRoaXMuZG9tO1xuICAgICAgICB0aGlzLmRvbSA9IHBhdGNoT3V0ZXJEZWNvKHRoaXMuZG9tLCB0aGlzLm5vZGVET00sIGNvbXB1dGVPdXRlckRlY28odGhpcy5vdXRlckRlY28sIHRoaXMubm9kZSwgbmVlZHNXcmFwKSwgY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMubm9kZSwgbmVlZHNXcmFwKSk7XG4gICAgICAgIGlmICh0aGlzLmRvbSAhPSBvbGRET00pIHtcbiAgICAgICAgICAgIG9sZERPTS5wbVZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5kb20ucG1WaWV3RGVzYyA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRlckRlY28gPSBvdXRlckRlY287XG4gICAgfVxuICAgIC8vIE1hcmsgdGhpcyBub2RlIGFzIGJlaW5nIHRoZSBzZWxlY3RlZCBub2RlLlxuICAgIHNlbGVjdE5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVET00ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlXCIpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBzZWxlY3RlZCBub2RlIG1hcmtpbmcgZnJvbSB0aGlzIG5vZGUuXG4gICAgZGVzZWxlY3ROb2RlKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlRE9NLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICB0aGlzLm5vZGVET00uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLXNlbGVjdGVkbm9kZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSB8fCAhdGhpcy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUpXG4gICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7XG4gICAgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gdGhpcy5ub2RlLmlzQXRvbTsgfVxufVxuLy8gQ3JlYXRlIGEgdmlldyBkZXNjIGZvciB0aGUgdG9wLWxldmVsIGRvY3VtZW50IG5vZGUsIHRvIGJlIGV4cG9ydGVkXG4vLyBhbmQgdXNlZCBieSB0aGUgdmlldyBjbGFzcy5cbmZ1bmN0aW9uIGRvY1ZpZXdEZXNjKGRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgdmlldykge1xuICAgIGFwcGx5T3V0ZXJEZWNvKGRvbSwgb3V0ZXJEZWNvLCBkb2MpO1xuICAgIGxldCBkb2NWaWV3ID0gbmV3IE5vZGVWaWV3RGVzYyh1bmRlZmluZWQsIGRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgZG9tLCBkb20sIHZpZXcsIDApO1xuICAgIGlmIChkb2NWaWV3LmNvbnRlbnRET00pXG4gICAgICAgIGRvY1ZpZXcudXBkYXRlQ2hpbGRyZW4odmlldywgMCk7XG4gICAgcmV0dXJuIGRvY1ZpZXc7XG59XG5jbGFzcyBUZXh0Vmlld0Rlc2MgZXh0ZW5kcyBOb2RlVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbm9kZURPTSwgdmlldykge1xuICAgICAgICBzdXBlcihwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG51bGwsIG5vZGVET00sIHZpZXcsIDApO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7XG4gICAgICAgIGxldCBza2lwID0gdGhpcy5ub2RlRE9NLnBhcmVudE5vZGU7XG4gICAgICAgIHdoaWxlIChza2lwICYmIHNraXAgIT0gdGhpcy5kb20gJiYgIXNraXAucG1Jc0RlY28pXG4gICAgICAgICAgICBza2lwID0gc2tpcC5wYXJlbnROb2RlO1xuICAgICAgICByZXR1cm4geyBza2lwOiAoc2tpcCB8fCB0cnVlKSB9O1xuICAgIH1cbiAgICB1cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSB8fCAodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkgJiYgIXRoaXMuaW5QYXJlbnQoKSkgfHxcbiAgICAgICAgICAgICFub2RlLnNhbWVNYXJrdXAodGhpcy5ub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKTtcbiAgICAgICAgaWYgKCh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSB8fCBub2RlLnRleHQgIT0gdGhpcy5ub2RlLnRleHQpICYmIG5vZGUudGV4dCAhPSB0aGlzLm5vZGVET00ubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVET00ubm9kZVZhbHVlID0gbm9kZS50ZXh0O1xuICAgICAgICAgICAgaWYgKHZpZXcudHJhY2tXcml0ZXMgPT0gdGhpcy5ub2RlRE9NKVxuICAgICAgICAgICAgICAgIHZpZXcudHJhY2tXcml0ZXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpblBhcmVudCgpIHtcbiAgICAgICAgbGV0IHBhcmVudERPTSA9IHRoaXMucGFyZW50LmNvbnRlbnRET007XG4gICAgICAgIGZvciAobGV0IG4gPSB0aGlzLm5vZGVET007IG47IG4gPSBuLnBhcmVudE5vZGUpXG4gICAgICAgICAgICBpZiAobiA9PSBwYXJlbnRET00pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZG9tRnJvbVBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5ub2RlRE9NLCBvZmZzZXQ6IHBvcyB9O1xuICAgIH1cbiAgICBsb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICAgICAgaWYgKGRvbSA9PSB0aGlzLm5vZGVET00pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgTWF0aC5taW4ob2Zmc2V0LCB0aGlzLm5vZGUudGV4dC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gc3VwZXIubG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uLnR5cGUgIT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbXV0YXRpb24udHlwZSAhPSBcInNlbGVjdGlvblwiO1xuICAgIH1cbiAgICBzbGljZShmcm9tLCB0bywgdmlldykge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMubm9kZS5jdXQoZnJvbSwgdG8pLCBkb20gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLnRleHQpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRWaWV3RGVzYyh0aGlzLnBhcmVudCwgbm9kZSwgdGhpcy5vdXRlckRlY28sIHRoaXMuaW5uZXJEZWNvLCBkb20sIGRvbSwgdmlldyk7XG4gICAgfVxuICAgIG1hcmtEaXJ0eShmcm9tLCB0bykge1xuICAgICAgICBzdXBlci5tYXJrRGlydHkoZnJvbSwgdG8pO1xuICAgICAgICBpZiAodGhpcy5kb20gIT0gdGhpcy5ub2RlRE9NICYmIChmcm9tID09IDAgfHwgdG8gPT0gdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IE5PREVfRElSVFk7XG4gICAgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8vIEEgZHVtbXkgZGVzYyB1c2VkIHRvIHRhZyB0cmFpbGluZyBCUiBvciBJTUcgbm9kZXMgY3JlYXRlZCB0byB3b3JrXG4vLyBhcm91bmQgY29udGVudEVkaXRhYmxlIHRlcnJpYmxlbmVzcy5cbmNsYXNzIFRyYWlsaW5nSGFja1ZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIHBhcnNlUnVsZSgpIHsgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07IH1cbiAgICBtYXRjaGVzSGFjayhub2RlTmFtZSkgeyByZXR1cm4gdGhpcy5kaXJ0eSA9PSBOT1RfRElSVFkgJiYgdGhpcy5kb20ubm9kZU5hbWUgPT0gbm9kZU5hbWU7IH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgaWdub3JlRm9yQ29vcmRzKCkgeyByZXR1cm4gdGhpcy5kb20ubm9kZU5hbWUgPT0gXCJJTUdcIjsgfVxufVxuLy8gQSBzZXBhcmF0ZSBzdWJjbGFzcyBpcyB1c2VkIGZvciBjdXN0b21pemVkIG5vZGUgdmlld3MsIHNvIHRoYXQgdGhlXG4vLyBleHRyYSBjaGVja3Mgb25seSBoYXZlIHRvIGJlIG1hZGUgZm9yIG5vZGVzIHRoYXQgYXJlIGFjdHVhbGx5XG4vLyBjdXN0b21pemVkLlxuY2xhc3MgQ3VzdG9tTm9kZVZpZXdEZXNjIGV4dGVuZHMgTm9kZVZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00sIG5vZGVET00sIHNwZWMsIHZpZXcsIHBvcykge1xuICAgICAgICBzdXBlcihwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00sIG5vZGVET00sIHZpZXcsIHBvcyk7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxuICAgIC8vIEEgY3VzdG9tIGB1cGRhdGVgIG1ldGhvZCBnZXRzIHRvIGRlY2lkZSB3aGV0aGVyIHRoZSB1cGRhdGUgZ29lc1xuICAgIC8vIHRocm91Z2guIElmIGl0IGRvZXMsIGFuZCB0aGVyZSdzIGEgYGNvbnRlbnRET01gIG5vZGUsIG91ciBsb2dpY1xuICAgIC8vIHVwZGF0ZXMgdGhlIGNoaWxkcmVuLlxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zcGVjLnVwZGF0ZSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc3BlYy51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGVudERPTSAmJiAhbm9kZS5pc0xlYWYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdE5vZGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYy5zZWxlY3ROb2RlID8gdGhpcy5zcGVjLnNlbGVjdE5vZGUoKSA6IHN1cGVyLnNlbGVjdE5vZGUoKTtcbiAgICB9XG4gICAgZGVzZWxlY3ROb2RlKCkge1xuICAgICAgICB0aGlzLnNwZWMuZGVzZWxlY3ROb2RlID8gdGhpcy5zcGVjLmRlc2VsZWN0Tm9kZSgpIDogc3VwZXIuZGVzZWxlY3ROb2RlKCk7XG4gICAgfVxuICAgIHNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHJvb3QsIGZvcmNlKSB7XG4gICAgICAgIHRoaXMuc3BlYy5zZXRTZWxlY3Rpb24gPyB0aGlzLnNwZWMuc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgcm9vdClcbiAgICAgICAgICAgIDogc3VwZXIuc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zcGVjLmRlc3Ryb3kpXG4gICAgICAgICAgICB0aGlzLnNwZWMuZGVzdHJveSgpO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHN0b3BFdmVudChldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLnN0b3BFdmVudCA/IHRoaXMuc3BlYy5zdG9wRXZlbnQoZXZlbnQpIDogZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMuaWdub3JlTXV0YXRpb24gPyB0aGlzLnNwZWMuaWdub3JlTXV0YXRpb24obXV0YXRpb24pIDogc3VwZXIuaWdub3JlTXV0YXRpb24obXV0YXRpb24pO1xuICAgIH1cbn1cbi8vIFN5bmMgdGhlIGNvbnRlbnQgb2YgdGhlIGdpdmVuIERPTSBub2RlIHdpdGggdGhlIG5vZGVzIGFzc29jaWF0ZWRcbi8vIHdpdGggdGhlIGdpdmVuIGFycmF5IG9mIHZpZXcgZGVzY3MsIHJlY3Vyc2luZyBpbnRvIG1hcmsgZGVzY3Ncbi8vIGJlY2F1c2UgdGhpcyBzaG91bGQgc3luYyB0aGUgc3VidHJlZSBmb3IgYSB3aG9sZSBub2RlIGF0IGEgdGltZS5cbmZ1bmN0aW9uIHJlbmRlckRlc2NzKHBhcmVudERPTSwgZGVzY3MsIHZpZXcpIHtcbiAgICBsZXQgZG9tID0gcGFyZW50RE9NLmZpcnN0Q2hpbGQsIHdyaXR0ZW4gPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc2NzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkZXNjID0gZGVzY3NbaV0sIGNoaWxkRE9NID0gZGVzYy5kb207XG4gICAgICAgIGlmIChjaGlsZERPTS5wYXJlbnROb2RlID09IHBhcmVudERPTSkge1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkRE9NICE9IGRvbSkge1xuICAgICAgICAgICAgICAgIGRvbSA9IHJtKGRvbSk7XG4gICAgICAgICAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb20gPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhcmVudERPTS5pbnNlcnRCZWZvcmUoY2hpbGRET00sIGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2MgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBkb20gPyBkb20ucHJldmlvdXNTaWJsaW5nIDogcGFyZW50RE9NLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHJlbmRlckRlc2NzKGRlc2MuY29udGVudERPTSwgZGVzYy5jaGlsZHJlbiwgdmlldyk7XG4gICAgICAgICAgICBkb20gPSBwb3MgPyBwb3MubmV4dFNpYmxpbmcgOiBwYXJlbnRET00uZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoZG9tKSB7XG4gICAgICAgIGRvbSA9IHJtKGRvbSk7XG4gICAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAod3JpdHRlbiAmJiB2aWV3LnRyYWNrV3JpdGVzID09IHBhcmVudERPTSlcbiAgICAgICAgdmlldy50cmFja1dyaXRlcyA9IG51bGw7XG59XG5jb25zdCBPdXRlckRlY29MZXZlbCA9IGZ1bmN0aW9uIChub2RlTmFtZSkge1xuICAgIGlmIChub2RlTmFtZSlcbiAgICAgICAgdGhpcy5ub2RlTmFtZSA9IG5vZGVOYW1lO1xufTtcbk91dGVyRGVjb0xldmVsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBub0RlY28gPSBbbmV3IE91dGVyRGVjb0xldmVsXTtcbmZ1bmN0aW9uIGNvbXB1dGVPdXRlckRlY28ob3V0ZXJEZWNvLCBub2RlLCBuZWVkc1dyYXApIHtcbiAgICBpZiAob3V0ZXJEZWNvLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbm9EZWNvO1xuICAgIGxldCB0b3AgPSBuZWVkc1dyYXAgPyBub0RlY29bMF0gOiBuZXcgT3V0ZXJEZWNvTGV2ZWwsIHJlc3VsdCA9IFt0b3BdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0ZXJEZWNvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBhdHRycyA9IG91dGVyRGVjb1tpXS50eXBlLmF0dHJzO1xuICAgICAgICBpZiAoIWF0dHJzKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChhdHRycy5ub2RlTmFtZSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRvcCA9IG5ldyBPdXRlckRlY29MZXZlbChhdHRycy5ub2RlTmFtZSkpO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gYXR0cnNbbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsID09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAobmVlZHNXcmFwICYmIHJlc3VsdC5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0b3AgPSBuZXcgT3V0ZXJEZWNvTGV2ZWwobm9kZS5pc0lubGluZSA/IFwic3BhblwiIDogXCJkaXZcIikpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJjbGFzc1wiKVxuICAgICAgICAgICAgICAgIHRvcC5jbGFzcyA9ICh0b3AuY2xhc3MgPyB0b3AuY2xhc3MgKyBcIiBcIiA6IFwiXCIpICsgdmFsO1xuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PSBcInN0eWxlXCIpXG4gICAgICAgICAgICAgICAgdG9wLnN0eWxlID0gKHRvcC5zdHlsZSA/IHRvcC5zdHlsZSArIFwiO1wiIDogXCJcIikgKyB2YWw7XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lICE9IFwibm9kZU5hbWVcIilcbiAgICAgICAgICAgICAgICB0b3BbbmFtZV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhdGNoT3V0ZXJEZWNvKG91dGVyRE9NLCBub2RlRE9NLCBwcmV2Q29tcHV0ZWQsIGN1ckNvbXB1dGVkKSB7XG4gICAgLy8gU2hvcnRjdXQgZm9yIHRyaXZpYWwgY2FzZVxuICAgIGlmIChwcmV2Q29tcHV0ZWQgPT0gbm9EZWNvICYmIGN1ckNvbXB1dGVkID09IG5vRGVjbylcbiAgICAgICAgcmV0dXJuIG5vZGVET007XG4gICAgbGV0IGN1ckRPTSA9IG5vZGVET007XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJDb21wdXRlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZGVjbyA9IGN1ckNvbXB1dGVkW2ldLCBwcmV2ID0gcHJldkNvbXB1dGVkW2ldO1xuICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudDtcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXYubm9kZU5hbWUgPT0gZGVjby5ub2RlTmFtZSAmJiBjdXJET00gIT0gb3V0ZXJET00gJiZcbiAgICAgICAgICAgICAgICAocGFyZW50ID0gY3VyRE9NLnBhcmVudE5vZGUpICYmIHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09IGRlY28ubm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBjdXJET00gPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGRlY28ubm9kZU5hbWUpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5wbUlzRGVjbyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGN1ckRPTSk7XG4gICAgICAgICAgICAgICAgcHJldiA9IG5vRGVjb1swXTtcbiAgICAgICAgICAgICAgICBjdXJET00gPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2hBdHRyaWJ1dGVzKGN1ckRPTSwgcHJldiB8fCBub0RlY29bMF0sIGRlY28pO1xuICAgIH1cbiAgICByZXR1cm4gY3VyRE9NO1xufVxuZnVuY3Rpb24gcGF0Y2hBdHRyaWJ1dGVzKGRvbSwgcHJldiwgY3VyKSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBwcmV2KVxuICAgICAgICBpZiAobmFtZSAhPSBcImNsYXNzXCIgJiYgbmFtZSAhPSBcInN0eWxlXCIgJiYgbmFtZSAhPSBcIm5vZGVOYW1lXCIgJiYgIShuYW1lIGluIGN1cikpXG4gICAgICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGZvciAobGV0IG5hbWUgaW4gY3VyKVxuICAgICAgICBpZiAobmFtZSAhPSBcImNsYXNzXCIgJiYgbmFtZSAhPSBcInN0eWxlXCIgJiYgbmFtZSAhPSBcIm5vZGVOYW1lXCIgJiYgY3VyW25hbWVdICE9IHByZXZbbmFtZV0pXG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIGN1cltuYW1lXSk7XG4gICAgaWYgKHByZXYuY2xhc3MgIT0gY3VyLmNsYXNzKSB7XG4gICAgICAgIGxldCBwcmV2TGlzdCA9IHByZXYuY2xhc3MgPyBwcmV2LmNsYXNzLnNwbGl0KFwiIFwiKS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcbiAgICAgICAgbGV0IGN1ckxpc3QgPSBjdXIuY2xhc3MgPyBjdXIuY2xhc3Muc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZMaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGN1ckxpc3QuaW5kZXhPZihwcmV2TGlzdFtpXSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC5yZW1vdmUocHJldkxpc3RbaV0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ckxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAocHJldkxpc3QuaW5kZXhPZihjdXJMaXN0W2ldKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NMaXN0LmFkZChjdXJMaXN0W2ldKTtcbiAgICAgICAgaWYgKGRvbS5jbGFzc0xpc3QubGVuZ3RoID09IDApXG4gICAgICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgfVxuICAgIGlmIChwcmV2LnN0eWxlICE9IGN1ci5zdHlsZSkge1xuICAgICAgICBpZiAocHJldi5zdHlsZSkge1xuICAgICAgICAgICAgbGV0IHByb3AgPSAvXFxzKihbXFx3XFwtXFx4YTEtXFx1ZmZmZl0rKVxccyo6KD86XCIoPzpcXFxcLnxbXlwiXSkqXCJ8Jyg/OlxcXFwufFteJ10pKid8XFwoLio/XFwpfFteO10pKi9nLCBtO1xuICAgICAgICAgICAgd2hpbGUgKG0gPSBwcm9wLmV4ZWMocHJldi5zdHlsZSkpXG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnJlbW92ZVByb3BlcnR5KG1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXIuc3R5bGUpXG4gICAgICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCArPSBjdXIuc3R5bGU7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlPdXRlckRlY28oZG9tLCBkZWNvLCBub2RlKSB7XG4gICAgcmV0dXJuIHBhdGNoT3V0ZXJEZWNvKGRvbSwgZG9tLCBub0RlY28sIGNvbXB1dGVPdXRlckRlY28oZGVjbywgbm9kZSwgZG9tLm5vZGVUeXBlICE9IDEpKTtcbn1cbmZ1bmN0aW9uIHNhbWVPdXRlckRlY28oYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFhW2ldLnR5cGUuZXEoYltpXS50eXBlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIFJlbW92ZSBhIERPTSBub2RlIGFuZCByZXR1cm4gaXRzIG5leHQgc2libGluZy5cbmZ1bmN0aW9uIHJtKGRvbSkge1xuICAgIGxldCBuZXh0ID0gZG9tLm5leHRTaWJsaW5nO1xuICAgIGRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbSk7XG4gICAgcmV0dXJuIG5leHQ7XG59XG4vLyBIZWxwZXIgY2xhc3MgZm9yIGluY3JlbWVudGFsbHkgdXBkYXRpbmcgYSB0cmVlIG9mIG1hcmsgZGVzY3MgYW5kXG4vLyB0aGUgd2lkZ2V0IGFuZCBub2RlIGRlc2NzIGluc2lkZSBvZiB0aGVtLlxuY2xhc3MgVmlld1RyZWVVcGRhdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b3AsIGxvY2ssIHZpZXcpIHtcbiAgICAgICAgdGhpcy5sb2NrID0gbG9jaztcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgLy8gSW5kZXggaW50byBgdGhpcy50b3BgJ3MgY2hpbGQgYXJyYXksIHJlcHJlc2VudHMgdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gdXBkYXRlIHBvc2l0aW9uLlxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgLy8gV2hlbiBlbnRlcmluZyBhIG1hcmssIHRoZSBjdXJyZW50IHRvcCBhbmQgaW5kZXggYXJlIHB1c2hlZFxuICAgICAgICAvLyBvbnRvIHRoaXMuXG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgLy8gVHJhY2tzIHdoZXRoZXIgYW55dGhpbmcgd2FzIGNoYW5nZWRcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLnByZU1hdGNoID0gcHJlTWF0Y2godG9wLm5vZGUuY29udGVudCwgdG9wKTtcbiAgICB9XG4gICAgLy8gRGVzdHJveSBhbmQgcmVtb3ZlIHRoZSBjaGlsZHJlbiBiZXR3ZWVuIHRoZSBnaXZlbiBpbmRpY2VzIGluXG4gICAgLy8gYHRoaXMudG9wYC5cbiAgICBkZXN0cm95QmV0d2VlbihzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChzdGFydCA9PSBlbmQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKVxuICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW5baV0uZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRGVzdHJveSBhbGwgcmVtYWluaW5nIGNoaWxkcmVuIGluIGB0aGlzLnRvcGAuXG4gICAgZGVzdHJveVJlc3QoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gU3luYyB0aGUgY3VycmVudCBzdGFjayBvZiBtYXJrIGRlc2NzIHdpdGggdGhlIGdpdmVuIGFycmF5IG9mXG4gICAgLy8gbWFya3MsIHJldXNpbmcgZXhpc3RpbmcgbWFyayBkZXNjcyB3aGVuIHBvc3NpYmxlLlxuICAgIHN5bmNUb01hcmtzKG1hcmtzLCBpbmxpbmUsIHZpZXcpIHtcbiAgICAgICAgbGV0IGtlZXAgPSAwLCBkZXB0aCA9IHRoaXMuc3RhY2subGVuZ3RoID4+IDE7XG4gICAgICAgIGxldCBtYXhLZWVwID0gTWF0aC5taW4oZGVwdGgsIG1hcmtzLmxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChrZWVwIDwgbWF4S2VlcCAmJlxuICAgICAgICAgICAgKGtlZXAgPT0gZGVwdGggLSAxID8gdGhpcy50b3AgOiB0aGlzLnN0YWNrWyhrZWVwICsgMSkgPDwgMV0pXG4gICAgICAgICAgICAgICAgLm1hdGNoZXNNYXJrKG1hcmtzW2tlZXBdKSAmJiBtYXJrc1trZWVwXS50eXBlLnNwZWMuc3Bhbm5pbmcgIT09IGZhbHNlKVxuICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICB3aGlsZSAoa2VlcCA8IGRlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lSZXN0KCk7XG4gICAgICAgICAgICB0aGlzLnRvcC5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy50b3AgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZGVwdGggPCBtYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnRvcCwgdGhpcy5pbmRleCArIDEpO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gLTE7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IE1hdGgubWluKHRoaXMuaW5kZXggKyAzLCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMudG9wLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Lm1hdGNoZXNNYXJrKG1hcmtzW2RlcHRoXSkgJiYgIXRoaXMuaXNMb2NrZWQobmV4dC5kb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiB0aGlzLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgZm91bmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmtEZXNjID0gTWFya1ZpZXdEZXNjLmNyZWF0ZSh0aGlzLnRvcCwgbWFya3NbZGVwdGhdLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4LCAwLCBtYXJrRGVzYyk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3AgPSBtYXJrRGVzYztcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRyeSB0byBmaW5kIGEgbm9kZSBkZXNjIG1hdGNoaW5nIHRoZSBnaXZlbiBkYXRhLiBTa2lwIG92ZXIgaXQgYW5kXG4gICAgLy8gcmV0dXJuIHRydWUgd2hlbiBzdWNjZXNzZnVsLlxuICAgIGZpbmROb2RlTWF0Y2gobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGluZGV4KSB7XG4gICAgICAgIGxldCBmb3VuZCA9IC0xLCB0YXJnZXREZXNjO1xuICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5wcmVNYXRjaC5pbmRleCAmJlxuICAgICAgICAgICAgKHRhcmdldERlc2MgPSB0aGlzLnByZU1hdGNoLm1hdGNoZXNbaW5kZXggLSB0aGlzLnByZU1hdGNoLmluZGV4XSkucGFyZW50ID09IHRoaXMudG9wICYmXG4gICAgICAgICAgICB0YXJnZXREZXNjLm1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSkge1xuICAgICAgICAgICAgZm91bmQgPSB0aGlzLnRvcC5jaGlsZHJlbi5pbmRleE9mKHRhcmdldERlc2MsIHRoaXMuaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXgsIGUgPSBNYXRoLm1pbih0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgsIGkgKyA1KTsgaSA8IGU7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMudG9wLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5tYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykgJiYgIXRoaXMucHJlTWF0Y2gubWF0Y2hlZC5oYXMoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgZm91bmQpO1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB1cGRhdGVOb2RlQXQobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGluZGV4LCB2aWV3KSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHRoaXMudG9wLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgaWYgKGNoaWxkLmRpcnR5ID09IE5PREVfRElSVFkgJiYgY2hpbGQuZG9tID09IGNoaWxkLmNvbnRlbnRET00pXG4gICAgICAgICAgICBjaGlsZC5kaXJ0eSA9IENPTlRFTlRfRElSVFk7XG4gICAgICAgIGlmICghY2hpbGQudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBpbmRleCk7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZpbmRJbmRleFdpdGhDaGlsZChkb21Ob2RlKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBkb21Ob2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAocGFyZW50ID09IHRoaXMudG9wLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVzYyA9IGRvbU5vZGUucG1WaWV3RGVzYztcbiAgICAgICAgICAgICAgICBpZiAoZGVzYylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXg7IGkgPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG9wLmNoaWxkcmVuW2ldID09IGRlc2MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21Ob2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRyeSB0byB1cGRhdGUgdGhlIG5leHQgbm9kZSwgaWYgYW55LCB0byB0aGUgZ2l2ZW4gZGF0YS4gQ2hlY2tzXG4gICAgLy8gcHJlLW1hdGNoZXMgdG8gYXZvaWQgb3ZlcndyaXRpbmcgbm9kZXMgdGhhdCBjb3VsZCBzdGlsbCBiZSB1c2VkLlxuICAgIHVwZGF0ZU5leHROb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBpbmRleCwgcG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIE5vZGVWaWV3RGVzYykge1xuICAgICAgICAgICAgICAgIGxldCBwcmVNYXRjaCA9IHRoaXMucHJlTWF0Y2gubWF0Y2hlZC5nZXQobmV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZU1hdGNoICE9IG51bGwgJiYgcHJlTWF0Y2ggIT0gaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dERPTSA9IG5leHQuZG9tLCB1cGRhdGVkO1xuICAgICAgICAgICAgICAgIC8vIENhbid0IHVwZGF0ZSBpZiBuZXh0RE9NIGlzIG9yIGNvbnRhaW5zIHRoaXMubG9jaywgZXhjZXB0IGlmXG4gICAgICAgICAgICAgICAgLy8gaXQncyBhIHRleHQgbm9kZSB3aG9zZSBjb250ZW50IGFscmVhZHkgbWF0Y2hlcyB0aGUgbmV3IHRleHRcbiAgICAgICAgICAgICAgICAvLyBhbmQgd2hvc2UgZGVjb3JhdGlvbnMgbWF0Y2ggdGhlIG5ldyBvbmVzLlxuICAgICAgICAgICAgICAgIGxldCBsb2NrZWQgPSB0aGlzLmlzTG9ja2VkKG5leHRET00pICYmXG4gICAgICAgICAgICAgICAgICAgICEobm9kZS5pc1RleHQgJiYgbmV4dC5ub2RlICYmIG5leHQubm9kZS5pc1RleHQgJiYgbmV4dC5ub2RlRE9NLm5vZGVWYWx1ZSA9PSBub2RlLnRleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQuZGlydHkgIT0gTk9ERV9ESVJUWSAmJiBzYW1lT3V0ZXJEZWNvKG91dGVyRGVjbywgbmV4dC5vdXRlckRlY28pKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxvY2tlZCAmJiBuZXh0LnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuZG9tICE9IG5leHRET00pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghbG9ja2VkICYmICh1cGRhdGVkID0gdGhpcy5yZWNyZWF0ZVdyYXBwZXIobmV4dCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXhdID0gdXBkYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWQuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5kaXJ0eSA9IENPTlRFTlRfRElSVFk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLnVwZGF0ZUNoaWxkcmVuKHZpZXcsIHBvcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFdoZW4gYSBub2RlIHdpdGggY29udGVudCBpcyByZXBsYWNlZCBieSBhIGRpZmZlcmVudCBub2RlIHdpdGhcbiAgICAvLyBpZGVudGljYWwgY29udGVudCwgbW92ZSBvdmVyIGl0cyBjaGlsZHJlbi5cbiAgICByZWNyZWF0ZVdyYXBwZXIobmV4dCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykge1xuICAgICAgICBpZiAobmV4dC5kaXJ0eSB8fCBub2RlLmlzQXRvbSB8fCAhbmV4dC5jaGlsZHJlbi5sZW5ndGggfHxcbiAgICAgICAgICAgICFuZXh0Lm5vZGUuY29udGVudC5lcShub2RlLmNvbnRlbnQpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB3cmFwcGVyID0gTm9kZVZpZXdEZXNjLmNyZWF0ZSh0aGlzLnRvcCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcyk7XG4gICAgICAgIGlmICh3cmFwcGVyLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIHdyYXBwZXIuY2hpbGRyZW4gPSBuZXh0LmNoaWxkcmVuO1xuICAgICAgICAgICAgbmV4dC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2ggb2Ygd3JhcHBlci5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaC5wYXJlbnQgPSB3cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIG5leHQuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgLy8gSW5zZXJ0IHRoZSBub2RlIGFzIGEgbmV3bHkgY3JlYXRlZCBub2RlIGRlc2MuXG4gICAgYWRkTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSB7XG4gICAgICAgIGxldCBkZXNjID0gTm9kZVZpZXdEZXNjLmNyZWF0ZSh0aGlzLnRvcCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcyk7XG4gICAgICAgIGlmIChkZXNjLmNvbnRlbnRET00pXG4gICAgICAgICAgICBkZXNjLnVwZGF0ZUNoaWxkcmVuKHZpZXcsIHBvcyArIDEpO1xuICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBkZXNjKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgcGxhY2VXaWRnZXQod2lkZ2V0LCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLmluZGV4IDwgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF0gOiBudWxsO1xuICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lm1hdGNoZXNXaWRnZXQod2lkZ2V0KSAmJlxuICAgICAgICAgICAgKHdpZGdldCA9PSBuZXh0LndpZGdldCB8fCAhbmV4dC53aWRnZXQudHlwZS50b0RPTS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRlc2MgPSBuZXcgV2lkZ2V0Vmlld0Rlc2ModGhpcy50b3AsIHdpZGdldCwgdmlldywgcG9zKTtcbiAgICAgICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4KyssIDAsIGRlc2MpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgYSB0ZXh0YmxvY2sgbG9va3MgYW5kIGJlaGF2ZXMgY29ycmVjdGx5IGluXG4gICAgLy8gY29udGVudEVkaXRhYmxlLlxuICAgIGFkZFRleHRibG9ja0hhY2tzKCkge1xuICAgICAgICBsZXQgbGFzdENoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleCAtIDFdLCBwYXJlbnQgPSB0aGlzLnRvcDtcbiAgICAgICAgd2hpbGUgKGxhc3RDaGlsZCBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgcGFyZW50ID0gbGFzdENoaWxkO1xuICAgICAgICAgICAgbGFzdENoaWxkID0gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxhc3RDaGlsZCB8fCAvLyBFbXB0eSB0ZXh0YmxvY2tcbiAgICAgICAgICAgICEobGFzdENoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXdEZXNjKSB8fFxuICAgICAgICAgICAgL1xcbiQvLnRlc3QobGFzdENoaWxkLm5vZGUudGV4dCkgfHxcbiAgICAgICAgICAgICh0aGlzLnZpZXcucmVxdWlyZXNHZWNrb0hhY2tOb2RlICYmIC9cXHMkLy50ZXN0KGxhc3RDaGlsZC5ub2RlLnRleHQpKSkge1xuICAgICAgICAgICAgLy8gQXZvaWQgYnVncyBpbiBTYWZhcmkncyBjdXJzb3IgZHJhd2luZyAoIzExNjUpIGFuZCBDaHJvbWUncyBtb3VzZSBzZWxlY3Rpb24gKCMxMTUyKVxuICAgICAgICAgICAgaWYgKChzYWZhcmkgfHwgY2hyb21lKSAmJiBsYXN0Q2hpbGQgJiYgbGFzdENoaWxkLmRvbS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkSGFja05vZGUoXCJJTUdcIiwgcGFyZW50KTtcbiAgICAgICAgICAgIHRoaXMuYWRkSGFja05vZGUoXCJCUlwiLCB0aGlzLnRvcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkSGFja05vZGUobm9kZU5hbWUsIHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ID09IHRoaXMudG9wICYmIHRoaXMuaW5kZXggPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoICYmIHBhcmVudC5jaGlsZHJlblt0aGlzLmluZGV4XS5tYXRjaGVzSGFjayhub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PSBcIklNR1wiKSB7XG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3Itc2VwYXJhdG9yXCI7XG4gICAgICAgICAgICAgICAgZG9tLmFsdCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZU5hbWUgPT0gXCJCUlwiKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLXRyYWlsaW5nQnJlYWtcIjtcbiAgICAgICAgICAgIGxldCBoYWNrID0gbmV3IFRyYWlsaW5nSGFja1ZpZXdEZXNjKHRoaXMudG9wLCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgIT0gdGhpcy50b3ApXG4gICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2goaGFjayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4KyssIDAsIGhhY2spO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0xvY2tlZChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2sgJiYgKG5vZGUgPT0gdGhpcy5sb2NrIHx8IG5vZGUubm9kZVR5cGUgPT0gMSAmJiBub2RlLmNvbnRhaW5zKHRoaXMubG9jay5wYXJlbnROb2RlKSk7XG4gICAgfVxufVxuLy8gSXRlcmF0ZSBmcm9tIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50IGFuZCBhcnJheSBvZiBkZXNjcyB0byBmaW5kXG4vLyBkaXJlY3RseSBtYXRjaGluZyBvbmVzLCBpbiBvcmRlciB0byBhdm9pZCBvdmVyZWFnZXJseSByZXVzaW5nIHRob3NlXG4vLyBmb3Igb3RoZXIgbm9kZXMuIFJldHVybnMgdGhlIGZyYWdtZW50IGluZGV4IG9mIHRoZSBmaXJzdCBub2RlIHRoYXRcbi8vIGlzIHBhcnQgb2YgdGhlIHNlcXVlbmNlIG9mIG1hdGNoZWQgbm9kZXMgYXQgdGhlIGVuZCBvZiB0aGVcbi8vIGZyYWdtZW50LlxuZnVuY3Rpb24gcHJlTWF0Y2goZnJhZywgcGFyZW50RGVzYykge1xuICAgIGxldCBjdXJEZXNjID0gcGFyZW50RGVzYywgZGVzY0kgPSBjdXJEZXNjLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBsZXQgZkkgPSBmcmFnLmNoaWxkQ291bnQsIG1hdGNoZWQgPSBuZXcgTWFwLCBtYXRjaGVzID0gW107XG4gICAgb3V0ZXI6IHdoaWxlIChmSSA+IDApIHtcbiAgICAgICAgbGV0IGRlc2M7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChkZXNjSSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY3VyRGVzYy5jaGlsZHJlbltkZXNjSSAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ckRlc2MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkZXNjSSA9IG5leHQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NJLS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1ckRlc2MgPT0gcGFyZW50RGVzYykge1xuICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICBkZXNjSSA9IGN1ckRlc2MucGFyZW50LmNoaWxkcmVuLmluZGV4T2YoY3VyRGVzYyk7XG4gICAgICAgICAgICAgICAgY3VyRGVzYyA9IGN1ckRlc2MucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlID0gZGVzYy5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKG5vZGUgIT0gZnJhZy5jaGlsZChmSSAtIDEpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC0tZkk7XG4gICAgICAgIG1hdGNoZWQuc2V0KGRlc2MsIGZJKTtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGRlc2MpO1xuICAgIH1cbiAgICByZXR1cm4geyBpbmRleDogZkksIG1hdGNoZWQsIG1hdGNoZXM6IG1hdGNoZXMucmV2ZXJzZSgpIH07XG59XG5mdW5jdGlvbiBjb21wYXJlU2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIGEudHlwZS5zaWRlIC0gYi50eXBlLnNpZGU7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIGFic3RyYWN0cyBpdGVyYXRpbmcgb3ZlciB0aGUgbm9kZXMgYW5kIGRlY29yYXRpb25zIGluXG4vLyBhIGZyYWdtZW50LiBDYWxscyBgb25Ob2RlYCBmb3IgZWFjaCBub2RlLCB3aXRoIGl0cyBsb2NhbCBhbmQgY2hpbGRcbi8vIGRlY29yYXRpb25zLiBTcGxpdHMgdGV4dCBub2RlcyB3aGVuIHRoZXJlIGlzIGEgZGVjb3JhdGlvbiBzdGFydGluZ1xuLy8gb3IgZW5kaW5nIGluc2lkZSBvZiB0aGVtLiBDYWxscyBgb25XaWRnZXRgIGZvciBlYWNoIHdpZGdldC5cbmZ1bmN0aW9uIGl0ZXJEZWNvKHBhcmVudCwgZGVjbywgb25XaWRnZXQsIG9uTm9kZSkge1xuICAgIGxldCBsb2NhbHMgPSBkZWNvLmxvY2FscyhwYXJlbnQpLCBvZmZzZXQgPSAwO1xuICAgIC8vIFNpbXBsZSwgY2hlYXAgdmFyaWFudCBmb3Igd2hlbiB0aGVyZSBhcmUgbm8gbG9jYWwgZGVjb3JhdGlvbnNcbiAgICBpZiAobG9jYWxzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50LmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50LmNoaWxkKGkpO1xuICAgICAgICAgICAgb25Ob2RlKGNoaWxkLCBsb2NhbHMsIGRlY28uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCksIGkpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGRlY29JbmRleCA9IDAsIGFjdGl2ZSA9IFtdLCByZXN0Tm9kZSA9IG51bGw7XG4gICAgZm9yIChsZXQgcGFyZW50SW5kZXggPSAwOzspIHtcbiAgICAgICAgbGV0IHdpZGdldCwgd2lkZ2V0cztcbiAgICAgICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGxvY2Fsc1tkZWNvSW5kZXgrK107XG4gICAgICAgICAgICBpZiAobmV4dC53aWRnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdpZGdldClcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICh3aWRnZXRzIHx8ICh3aWRnZXRzID0gW3dpZGdldF0pKS5wdXNoKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgICAgIGlmICh3aWRnZXRzKSB7XG4gICAgICAgICAgICAgICAgd2lkZ2V0cy5zb3J0KGNvbXBhcmVTaWRlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZGdldHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIG9uV2lkZ2V0KHdpZGdldHNbaV0sIHBhcmVudEluZGV4LCAhIXJlc3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9uV2lkZ2V0KHdpZGdldCwgcGFyZW50SW5kZXgsICEhcmVzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjaGlsZCwgaW5kZXg7XG4gICAgICAgIGlmIChyZXN0Tm9kZSkge1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNoaWxkID0gcmVzdE5vZGU7XG4gICAgICAgICAgICByZXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyZW50SW5kZXggPCBwYXJlbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgICAgICAgIGNoaWxkID0gcGFyZW50LmNoaWxkKHBhcmVudEluZGV4KyspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoYWN0aXZlW2ldLnRvIDw9IG9mZnNldClcbiAgICAgICAgICAgICAgICBhY3RpdmUuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLmZyb20gPD0gb2Zmc2V0ICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID4gb2Zmc2V0KVxuICAgICAgICAgICAgYWN0aXZlLnB1c2gobG9jYWxzW2RlY29JbmRleCsrXSk7XG4gICAgICAgIGxldCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgaWYgKGNoaWxkLmlzVGV4dCkge1xuICAgICAgICAgICAgbGV0IGN1dEF0ID0gZW5kO1xuICAgICAgICAgICAgaWYgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0uZnJvbSA8IGN1dEF0KVxuICAgICAgICAgICAgICAgIGN1dEF0ID0gbG9jYWxzW2RlY29JbmRleF0uZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVbaV0udG8gPCBjdXRBdClcbiAgICAgICAgICAgICAgICAgICAgY3V0QXQgPSBhY3RpdmVbaV0udG87XG4gICAgICAgICAgICBpZiAoY3V0QXQgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICByZXN0Tm9kZSA9IGNoaWxkLmN1dChjdXRBdCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jdXQoMCwgY3V0QXQgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGN1dEF0O1xuICAgICAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA8IGVuZClcbiAgICAgICAgICAgICAgICBkZWNvSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0ZXJEZWNvID0gY2hpbGQuaXNJbmxpbmUgJiYgIWNoaWxkLmlzTGVhZiA/IGFjdGl2ZS5maWx0ZXIoZCA9PiAhZC5pbmxpbmUpIDogYWN0aXZlLnNsaWNlKCk7XG4gICAgICAgIG9uTm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBkZWNvLmZvckNoaWxkKG9mZnNldCwgY2hpbGQpLCBpbmRleCk7XG4gICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG59XG4vLyBMaXN0IG1hcmtlcnMgaW4gTW9iaWxlIFNhZmFyaSB3aWxsIG15c3RlcmlvdXNseSBkaXNhcHBlYXJcbi8vIHNvbWV0aW1lcy4gVGhpcyB3b3JrcyBhcm91bmQgdGhhdC5cbmZ1bmN0aW9uIGlvc0hhY2tzKGRvbSkge1xuICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJVTFwiIHx8IGRvbS5ub2RlTmFtZSA9PSBcIk9MXCIpIHtcbiAgICAgICAgbGV0IG9sZENTUyA9IGRvbS5zdHlsZS5jc3NUZXh0O1xuICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG9sZENTUyArIFwiOyBsaXN0LXN0eWxlOiBzcXVhcmUgIWltcG9ydGFudFwiO1xuICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20pLmxpc3RTdHlsZTtcbiAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBvbGRDU1M7XG4gICAgfVxufVxuZnVuY3Rpb24gbmVhcmJ5VGV4dE5vZGUobm9kZSwgb2Zmc2V0KSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiBvZmZzZXQgJiYgbm9kZS5jaGlsZE5vZGVzW29mZnNldF0ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZVNpemUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEZpbmQgYSBwaWVjZSBvZiB0ZXh0IGluIGFuIGlubGluZSBmcmFnbWVudCwgb3ZlcmxhcHBpbmcgZnJvbS10b1xuZnVuY3Rpb24gZmluZFRleHRJbkZyYWdtZW50KGZyYWcsIHRleHQsIGZyb20sIHRvKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBmcmFnLmNoaWxkQ291bnQgJiYgcG9zIDw9IHRvOykge1xuICAgICAgICBsZXQgY2hpbGQgPSBmcmFnLmNoaWxkKGkrKyksIGNoaWxkU3RhcnQgPSBwb3M7XG4gICAgICAgIHBvcyArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgaWYgKCFjaGlsZC5pc1RleHQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IHN0ciA9IGNoaWxkLnRleHQ7XG4gICAgICAgIHdoaWxlIChpIDwgZnJhZy5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGZyYWcuY2hpbGQoaSsrKTtcbiAgICAgICAgICAgIHBvcyArPSBuZXh0Lm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKCFuZXh0LmlzVGV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0ciArPSBuZXh0LnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSBmcm9tKSB7XG4gICAgICAgICAgICBpZiAocG9zID49IHRvICYmIHN0ci5zbGljZSh0byAtIHRleHQubGVuZ3RoIC0gY2hpbGRTdGFydCwgdG8gLSBjaGlsZFN0YXJ0KSA9PSB0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0byAtIHRleHQubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gY2hpbGRTdGFydCA8IHRvID8gc3RyLmxhc3RJbmRleE9mKHRleHQsIHRvIC0gY2hpbGRTdGFydCAtIDEpIDogLTE7XG4gICAgICAgICAgICBpZiAoZm91bmQgPj0gMCAmJiBmb3VuZCArIHRleHQubGVuZ3RoICsgY2hpbGRTdGFydCA+PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFN0YXJ0ICsgZm91bmQ7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PSB0byAmJiBzdHIubGVuZ3RoID49ICh0byArIHRleHQubGVuZ3RoKSAtIGNoaWxkU3RhcnQgJiZcbiAgICAgICAgICAgICAgICBzdHIuc2xpY2UodG8gLSBjaGlsZFN0YXJ0LCB0byAtIGNoaWxkU3RhcnQgKyB0ZXh0Lmxlbmd0aCkgPT0gdGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gdG87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuLy8gUmVwbGFjZSByYW5nZSBmcm9tLXRvIGluIGFuIGFycmF5IG9mIHZpZXcgZGVzY3Mgd2l0aCByZXBsYWNlbWVudFxuLy8gKG1heSBiZSBudWxsIHRvIGp1c3QgZGVsZXRlKS4gVGhpcyBnb2VzIHZlcnkgbXVjaCBhZ2FpbnN0IHRoZSBncmFpblxuLy8gb2YgdGhlIHJlc3Qgb2YgdGhpcyBjb2RlLCB3aGljaCB0ZW5kcyB0byBjcmVhdGUgbm9kZXMgd2l0aCB0aGVcbi8vIHJpZ2h0IHNoYXBlIGluIG9uZSBnbywgcmF0aGVyIHRoYW4gbWVzc2luZyB3aXRoIHRoZW0gYWZ0ZXJcbi8vIGNyZWF0aW9uLCBidXQgaXMgbmVjZXNzYXJ5IGluIHRoZSBjb21wb3NpdGlvbiBoYWNrLlxuZnVuY3Rpb24gcmVwbGFjZU5vZGVzKG5vZGVzLCBmcm9tLCB0bywgdmlldywgcmVwbGFjZW1lbnQpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIG9mZiA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBub2Rlc1tpXSwgc3RhcnQgPSBvZmYsIGVuZCA9IG9mZiArPSBjaGlsZC5zaXplO1xuICAgICAgICBpZiAoc3RhcnQgPj0gdG8gfHwgZW5kIDw9IGZyb20pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQuc2xpY2UoMCwgZnJvbSAtIHN0YXJ0LCB2aWV3KSk7XG4gICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChyZXBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQuc2xpY2UodG8gLSBzdGFydCwgY2hpbGQuc2l6ZSwgdmlldykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbkZyb21ET00odmlldywgb3JpZ2luID0gbnVsbCkge1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCksIGRvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIGlmICghZG9tU2VsLmZvY3VzTm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG5lYXJlc3REZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGRvbVNlbC5mb2N1c05vZGUpLCBpbldpZGdldCA9IG5lYXJlc3REZXNjICYmIG5lYXJlc3REZXNjLnNpemUgPT0gMDtcbiAgICBsZXQgaGVhZCA9IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCwgMSk7XG4gICAgaWYgKGhlYWQgPCAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgJGhlYWQgPSBkb2MucmVzb2x2ZShoZWFkKSwgJGFuY2hvciwgc2VsZWN0aW9uO1xuICAgIGlmIChzZWxlY3Rpb25Db2xsYXBzZWQoZG9tU2VsKSkge1xuICAgICAgICAkYW5jaG9yID0gJGhlYWQ7XG4gICAgICAgIHdoaWxlIChuZWFyZXN0RGVzYyAmJiAhbmVhcmVzdERlc2Mubm9kZSlcbiAgICAgICAgICAgIG5lYXJlc3REZXNjID0gbmVhcmVzdERlc2MucGFyZW50O1xuICAgICAgICBsZXQgbmVhcmVzdERlc2NOb2RlID0gbmVhcmVzdERlc2Mubm9kZTtcbiAgICAgICAgaWYgKG5lYXJlc3REZXNjICYmIG5lYXJlc3REZXNjTm9kZS5pc0F0b20gJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobmVhcmVzdERlc2NOb2RlKSAmJiBuZWFyZXN0RGVzYy5wYXJlbnRcbiAgICAgICAgICAgICYmICEobmVhcmVzdERlc2NOb2RlLmlzSW5saW5lICYmIGlzT25FZGdlKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCwgbmVhcmVzdERlc2MuZG9tKSkpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBuZWFyZXN0RGVzYy5wb3NCZWZvcmU7XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBuZXcgTm9kZVNlbGVjdGlvbihoZWFkID09IHBvcyA/ICRoZWFkIDogZG9jLnJlc29sdmUocG9zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBhbmNob3IgPSB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCwgMSk7XG4gICAgICAgIGlmIChhbmNob3IgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICRhbmNob3IgPSBkb2MucmVzb2x2ZShhbmNob3IpO1xuICAgIH1cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgICBsZXQgYmlhcyA9IG9yaWdpbiA9PSBcInBvaW50ZXJcIiB8fCAodmlldy5zdGF0ZS5zZWxlY3Rpb24uaGVhZCA8ICRoZWFkLnBvcyAmJiAhaW5XaWRnZXQpID8gMSA6IC0xO1xuICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRhbmNob3IsICRoZWFkLCBiaWFzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uIGVkaXRvck93bnNTZWxlY3Rpb24odmlldykge1xuICAgIHJldHVybiB2aWV3LmVkaXRhYmxlID8gdmlldy5oYXNGb2N1cygpIDpcbiAgICAgICAgaGFzU2VsZWN0aW9uKHZpZXcpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jb250YWlucyh2aWV3LmRvbSk7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Ub0RPTSh2aWV3LCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIHN5bmNOb2RlU2VsZWN0aW9uKHZpZXcsIHNlbCk7XG4gICAgaWYgKCFlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpKVxuICAgICAgICByZXR1cm47XG4gICAgLy8gVGhlIGRlbGF5ZWQgZHJhZyBzZWxlY3Rpb24gY2F1c2VzIGlzc3VlcyB3aXRoIENlbGwgU2VsZWN0aW9uc1xuICAgIC8vIGluIFNhZmFyaS4gQW5kIHRoZSBkcmFnIHNlbGVjdGlvbiBkZWxheSBpcyB0byB3b3JrYXJvbmQgaXNzdWVzXG4gICAgLy8gd2hpY2ggb25seSBwcmVzZW50IGluIENocm9tZS5cbiAgICBpZiAoIWZvcmNlICYmIHZpZXcuaW5wdXQubW91c2VEb3duICYmIHZpZXcuaW5wdXQubW91c2VEb3duLmFsbG93RGVmYXVsdCAmJiBjaHJvbWUpIHtcbiAgICAgICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSwgY3VyU2VsID0gdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICBpZiAoZG9tU2VsLmFuY2hvck5vZGUgJiYgY3VyU2VsLmFuY2hvck5vZGUgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0LCBjdXJTZWwuYW5jaG9yTm9kZSwgY3VyU2VsLmFuY2hvck9mZnNldCkpIHtcbiAgICAgICAgICAgIHZpZXcuaW5wdXQubW91c2VEb3duLmRlbGF5ZWRTZWxlY3Rpb25TeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5kaXNjb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHZpZXcuY3Vyc29yV3JhcHBlcikge1xuICAgICAgICBzZWxlY3RDdXJzb3JXcmFwcGVyKHZpZXcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHsgYW5jaG9yLCBoZWFkIH0gPSBzZWwsIHJlc2V0RWRpdGFibGVGcm9tLCByZXNldEVkaXRhYmxlVG87XG4gICAgICAgIGlmIChicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSAmJiAhKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAoIXNlbC4kZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlRnJvbSA9IHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHNlbC5mcm9tKTtcbiAgICAgICAgICAgIGlmICghc2VsLmVtcHR5ICYmICFzZWwuJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZVRvID0gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgc2VsLnRvKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRvY1ZpZXcuc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgdmlldy5yb290LCBmb3JjZSk7XG4gICAgICAgIGlmIChicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSkge1xuICAgICAgICAgICAgaWYgKHJlc2V0RWRpdGFibGVGcm9tKVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGUocmVzZXRFZGl0YWJsZUZyb20pO1xuICAgICAgICAgICAgaWYgKHJlc2V0RWRpdGFibGVUbylcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlKHJlc2V0RWRpdGFibGVUbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbC52aXNpYmxlKSB7XG4gICAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgICAgICAgaWYgKFwib25zZWxlY3Rpb25jaGFuZ2VcIiBpbiBkb2N1bWVudClcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzc09uU2VsZWN0aW9uQ2hhbmdlKHZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgdmlldy5kb21PYnNlcnZlci5jb25uZWN0U2VsZWN0aW9uKCk7XG59XG4vLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgV2Via2l0IG5vdCBhbGxvd2luZyBhIHNlbGVjdGlvbiB0byBzdGFydC9lbmRcbi8vIGJldHdlZW4gbm9uLWVkaXRhYmxlIGJsb2NrIG5vZGVzLiBXZSBicmllZmx5IG1ha2Ugc29tZXRoaW5nXG4vLyBlZGl0YWJsZSwgc2V0IHRoZSBzZWxlY3Rpb24sIHRoZW4gc2V0IGl0IHVuZWRpdGFibGUgYWdhaW4uXG5jb25zdCBicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSA9IHNhZmFyaSB8fCBjaHJvbWUgJiYgY2hyb21lX3ZlcnNpb24gPCA2MztcbmZ1bmN0aW9uIHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHBvcykge1xuICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCAwKTtcbiAgICBsZXQgYWZ0ZXIgPSBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoID8gbm9kZS5jaGlsZE5vZGVzW29mZnNldF0gOiBudWxsO1xuICAgIGxldCBiZWZvcmUgPSBvZmZzZXQgPyBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0gOiBudWxsO1xuICAgIGlmIChzYWZhcmkgJiYgYWZ0ZXIgJiYgYWZ0ZXIuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgcmV0dXJuIHNldEVkaXRhYmxlKGFmdGVyKTtcbiAgICBpZiAoKCFhZnRlciB8fCBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSAmJlxuICAgICAgICAoIWJlZm9yZSB8fCBiZWZvcmUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikpIHtcbiAgICAgICAgaWYgKGFmdGVyKVxuICAgICAgICAgICAgcmV0dXJuIHNldEVkaXRhYmxlKGFmdGVyKTtcbiAgICAgICAgZWxzZSBpZiAoYmVmb3JlKVxuICAgICAgICAgICAgcmV0dXJuIHNldEVkaXRhYmxlKGJlZm9yZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0RWRpdGFibGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCI7XG4gICAgaWYgKHNhZmFyaSAmJiBlbGVtZW50LmRyYWdnYWJsZSkge1xuICAgICAgICBlbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICBlbGVtZW50Lndhc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuZnVuY3Rpb24gcmVzZXRFZGl0YWJsZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgaWYgKGVsZW1lbnQud2FzRHJhZ2dhYmxlKSB7XG4gICAgICAgIGVsZW1lbnQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgZWxlbWVudC53YXNEcmFnZ2FibGUgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzT25TZWxlY3Rpb25DaGFuZ2Uodmlldykge1xuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50O1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkKTtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBub2RlID0gZG9tU2VsLmFuY2hvck5vZGUsIG9mZnNldCA9IGRvbVNlbC5hbmNob3JPZmZzZXQ7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChkb21TZWwuYW5jaG9yTm9kZSAhPSBub2RlIHx8IGRvbVNlbC5hbmNob3JPZmZzZXQgIT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVkaXRvck93bnNTZWxlY3Rpb24odmlldykgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNlbGVjdEN1cnNvcldyYXBwZXIodmlldykge1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpLCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSB2aWV3LmN1cnNvcldyYXBwZXIuZG9tLCBpbWcgPSBub2RlLm5vZGVOYW1lID09IFwiSU1HXCI7XG4gICAgaWYgKGltZylcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUucGFyZW50Tm9kZSwgZG9tSW5kZXgobm9kZSkgKyAxKTtcbiAgICBlbHNlXG4gICAgICAgIHJhbmdlLnNldEVuZChub2RlLCAwKTtcbiAgICByYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gICAgZG9tU2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIGRvbVNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgLy8gS2x1ZGdlIHRvIGtpbGwgJ2NvbnRyb2wgc2VsZWN0aW9uJyBpbiBJRTExIHdoZW4gc2VsZWN0aW5nIGFuXG4gICAgLy8gaW52aXNpYmxlIGN1cnNvciB3cmFwcGVyLCBzaW5jZSB0aGF0IHdvdWxkIHJlc3VsdCBpbiB0aG9zZSB3ZWlyZFxuICAgIC8vIHJlc2l6ZSBoYW5kbGVzIGFuZCBhIHNlbGVjdGlvbiB0aGF0IGNvbnNpZGVycyB0aGUgYWJzb2x1dGVseVxuICAgIC8vIHBvc2l0aW9uZWQgd3JhcHBlciwgcmF0aGVyIHRoYW4gdGhlIHJvb3QgZWRpdGFibGUgbm9kZSwgdGhlXG4gICAgLy8gZm9jdXNlZCBlbGVtZW50LlxuICAgIGlmICghaW1nICYmICF2aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlICYmIGllICYmIGllX3ZlcnNpb24gPD0gMTEpIHtcbiAgICAgICAgbm9kZS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIG5vZGUuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBzeW5jTm9kZVNlbGVjdGlvbih2aWV3LCBzZWwpIHtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5kZXNjQXQoc2VsLmZyb20pO1xuICAgICAgICBpZiAoZGVzYyAhPSB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjKSB7XG4gICAgICAgICAgICBjbGVhck5vZGVTZWxlY3Rpb24odmlldyk7XG4gICAgICAgICAgICBpZiAoZGVzYylcbiAgICAgICAgICAgICAgICBkZXNjLnNlbGVjdE5vZGUoKTtcbiAgICAgICAgICAgIHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSBkZXNjO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjbGVhck5vZGVTZWxlY3Rpb24odmlldyk7XG4gICAgfVxufVxuLy8gQ2xlYXIgYWxsIERPTSBzdGF0ZWZ1bG5lc3Mgb2YgdGhlIGxhc3Qgbm9kZSBzZWxlY3Rpb24uXG5mdW5jdGlvbiBjbGVhck5vZGVTZWxlY3Rpb24odmlldykge1xuICAgIGlmICh2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjKSB7XG4gICAgICAgIGlmICh2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjLnBhcmVudClcbiAgICAgICAgICAgIHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MuZGVzZWxlY3ROb2RlKCk7XG4gICAgICAgIHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkYW5jaG9yLCAkaGVhZCwgYmlhcykge1xuICAgIHJldHVybiB2aWV3LnNvbWVQcm9wKFwiY3JlYXRlU2VsZWN0aW9uQmV0d2VlblwiLCBmID0+IGYodmlldywgJGFuY2hvciwgJGhlYWQpKVxuICAgICAgICB8fCBUZXh0U2VsZWN0aW9uLmJldHdlZW4oJGFuY2hvciwgJGhlYWQsIGJpYXMpO1xufVxuZnVuY3Rpb24gaGFzRm9jdXNBbmRTZWxlY3Rpb24odmlldykge1xuICAgIGlmICh2aWV3LmVkaXRhYmxlICYmICF2aWV3Lmhhc0ZvY3VzKCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaGFzU2VsZWN0aW9uKHZpZXcpO1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGlmICghc2VsLmFuY2hvck5vZGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBGaXJlZm94IHdpbGwgcmFpc2UgJ3Blcm1pc3Npb24gZGVuaWVkJyBlcnJvcnMgd2hlbiBhY2Nlc3NpbmdcbiAgICAgICAgLy8gcHJvcGVydGllcyBvZiBgc2VsLmFuY2hvck5vZGVgIHdoZW4gaXQncyBpbiBhIGdlbmVyYXRlZCBDU1NcbiAgICAgICAgLy8gZWxlbWVudC5cbiAgICAgICAgcmV0dXJuIHZpZXcuZG9tLmNvbnRhaW5zKHNlbC5hbmNob3JOb2RlLm5vZGVUeXBlID09IDMgPyBzZWwuYW5jaG9yTm9kZS5wYXJlbnROb2RlIDogc2VsLmFuY2hvck5vZGUpICYmXG4gICAgICAgICAgICAodmlldy5lZGl0YWJsZSB8fCB2aWV3LmRvbS5jb250YWlucyhzZWwuZm9jdXNOb2RlLm5vZGVUeXBlID09IDMgPyBzZWwuZm9jdXNOb2RlLnBhcmVudE5vZGUgOiBzZWwuZm9jdXNOb2RlKSk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhbmNob3JJblJpZ2h0UGxhY2Uodmlldykge1xuICAgIGxldCBhbmNob3JET00gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IsIDApO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgcmV0dXJuIGlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIG1vdmVTZWxlY3Rpb25CbG9jayhzdGF0ZSwgZGlyKSB7XG4gICAgbGV0IHsgJGFuY2hvciwgJGhlYWQgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgJHNpZGUgPSBkaXIgPiAwID8gJGFuY2hvci5tYXgoJGhlYWQpIDogJGFuY2hvci5taW4oJGhlYWQpO1xuICAgIGxldCAkc3RhcnQgPSAhJHNpZGUucGFyZW50LmlubGluZUNvbnRlbnQgPyAkc2lkZSA6ICRzaWRlLmRlcHRoID8gc3RhdGUuZG9jLnJlc29sdmUoZGlyID4gMCA/ICRzaWRlLmFmdGVyKCkgOiAkc2lkZS5iZWZvcmUoKSkgOiBudWxsO1xuICAgIHJldHVybiAkc3RhcnQgJiYgU2VsZWN0aW9uLmZpbmRGcm9tKCRzdGFydCwgZGlyKTtcbn1cbmZ1bmN0aW9uIGFwcGx5KHZpZXcsIHNlbCkge1xuICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCBkaXIsIG1vZHMpIHtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKG1vZHMuaW5kZXhPZihcInNcIikgPiAtMSkge1xuICAgICAgICAgICAgbGV0IHsgJGhlYWQgfSA9IHNlbCwgbm9kZSA9ICRoZWFkLnRleHRPZmZzZXQgPyBudWxsIDogZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXI7XG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5pc1RleHQgfHwgIW5vZGUuaXNMZWFmKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCAkbmV3SGVhZCA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoJGhlYWQucG9zICsgbm9kZS5ub2RlU2l6ZSAqIChkaXIgPCAwID8gLTEgOiAxKSk7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24oc2VsLiRhbmNob3IsICRuZXdIZWFkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXNlbC5lbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyID4gMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiKSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIChuZXh0IGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEobWFjICYmIG1vZHMuaW5kZXhPZihcIm1cIikgPiAtMSkpIHtcbiAgICAgICAgICAgIGxldCAkaGVhZCA9IHNlbC4kaGVhZCwgbm9kZSA9ICRoZWFkLnRleHRPZmZzZXQgPyBudWxsIDogZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXIsIGRlc2M7XG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5pc1RleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5vZGVQb3MgPSBkaXIgPCAwID8gJGhlYWQucG9zIC0gbm9kZS5ub2RlU2l6ZSA6ICRoZWFkLnBvcztcbiAgICAgICAgICAgIGlmICghKG5vZGUuaXNBdG9tIHx8IChkZXNjID0gdmlldy5kb2NWaWV3LmRlc2NBdChub2RlUG9zKSkgJiYgIWRlc2MuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBOb2RlU2VsZWN0aW9uKGRpciA8IDAgPyB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKCRoZWFkLnBvcyAtIG5vZGUubm9kZVNpemUpIDogJGhlYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdlYmtpdCkge1xuICAgICAgICAgICAgICAgIC8vIENocm9tZSBhbmQgU2FmYXJpIHdpbGwgaW50cm9kdWNlIGV4dHJhIHBvaW50bGVzcyBjdXJzb3JcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbnMgYXJvdW5kIGlubGluZSB1bmVkaXRhYmxlIG5vZGVzLCBzbyB3ZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgLy8gdGFrZSBvdmVyIGFuZCBtb3ZlIHRoZSBjdXJzb3IgcGFzdCB0aGVtICgjOTM3KVxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgVGV4dFNlbGVjdGlvbih2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGRpciA8IDAgPyBub2RlUG9zIDogbm9kZVBvcyArIG5vZGUubm9kZVNpemUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzZWwubm9kZS5pc0lubGluZSkge1xuICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24oZGlyID4gMCA/IHNlbC4kdG8gOiBzZWwuJGZyb20pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9kZUxlbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc0lnbm9yYWJsZShkb20sIGRpcikge1xuICAgIGxldCBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gICAgcmV0dXJuIGRlc2MgJiYgZGVzYy5zaXplID09IDAgJiYgKGRpciA8IDAgfHwgZG9tLm5leHRTaWJsaW5nIHx8IGRvbS5ub2RlTmFtZSAhPSBcIkJSXCIpO1xufVxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlcyh2aWV3LCBkaXIpIHtcbiAgICByZXR1cm4gZGlyIDwgMCA/IHNraXBJZ25vcmVkTm9kZXNCZWZvcmUodmlldykgOiBza2lwSWdub3JlZE5vZGVzQWZ0ZXIodmlldyk7XG59XG4vLyBNYWtlIHN1cmUgdGhlIGN1cnNvciBpc24ndCBkaXJlY3RseSBhZnRlciBvbmUgb3IgbW9yZSBpZ25vcmVkXG4vLyBub2Rlcywgd2hpY2ggd2lsbCBjb25mdXNlIHRoZSBicm93c2VyJ3MgY3Vyc29yIG1vdGlvbiBsb2dpYy5cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXNCZWZvcmUodmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IG1vdmVOb2RlLCBtb3ZlT2Zmc2V0LCBmb3JjZSA9IGZhbHNlO1xuICAgIC8vIEdlY2tvIHdpbGwgZG8gb2RkIHRoaW5ncyB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgZGlyZWN0bHkgaW4gZnJvbnRcbiAgICAvLyBvZiBhIG5vbi1lZGl0YWJsZSBub2RlLCBzbyBpbiB0aGF0IGNhc2UsIG1vdmUgaXQgaW50byB0aGUgbmV4dFxuICAgIC8vIG5vZGUgaWYgcG9zc2libGUuIElzc3VlIHByb3NlbWlycm9yL3Byb3NlbWlycm9yIzgzMi5cbiAgICBpZiAoZ2Vja28gJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA8IG5vZGVMZW4obm9kZSkgJiYgaXNJZ25vcmFibGUobm9kZS5jaGlsZE5vZGVzW29mZnNldF0sIC0xKSlcbiAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGlzSWdub3JhYmxlKGJlZm9yZSwgLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IC0tb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCbG9ja05vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIHdoaWxlIChwcmV2ICYmIGlzSWdub3JhYmxlKHByZXYsIC0xKSkge1xuICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSBkb21JbmRleChwcmV2KTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gcHJldi5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHByZXY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZUxlbihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm9yY2UpXG4gICAgICAgIHNldFNlbEZvY3VzKHZpZXcsIG5vZGUsIG9mZnNldCk7XG4gICAgZWxzZSBpZiAobW92ZU5vZGUpXG4gICAgICAgIHNldFNlbEZvY3VzKHZpZXcsIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0KTtcbn1cbi8vIE1ha2Ugc3VyZSB0aGUgY3Vyc29yIGlzbid0IGRpcmVjdGx5IGJlZm9yZSBvbmUgb3IgbW9yZSBpZ25vcmVkXG4vLyBub2Rlcy5cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXNBZnRlcih2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbGVuID0gbm9kZUxlbihub2RlKTtcbiAgICBsZXQgbW92ZU5vZGUsIG1vdmVPZmZzZXQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBpZiAoaXNJZ25vcmFibGUoYWZ0ZXIsIDEpKSB7XG4gICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSArK29mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Jsb2NrTm9kZShub2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCAmJiBpc0lnbm9yYWJsZShuZXh0LCAxKSkge1xuICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbmV4dC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSBkb21JbmRleChuZXh0KSArIDE7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBsZW4gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBsZW4gPSBub2RlTGVuKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtb3ZlTm9kZSlcbiAgICAgICAgc2V0U2VsRm9jdXModmlldywgbW92ZU5vZGUsIG1vdmVPZmZzZXQpO1xufVxuZnVuY3Rpb24gaXNCbG9ja05vZGUoZG9tKSB7XG4gICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICByZXR1cm4gZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2s7XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUFmdGVyKG5vZGUsIG9mZnNldCkge1xuICAgIHdoaWxlIChub2RlICYmIG9mZnNldCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmICFoYXNCbG9ja0Rlc2Mobm9kZSkpIHtcbiAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSkgKyAxO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMSAmJiBuZXh0LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dE5vZGVCZWZvcmUobm9kZSwgb2Zmc2V0KSB7XG4gICAgd2hpbGUgKG5vZGUgJiYgIW9mZnNldCAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG5leHQgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMSAmJiBuZXh0LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIG9mZnNldCA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0U2VsRm9jdXModmlldywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMykge1xuICAgICAgICBsZXQgYmVmb3JlLCBhZnRlcjtcbiAgICAgICAgaWYgKGFmdGVyID0gdGV4dE5vZGVBZnRlcihub2RlLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBub2RlID0gYWZ0ZXI7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJlZm9yZSA9IHRleHROb2RlQmVmb3JlKG5vZGUsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgICAgICBvZmZzZXQgPSBiZWZvcmUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uQ29sbGFwc2VkKHNlbCkpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsLmV4dGVuZCkge1xuICAgICAgICBzZWwuZXh0ZW5kKG5vZGUsIG9mZnNldCk7XG4gICAgfVxuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXc7XG4gICAgLy8gSWYgbm8gc3RhdGUgdXBkYXRlIGVuZHMgdXAgaGFwcGVuaW5nLCByZXNldCB0aGUgc2VsZWN0aW9uLlxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodmlldy5zdGF0ZSA9PSBzdGF0ZSlcbiAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGZpbmREaXJlY3Rpb24odmlldywgcG9zKSB7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCEoY2hyb21lIHx8IHdpbmRvd3MpICYmICRwb3MucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgaWYgKHBvcyA+ICRwb3Muc3RhcnQoKSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHZpZXcuY29vcmRzQXRQb3MocG9zIC0gMSk7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGJlZm9yZS50b3AgKyBiZWZvcmUuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICBpZiAobWlkID4gY29vcmRzLnRvcCAmJiBtaWQgPCBjb29yZHMuYm90dG9tICYmIE1hdGguYWJzKGJlZm9yZS5sZWZ0IC0gY29vcmRzLmxlZnQpID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlLmxlZnQgPCBjb29yZHMubGVmdCA/IFwibHRyXCIgOiBcInJ0bFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPCAkcG9zLmVuZCgpKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyArIDEpO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChhZnRlci50b3AgKyBhZnRlci5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgIGlmIChtaWQgPiBjb29yZHMudG9wICYmIG1pZCA8IGNvb3Jkcy5ib3R0b20gJiYgTWF0aC5hYnMoYWZ0ZXIubGVmdCAtIGNvb3Jkcy5sZWZ0KSA+IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyLmxlZnQgPiBjb29yZHMubGVmdCA/IFwibHRyXCIgOiBcInJ0bFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUodmlldy5kb20pLmRpcmVjdGlvbjtcbiAgICByZXR1cm4gY29tcHV0ZWQgPT0gXCJydGxcIiA/IFwicnRsXCIgOiBcImx0clwiO1xufVxuLy8gQ2hlY2sgd2hldGhlciB2ZXJ0aWNhbCBzZWxlY3Rpb24gbW90aW9uIHdvdWxkIGludm9sdmUgbm9kZVxuLy8gc2VsZWN0aW9ucy4gSWYgc28sIGFwcGx5IGl0IChpZiBub3QsIHRoZSByZXN1bHQgaXMgbGVmdCB0byB0aGVcbi8vIGJyb3dzZXIpXG5mdW5jdGlvbiBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIGRpciwgbW9kcykge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiAhc2VsLmVtcHR5IHx8IG1vZHMuaW5kZXhPZihcInNcIikgPiAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChtYWMgJiYgbW9kcy5pbmRleE9mKFwibVwiKSA+IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgJGZyb20sICR0byB9ID0gc2VsO1xuICAgIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdmlldy5lbmRPZlRleHRibG9jayhkaXIgPCAwID8gXCJ1cFwiIDogXCJkb3duXCIpKSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgIGlmIChuZXh0ICYmIChuZXh0IGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV4dCk7XG4gICAgfVxuICAgIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSBkaXIgPCAwID8gJGZyb20gOiAkdG87XG4gICAgICAgIGxldCBiZXlvbmQgPSBzZWwgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24gPyBTZWxlY3Rpb24ubmVhcihzaWRlLCBkaXIpIDogU2VsZWN0aW9uLmZpbmRGcm9tKHNpZGUsIGRpcik7XG4gICAgICAgIHJldHVybiBiZXlvbmQgPyBhcHBseSh2aWV3LCBiZXlvbmQpIDogZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIGRpcikge1xuICAgIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yLCBlbXB0eSB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyID4gMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IG5leHROb2RlID0gISRoZWFkLnRleHRPZmZzZXQgJiYgKGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyKTtcbiAgICBpZiAobmV4dE5vZGUgJiYgIW5leHROb2RlLmlzVGV4dCkge1xuICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgICAgICBpZiAoZGlyIDwgMClcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgkaGVhZC5wb3MgLSBuZXh0Tm9kZS5ub2RlU2l6ZSwgJGhlYWQucG9zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIuZGVsZXRlKCRoZWFkLnBvcywgJGhlYWQucG9zICsgbmV4dE5vZGUubm9kZVNpemUpO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN3aXRjaEVkaXRhYmxlKHZpZXcsIG5vZGUsIHN0YXRlKSB7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgbm9kZS5jb250ZW50RWRpdGFibGUgPSBzdGF0ZTtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG59XG4vLyBJc3N1ZSAjODY3IC8gIzEwOTAgLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05MDM4MjFcbi8vIEluIHdoaWNoIFNhZmFyaSAoYW5kIGF0IHNvbWUgcG9pbnQgaW4gdGhlIHBhc3QsIENocm9tZSkgZG9lcyByZWFsbHlcbi8vIHdyb25nIHRoaW5ncyB3aGVuIHRoZSBkb3duIGFycm93IGlzIHByZXNzZWQgd2hlbiB0aGUgY3Vyc29yIGlzXG4vLyBkaXJlY3RseSBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2sgYW5kIGhhcyBhbiB1bmVkaXRhYmxlIG5vZGVcbi8vIGFmdGVyIGl0XG5mdW5jdGlvbiBzYWZhcmlEb3duQXJyb3dCdWcodmlldykge1xuICAgIGlmICghc2FmYXJpIHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRoZWFkLnBhcmVudE9mZnNldCA+IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgaWYgKGZvY3VzTm9kZSAmJiBmb2N1c05vZGUubm9kZVR5cGUgPT0gMSAmJiBmb2N1c09mZnNldCA9PSAwICYmXG4gICAgICAgIGZvY3VzTm9kZS5maXJzdENoaWxkICYmIGZvY3VzTm9kZS5maXJzdENoaWxkLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZm9jdXNOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHN3aXRjaEVkaXRhYmxlKHZpZXcsIGNoaWxkLCBcInRydWVcIik7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc3dpdGNoRWRpdGFibGUodmlldywgY2hpbGQsIFwiZmFsc2VcIiksIDIwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQSBiYWNrZHJvcCBrZXkgbWFwcGluZyB1c2VkIHRvIG1ha2Ugc3VyZSB3ZSBhbHdheXMgc3VwcHJlc3Mga2V5c1xuLy8gdGhhdCBoYXZlIGEgZGFuZ2Vyb3VzIGRlZmF1bHQgZWZmZWN0LCBldmVuIGlmIHRoZSBjb21tYW5kcyB0aGV5IGFyZVxuLy8gYm91bmQgdG8gcmV0dXJuIGZhbHNlLCBhbmQgdG8gbWFrZSBzdXJlIHRoYXQgY3Vyc29yLW1vdGlvbiBrZXlzXG4vLyBmaW5kIGEgY3Vyc29yIChhcyBvcHBvc2VkIHRvIGEgbm9kZSBzZWxlY3Rpb24pIHdoZW4gcHJlc3NlZC4gRm9yXG4vLyBjdXJzb3ItbW90aW9uIGtleXMsIHRoZSBjb2RlIGluIHRoZSBoYW5kbGVycyBhbHNvIHRha2VzIGNhcmUgb2Zcbi8vIGJsb2NrIHNlbGVjdGlvbnMuXG5mdW5jdGlvbiBnZXRNb2RzKGV2ZW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcImNcIjtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwibVwiO1xuICAgIGlmIChldmVudC5hbHRLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcImFcIjtcbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcInNcIjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FwdHVyZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgY29kZSA9IGV2ZW50LmtleUNvZGUsIG1vZHMgPSBnZXRNb2RzKGV2ZW50KTtcbiAgICBpZiAoY29kZSA9PSA4IHx8IChtYWMgJiYgY29kZSA9PSA3MiAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBCYWNrc3BhY2UsIEN0cmwtaCBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIC0xKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIC0xKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGNvZGUgPT0gNDYgJiYgIWV2ZW50LnNoaWZ0S2V5KSB8fCAobWFjICYmIGNvZGUgPT0gNjggJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gRGVsZXRlLCBDdHJsLWQgb24gTWFjXG4gICAgICAgIHJldHVybiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCAxKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIDEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDEzIHx8IGNvZGUgPT0gMjcpIHsgLy8gRW50ZXIsIEVzY1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAzNyB8fCAobWFjICYmIGNvZGUgPT0gNjYgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gTGVmdCBhcnJvdywgQ3RybC1iIG9uIE1hY1xuICAgICAgICBsZXQgZGlyID0gY29kZSA9PSAzNyA/IChmaW5kRGlyZWN0aW9uKHZpZXcsIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20pID09IFwibHRyXCIgPyAtMSA6IDEpIDogLTE7XG4gICAgICAgIHJldHVybiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMzkgfHwgKG1hYyAmJiBjb2RlID09IDcwICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIFJpZ2h0IGFycm93LCBDdHJsLWYgb24gTWFjXG4gICAgICAgIGxldCBkaXIgPSBjb2RlID09IDM5ID8gKGZpbmREaXJlY3Rpb24odmlldywgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSkgPT0gXCJsdHJcIiA/IDEgOiAtMSkgOiAxO1xuICAgICAgICByZXR1cm4gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCBkaXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDM4IHx8IChtYWMgJiYgY29kZSA9PSA4MCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBVcCBhcnJvdywgQ3RybC1wIG9uIE1hY1xuICAgICAgICByZXR1cm4gc2VsZWN0VmVydGljYWxseSh2aWV3LCAtMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAtMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gNDAgfHwgKG1hYyAmJiBjb2RlID09IDc4ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIERvd24gYXJyb3csIEN0cmwtbiBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB8fCBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIDEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1vZHMgPT0gKG1hYyA/IFwibVwiIDogXCJjXCIpICYmXG4gICAgICAgIChjb2RlID09IDY2IHx8IGNvZGUgPT0gNzMgfHwgY29kZSA9PSA4OSB8fCBjb2RlID09IDkwKSkgeyAvLyBNb2QtW2JpeXpdXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSkge1xuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1Db3BpZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldyk7IH0pO1xuICAgIGxldCBjb250ZXh0ID0gW10sIHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSBzbGljZTtcbiAgICB3aGlsZSAob3BlblN0YXJ0ID4gMSAmJiBvcGVuRW5kID4gMSAmJiBjb250ZW50LmNoaWxkQ291bnQgPT0gMSAmJiBjb250ZW50LmZpcnN0Q2hpbGQuY2hpbGRDb3VudCA9PSAxKSB7XG4gICAgICAgIG9wZW5TdGFydC0tO1xuICAgICAgICBvcGVuRW5kLS07XG4gICAgICAgIGxldCBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBjb250ZXh0LnB1c2gobm9kZS50eXBlLm5hbWUsIG5vZGUuYXR0cnMgIT0gbm9kZS50eXBlLmRlZmF1bHRBdHRycyA/IG5vZGUuYXR0cnMgOiBudWxsKTtcbiAgICAgICAgY29udGVudCA9IG5vZGUuY29udGVudDtcbiAgICB9XG4gICAgbGV0IHNlcmlhbGl6ZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkU2VyaWFsaXplclwiKSB8fCBET01TZXJpYWxpemVyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgIGxldCBkb2MgPSBkZXRhY2hlZERvYygpLCB3cmFwID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChzZXJpYWxpemVyLnNlcmlhbGl6ZUZyYWdtZW50KGNvbnRlbnQsIHsgZG9jdW1lbnQ6IGRvYyB9KSk7XG4gICAgbGV0IGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQsIG5lZWRzV3JhcCwgd3JhcHBlcnMgPSAwO1xuICAgIHdoaWxlIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJiAobmVlZHNXcmFwID0gd3JhcE1hcFtmaXJzdENoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gbmVlZHNXcmFwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgd3JhcHBlciA9IGRvYy5jcmVhdGVFbGVtZW50KG5lZWRzV3JhcFtpXSk7XG4gICAgICAgICAgICB3aGlsZSAod3JhcC5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQod3JhcC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgICAgICB3cmFwcGVycysrO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQ7XG4gICAgfVxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIsIGAke29wZW5TdGFydH0gJHtvcGVuRW5kfSR7d3JhcHBlcnMgPyBgIC0ke3dyYXBwZXJzfWAgOiBcIlwifSAke0pTT04uc3RyaW5naWZ5KGNvbnRleHQpfWApO1xuICAgIGxldCB0ZXh0ID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRTZXJpYWxpemVyXCIsIGYgPT4gZihzbGljZSwgdmlldykpIHx8XG4gICAgICAgIHNsaWNlLmNvbnRlbnQudGV4dEJldHdlZW4oMCwgc2xpY2UuY29udGVudC5zaXplLCBcIlxcblxcblwiKTtcbiAgICByZXR1cm4geyBkb206IHdyYXAsIHRleHQgfTtcbn1cbi8vIFJlYWQgYSBzbGljZSBvZiBjb250ZW50IGZyb20gdGhlIGNsaXBib2FyZCAob3IgZHJvcCBkYXRhKS5cbmZ1bmN0aW9uIHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCBwbGFpblRleHQsICRjb250ZXh0KSB7XG4gICAgbGV0IGluQ29kZSA9ICRjb250ZXh0LnBhcmVudC50eXBlLnNwZWMuY29kZTtcbiAgICBsZXQgZG9tLCBzbGljZTtcbiAgICBpZiAoIWh0bWwgJiYgIXRleHQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBhc1RleHQgPSB0ZXh0ICYmIChwbGFpblRleHQgfHwgaW5Db2RlIHx8ICFodG1sKTtcbiAgICBpZiAoYXNUZXh0KSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRUZXh0XCIsIGYgPT4geyB0ZXh0ID0gZih0ZXh0LCBpbkNvZGUgfHwgcGxhaW5UZXh0LCB2aWV3KTsgfSk7XG4gICAgICAgIGlmIChpbkNvZGUpXG4gICAgICAgICAgICByZXR1cm4gdGV4dCA/IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHZpZXcuc3RhdGUuc2NoZW1hLnRleHQodGV4dC5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpKSksIDAsIDApIDogU2xpY2UuZW1wdHk7XG4gICAgICAgIGxldCBwYXJzZWQgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkVGV4dFBhcnNlclwiLCBmID0+IGYodGV4dCwgJGNvbnRleHQsIHBsYWluVGV4dCwgdmlldykpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBzbGljZSA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9ICRjb250ZXh0Lm1hcmtzKCk7XG4gICAgICAgICAgICBsZXQgeyBzY2hlbWEgfSA9IHZpZXcuc3RhdGUsIHNlcmlhbGl6ZXIgPSBET01TZXJpYWxpemVyLmZyb21TY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0ZXh0LnNwbGl0KC8oPzpcXHJcXG4/fFxcbikrLykuZm9yRWFjaChibG9jayA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHAgPSBkb20uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIikpO1xuICAgICAgICAgICAgICAgIGlmIChibG9jaylcbiAgICAgICAgICAgICAgICAgICAgcC5hcHBlbmRDaGlsZChzZXJpYWxpemVyLnNlcmlhbGl6ZU5vZGUoc2NoZW1hLnRleHQoYmxvY2ssIG1hcmtzKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRIVE1MXCIsIGYgPT4geyBodG1sID0gZihodG1sLCB2aWV3KTsgfSk7XG4gICAgICAgIGRvbSA9IHJlYWRIVE1MKGh0bWwpO1xuICAgICAgICBpZiAod2Via2l0KVxuICAgICAgICAgICAgcmVzdG9yZVJlcGxhY2VkU3BhY2VzKGRvbSk7XG4gICAgfVxuICAgIGxldCBjb250ZXh0Tm9kZSA9IGRvbSAmJiBkb20ucXVlcnlTZWxlY3RvcihcIltkYXRhLXBtLXNsaWNlXVwiKTtcbiAgICBsZXQgc2xpY2VEYXRhID0gY29udGV4dE5vZGUgJiYgL14oXFxkKykgKFxcZCspKD86IC0oXFxkKykpPyAoLiopLy5leGVjKGNvbnRleHROb2RlLmdldEF0dHJpYnV0ZShcImRhdGEtcG0tc2xpY2VcIikgfHwgXCJcIik7XG4gICAgaWYgKHNsaWNlRGF0YSAmJiBzbGljZURhdGFbM10pXG4gICAgICAgIGZvciAobGV0IGkgPSArc2xpY2VEYXRhWzNdOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBkb20uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZG9tID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICBpZiAoIXNsaWNlKSB7XG4gICAgICAgIGxldCBwYXJzZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkUGFyc2VyXCIpIHx8IHZpZXcuc29tZVByb3AoXCJkb21QYXJzZXJcIikgfHwgRE9NUGFyc2VyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgICAgICBzbGljZSA9IHBhcnNlci5wYXJzZVNsaWNlKGRvbSwge1xuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAhIShhc1RleHQgfHwgc2xpY2VEYXRhKSxcbiAgICAgICAgICAgIGNvbnRleHQ6ICRjb250ZXh0LFxuICAgICAgICAgICAgcnVsZUZyb21Ob2RlKGRvbSkge1xuICAgICAgICAgICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmICFkb20ubmV4dFNpYmxpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgZG9tLnBhcmVudE5vZGUgJiYgIWlubGluZVBhcmVudHMudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNsaWNlRGF0YSkge1xuICAgICAgICBzbGljZSA9IGFkZENvbnRleHQoY2xvc2VTbGljZShzbGljZSwgK3NsaWNlRGF0YVsxXSwgK3NsaWNlRGF0YVsyXSksIHNsaWNlRGF0YVs0XSk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBIVE1MIHdhc24ndCBjcmVhdGVkIGJ5IFByb3NlTWlycm9yLiBNYWtlIHN1cmUgdG9wLWxldmVsIHNpYmxpbmdzIGFyZSBjb2hlcmVudFxuICAgICAgICBzbGljZSA9IFNsaWNlLm1heE9wZW4obm9ybWFsaXplU2libGluZ3Moc2xpY2UuY29udGVudCwgJGNvbnRleHQpLCB0cnVlKTtcbiAgICAgICAgaWYgKHNsaWNlLm9wZW5TdGFydCB8fCBzbGljZS5vcGVuRW5kKSB7XG4gICAgICAgICAgICBsZXQgb3BlblN0YXJ0ID0gMCwgb3BlbkVuZCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBub2RlID0gc2xpY2UuY29udGVudC5maXJzdENoaWxkOyBvcGVuU3RhcnQgPCBzbGljZS5vcGVuU3RhcnQgJiYgIW5vZGUudHlwZS5zcGVjLmlzb2xhdGluZzsgb3BlblN0YXJ0KyssIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQpIHsgfVxuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNsaWNlLmNvbnRlbnQubGFzdENoaWxkOyBvcGVuRW5kIDwgc2xpY2Uub3BlbkVuZCAmJiAhbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nOyBvcGVuRW5kKyssIG5vZGUgPSBub2RlLmxhc3RDaGlsZCkgeyB9XG4gICAgICAgICAgICBzbGljZSA9IGNsb3NlU2xpY2Uoc2xpY2UsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3KTsgfSk7XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuY29uc3QgaW5saW5lUGFyZW50cyA9IC9eKGF8YWJicnxhY3JvbnltfGJ8Y2l0ZXxjb2RlfGRlbHxlbXxpfGluc3xrYmR8bGFiZWx8b3V0cHV0fHF8cnVieXxzfHNhbXB8c3BhbnxzdHJvbmd8c3VifHN1cHx0aW1lfHV8dHR8dmFyKSQvaTtcbi8vIFRha2VzIGEgc2xpY2UgcGFyc2VkIHdpdGggcGFyc2VTbGljZSwgd2hpY2ggbWVhbnMgdGhlcmUgaGFzbid0IGJlZW5cbi8vIGFueSBjb250ZW50LWV4cHJlc3Npb24gY2hlY2tpbmcgZG9uZSBvbiB0aGUgdG9wIG5vZGVzLCB0cmllcyB0b1xuLy8gZmluZCBhIHBhcmVudCBub2RlIGluIHRoZSBjdXJyZW50IGNvbnRleHQgdGhhdCBtaWdodCBmaXQgdGhlIG5vZGVzLFxuLy8gYW5kIGlmIHN1Y2Nlc3NmdWwsIHJlYnVpbGRzIHRoZSBzbGljZSBzbyB0aGF0IGl0IGZpdHMgaW50byB0aGF0IHBhcmVudC5cbi8vXG4vLyBUaGlzIGFkZHJlc3NlcyB0aGUgcHJvYmxlbSB0aGF0IFRyYW5zZm9ybS5yZXBsYWNlIGV4cGVjdHMgYVxuLy8gY29oZXJlbnQgc2xpY2UsIGFuZCB3aWxsIGZhaWwgdG8gcGxhY2UgYSBzZXQgb2Ygc2libGluZ3MgdGhhdCBkb24ndFxuLy8gZml0IGFueXdoZXJlIGluIHRoZSBzY2hlbWEuXG5mdW5jdGlvbiBub3JtYWxpemVTaWJsaW5ncyhmcmFnbWVudCwgJGNvbnRleHQpIHtcbiAgICBpZiAoZnJhZ21lbnQuY2hpbGRDb3VudCA8IDIpXG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICBmb3IgKGxldCBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAkY29udGV4dC5ub2RlKGQpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJlbnQuY29udGVudE1hdGNoQXQoJGNvbnRleHQuaW5kZXgoZCkpO1xuICAgICAgICBsZXQgbGFzdFdyYXAsIHJlc3VsdCA9IFtdO1xuICAgICAgICBmcmFnbWVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHdyYXAgPSBtYXRjaC5maW5kV3JhcHBpbmcobm9kZS50eXBlKSwgaW5MYXN0O1xuICAgICAgICAgICAgaWYgKCF3cmFwKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGluTGFzdCA9IHJlc3VsdC5sZW5ndGggJiYgbGFzdFdyYXAubGVuZ3RoICYmIGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gaW5MYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBjbG9zZVJpZ2h0KHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIGxhc3RXcmFwLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXBwZWQgPSB3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god3JhcHBlZCk7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaC5tYXRjaFR5cGUod3JhcHBlZC50eXBlKTtcbiAgICAgICAgICAgICAgICBsYXN0V3JhcCA9IHdyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20ocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gd2l0aFdyYXBwZXJzKG5vZGUsIHdyYXAsIGZyb20gPSAwKSB7XG4gICAgZm9yIChsZXQgaSA9IHdyYXAubGVuZ3RoIC0gMTsgaSA+PSBmcm9tOyBpLS0pXG4gICAgICAgIG5vZGUgPSB3cmFwW2ldLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbi8vIFVzZWQgdG8gZ3JvdXAgYWRqYWNlbnQgbm9kZXMgd3JhcHBlZCBpbiBzaW1pbGFyIHBhcmVudHMgYnlcbi8vIG5vcm1hbGl6ZVNpYmxpbmdzIGludG8gdGhlIHNhbWUgcGFyZW50IG5vZGVcbmZ1bmN0aW9uIGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgc2libGluZywgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPCB3cmFwLmxlbmd0aCAmJiBkZXB0aCA8IGxhc3RXcmFwLmxlbmd0aCAmJiB3cmFwW2RlcHRoXSA9PSBsYXN0V3JhcFtkZXB0aF0pIHtcbiAgICAgICAgbGV0IGlubmVyID0gYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCBzaWJsaW5nLmxhc3RDaGlsZCwgZGVwdGggKyAxKTtcbiAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmcuY29weShzaWJsaW5nLmNvbnRlbnQucmVwbGFjZUNoaWxkKHNpYmxpbmcuY2hpbGRDb3VudCAtIDEsIGlubmVyKSk7XG4gICAgICAgIGxldCBtYXRjaCA9IHNpYmxpbmcuY29udGVudE1hdGNoQXQoc2libGluZy5jaGlsZENvdW50KTtcbiAgICAgICAgaWYgKG1hdGNoLm1hdGNoVHlwZShkZXB0aCA9PSB3cmFwLmxlbmd0aCAtIDEgPyBub2RlLnR5cGUgOiB3cmFwW2RlcHRoICsgMV0pKVxuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmcuY29weShzaWJsaW5nLmNvbnRlbnQuYXBwZW5kKEZyYWdtZW50LmZyb20od2l0aFdyYXBwZXJzKG5vZGUsIHdyYXAsIGRlcHRoICsgMSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvc2VSaWdodChub2RlLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICBsZXQgZnJhZ21lbnQgPSBub2RlLmNvbnRlbnQucmVwbGFjZUNoaWxkKG5vZGUuY2hpbGRDb3VudCAtIDEsIGNsb3NlUmlnaHQobm9kZS5sYXN0Q2hpbGQsIGRlcHRoIC0gMSkpO1xuICAgIGxldCBmaWxsID0gbm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgIHJldHVybiBub2RlLmNvcHkoZnJhZ21lbnQuYXBwZW5kKGZpbGwpKTtcbn1cbmZ1bmN0aW9uIGNsb3NlUmFuZ2UoZnJhZ21lbnQsIHNpZGUsIGZyb20sIHRvLCBkZXB0aCwgb3BlbkVuZCkge1xuICAgIGxldCBub2RlID0gc2lkZSA8IDAgPyBmcmFnbWVudC5maXJzdENoaWxkIDogZnJhZ21lbnQubGFzdENoaWxkLCBpbm5lciA9IG5vZGUuY29udGVudDtcbiAgICBpZiAoZnJhZ21lbnQuY2hpbGRDb3VudCA+IDEpXG4gICAgICAgIG9wZW5FbmQgPSAwO1xuICAgIGlmIChkZXB0aCA8IHRvIC0gMSlcbiAgICAgICAgaW5uZXIgPSBjbG9zZVJhbmdlKGlubmVyLCBzaWRlLCBmcm9tLCB0bywgZGVwdGggKyAxLCBvcGVuRW5kKTtcbiAgICBpZiAoZGVwdGggPj0gZnJvbSlcbiAgICAgICAgaW5uZXIgPSBzaWRlIDwgMCA/IG5vZGUuY29udGVudE1hdGNoQXQoMCkuZmlsbEJlZm9yZShpbm5lciwgb3BlbkVuZCA8PSBkZXB0aCkuYXBwZW5kKGlubmVyKVxuICAgICAgICAgICAgOiBpbm5lci5hcHBlbmQobm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKHNpZGUgPCAwID8gMCA6IGZyYWdtZW50LmNoaWxkQ291bnQgLSAxLCBub2RlLmNvcHkoaW5uZXIpKTtcbn1cbmZ1bmN0aW9uIGNsb3NlU2xpY2Uoc2xpY2UsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGlmIChvcGVuU3RhcnQgPCBzbGljZS5vcGVuU3RhcnQpXG4gICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKGNsb3NlUmFuZ2Uoc2xpY2UuY29udGVudCwgLTEsIG9wZW5TdGFydCwgc2xpY2Uub3BlblN0YXJ0LCAwLCBzbGljZS5vcGVuRW5kKSwgb3BlblN0YXJ0LCBzbGljZS5vcGVuRW5kKTtcbiAgICBpZiAob3BlbkVuZCA8IHNsaWNlLm9wZW5FbmQpXG4gICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKGNsb3NlUmFuZ2Uoc2xpY2UuY29udGVudCwgMSwgb3BlbkVuZCwgc2xpY2Uub3BlbkVuZCwgMCwgMCksIHNsaWNlLm9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuLy8gVHJpY2sgZnJvbSBqUXVlcnkgLS0gc29tZSBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgaW4gb3RoZXJcbi8vIGVsZW1lbnRzIGZvciBpbm5lckhUTUwgdG8gd29yay4gSS5lLiBpZiB5b3UgZG8gYGRpdi5pbm5lckhUTUwgPVxuLy8gXCI8dGQ+Li48L3RkPlwiYCB0aGUgdGFibGUgY2VsbHMgYXJlIGlnbm9yZWQuXG5jb25zdCB3cmFwTWFwID0ge1xuICAgIHRoZWFkOiBbXCJ0YWJsZVwiXSxcbiAgICB0Ym9keTogW1widGFibGVcIl0sXG4gICAgdGZvb3Q6IFtcInRhYmxlXCJdLFxuICAgIGNhcHRpb246IFtcInRhYmxlXCJdLFxuICAgIGNvbGdyb3VwOiBbXCJ0YWJsZVwiXSxcbiAgICBjb2w6IFtcInRhYmxlXCIsIFwiY29sZ3JvdXBcIl0sXG4gICAgdHI6IFtcInRhYmxlXCIsIFwidGJvZHlcIl0sXG4gICAgdGQ6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXSxcbiAgICB0aDogW1widGFibGVcIiwgXCJ0Ym9keVwiLCBcInRyXCJdXG59O1xubGV0IF9kZXRhY2hlZERvYyA9IG51bGw7XG5mdW5jdGlvbiBkZXRhY2hlZERvYygpIHtcbiAgICByZXR1cm4gX2RldGFjaGVkRG9jIHx8IChfZGV0YWNoZWREb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJ0aXRsZVwiKSk7XG59XG5mdW5jdGlvbiByZWFkSFRNTChodG1sKSB7XG4gICAgbGV0IG1ldGFzID0gL14oXFxzKjxtZXRhIFtePl0qPikqLy5leGVjKGh0bWwpO1xuICAgIGlmIChtZXRhcylcbiAgICAgICAgaHRtbCA9IGh0bWwuc2xpY2UobWV0YXNbMF0ubGVuZ3RoKTtcbiAgICBsZXQgZWx0ID0gZGV0YWNoZWREb2MoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGxldCBmaXJzdFRhZyA9IC88KFthLXpdW14+XFxzXSspL2kuZXhlYyhodG1sKSwgd3JhcDtcbiAgICBpZiAod3JhcCA9IGZpcnN0VGFnICYmIHdyYXBNYXBbZmlyc3RUYWdbMV0udG9Mb3dlckNhc2UoKV0pXG4gICAgICAgIGh0bWwgPSB3cmFwLm1hcChuID0+IFwiPFwiICsgbiArIFwiPlwiKS5qb2luKFwiXCIpICsgaHRtbCArIHdyYXAubWFwKG4gPT4gXCI8L1wiICsgbiArIFwiPlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICBlbHQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICBpZiAod3JhcClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZWx0ID0gZWx0LnF1ZXJ5U2VsZWN0b3Iod3JhcFtpXSkgfHwgZWx0O1xuICAgIHJldHVybiBlbHQ7XG59XG4vLyBXZWJraXQgYnJvd3NlcnMgZG8gc29tZSBoYXJkLXRvLXByZWRpY3QgcmVwbGFjZW1lbnQgb2YgcmVndWxhclxuLy8gc3BhY2VzIHdpdGggbm9uLWJyZWFraW5nIHNwYWNlcyB3aGVuIHB1dHRpbmcgY29udGVudCBvbiB0aGVcbi8vIGNsaXBib2FyZC4gVGhpcyB0cmllcyB0byBjb252ZXJ0IHN1Y2ggbm9uLWJyZWFraW5nIHNwYWNlcyAod2hpY2hcbi8vIHdpbGwgYmUgd3JhcHBlZCBpbiBhIHBsYWluIHNwYW4gb24gQ2hyb21lLCBhIHNwYW4gd2l0aCBjbGFzc1xuLy8gQXBwbGUtY29udmVydGVkLXNwYWNlIG9uIFNhZmFyaSkgYmFjayB0byByZWd1bGFyIHNwYWNlcy5cbmZ1bmN0aW9uIHJlc3RvcmVSZXBsYWNlZFNwYWNlcyhkb20pIHtcbiAgICBsZXQgbm9kZXMgPSBkb20ucXVlcnlTZWxlY3RvckFsbChjaHJvbWUgPyBcInNwYW46bm90KFtjbGFzc10pOm5vdChbc3R5bGVdKVwiIDogXCJzcGFuLkFwcGxlLWNvbnZlcnRlZC1zcGFjZVwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZS50ZXh0Q29udGVudCA9PSBcIlxcdTAwYTBcIiAmJiBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGRvbS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIFwiKSwgbm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkQ29udGV4dChzbGljZSwgY29udGV4dCkge1xuICAgIGlmICghc2xpY2Uuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgIGxldCBzY2hlbWEgPSBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQudHlwZS5zY2hlbWEsIGFycmF5O1xuICAgIHRyeSB7XG4gICAgICAgIGFycmF5ID0gSlNPTi5wYXJzZShjb250ZXh0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgIH1cbiAgICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHNsaWNlO1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBsZXQgdHlwZSA9IHNjaGVtYS5ub2Rlc1thcnJheVtpXV07XG4gICAgICAgIGlmICghdHlwZSB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhcnJheVtpICsgMV0sIGNvbnRlbnQpKTtcbiAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgIG9wZW5FbmQrKztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xufVxuXG4vLyBBIGNvbGxlY3Rpb24gb2YgRE9NIGV2ZW50cyB0aGF0IG9jY3VyIHdpdGhpbiB0aGUgZWRpdG9yLCBhbmQgY2FsbGJhY2sgZnVuY3Rpb25zXG4vLyB0byBpbnZva2Ugd2hlbiB0aGUgZXZlbnQgZmlyZXMuXG5jb25zdCBoYW5kbGVycyA9IHt9O1xuY29uc3QgZWRpdEhhbmRsZXJzID0ge307XG5jb25zdCBwYXNzaXZlSGFuZGxlcnMgPSB7IHRvdWNoc3RhcnQ6IHRydWUsIHRvdWNobW92ZTogdHJ1ZSB9O1xuY2xhc3MgSW5wdXRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2hpZnRLZXkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZVRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDbGljayA9IHsgdGltZTogMCwgeDogMCwgeTogMCwgdHlwZTogXCJcIiB9O1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICB0aGlzLmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RGb2N1cyA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoID0gMDtcbiAgICAgICAgdGhpcy5sYXN0QW5kcm9pZERlbGV0ZSA9IDA7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPSAtMmU4O1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uSUQgPSAxO1xuICAgICAgICAvLyBTZXQgdG8gYSBjb21wb3NpdGlvbiBJRCB3aGVuIHRoZXJlIGFyZSBwZW5kaW5nIGNoYW5nZXMgYXQgY29tcG9zaXRpb25lbmRcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzID0gMDtcbiAgICAgICAgdGhpcy5kb21DaGFuZ2VDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuaGlkZVNlbGVjdGlvbkd1YXJkID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBpbml0SW5wdXQodmlldykge1xuICAgIGZvciAobGV0IGV2ZW50IGluIGhhbmRsZXJzKSB7XG4gICAgICAgIGxldCBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbZXZlbnRdID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnRCZWxvbmdzVG9WaWV3KHZpZXcsIGV2ZW50KSAmJiAhcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkgJiZcbiAgICAgICAgICAgICAgICAodmlldy5lZGl0YWJsZSB8fCAhKGV2ZW50LnR5cGUgaW4gZWRpdEhhbmRsZXJzKSkpXG4gICAgICAgICAgICAgICAgaGFuZGxlcih2aWV3LCBldmVudCk7XG4gICAgICAgIH0sIHBhc3NpdmVIYW5kbGVyc1tldmVudF0gPyB7IHBhc3NpdmU6IHRydWUgfSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8vIE9uIFNhZmFyaSwgZm9yIHJlYXNvbnMgYmV5b25kIG15IHVuZGVyc3RhbmRpbmcsIGFkZGluZyBhbiBpbnB1dFxuICAgIC8vIGV2ZW50IGhhbmRsZXIgbWFrZXMgYW4gaXNzdWUgd2hlcmUgdGhlIGNvbXBvc2l0aW9uIHZhbmlzaGVzIHdoZW5cbiAgICAvLyB5b3UgcHJlc3MgZW50ZXIgZ28gYXdheS5cbiAgICBpZiAoc2FmYXJpKVxuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4gbnVsbCk7XG4gICAgZW5zdXJlTGlzdGVuZXJzKHZpZXcpO1xufVxuZnVuY3Rpb24gc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIG9yaWdpbikge1xuICAgIHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG9yaWdpbjtcbiAgICB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lJbnB1dCh2aWV3KSB7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgZm9yIChsZXQgdHlwZSBpbiB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnMpXG4gICAgICAgIHZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW3R5cGVdKTtcbiAgICBjbGVhclRpbWVvdXQodmlldy5pbnB1dC5jb21wb3NpbmdUaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQodmlldy5pbnB1dC5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQpO1xufVxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuZXJzKHZpZXcpIHtcbiAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRE9NRXZlbnRzXCIsIGN1cnJlbnRIYW5kbGVycyA9PiB7XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gY3VycmVudEhhbmRsZXJzKVxuICAgICAgICAgICAgaWYgKCF2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0pXG4gICAgICAgICAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0gPSBldmVudCA9PiBydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHZpZXcuc29tZVByb3AoXCJoYW5kbGVET01FdmVudHNcIiwgaGFuZGxlcnMgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlciA9IGhhbmRsZXJzW2V2ZW50LnR5cGVdO1xuICAgICAgICByZXR1cm4gaGFuZGxlciA/IGhhbmRsZXIodmlldywgZXZlbnQpIHx8IGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBmYWxzZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGV2ZW50QmVsb25nc1RvVmlldyh2aWV3LCBldmVudCkge1xuICAgIGlmICghZXZlbnQuYnViYmxlcylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBub2RlID0gZXZlbnQudGFyZ2V0OyBub2RlICE9IHZpZXcuZG9tOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSB8fFxuICAgICAgICAgICAgKG5vZGUucG1WaWV3RGVzYyAmJiBub2RlLnBtVmlld0Rlc2Muc3RvcEV2ZW50KGV2ZW50KSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSAmJiBoYW5kbGVyc1tldmVudC50eXBlXSAmJlxuICAgICAgICAodmlldy5lZGl0YWJsZSB8fCAhKGV2ZW50LnR5cGUgaW4gZWRpdEhhbmRsZXJzKSkpXG4gICAgICAgIGhhbmRsZXJzW2V2ZW50LnR5cGVdKHZpZXcsIGV2ZW50KTtcbn1cbmVkaXRIYW5kbGVycy5rZXlkb3duID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZXZlbnQua2V5Q29kZSA9PSAxNiB8fCBldmVudC5zaGlmdEtleTtcbiAgICBpZiAoaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkpXG4gICAgICAgIHJldHVybjtcbiAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlVGltZSA9IERhdGUubm93KCk7XG4gICAgLy8gU3VwcHJlc3MgZW50ZXIga2V5IGV2ZW50cyBvbiBDaHJvbWUgQW5kcm9pZCwgYmVjYXVzZSB0aG9zZSB0ZW5kXG4gICAgLy8gdG8gYmUgcGFydCBvZiBhIGNvbmZ1c2VkIHNlcXVlbmNlIG9mIGNvbXBvc2l0aW9uIGV2ZW50cyBmaXJlZCxcbiAgICAvLyBhbmQgaGFuZGxpbmcgdGhlbSBlYWdlcmx5IHRlbmRzIHRvIGNvcnJ1cHQgdGhlIGlucHV0LlxuICAgIGlmIChhbmRyb2lkICYmIGNocm9tZSAmJiBldmVudC5rZXlDb2RlID09IDEzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgIT0gMjI5KVxuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAvLyBPbiBpT1MsIGlmIHdlIHByZXZlbnREZWZhdWx0IGVudGVyIGtleSBwcmVzc2VzLCB0aGUgdmlydHVhbFxuICAgIC8vIGtleWJvYXJkIGdldHMgY29uZnVzZWQuIFNvIHRoZSBoYWNrIGhlcmUgaXMgdG8gc2V0IGEgZmxhZyB0aGF0XG4gICAgLy8gbWFrZXMgdGhlIERPTSBjaGFuZ2UgY29kZSByZWNvZ25pemUgdGhhdCB3aGF0IGp1c3QgaGFwcGVucyBzaG91bGRcbiAgICAvLyBiZSByZXBsYWNlZCBieSB3aGF0ZXZlciB0aGUgRW50ZXIga2V5IGhhbmRsZXJzIGRvLlxuICAgIGlmIChpb3MgJiYgZXZlbnQua2V5Q29kZSA9PSAxMyAmJiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5ICYmICFldmVudC5tZXRhS2V5KSB7XG4gICAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IG5vdztcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9PSBub3cpIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKTtcbiAgICAgICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBldmVudCkpIHx8IGNhcHR1cmVLZXlEb3duKHZpZXcsIGV2ZW50KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwia2V5XCIpO1xuICAgIH1cbn07XG5lZGl0SGFuZGxlcnMua2V5dXAgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAxNilcbiAgICAgICAgdmlldy5pbnB1dC5zaGlmdEtleSA9IGZhbHNlO1xufTtcbmVkaXRIYW5kbGVycy5rZXlwcmVzcyA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgaWYgKGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpIHx8ICFldmVudC5jaGFyQ29kZSB8fFxuICAgICAgICBldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgfHwgbWFjICYmIGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleVByZXNzXCIsIGYgPT4gZih2aWV3LCBldmVudCkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHx8ICFzZWwuJGZyb20uc2FtZVBhcmVudChzZWwuJHRvKSkge1xuICAgICAgICBsZXQgdGV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUpO1xuICAgICAgICBpZiAoIS9bXFxyXFxuXS8udGVzdCh0ZXh0KSAmJiAhdmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmID0+IGYodmlldywgc2VsLiRmcm9tLnBvcywgc2VsLiR0by5wb3MsIHRleHQpKSlcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KHRleHQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBldmVudENvb3JkcyhldmVudCkgeyByZXR1cm4geyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfTsgfVxuZnVuY3Rpb24gaXNOZWFyKGV2ZW50LCBjbGljaykge1xuICAgIGxldCBkeCA9IGNsaWNrLnggLSBldmVudC5jbGllbnRYLCBkeSA9IGNsaWNrLnkgLSBldmVudC5jbGllbnRZO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA8IDEwMDtcbn1cbmZ1bmN0aW9uIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgcHJvcE5hbWUsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHZpZXcuc29tZVByb3AocHJvcE5hbWUsIGYgPT4gaSA+ICRwb3MuZGVwdGggPyBmKHZpZXcsIHBvcywgJHBvcy5ub2RlQWZ0ZXIsICRwb3MuYmVmb3JlKGkpLCBldmVudCwgdHJ1ZSlcbiAgICAgICAgICAgIDogZih2aWV3LCBwb3MsICRwb3Mubm9kZShpKSwgJHBvcy5iZWZvcmUoaSksIGV2ZW50LCBmYWxzZSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBzZWxlY3Rpb24sIG9yaWdpbikge1xuICAgIGlmICghdmlldy5mb2N1c2VkKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBpZiAob3JpZ2luID09IFwicG9pbnRlclwiKVxuICAgICAgICB0ci5zZXRNZXRhKFwicG9pbnRlclwiLCB0cnVlKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdENsaWNrZWRMZWFmKHZpZXcsIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKSwgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICAgIGlmIChub2RlICYmIG5vZGUuaXNBdG9tICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VsZWN0Q2xpY2tlZE5vZGUodmlldywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgc2VsZWN0ZWROb2RlLCBzZWxlY3RBdDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbilcbiAgICAgICAgc2VsZWN0ZWROb2RlID0gc2VsLm5vZGU7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gaSA+ICRwb3MuZGVwdGggPyAkcG9zLm5vZGVBZnRlciA6ICRwb3Mubm9kZShpKTtcbiAgICAgICAgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIHNlbC4kZnJvbS5kZXB0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBpID49IHNlbC4kZnJvbS5kZXB0aCAmJiAkcG9zLmJlZm9yZShzZWwuJGZyb20uZGVwdGggKyAxKSA9PSBzZWwuJGZyb20ucG9zKVxuICAgICAgICAgICAgICAgIHNlbGVjdEF0ID0gJHBvcy5iZWZvcmUoc2VsLiRmcm9tLmRlcHRoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWxlY3RBdCA9ICRwb3MuYmVmb3JlKGkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdEF0ICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBzZWxlY3RBdCksIFwicG9pbnRlclwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50LCBzZWxlY3ROb2RlKSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUNsaWNrXCIsIGYgPT4gZih2aWV3LCBwb3MsIGV2ZW50KSkgfHxcbiAgICAgICAgKHNlbGVjdE5vZGUgPyBzZWxlY3RDbGlja2VkTm9kZSh2aWV3LCBpbnNpZGUpIDogc2VsZWN0Q2xpY2tlZExlYWYodmlldywgaW5zaWRlKSk7XG59XG5mdW5jdGlvbiBoYW5kbGVEb3VibGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZURvdWJsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRG91YmxlQ2xpY2tcIiwgZiA9PiBmKHZpZXcsIHBvcywgZXZlbnQpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVRyaXBsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlVHJpcGxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVUcmlwbGVDbGlja1wiLCBmID0+IGYodmlldywgcG9zLCBldmVudCkpIHx8XG4gICAgICAgIGRlZmF1bHRUcmlwbGVDbGljayh2aWV3LCBpbnNpZGUsIGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRUcmlwbGVDbGljayh2aWV3LCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIGlmIChpbnNpZGUgPT0gLTEpIHtcbiAgICAgICAgaWYgKGRvYy5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCAwLCBkb2MuY29udGVudC5zaXplKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gaSA+ICRwb3MuZGVwdGggPyAkcG9zLm5vZGVBZnRlciA6ICRwb3Mubm9kZShpKTtcbiAgICAgICAgbGV0IG5vZGVQb3MgPSAkcG9zLmJlZm9yZShpKTtcbiAgICAgICAgaWYgKG5vZGUuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIG5vZGVQb3MgKyAxLCBub2RlUG9zICsgMSArIG5vZGUuY29udGVudC5zaXplKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICBlbHNlIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIG5vZGVQb3MpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JjZURPTUZsdXNoKHZpZXcpIHtcbiAgICByZXR1cm4gZW5kQ29tcG9zaXRpb24odmlldyk7XG59XG5jb25zdCBzZWxlY3ROb2RlTW9kaWZpZXIgPSBtYWMgPyBcIm1ldGFLZXlcIiA6IFwiY3RybEtleVwiO1xuaGFuZGxlcnMubW91c2Vkb3duID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgbGV0IGZsdXNoZWQgPSBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICAgIGxldCBub3cgPSBEYXRlLm5vdygpLCB0eXBlID0gXCJzaW5nbGVDbGlja1wiO1xuICAgIGlmIChub3cgLSB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lIDwgNTAwICYmIGlzTmVhcihldmVudCwgdmlldy5pbnB1dC5sYXN0Q2xpY2spICYmICFldmVudFtzZWxlY3ROb2RlTW9kaWZpZXJdKSB7XG4gICAgICAgIGlmICh2aWV3LmlucHV0Lmxhc3RDbGljay50eXBlID09IFwic2luZ2xlQ2xpY2tcIilcbiAgICAgICAgICAgIHR5cGUgPSBcImRvdWJsZUNsaWNrXCI7XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuaW5wdXQubGFzdENsaWNrLnR5cGUgPT0gXCJkb3VibGVDbGlja1wiKVxuICAgICAgICAgICAgdHlwZSA9IFwidHJpcGxlQ2xpY2tcIjtcbiAgICB9XG4gICAgdmlldy5pbnB1dC5sYXN0Q2xpY2sgPSB7IHRpbWU6IG5vdywgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSwgdHlwZSB9O1xuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgaWYgKCFwb3MpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpIHtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXQubW91c2VEb3duKVxuICAgICAgICAgICAgdmlldy5pbnB1dC5tb3VzZURvd24uZG9uZSgpO1xuICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93biA9IG5ldyBNb3VzZURvd24odmlldywgcG9zLCBldmVudCwgISFmbHVzaGVkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHR5cGUgPT0gXCJkb3VibGVDbGlja1wiID8gaGFuZGxlRG91YmxlQ2xpY2sgOiBoYW5kbGVUcmlwbGVDbGljaykodmlldywgcG9zLnBvcywgcG9zLmluc2lkZSwgZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xuICAgIH1cbn07XG5jbGFzcyBNb3VzZURvd24ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHBvcywgZXZlbnQsIGZsdXNoZWQpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy5mbHVzaGVkID0gZmx1c2hlZDtcbiAgICAgICAgdGhpcy5kZWxheWVkU2VsZWN0aW9uU3luYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1pZ2h0RHJhZyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhcnREb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICAgICAgdGhpcy5zZWxlY3ROb2RlID0gISFldmVudFtzZWxlY3ROb2RlTW9kaWZpZXJdO1xuICAgICAgICB0aGlzLmFsbG93RGVmYXVsdCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICBsZXQgdGFyZ2V0Tm9kZSwgdGFyZ2V0UG9zO1xuICAgICAgICBpZiAocG9zLmluc2lkZSA+IC0xKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlID0gdmlldy5zdGF0ZS5kb2Mubm9kZUF0KHBvcy5pbnNpZGUpO1xuICAgICAgICAgICAgdGFyZ2V0UG9zID0gcG9zLmluc2lkZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MucG9zKTtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSAkcG9zLnBhcmVudDtcbiAgICAgICAgICAgIHRhcmdldFBvcyA9ICRwb3MuZGVwdGggPyAkcG9zLmJlZm9yZSgpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBmbHVzaGVkID8gbnVsbCA6IGV2ZW50LnRhcmdldDtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGVzYyA9IHRhcmdldCA/IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyh0YXJnZXQsIHRydWUpIDogbnVsbDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXREZXNjID8gdGFyZ2V0RGVzYy5kb20gOiBudWxsO1xuICAgICAgICBsZXQgeyBzZWxlY3Rpb24gfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gPT0gMCAmJlxuICAgICAgICAgICAgdGFyZ2V0Tm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlICYmIHRhcmdldE5vZGUudHlwZS5zcGVjLnNlbGVjdGFibGUgIT09IGZhbHNlIHx8XG4gICAgICAgICAgICBzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5mcm9tIDw9IHRhcmdldFBvcyAmJiBzZWxlY3Rpb24udG8gPiB0YXJnZXRQb3MpXG4gICAgICAgICAgICB0aGlzLm1pZ2h0RHJhZyA9IHtcbiAgICAgICAgICAgICAgICBub2RlOiB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgIHBvczogdGFyZ2V0UG9zLFxuICAgICAgICAgICAgICAgIGFkZEF0dHI6ICEhKHRoaXMudGFyZ2V0ICYmICF0aGlzLnRhcmdldC5kcmFnZ2FibGUpLFxuICAgICAgICAgICAgICAgIHNldFVuZWRpdGFibGU6ICEhKHRoaXMudGFyZ2V0ICYmIGdlY2tvICYmICF0aGlzLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIikpXG4gICAgICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy50YXJnZXQgJiYgdGhpcy5taWdodERyYWcgJiYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIgfHwgdGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cilcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaW5wdXQubW91c2VEb3duID09IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIiwgXCJmYWxzZVwiKTtcbiAgICAgICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCA9IHRoaXMudXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSA9IHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbiAgICB9XG4gICAgZG9uZSgpIHtcbiAgICAgICAgdGhpcy52aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCk7XG4gICAgICAgIHRoaXMudmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnICYmIHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZFNlbGVjdGlvblN5bmMpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNlbGVjdGlvblRvRE9NKHRoaXMudmlldykpO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXQubW91c2VEb3duID0gbnVsbDtcbiAgICB9XG4gICAgdXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIGlmICghdGhpcy52aWV3LmRvbS5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZG9jICE9IHRoaXMuc3RhcnREb2MpXG4gICAgICAgICAgICBwb3MgPSB0aGlzLnZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICAgICAgdGhpcy51cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0RlZmF1bHQgfHwgIXBvcykge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZVNpbmdsZUNsaWNrKHRoaXMudmlldywgcG9zLnBvcywgcG9zLmluc2lkZSwgZXZlbnQsIHRoaXMuc2VsZWN0Tm9kZSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuYnV0dG9uID09IDAgJiZcbiAgICAgICAgICAgICh0aGlzLmZsdXNoZWQgfHxcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgaWdub3JlcyBjbGlja3Mgb24gZHJhZ2dhYmxlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgKHNhZmFyaSAmJiB0aGlzLm1pZ2h0RHJhZyAmJiAhdGhpcy5taWdodERyYWcubm9kZS5pc0F0b20pIHx8XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzIHRyZWF0IGEgbm9kZSBzZWxlY3Rpb24gYXMgYVxuICAgICAgICAgICAgICAgIC8vIGN1cnNvciwgYnV0IHN0aWxsIHJlcG9ydCB0aGF0IHRoZSBub2RlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBhc2tlZCB0aHJvdWdoIGdldFNlbGVjdGlvbi4gWW91J2xsIHRoZW4gZ2V0IGFcbiAgICAgICAgICAgICAgICAvLyBzaXR1YXRpb24gd2hlcmUgY2xpY2tpbmcgYXQgdGhlIHBvaW50IHdoZXJlIHRoYXRcbiAgICAgICAgICAgICAgICAvLyAoaGlkZGVuKSBjdXJzb3IgaXMgZG9lc24ndCBjaGFuZ2UgdGhlIHNlbGVjdGlvbiwgYW5kXG4gICAgICAgICAgICAgICAgLy8gdGh1cyBkb2Vzbid0IGdldCBhIHJlYWN0aW9uIGZyb20gUHJvc2VNaXJyb3IuIFRoaXNcbiAgICAgICAgICAgICAgICAvLyB3b3JrcyBhcm91bmQgdGhhdC5cbiAgICAgICAgICAgICAgICAoY2hyb21lICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUgJiZcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oTWF0aC5hYnMocG9zLnBvcyAtIHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSksIE1hdGguYWJzKHBvcy5wb3MgLSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvKSkgPD0gMikpKSB7XG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odGhpcy52aWV3LCBTZWxlY3Rpb24ubmVhcih0aGlzLnZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zLnBvcykpLCBcInBvaW50ZXJcIik7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpO1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICAgIGlmIChldmVudC5idXR0b25zID09IDApXG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICB9XG4gICAgdXBkYXRlQWxsb3dEZWZhdWx0KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd0RlZmF1bHQgJiYgKE1hdGguYWJzKHRoaXMuZXZlbnQueCAtIGV2ZW50LmNsaWVudFgpID4gNCB8fFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5ldmVudC55IC0gZXZlbnQuY2xpZW50WSkgPiA0KSlcbiAgICAgICAgICAgIHRoaXMuYWxsb3dEZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG59XG5oYW5kbGVycy50b3VjaHN0YXJ0ID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dC5sYXN0VG91Y2ggPSBEYXRlLm5vdygpO1xuICAgIGZvcmNlRE9NRmx1c2godmlldyk7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy50b3VjaG1vdmUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RUb3VjaCA9IERhdGUubm93KCk7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy5jb250ZXh0bWVudSA9IHZpZXcgPT4gZm9yY2VET01GbHVzaCh2aWV3KTtcbmZ1bmN0aW9uIGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpIHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIFNlZSBodHRwczovL3d3dy5zdHVtLmRlLzIwMTYvMDYvMjQvaGFuZGxpbmctaW1lLWV2ZW50cy1pbi1qYXZhc2NyaXB0Ly5cbiAgICAvLyBPbiBKYXBhbmVzZSBpbnB1dCBtZXRob2QgZWRpdG9ycyAoSU1FcyksIHRoZSBFbnRlciBrZXkgaXMgdXNlZCB0byBjb25maXJtIGNoYXJhY3RlclxuICAgIC8vIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmVcbiAgICAvLyBlbWl0dGVkLiBUaGUga2V5ZG93biBldmVudCB0cmlnZ2VycyBuZXdsaW5lIGluc2VydGlvbiwgd2hpY2ggd2UgZG9uJ3Qgd2FudC5cbiAgICAvLyBUaGlzIG1ldGhvZCByZXR1cm5zIHRydWUgaWYgdGhlIGtleWRvd24gZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgLy8gV2Ugb25seSBpZ25vcmUgaXQgb25jZSwgYXMgcHJlc3NpbmcgRW50ZXIgYSBzZWNvbmQgdGltZSAqc2hvdWxkKiBpbnNlcnQgYSBuZXdsaW5lLlxuICAgIC8vIEZ1cnRoZXJtb3JlLCB0aGUga2V5ZG93biBldmVudCB0aW1lc3RhbXAgbXVzdCBiZSBjbG9zZSB0byB0aGUgY29tcG9zaXRpb25FbmRlZEF0IHRpbWVzdGFtcC5cbiAgICAvLyBUaGlzIGd1YXJkcyBhZ2FpbnN0IHRoZSBjYXNlIHdoZXJlIGNvbXBvc2l0aW9uZW5kIGlzIHRyaWdnZXJlZCB3aXRob3V0IHRoZSBrZXlib2FyZFxuICAgIC8vIChlLmcuIGNoYXJhY3RlciBjb25maXJtYXRpb24gbWF5IGJlIGRvbmUgd2l0aCB0aGUgbW91c2UpLCBhbmQga2V5ZG93biBpcyB0cmlnZ2VyZWRcbiAgICAvLyBhZnRlcndhcmRzLSB3ZSB3b3VsZG4ndCB3YW50IHRvIGlnbm9yZSB0aGUga2V5ZG93biBldmVudCBpbiB0aGlzIGNhc2UuXG4gICAgaWYgKHNhZmFyaSAmJiBNYXRoLmFicyhldmVudC50aW1lU3RhbXAgLSB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCkgPCA1MDApIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSAtMmU4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gRHJvcCBhY3RpdmUgY29tcG9zaXRpb24gYWZ0ZXIgNSBzZWNvbmRzIG9mIGluYWN0aXZpdHkgb24gQW5kcm9pZFxuY29uc3QgdGltZW91dENvbXBvc2l0aW9uID0gYW5kcm9pZCA/IDUwMDAgOiAtMTtcbmVkaXRIYW5kbGVycy5jb21wb3NpdGlvbnN0YXJ0ID0gZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9udXBkYXRlID0gdmlldyA9PiB7XG4gICAgaWYgKCF2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZsdXNoKCk7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCAkcG9zID0gc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xuICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmXG4gICAgICAgICAgICAoc3RhdGUuc3RvcmVkTWFya3MgfHxcbiAgICAgICAgICAgICAgICAoISRwb3MudGV4dE9mZnNldCAmJiAkcG9zLnBhcmVudE9mZnNldCAmJiAkcG9zLm5vZGVCZWZvcmUubWFya3Muc29tZShtID0+IG0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UpKSkpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gd3JhcCB0aGUgY3Vyc29yIGluIG1hcmsgbm9kZXMgZGlmZmVyZW50IGZyb20gdGhlIG9uZXMgaW4gdGhlIERPTSBjb250ZXh0XG4gICAgICAgICAgICB2aWV3Lm1hcmtDdXJzb3IgPSB2aWV3LnN0YXRlLnN0b3JlZE1hcmtzIHx8ICRwb3MubWFya3MoKTtcbiAgICAgICAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcsIHRydWUpO1xuICAgICAgICAgICAgdmlldy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcpO1xuICAgICAgICAgICAgLy8gSW4gZmlyZWZveCwgaWYgdGhlIGN1cnNvciBpcyBhZnRlciBidXQgb3V0c2lkZSBhIG1hcmtlZCBub2RlLFxuICAgICAgICAgICAgLy8gdGhlIGluc2VydGVkIHRleHQgd29uJ3QgaW5oZXJpdCB0aGUgbWFya3MuIFNvIHRoaXMgbW92ZXMgaXRcbiAgICAgICAgICAgIC8vIGluc2lkZSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICBpZiAoZ2Vja28gJiYgc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICEkcG9zLnRleHRPZmZzZXQgJiYgJHBvcy5ub2RlQmVmb3JlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDsgbm9kZSAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0ICE9IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBvZmZzZXQgPCAwID8gbm9kZS5sYXN0Q2hpbGQgOiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kb21TZWxlY3Rpb24oKS5jb2xsYXBzZShiZWZvcmUsIGJlZm9yZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIHRpbWVvdXRDb21wb3NpdGlvbik7XG59O1xuZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gZXZlbnQudGltZVN0YW1wO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSB2aWV3LmRvbU9ic2VydmVyLnBlbmRpbmdSZWNvcmRzKCkubGVuZ3RoID8gdmlldy5pbnB1dC5jb21wb3NpdGlvbklEIDogMDtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcylcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdmlldy5kb21PYnNlcnZlci5mbHVzaCgpKTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbklEKys7XG4gICAgICAgIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCAyMCk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCBkZWxheSkge1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQpO1xuICAgIGlmIChkZWxheSA+IC0xKVxuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGVuZENvbXBvc2l0aW9uKHZpZXcpLCBkZWxheSk7XG59XG5mdW5jdGlvbiBjbGVhckNvbXBvc2l0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSB0aW1lc3RhbXBGcm9tQ3VzdG9tRXZlbnQoKTtcbiAgICB9XG4gICAgd2hpbGUgKHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2Rlcy5sZW5ndGggPiAwKVxuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMucG9wKCkubWFya1BhcmVudHNEaXJ0eSgpO1xufVxuZnVuY3Rpb24gdGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50KCkge1xuICAgIGxldCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgZXZlbnQuaW5pdEV2ZW50KFwiZXZlbnRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcDtcbn1cbi8qKlxuQGludGVybmFsXG4qL1xuZnVuY3Rpb24gZW5kQ29tcG9zaXRpb24odmlldywgZm9yY2VVcGRhdGUgPSBmYWxzZSkge1xuICAgIGlmIChhbmRyb2lkICYmIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hpbmdTb29uID49IDApXG4gICAgICAgIHJldHVybjtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICBjbGVhckNvbXBvc2l0aW9uKHZpZXcpO1xuICAgIGlmIChmb3JjZVVwZGF0ZSB8fCB2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KSB7XG4gICAgICAgIGxldCBzZWwgPSBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcpO1xuICAgICAgICBpZiAoc2VsICYmICFzZWwuZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmlldy51cGRhdGVTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSkge1xuICAgIC8vIFRoZSBleHRyYSB3cmFwcGVyIGlzIHNvbWVob3cgbmVjZXNzYXJ5IG9uIElFL0VkZ2UgdG8gcHJldmVudCB0aGVcbiAgICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgICBpZiAoIXZpZXcuZG9tLnBhcmVudE5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgd3JhcCA9IHZpZXcuZG9tLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgIHdyYXAuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbigpLCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGRvbSk7XG4gICAgLy8gRG9uZSBiZWNhdXNlIElFIHdpbGwgZmlyZSBhIHNlbGVjdGlvbmNoYW5nZSBtb3ZpbmcgdGhlIHNlbGVjdGlvblxuICAgIC8vIHRvIGl0cyBzdGFydCB3aGVuIHJlbW92ZUFsbFJhbmdlcyBpcyBjYWxsZWQgYW5kIHRoZSBlZGl0b3Igc3RpbGxcbiAgICAvLyBoYXMgZm9jdXMgKHdoaWNoIHdpbGwgbWVzcyB1cCB0aGUgZWRpdG9yJ3Mgc2VsZWN0aW9uIHN0YXRlKS5cbiAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh3cmFwLnBhcmVudE5vZGUpXG4gICAgICAgICAgICB3cmFwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQod3JhcCk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9LCA1MCk7XG59XG4vLyBUaGlzIGlzIHZlcnkgY3J1ZGUsIGJ1dCB1bmZvcnR1bmF0ZWx5IGJvdGggdGhlc2UgYnJvd3NlcnMgX3ByZXRlbmRfXG4vLyB0aGF0IHRoZXkgaGF2ZSBhIGNsaXBib2FyZCBBUElcdTIwMTRhbGwgdGhlIG9iamVjdHMgYW5kIG1ldGhvZHMgYXJlXG4vLyB0aGVyZSwgdGhleSBqdXN0IGRvbid0IHdvcmssIGFuZCB0aGV5IGFyZSBoYXJkIHRvIHRlc3QuXG5jb25zdCBicm9rZW5DbGlwYm9hcmRBUEkgPSAoaWUgJiYgaWVfdmVyc2lvbiA8IDE1KSB8fFxuICAgIChpb3MgJiYgd2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuaGFuZGxlcnMuY29weSA9IGVkaXRIYW5kbGVycy5jdXQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgY3V0ID0gZXZlbnQudHlwZSA9PSBcImN1dFwiO1xuICAgIGlmIChzZWwuZW1wdHkpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBJRSBhbmQgRWRnZSdzIGNsaXBib2FyZCBpbnRlcmZhY2UgaXMgY29tcGxldGVseSBicm9rZW5cbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGxldCBzbGljZSA9IHNlbC5jb250ZW50KCksIHsgZG9tLCB0ZXh0IH0gPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgIGRhdGEuc2V0RGF0YShcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSk7XG4gICAgfVxuICAgIGlmIChjdXQpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiY3V0XCIpKTtcbn07XG5mdW5jdGlvbiBzbGljZVNpbmdsZU5vZGUoc2xpY2UpIHtcbiAgICByZXR1cm4gc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uub3BlbkVuZCA9PSAwICYmIHNsaWNlLmNvbnRlbnQuY2hpbGRDb3VudCA9PSAxID8gc2xpY2UuY29udGVudC5maXJzdENoaWxkIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3LCBldmVudCkge1xuICAgIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBwbGFpblRleHQgPSB2aWV3LmlucHV0LnNoaWZ0S2V5IHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBhcmVudC50eXBlLnNwZWMuY29kZTtcbiAgICBsZXQgdGFyZ2V0ID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KHBsYWluVGV4dCA/IFwidGV4dGFyZWFcIiA6IFwiZGl2XCIpKTtcbiAgICBpZiAoIXBsYWluVGV4dClcbiAgICAgICAgdGFyZ2V0LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICBsZXQgcGxhaW4gPSB2aWV3LmlucHV0LnNoaWZ0S2V5ICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgIT0gNDU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgaWYgKHRhcmdldC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgICAgaWYgKHBsYWluVGV4dClcbiAgICAgICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnZhbHVlLCBudWxsLCBwbGFpbiwgZXZlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb1Bhc3RlKHZpZXcsIHRhcmdldC50ZXh0Q29udGVudCwgdGFyZ2V0LmlubmVySFRNTCwgcGxhaW4sIGV2ZW50KTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBkb1Bhc3RlKHZpZXcsIHRleHQsIGh0bWwsIHByZWZlclBsYWluLCBldmVudCkge1xuICAgIGxldCBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCBwcmVmZXJQbGFpbiwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20pO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlUGFzdGVcIiwgZiA9PiBmKHZpZXcsIGV2ZW50LCBzbGljZSB8fCBTbGljZS5lbXB0eSkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXNsaWNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNpbmdsZU5vZGUgPSBzbGljZVNpbmdsZU5vZGUoc2xpY2UpO1xuICAgIGxldCB0ciA9IHNpbmdsZU5vZGVcbiAgICAgICAgPyB2aWV3LnN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNpbmdsZU5vZGUsIHByZWZlclBsYWluKVxuICAgICAgICA6IHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbihzbGljZSk7XG4gICAgdmlldy5kaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJwYXN0ZVwiLCB0cnVlKS5zZXRNZXRhKFwidWlFdmVudFwiLCBcInBhc3RlXCIpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldFRleHQoY2xpcGJvYXJkRGF0YSkge1xuICAgIGxldCB0ZXh0ID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSB8fCBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpO1xuICAgIGlmICh0ZXh0KVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICBsZXQgdXJpcyA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvdXJpLWxpc3RcIik7XG4gICAgcmV0dXJuIHVyaXMgPyB1cmlzLnJlcGxhY2UoL1xccj9cXG4vZywgXCIgXCIpIDogXCJcIjtcbn1cbmVkaXRIYW5kbGVycy5wYXN0ZSA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgLy8gSGFuZGxpbmcgcGFzdGUgZnJvbSBKYXZhU2NyaXB0IGR1cmluZyBjb21wb3NpdGlvbiBpcyB2ZXJ5IHBvb3JseVxuICAgIC8vIGhhbmRsZWQgYnkgYnJvd3NlcnMsIHNvIGFzIGEgZG9kZ3kgYnV0IHByZWZlcmFibGUga2x1ZGdlLCB3ZSBqdXN0XG4gICAgLy8gbGV0IHRoZSBicm93c2VyIGRvIGl0cyBuYXRpdmUgdGhpbmcgdGhlcmUsIGV4Y2VwdCBvbiBBbmRyb2lkLFxuICAgIC8vIHdoZXJlIHRoZSBlZGl0b3IgaXMgYWxtb3N0IGFsd2F5cyBjb21wb3NpbmcuXG4gICAgaWYgKHZpZXcuY29tcG9zaW5nICYmICFhbmRyb2lkKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBsZXQgcGxhaW4gPSB2aWV3LmlucHV0LnNoaWZ0S2V5ICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgIT0gNDU7XG4gICAgaWYgKGRhdGEgJiYgZG9QYXN0ZSh2aWV3LCBnZXRUZXh0KGRhdGEpLCBkYXRhLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIHBsYWluLCBldmVudCkpXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZWxzZVxuICAgICAgICBjYXB0dXJlUGFzdGUodmlldywgZXZlbnQpO1xufTtcbmNsYXNzIERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihzbGljZSwgbW92ZSwgbm9kZSkge1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMubW92ZSA9IG1vdmU7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfVxufVxuY29uc3QgZHJhZ0NvcHlNb2RpZmllciA9IG1hYyA/IFwiYWx0S2V5XCIgOiBcImN0cmxLZXlcIjtcbmhhbmRsZXJzLmRyYWdzdGFydCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IG1vdXNlRG93biA9IHZpZXcuaW5wdXQubW91c2VEb3duO1xuICAgIGlmIChtb3VzZURvd24pXG4gICAgICAgIG1vdXNlRG93bi5kb25lKCk7XG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHBvcyA9IHNlbC5lbXB0eSA/IG51bGwgOiB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgbGV0IG5vZGU7XG4gICAgaWYgKHBvcyAmJiBwb3MucG9zID49IHNlbC5mcm9tICYmIHBvcy5wb3MgPD0gKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gPyBzZWwudG8gLSAxIDogc2VsLnRvKSkgO1xuICAgIGVsc2UgaWYgKG1vdXNlRG93biAmJiBtb3VzZURvd24ubWlnaHREcmFnKSB7XG4gICAgICAgIG5vZGUgPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgbW91c2VEb3duLm1pZ2h0RHJhZy5wb3MpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZXZlbnQudGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUgJiYgZGVzYyAhPSB2aWV3LmRvY1ZpZXcpXG4gICAgICAgICAgICBub2RlID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIGRlc2MucG9zQmVmb3JlKTtcbiAgICB9XG4gICAgbGV0IHNsaWNlID0gKG5vZGUgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24pLmNvbnRlbnQoKSwgeyBkb20sIHRleHQgfSA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmNsZWFyRGF0YSgpO1xuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKGJyb2tlbkNsaXBib2FyZEFQSSA/IFwiVGV4dFwiIDogXCJ0ZXh0L2h0bWxcIiwgZG9tLmlubmVySFRNTCk7XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci9pc3N1ZXMvMTE1NlxuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TW92ZVwiO1xuICAgIGlmICghYnJva2VuQ2xpcGJvYXJkQVBJKVxuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgdGV4dCk7XG4gICAgdmlldy5kcmFnZ2luZyA9IG5ldyBEcmFnZ2luZyhzbGljZSwgIWV2ZW50W2RyYWdDb3B5TW9kaWZpZXJdLCBub2RlKTtcbn07XG5oYW5kbGVycy5kcmFnZW5kID0gdmlldyA9PiB7XG4gICAgbGV0IGRyYWdnaW5nID0gdmlldy5kcmFnZ2luZztcbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3LmRyYWdnaW5nID09IGRyYWdnaW5nKVxuICAgICAgICAgICAgdmlldy5kcmFnZ2luZyA9IG51bGw7XG4gICAgfSwgNTApO1xufTtcbmVkaXRIYW5kbGVycy5kcmFnb3ZlciA9IGVkaXRIYW5kbGVycy5kcmFnZW50ZXIgPSAoXywgZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuZWRpdEhhbmRsZXJzLmRyb3AgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBkcmFnZ2luZyA9IHZpZXcuZHJhZ2dpbmc7XG4gICAgdmlldy5kcmFnZ2luZyA9IG51bGw7XG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgZXZlbnRQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgaWYgKCFldmVudFBvcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCAkbW91c2UgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGV2ZW50UG9zLnBvcyk7XG4gICAgbGV0IHNsaWNlID0gZHJhZ2dpbmcgJiYgZHJhZ2dpbmcuc2xpY2U7XG4gICAgaWYgKHNsaWNlKSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldyk7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2xpY2UgPSBwYXJzZUZyb21DbGlwYm9hcmQodmlldywgZ2V0VGV4dChldmVudC5kYXRhVHJhbnNmZXIpLCBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIGZhbHNlLCAkbW91c2UpO1xuICAgIH1cbiAgICBsZXQgbW92ZSA9ICEhKGRyYWdnaW5nICYmICFldmVudFtkcmFnQ29weU1vZGlmaWVyXSk7XG4gICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVEcm9wXCIsIGYgPT4gZih2aWV3LCBldmVudCwgc2xpY2UgfHwgU2xpY2UuZW1wdHksIG1vdmUpKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc2xpY2UpXG4gICAgICAgIHJldHVybjtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGxldCBpbnNlcnRQb3MgPSBzbGljZSA/IGRyb3BQb2ludCh2aWV3LnN0YXRlLmRvYywgJG1vdXNlLnBvcywgc2xpY2UpIDogJG1vdXNlLnBvcztcbiAgICBpZiAoaW5zZXJ0UG9zID09IG51bGwpXG4gICAgICAgIGluc2VydFBvcyA9ICRtb3VzZS5wb3M7XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICBpZiAobW92ZSkge1xuICAgICAgICBsZXQgeyBub2RlIH0gPSBkcmFnZ2luZztcbiAgICAgICAgaWYgKG5vZGUpXG4gICAgICAgICAgICBub2RlLnJlcGxhY2UodHIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgbGV0IHBvcyA9IHRyLm1hcHBpbmcubWFwKGluc2VydFBvcyk7XG4gICAgbGV0IGlzTm9kZSA9IHNsaWNlLm9wZW5TdGFydCA9PSAwICYmIHNsaWNlLm9wZW5FbmQgPT0gMCAmJiBzbGljZS5jb250ZW50LmNoaWxkQ291bnQgPT0gMTtcbiAgICBsZXQgYmVmb3JlSW5zZXJ0ID0gdHIuZG9jO1xuICAgIGlmIChpc05vZGUpXG4gICAgICAgIHRyLnJlcGxhY2VSYW5nZVdpdGgocG9zLCBwb3MsIHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgZWxzZVxuICAgICAgICB0ci5yZXBsYWNlUmFuZ2UocG9zLCBwb3MsIHNsaWNlKTtcbiAgICBpZiAodHIuZG9jLmVxKGJlZm9yZUluc2VydCkpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgJHBvcyA9IHRyLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKGlzTm9kZSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpICYmXG4gICAgICAgICRwb3Mubm9kZUFmdGVyICYmICRwb3Mubm9kZUFmdGVyLnNhbWVNYXJrdXAoc2xpY2UuY29udGVudC5maXJzdENoaWxkKSkge1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24obmV3IE5vZGVTZWxlY3Rpb24oJHBvcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGVuZCA9IHRyLm1hcHBpbmcubWFwKGluc2VydFBvcyk7XG4gICAgICAgIHRyLm1hcHBpbmcubWFwc1t0ci5tYXBwaW5nLm1hcHMubGVuZ3RoIC0gMV0uZm9yRWFjaCgoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSA9PiBlbmQgPSBuZXdUbyk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRwb3MsIHRyLmRvYy5yZXNvbHZlKGVuZCkpKTtcbiAgICB9XG4gICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIuc2V0TWV0YShcInVpRXZlbnRcIiwgXCJkcm9wXCIpKTtcbn07XG5oYW5kbGVycy5mb2N1cyA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXQubGFzdEZvY3VzID0gRGF0ZS5ub3coKTtcbiAgICBpZiAoIXZpZXcuZm9jdXNlZCkge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgdmlldy5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5kb2NWaWV3ICYmIHZpZXcuaGFzRm9jdXMoKSAmJiAhdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmVxKHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSkpXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgICAgIH0sIDIwKTtcbiAgICB9XG59O1xuaGFuZGxlcnMuYmx1ciA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgaWYgKHZpZXcuZm9jdXNlZCkge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgdmlldy5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgICAgdmlldy5mb2N1c2VkID0gZmFsc2U7XG4gICAgfVxufTtcbmhhbmRsZXJzLmJlZm9yZWlucHV0ID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICAvLyBXZSBzaG91bGQgcHJvYmFibHkgZG8gbW9yZSB3aXRoIGJlZm9yZWlucHV0IGV2ZW50cywgYnV0IHN1cHBvcnRcbiAgICAvLyBpcyBzbyBzcG90dHkgdGhhdCBJJ20gc3RpbGwgd2FpdGluZyB0byBzZWUgd2hlcmUgdGhleSBhcmUgZ29pbmcuXG4gICAgLy8gVmVyeSBzcGVjaWZpYyBoYWNrIHRvIGRlYWwgd2l0aCBiYWNrc3BhY2Ugc29tZXRpbWVzIGZhaWxpbmcgb25cbiAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aGVuIGFmdGVyIGFuIHVuZWRpdGFibGUgbm9kZS5cbiAgICBpZiAoY2hyb21lICYmIGFuZHJvaWQgJiYgZXZlbnQuaW5wdXRUeXBlID09IFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCIpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5mbHVzaFNvb24oKTtcbiAgICAgICAgbGV0IHsgZG9tQ2hhbmdlQ291bnQgfSA9IHZpZXcuaW5wdXQ7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXQuZG9tQ2hhbmdlQ291bnQgIT0gZG9tQ2hhbmdlQ291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBFdmVudCBhbHJlYWR5IGhhZCBzb21lIGVmZmVjdFxuICAgICAgICAgICAgLy8gVGhpcyBidWcgdGVuZHMgdG8gY2xvc2UgdGhlIHZpcnR1YWwga2V5Ym9hcmQsIHNvIHdlIHJlZm9jdXNcbiAgICAgICAgICAgIHZpZXcuZG9tLmJsdXIoKTtcbiAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoOCwgXCJCYWNrc3BhY2VcIikpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIC8vIENydWRlIGFwcHJveGltYXRpb24gb2YgYmFja3NwYWNlIGJlaGF2aW9yIHdoZW4gbm8gY29tbWFuZCBoYW5kbGVkIGl0XG4gICAgICAgICAgICBpZiAoJGN1cnNvciAmJiAkY3Vyc29yLnBvcyA+IDApXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmRlbGV0ZSgkY3Vyc29yLnBvcyAtIDEsICRjdXJzb3IucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfSwgNTApO1xuICAgIH1cbn07XG4vLyBNYWtlIHN1cmUgYWxsIGhhbmRsZXJzIGdldCByZWdpc3RlcmVkXG5mb3IgKGxldCBwcm9wIGluIGVkaXRIYW5kbGVycylcbiAgICBoYW5kbGVyc1twcm9wXSA9IGVkaXRIYW5kbGVyc1twcm9wXTtcblxuZnVuY3Rpb24gY29tcGFyZU9ianMoYSwgYikge1xuICAgIGlmIChhID09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAobGV0IHAgaW4gYSlcbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgcCBpbiBiKVxuICAgICAgICBpZiAoIShwIGluIGEpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodG9ET00sIHNwZWMpIHtcbiAgICAgICAgdGhpcy50b0RPTSA9IHRvRE9NO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgICAgICAgdGhpcy5zaWRlID0gdGhpcy5zcGVjLnNpZGUgfHwgMDtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGxldCB7IHBvcywgZGVsZXRlZCB9ID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCB0aGlzLnNpZGUgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQgPyBudWxsIDogbmV3IERlY29yYXRpb24ocG9zIC0gb2Zmc2V0LCBwb3MgLSBvZmZzZXQsIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKG90aGVyIGluc3RhbmNlb2YgV2lkZ2V0VHlwZSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLnNwZWMua2V5ICYmIHRoaXMuc3BlYy5rZXkgPT0gb3RoZXIuc3BlYy5rZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b0RPTSA9PSBvdGhlci50b0RPTSAmJiBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKSk7XG4gICAgfVxuICAgIGRlc3Ryb3kobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5zcGVjLmRlc3Ryb3kpXG4gICAgICAgICAgICB0aGlzLnNwZWMuZGVzdHJveShub2RlKTtcbiAgICB9XG59XG5jbGFzcyBJbmxpbmVUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihhdHRycywgc3BlYykge1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWMgfHwgbm9TcGVjO1xuICAgIH1cbiAgICBtYXAobWFwcGluZywgc3Bhbiwgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcChzcGFuLmZyb20gKyBvbGRPZmZzZXQsIHRoaXMuc3BlYy5pbmNsdXNpdmVTdGFydCA/IC0xIDogMSkgLSBvZmZzZXQ7XG4gICAgICAgIGxldCB0byA9IG1hcHBpbmcubWFwKHNwYW4udG8gKyBvbGRPZmZzZXQsIHRoaXMuc3BlYy5pbmNsdXNpdmVFbmQgPyAxIDogLTEpIC0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gZnJvbSA+PSB0byA/IG51bGwgOiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgdGhpcyk7XG4gICAgfVxuICAgIHZhbGlkKF8sIHNwYW4pIHsgcmV0dXJuIHNwYW4uZnJvbSA8IHNwYW4udG87IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKG90aGVyIGluc3RhbmNlb2YgSW5saW5lVHlwZSAmJiBjb21wYXJlT2Jqcyh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKTtcbiAgICB9XG4gICAgc3RhdGljIGlzKHNwYW4pIHsgcmV0dXJuIHNwYW4udHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGU7IH1cbiAgICBkZXN0cm95KCkgeyB9XG59XG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCAxKTtcbiAgICAgICAgaWYgKGZyb20uZGVsZXRlZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdChzcGFuLnRvICsgb2xkT2Zmc2V0LCAtMSk7XG4gICAgICAgIGlmICh0by5kZWxldGVkIHx8IHRvLnBvcyA8PSBmcm9tLnBvcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbS5wb3MgLSBvZmZzZXQsIHRvLnBvcyAtIG9mZnNldCwgdGhpcyk7XG4gICAgfVxuICAgIHZhbGlkKG5vZGUsIHNwYW4pIHtcbiAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChzcGFuLmZyb20pLCBjaGlsZDtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA9PSBzcGFuLmZyb20gJiYgIShjaGlsZCA9IG5vZGUuY2hpbGQoaW5kZXgpKS5pc1RleHQgJiYgb2Zmc2V0ICsgY2hpbGQubm9kZVNpemUgPT0gc3Bhbi50bztcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIE5vZGVUeXBlICYmIGNvbXBhcmVPYmpzKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVPYmpzKHRoaXMuc3BlYywgb3RoZXIuc3BlYykpO1xuICAgIH1cbiAgICBkZXN0cm95KCkgeyB9XG59XG4vKipcbkRlY29yYXRpb24gb2JqZWN0cyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIHZpZXcgdGhyb3VnaCB0aGVcbltgZGVjb3JhdGlvbnNgIHByb3BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzLmRlY29yYXRpb25zKS4gVGhleSBjb21lIGluXG5zZXZlcmFsIHZhcmlhbnRzXHUyMDE0c2VlIHRoZSBzdGF0aWMgbWVtYmVycyBvZiB0aGlzIGNsYXNzIGZvciBkZXRhaWxzLlxuKi9cbmNsYXNzIERlY29yYXRpb24ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBkZWNvcmF0aW9uLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbi4gV2lsbCBiZSB0aGUgc2FtZSBhcyBgZnJvbWAgZm9yIFt3aWRnZXRcbiAgICBkZWNvcmF0aW9uc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl53aWRnZXQpLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHlwZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29weShmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIHRoaXMudHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZXEob3RoZXIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5lcShvdGhlci50eXBlKSAmJiB0aGlzLmZyb20gKyBvZmZzZXQgPT0gb3RoZXIuZnJvbSAmJiB0aGlzLnRvICsgb2Zmc2V0ID09IG90aGVyLnRvO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hcChtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLm1hcChtYXBwaW5nLCB0aGlzLCBvZmZzZXQsIG9sZE9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZXMgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggaXMgYSBET00gbm9kZSB0aGF0J3Mgc2hvd24gaW5cbiAgICB0aGUgZG9jdW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdVxuICAgIGRlbGF5IHJlbmRlcmluZyB0aGUgd2lkZ2V0IGJ5IHBhc3NpbmcgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAgICBjYWxsZWQgd2hlbiB0aGUgd2lkZ2V0IGlzIGFjdHVhbGx5IGRyYXduIGluIGEgdmlldywgYnV0IHlvdSBjYW5cbiAgICBhbHNvIGRpcmVjdGx5IHBhc3MgYSBET00gbm9kZS4gYGdldFBvc2AgY2FuIGJlIHVzZWQgdG8gZmluZCB0aGVcbiAgICB3aWRnZXQncyBjdXJyZW50IGRvY3VtZW50IHBvc2l0aW9uLlxuICAgICovXG4gICAgc3RhdGljIHdpZGdldChwb3MsIHRvRE9NLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihwb3MsIHBvcywgbmV3IFdpZGdldFR5cGUodG9ET00sIHNwZWMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlcyBhbiBpbmxpbmUgZGVjb3JhdGlvbiwgd2hpY2ggYWRkcyB0aGUgZ2l2ZW4gYXR0cmlidXRlcyB0b1xuICAgIGVhY2ggaW5saW5lIG5vZGUgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuXG4gICAgKi9cbiAgICBzdGF0aWMgaW5saW5lKGZyb20sIHRvLCBhdHRycywgc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIG5ldyBJbmxpbmVUeXBlKGF0dHJzLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZXMgYSBub2RlIGRlY29yYXRpb24uIGBmcm9tYCBhbmQgYHRvYCBzaG91bGQgcG9pbnQgcHJlY2lzZWx5XG4gICAgYmVmb3JlIGFuZCBhZnRlciBhIG5vZGUgaW4gdGhlIGRvY3VtZW50LiBUaGF0IG5vZGUsIGFuZCBvbmx5IHRoYXRcbiAgICBub2RlLCB3aWxsIHJlY2VpdmUgdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgbm9kZShmcm9tLCB0bywgYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCBuZXcgTm9kZVR5cGUoYXR0cnMsIHNwZWMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNwZWMgcHJvdmlkZWQgd2hlbiBjcmVhdGluZyB0aGlzIGRlY29yYXRpb24uIENhbiBiZSB1c2VmdWxcbiAgICBpZiB5b3UndmUgc3RvcmVkIGV4dHJhIGluZm9ybWF0aW9uIGluIHRoYXQgb2JqZWN0LlxuICAgICovXG4gICAgZ2V0IHNwZWMoKSB7IHJldHVybiB0aGlzLnR5cGUuc3BlYzsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlubGluZSgpIHsgcmV0dXJuIHRoaXMudHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCB3aWRnZXQoKSB7IHJldHVybiB0aGlzLnR5cGUgaW5zdGFuY2VvZiBXaWRnZXRUeXBlOyB9XG59XG5jb25zdCBub25lID0gW10sIG5vU3BlYyA9IHt9O1xuLyoqXG5BIGNvbGxlY3Rpb24gb2YgW2RlY29yYXRpb25zXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uKSwgb3JnYW5pemVkIGluIHN1Y2hcbmEgd2F5IHRoYXQgdGhlIGRyYXdpbmcgYWxnb3JpdGhtIGNhbiBlZmZpY2llbnRseSB1c2UgYW5kIGNvbXBhcmVcbnRoZW0uIFRoaXMgaXMgYSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlXHUyMDE0aXQgaXMgbm90IG1vZGlmaWVkLFxudXBkYXRlcyBjcmVhdGUgYSBuZXcgdmFsdWUuXG4qL1xuY2xhc3MgRGVjb3JhdGlvblNldCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbCwgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsLmxlbmd0aCA/IGxvY2FsIDogbm9uZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuIDogbm9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIGRlY29yYXRpb25zLCB1c2luZyB0aGUgc3RydWN0dXJlIG9mIHRoZSBnaXZlblxuICAgIGRvY3VtZW50LiBUaGlzIHdpbGwgY29uc3VtZSAobW9kaWZ5KSB0aGUgYGRlY29yYXRpb25zYCBhcnJheSwgc29cbiAgICB5b3UgbXVzdCBtYWtlIGEgY29weSBpZiB5b3Ugd2FudCBuZWVkIHRvIHByZXNlcnZlIHRoYXQuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRvYywgZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGRlY29yYXRpb25zLmxlbmd0aCA/IGJ1aWxkVHJlZShkZWNvcmF0aW9ucywgZG9jLCAwLCBub1NwZWMpIDogZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgYWxsIGRlY29yYXRpb25zIGluIHRoaXMgc2V0IHdoaWNoIHRvdWNoIHRoZSBnaXZlbiByYW5nZVxuICAgIChpbmNsdWRpbmcgZGVjb3JhdGlvbnMgdGhhdCBzdGFydCBvciBlbmQgZGlyZWN0bHkgYXQgdGhlXG4gICAgYm91bmRhcmllcykgYW5kIG1hdGNoIHRoZSBnaXZlbiBwcmVkaWNhdGUgb24gdGhlaXIgc3BlYy4gV2hlblxuICAgIGBzdGFydGAgYW5kIGBlbmRgIGFyZSBvbWl0dGVkLCBhbGwgZGVjb3JhdGlvbnMgaW4gdGhlIHNldCBhcmVcbiAgICBjb25zaWRlcmVkLiBXaGVuIGBwcmVkaWNhdGVgIGlzbid0IGdpdmVuLCBhbGwgZGVjb3JhdGlvbnMgYXJlXG4gICAgYXNzdW1lZCB0byBtYXRjaC5cbiAgICAqL1xuICAgIGZpbmQoc3RhcnQsIGVuZCwgcHJlZGljYXRlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5maW5kSW5uZXIoc3RhcnQgPT0gbnVsbCA/IDAgOiBzdGFydCwgZW5kID09IG51bGwgPyAxZTkgOiBlbmQsIHJlc3VsdCwgMCwgcHJlZGljYXRlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmluZElubmVyKHN0YXJ0LCBlbmQsIHJlc3VsdCwgb2Zmc2V0LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IHRoaXMubG9jYWxbaV07XG4gICAgICAgICAgICBpZiAoc3Bhbi5mcm9tIDw9IGVuZCAmJiBzcGFuLnRvID49IHN0YXJ0ICYmICghcHJlZGljYXRlIHx8IHByZWRpY2F0ZShzcGFuLnNwZWMpKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFuLmNvcHkoc3Bhbi5mcm9tICsgb2Zmc2V0LCBzcGFuLnRvICsgb2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSA8IGVuZCAmJiB0aGlzLmNoaWxkcmVuW2kgKyAxXSA+IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkT2ZmID0gdGhpcy5jaGlsZHJlbltpXSArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpICsgMl0uZmluZElubmVyKHN0YXJ0IC0gY2hpbGRPZmYsIGVuZCAtIGNoaWxkT2ZmLCByZXN1bHQsIG9mZnNldCArIGNoaWxkT2ZmLCBwcmVkaWNhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGUgc2V0IG9mIGRlY29yYXRpb25zIGluIHJlc3BvbnNlIHRvIGEgY2hhbmdlIGluIHRoZVxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgbWFwKG1hcHBpbmcsIGRvYywgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSB8fCBtYXBwaW5nLm1hcHMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwSW5uZXIobWFwcGluZywgZG9jLCAwLCAwLCBvcHRpb25zIHx8IG5vU3BlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWFwSW5uZXIobWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG5ld0xvY2FsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSB0aGlzLmxvY2FsW2ldLm1hcChtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCk7XG4gICAgICAgICAgICBpZiAobWFwcGVkICYmIG1hcHBlZC50eXBlLnZhbGlkKG5vZGUsIG1hcHBlZCkpXG4gICAgICAgICAgICAgICAgKG5ld0xvY2FsIHx8IChuZXdMb2NhbCA9IFtdKSkucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vblJlbW92ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVtb3ZlKHRoaXMubG9jYWxbaV0uc3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG1hcENoaWxkcmVuKHRoaXMuY2hpbGRyZW4sIG5ld0xvY2FsIHx8IFtdLCBtYXBwaW5nLCBub2RlLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXdMb2NhbCA/IG5ldyBEZWNvcmF0aW9uU2V0KG5ld0xvY2FsLnNvcnQoYnlQb3MpLCBub25lKSA6IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgdGhlIGdpdmVuIGFycmF5IG9mIGRlY29yYXRpb25zIHRvIHRoZSBvbmVzIGluIHRoZSBzZXQsXG4gICAgcHJvZHVjaW5nIGEgbmV3IHNldC4gQ29uc3VtZXMgdGhlIGBkZWNvcmF0aW9uc2AgYXJyYXkuIE5lZWRzXG4gICAgYWNjZXNzIHRvIHRoZSBjdXJyZW50IGRvY3VtZW50IHRvIGNyZWF0ZSB0aGUgYXBwcm9wcmlhdGUgdHJlZVxuICAgIHN0cnVjdHVyZS5cbiAgICAqL1xuICAgIGFkZChkb2MsIGRlY29yYXRpb25zKSB7XG4gICAgICAgIGlmICghZGVjb3JhdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICh0aGlzID09IGVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKGRvYywgZGVjb3JhdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRJbm5lcihkb2MsIGRlY29yYXRpb25zLCAwKTtcbiAgICB9XG4gICAgYWRkSW5uZXIoZG9jLCBkZWNvcmF0aW9ucywgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiwgY2hpbGRJbmRleCA9IDA7XG4gICAgICAgIGRvYy5mb3JFYWNoKChjaGlsZE5vZGUsIGNoaWxkT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBsZXQgYmFzZU9mZnNldCA9IGNoaWxkT2Zmc2V0ICsgb2Zmc2V0LCBmb3VuZDtcbiAgICAgICAgICAgIGlmICghKGZvdW5kID0gdGFrZVNwYW5zRm9yTm9kZShkZWNvcmF0aW9ucywgY2hpbGROb2RlLCBiYXNlT2Zmc2V0KSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZEluZGV4IDwgY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuW2NoaWxkSW5kZXhdIDwgY2hpbGRPZmZzZXQpXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleCArPSAzO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2NoaWxkSW5kZXhdID09IGNoaWxkT2Zmc2V0KVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2NoaWxkSW5kZXggKyAyXSA9IGNoaWxkcmVuW2NoaWxkSW5kZXggKyAyXS5hZGRJbm5lcihjaGlsZE5vZGUsIGZvdW5kLCBiYXNlT2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDAsIGNoaWxkT2Zmc2V0LCBjaGlsZE9mZnNldCArIGNoaWxkTm9kZS5ub2RlU2l6ZSwgYnVpbGRUcmVlKGZvdW5kLCBjaGlsZE5vZGUsIGJhc2VPZmZzZXQgKyAxLCBub1NwZWMpKTtcbiAgICAgICAgICAgIGNoaWxkSW5kZXggKz0gMztcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsb2NhbCA9IG1vdmVTcGFucyhjaGlsZEluZGV4ID8gd2l0aG91dE51bGxzKGRlY29yYXRpb25zKSA6IGRlY29yYXRpb25zLCAtb2Zmc2V0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghbG9jYWxbaV0udHlwZS52YWxpZChkb2MsIGxvY2FsW2ldKSlcbiAgICAgICAgICAgICAgICBsb2NhbC5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLmxlbmd0aCA/IHRoaXMubG9jYWwuY29uY2F0KGxvY2FsKS5zb3J0KGJ5UG9zKSA6IHRoaXMubG9jYWwsIGNoaWxkcmVuIHx8IHRoaXMuY2hpbGRyZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgc2V0IHRoYXQgY29udGFpbnMgdGhlIGRlY29yYXRpb25zIGluIHRoaXMgc2V0LCBtaW51c1xuICAgIHRoZSBvbmVzIGluIHRoZSBnaXZlbiBhcnJheS5cbiAgICAqL1xuICAgIHJlbW92ZShkZWNvcmF0aW9ucykge1xuICAgICAgICBpZiAoZGVjb3JhdGlvbnMubGVuZ3RoID09IDAgfHwgdGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVJbm5lcihkZWNvcmF0aW9ucywgMCk7XG4gICAgfVxuICAgIHJlbW92ZUlubmVyKGRlY29yYXRpb25zLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiwgbG9jYWwgPSB0aGlzLmxvY2FsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQ7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGNoaWxkcmVuW2ldICsgb2Zmc2V0LCB0byA9IGNoaWxkcmVuW2kgKyAxXSArIG9mZnNldDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBzcGFuOyBqIDwgZGVjb3JhdGlvbnMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKHNwYW4gPSBkZWNvcmF0aW9uc1tqXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Bhbi5mcm9tID4gZnJvbSAmJiBzcGFuLnRvIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb25zW2pdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIChmb3VuZCB8fCAoZm91bmQgPSBbXSkpLnB1c2goc3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuID09IHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICBsZXQgcmVtb3ZlZCA9IGNoaWxkcmVuW2kgKyAyXS5yZW1vdmVJbm5lcihmb3VuZCwgZnJvbSArIDEpO1xuICAgICAgICAgICAgaWYgKHJlbW92ZWQgIT0gZW1wdHkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMl0gPSByZW1vdmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDMpO1xuICAgICAgICAgICAgICAgIGkgLT0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWwubGVuZ3RoKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHNwYW47IGkgPCBkZWNvcmF0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoc3BhbiA9IGRlY29yYXRpb25zW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbG9jYWwubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxbal0uZXEoc3Bhbiwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbCA9PSB0aGlzLmxvY2FsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbCA9IHRoaXMubG9jYWwuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbC5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZHJlbiA9PSB0aGlzLmNoaWxkcmVuICYmIGxvY2FsID09IHRoaXMubG9jYWwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIGxvY2FsLmxlbmd0aCB8fCBjaGlsZHJlbi5sZW5ndGggPyBuZXcgRGVjb3JhdGlvblNldChsb2NhbCwgY2hpbGRyZW4pIDogZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZm9yQ2hpbGQob2Zmc2V0LCBub2RlKSB7XG4gICAgICAgIGlmICh0aGlzID09IGVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuICAgICAgICBsZXQgY2hpbGQsIGxvY2FsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSA9PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpICsgMl07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IG9mZnNldCArIDEsIGVuZCA9IHN0YXJ0ICsgbm9kZS5jb250ZW50LnNpemU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGRlYyA9IHRoaXMubG9jYWxbaV07XG4gICAgICAgICAgICBpZiAoZGVjLmZyb20gPCBlbmQgJiYgZGVjLnRvID4gc3RhcnQgJiYgKGRlYy50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KHN0YXJ0LCBkZWMuZnJvbSkgLSBzdGFydCwgdG8gPSBNYXRoLm1pbihlbmQsIGRlYy50bykgLSBzdGFydDtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHRvKVxuICAgICAgICAgICAgICAgICAgICAobG9jYWwgfHwgKGxvY2FsID0gW10pKS5wdXNoKGRlYy5jb3B5KGZyb20sIHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxTZXQgPSBuZXcgRGVjb3JhdGlvblNldChsb2NhbC5zb3J0KGJ5UG9zKSwgbm9uZSk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQgPyBuZXcgRGVjb3JhdGlvbkdyb3VwKFtsb2NhbFNldCwgY2hpbGRdKSA6IGxvY2FsU2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAodGhpcyA9PSBvdGhlcilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQpIHx8XG4gICAgICAgICAgICB0aGlzLmxvY2FsLmxlbmd0aCAhPSBvdGhlci5sb2NhbC5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9IG90aGVyLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmxvY2FsW2ldLmVxKG90aGVyLmxvY2FsW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldICE9IG90aGVyLmNoaWxkcmVuW2ldIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpICsgMV0gIT0gb3RoZXIuY2hpbGRyZW5baSArIDFdIHx8XG4gICAgICAgICAgICAgICAgIXRoaXMuY2hpbGRyZW5baSArIDJdLmVxKG90aGVyLmNoaWxkcmVuW2kgKyAyXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBsb2NhbHMobm9kZSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlT3ZlcmxhcCh0aGlzLmxvY2Fsc0lubmVyKG5vZGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBsb2NhbHNJbm5lcihub2RlKSB7XG4gICAgICAgIGlmICh0aGlzID09IGVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIG5vbmU7XG4gICAgICAgIGlmIChub2RlLmlubGluZUNvbnRlbnQgfHwgIXRoaXMubG9jYWwuc29tZShJbmxpbmVUeXBlLmlzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5sb2NhbFtpXS50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5sb2NhbFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgZGVjb3JhdGlvbnMuXG4qL1xuRGVjb3JhdGlvblNldC5lbXB0eSA9IG5ldyBEZWNvcmF0aW9uU2V0KFtdLCBbXSk7XG4vKipcbkBpbnRlcm5hbFxuKi9cbkRlY29yYXRpb25TZXQucmVtb3ZlT3ZlcmxhcCA9IHJlbW92ZU92ZXJsYXA7XG5jb25zdCBlbXB0eSA9IERlY29yYXRpb25TZXQuZW1wdHk7XG4vLyBBbiBhYnN0cmFjdGlvbiB0aGF0IGFsbG93cyB0aGUgY29kZSBkZWFsaW5nIHdpdGggZGVjb3JhdGlvbnMgdG9cbi8vIHRyZWF0IG11bHRpcGxlIERlY29yYXRpb25TZXQgb2JqZWN0cyBhcyBpZiBpdCB3ZXJlIGEgc2luZ2xlIG9iamVjdFxuLy8gd2l0aCAoYSBzdWJzZXQgb2YpIHRoZSBzYW1lIGludGVyZmFjZS5cbmNsYXNzIERlY29yYXRpb25Hcm91cCB7XG4gICAgY29uc3RydWN0b3IobWVtYmVycykge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzO1xuICAgIH1cbiAgICBtYXAobWFwcGluZywgZG9jKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlZERlY29zID0gdGhpcy5tZW1iZXJzLm1hcChtZW1iZXIgPT4gbWVtYmVyLm1hcChtYXBwaW5nLCBkb2MsIG5vU3BlYykpO1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbkdyb3VwLmZyb20obWFwcGVkRGVjb3MpO1xuICAgIH1cbiAgICBmb3JDaGlsZChvZmZzZXQsIGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC5pc0xlYWYpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5lbXB0eTtcbiAgICAgICAgbGV0IGZvdW5kID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5tZW1iZXJzW2ldLmZvckNoaWxkKG9mZnNldCwgY2hpbGQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBlbXB0eSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBEZWNvcmF0aW9uR3JvdXApXG4gICAgICAgICAgICAgICAgZm91bmQgPSBmb3VuZC5jb25jYXQocmVzdWx0Lm1lbWJlcnMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZvdW5kLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbkdyb3VwLmZyb20oZm91bmQpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIERlY29yYXRpb25Hcm91cCkgfHxcbiAgICAgICAgICAgIG90aGVyLm1lbWJlcnMubGVuZ3RoICE9IHRoaXMubWVtYmVycy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLm1lbWJlcnNbaV0uZXEob3RoZXIubWVtYmVyc1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbG9jYWxzKG5vZGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCwgc29ydGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsb2NhbHMgPSB0aGlzLm1lbWJlcnNbaV0ubG9jYWxzSW5uZXIobm9kZSk7XG4gICAgICAgICAgICBpZiAoIWxvY2Fscy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxvY2FscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvY2Fscy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobG9jYWxzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ID8gcmVtb3ZlT3ZlcmxhcChzb3J0ZWQgPyByZXN1bHQgOiByZXN1bHQuc29ydChieVBvcykpIDogbm9uZTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgZ3JvdXAgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiBkZWNvcmF0aW9uIHNldHMsIG9yIHJldHVyblxuICAgIC8vIGEgc2luZ2xlIHNldCB3aGVuIHBvc3NpYmxlLlxuICAgIHN0YXRpYyBmcm9tKG1lbWJlcnMpIHtcbiAgICAgICAgc3dpdGNoIChtZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gZW1wdHk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBtZW1iZXJzWzBdO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIG5ldyBEZWNvcmF0aW9uR3JvdXAobWVtYmVycy5ldmVyeShtID0+IG0gaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0KSA/IG1lbWJlcnMgOlxuICAgICAgICAgICAgICAgIG1lbWJlcnMucmVkdWNlKChyLCBtKSA9PiByLmNvbmNhdChtIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCA/IG0gOiBtLm1lbWJlcnMpLCBbXSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwQ2hpbGRyZW4ob2xkQ2hpbGRyZW4sIG5ld0xvY2FsLCBtYXBwaW5nLCBub2RlLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucykge1xuICAgIGxldCBjaGlsZHJlbiA9IG9sZENoaWxkcmVuLnNsaWNlKCk7XG4gICAgLy8gTWFyayB0aGUgY2hpbGRyZW4gdGhhdCBhcmUgZGlyZWN0bHkgdG91Y2hlZCBieSBjaGFuZ2VzLCBhbmRcbiAgICAvLyBtb3ZlIHRob3NlIHRoYXQgYXJlIGFmdGVyIHRoZSBjaGFuZ2VzLlxuICAgIGZvciAobGV0IGkgPSAwLCBiYXNlT2Zmc2V0ID0gb2xkT2Zmc2V0OyBpIDwgbWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBtb3ZlZCA9IDA7XG4gICAgICAgIG1hcHBpbmcubWFwc1tpXS5mb3JFYWNoKChvbGRTdGFydCwgb2xkRW5kLCBuZXdTdGFydCwgbmV3RW5kKSA9PiB7XG4gICAgICAgICAgICBsZXQgZFNpemUgPSAobmV3RW5kIC0gbmV3U3RhcnQpIC0gKG9sZEVuZCAtIG9sZFN0YXJ0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gY2hpbGRyZW5baSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPCAwIHx8IG9sZFN0YXJ0ID4gZW5kICsgYmFzZU9mZnNldCAtIG1vdmVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjaGlsZHJlbltpXSArIGJhc2VPZmZzZXQgLSBtb3ZlZDtcbiAgICAgICAgICAgICAgICBpZiAob2xkRW5kID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IG9sZFN0YXJ0IDw9IHN0YXJ0ID8gLTIgOiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkU3RhcnQgPj0gYmFzZU9mZnNldCAmJiBkU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSArPSBkU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdICs9IGRTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vdmVkICs9IGRTaXplO1xuICAgICAgICB9KTtcbiAgICAgICAgYmFzZU9mZnNldCA9IG1hcHBpbmcubWFwc1tpXS5tYXAoYmFzZU9mZnNldCwgLTEpO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBjaGlsZCBub2RlcyB0aGF0IHN0aWxsIGNvcnJlc3BvbmQgdG8gYSBzaW5nbGUgbm9kZSxcbiAgICAvLyByZWN1cnNpdmVseSBjYWxsIG1hcElubmVyIG9uIHRoZW0gYW5kIHVwZGF0ZSB0aGVpciBwb3NpdGlvbnMuXG4gICAgbGV0IG11c3RSZWJ1aWxkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA8IDApIHsgLy8gVG91Y2hlZCBub2Rlc1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA9PSAtMikge1xuICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSAtMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAob2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQpLCBmcm9tTG9jYWwgPSBmcm9tIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGZyb21Mb2NhbCA8IDAgfHwgZnJvbUxvY2FsID49IG5vZGUuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTXVzdCByZWFkIG9sZENoaWxkcmVuIGJlY2F1c2UgY2hpbGRyZW4gd2FzIHRhZ2dlZCB3aXRoIC0xXG4gICAgICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcChvbGRDaGlsZHJlbltpICsgMV0gKyBvbGRPZmZzZXQsIC0xKSwgdG9Mb2NhbCA9IHRvIC0gb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldDogY2hpbGRPZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoZnJvbUxvY2FsKTtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBub2RlLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE9mZnNldCA9PSBmcm9tTG9jYWwgJiYgY2hpbGRPZmZzZXQgKyBjaGlsZE5vZGUubm9kZVNpemUgPT0gdG9Mb2NhbCkge1xuICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBjaGlsZHJlbltpICsgMl1cbiAgICAgICAgICAgICAgICAgICAgLm1hcElubmVyKG1hcHBpbmcsIGNoaWxkTm9kZSwgZnJvbSArIDEsIG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCAhPSBlbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSA9IGZyb21Mb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gdG9Mb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDJdID0gbWFwcGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAvLyBSZW1haW5pbmcgY2hpbGRyZW4gbXVzdCBiZSBjb2xsZWN0ZWQgYW5kIHJlYnVpbHQgaW50byB0aGUgYXBwcm9wcmlhdGUgc3RydWN0dXJlXG4gICAgaWYgKG11c3RSZWJ1aWxkKSB7XG4gICAgICAgIGxldCBkZWNvcmF0aW9ucyA9IG1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zKGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgbmV3TG9jYWwsIG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKTtcbiAgICAgICAgbGV0IGJ1aWx0ID0gYnVpbGRUcmVlKGRlY29yYXRpb25zLCBub2RlLCAwLCBvcHRpb25zKTtcbiAgICAgICAgbmV3TG9jYWwgPSBidWlsdC5sb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPCAwKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDMpO1xuICAgICAgICAgICAgICAgIGkgLT0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgYnVpbHQuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gYnVpbHQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICB3aGlsZSAoaiA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltqXSA8IGZyb20pXG4gICAgICAgICAgICAgICAgaiArPSAzO1xuICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGosIDAsIGJ1aWx0LmNoaWxkcmVuW2ldLCBidWlsdC5jaGlsZHJlbltpICsgMV0sIGJ1aWx0LmNoaWxkcmVuW2kgKyAyXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uU2V0KG5ld0xvY2FsLnNvcnQoYnlQb3MpLCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBtb3ZlU3BhbnMoc3BhbnMsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0IHx8ICFzcGFucy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBzcGFucztcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRGVjb3JhdGlvbihzcGFuLmZyb20gKyBvZmZzZXQsIHNwYW4udG8gKyBvZmZzZXQsIHNwYW4udHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFwQW5kR2F0aGVyUmVtYWluaW5nRGVjb3JhdGlvbnMoY2hpbGRyZW4sIG9sZENoaWxkcmVuLCBkZWNvcmF0aW9ucywgbWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAvLyBHYXRoZXIgYWxsIGRlY29yYXRpb25zIGZyb20gdGhlIHJlbWFpbmluZyBtYXJrZWQgY2hpbGRyZW5cbiAgICBmdW5jdGlvbiBnYXRoZXIoc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBzZXQubG9jYWxbaV0ubWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQpXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vblJlbW92ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVtb3ZlKHNldC5sb2NhbFtpXS5zcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGdhdGhlcihzZXQuY2hpbGRyZW5baSArIDJdLCBzZXQuY2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA9PSAtMSlcbiAgICAgICAgICAgIGdhdGhlcihjaGlsZHJlbltpICsgMl0sIG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSk7XG4gICAgcmV0dXJuIGRlY29yYXRpb25zO1xufVxuZnVuY3Rpb24gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZW5kID0gb2Zmc2V0ICsgbm9kZS5ub2RlU2l6ZSwgZm91bmQgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwLCBzcGFuOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKChzcGFuID0gc3BhbnNbaV0pICYmIHNwYW4uZnJvbSA+IG9mZnNldCAmJiBzcGFuLnRvIDwgZW5kKSB7XG4gICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgc3BhbnNbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIHdpdGhvdXROdWxscyhhcnJheSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYXJyYXlbaV0gIT0gbnVsbClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQnVpbGQgdXAgYSB0cmVlIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBzZXQgb2YgZGVjb3JhdGlvbnMuIGBvZmZzZXRgXG4vLyBpcyBhIGJhc2Ugb2Zmc2V0IHRoYXQgc2hvdWxkIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgYGZyb21gIGFuZCBgdG9gXG4vLyBwb3NpdGlvbnMgaW4gdGhlIHNwYW5zIChzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gYWxsb2NhdGUgbmV3IHNwYW5zXG4vLyBmb3IgcmVjdXJzaXZlIGNhbGxzKS5cbmZ1bmN0aW9uIGJ1aWxkVHJlZShzcGFucywgbm9kZSwgb2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIGhhc051bGxzID0gZmFsc2U7XG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZE5vZGUsIGxvY2FsU3RhcnQpID0+IHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgY2hpbGROb2RlLCBsb2NhbFN0YXJ0ICsgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICBoYXNOdWxscyA9IHRydWU7XG4gICAgICAgICAgICBsZXQgc3VidHJlZSA9IGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBvZmZzZXQgKyBsb2NhbFN0YXJ0ICsgMSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc3VidHJlZSAhPSBlbXB0eSlcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGxvY2FsU3RhcnQsIGxvY2FsU3RhcnQgKyBjaGlsZE5vZGUubm9kZVNpemUsIHN1YnRyZWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGxvY2FscyA9IG1vdmVTcGFucyhoYXNOdWxscyA/IHdpdGhvdXROdWxscyhzcGFucykgOiBzcGFucywgLW9mZnNldCkuc29ydChieVBvcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbHMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghbG9jYWxzW2ldLnR5cGUudmFsaWQobm9kZSwgbG9jYWxzW2ldKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZShsb2NhbHNbaV0uc3BlYyk7XG4gICAgICAgICAgICBsb2NhbHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbG9jYWxzLmxlbmd0aCB8fCBjaGlsZHJlbi5sZW5ndGggPyBuZXcgRGVjb3JhdGlvblNldChsb2NhbHMsIGNoaWxkcmVuKSA6IGVtcHR5O1xufVxuLy8gVXNlZCB0byBzb3J0IGRlY29yYXRpb25zIHNvIHRoYXQgb25lcyB3aXRoIGEgbG93IHN0YXJ0IHBvc2l0aW9uXG4vLyBjb21lIGZpcnN0LCBhbmQgd2l0aGluIGEgc2V0IHdpdGggdGhlIHNhbWUgc3RhcnQgcG9zaXRpb24sIHRob3NlXG4vLyB3aXRoIGFuIHNtYWxsZXIgZW5kIHBvc2l0aW9uIGNvbWUgZmlyc3QuXG5mdW5jdGlvbiBieVBvcyhhLCBiKSB7XG4gICAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnRvIC0gYi50bztcbn1cbi8vIFNjYW4gYSBzb3J0ZWQgYXJyYXkgb2YgZGVjb3JhdGlvbnMgZm9yIHBhcnRpYWxseSBvdmVybGFwcGluZyBzcGFucyxcbi8vIGFuZCBzcGxpdCB0aG9zZSBzbyB0aGF0IG9ubHkgZnVsbHkgb3ZlcmxhcHBpbmcgc3BhbnMgYXJlIGxlZnQgKHRvXG4vLyBtYWtlIHN1YnNlcXVlbnQgcmVuZGVyaW5nIGVhc2llcikuIFdpbGwgcmV0dXJuIHRoZSBpbnB1dCBhcnJheSBpZlxuLy8gbm8gcGFydGlhbGx5IG92ZXJsYXBwaW5nIHNwYW5zIGFyZSBmb3VuZCAodGhlIGNvbW1vbiBjYXNlKS5cbmZ1bmN0aW9uIHJlbW92ZU92ZXJsYXAoc3BhbnMpIHtcbiAgICBsZXQgd29ya2luZyA9IHNwYW5zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29ya2luZy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbGV0IHNwYW4gPSB3b3JraW5nW2ldO1xuICAgICAgICBpZiAoc3Bhbi5mcm9tICE9IHNwYW4udG8pXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCB3b3JraW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB3b3JraW5nW2pdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPT0gc3Bhbi5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvICE9IHNwYW4udG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBzcGFucy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9sbG93ZWQgYnkgYSBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgbGFyZ2VyIHNwYW4uIFNwbGl0IHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYW4uXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nW2pdID0gbmV4dC5jb3B5KG5leHQuZnJvbSwgc3Bhbi50byk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqICsgMSwgbmV4dC5jb3B5KHNwYW4udG8sIG5leHQudG8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPCBzcGFuLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya2luZyA9PSBzcGFucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gc3BhbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbmQgb2YgdGhpcyBvbmUgb3ZlcmxhcHMgd2l0aCBhIHN1YnNlcXVlbnQgc3Bhbi4gU3BsaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1tpXSA9IHNwYW4uY29weShzcGFuLmZyb20sIG5leHQuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqLCBzcGFuLmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd29ya2luZztcbn1cbmZ1bmN0aW9uIGluc2VydEFoZWFkKGFycmF5LCBpLCBkZWNvKSB7XG4gICAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGggJiYgYnlQb3MoZGVjbywgYXJyYXlbaV0pID4gMClcbiAgICAgICAgaSsrO1xuICAgIGFycmF5LnNwbGljZShpLCAwLCBkZWNvKTtcbn1cbi8vIEdldCB0aGUgZGVjb3JhdGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IHByb3BzIG9mIGEgdmlldy5cbmZ1bmN0aW9uIHZpZXdEZWNvcmF0aW9ucyh2aWV3KSB7XG4gICAgbGV0IGZvdW5kID0gW107XG4gICAgdmlldy5zb21lUHJvcChcImRlY29yYXRpb25zXCIsIGYgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZih2aWV3LnN0YXRlKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgIT0gZW1wdHkpXG4gICAgICAgICAgICBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgaWYgKHZpZXcuY3Vyc29yV3JhcHBlcilcbiAgICAgICAgZm91bmQucHVzaChEZWNvcmF0aW9uU2V0LmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgW3ZpZXcuY3Vyc29yV3JhcHBlci5kZWNvXSkpO1xuICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShmb3VuZCk7XG59XG5cbmNvbnN0IG9ic2VydmVPcHRpb25zID0ge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWVcbn07XG4vLyBJRTExIGhhcyB2ZXJ5IGJyb2tlbiBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHdlIGFsc28gbGlzdGVuIHRvIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZFxuY29uc3QgdXNlQ2hhckRhdGEgPSBpZSAmJiBpZV92ZXJzaW9uIDw9IDExO1xuY2xhc3MgU2VsZWN0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIHNldChzZWwpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gc2VsLmFuY2hvck5vZGU7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gc2VsLmFuY2hvck9mZnNldDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBzZWwuZm9jdXNOb2RlO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgIH1cbiAgICBlcShzZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlbC5hbmNob3JOb2RlID09IHRoaXMuYW5jaG9yTm9kZSAmJiBzZWwuYW5jaG9yT2Zmc2V0ID09IHRoaXMuYW5jaG9yT2Zmc2V0ICYmXG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlID09IHRoaXMuZm9jdXNOb2RlICYmIHNlbC5mb2N1c09mZnNldCA9PSB0aGlzLmZvY3VzT2Zmc2V0O1xuICAgIH1cbn1cbmNsYXNzIERPTU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBoYW5kbGVET01DaGFuZ2UpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5oYW5kbGVET01DaGFuZ2UgPSBoYW5kbGVET01DaGFuZ2U7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyICYmXG4gICAgICAgICAgICBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dGF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgLy8gSUUxMSB3aWxsIHNvbWV0aW1lcyAob24gYmFja3NwYWNpbmcgb3V0IGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vIHRleHQgbm9kZSBhZnRlciBhIEJSIG5vZGUpIGNhbGwgdGhlIG9ic2VydmVyIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIGFjdHVhbGx5IHVwZGF0aW5nIHRoZSBET00sIHdoaWNoIHdpbGwgY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBQcm9zZU1pcnJvciB0byBtaXNzIHRoZSBjaGFuZ2UgKHNlZSAjOTMwKVxuICAgICAgICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIG11dGF0aW9ucy5zb21lKG0gPT4gbS50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbS5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIG0udHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIiAmJiBtLm9sZFZhbHVlLmxlbmd0aCA+IG0udGFyZ2V0Lm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGFyZ2V0OiBlLnRhcmdldCwgdHlwZTogXCJjaGFyYWN0ZXJEYXRhXCIsIG9sZFZhbHVlOiBlLnByZXZWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBmbHVzaFNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmZsdXNoaW5nU29vbiA8IDApXG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTsgdGhpcy5mbHVzaCgpOyB9LCAyMCk7XG4gICAgfVxuICAgIGZvcmNlRmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZsdXNoaW5nU29vbiA+IC0xKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZmx1c2hpbmdTb29uKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdTb29uID0gLTE7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy52aWV3LmRvbSwgb2JzZXJ2ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5jb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICBsZXQgdGFrZSA9IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgICAgIGlmICh0YWtlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRha2VbaV0pO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuZmx1c2goKSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub25DaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgY29ubmVjdFNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5vd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20ub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICBzdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKSB7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IGZhbHNlLCA1MCk7XG4gICAgfVxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKCkge1xuICAgICAgICBpZiAoIWhhc0ZvY3VzQW5kU2VsZWN0aW9uKHRoaXMudmlldykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcylcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpO1xuICAgICAgICAvLyBEZWxldGlvbnMgb24gSUUxMSBmaXJlIHRoZWlyIGV2ZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIsIGdpdmluZ1xuICAgICAgICAvLyB1cyBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBET00gY2hhbmdlcyBhcmVcbiAgICAgICAgLy8gcmVwb3J0ZWQuXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgc2VsID0gdGhpcy52aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICAvLyBTZWxlY3Rpb24uaXNDb2xsYXBzZWQgaXNuJ3QgcmVsaWFibGUgb24gSUVcbiAgICAgICAgICAgIGlmIChzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgc2V0Q3VyU2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHRoaXMudmlldy5kb21TZWxlY3Rpb25SYW5nZSgpKTtcbiAgICB9XG4gICAgaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCkge1xuICAgICAgICBpZiAoIXNlbC5mb2N1c05vZGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IGFuY2VzdG9ycyA9IG5ldyBTZXQsIGNvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IHNlbC5mb2N1c05vZGU7IHNjYW47IHNjYW4gPSBwYXJlbnROb2RlKHNjYW4pKVxuICAgICAgICAgICAgYW5jZXN0b3JzLmFkZChzY2FuKTtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IHNlbC5hbmNob3JOb2RlOyBzY2FuOyBzY2FuID0gcGFyZW50Tm9kZShzY2FuKSlcbiAgICAgICAgICAgIGlmIChhbmNlc3RvcnMuaGFzKHNjYW4pKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gc2NhbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRlc2MgPSBjb250YWluZXIgJiYgdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5pZ25vcmVNdXRhdGlvbih7XG4gICAgICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICAgICAgdGFyZ2V0OiBjb250YWluZXIubm9kZVR5cGUgPT0gMyA/IGNvbnRhaW5lci5wYXJlbnROb2RlIDogY29udGFpbmVyXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGVuZGluZ1JlY29yZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKVxuICAgICAgICAgICAgZm9yIChsZXQgbXV0IG9mIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSlcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWU7XG4gICAgfVxuICAgIGZsdXNoKCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXZpZXcuZG9jVmlldyB8fCB0aGlzLmZsdXNoaW5nU29vbiA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbXV0YXRpb25zID0gdGhpcy5wZW5kaW5nUmVjb3JkcygpO1xuICAgICAgICBpZiAobXV0YXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG5ld1NlbCA9ICF0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyAmJiAhdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkgJiYgaGFzRm9jdXNBbmRTZWxlY3Rpb24odmlldykgJiYgIXRoaXMuaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCk7XG4gICAgICAgIGxldCBmcm9tID0gLTEsIHRvID0gLTEsIHR5cGVPdmVyID0gZmFsc2UsIGFkZGVkID0gW107XG4gICAgICAgIGlmICh2aWV3LmVkaXRhYmxlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJlZ2lzdGVyTXV0YXRpb24obXV0YXRpb25zW2ldLCBhZGRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gZnJvbSA8IDAgPyByZXN1bHQuZnJvbSA6IE1hdGgubWluKHJlc3VsdC5mcm9tLCBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSB0byA8IDAgPyByZXN1bHQudG8gOiBNYXRoLm1heChyZXN1bHQudG8sIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlT3ZlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlY2tvICYmIGFkZGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCBicnMgPSBhZGRlZC5maWx0ZXIobiA9PiBuLm5vZGVOYW1lID09IFwiQlJcIik7XG4gICAgICAgICAgICBpZiAoYnJzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGEgPSBicnNbMF0sIGIgPSBicnNbMV07XG4gICAgICAgICAgICAgICAgaWYgKGEucGFyZW50Tm9kZSAmJiBhLnBhcmVudE5vZGUucGFyZW50Tm9kZSA9PSBiLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZWFkU2VsID0gbnVsbDtcbiAgICAgICAgLy8gSWYgaXQgbG9va3MgbGlrZSB0aGUgYnJvd3NlciBoYXMgcmVzZXQgdGhlIHNlbGVjdGlvbiB0byB0aGVcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIGRvY3VtZW50IGFmdGVyIGZvY3VzLCByZXN0b3JlIHRoZSBzZWxlY3Rpb24gZnJvbVxuICAgICAgICAvLyB0aGUgc3RhdGVcbiAgICAgICAgaWYgKGZyb20gPCAwICYmIG5ld1NlbCAmJiB2aWV3LmlucHV0Lmxhc3RGb2N1cyA+IERhdGUubm93KCkgLSAyMDAgJiZcbiAgICAgICAgICAgIE1hdGgubWF4KHZpZXcuaW5wdXQubGFzdFRvdWNoLCB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lKSA8IERhdGUubm93KCkgLSAzMDAgJiZcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbGxhcHNlZChzZWwpICYmIChyZWFkU2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3KSkgJiZcbiAgICAgICAgICAgIHJlYWRTZWwuZXEoU2VsZWN0aW9uLm5lYXIodmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgwKSwgMSkpKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IDA7XG4gICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQoc2VsKTtcbiAgICAgICAgICAgIHZpZXcuc2Nyb2xsVG9TZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcm9tID4gLTEgfHwgbmV3U2VsKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdmlldy5kb2NWaWV3Lm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgY2hlY2tDU1Modmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURPTUNoYW5nZShmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKTtcbiAgICAgICAgICAgIGlmICh2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkpXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHNlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJNdXRhdGlvbihtdXQsIGFkZGVkKSB7XG4gICAgICAgIC8vIElnbm9yZSBtdXRhdGlvbnMgaW5zaWRlIG5vZGVzIHRoYXQgd2VyZSBhbHJlYWR5IG5vdGVkIGFzIGluc2VydGVkXG4gICAgICAgIGlmIChhZGRlZC5pbmRleE9mKG11dC50YXJnZXQpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRlc2MgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhtdXQudGFyZ2V0KTtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiYXR0cmlidXRlc1wiICYmXG4gICAgICAgICAgICAoZGVzYyA9PSB0aGlzLnZpZXcuZG9jVmlldyB8fCBtdXQuYXR0cmlidXRlTmFtZSA9PSBcImNvbnRlbnRlZGl0YWJsZVwiIHx8XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzb21ldGltZXMgZmlyZXMgc3B1cmlvdXMgZXZlbnRzIGZvciBudWxsL2VtcHR5IHN0eWxlc1xuICAgICAgICAgICAgICAgIChtdXQuYXR0cmlidXRlTmFtZSA9PSBcInN0eWxlXCIgJiYgIW11dC5vbGRWYWx1ZSAmJiAhbXV0LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghZGVzYyB8fCBkZXNjLmlnbm9yZU11dGF0aW9uKG11dCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgYWRkZWQucHVzaChtdXQuYWRkZWROb2Rlc1tpXSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5jb250ZW50RE9NICYmIGRlc2MuY29udGVudERPTSAhPSBkZXNjLmRvbSAmJiAhZGVzYy5jb250ZW50RE9NLmNvbnRhaW5zKG11dC50YXJnZXQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGZyb206IGRlc2MucG9zQmVmb3JlLCB0bzogZGVzYy5wb3NBZnRlciB9O1xuICAgICAgICAgICAgbGV0IHByZXYgPSBtdXQucHJldmlvdXNTaWJsaW5nLCBuZXh0ID0gbXV0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgbXV0LmFkZGVkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gSUUxMSBnaXZlcyB1cyBpbmNvcnJlY3QgbmV4dC9wcmV2IHNpYmxpbmdzIGZvciBzb21lXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0aW9ucywgc28gaWYgdGhlcmUgYXJlIGFkZGVkIG5vZGVzLCByZWNvbXB1dGUgdGhvc2VcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dC5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHByZXZpb3VzU2libGluZywgbmV4dFNpYmxpbmcgfSA9IG11dC5hZGRlZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzU2libGluZyB8fCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG11dC5hZGRlZE5vZGVzLCBwcmV2aW91c1NpYmxpbmcpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dFNpYmxpbmcgfHwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChtdXQuYWRkZWROb2RlcywgbmV4dFNpYmxpbmcpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZnJvbU9mZnNldCA9IHByZXYgJiYgcHJldi5wYXJlbnROb2RlID09IG11dC50YXJnZXRcbiAgICAgICAgICAgICAgICA/IGRvbUluZGV4KHByZXYpICsgMSA6IDA7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGRlc2MubG9jYWxQb3NGcm9tRE9NKG11dC50YXJnZXQsIGZyb21PZmZzZXQsIC0xKTtcbiAgICAgICAgICAgIGxldCB0b09mZnNldCA9IG5leHQgJiYgbmV4dC5wYXJlbnROb2RlID09IG11dC50YXJnZXRcbiAgICAgICAgICAgICAgICA/IGRvbUluZGV4KG5leHQpIDogbXV0LnRhcmdldC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCB0byA9IGRlc2MubG9jYWxQb3NGcm9tRE9NKG11dC50YXJnZXQsIHRvT2Zmc2V0LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb20sIHRvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXV0LnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IGRlc2MucG9zQXRTdGFydCAtIGRlc2MuYm9yZGVyLCB0bzogZGVzYy5wb3NBdEVuZCArIGRlc2MuYm9yZGVyIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFwiY2hhcmFjdGVyRGF0YVwiXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IGRlc2MucG9zQXRTdGFydCxcbiAgICAgICAgICAgICAgICB0bzogZGVzYy5wb3NBdEVuZCxcbiAgICAgICAgICAgICAgICAvLyBBbiBldmVudCB3YXMgZ2VuZXJhdGVkIGZvciBhIHRleHQgY2hhbmdlIHRoYXQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgIC8vIGFueSB0ZXh0LiBNYXJrIHRoZSBkb20gY2hhbmdlIHRvIGZhbGwgYmFjayB0byBhc3N1bWluZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3Rpb24gd2FzIHR5cGVkIG92ZXIgd2l0aCBhbiBpZGVudGljYWwgdmFsdWUgaWYgaXQgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGFub3RoZXIgY2hhbmdlLlxuICAgICAgICAgICAgICAgIHR5cGVPdmVyOiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgY3NzQ2hlY2tlZCA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgY3NzQ2hlY2tXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNoZWNrQ1NTKHZpZXcpIHtcbiAgICBpZiAoY3NzQ2hlY2tlZC5oYXModmlldykpXG4gICAgICAgIHJldHVybjtcbiAgICBjc3NDaGVja2VkLnNldCh2aWV3LCBudWxsKTtcbiAgICBpZiAoWydub3JtYWwnLCAnbm93cmFwJywgJ3ByZS1saW5lJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKHZpZXcuZG9tKS53aGl0ZVNwYWNlKSAhPT0gLTEpIHtcbiAgICAgICAgdmlldy5yZXF1aXJlc0dlY2tvSGFja05vZGUgPSBnZWNrbztcbiAgICAgICAgaWYgKGNzc0NoZWNrV2FybmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlW1wid2FyblwiXShcIlByb3NlTWlycm9yIGV4cGVjdHMgdGhlIENTUyB3aGl0ZS1zcGFjZSBwcm9wZXJ0eSB0byBiZSBzZXQsIHByZWZlcmFibHkgdG8gJ3ByZS13cmFwJy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gbG9hZCBzdHlsZS9wcm9zZW1pcnJvci5jc3MgZnJvbSB0aGUgcHJvc2VtaXJyb3ItdmlldyBwYWNrYWdlLlwiKTtcbiAgICAgICAgY3NzQ2hlY2tXYXJuZWQgPSB0cnVlO1xuICAgIH1cbn1cbi8vIFVzZWQgdG8gd29yayBhcm91bmQgYSBTYWZhcmkgU2VsZWN0aW9uL3NoYWRvdyBET00gYnVnXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzQxNCBmaXhcbmZ1bmN0aW9uIHNhZmFyaVNoYWRvd1NlbGVjdGlvblJhbmdlKHZpZXcpIHtcbiAgICBsZXQgZm91bmQ7XG4gICAgZnVuY3Rpb24gcmVhZChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZm91bmQgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKVswXTtcbiAgICB9XG4gICAgLy8gQmVjYXVzZSBTYWZhcmkgKGF0IGxlYXN0IGluIDIwMTgtMjAyMikgZG9lc24ndCBwcm92aWRlIHJlZ3VsYXJcbiAgICAvLyBhY2Nlc3MgdG8gdGhlIHNlbGVjdGlvbiBpbnNpZGUgYSBzaGFkb3dSb290LCB3ZSBoYXZlIHRvIHBlcmZvcm0gYVxuICAgIC8vIHJpZGljdWxvdXMgaGFjayB0byBnZXQgYXQgaXRcdTIwMTR1c2luZyBgZXhlY0NvbW1hbmRgIHRvIHRyaWdnZXIgYVxuICAgIC8vIGBiZWZvcmVJbnB1dGAgZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVhZCB0aGUgdGFyZ2V0IHJhbmdlIGZyb20gdGhlXG4gICAgLy8gZXZlbnQuXG4gICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5kZW50XCIpO1xuICAgIHZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICBsZXQgYW5jaG9yTm9kZSA9IGZvdW5kLnN0YXJ0Q29udGFpbmVyLCBhbmNob3JPZmZzZXQgPSBmb3VuZC5zdGFydE9mZnNldDtcbiAgICBsZXQgZm9jdXNOb2RlID0gZm91bmQuZW5kQ29udGFpbmVyLCBmb2N1c09mZnNldCA9IGZvdW5kLmVuZE9mZnNldDtcbiAgICBsZXQgY3VycmVudEFuY2hvciA9IHZpZXcuZG9tQXRQb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yKTtcbiAgICAvLyBTaW5jZSBzdWNoIGEgcmFuZ2UgZG9lc24ndCBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuY2hvciBhbmQgaGVhZCxcbiAgICAvLyB1c2UgYSBoZXVyaXN0aWMgdGhhdCBmbGlwcyBpdCBhcm91bmQgaWYgaXRzIGVuZCBtYXRjaGVzIHRoZVxuICAgIC8vIGN1cnJlbnQgYW5jaG9yLlxuICAgIGlmIChpc0VxdWl2YWxlbnRQb3NpdGlvbihjdXJyZW50QW5jaG9yLm5vZGUsIGN1cnJlbnRBbmNob3Iub2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSlcbiAgICAgICAgW2FuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldF0gPSBbZm9jdXNOb2RlLCBmb2N1c09mZnNldCwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0XTtcbiAgICByZXR1cm4geyBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfTtcbn1cblxuLy8gTm90ZSB0aGF0IGFsbCByZWZlcmVuY2luZyBhbmQgcGFyc2luZyBpcyBkb25lIHdpdGggdGhlXG4vLyBzdGFydC1vZi1vcGVyYXRpb24gc2VsZWN0aW9uIGFuZCBkb2N1bWVudCwgc2luY2UgdGhhdCdzIHRoZSBvbmVcbi8vIHRoYXQgdGhlIERPTSByZXByZXNlbnRzLiBJZiBhbnkgY2hhbmdlcyBjYW1lIGluIGluIHRoZSBtZWFudGltZSxcbi8vIHRoZSBtb2RpZmljYXRpb24gaXMgbWFwcGVkIG92ZXIgdGhvc2UgYmVmb3JlIGl0IGlzIGFwcGxpZWQsIGluXG4vLyByZWFkRE9NQ2hhbmdlLlxuZnVuY3Rpb24gcGFyc2VCZXR3ZWVuKHZpZXcsIGZyb21fLCB0b18pIHtcbiAgICBsZXQgeyBub2RlOiBwYXJlbnQsIGZyb21PZmZzZXQsIHRvT2Zmc2V0LCBmcm9tLCB0byB9ID0gdmlldy5kb2NWaWV3LnBhcnNlUmFuZ2UoZnJvbV8sIHRvXyk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgZmluZDtcbiAgICBsZXQgYW5jaG9yID0gZG9tU2VsLmFuY2hvck5vZGU7XG4gICAgaWYgKGFuY2hvciAmJiB2aWV3LmRvbS5jb250YWlucyhhbmNob3Iubm9kZVR5cGUgPT0gMSA/IGFuY2hvciA6IGFuY2hvci5wYXJlbnROb2RlKSkge1xuICAgICAgICBmaW5kID0gW3sgbm9kZTogYW5jaG9yLCBvZmZzZXQ6IGRvbVNlbC5hbmNob3JPZmZzZXQgfV07XG4gICAgICAgIGlmICghc2VsZWN0aW9uQ29sbGFwc2VkKGRvbVNlbCkpXG4gICAgICAgICAgICBmaW5kLnB1c2goeyBub2RlOiBkb21TZWwuZm9jdXNOb2RlLCBvZmZzZXQ6IGRvbVNlbC5mb2N1c09mZnNldCB9KTtcbiAgICB9XG4gICAgLy8gV29yayBhcm91bmQgaXNzdWUgaW4gQ2hyb21lIHdoZXJlIGJhY2tzcGFjaW5nIHNvbWV0aW1lcyByZXBsYWNlc1xuICAgIC8vIHRoZSBkZWxldGVkIGNvbnRlbnQgd2l0aCBhIHJhbmRvbSBCUiBub2RlIChpc3N1ZXMgIzc5OSwgIzgzMSlcbiAgICBpZiAoY2hyb21lICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDgpIHtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdG9PZmZzZXQ7IG9mZiA+IGZyb21PZmZzZXQ7IG9mZi0tKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHBhcmVudC5jaGlsZE5vZGVzW29mZiAtIDFdLCBkZXNjID0gbm9kZS5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJCUlwiICYmICFkZXNjKSB7XG4gICAgICAgICAgICAgICAgdG9PZmZzZXQgPSBvZmY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgZGVzYy5zaXplKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdGFydERvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIGxldCBwYXJzZXIgPSB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IERPTVBhcnNlci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICBsZXQgJGZyb20gPSBzdGFydERvYy5yZXNvbHZlKGZyb20pO1xuICAgIGxldCBzZWwgPSBudWxsLCBkb2MgPSBwYXJzZXIucGFyc2UocGFyZW50LCB7XG4gICAgICAgIHRvcE5vZGU6ICRmcm9tLnBhcmVudCxcbiAgICAgICAgdG9wTWF0Y2g6ICRmcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleCgpKSxcbiAgICAgICAgdG9wT3BlbjogdHJ1ZSxcbiAgICAgICAgZnJvbTogZnJvbU9mZnNldCxcbiAgICAgICAgdG86IHRvT2Zmc2V0LFxuICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICRmcm9tLnBhcmVudC50eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIiA/IFwiZnVsbFwiIDogdHJ1ZSxcbiAgICAgICAgZmluZFBvc2l0aW9uczogZmluZCxcbiAgICAgICAgcnVsZUZyb21Ob2RlLFxuICAgICAgICBjb250ZXh0OiAkZnJvbVxuICAgIH0pO1xuICAgIGlmIChmaW5kICYmIGZpbmRbMF0ucG9zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGFuY2hvciA9IGZpbmRbMF0ucG9zLCBoZWFkID0gZmluZFsxXSAmJiBmaW5kWzFdLnBvcztcbiAgICAgICAgaWYgKGhlYWQgPT0gbnVsbClcbiAgICAgICAgICAgIGhlYWQgPSBhbmNob3I7XG4gICAgICAgIHNlbCA9IHsgYW5jaG9yOiBhbmNob3IgKyBmcm9tLCBoZWFkOiBoZWFkICsgZnJvbSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBkb2MsIHNlbCwgZnJvbSwgdG8gfTtcbn1cbmZ1bmN0aW9uIHJ1bGVGcm9tTm9kZShkb20pIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIGlmIChkZXNjKSB7XG4gICAgICAgIHJldHVybiBkZXNjLnBhcnNlUnVsZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmIGRvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgIC8vIFNhZmFyaSByZXBsYWNlcyB0aGUgbGlzdCBpdGVtIG9yIHRhYmxlIGNlbGwgd2l0aCBhIEJSXG4gICAgICAgIC8vIGRpcmVjdGx5IGluIHRoZSBsaXN0IG5vZGUgKD8hKSBpZiB5b3UgZGVsZXRlIHRoZSBsYXN0XG4gICAgICAgIC8vIGNoYXJhY3RlciBpbiBhIGxpc3QgaXRlbSBvciB0YWJsZSBjZWxsICgjNzA4LCAjODYyKVxuICAgICAgICBpZiAoc2FmYXJpICYmIC9eKHVsfG9sKSQvaS50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgbGV0IHNraXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgc2tpcC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc2tpcCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvbS5wYXJlbnROb2RlLmxhc3RDaGlsZCA9PSBkb20gfHwgc2FmYXJpICYmIC9eKHRyfHRhYmxlKSQvaS50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVOYW1lID09IFwiSU1HXCIgJiYgZG9tLmdldEF0dHJpYnV0ZShcIm1hcmstcGxhY2Vob2xkZXJcIikpIHtcbiAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgaXNJbmxpbmUgPSAvXihhfGFiYnJ8YWNyb255bXxifGJkW2lvXXxiaWd8YnJ8YnV0dG9ufGNpdGV8Y29kZXxkYXRhKGxpc3QpP3xkZWx8ZGZufGVtfGl8aW5zfGtiZHxsYWJlbHxtYXB8bWFya3xtZXRlcnxvdXRwdXR8cXxydWJ5fHN8c2FtcHxzbWFsbHxzcGFufHN0cm9uZ3xzdVticF18dGltZXx1fHR0fHZhcikkL2k7XG5mdW5jdGlvbiByZWFkRE9NQ2hhbmdlKHZpZXcsIGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWROb2Rlcykge1xuICAgIGxldCBjb21wb3NpdGlvbklEID0gdmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzIHx8ICh2aWV3LmNvbXBvc2luZyA/IHZpZXcuaW5wdXQuY29tcG9zaXRpb25JRCA6IDApO1xuICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyA9IDA7XG4gICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgIGxldCBvcmlnaW4gPSB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwID8gdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luIDogbnVsbDtcbiAgICAgICAgbGV0IG5ld1NlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldywgb3JpZ2luKTtcbiAgICAgICAgaWYgKG5ld1NlbCAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24uZXEobmV3U2VsKSkge1xuICAgICAgICAgICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmXG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gMTMgJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lICYmXG4gICAgICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3U2VsKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpXG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcInBvaW50ZXJcIiwgdHJ1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcmlnaW4gPT0gXCJrZXlcIilcbiAgICAgICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uSUQpXG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgJGJlZm9yZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgbGV0IHNoYXJlZCA9ICRiZWZvcmUuc2hhcmVkRGVwdGgodG8pO1xuICAgIGZyb20gPSAkYmVmb3JlLmJlZm9yZShzaGFyZWQgKyAxKTtcbiAgICB0byA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUodG8pLmFmdGVyKHNoYXJlZCArIDEpO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcGFyc2UgPSBwYXJzZUJldHdlZW4odmlldywgZnJvbSwgdG8pO1xuICAgIGxldCBkb2MgPSB2aWV3LnN0YXRlLmRvYywgY29tcGFyZSA9IGRvYy5zbGljZShwYXJzZS5mcm9tLCBwYXJzZS50byk7XG4gICAgbGV0IHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZTtcbiAgICAvLyBQcmVmZXIgYW5jaG9yaW5nIHRvIGVuZCB3aGVuIEJhY2tzcGFjZSBpcyBwcmVzc2VkXG4gICAgaWYgKHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDggJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lKSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb207XG4gICAgICAgIHByZWZlcnJlZFNpZGUgPSBcInN0YXJ0XCI7XG4gICAgfVxuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPSBudWxsO1xuICAgIGxldCBjaGFuZ2UgPSBmaW5kRGlmZihjb21wYXJlLmNvbnRlbnQsIHBhcnNlLmRvYy5jb250ZW50LCBwYXJzZS5mcm9tLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpO1xuICAgIGlmICgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSB8fCBhbmRyb2lkKSAmJlxuICAgICAgICBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVUeXBlID09IDEgJiYgIWlzSW5saW5lLnRlc3Qobi5ub2RlTmFtZSkpICYmXG4gICAgICAgICghY2hhbmdlIHx8IGNoYW5nZS5lbmRBID49IGNoYW5nZS5lbmRCKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSkge1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVPdmVyICYmIHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgIXNlbC5lbXB0eSAmJiBzZWwuJGhlYWQuc2FtZVBhcmVudChzZWwuJGFuY2hvcikgJiZcbiAgICAgICAgICAgICF2aWV3LmNvbXBvc2luZyAmJiAhKHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yICE9IHBhcnNlLnNlbC5oZWFkKSkge1xuICAgICAgICAgICAgY2hhbmdlID0geyBzdGFydDogc2VsLmZyb20sIGVuZEE6IHNlbC50bywgZW5kQjogc2VsLnRvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdmlldy5zdGF0ZS5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCAmJiAhc2VsLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJjb21wb3NpdGlvblwiLCBjb21wb3NpdGlvbklEKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENocm9tZSBzb21ldGltZXMgbGVhdmVzIHRoZSBjdXJzb3IgYmVmb3JlIHRoZSBpbnNlcnRlZCB0ZXh0IHdoZW5cbiAgICAvLyBjb21wb3NpbmcgYWZ0ZXIgYSBjdXJzb3Igd3JhcHBlci4gVGhpcyBtb3ZlcyBpdCBmb3J3YXJkLlxuICAgIGlmIChjaHJvbWUgJiYgdmlldy5jdXJzb3JXcmFwcGVyICYmIHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yID09IHZpZXcuY3Vyc29yV3JhcHBlci5kZWNvLmZyb20gJiZcbiAgICAgICAgcGFyc2Uuc2VsLmhlYWQgPT0gcGFyc2Uuc2VsLmFuY2hvcikge1xuICAgICAgICBsZXQgc2l6ZSA9IGNoYW5nZS5lbmRCIC0gY2hhbmdlLnN0YXJ0O1xuICAgICAgICBwYXJzZS5zZWwgPSB7IGFuY2hvcjogcGFyc2Uuc2VsLmFuY2hvciArIHNpemUsIGhlYWQ6IHBhcnNlLnNlbC5hbmNob3IgKyBzaXplIH07XG4gICAgfVxuICAgIHZpZXcuaW5wdXQuZG9tQ2hhbmdlQ291bnQrKztcbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgb3ZlcndyaXRpbmcgYSBzZWxlY3Rpb24gYnkgdHlwaW5nIG1hdGNoZXNcbiAgICAvLyB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBzZWxlY3RlZCBjb250ZW50LCBjcmVhdGluZyBhIGNoYW5nZVxuICAgIC8vIHRoYXQncyBzbWFsbGVyIHRoYW4gd2hhdCB3YXMgYWN0dWFsbHkgb3ZlcndyaXR0ZW4uXG4gICAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJlxuICAgICAgICBjaGFuZ2Uuc3RhcnQgPT0gY2hhbmdlLmVuZEIgJiZcbiAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChjaGFuZ2Uuc3RhcnQgPiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICYmIGNoYW5nZS5zdGFydCA8PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICsgMiAmJlxuICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+PSBwYXJzZS5mcm9tKSB7XG4gICAgICAgICAgICBjaGFuZ2Uuc3RhcnQgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS5lbmRBIDwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gJiYgY2hhbmdlLmVuZEEgPj0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gLSAyICYmXG4gICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byA8PSBwYXJzZS50bykge1xuICAgICAgICAgICAgY2hhbmdlLmVuZEIgKz0gKHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIC0gY2hhbmdlLmVuZEEpO1xuICAgICAgICAgICAgY2hhbmdlLmVuZEEgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJRTExIHdpbGwgaW5zZXJ0IGEgbm9uLWJyZWFraW5nIHNwYWNlIF9haGVhZF8gb2YgdGhlIHNwYWNlIGFmdGVyXG4gICAgLy8gdGhlIGN1cnNvciBzcGFjZSB3aGVuIGFkZGluZyBhIHNwYWNlIGJlZm9yZSBhbm90aGVyIHNwYWNlLiBXaGVuXG4gICAgLy8gdGhhdCBoYXBwZW5lZCwgYWRqdXN0IHRoZSBjaGFuZ2UgdG8gY292ZXIgdGhlIHNwYWNlIGluc3RlYWQuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0ICsgMSAmJlxuICAgICAgICBjaGFuZ2UuZW5kQSA9PSBjaGFuZ2Uuc3RhcnQgJiYgY2hhbmdlLnN0YXJ0ID4gcGFyc2UuZnJvbSAmJlxuICAgICAgICBwYXJzZS5kb2MudGV4dEJldHdlZW4oY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSAtIDEsIGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20gKyAxKSA9PSBcIiBcXHUwMGEwXCIpIHtcbiAgICAgICAgY2hhbmdlLnN0YXJ0LS07XG4gICAgICAgIGNoYW5nZS5lbmRBLS07XG4gICAgICAgIGNoYW5nZS5lbmRCLS07XG4gICAgfVxuICAgIGxldCAkZnJvbSA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tKTtcbiAgICBsZXQgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgbGV0ICRmcm9tQSA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCk7XG4gICAgbGV0IGlubGluZUNoYW5nZSA9ICRmcm9tLnNhbWVQYXJlbnQoJHRvKSAmJiAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCAmJiAkZnJvbUEuZW5kKCkgPj0gY2hhbmdlLmVuZEE7XG4gICAgbGV0IG5leHRTZWw7XG4gICAgLy8gSWYgdGhpcyBsb29rcyBsaWtlIHRoZSBlZmZlY3Qgb2YgcHJlc3NpbmcgRW50ZXIgKG9yIHdhcyByZWNvcmRlZFxuICAgIC8vIGFzIGJlaW5nIGFuIGlPUyBlbnRlciBwcmVzcyksIGp1c3QgZGlzcGF0Y2ggYW4gRW50ZXIga2V5IGluc3RlYWQuXG4gICAgaWYgKCgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSAmJlxuICAgICAgICAoIWlubGluZUNoYW5nZSB8fCBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVOYW1lID09IFwiRElWXCIgfHwgbi5ub2RlTmFtZSA9PSBcIlBcIikpKSB8fFxuICAgICAgICAoIWlubGluZUNoYW5nZSAmJiAkZnJvbS5wb3MgPCBwYXJzZS5kb2MuY29udGVudC5zaXplICYmICEkZnJvbS5zYW1lUGFyZW50KCR0bykgJiZcbiAgICAgICAgICAgIChuZXh0U2VsID0gU2VsZWN0aW9uLmZpbmRGcm9tKHBhcnNlLmRvYy5yZXNvbHZlKCRmcm9tLnBvcyArIDEpLCAxLCB0cnVlKSkgJiZcbiAgICAgICAgICAgIG5leHRTZWwuaGVhZCA9PSAkdG8ucG9zKSkgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpIHtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFNhbWUgZm9yIGJhY2tzcGFjZVxuICAgIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IgPiBjaGFuZ2Uuc3RhcnQgJiZcbiAgICAgICAgbG9va3NMaWtlSm9pbihkb2MsIGNoYW5nZS5zdGFydCwgY2hhbmdlLmVuZEEsICRmcm9tLCAkdG8pICYmXG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCg4LCBcIkJhY2tzcGFjZVwiKSkpKSB7XG4gICAgICAgIGlmIChhbmRyb2lkICYmIGNocm9tZSlcbiAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCk7IC8vICM4MjBcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aWxsIG9jY2FzaW9uYWxseSwgZHVyaW5nIGNvbXBvc2l0aW9uLCBkZWxldGUgdGhlXG4gICAgLy8gZW50aXJlIGNvbXBvc2l0aW9uIGFuZCB0aGVuIGltbWVkaWF0ZWx5IGluc2VydCBpdCBhZ2Fpbi4gVGhpcyBpc1xuICAgIC8vIHVzZWQgdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCAmJiBjaGFuZ2UuZW5kQiA9PSBjaGFuZ2Uuc3RhcnQpXG4gICAgICAgIHZpZXcuaW5wdXQubGFzdEFuZHJvaWREZWxldGUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFRoaXMgdHJpZXMgdG8gZGV0ZWN0IEFuZHJvaWQgdmlydHVhbCBrZXlib2FyZFxuICAgIC8vIGVudGVyLWFuZC1waWNrLXN1Z2dlc3Rpb24gYWN0aW9uLiBUaGF0IHNvbWV0aW1lcyAoc2VlIGlzc3VlXG4gICAgLy8gIzEwNTkpIGZpcnN0IGZpcmVzIGEgRE9NIG11dGF0aW9uLCBiZWZvcmUgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG9cbiAgICAvLyB0aGUgbmV3bHkgY3JlYXRlZCBibG9jay4gQW5kIHRoZW4sIGJlY2F1c2UgUHJvc2VNaXJyb3IgY2xlYW5zIHVwXG4gICAgLy8gdGhlIERPTSBzZWxlY3Rpb24sIGl0IGdpdmVzIHVwIG1vdmluZyB0aGUgc2VsZWN0aW9uIGVudGlyZWx5LFxuICAgIC8vIGxlYXZpbmcgdGhlIGN1cnNvciBpbiB0aGUgd3JvbmcgcGxhY2UuIFdoZW4gdGhhdCBoYXBwZW5zLCB3ZSBkcm9wXG4gICAgLy8gdGhlIG5ldyBwYXJhZ3JhcGggZnJvbSB0aGUgaW5pdGlhbCBjaGFuZ2UsIGFuZCBmaXJlIGEgc2ltdWxhdGVkXG4gICAgLy8gZW50ZXIga2V5IGFmdGVyd2FyZHMuXG4gICAgaWYgKGFuZHJvaWQgJiYgIWlubGluZUNoYW5nZSAmJiAkZnJvbS5zdGFydCgpICE9ICR0by5zdGFydCgpICYmICR0by5wYXJlbnRPZmZzZXQgPT0gMCAmJiAkZnJvbS5kZXB0aCA9PSAkdG8uZGVwdGggJiZcbiAgICAgICAgcGFyc2Uuc2VsICYmIHBhcnNlLnNlbC5hbmNob3IgPT0gcGFyc2Uuc2VsLmhlYWQgJiYgcGFyc2Uuc2VsLmhlYWQgPT0gY2hhbmdlLmVuZEEpIHtcbiAgICAgICAgY2hhbmdlLmVuZEIgLT0gMjtcbiAgICAgICAgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpOyB9KTtcbiAgICAgICAgfSwgMjApO1xuICAgIH1cbiAgICBsZXQgY2hGcm9tID0gY2hhbmdlLnN0YXJ0LCBjaFRvID0gY2hhbmdlLmVuZEE7XG4gICAgbGV0IHRyLCBzdG9yZWRNYXJrcywgbWFya0NoYW5nZTtcbiAgICBpZiAoaW5saW5lQ2hhbmdlKSB7XG4gICAgICAgIGlmICgkZnJvbS5wb3MgPT0gJHRvLnBvcykgeyAvLyBEZWxldGlvblxuICAgICAgICAgICAgLy8gSUUxMSBzb21ldGltZXMgd2VpcmRseSBtb3ZlcyB0aGUgRE9NIHNlbGVjdGlvbiBhcm91bmQgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIG91dCB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHRleHRibG9ja1xuICAgICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgJGZyb20ucGFyZW50T2Zmc2V0ID09IDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcygpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2VsZWN0aW9uVG9ET00odmlldyksIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyID0gdmlldy5zdGF0ZS50ci5kZWxldGUoY2hGcm9tLCBjaFRvKTtcbiAgICAgICAgICAgIHN0b3JlZE1hcmtzID0gZG9jLnJlc29sdmUoY2hhbmdlLnN0YXJ0KS5tYXJrc0Fjcm9zcyhkb2MucmVzb2x2ZShjaGFuZ2UuZW5kQSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCAvLyBBZGRpbmcgb3IgcmVtb3ZpbmcgYSBtYXJrXG4gICAgICAgIGNoYW5nZS5lbmRBID09IGNoYW5nZS5lbmRCICYmXG4gICAgICAgICAgICAobWFya0NoYW5nZSA9IGlzTWFya0NoYW5nZSgkZnJvbS5wYXJlbnQuY29udGVudC5jdXQoJGZyb20ucGFyZW50T2Zmc2V0LCAkdG8ucGFyZW50T2Zmc2V0KSwgJGZyb21BLnBhcmVudC5jb250ZW50LmN1dCgkZnJvbUEucGFyZW50T2Zmc2V0LCBjaGFuZ2UuZW5kQSAtICRmcm9tQS5zdGFydCgpKSkpKSB7XG4gICAgICAgICAgICB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgICAgICAgICBpZiAobWFya0NoYW5nZS50eXBlID09IFwiYWRkXCIpXG4gICAgICAgICAgICAgICAgdHIuYWRkTWFyayhjaEZyb20sIGNoVG8sIG1hcmtDaGFuZ2UubWFyayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdHIucmVtb3ZlTWFyayhjaEZyb20sIGNoVG8sIG1hcmtDaGFuZ2UubWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJGZyb20ucGFyZW50LmNoaWxkKCRmcm9tLmluZGV4KCkpLmlzVGV4dCAmJiAkZnJvbS5pbmRleCgpID09ICR0by5pbmRleCgpIC0gKCR0by50ZXh0T2Zmc2V0ID8gMCA6IDEpKSB7XG4gICAgICAgICAgICAvLyBCb3RoIHBvc2l0aW9ucyBpbiB0aGUgc2FtZSB0ZXh0IG5vZGUgLS0gc2ltcGx5IGluc2VydCB0ZXh0XG4gICAgICAgICAgICBsZXQgdGV4dCA9ICRmcm9tLnBhcmVudC50ZXh0QmV0d2VlbigkZnJvbS5wYXJlbnRPZmZzZXQsICR0by5wYXJlbnRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVUZXh0SW5wdXRcIiwgZiA9PiBmKHZpZXcsIGNoRnJvbSwgY2hUbywgdGV4dCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRyID0gdmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KHRleHQsIGNoRnJvbSwgY2hUbyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0cilcbiAgICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLnJlcGxhY2UoY2hGcm9tLCBjaFRvLCBwYXJzZS5kb2Muc2xpY2UoY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSwgY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKSk7XG4gICAgaWYgKHBhcnNlLnNlbCkge1xuICAgICAgICBsZXQgc2VsID0gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCB0ci5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgIC8vIENocm9tZSBBbmRyb2lkIHdpbGwgc29tZXRpbWVzLCBkdXJpbmcgY29tcG9zaXRpb24sIHJlcG9ydCB0aGVcbiAgICAgICAgLy8gc2VsZWN0aW9uIGluIHRoZSB3cm9uZyBwbGFjZS4gSWYgaXQgbG9va3MgbGlrZSB0aGF0IGlzXG4gICAgICAgIC8vIGhhcHBlbmluZywgZG9uJ3QgdXBkYXRlIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgIC8vIEVkZ2UganVzdCBkb2Vzbid0IG1vdmUgdGhlIGN1cnNvciBmb3J3YXJkIHdoZW4geW91IHN0YXJ0IHR5cGluZ1xuICAgICAgICAvLyBpbiBhbiBlbXB0eSBibG9jayBvciBiZXR3ZWVuIGJyIG5vZGVzLlxuICAgICAgICBpZiAoc2VsICYmICEoY2hyb21lICYmIGFuZHJvaWQgJiYgdmlldy5jb21wb3NpbmcgJiYgc2VsLmVtcHR5ICYmXG4gICAgICAgICAgICAoY2hhbmdlLnN0YXJ0ICE9IGNoYW5nZS5lbmRCIHx8IHZpZXcuaW5wdXQubGFzdEFuZHJvaWREZWxldGUgPCBEYXRlLm5vdygpIC0gMTAwKSAmJlxuICAgICAgICAgICAgKHNlbC5oZWFkID09IGNoRnJvbSB8fCBzZWwuaGVhZCA9PSB0ci5tYXBwaW5nLm1hcChjaFRvKSAtIDEpIHx8XG4gICAgICAgICAgICBpZSAmJiBzZWwuZW1wdHkgJiYgc2VsLmhlYWQgPT0gY2hGcm9tKSlcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgIH1cbiAgICBpZiAoc3RvcmVkTWFya3MpXG4gICAgICAgIHRyLmVuc3VyZU1hcmtzKHN0b3JlZE1hcmtzKTtcbiAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG59XG5mdW5jdGlvbiByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIGRvYywgcGFyc2VkU2VsKSB7XG4gICAgaWYgKE1hdGgubWF4KHBhcnNlZFNlbC5hbmNob3IsIHBhcnNlZFNlbC5oZWFkKSA+IGRvYy5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5hbmNob3IpLCBkb2MucmVzb2x2ZShwYXJzZWRTZWwuaGVhZCkpO1xufVxuLy8gR2l2ZW4gdHdvIHNhbWUtbGVuZ3RoLCBub24tZW1wdHkgZnJhZ21lbnRzIG9mIGlubGluZSBjb250ZW50LFxuLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGZpcnN0IGNvdWxkIGJlIGNyZWF0ZWQgZnJvbSB0aGUgc2Vjb25kIGJ5XG4vLyByZW1vdmluZyBvciBhZGRpbmcgYSBzaW5nbGUgbWFyayB0eXBlLlxuZnVuY3Rpb24gaXNNYXJrQ2hhbmdlKGN1ciwgcHJldikge1xuICAgIGxldCBjdXJNYXJrcyA9IGN1ci5maXJzdENoaWxkLm1hcmtzLCBwcmV2TWFya3MgPSBwcmV2LmZpcnN0Q2hpbGQubWFya3M7XG4gICAgbGV0IGFkZGVkID0gY3VyTWFya3MsIHJlbW92ZWQgPSBwcmV2TWFya3MsIHR5cGUsIG1hcmssIHVwZGF0ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgYWRkZWQgPSBwcmV2TWFya3NbaV0ucmVtb3ZlRnJvbVNldChhZGRlZCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVtb3ZlZCA9IGN1ck1hcmtzW2ldLnJlbW92ZUZyb21TZXQocmVtb3ZlZCk7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCA9PSAxICYmIHJlbW92ZWQubGVuZ3RoID09IDApIHtcbiAgICAgICAgbWFyayA9IGFkZGVkWzBdO1xuICAgICAgICB0eXBlID0gXCJhZGRcIjtcbiAgICAgICAgdXBkYXRlID0gKG5vZGUpID0+IG5vZGUubWFyayhtYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWRkZWQubGVuZ3RoID09IDAgJiYgcmVtb3ZlZC5sZW5ndGggPT0gMSkge1xuICAgICAgICBtYXJrID0gcmVtb3ZlZFswXTtcbiAgICAgICAgdHlwZSA9IFwicmVtb3ZlXCI7XG4gICAgICAgIHVwZGF0ZSA9IChub2RlKSA9PiBub2RlLm1hcmsobWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgdXBkYXRlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5jaGlsZENvdW50OyBpKyspXG4gICAgICAgIHVwZGF0ZWQucHVzaCh1cGRhdGUocHJldi5jaGlsZChpKSkpO1xuICAgIGlmIChGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLmVxKGN1cikpXG4gICAgICAgIHJldHVybiB7IG1hcmssIHR5cGUgfTtcbn1cbmZ1bmN0aW9uIGxvb2tzTGlrZUpvaW4ob2xkLCBzdGFydCwgZW5kLCAkbmV3U3RhcnQsICRuZXdFbmQpIHtcbiAgICBpZiAoISRuZXdTdGFydC5wYXJlbnQuaXNUZXh0YmxvY2sgfHxcbiAgICAgICAgLy8gVGhlIGNvbnRlbnQgbXVzdCBoYXZlIHNocnVua1xuICAgICAgICBlbmQgLSBzdGFydCA8PSAkbmV3RW5kLnBvcyAtICRuZXdTdGFydC5wb3MgfHxcbiAgICAgICAgLy8gbmV3RW5kIG11c3QgcG9pbnQgZGlyZWN0bHkgYXQgb3IgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgYmxvY2sgdGhhdCBuZXdTdGFydCBwb2ludHMgaW50b1xuICAgICAgICBza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJG5ld1N0YXJ0LCB0cnVlLCBmYWxzZSkgPCAkbmV3RW5kLnBvcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkc3RhcnQgPSBvbGQucmVzb2x2ZShzdGFydCk7XG4gICAgLy8gU3RhcnQgbXVzdCBiZSBhdCB0aGUgZW5kIG9mIGEgYmxvY2tcbiAgICBpZiAoJHN0YXJ0LnBhcmVudE9mZnNldCA8ICRzdGFydC5wYXJlbnQuY29udGVudC5zaXplIHx8ICEkc3RhcnQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRuZXh0ID0gb2xkLnJlc29sdmUoc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRzdGFydCwgdHJ1ZSwgdHJ1ZSkpO1xuICAgIC8vIFRoZSBuZXh0IHRleHRibG9jayBtdXN0IHN0YXJ0IGJlZm9yZSBlbmQgYW5kIGVuZCBuZWFyIGl0XG4gICAgaWYgKCEkbmV4dC5wYXJlbnQuaXNUZXh0YmxvY2sgfHwgJG5leHQucG9zID4gZW5kIHx8XG4gICAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV4dCwgdHJ1ZSwgZmFsc2UpIDwgZW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gVGhlIGZyYWdtZW50cyBhZnRlciB0aGUgam9pbiBwb2ludCBtdXN0IG1hdGNoXG4gICAgcmV0dXJuICRuZXdTdGFydC5wYXJlbnQuY29udGVudC5jdXQoJG5ld1N0YXJ0LnBhcmVudE9mZnNldCkuZXEoJG5leHQucGFyZW50LmNvbnRlbnQpO1xufVxuZnVuY3Rpb24gc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRwb3MsIGZyb21FbmQsIG1heU9wZW4pIHtcbiAgICBsZXQgZGVwdGggPSAkcG9zLmRlcHRoLCBlbmQgPSBmcm9tRW5kID8gJHBvcy5lbmQoKSA6ICRwb3MucG9zO1xuICAgIHdoaWxlIChkZXB0aCA+IDAgJiYgKGZyb21FbmQgfHwgJHBvcy5pbmRleEFmdGVyKGRlcHRoKSA9PSAkcG9zLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpKSB7XG4gICAgICAgIGRlcHRoLS07XG4gICAgICAgIGVuZCsrO1xuICAgICAgICBmcm9tRW5kID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChtYXlPcGVuKSB7XG4gICAgICAgIGxldCBuZXh0ID0gJHBvcy5ub2RlKGRlcHRoKS5tYXliZUNoaWxkKCRwb3MuaW5kZXhBZnRlcihkZXB0aCkpO1xuICAgICAgICB3aGlsZSAobmV4dCAmJiAhbmV4dC5pc0xlYWYpIHtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcG9zLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpIHtcbiAgICBsZXQgc3RhcnQgPSBhLmZpbmREaWZmU3RhcnQoYiwgcG9zKTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgYTogZW5kQSwgYjogZW5kQiB9ID0gYS5maW5kRGlmZkVuZChiLCBwb3MgKyBhLnNpemUsIHBvcyArIGIuc2l6ZSk7XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgc3RhcnQgLSBNYXRoLm1pbihlbmRBLCBlbmRCKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSBlbmRBICsgYWRqdXN0IC0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChlbmRBIDwgc3RhcnQgJiYgYS5zaXplIDwgYi5zaXplKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRBID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBzdGFydCAtPSBtb3ZlO1xuICAgICAgICBpZiAoc3RhcnQgJiYgc3RhcnQgPCBiLnNpemUgJiYgaXNTdXJyb2dhdGVQYWlyKGIudGV4dEJldHdlZW4oc3RhcnQgLSAxLCBzdGFydCArIDEpKSlcbiAgICAgICAgICAgIHN0YXJ0ICs9IG1vdmUgPyAxIDogLTE7XG4gICAgICAgIGVuZEIgPSBzdGFydCArIChlbmRCIC0gZW5kQSk7XG4gICAgICAgIGVuZEEgPSBzdGFydDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZW5kQiA8IHN0YXJ0KSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRCID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBzdGFydCAtPSBtb3ZlO1xuICAgICAgICBpZiAoc3RhcnQgJiYgc3RhcnQgPCBhLnNpemUgJiYgaXNTdXJyb2dhdGVQYWlyKGEudGV4dEJldHdlZW4oc3RhcnQgLSAxLCBzdGFydCArIDEpKSlcbiAgICAgICAgICAgIHN0YXJ0ICs9IG1vdmUgPyAxIDogLTE7XG4gICAgICAgIGVuZEEgPSBzdGFydCArIChlbmRBIC0gZW5kQik7XG4gICAgICAgIGVuZEIgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZEEsIGVuZEIgfTtcbn1cbmZ1bmN0aW9uIGlzU3Vycm9nYXRlUGFpcihzdHIpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCAhPSAyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGEgPSBzdHIuY2hhckNvZGVBdCgwKSwgYiA9IHN0ci5jaGFyQ29kZUF0KDEpO1xuICAgIHJldHVybiBhID49IDB4REMwMCAmJiBhIDw9IDB4REZGRiAmJiBiID49IDB4RDgwMCAmJiBiIDw9IDB4REJGRjtcbn1cblxuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX3NlcmlhbGl6ZUZvckNsaXBib2FyZCA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZDtcbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX19wYXJzZUZyb21DbGlwYm9hcmQgPSBwYXJzZUZyb21DbGlwYm9hcmQ7XG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fZW5kQ29tcG9zaXRpb24gPSBlbmRDb21wb3NpdGlvbjtcbi8qKlxuQW4gZWRpdG9yIHZpZXcgbWFuYWdlcyB0aGUgRE9NIHN0cnVjdHVyZSB0aGF0IHJlcHJlc2VudHMgYW5cbmVkaXRhYmxlIGRvY3VtZW50LiBJdHMgc3RhdGUgYW5kIGJlaGF2aW9yIGFyZSBkZXRlcm1pbmVkIGJ5IGl0c1xuW3Byb3BzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EaXJlY3RFZGl0b3JQcm9wcykuXG4qL1xuY2xhc3MgRWRpdG9yVmlldyB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdmlldy4gYHBsYWNlYCBtYXkgYmUgYSBET00gbm9kZSB0aGF0IHRoZSBlZGl0b3Igc2hvdWxkXG4gICAgYmUgYXBwZW5kZWQgdG8sIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHBsYWNlIGl0IGludG8gdGhlIGRvY3VtZW50LFxuICAgIG9yIGFuIG9iamVjdCB3aG9zZSBgbW91bnRgIHByb3BlcnR5IGhvbGRzIHRoZSBub2RlIHRvIHVzZSBhcyB0aGVcbiAgICBkb2N1bWVudCBjb250YWluZXIuIElmIGl0IGlzIGBudWxsYCwgdGhlIGVkaXRvciB3aWxsIG5vdCBiZVxuICAgIGFkZGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlLCBwcm9wcykge1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEtsdWRnZSB1c2VkIHRvIHdvcmsgYXJvdW5kIGEgQ2hyb21lIGJ1ZyBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFya0N1cnNvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5wdXQgPSBuZXcgSW5wdXRTdGF0ZTtcbiAgICAgICAgdGhpcy5wcmV2RGlyZWN0UGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpblZpZXdzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBIb2xkcyBgdHJ1ZWAgd2hlbiBhIGhhY2sgbm9kZSBpcyBuZWVkZWQgaW4gRmlyZWZveCB0byBwcmV2ZW50IHRoZVxuICAgICAgICBbc3BhY2UgaXMgZWF0ZW4gaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci9pc3N1ZXMvNjUxKVxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXF1aXJlc0dlY2tvSGFja05vZGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZW4gZWRpdG9yIGNvbnRlbnQgaXMgYmVpbmcgZHJhZ2dlZCwgdGhpcyBvYmplY3QgY29udGFpbnNcbiAgICAgICAgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGRyYWdnZWQgc2xpY2UgYW5kIHdoZXRoZXIgaXQgaXMgYmVpbmdcbiAgICAgICAgY29waWVkIG9yIG1vdmVkLiBBdCBhbnkgb3RoZXIgdGltZSwgaXQgaXMgbnVsbC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Byb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBwcm9wcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucyB8fCBbXTtcbiAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zLmZvckVhY2goY2hlY2tTdGF0ZUNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLmRpc3BhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZG9tID0gKHBsYWNlICYmIHBsYWNlLm1vdW50KSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBpZiAocGxhY2UpIHtcbiAgICAgICAgICAgIGlmIChwbGFjZS5hcHBlbmRDaGlsZClcbiAgICAgICAgICAgICAgICBwbGFjZS5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGxhY2UgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIHBsYWNlKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYWNlLm1vdW50KVxuICAgICAgICAgICAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICAgICAgICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGVWaWV3cyA9IGJ1aWxkTm9kZVZpZXdzKHRoaXMpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBkb2NWaWV3RGVzYyh0aGlzLnN0YXRlLmRvYywgY29tcHV0ZURvY0RlY28odGhpcyksIHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgdGhpcy5kb20sIHRoaXMpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyID0gbmV3IERPTU9ic2VydmVyKHRoaXMsIChmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKSA9PiByZWFkRE9NQ2hhbmdlKHRoaXMsIGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpKTtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICBpbml0SW5wdXQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlUGx1Z2luVmlld3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSG9sZHMgYHRydWVgIHdoZW4gYVxuICAgIFtjb21wb3NpdGlvbl0oaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3VpZXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHMpXG4gICAgaXMgYWN0aXZlLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2luZygpIHsgcmV0dXJuIHRoaXMuaW5wdXQuY29tcG9zaW5nOyB9XG4gICAgLyoqXG4gICAgVGhlIHZpZXcncyBjdXJyZW50IFtwcm9wc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMpLlxuICAgICovXG4gICAgZ2V0IHByb3BzKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvcHMuc3RhdGUgIT0gdGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLl9wcm9wcztcbiAgICAgICAgICAgIHRoaXMuX3Byb3BzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcHNbbmFtZV0gPSBwcmV2W25hbWVdO1xuICAgICAgICAgICAgdGhpcy5fcHJvcHMuc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wcztcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3J3MgcHJvcHMuIFdpbGwgaW1tZWRpYXRlbHkgY2F1c2UgYW4gdXBkYXRlIHRvXG4gICAgdGhlIERPTS5cbiAgICAqL1xuICAgIHVwZGF0ZShwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMuaGFuZGxlRE9NRXZlbnRzICE9IHRoaXMuX3Byb3BzLmhhbmRsZURPTUV2ZW50cylcbiAgICAgICAgICAgIGVuc3VyZUxpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgbGV0IHByZXZQcm9wcyA9IHRoaXMuX3Byb3BzO1xuICAgICAgICB0aGlzLl9wcm9wcyA9IHByb3BzO1xuICAgICAgICBpZiAocHJvcHMucGx1Z2lucykge1xuICAgICAgICAgICAgcHJvcHMucGx1Z2lucy5mb3JFYWNoKGNoZWNrU3RhdGVDb21wb25lbnQpO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlSW5uZXIocHJvcHMuc3RhdGUsIHByZXZQcm9wcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldyBieSB1cGRhdGluZyBleGlzdGluZyBwcm9wcyBvYmplY3Qgd2l0aCB0aGUgb2JqZWN0XG4gICAgZ2l2ZW4gYXMgYXJndW1lbnQuIEVxdWl2YWxlbnQgdG8gYHZpZXcudXBkYXRlKE9iamVjdC5hc3NpZ24oe30sXG4gICAgdmlldy5wcm9wcywgcHJvcHMpKWAuXG4gICAgKi9cbiAgICBzZXRQcm9wcyhwcm9wcykge1xuICAgICAgICBsZXQgdXBkYXRlZCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuX3Byb3BzKVxuICAgICAgICAgICAgdXBkYXRlZFtuYW1lXSA9IHRoaXMuX3Byb3BzW25hbWVdO1xuICAgICAgICB1cGRhdGVkLnN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wcylcbiAgICAgICAgICAgIHVwZGF0ZWRbbmFtZV0gPSBwcm9wc1tuYW1lXTtcbiAgICAgICAgdGhpcy51cGRhdGUodXBkYXRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgZWRpdG9yJ3MgYHN0YXRlYCBwcm9wLCB3aXRob3V0IHRvdWNoaW5nIGFueSBvZiB0aGVcbiAgICBvdGhlciBwcm9wcy5cbiAgICAqL1xuICAgIHVwZGF0ZVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVJbm5lcihzdGF0ZSwgdGhpcy5fcHJvcHMpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZUlubmVyKHN0YXRlLCBwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcHJldiA9IHRoaXMuc3RhdGUsIHJlZHJhdyA9IGZhbHNlLCB1cGRhdGVTZWwgPSBmYWxzZTtcbiAgICAgICAgLy8gV2hlbiBzdG9yZWQgbWFya3MgYXJlIGFkZGVkLCBzdG9wIGNvbXBvc2l0aW9uLCBzbyB0aGF0IHRoZXkgY2FuXG4gICAgICAgIC8vIGJlIGRpc3BsYXllZC5cbiAgICAgICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzICYmIHRoaXMuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICBjbGVhckNvbXBvc2l0aW9uKHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlU2VsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIGxldCBwbHVnaW5zQ2hhbmdlZCA9IHByZXYucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zIHx8IHRoaXMuX3Byb3BzLnBsdWdpbnMgIT0gcHJldlByb3BzLnBsdWdpbnM7XG4gICAgICAgIGlmIChwbHVnaW5zQ2hhbmdlZCB8fCB0aGlzLl9wcm9wcy5wbHVnaW5zICE9IHByZXZQcm9wcy5wbHVnaW5zIHx8IHRoaXMuX3Byb3BzLm5vZGVWaWV3cyAhPSBwcmV2UHJvcHMubm9kZVZpZXdzKSB7XG4gICAgICAgICAgICBsZXQgbm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZE5vZGVWaWV3cyhub2RlVmlld3MsIHRoaXMubm9kZVZpZXdzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVZpZXdzID0gbm9kZVZpZXdzO1xuICAgICAgICAgICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsdWdpbnNDaGFuZ2VkIHx8IHByZXZQcm9wcy5oYW5kbGVET01FdmVudHMgIT0gdGhpcy5fcHJvcHMuaGFuZGxlRE9NRXZlbnRzKSB7XG4gICAgICAgICAgICBlbnN1cmVMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICAgICAgICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICAgICAgICBsZXQgaW5uZXJEZWNvID0gdmlld0RlY29yYXRpb25zKHRoaXMpLCBvdXRlckRlY28gPSBjb21wdXRlRG9jRGVjbyh0aGlzKTtcbiAgICAgICAgbGV0IHNjcm9sbCA9IHByZXYucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zICYmICFwcmV2LmRvYy5lcShzdGF0ZS5kb2MpID8gXCJyZXNldFwiXG4gICAgICAgICAgICA6IHN0YXRlLnNjcm9sbFRvU2VsZWN0aW9uID4gcHJldi5zY3JvbGxUb1NlbGVjdGlvbiA/IFwidG8gc2VsZWN0aW9uXCIgOiBcInByZXNlcnZlXCI7XG4gICAgICAgIGxldCB1cGRhdGVEb2MgPSByZWRyYXcgfHwgIXRoaXMuZG9jVmlldy5tYXRjaGVzTm9kZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgaWYgKHVwZGF0ZURvYyB8fCAhc3RhdGUuc2VsZWN0aW9uLmVxKHByZXYuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHVwZGF0ZVNlbCA9IHRydWU7XG4gICAgICAgIGxldCBvbGRTY3JvbGxQb3MgPSBzY3JvbGwgPT0gXCJwcmVzZXJ2ZVwiICYmIHVwZGF0ZVNlbCAmJiB0aGlzLmRvbS5zdHlsZS5vdmVyZmxvd0FuY2hvciA9PSBudWxsICYmIHN0b3JlU2Nyb2xsUG9zKHRoaXMpO1xuICAgICAgICBpZiAodXBkYXRlU2VsKSB7XG4gICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGFuIGlzc3VlIGluIENocm9tZSwgSUUsIGFuZCBFZGdlIHdoZXJlIGNoYW5naW5nXG4gICAgICAgICAgICAvLyB0aGUgRE9NIGFyb3VuZCBhbiBhY3RpdmUgc2VsZWN0aW9uIHB1dHMgaXQgaW50byBhIGJyb2tlblxuICAgICAgICAgICAgLy8gc3RhdGUgd2hlcmUgdGhlIHRoaW5nIHRoZSB1c2VyIHNlZXMgZGlmZmVycyBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIHJlcG9ydGVkIGJ5IHRoZSBTZWxlY3Rpb24gb2JqZWN0ICgjNzEwLCAjOTczLFxuICAgICAgICAgICAgLy8gIzEwMTEsICMxMDEzLCAjMTAzNSkuXG4gICAgICAgICAgICBsZXQgZm9yY2VTZWxVcGRhdGUgPSB1cGRhdGVEb2MgJiYgKGllIHx8IGNocm9tZSkgJiYgIXRoaXMuY29tcG9zaW5nICYmXG4gICAgICAgICAgICAgICAgIXByZXYuc2VsZWN0aW9uLmVtcHR5ICYmICFzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgc2VsZWN0aW9uQ29udGV4dENoYW5nZWQocHJldi5zZWxlY3Rpb24sIHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICBpZiAodXBkYXRlRG9jKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgdGhhdCB0aGUgc2VsZWN0aW9uIHBvaW50cyBpbnRvIGlzIHdyaXR0ZW4gdG8sXG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIHNvbWV0aW1lcyBzdGFydHMgbWlzcmVwb3J0aW5nIHRoZSBzZWxlY3Rpb24sIHNvIHRoaXNcbiAgICAgICAgICAgICAgICAvLyB0cmFja3MgdGhhdCBhbmQgZm9yY2VzIGEgc2VsZWN0aW9uIHJlc2V0IHdoZW4gb3VyIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIGRpZCB3cml0ZSB0byB0aGUgbm9kZS5cbiAgICAgICAgICAgICAgICBsZXQgY2hyb21lS2x1ZGdlID0gY2hyb21lID8gKHRoaXMudHJhY2tXcml0ZXMgPSB0aGlzLmRvbVNlbGVjdGlvblJhbmdlKCkuZm9jdXNOb2RlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHJhdyB8fCAhdGhpcy5kb2NWaWV3LnVwZGF0ZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlT3V0ZXJEZWNvKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3ID0gZG9jVmlld0Rlc2Moc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgdGhpcy5kb20sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hyb21lS2x1ZGdlICYmICF0aGlzLnRyYWNrV3JpdGVzKVxuICAgICAgICAgICAgICAgICAgICBmb3JjZVNlbFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBmb3IgYW4gaXNzdWUgd2hlcmUgYW4gdXBkYXRlIGFycml2aW5nIHJpZ2h0IGJldHdlZW5cbiAgICAgICAgICAgIC8vIGEgRE9NIHNlbGVjdGlvbiBjaGFuZ2UgYW5kIHRoZSBcInNlbGVjdGlvbmNoYW5nZVwiIGV2ZW50IGZvciBpdFxuICAgICAgICAgICAgLy8gY2FuIGNhdXNlIGEgc3B1cmlvdXMgRE9NIHNlbGVjdGlvbiB1cGRhdGUsIGRpc3J1cHRpbmcgbW91c2VcbiAgICAgICAgICAgIC8vIGRyYWcgc2VsZWN0aW9uLlxuICAgICAgICAgICAgaWYgKGZvcmNlU2VsVXBkYXRlIHx8XG4gICAgICAgICAgICAgICAgISh0aGlzLmlucHV0Lm1vdXNlRG93biAmJiB0aGlzLmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uZXEodGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICBhbmNob3JJblJpZ2h0UGxhY2UodGhpcykpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odGhpcywgZm9yY2VTZWxVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3luY05vZGVTZWxlY3Rpb24odGhpcywgc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUGx1Z2luVmlld3MocHJldik7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5kcmFnZ2luZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGUpICYmICFwcmV2LmRvYy5lcShzdGF0ZS5kb2MpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVEcmFnZ2VkTm9kZSh0aGlzLmRyYWdnaW5nLCBwcmV2KTtcbiAgICAgICAgaWYgKHNjcm9sbCA9PSBcInJlc2V0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2Nyb2xsID09IFwidG8gc2VsZWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9TZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbGRTY3JvbGxQb3MpIHtcbiAgICAgICAgICAgIHJlc2V0U2Nyb2xsUG9zKG9sZFNjcm9sbFBvcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzY3JvbGxUb1NlbGVjdGlvbigpIHtcbiAgICAgICAgbGV0IHN0YXJ0RE9NID0gdGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpLmZvY3VzTm9kZTtcbiAgICAgICAgaWYgKHRoaXMuc29tZVByb3AoXCJoYW5kbGVTY3JvbGxUb1NlbGVjdGlvblwiLCBmID0+IGYodGhpcykpKSA7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuZG9jVmlldy5kb21BZnRlclBvcyh0aGlzLnN0YXRlLnNlbGVjdGlvbi5mcm9tKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBzY3JvbGxSZWN0SW50b1ZpZXcodGhpcywgdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzdGFydERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxSZWN0SW50b1ZpZXcodGhpcywgdGhpcy5jb29yZHNBdFBvcyh0aGlzLnN0YXRlLnNlbGVjdGlvbi5oZWFkLCAxKSwgc3RhcnRET00pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3lQbHVnaW5WaWV3cygpIHtcbiAgICAgICAgbGV0IHZpZXc7XG4gICAgICAgIHdoaWxlICh2aWV3ID0gdGhpcy5wbHVnaW5WaWV3cy5wb3AoKSlcbiAgICAgICAgICAgIGlmICh2aWV3LmRlc3Ryb3kpXG4gICAgICAgICAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgfVxuICAgIHVwZGF0ZVBsdWdpblZpZXdzKHByZXZTdGF0ZSkge1xuICAgICAgICBpZiAoIXByZXZTdGF0ZSB8fCBwcmV2U3RhdGUucGx1Z2lucyAhPSB0aGlzLnN0YXRlLnBsdWdpbnMgfHwgdGhpcy5kaXJlY3RQbHVnaW5zICE9IHRoaXMucHJldkRpcmVjdFBsdWdpbnMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldkRpcmVjdFBsdWdpbnMgPSB0aGlzLmRpcmVjdFBsdWdpbnM7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lQbHVnaW5WaWV3cygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRpcmVjdFBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5kaXJlY3RQbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy52aWV3KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpblZpZXdzLnB1c2gocGx1Z2luLnNwZWMudmlldyh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGUucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLnN0YXRlLnBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLnZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luVmlld3MucHVzaChwbHVnaW4uc3BlYy52aWV3KHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5WaWV3cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW5WaWV3ID0gdGhpcy5wbHVnaW5WaWV3c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luVmlldy51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpblZpZXcudXBkYXRlKHRoaXMsIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlRHJhZ2dlZE5vZGUoZHJhZ2dpbmcsIHByZXYpIHtcbiAgICAgICAgbGV0IHNlbCA9IGRyYWdnaW5nLm5vZGUsIGZvdW5kID0gLTE7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRvYy5ub2RlQXQoc2VsLmZyb20pID09IHNlbC5ub2RlKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHNlbC5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1vdmVkUG9zID0gc2VsLmZyb20gKyAodGhpcy5zdGF0ZS5kb2MuY29udGVudC5zaXplIC0gcHJldi5kb2MuY29udGVudC5zaXplKTtcbiAgICAgICAgICAgIGxldCBtb3ZlZCA9IG1vdmVkUG9zID4gMCAmJiB0aGlzLnN0YXRlLmRvYy5ub2RlQXQobW92ZWRQb3MpO1xuICAgICAgICAgICAgaWYgKG1vdmVkID09IHNlbC5ub2RlKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gbW92ZWRQb3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG5ldyBEcmFnZ2luZyhkcmFnZ2luZy5zbGljZSwgZHJhZ2dpbmcubW92ZSwgZm91bmQgPCAwID8gdW5kZWZpbmVkIDogTm9kZVNlbGVjdGlvbi5jcmVhdGUodGhpcy5zdGF0ZS5kb2MsIGZvdW5kKSk7XG4gICAgfVxuICAgIHNvbWVQcm9wKHByb3BOYW1lLCBmKSB7XG4gICAgICAgIGxldCBwcm9wID0gdGhpcy5fcHJvcHMgJiYgdGhpcy5fcHJvcHNbcHJvcE5hbWVdLCB2YWx1ZTtcbiAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHByb3AgPSB0aGlzLmRpcmVjdFBsdWdpbnNbaV0ucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGx1Z2lucyA9IHRoaXMuc3RhdGUucGx1Z2lucztcbiAgICAgICAgaWYgKHBsdWdpbnMpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IHBsdWdpbnNbaV0ucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYocHJvcCkgOiBwcm9wKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoZSB2aWV3IGhhcyBmb2N1cy5cbiAgICAqL1xuICAgIGhhc0ZvY3VzKCkge1xuICAgICAgICAvLyBXb3JrIGFyb3VuZCBJRSBub3QgaGFuZGxpbmcgZm9jdXMgY29ycmVjdGx5IGlmIHJlc2l6ZSBoYW5kbGVzIGFyZSBzaG93bi5cbiAgICAgICAgLy8gSWYgdGhlIGN1cnNvciBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHJlc2l6ZSBoYW5kbGVzLCBhY3RpdmVFbGVtZW50XG4gICAgICAgIC8vIHdpbGwgYmUgdGhhdCBlbGVtZW50IGluc3RlYWQgb2YgdGhpcy5kb20uXG4gICAgICAgIGlmIChpZSkge1xuICAgICAgICAgICAgLy8gSWYgYWN0aXZlRWxlbWVudCBpcyB3aXRoaW4gdGhpcy5kb20sIGFuZCB0aGVyZSBhcmUgbm8gb3RoZXIgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIHNldHRpbmcgYGNvbnRlbnRlZGl0YWJsZWAgdG8gZmFsc2UgaW4gYmV0d2VlbiwgdHJlYXQgaXQgYXMgZm9jdXNlZC5cbiAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCAhdGhpcy5kb20uY29udGFpbnMobm9kZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgJiYgdGhpcy5kb20gIT0gbm9kZSAmJiB0aGlzLmRvbS5jb250YWlucyhub2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSAnZmFsc2UnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgRm9jdXMgdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdGFibGUpXG4gICAgICAgICAgICBmb2N1c1ByZXZlbnRTY3JvbGwodGhpcy5kb20pO1xuICAgICAgICBzZWxlY3Rpb25Ub0RPTSh0aGlzKTtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGRvY3VtZW50IHJvb3QgaW4gd2hpY2ggdGhlIGVkaXRvciBleGlzdHMuIFRoaXMgd2lsbFxuICAgIHVzdWFsbHkgYmUgdGhlIHRvcC1sZXZlbCBgZG9jdW1lbnRgLCBidXQgbWlnaHQgYmUgYSBbc2hhZG93XG4gICAgRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9XZWJfQ29tcG9uZW50cy9TaGFkb3dfRE9NKVxuICAgIHJvb3QgaWYgdGhlIGVkaXRvciBpcyBpbnNpZGUgb25lLlxuICAgICovXG4gICAgZ2V0IHJvb3QoKSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9yb290O1xuICAgICAgICBpZiAoY2FjaGVkID09IG51bGwpXG4gICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSB0aGlzLmRvbS5wYXJlbnROb2RlOyBzZWFyY2g7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5ub2RlVHlwZSA9PSA5IHx8IChzZWFyY2gubm9kZVR5cGUgPT0gMTEgJiYgc2VhcmNoLmhvc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VhcmNoLmdldFNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihzZWFyY2gpLmdldFNlbGVjdGlvbiA9ICgpID0+IHNlYXJjaC5vd25lckRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdCA9IHNlYXJjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZWQgfHwgZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZW4gYW4gZXhpc3RpbmcgZWRpdG9yIHZpZXcgaXMgbW92ZWQgdG8gYSBuZXcgZG9jdW1lbnQgb3JcbiAgICBzaGFkb3cgdHJlZSwgY2FsbCB0aGlzIHRvIG1ha2UgaXQgcmVjb21wdXRlIGl0cyByb290LlxuICAgICovXG4gICAgdXBkYXRlUm9vdCgpIHtcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEdpdmVuIGEgcGFpciBvZiB2aWV3cG9ydCBjb29yZGluYXRlcywgcmV0dXJuIHRoZSBkb2N1bWVudFxuICAgIHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlbS4gTWF5IHJldHVybiBudWxsIGlmIHRoZSBnaXZlblxuICAgIGNvb3JkaW5hdGVzIGFyZW4ndCBpbnNpZGUgb2YgdGhlIGVkaXRvci4gV2hlbiBhbiBvYmplY3QgaXNcbiAgICByZXR1cm5lZCwgaXRzIGBwb3NgIHByb3BlcnR5IGlzIHRoZSBwb3NpdGlvbiBuZWFyZXN0IHRvIHRoZVxuICAgIGNvb3JkaW5hdGVzLCBhbmQgaXRzIGBpbnNpZGVgIHByb3BlcnR5IGhvbGRzIHRoZSBwb3NpdGlvbiBvZiB0aGVcbiAgICBpbm5lciBub2RlIHRoYXQgdGhlIHBvc2l0aW9uIGZhbGxzIGluc2lkZSBvZiwgb3IgLTEgaWYgaXQgaXMgYXRcbiAgICB0aGUgdG9wIGxldmVsLCBub3QgaW4gYW55IG5vZGUuXG4gICAgKi9cbiAgICBwb3NBdENvb3Jkcyhjb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHBvc0F0Q29vcmRzKHRoaXMsIGNvb3Jkcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIHZpZXdwb3J0IHJlY3RhbmdsZSBhdCBhIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgIGBsZWZ0YCBhbmQgYHJpZ2h0YCB3aWxsIGJlIHRoZSBzYW1lIG51bWJlciwgYXMgdGhpcyByZXR1cm5zIGFcbiAgICBmbGF0IGN1cnNvci1pc2ggcmVjdGFuZ2xlLiBJZiB0aGUgcG9zaXRpb24gaXMgYmV0d2VlbiB0d28gdGhpbmdzXG4gICAgdGhhdCBhcmVuJ3QgZGlyZWN0bHkgYWRqYWNlbnQsIGBzaWRlYCBkZXRlcm1pbmVzIHdoaWNoIGVsZW1lbnRcbiAgICBpcyB1c2VkLiBXaGVuIDwgMCwgdGhlIGVsZW1lbnQgYmVmb3JlIHRoZSBwb3NpdGlvbiBpcyB1c2VkLFxuICAgIG90aGVyd2lzZSB0aGUgZWxlbWVudCBhZnRlci5cbiAgICAqL1xuICAgIGNvb3Jkc0F0UG9zKHBvcywgc2lkZSA9IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0F0UG9zKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBkb2N1bWVudFxuICAgIHBvc2l0aW9uLiBXaGVuIGBzaWRlYCBpcyBuZWdhdGl2ZSwgZmluZCB0aGUgcG9zaXRpb24gYXMgY2xvc2UgYXNcbiAgICBwb3NzaWJsZSB0byB0aGUgY29udGVudCBiZWZvcmUgdGhlIHBvc2l0aW9uLiBXaGVuIHBvc2l0aXZlLFxuICAgIHByZWZlciBwb3NpdGlvbnMgY2xvc2UgdG8gdGhlIGNvbnRlbnQgYWZ0ZXIgdGhlIHBvc2l0aW9uLiBXaGVuXG4gICAgemVybywgcHJlZmVyIGFzIHNoYWxsb3cgYSBwb3NpdGlvbiBhcyBwb3NzaWJsZS5cbiAgICBcbiAgICBOb3RlIHRoYXQgeW91IHNob3VsZCAqKm5vdCoqIG11dGF0ZSB0aGUgZWRpdG9yJ3MgaW50ZXJuYWwgRE9NLFxuICAgIG9ubHkgaW5zcGVjdCBpdCAoYW5kIGV2ZW4gdGhhdCBpcyB1c3VhbGx5IG5vdCBuZWNlc3NhcnkpLlxuICAgICovXG4gICAgZG9tQXRQb3MocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgRE9NIG5vZGUgdGhhdCByZXByZXNlbnRzIHRoZSBkb2N1bWVudCBub2RlIGFmdGVyIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9uLiBNYXkgcmV0dXJuIGBudWxsYCB3aGVuIHRoZSBwb3NpdGlvbiBkb2Vzbid0IHBvaW50XG4gICAgaW4gZnJvbnQgb2YgYSBub2RlIG9yIGlmIHRoZSBub2RlIGlzIGluc2lkZSBhbiBvcGFxdWUgbm9kZSB2aWV3LlxuICAgIFxuICAgIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgYWJsZSB0byBjYWxsIHRoaW5ncyBsaWtlXG4gICAgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgb24gdGhhdCBET00gbm9kZS4gRG8gKipub3QqKiBtdXRhdGUgdGhlXG4gICAgZWRpdG9yIERPTSBkaXJlY3RseSwgb3IgYWRkIHN0eWxpbmcgdGhpcyB3YXksIHNpbmNlIHRoYXQgd2lsbCBiZVxuICAgIGltbWVkaWF0ZWx5IG92ZXJyaWRlbiBieSB0aGUgZWRpdG9yIGFzIGl0IHJlZHJhd3MgdGhlIG5vZGUuXG4gICAgKi9cbiAgICBub2RlRE9NKHBvcykge1xuICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZG9jVmlldy5kZXNjQXQocG9zKTtcbiAgICAgICAgcmV0dXJuIGRlc2MgPyBkZXNjLm5vZGVET00gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgZ2l2ZW4gRE9NXG4gICAgcG9zaXRpb24uIChXaGVuZXZlciBwb3NzaWJsZSwgaXQgaXMgcHJlZmVyYWJsZSB0byBpbnNwZWN0IHRoZVxuICAgIGRvY3VtZW50IHN0cnVjdHVyZSBkaXJlY3RseSwgcmF0aGVyIHRoYW4gcG9raW5nIGFyb3VuZCBpbiB0aGVcbiAgICBET00sIGJ1dCBzb21ldGltZXNcdTIwMTRmb3IgZXhhbXBsZSB3aGVuIGludGVycHJldGluZyBhbiBldmVudFxuICAgIHRhcmdldFx1MjAxNHlvdSBkb24ndCBoYXZlIGEgY2hvaWNlLilcbiAgICBcbiAgICBUaGUgYGJpYXNgIHBhcmFtZXRlciBjYW4gYmUgdXNlZCB0byBpbmZsdWVuY2Ugd2hpY2ggc2lkZSBvZiBhIERPTVxuICAgIG5vZGUgdG8gdXNlIHdoZW4gdGhlIHBvc2l0aW9uIGlzIGluc2lkZSBhIGxlYWYgbm9kZS5cbiAgICAqL1xuICAgIHBvc0F0RE9NKG5vZGUsIG9mZnNldCwgYmlhcyA9IC0xKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIGJpYXMpO1xuICAgICAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRPTSBwb3NpdGlvbiBub3QgaW5zaWRlIHRoZSBlZGl0b3JcIik7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgb3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrIHdoZW5cbiAgICBtb3ZpbmcgaW4gYSBnaXZlbiBkaXJlY3Rpb24uIFdoZW4sIGZvciBleGFtcGxlLCBnaXZlbiBgXCJsZWZ0XCJgLFxuICAgIGl0IHdpbGwgcmV0dXJuIHRydWUgaWYgbW92aW5nIGxlZnQgZnJvbSB0aGUgY3VycmVudCBjdXJzb3JcbiAgICBwb3NpdGlvbiB3b3VsZCBsZWF2ZSB0aGF0IHBvc2l0aW9uJ3MgcGFyZW50IHRleHRibG9jay4gV2lsbCBhcHBseVxuICAgIHRvIHRoZSB2aWV3J3MgY3VycmVudCBzdGF0ZSBieSBkZWZhdWx0LCBidXQgaXQgaXMgcG9zc2libGUgdG9cbiAgICBwYXNzIGEgZGlmZmVyZW50IHN0YXRlLlxuICAgICovXG4gICAgZW5kT2ZUZXh0YmxvY2soZGlyLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gZW5kT2ZUZXh0YmxvY2sodGhpcywgc3RhdGUgfHwgdGhpcy5zdGF0ZSwgZGlyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUnVuIHRoZSBlZGl0b3IncyBwYXN0ZSBsb2dpYyB3aXRoIHRoZSBnaXZlbiBIVE1MIHN0cmluZy4gVGhlXG4gICAgYGV2ZW50YCwgaWYgZ2l2ZW4sIHdpbGwgYmUgcGFzc2VkIHRvIHRoZVxuICAgIFtgaGFuZGxlUGFzdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5oYW5kbGVQYXN0ZSkgaG9vay5cbiAgICAqL1xuICAgIHBhc3RlSFRNTChodG1sLCBldmVudCkge1xuICAgICAgICByZXR1cm4gZG9QYXN0ZSh0aGlzLCBcIlwiLCBodG1sLCBmYWxzZSwgZXZlbnQgfHwgbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gdGhlIGVkaXRvcidzIHBhc3RlIGxvZ2ljIHdpdGggdGhlIGdpdmVuIHBsYWluLXRleHQgaW5wdXQuXG4gICAgKi9cbiAgICBwYXN0ZVRleHQodGV4dCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFzdGUodGhpcywgdGV4dCwgbnVsbCwgdHJ1ZSwgZXZlbnQgfHwgbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmVzIHRoZSBlZGl0b3IgZnJvbSB0aGUgRE9NIGFuZCBkZXN0cm95cyBhbGwgW25vZGVcbiAgICB2aWV3c10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuTm9kZVZpZXcpLlxuICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvY1ZpZXcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlc3Ryb3lJbnB1dCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXN0cm95UGx1Z2luVmlld3MoKTtcbiAgICAgICAgaWYgKHRoaXMubW91bnRlZCkge1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZSh0aGlzLnN0YXRlLmRvYywgW10sIHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRvbS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5kb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhpcyBpcyB0cnVlIHdoZW4gdGhlIHZpZXcgaGFzIGJlZW5cbiAgICBbZGVzdHJveWVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRlc3Ryb3kpIChhbmQgdGh1cyBzaG91bGQgbm90IGJlXG4gICAgdXNlZCBhbnltb3JlKS5cbiAgICAqL1xuICAgIGdldCBpc0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldyA9PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2VkIGZvciB0ZXN0aW5nLlxuICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCBldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIERpc3BhdGNoIGEgdHJhbnNhY3Rpb24uIFdpbGwgY2FsbFxuICAgIFtgZGlzcGF0Y2hUcmFuc2FjdGlvbmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRpcmVjdEVkaXRvclByb3BzLmRpc3BhdGNoVHJhbnNhY3Rpb24pXG4gICAgd2hlbiBnaXZlbiwgYW5kIG90aGVyd2lzZSBkZWZhdWx0cyB0byBhcHBseWluZyB0aGUgdHJhbnNhY3Rpb24gdG9cbiAgICB0aGUgY3VycmVudCBzdGF0ZSBhbmQgY2FsbGluZ1xuICAgIFtgdXBkYXRlU3RhdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnVwZGF0ZVN0YXRlKSB3aXRoIHRoZSByZXN1bHQuXG4gICAgVGhpcyBtZXRob2QgaXMgYm91bmQgdG8gdGhlIHZpZXcgaW5zdGFuY2UsIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgZWFzaWx5IHBhc3NlZCBhcm91bmQuXG4gICAgKi9cbiAgICBkaXNwYXRjaCh0cikge1xuICAgICAgICBsZXQgZGlzcGF0Y2hUcmFuc2FjdGlvbiA9IHRoaXMuX3Byb3BzLmRpc3BhdGNoVHJhbnNhY3Rpb247XG4gICAgICAgIGlmIChkaXNwYXRjaFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbi5jYWxsKHRoaXMsIHRyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh0aGlzLnN0YXRlLmFwcGx5KHRyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBzYWZhcmkgJiYgdGhpcy5yb290Lm5vZGVUeXBlID09PSAxMSAmJiBkZWVwQWN0aXZlRWxlbWVudCh0aGlzLmRvbS5vd25lckRvY3VtZW50KSA9PSB0aGlzLmRvbVxuICAgICAgICAgICAgPyBzYWZhcmlTaGFkb3dTZWxlY3Rpb25SYW5nZSh0aGlzKSA6IHRoaXMuZG9tU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tU2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LmdldFNlbGVjdGlvbigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVEb2NEZWNvKHZpZXcpIHtcbiAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGF0dHJzLmNsYXNzID0gXCJQcm9zZU1pcnJvclwiO1xuICAgIGF0dHJzLmNvbnRlbnRlZGl0YWJsZSA9IFN0cmluZyh2aWV3LmVkaXRhYmxlKTtcbiAgICB2aWV3LnNvbWVQcm9wKFwiYXR0cmlidXRlc1wiLCB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgZm9yIChsZXQgYXR0ciBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyID09IFwiY2xhc3NcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuY2xhc3MgKz0gXCIgXCIgKyB2YWx1ZVthdHRyXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuc3R5bGUgPSAoYXR0cnMuc3R5bGUgPyBhdHRycy5zdHlsZSArIFwiO1wiIDogXCJcIikgKyB2YWx1ZVthdHRyXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYXR0cnNbYXR0cl0gJiYgYXR0ciAhPSBcImNvbnRlbnRlZGl0YWJsZVwiICYmIGF0dHIgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgICAgICBhdHRyc1thdHRyXSA9IFN0cmluZyh2YWx1ZVthdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFhdHRycy50cmFuc2xhdGUpXG4gICAgICAgIGF0dHJzLnRyYW5zbGF0ZSA9IFwibm9cIjtcbiAgICByZXR1cm4gW0RlY29yYXRpb24ubm9kZSgwLCB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsIGF0dHJzKV07XG59XG5mdW5jdGlvbiB1cGRhdGVDdXJzb3JXcmFwcGVyKHZpZXcpIHtcbiAgICBpZiAodmlldy5tYXJrQ3Vyc29yKSB7XG4gICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcIm1hcmstcGxhY2Vob2xkZXJcIiwgXCJ0cnVlXCIpO1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiYWx0XCIsIFwiXCIpO1xuICAgICAgICB2aWV3LmN1cnNvcldyYXBwZXIgPSB7IGRvbSwgZGVjbzogRGVjb3JhdGlvbi53aWRnZXQodmlldy5zdGF0ZS5zZWxlY3Rpb24uaGVhZCwgZG9tLCB7IHJhdzogdHJ1ZSwgbWFya3M6IHZpZXcubWFya0N1cnNvciB9KSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFZGl0YWJsZSh2aWV3KSB7XG4gICAgcmV0dXJuICF2aWV3LnNvbWVQcm9wKFwiZWRpdGFibGVcIiwgdmFsdWUgPT4gdmFsdWUodmlldy5zdGF0ZSkgPT09IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkNvbnRleHRDaGFuZ2VkKHNlbDEsIHNlbDIpIHtcbiAgICBsZXQgZGVwdGggPSBNYXRoLm1pbihzZWwxLiRhbmNob3Iuc2hhcmVkRGVwdGgoc2VsMS5oZWFkKSwgc2VsMi4kYW5jaG9yLnNoYXJlZERlcHRoKHNlbDIuaGVhZCkpO1xuICAgIHJldHVybiBzZWwxLiRhbmNob3Iuc3RhcnQoZGVwdGgpICE9IHNlbDIuJGFuY2hvci5zdGFydChkZXB0aCk7XG59XG5mdW5jdGlvbiBidWlsZE5vZGVWaWV3cyh2aWV3KSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZnVuY3Rpb24gYWRkKG9iaikge1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG9iailcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgcHJvcCkpXG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgICB2aWV3LnNvbWVQcm9wKFwibm9kZVZpZXdzXCIsIGFkZCk7XG4gICAgdmlldy5zb21lUHJvcChcIm1hcmtWaWV3c1wiLCBhZGQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjaGFuZ2VkTm9kZVZpZXdzKGEsIGIpIHtcbiAgICBsZXQgbkEgPSAwLCBuQiA9IDA7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBhKSB7XG4gICAgICAgIGlmIChhW3Byb3BdICE9IGJbcHJvcF0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbkErKztcbiAgICB9XG4gICAgZm9yIChsZXQgXyBpbiBiKVxuICAgICAgICBuQisrO1xuICAgIHJldHVybiBuQSAhPSBuQjtcbn1cbmZ1bmN0aW9uIGNoZWNrU3RhdGVDb21wb25lbnQocGx1Z2luKSB7XG4gICAgaWYgKHBsdWdpbi5zcGVjLnN0YXRlIHx8IHBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uIHx8IHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBsdWdpbnMgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSB2aWV3IG11c3Qgbm90IGhhdmUgYSBzdGF0ZSBjb21wb25lbnRcIik7XG59XG5cbmV4cG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQsIEVkaXRvclZpZXcsIF9fZW5kQ29tcG9zaXRpb24sIF9fcGFyc2VGcm9tQ2xpcGJvYXJkLCBfX3NlcmlhbGl6ZUZvckNsaXBib2FyZCB9O1xuIiwgImV4cG9ydCB2YXIgYmFzZSA9IHtcbiAgODogXCJCYWNrc3BhY2VcIixcbiAgOTogXCJUYWJcIixcbiAgMTA6IFwiRW50ZXJcIixcbiAgMTI6IFwiTnVtTG9ja1wiLFxuICAxMzogXCJFbnRlclwiLFxuICAxNjogXCJTaGlmdFwiLFxuICAxNzogXCJDb250cm9sXCIsXG4gIDE4OiBcIkFsdFwiLFxuICAyMDogXCJDYXBzTG9ja1wiLFxuICAyNzogXCJFc2NhcGVcIixcbiAgMzI6IFwiIFwiLFxuICAzMzogXCJQYWdlVXBcIixcbiAgMzQ6IFwiUGFnZURvd25cIixcbiAgMzU6IFwiRW5kXCIsXG4gIDM2OiBcIkhvbWVcIixcbiAgMzc6IFwiQXJyb3dMZWZ0XCIsXG4gIDM4OiBcIkFycm93VXBcIixcbiAgMzk6IFwiQXJyb3dSaWdodFwiLFxuICA0MDogXCJBcnJvd0Rvd25cIixcbiAgNDQ6IFwiUHJpbnRTY3JlZW5cIixcbiAgNDU6IFwiSW5zZXJ0XCIsXG4gIDQ2OiBcIkRlbGV0ZVwiLFxuICA1OTogXCI7XCIsXG4gIDYxOiBcIj1cIixcbiAgOTE6IFwiTWV0YVwiLFxuICA5MjogXCJNZXRhXCIsXG4gIDEwNjogXCIqXCIsXG4gIDEwNzogXCIrXCIsXG4gIDEwODogXCIsXCIsXG4gIDEwOTogXCItXCIsXG4gIDExMDogXCIuXCIsXG4gIDExMTogXCIvXCIsXG4gIDE0NDogXCJOdW1Mb2NrXCIsXG4gIDE0NTogXCJTY3JvbGxMb2NrXCIsXG4gIDE2MDogXCJTaGlmdFwiLFxuICAxNjE6IFwiU2hpZnRcIixcbiAgMTYyOiBcIkNvbnRyb2xcIixcbiAgMTYzOiBcIkNvbnRyb2xcIixcbiAgMTY0OiBcIkFsdFwiLFxuICAxNjU6IFwiQWx0XCIsXG4gIDE3MzogXCItXCIsXG4gIDE4NjogXCI7XCIsXG4gIDE4NzogXCI9XCIsXG4gIDE4ODogXCIsXCIsXG4gIDE4OTogXCItXCIsXG4gIDE5MDogXCIuXCIsXG4gIDE5MTogXCIvXCIsXG4gIDE5MjogXCJgXCIsXG4gIDIxOTogXCJbXCIsXG4gIDIyMDogXCJcXFxcXCIsXG4gIDIyMTogXCJdXCIsXG4gIDIyMjogXCInXCJcbn1cblxuZXhwb3J0IHZhciBzaGlmdCA9IHtcbiAgNDg6IFwiKVwiLFxuICA0OTogXCIhXCIsXG4gIDUwOiBcIkBcIixcbiAgNTE6IFwiI1wiLFxuICA1MjogXCIkXCIsXG4gIDUzOiBcIiVcIixcbiAgNTQ6IFwiXlwiLFxuICA1NTogXCImXCIsXG4gIDU2OiBcIipcIixcbiAgNTc6IFwiKFwiLFxuICA1OTogXCI6XCIsXG4gIDYxOiBcIitcIixcbiAgMTczOiBcIl9cIixcbiAgMTg2OiBcIjpcIixcbiAgMTg3OiBcIitcIixcbiAgMTg4OiBcIjxcIixcbiAgMTg5OiBcIl9cIixcbiAgMTkwOiBcIj5cIixcbiAgMTkxOiBcIj9cIixcbiAgMTkyOiBcIn5cIixcbiAgMjE5OiBcIntcIixcbiAgMjIwOiBcInxcIixcbiAgMjIxOiBcIn1cIixcbiAgMjIyOiBcIlxcXCJcIlxufVxuXG52YXIgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxudmFyIGllID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9NU0lFIFxcZHxUcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVxuXG4vLyBGaWxsIGluIHRoZSBkaWdpdCBrZXlzXG5mb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIGJhc2VbNDggKyBpXSA9IGJhc2VbOTYgKyBpXSA9IFN0cmluZyhpKVxuXG4vLyBUaGUgZnVuY3Rpb24ga2V5c1xuZm9yICh2YXIgaSA9IDE7IGkgPD0gMjQ7IGkrKykgYmFzZVtpICsgMTExXSA9IFwiRlwiICsgaVxuXG4vLyBBbmQgdGhlIGFscGhhYmV0aWMga2V5c1xuZm9yICh2YXIgaSA9IDY1OyBpIDw9IDkwOyBpKyspIHtcbiAgYmFzZVtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSArIDMyKVxuICBzaGlmdFtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSlcbn1cblxuLy8gRm9yIGVhY2ggY29kZSB0aGF0IGRvZXNuJ3QgaGF2ZSBhIHNoaWZ0LWVxdWl2YWxlbnQsIGNvcHkgdGhlIGJhc2UgbmFtZVxuZm9yICh2YXIgY29kZSBpbiBiYXNlKSBpZiAoIXNoaWZ0Lmhhc093blByb3BlcnR5KGNvZGUpKSBzaGlmdFtjb2RlXSA9IGJhc2VbY29kZV1cblxuZXhwb3J0IGZ1bmN0aW9uIGtleU5hbWUoZXZlbnQpIHtcbiAgLy8gT24gbWFjT1MsIGtleXMgaGVsZCB3aXRoIFNoaWZ0IGFuZCBDbWQgZG9uJ3QgcmVmbGVjdCB0aGUgZWZmZWN0IG9mIFNoaWZ0IGluIGAua2V5YC5cbiAgLy8gT24gSUUsIHNoaWZ0IGVmZmVjdCBpcyBuZXZlciBpbmNsdWRlZCBpbiBgLmtleWAuXG4gIHZhciBpZ25vcmVLZXkgPSBtYWMgJiYgZXZlbnQubWV0YUtleSAmJiBldmVudC5zaGlmdEtleSAmJiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5IHx8XG4gICAgICBpZSAmJiBldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXkgJiYgZXZlbnQua2V5Lmxlbmd0aCA9PSAxIHx8XG4gICAgICBldmVudC5rZXkgPT0gXCJVbmlkZW50aWZpZWRcIlxuICB2YXIgbmFtZSA9ICghaWdub3JlS2V5ICYmIGV2ZW50LmtleSkgfHxcbiAgICAoZXZlbnQuc2hpZnRLZXkgPyBzaGlmdCA6IGJhc2UpW2V2ZW50LmtleUNvZGVdIHx8XG4gICAgZXZlbnQua2V5IHx8IFwiVW5pZGVudGlmaWVkXCJcbiAgLy8gRWRnZSBzb21ldGltZXMgcHJvZHVjZXMgd3JvbmcgbmFtZXMgKElzc3VlICMzKVxuICBpZiAobmFtZSA9PSBcIkVzY1wiKSBuYW1lID0gXCJFc2NhcGVcIlxuICBpZiAobmFtZSA9PSBcIkRlbFwiKSBuYW1lID0gXCJEZWxldGVcIlxuICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy84ODYwNTcxL1xuICBpZiAobmFtZSA9PSBcIkxlZnRcIikgbmFtZSA9IFwiQXJyb3dMZWZ0XCJcbiAgaWYgKG5hbWUgPT0gXCJVcFwiKSBuYW1lID0gXCJBcnJvd1VwXCJcbiAgaWYgKG5hbWUgPT0gXCJSaWdodFwiKSBuYW1lID0gXCJBcnJvd1JpZ2h0XCJcbiAgaWYgKG5hbWUgPT0gXCJEb3duXCIpIG5hbWUgPSBcIkFycm93RG93blwiXG4gIHJldHVybiBuYW1lXG59XG4iLCAiaW1wb3J0IHsga2V5TmFtZSwgYmFzZSB9IGZyb20gJ3czYy1rZXluYW1lJztcbmltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuY29uc3QgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gL01hY3xpUChob25lfFtvYV1kKS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pIDogZmFsc2U7XG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUpIHtcbiAgICBsZXQgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKSwgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHJlc3VsdCA9PSBcIlNwYWNlXCIpXG4gICAgICAgIHJlc3VsdCA9IFwiIFwiO1xuICAgIGxldCBhbHQsIGN0cmwsIHNoaWZ0LCBtZXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGxldCBtb2QgPSBwYXJ0c1tpXTtcbiAgICAgICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBhbHQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgc2hpZnQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIGlmIChtYWMpXG4gICAgICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgbW9kKTtcbiAgICB9XG4gICAgaWYgKGFsdClcbiAgICAgICAgcmVzdWx0ID0gXCJBbHQtXCIgKyByZXN1bHQ7XG4gICAgaWYgKGN0cmwpXG4gICAgICAgIHJlc3VsdCA9IFwiQ3RybC1cIiArIHJlc3VsdDtcbiAgICBpZiAobWV0YSlcbiAgICAgICAgcmVzdWx0ID0gXCJNZXRhLVwiICsgcmVzdWx0O1xuICAgIGlmIChzaGlmdClcbiAgICAgICAgcmVzdWx0ID0gXCJTaGlmdC1cIiArIHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKG1hcCkge1xuICAgIGxldCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBwcm9wIGluIG1hcClcbiAgICAgICAgY29weVtub3JtYWxpemVLZXlOYW1lKHByb3ApXSA9IG1hcFtwcm9wXTtcbiAgICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uIG1vZGlmaWVycyhuYW1lLCBldmVudCwgc2hpZnQgPSB0cnVlKSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSlcbiAgICAgICAgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAgbmFtZSA9IFwiQ3RybC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIG5hbWUgPSBcIk1ldGEtXCIgKyBuYW1lO1xuICAgIGlmIChzaGlmdCAmJiBldmVudC5zaGlmdEtleSlcbiAgICAgICAgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lO1xuICAgIHJldHVybiBuYW1lO1xufVxuLyoqXG5DcmVhdGUgYSBrZXltYXAgcGx1Z2luIGZvciB0aGUgZ2l2ZW4gc2V0IG9mIGJpbmRpbmdzLlxuXG5CaW5kaW5ncyBzaG91bGQgbWFwIGtleSBuYW1lcyB0byBbY29tbWFuZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzKS1zdHlsZVxuZnVuY3Rpb25zLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIGAoRWRpdG9yU3RhdGUsIGRpc3BhdGNoLFxuRWRpdG9yVmlldylgIGFyZ3VtZW50cywgYW5kIHNob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHRoZXkndmUgaGFuZGxlZFxudGhlIGtleS4gTm90ZSB0aGF0IHRoZSB2aWV3IGFyZ3VtZW50IGlzbid0IHBhcnQgb2YgdGhlIGNvbW1hbmRcbnByb3RvY29sLCBidXQgY2FuIGJlIHVzZWQgYXMgYW4gZXNjYXBlIGhhdGNoIGlmIGEgYmluZGluZyBuZWVkcyB0b1xuZGlyZWN0bHkgaW50ZXJhY3Qgd2l0aCB0aGUgVUkuXG5cbktleSBuYW1lcyBtYXkgYmUgc3RyaW5ncyBsaWtlIGBcIlNoaWZ0LUN0cmwtRW50ZXJcImBcdTIwMTRhIGtleVxuaWRlbnRpZmllciBwcmVmaXhlZCB3aXRoIHplcm8gb3IgbW9yZSBtb2RpZmllcnMuIEtleSBpZGVudGlmaWVyc1xuYXJlIGJhc2VkIG9uIHRoZSBzdHJpbmdzIHRoYXQgY2FuIGFwcGVhciBpblxuW2BLZXlFdmVudC5rZXlgXShodHRwczpkZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5KS5cblVzZSBsb3dlcmNhc2UgbGV0dGVycyB0byByZWZlciB0byBsZXR0ZXIga2V5cyAob3IgdXBwZXJjYXNlIGxldHRlcnNcbmlmIHlvdSB3YW50IHNoaWZ0IHRvIGJlIGhlbGQpLiBZb3UgbWF5IHVzZSBgXCJTcGFjZVwiYCBhcyBhbiBhbGlhc1xuZm9yIHRoZSBgXCIgXCJgIG5hbWUuXG5cbk1vZGlmaWVycyBjYW4gYmUgZ2l2ZW4gaW4gYW55IG9yZGVyLiBgU2hpZnQtYCAob3IgYHMtYCksIGBBbHQtYCAob3JcbmBhLWApLCBgQ3RybC1gIChvciBgYy1gIG9yIGBDb250cm9sLWApIGFuZCBgQ21kLWAgKG9yIGBtLWAgb3JcbmBNZXRhLWApIGFyZSByZWNvZ25pemVkLiBGb3IgY2hhcmFjdGVycyB0aGF0IGFyZSBjcmVhdGVkIGJ5IGhvbGRpbmdcbnNoaWZ0LCB0aGUgYFNoaWZ0LWAgcHJlZml4IGlzIGltcGxpZWQsIGFuZCBzaG91bGQgbm90IGJlIGFkZGVkXG5leHBsaWNpdGx5LlxuXG5Zb3UgY2FuIHVzZSBgTW9kLWAgYXMgYSBzaG9ydGhhbmQgZm9yIGBDbWQtYCBvbiBNYWMgYW5kIGBDdHJsLWAgb25cbm90aGVyIHBsYXRmb3Jtcy5cblxuWW91IGNhbiBhZGQgbXVsdGlwbGUga2V5bWFwIHBsdWdpbnMgdG8gYW4gZWRpdG9yLiBUaGUgb3JkZXIgaW5cbndoaWNoIHRoZXkgYXBwZWFyIGRldGVybWluZXMgdGhlaXIgcHJlY2VkZW5jZSAodGhlIG9uZXMgZWFybHkgaW5cbnRoZSBhcnJheSBnZXQgdG8gZGlzcGF0Y2ggZmlyc3QpLlxuKi9cbmZ1bmN0aW9uIGtleW1hcChiaW5kaW5ncykge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHsgcHJvcHM6IHsgaGFuZGxlS2V5RG93bjoga2V5ZG93bkhhbmRsZXIoYmluZGluZ3MpIH0gfSk7XG59XG4vKipcbkdpdmVuIGEgc2V0IG9mIGJpbmRpbmdzICh1c2luZyB0aGUgc2FtZSBmb3JtYXQgYXNcbltga2V5bWFwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2tleW1hcC5rZXltYXApKSwgcmV0dXJuIGEgW2tleWRvd25cbmhhbmRsZXJdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzLmhhbmRsZUtleURvd24pIHRoYXQgaGFuZGxlcyB0aGVtLlxuKi9cbmZ1bmN0aW9uIGtleWRvd25IYW5kbGVyKGJpbmRpbmdzKSB7XG4gICAgbGV0IG1hcCA9IG5vcm1hbGl6ZShiaW5kaW5ncyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2aWV3LCBldmVudCkge1xuICAgICAgICBsZXQgbmFtZSA9IGtleU5hbWUoZXZlbnQpLCBiYXNlTmFtZSwgZGlyZWN0ID0gbWFwW21vZGlmaWVycyhuYW1lLCBldmVudCldO1xuICAgICAgICBpZiAoZGlyZWN0ICYmIGRpcmVjdCh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBBIGNoYXJhY3RlciBrZXlcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09IDEgJiYgbmFtZSAhPSBcIiBcIikge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGUgbmFtZSB3YXMgYWxyZWFkeSBtb2RpZmllZCBieSBzaGlmdCwgdHJ5IGxvb2tpbmdcbiAgICAgICAgICAgICAgICAvLyBpdCB1cCB3aXRob3V0IGl0cyBzaGlmdCBtb2RpZmllclxuICAgICAgICAgICAgICAgIGxldCBub1NoaWZ0ID0gbWFwW21vZGlmaWVycyhuYW1lLCBldmVudCwgZmFsc2UpXTtcbiAgICAgICAgICAgICAgICBpZiAobm9TaGlmdCAmJiBub1NoaWZ0KHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgbmFtZS5jaGFyQ29kZUF0KDApID4gMTI3KSAmJlxuICAgICAgICAgICAgICAgIChiYXNlTmFtZSA9IGJhc2VbZXZlbnQua2V5Q29kZV0pICYmIGJhc2VOYW1lICE9IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgZmFsbGluZyBiYWNrIHRvIHRoZSBrZXlDb2RlIHdoZW4gdGhlcmUncyBhIG1vZGlmaWVyXG4gICAgICAgICAgICAgICAgLy8gYWN0aXZlIG9yIHRoZSBjaGFyYWN0ZXIgcHJvZHVjZWQgaXNuJ3QgQVNDSUksIGFuZCBvdXIgdGFibGVcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWNlcyBhIGRpZmZlcmVudCBuYW1lIGZyb20gdGhlIHRoZSBrZXlDb2RlLiBTZWUgIzY2OCxcbiAgICAgICAgICAgICAgICAvLyAjMTA2MFxuICAgICAgICAgICAgICAgIGxldCBmcm9tQ29kZSA9IG1hcFttb2RpZmllcnMoYmFzZU5hbWUsIGV2ZW50KV07XG4gICAgICAgICAgICAgICAgaWYgKGZyb21Db2RlICYmIGZyb21Db2RlKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsga2V5ZG93bkhhbmRsZXIsIGtleW1hcCB9O1xuIiwgImltcG9ydCB7IGxpZnRUYXJnZXQsIHJlcGxhY2VTdGVwLCBSZXBsYWNlU3RlcCwgY2FuSm9pbiwgam9pblBvaW50LCBjYW5TcGxpdCwgUmVwbGFjZUFyb3VuZFN0ZXAsIGZpbmRXcmFwcGluZyB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBTbGljZSwgRnJhZ21lbnQgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uLCBTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24sIEFsbFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgaWYgdGhlcmUgaXMgb25lLlxuKi9cbmNvbnN0IGRlbGV0ZVNlbGVjdGlvbiA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpIHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSlcbiAgICAgICAgOiAkY3Vyc29yLnBhcmVudE9mZnNldCA+IDApKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gJGN1cnNvcjtcbn1cbi8qKlxuSWYgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLCB0cnkgdG9cbnJlZHVjZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGJsb2NrIGFuZCB0aGUgb25lIGJlZm9yZSBpdFx1MjAxNGlmXG50aGVyZSdzIGEgYmxvY2sgZGlyZWN0bHkgYmVmb3JlIGl0IHRoYXQgY2FuIGJlIGpvaW5lZCwgam9pbiB0aGVtLlxuSWYgbm90LCB0cnkgdG8gbW92ZSB0aGUgc2VsZWN0ZWQgYmxvY2sgY2xvc2VyIHRvIHRoZSBuZXh0IG9uZSBpblxudGhlIGRvY3VtZW50IHN0cnVjdHVyZSBieSBsaWZ0aW5nIGl0IG91dCBvZiBpdHMgcGFyZW50IG9yIG1vdmluZyBpdFxuaW50byBhIHBhcmVudCBvZiB0aGUgcHJldmlvdXMgYmxvY2suIFdpbGwgdXNlIHRoZSB2aWV3IGZvciBhY2N1cmF0ZVxuKGJpZGktYXdhcmUpIHN0YXJ0LW9mLXRleHRibG9jayBkZXRlY3Rpb24gaWYgZ2l2ZW4uXG4qL1xuY29uc3Qgam9pbkJhY2t3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja1N0YXJ0KHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGN1cnNvcik7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUgdGhpcywgdHJ5IHRvIGxpZnRcbiAgICBpZiAoISRjdXQpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gJGN1cnNvci5ibG9ja1JhbmdlKCksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlO1xuICAgIC8vIEFwcGx5IHRoZSBqb2luaW5nIGFsZ29yaXRobVxuICAgIGlmICghYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcgJiYgZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBJZiB0aGUgbm9kZSBiZWxvdyBoYXMgbm8gY29udGVudCBhbmQgdGhlIG5vZGUgYWJvdmUgaXNcbiAgICAvLyBzZWxlY3RhYmxlLCBkZWxldGUgdGhlIG5vZGUgYmVsb3cgYW5kIHNlbGVjdCB0aGUgb25lIGFib3ZlLlxuICAgIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJlxuICAgICAgICAodGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSB8fCBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShiZWZvcmUpKSkge1xuICAgICAgICBsZXQgZGVsU3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgJGN1cnNvci5iZWZvcmUoKSwgJGN1cnNvci5hZnRlcigpLCBTbGljZS5lbXB0eSk7XG4gICAgICAgIGlmIChkZWxTdGVwICYmIGRlbFN0ZXAuc2xpY2Uuc2l6ZSA8IGRlbFN0ZXAudG8gLSBkZWxTdGVwLmZyb20pIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoZGVsU3RlcCk7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikgPyBTZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MsIC0xKSksIC0xKVxuICAgICAgICAgICAgICAgICAgICA6IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJGN1dC5wb3MgLSBiZWZvcmUubm9kZVNpemUpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBub2RlIGJlZm9yZSBpcyBhbiBhdG9tLCBkZWxldGUgaXRcbiAgICBpZiAoYmVmb3JlLmlzQXRvbSAmJiAkY3V0LmRlcHRoID09ICRjdXJzb3IuZGVwdGggLSAxKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSwgJGN1dC5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuQSBtb3JlIGxpbWl0ZWQgZm9ybSBvZiBbYGpvaW5CYWNrd2FyZGBdKCRjb21tYW5kcy5qb2luQmFja3dhcmQpXG50aGF0IG9ubHkgdHJpZXMgdG8gam9pbiB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gdGhlIG9uZSBiZWZvcmVcbml0LCBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jay5cbiovXG5jb25zdCBqb2luVGV4dGJsb2NrQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEJlZm9yZSgkY3Vyc29yKTtcbiAgICByZXR1cm4gJGN1dCA/IGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkgOiBmYWxzZTtcbn07XG4vKipcbkEgbW9yZSBsaW1pdGVkIGZvcm0gb2YgW2Bqb2luRm9yd2FyZGBdKCRjb21tYW5kcy5qb2luRm9yd2FyZClcbnRoYXQgb25seSB0cmllcyB0byBqb2luIHRoZSBjdXJyZW50IHRleHRibG9jayB0byB0aGUgb25lIGFmdGVyXG5pdCwgaWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrLlxuKi9cbmNvbnN0IGpvaW5UZXh0YmxvY2tGb3J3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja0VuZChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGN1cnNvcik7XG4gICAgcmV0dXJuICRjdXQgPyBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZSwgYmVmb3JlVGV4dCA9IGJlZm9yZSwgYmVmb3JlUG9zID0gJGN1dC5wb3MgLSAxO1xuICAgIGZvciAoOyAhYmVmb3JlVGV4dC5pc1RleHRibG9jazsgYmVmb3JlUG9zLS0pIHtcbiAgICAgICAgaWYgKGJlZm9yZVRleHQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gYmVmb3JlVGV4dC5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGJlZm9yZVRleHQgPSBjaGlsZDtcbiAgICB9XG4gICAgbGV0IGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXIsIGFmdGVyVGV4dCA9IGFmdGVyLCBhZnRlclBvcyA9ICRjdXQucG9zICsgMTtcbiAgICBmb3IgKDsgIWFmdGVyVGV4dC5pc1RleHRibG9jazsgYWZ0ZXJQb3MrKykge1xuICAgICAgICBpZiAoYWZ0ZXJUZXh0LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjaGlsZCA9IGFmdGVyVGV4dC5maXJzdENoaWxkO1xuICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBhZnRlclRleHQgPSBjaGlsZDtcbiAgICB9XG4gICAgbGV0IHN0ZXAgPSByZXBsYWNlU3RlcChzdGF0ZS5kb2MsIGJlZm9yZVBvcywgYWZ0ZXJQb3MsIFNsaWNlLmVtcHR5KTtcbiAgICBpZiAoIXN0ZXAgfHwgc3RlcC5mcm9tICE9IGJlZm9yZVBvcyB8fFxuICAgICAgICBzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgJiYgc3RlcC5zbGljZS5zaXplID49IGFmdGVyUG9zIC0gYmVmb3JlUG9zKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoc3RlcCk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIGJlZm9yZVBvcykpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0ZXh0YmxvY2tBdChub2RlLCBzaWRlLCBvbmx5ID0gZmFsc2UpIHtcbiAgICBmb3IgKGxldCBzY2FuID0gbm9kZTsgc2Nhbjsgc2NhbiA9IChzaWRlID09IFwic3RhcnRcIiA/IHNjYW4uZmlyc3RDaGlsZCA6IHNjYW4ubGFzdENoaWxkKSkge1xuICAgICAgICBpZiAoc2Nhbi5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob25seSAmJiBzY2FuLmNoaWxkQ291bnQgIT0gMSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG5XaGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jaywgc2VsZWN0XG50aGUgbm9kZSBiZWZvcmUgdGhhdCB0ZXh0YmxvY2ssIGlmIHBvc3NpYmxlLiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG5ib3VuZCB0byBrZXlzIGxpa2UgYmFja3NwYWNlLCBhZnRlclxuW2Bqb2luQmFja3dhcmRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuam9pbkJhY2t3YXJkKSBvciBvdGhlciBkZWxldGluZ1xuY29tbWFuZHMsIGFzIGEgZmFsbC1iYWNrIGJlaGF2aW9yIHdoZW4gdGhlIHNjaGVtYSBkb2Vzbid0IGFsbG93XG5kZWxldGlvbiBhdCB0aGUgc2VsZWN0ZWQgcG9pbnQuXG4qL1xuY29uc3Qgc2VsZWN0Tm9kZUJhY2t3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCB7ICRoZWFkLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uLCAkY3V0ID0gJGhlYWQ7XG4gICAgaWYgKCFlbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgaWYgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImJhY2t3YXJkXCIsIHN0YXRlKSA6ICRoZWFkLnBhcmVudE9mZnNldCA+IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRoZWFkKTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSAkY3V0ICYmICRjdXQubm9kZUJlZm9yZTtcbiAgICBpZiAoIW5vZGUgfHwgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCAkY3V0LnBvcyAtIG5vZGUubm9kZVNpemUpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBmaW5kQ3V0QmVmb3JlKCRwb3MpIHtcbiAgICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICgkcG9zLmluZGV4KGkpID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZSgkcG9zLmJlZm9yZShpICsgMSkpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShpKS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KSB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiZm9yd2FyZFwiLCBzdGF0ZSlcbiAgICAgICAgOiAkY3Vyc29yLnBhcmVudE9mZnNldCA8ICRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAkY3Vyc29yO1xufVxuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYVxudGV4dGJsb2NrLCB0cnkgdG8gcmVkdWNlIG9yIHJlbW92ZSB0aGUgYm91bmRhcnkgYmV0d2VlbiB0aGF0IGJsb2NrXG5hbmQgdGhlIG9uZSBhZnRlciBpdCwgZWl0aGVyIGJ5IGpvaW5pbmcgdGhlbSBvciBieSBtb3ZpbmcgdGhlIG90aGVyXG5ibG9jayBjbG9zZXIgdG8gdGhpcyBvbmUgaW4gdGhlIHRyZWUgc3RydWN0dXJlLiBXaWxsIHVzZSB0aGUgdmlld1xuZm9yIGFjY3VyYXRlIHN0YXJ0LW9mLXRleHRibG9jayBkZXRlY3Rpb24gaWYgZ2l2ZW4uXG4qL1xuY29uc3Qgam9pbkZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRBZnRlcigkY3Vyc29yKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBub2RlIGFmdGVyIHRoaXMsIHRoZXJlJ3Mgbm90aGluZyB0byBkb1xuICAgIGlmICghJGN1dClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhZnRlciA9ICRjdXQubm9kZUFmdGVyO1xuICAgIC8vIFRyeSB0aGUgam9pbmluZyBhbGdvcml0aG1cbiAgICBpZiAoZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBJZiB0aGUgbm9kZSBhYm92ZSBoYXMgbm8gY29udGVudCBhbmQgdGhlIG5vZGUgYmVsb3cgaXNcbiAgICAvLyBzZWxlY3RhYmxlLCBkZWxldGUgdGhlIG5vZGUgYWJvdmUgYW5kIHNlbGVjdCB0aGUgb25lIGJlbG93LlxuICAgIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJlxuICAgICAgICAodGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIikgfHwgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoYWZ0ZXIpKSkge1xuICAgICAgICBsZXQgZGVsU3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgJGN1cnNvci5iZWZvcmUoKSwgJGN1cnNvci5hZnRlcigpLCBTbGljZS5lbXB0eSk7XG4gICAgICAgIGlmIChkZWxTdGVwICYmIGRlbFN0ZXAuc2xpY2Uuc2l6ZSA8IGRlbFN0ZXAudG8gLSBkZWxTdGVwLmZyb20pIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoZGVsU3RlcCk7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIpID8gU2VsZWN0aW9uLmZpbmRGcm9tKHRyLmRvYy5yZXNvbHZlKHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSksIDEpXG4gICAgICAgICAgICAgICAgICAgIDogTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcykpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgYW4gYXRvbSwgZGVsZXRlIGl0XG4gICAgaWYgKGFmdGVyLmlzQXRvbSAmJiAkY3V0LmRlcHRoID09ICRjdXJzb3IuZGVwdGggLSAxKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkY3V0LnBvcywgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5XaGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2ssIHNlbGVjdFxudGhlIG5vZGUgY29taW5nIGFmdGVyIHRoYXQgdGV4dGJsb2NrLCBpZiBwb3NzaWJsZS4gVGhpcyBpcyBpbnRlbmRlZFxudG8gYmUgYm91bmQgdG8ga2V5cyBsaWtlIGRlbGV0ZSwgYWZ0ZXJcbltgam9pbkZvcndhcmRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuam9pbkZvcndhcmQpIGFuZCBzaW1pbGFyIGRlbGV0aW5nXG5jb21tYW5kcywgdG8gcHJvdmlkZSBhIGZhbGwtYmFjayBiZWhhdmlvciB3aGVuIHRoZSBzY2hlbWEgZG9lc24ndFxuYWxsb3cgZGVsZXRpb24gYXQgdGhlIHNlbGVjdGVkIHBvaW50LlxuKi9cbmNvbnN0IHNlbGVjdE5vZGVGb3J3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCB7ICRoZWFkLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uLCAkY3V0ID0gJGhlYWQ7XG4gICAgaWYgKCFlbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgaWYgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImZvcndhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0IDwgJGhlYWQucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgJGN1dCA9IGZpbmRDdXRBZnRlcigkaGVhZCk7XG4gICAgfVxuICAgIGxldCBub2RlID0gJGN1dCAmJiAkY3V0Lm5vZGVBZnRlcjtcbiAgICBpZiAoIW5vZGUgfHwgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCAkY3V0LnBvcykpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGZpbmRDdXRBZnRlcigkcG9zKSB7XG4gICAgaWYgKCEkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5ub2RlKGkpO1xuICAgICAgICAgICAgaWYgKCRwb3MuaW5kZXgoaSkgKyAxIDwgcGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUoJHBvcy5hZnRlcihpICsgMSkpO1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbkpvaW4gdGhlIHNlbGVjdGVkIGJsb2NrIG9yLCBpZiB0aGVyZSBpcyBhIHRleHQgc2VsZWN0aW9uLCB0aGVcbmNsb3Nlc3QgYW5jZXN0b3IgYmxvY2sgb2YgdGhlIHNlbGVjdGlvbiB0aGF0IGNhbiBiZSBqb2luZWQsIHdpdGhcbnRoZSBzaWJsaW5nIGFib3ZlIGl0LlxuKi9cbmNvbnN0IGpvaW5VcCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCBub2RlU2VsID0gc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiwgcG9pbnQ7XG4gICAgaWYgKG5vZGVTZWwpIHtcbiAgICAgICAgaWYgKHNlbC5ub2RlLmlzVGV4dGJsb2NrIHx8ICFjYW5Kb2luKHN0YXRlLmRvYywgc2VsLmZyb20pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwb2ludCA9IHNlbC5mcm9tO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwuZnJvbSwgLTEpO1xuICAgICAgICBpZiAocG9pbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLmpvaW4ocG9pbnQpO1xuICAgICAgICBpZiAobm9kZVNlbClcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHBvaW50IC0gc3RhdGUuZG9jLnJlc29sdmUocG9pbnQpLm5vZGVCZWZvcmUubm9kZVNpemUpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSm9pbiB0aGUgc2VsZWN0ZWQgYmxvY2ssIG9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIG9mIHRoZSBzZWxlY3Rpb25cbnRoYXQgY2FuIGJlIGpvaW5lZCwgd2l0aCB0aGUgc2libGluZyBhZnRlciBpdC5cbiovXG5jb25zdCBqb2luRG93biA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCBwb2ludDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIWNhbkpvaW4oc3RhdGUuZG9jLCBzZWwudG8pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwb2ludCA9IHNlbC50bztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc2VsLnRvLCAxKTtcbiAgICAgICAgaWYgKHBvaW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuam9pbihwb2ludCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5MaWZ0IHRoZSBzZWxlY3RlZCBibG9jaywgb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgYmxvY2sgb2YgdGhlXG5zZWxlY3Rpb24gdGhhdCBjYW4gYmUgbGlmdGVkLCBvdXQgb2YgaXRzIHBhcmVudCBub2RlLlxuKi9cbmNvbnN0IGxpZnQgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgdGhlIHNlbGVjdGlvbiBpcyBpbiBhIG5vZGUgd2hvc2UgdHlwZSBoYXMgYSB0cnV0aHlcbltgY29kZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5jb2RlKSBwcm9wZXJ0eSBpbiBpdHMgc3BlYywgcmVwbGFjZSB0aGVcbnNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZSBjaGFyYWN0ZXIuXG4qL1xuY29uc3QgbmV3bGluZUluQ29kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5pbnNlcnRUZXh0KFwiXFxuXCIpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGRlZmF1bHRCbG9ja0F0KG1hdGNoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgeyB0eXBlIH0gPSBtYXRjaC5lZGdlKGkpO1xuICAgICAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpXG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBpbiBhIG5vZGUgd2l0aCBhIHRydXRoeVxuW2Bjb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCBjcmVhdGUgYVxuZGVmYXVsdCBibG9jayBhZnRlciB0aGUgY29kZSBibG9jaywgYW5kIG1vdmUgdGhlIGN1cnNvciB0aGVyZS5cbiovXG5jb25zdCBleGl0Q29kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFib3ZlID0gJGhlYWQubm9kZSgtMSksIGFmdGVyID0gJGhlYWQuaW5kZXhBZnRlcigtMSksIHR5cGUgPSBkZWZhdWx0QmxvY2tBdChhYm92ZS5jb250ZW50TWF0Y2hBdChhZnRlcikpO1xuICAgIGlmICghdHlwZSB8fCAhYWJvdmUuY2FuUmVwbGFjZVdpdGgoYWZ0ZXIsIGFmdGVyLCB0eXBlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgcG9zID0gJGhlYWQuYWZ0ZXIoKSwgdHIgPSBzdGF0ZS50ci5yZXBsYWNlV2l0aChwb3MsIHBvcywgdHlwZS5jcmVhdGVBbmRGaWxsKCkpO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUocG9zKSwgMSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiBhIGJsb2NrIG5vZGUgaXMgc2VsZWN0ZWQsIGNyZWF0ZSBhbiBlbXB0eSBwYXJhZ3JhcGggYmVmb3JlIChpZlxuaXQgaXMgaXRzIHBhcmVudCdzIGZpcnN0IGNoaWxkKSBvciBhZnRlciBpdC5cbiovXG5jb25zdCBjcmVhdGVQYXJhZ3JhcGhOZWFyID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIHsgJGZyb20sICR0byB9ID0gc2VsO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24gfHwgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgfHwgJHRvLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHR5cGUgPSBkZWZhdWx0QmxvY2tBdCgkdG8ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCR0by5pbmRleEFmdGVyKCkpKTtcbiAgICBpZiAoIXR5cGUgfHwgIXR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHNpZGUgPSAoISRmcm9tLnBhcmVudE9mZnNldCAmJiAkdG8uaW5kZXgoKSA8ICR0by5wYXJlbnQuY2hpbGRDb3VudCA/ICRmcm9tIDogJHRvKS5wb3M7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLmluc2VydChzaWRlLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHNpZGUgKyAxKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIHRoZSBjdXJzb3IgaXMgaW4gYW4gZW1wdHkgdGV4dGJsb2NrIHRoYXQgY2FuIGJlIGxpZnRlZCwgbGlmdCB0aGVcbmJsb2NrLlxuKi9cbmNvbnN0IGxpZnRFbXB0eUJsb2NrID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRjdXJzb3IuZGVwdGggPiAxICYmICRjdXJzb3IuYWZ0ZXIoKSAhPSAkY3Vyc29yLmVuZCgtMSkpIHtcbiAgICAgICAgbGV0IGJlZm9yZSA9ICRjdXJzb3IuYmVmb3JlKCk7XG4gICAgICAgIGlmIChjYW5TcGxpdChzdGF0ZS5kb2MsIGJlZm9yZSkpIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zcGxpdChiZWZvcmUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJhbmdlID0gJGN1cnNvci5ibG9ja1JhbmdlKCksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNyZWF0ZSBhIHZhcmlhbnQgb2YgW2BzcGxpdEJsb2NrYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLnNwbGl0QmxvY2spIHRoYXQgdXNlc1xuYSBjdXN0b20gZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIHRoZSBuZXdseSBzcGxpdCBvZmYgYmxvY2suXG4qL1xuZnVuY3Rpb24gc3BsaXRCbG9ja0FzKHNwbGl0Tm9kZSkge1xuICAgIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc3RhdGUuc2VsZWN0aW9uLm5vZGUuaXNCbG9jaykge1xuICAgICAgICAgICAgaWYgKCEkZnJvbS5wYXJlbnRPZmZzZXQgfHwgIWNhblNwbGl0KHN0YXRlLmRvYywgJGZyb20ucG9zKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJGZyb20ucGFyZW50LmlzQmxvY2spXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IGF0RW5kID0gJHRvLnBhcmVudE9mZnNldCA9PSAkdG8ucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gfHwgc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgbGV0IGRlZmx0ID0gJGZyb20uZGVwdGggPT0gMCA/IG51bGwgOiBkZWZhdWx0QmxvY2tBdCgkZnJvbS5ub2RlKC0xKS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKC0xKSkpO1xuICAgICAgICAgICAgbGV0IHNwbGl0VHlwZSA9IHNwbGl0Tm9kZSAmJiBzcGxpdE5vZGUoJHRvLnBhcmVudCwgYXRFbmQpO1xuICAgICAgICAgICAgbGV0IHR5cGVzID0gc3BsaXRUeXBlID8gW3NwbGl0VHlwZV0gOiBhdEVuZCAmJiBkZWZsdCA/IFt7IHR5cGU6IGRlZmx0IH1dIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGNhbiA9IGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xuICAgICAgICAgICAgaWYgKCF0eXBlcyAmJiAhY2FuICYmIGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgZGVmbHQgPyBbeyB0eXBlOiBkZWZsdCB9XSA6IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmbHQpXG4gICAgICAgICAgICAgICAgICAgIHR5cGVzID0gW3sgdHlwZTogZGVmbHQgfV07XG4gICAgICAgICAgICAgICAgY2FuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW4pIHtcbiAgICAgICAgICAgICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFhdEVuZCAmJiAhJGZyb20ucGFyZW50T2Zmc2V0ICYmICRmcm9tLnBhcmVudC50eXBlICE9IGRlZmx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgJGZpcnN0ID0gdHIuZG9jLnJlc29sdmUoZmlyc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmbHQgJiYgJGZyb20ubm9kZSgtMSkuY2FuUmVwbGFjZVdpdGgoJGZpcnN0LmluZGV4KCksICRmaXJzdC5pbmRleCgpICsgMSwgZGVmbHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksIGRlZmx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5TcGxpdCB0aGUgcGFyZW50IGJsb2NrIG9mIHRoZSBzZWxlY3Rpb24uIElmIHRoZSBzZWxlY3Rpb24gaXMgYSB0ZXh0XG5zZWxlY3Rpb24sIGFsc28gZGVsZXRlIGl0cyBjb250ZW50LlxuKi9cbmNvbnN0IHNwbGl0QmxvY2sgPSBzcGxpdEJsb2NrQXMoKTtcbi8qKlxuQWN0cyBsaWtlIFtgc3BsaXRCbG9ja2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdEJsb2NrKSwgYnV0IHdpdGhvdXRcbnJlc2V0dGluZyB0aGUgc2V0IG9mIGFjdGl2ZSBtYXJrcyBhdCB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IHNwbGl0QmxvY2tLZWVwTWFya3MgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgcmV0dXJuIHNwbGl0QmxvY2soc3RhdGUsIGRpc3BhdGNoICYmICh0ciA9PiB7XG4gICAgICAgIGxldCBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgICAgIGlmIChtYXJrcylcbiAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH0pKTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbm9kZSB3cmFwcGluZyB0aGUgY3VycmVudCBzZWxlY3Rpb24sIGlmXG5hbnkuIChXaWxsIG5vdCBzZWxlY3QgdGhlIGRvY3VtZW50IG5vZGUuKVxuKi9cbmNvbnN0IHNlbGVjdFBhcmVudE5vZGUgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb24sIHBvcztcbiAgICBsZXQgc2FtZSA9ICRmcm9tLnNoYXJlZERlcHRoKHRvKTtcbiAgICBpZiAoc2FtZSA9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcG9zID0gJGZyb20uYmVmb3JlKHNhbWUpO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgcG9zKSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2VsZWN0IHRoZSB3aG9sZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3RBbGwgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEFsbFNlbGVjdGlvbihzdGF0ZS5kb2MpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gam9pbk1heWJlQ2xlYXIoc3RhdGUsICRwb3MsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlciwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgaWYgKCFiZWZvcmUgfHwgIWFmdGVyIHx8ICFiZWZvcmUudHlwZS5jb21wYXRpYmxlQ29udGVudChhZnRlci50eXBlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghYmVmb3JlLmNvbnRlbnQuc2l6ZSAmJiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4IC0gMSwgaW5kZXgpKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkcG9zLnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSwgJHBvcy5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCEkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpIHx8ICEoYWZ0ZXIuaXNUZXh0YmxvY2sgfHwgY2FuSm9pbihzdGF0ZS5kb2MsICRwb3MucG9zKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyXG4gICAgICAgICAgICAuY2xlYXJJbmNvbXBhdGlibGUoJHBvcy5wb3MsIGJlZm9yZS50eXBlLCBiZWZvcmUuY29udGVudE1hdGNoQXQoYmVmb3JlLmNoaWxkQ291bnQpKVxuICAgICAgICAgICAgLmpvaW4oJHBvcy5wb3MpXG4gICAgICAgICAgICAuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkge1xuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmUsIGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXIsIGNvbm4sIG1hdGNoO1xuICAgIGlmIChiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZyB8fCBhZnRlci50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGpvaW5NYXliZUNsZWFyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBjYW5EZWxBZnRlciA9ICRjdXQucGFyZW50LmNhblJlcGxhY2UoJGN1dC5pbmRleCgpLCAkY3V0LmluZGV4KCkgKyAxKTtcbiAgICBpZiAoY2FuRGVsQWZ0ZXIgJiZcbiAgICAgICAgKGNvbm4gPSAobWF0Y2ggPSBiZWZvcmUuY29udGVudE1hdGNoQXQoYmVmb3JlLmNoaWxkQ291bnQpKS5maW5kV3JhcHBpbmcoYWZ0ZXIudHlwZSkpICYmXG4gICAgICAgIG1hdGNoLm1hdGNoVHlwZShjb25uWzBdIHx8IGFmdGVyLnR5cGUpLnZhbGlkRW5kKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IGVuZCA9ICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUsIHdyYXAgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBjb25uLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKGNvbm5baV0uY3JlYXRlKG51bGwsIHdyYXApKTtcbiAgICAgICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKGJlZm9yZS5jb3B5KHdyYXApKTtcbiAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKCRjdXQucG9zIC0gMSwgZW5kLCAkY3V0LnBvcywgZW5kLCBuZXcgU2xpY2Uod3JhcCwgMSwgMCksIGNvbm4ubGVuZ3RoLCB0cnVlKSk7XG4gICAgICAgICAgICBsZXQgam9pbkF0ID0gZW5kICsgMiAqIGNvbm4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNhbkpvaW4odHIuZG9jLCBqb2luQXQpKVxuICAgICAgICAgICAgICAgIHRyLmpvaW4oam9pbkF0KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgc2VsQWZ0ZXIgPSBTZWxlY3Rpb24uZmluZEZyb20oJGN1dCwgMSk7XG4gICAgbGV0IHJhbmdlID0gc2VsQWZ0ZXIgJiYgc2VsQWZ0ZXIuJGZyb20uYmxvY2tSYW5nZShzZWxBZnRlci4kdG8pLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ICE9IG51bGwgJiYgdGFyZ2V0ID49ICRjdXQuZGVwdGgpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjYW5EZWxBZnRlciAmJiB0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiLCB0cnVlKSAmJiB0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpKSB7XG4gICAgICAgIGxldCBhdCA9IGJlZm9yZSwgd3JhcCA9IFtdO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICB3cmFwLnB1c2goYXQpO1xuICAgICAgICAgICAgaWYgKGF0LmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgYXQgPSBhdC5sYXN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFmdGVyVGV4dCA9IGFmdGVyLCBhZnRlckRlcHRoID0gMTtcbiAgICAgICAgZm9yICg7ICFhZnRlclRleHQuaXNUZXh0YmxvY2s7IGFmdGVyVGV4dCA9IGFmdGVyVGV4dC5maXJzdENoaWxkKVxuICAgICAgICAgICAgYWZ0ZXJEZXB0aCsrO1xuICAgICAgICBpZiAoYXQuY2FuUmVwbGFjZShhdC5jaGlsZENvdW50LCBhdC5jaGlsZENvdW50LCBhZnRlclRleHQuY29udGVudCkpIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gd3JhcC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gRnJhZ21lbnQuZnJvbSh3cmFwW2ldLmNvcHkoZW5kKSk7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSB3cmFwLmxlbmd0aCwgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSwgJGN1dC5wb3MgKyBhZnRlckRlcHRoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplIC0gYWZ0ZXJEZXB0aCwgbmV3IFNsaWNlKGVuZCwgd3JhcC5sZW5ndGgsIDApLCAwLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RUZXh0YmxvY2tTaWRlKHNpZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCAkcG9zID0gc2lkZSA8IDAgPyBzZWwuJGZyb20gOiBzZWwuJHRvO1xuICAgICAgICBsZXQgZGVwdGggPSAkcG9zLmRlcHRoO1xuICAgICAgICB3aGlsZSAoJHBvcy5ub2RlKGRlcHRoKS5pc0lubGluZSkge1xuICAgICAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJHBvcy5ub2RlKGRlcHRoKS5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgc2lkZSA8IDAgPyAkcG9zLnN0YXJ0KGRlcHRoKSA6ICRwb3MuZW5kKGRlcHRoKSkpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgc3RhcnQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuKi9cbmNvbnN0IHNlbGVjdFRleHRibG9ja1N0YXJ0ID0gc2VsZWN0VGV4dGJsb2NrU2lkZSgtMSk7XG4vKipcbk1vdmVzIHRoZSBjdXJzb3IgdG8gdGhlIGVuZCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4qL1xuY29uc3Qgc2VsZWN0VGV4dGJsb2NrRW5kID0gc2VsZWN0VGV4dGJsb2NrU2lkZSgxKTtcbi8vIFBhcmFtZXRlcml6ZWQgY29tbWFuZHNcbi8qKlxuV3JhcCB0aGUgc2VsZWN0aW9uIGluIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSB3aXRoIHRoZSBnaXZlblxuYXR0cmlidXRlcy5cbiovXG5mdW5jdGlvbiB3cmFwSW4obm9kZVR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCB3cmFwcGluZyA9IHJhbmdlICYmIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICAgICAgaWYgKCF3cmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIud3JhcChyYW5nZSwgd3JhcHBpbmcpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5SZXR1cm5zIGEgY29tbWFuZCB0aGF0IHRyaWVzIHRvIHNldCB0aGUgc2VsZWN0ZWQgdGV4dGJsb2NrcyB0byB0aGVcbmdpdmVuIG5vZGUgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuKi9cbmZ1bmN0aW9uIHNldEJsb2NrVHlwZShub2RlVHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IGFwcGxpY2FibGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aCAmJiAhYXBwbGljYWJsZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyAkZnJvbTogeyBwb3M6IGZyb20gfSwgJHRvOiB7IHBvczogdG8gfSB9ID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1tpXTtcbiAgICAgICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwbGljYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5pc1RleHRibG9jayB8fCBub2RlLmhhc01hcmt1cChub2RlVHlwZSwgYXR0cnMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWNhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCAkcG9zID0gc3RhdGUuZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2FibGUgPSAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCBub2RlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcHBsaWNhYmxlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgJGZyb206IHsgcG9zOiBmcm9tIH0sICR0bzogeyBwb3M6IHRvIH0gfSA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgdHIuc2V0QmxvY2tUeXBlKGZyb20sIHRvLCBub2RlVHlwZSwgYXR0cnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtBcHBsaWVzKGRvYywgcmFuZ2VzLCB0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICBsZXQgY2FuID0gJGZyb20uZGVwdGggPT0gMCA/IGRvYy5pbmxpbmVDb250ZW50ICYmIGRvYy50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpIDogZmFsc2U7XG4gICAgICAgIGRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCBub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChjYW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FuID0gbm9kZS5pbmxpbmVDb250ZW50ICYmIG5vZGUudHlwZS5hbGxvd3NNYXJrVHlwZSh0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjYW4pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG5DcmVhdGUgYSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgdG9nZ2xlcyB0aGUgZ2l2ZW4gbWFyayB3aXRoIHRoZVxuZ2l2ZW4gYXR0cmlidXRlcy4gV2lsbCByZXR1cm4gYGZhbHNlYCB3aGVuIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuZG9lc24ndCBzdXBwb3J0IHRoYXQgbWFyay4gVGhpcyB3aWxsIHJlbW92ZSB0aGUgbWFyayBpZiBhbnkgbWFya3Ncbm9mIHRoYXQgdHlwZSBleGlzdCBpbiB0aGUgc2VsZWN0aW9uLCBvciBhZGQgaXQgb3RoZXJ3aXNlLiBJZiB0aGVcbnNlbGVjdGlvbiBpcyBlbXB0eSwgdGhpcyBhcHBsaWVzIHRvIHRoZSBbc3RvcmVkXG5tYXJrc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnN0b3JlZE1hcmtzKSBpbnN0ZWFkIG9mIGEgcmFuZ2Ugb2YgdGhlXG5kb2N1bWVudC5cbiovXG5mdW5jdGlvbiB0b2dnbGVNYXJrKG1hcmtUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyBlbXB0eSwgJGN1cnNvciwgcmFuZ2VzIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICgoZW1wdHkgJiYgISRjdXJzb3IpIHx8ICFtYXJrQXBwbGllcyhzdGF0ZS5kb2MsIHJhbmdlcywgbWFya1R5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlLmlzSW5TZXQoc3RhdGUuc3RvcmVkTWFya3MgfHwgJGN1cnNvci5tYXJrcygpKSlcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIucmVtb3ZlU3RvcmVkTWFyayhtYXJrVHlwZSkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuYWRkU3RvcmVkTWFyayhtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFzID0gZmFsc2UsIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7ICFoYXMgJiYgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGhhcyA9IHN0YXRlLmRvYy5yYW5nZUhhc01hcmsoJGZyb20ucG9zLCAkdG8ucG9zLCBtYXJrVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIucmVtb3ZlTWFyaygkZnJvbS5wb3MsICR0by5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gJGZyb20ucG9zLCB0byA9ICR0by5wb3MsIHN0YXJ0ID0gJGZyb20ubm9kZUFmdGVyLCBlbmQgPSAkdG8ubm9kZUJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZVN0YXJ0ID0gc3RhcnQgJiYgc3RhcnQuaXNUZXh0ID8gL15cXHMqLy5leGVjKHN0YXJ0LnRleHQpWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VFbmQgPSBlbmQgJiYgZW5kLmlzVGV4dCA/IC9cXHMqJC8uZXhlYyhlbmQudGV4dClbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tICsgc3BhY2VTdGFydCA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSArPSBzcGFjZVN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIC09IHNwYWNlRW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayhmcm9tLCB0bywgbWFya1R5cGUuY3JlYXRlKGF0dHJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHdyYXBEaXNwYXRjaEZvckpvaW4oZGlzcGF0Y2gsIGlzSm9pbmFibGUpIHtcbiAgICByZXR1cm4gKHRyKSA9PiB7XG4gICAgICAgIGlmICghdHIuaXNHZW5lcmljKVxuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyLm1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcCA9IHRyLm1hcHBpbmcubWFwc1tpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmFuZ2VzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIHJhbmdlc1tqXSA9IG1hcC5tYXAocmFuZ2VzW2pdKTtcbiAgICAgICAgICAgIG1hcC5mb3JFYWNoKChfcywgX2UsIGZyb20sIHRvKSA9PiByYW5nZXMucHVzaChmcm9tLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggam9pbmFibGUgcG9pbnRzIGV4aXN0IGluc2lkZSB0aG9zZSByYW5nZXMsXG4gICAgICAgIC8vIGJ5IGNoZWNraW5nIGFsbCBub2RlIGJvdW5kYXJpZXMgaW4gdGhlaXIgcGFyZW50IG5vZGVzLlxuICAgICAgICBsZXQgam9pbmFibGUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzW2ldLCB0byA9IHJhbmdlc1tpICsgMV07XG4gICAgICAgICAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgZGVwdGggPSAkZnJvbS5zaGFyZWREZXB0aCh0byksIHBhcmVudCA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSwgcG9zID0gJGZyb20uYWZ0ZXIoZGVwdGggKyAxKTsgcG9zIDw9IHRvOyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAmJiBqb2luYWJsZS5pbmRleE9mKHBvcykgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlLnR5cGUgPT0gYWZ0ZXIudHlwZSAmJiBpc0pvaW5hYmxlKGJlZm9yZSwgYWZ0ZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmFibGUucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gYWZ0ZXIubm9kZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSm9pbiB0aGUgam9pbmFibGUgcG9pbnRzXG4gICAgICAgIGpvaW5hYmxlLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGpvaW5hYmxlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoY2FuSm9pbih0ci5kb2MsIGpvaW5hYmxlW2ldKSlcbiAgICAgICAgICAgICAgICB0ci5qb2luKGpvaW5hYmxlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgfTtcbn1cbi8qKlxuV3JhcCBhIGNvbW1hbmQgc28gdGhhdCwgd2hlbiBpdCBwcm9kdWNlcyBhIHRyYW5zZm9ybSB0aGF0IGNhdXNlc1xudHdvIGpvaW5hYmxlIG5vZGVzIHRvIGVuZCB1cCBuZXh0IHRvIGVhY2ggb3RoZXIsIHRob3NlIGFyZSBqb2luZWQuXG5Ob2RlcyBhcmUgY29uc2lkZXJlZCBqb2luYWJsZSB3aGVuIHRoZXkgYXJlIG9mIHRoZSBzYW1lIHR5cGUgYW5kXG53aGVuIHRoZSBgaXNKb2luYWJsZWAgcHJlZGljYXRlIHJldHVybnMgdHJ1ZSBmb3IgdGhlbSBvciwgaWYgYW5cbmFycmF5IG9mIHN0cmluZ3Mgd2FzIHBhc3NlZCwgaWYgdGhlaXIgbm9kZSB0eXBlIG5hbWUgaXMgaW4gdGhhdFxuYXJyYXkuXG4qL1xuZnVuY3Rpb24gYXV0b0pvaW4oY29tbWFuZCwgaXNKb2luYWJsZSkge1xuICAgIGxldCBjYW5Kb2luID0gQXJyYXkuaXNBcnJheShpc0pvaW5hYmxlKSA/IChub2RlKSA9PiBpc0pvaW5hYmxlLmluZGV4T2Yobm9kZS50eXBlLm5hbWUpID4gLTFcbiAgICAgICAgOiBpc0pvaW5hYmxlO1xuICAgIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiBjb21tYW5kKHN0YXRlLCBkaXNwYXRjaCAmJiB3cmFwRGlzcGF0Y2hGb3JKb2luKGRpc3BhdGNoLCBjYW5Kb2luKSwgdmlldyk7XG59XG4vKipcbkNvbWJpbmUgYSBudW1iZXIgb2YgY29tbWFuZCBmdW5jdGlvbnMgaW50byBhIHNpbmdsZSBmdW5jdGlvbiAod2hpY2hcbmNhbGxzIHRoZW0gb25lIGJ5IG9uZSB1bnRpbCBvbmUgcmV0dXJucyB0cnVlKS5cbiovXG5mdW5jdGlvbiBjaGFpbkNvbW1hbmRzKC4uLmNvbW1hbmRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjb21tYW5kc1tpXShzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbmxldCBiYWNrc3BhY2UgPSBjaGFpbkNvbW1hbmRzKGRlbGV0ZVNlbGVjdGlvbiwgam9pbkJhY2t3YXJkLCBzZWxlY3ROb2RlQmFja3dhcmQpO1xubGV0IGRlbCA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luRm9yd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQpO1xuLyoqXG5BIGJhc2ljIGtleW1hcCBjb250YWluaW5nIGJpbmRpbmdzIG5vdCBzcGVjaWZpYyB0byBhbnkgc2NoZW1hLlxuQmluZHMgdGhlIGZvbGxvd2luZyBrZXlzICh3aGVuIG11bHRpcGxlIGNvbW1hbmRzIGFyZSBsaXN0ZWQsIHRoZXlcbmFyZSBjaGFpbmVkIHdpdGggW2BjaGFpbkNvbW1hbmRzYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmNoYWluQ29tbWFuZHMpKTpcblxuKiAqKkVudGVyKiogdG8gYG5ld2xpbmVJbkNvZGVgLCBgY3JlYXRlUGFyYWdyYXBoTmVhcmAsIGBsaWZ0RW1wdHlCbG9ja2AsIGBzcGxpdEJsb2NrYFxuKiAqKk1vZC1FbnRlcioqIHRvIGBleGl0Q29kZWBcbiogKipCYWNrc3BhY2UqKiBhbmQgKipNb2QtQmFja3NwYWNlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luQmFja3dhcmRgLCBgc2VsZWN0Tm9kZUJhY2t3YXJkYFxuKiAqKkRlbGV0ZSoqIGFuZCAqKk1vZC1EZWxldGUqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5Gb3J3YXJkYCwgYHNlbGVjdE5vZGVGb3J3YXJkYFxuKiAqKk1vZC1EZWxldGUqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5Gb3J3YXJkYCwgYHNlbGVjdE5vZGVGb3J3YXJkYFxuKiAqKk1vZC1hKiogdG8gYHNlbGVjdEFsbGBcbiovXG5jb25zdCBwY0Jhc2VLZXltYXAgPSB7XG4gICAgXCJFbnRlclwiOiBjaGFpbkNvbW1hbmRzKG5ld2xpbmVJbkNvZGUsIGNyZWF0ZVBhcmFncmFwaE5lYXIsIGxpZnRFbXB0eUJsb2NrLCBzcGxpdEJsb2NrKSxcbiAgICBcIk1vZC1FbnRlclwiOiBleGl0Q29kZSxcbiAgICBcIkJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gICAgXCJNb2QtQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gICAgXCJEZWxldGVcIjogZGVsLFxuICAgIFwiTW9kLURlbGV0ZVwiOiBkZWwsXG4gICAgXCJNb2QtYVwiOiBzZWxlY3RBbGxcbn07XG4vKipcbkEgY29weSBvZiBgcGNCYXNlS2V5bWFwYCB0aGF0IGFsc28gYmluZHMgKipDdHJsLWgqKiBsaWtlIEJhY2tzcGFjZSxcbioqQ3RybC1kKiogbGlrZSBEZWxldGUsICoqQWx0LUJhY2tzcGFjZSoqIGxpa2UgQ3RybC1CYWNrc3BhY2UsIGFuZFxuKipDdHJsLUFsdC1CYWNrc3BhY2UqKiwgKipBbHQtRGVsZXRlKiosIGFuZCAqKkFsdC1kKiogbGlrZVxuQ3RybC1EZWxldGUuXG4qL1xuY29uc3QgbWFjQmFzZUtleW1hcCA9IHtcbiAgICBcIkN0cmwtaFwiOiBwY0Jhc2VLZXltYXBbXCJCYWNrc3BhY2VcIl0sXG4gICAgXCJBbHQtQmFja3NwYWNlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1CYWNrc3BhY2VcIl0sXG4gICAgXCJDdHJsLWRcIjogcGNCYXNlS2V5bWFwW1wiRGVsZXRlXCJdLFxuICAgIFwiQ3RybC1BbHQtQmFja3NwYWNlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJBbHQtRGVsZXRlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJBbHQtZFwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICAgIFwiQ3RybC1hXCI6IHNlbGVjdFRleHRibG9ja1N0YXJ0LFxuICAgIFwiQ3RybC1lXCI6IHNlbGVjdFRleHRibG9ja0VuZFxufTtcbmZvciAobGV0IGtleSBpbiBwY0Jhc2VLZXltYXApXG4gICAgbWFjQmFzZUtleW1hcFtrZXldID0gcGNCYXNlS2V5bWFwW2tleV07XG5jb25zdCBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyAvTWFjfGlQKGhvbmV8W29hXWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgOiB0eXBlb2Ygb3MgIT0gXCJ1bmRlZmluZWRcIiAmJiBvcy5wbGF0Zm9ybSA/IG9zLnBsYXRmb3JtKCkgPT0gXCJkYXJ3aW5cIiA6IGZhbHNlO1xuLyoqXG5EZXBlbmRpbmcgb24gdGhlIGRldGVjdGVkIHBsYXRmb3JtLCB0aGlzIHdpbGwgaG9sZFxuW2BwY0Jhc2VrZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMucGNCYXNlS2V5bWFwKSBvclxuW2BtYWNCYXNlS2V5bWFwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLm1hY0Jhc2VLZXltYXApLlxuKi9cbmNvbnN0IGJhc2VLZXltYXAgPSBtYWMgPyBtYWNCYXNlS2V5bWFwIDogcGNCYXNlS2V5bWFwO1xuXG5leHBvcnQgeyBhdXRvSm9pbiwgYmFzZUtleW1hcCwgY2hhaW5Db21tYW5kcywgY3JlYXRlUGFyYWdyYXBoTmVhciwgZGVsZXRlU2VsZWN0aW9uLCBleGl0Q29kZSwgam9pbkJhY2t3YXJkLCBqb2luRG93biwgam9pbkZvcndhcmQsIGpvaW5UZXh0YmxvY2tCYWNrd2FyZCwgam9pblRleHRibG9ja0ZvcndhcmQsIGpvaW5VcCwgbGlmdCwgbGlmdEVtcHR5QmxvY2ssIG1hY0Jhc2VLZXltYXAsIG5ld2xpbmVJbkNvZGUsIHBjQmFzZUtleW1hcCwgc2VsZWN0QWxsLCBzZWxlY3ROb2RlQmFja3dhcmQsIHNlbGVjdE5vZGVGb3J3YXJkLCBzZWxlY3RQYXJlbnROb2RlLCBzZWxlY3RUZXh0YmxvY2tFbmQsIHNlbGVjdFRleHRibG9ja1N0YXJ0LCBzZXRCbG9ja1R5cGUsIHNwbGl0QmxvY2ssIHNwbGl0QmxvY2tBcywgc3BsaXRCbG9ja0tlZXBNYXJrcywgdG9nZ2xlTWFyaywgd3JhcEluIH07XG4iLCAiaW1wb3J0IHsgZmluZFdyYXBwaW5nLCBSZXBsYWNlQXJvdW5kU3RlcCwgY2FuU3BsaXQsIGxpZnRUYXJnZXQsIGNhbkpvaW4gfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgTm9kZVJhbmdlLCBGcmFnbWVudCwgU2xpY2UgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBTZWxlY3Rpb24gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbmNvbnN0IG9sRE9NID0gW1wib2xcIiwgMF0sIHVsRE9NID0gW1widWxcIiwgMF0sIGxpRE9NID0gW1wibGlcIiwgMF07XG4vKipcbkFuIG9yZGVyZWQgbGlzdCBbbm9kZSBzcGVjXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMpLiBIYXMgYSBzaW5nbGVcbmF0dHJpYnV0ZSwgYG9yZGVyYCwgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIGF0IHdoaWNoIHRoZSBsaXN0XG5zdGFydHMgY291bnRpbmcsIGFuZCBkZWZhdWx0cyB0byAxLiBSZXByZXNlbnRlZCBhcyBhbiBgPG9sPmBcbmVsZW1lbnQuXG4qL1xuY29uc3Qgb3JkZXJlZExpc3QgPSB7XG4gICAgYXR0cnM6IHsgb3JkZXI6IHsgZGVmYXVsdDogMSB9IH0sXG4gICAgcGFyc2VET006IFt7IHRhZzogXCJvbFwiLCBnZXRBdHRycyhkb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBvcmRlcjogZG9tLmhhc0F0dHJpYnV0ZShcInN0YXJ0XCIpID8gK2RvbS5nZXRBdHRyaWJ1dGUoXCJzdGFydFwiKSA6IDEgfTtcbiAgICAgICAgICAgIH0gfV0sXG4gICAgdG9ET00obm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5hdHRycy5vcmRlciA9PSAxID8gb2xET00gOiBbXCJvbFwiLCB7IHN0YXJ0OiBub2RlLmF0dHJzLm9yZGVyIH0sIDBdO1xuICAgIH1cbn07XG4vKipcbkEgYnVsbGV0IGxpc3Qgbm9kZSBzcGVjLCByZXByZXNlbnRlZCBpbiB0aGUgRE9NIGFzIGA8dWw+YC5cbiovXG5jb25zdCBidWxsZXRMaXN0ID0ge1xuICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwidWxcIiB9XSxcbiAgICB0b0RPTSgpIHsgcmV0dXJuIHVsRE9NOyB9XG59O1xuLyoqXG5BIGxpc3QgaXRlbSAoYDxsaT5gKSBzcGVjLlxuKi9cbmNvbnN0IGxpc3RJdGVtID0ge1xuICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwibGlcIiB9XSxcbiAgICB0b0RPTSgpIHsgcmV0dXJuIGxpRE9NOyB9LFxuICAgIGRlZmluaW5nOiB0cnVlXG59O1xuZnVuY3Rpb24gYWRkKG9iaiwgcHJvcHMpIHtcbiAgICBsZXQgY29weSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICBjb3B5W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpXG4gICAgICAgIGNvcHlbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICByZXR1cm4gY29weTtcbn1cbi8qKlxuQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGFkZGluZyBsaXN0LXJlbGF0ZWQgbm9kZSB0eXBlcyB0byBhIG1hcFxuc3BlY2lmeWluZyB0aGUgbm9kZXMgZm9yIGEgc2NoZW1hLiBBZGRzXG5bYG9yZGVyZWRMaXN0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3NjaGVtYS1saXN0Lm9yZGVyZWRMaXN0KSBhcyBgXCJvcmRlcmVkX2xpc3RcImAsXG5bYGJ1bGxldExpc3RgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc2NoZW1hLWxpc3QuYnVsbGV0TGlzdCkgYXMgYFwiYnVsbGV0X2xpc3RcImAsIGFuZFxuW2BsaXN0SXRlbWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzY2hlbWEtbGlzdC5saXN0SXRlbSkgYXMgYFwibGlzdF9pdGVtXCJgLlxuXG5gaXRlbUNvbnRlbnRgIGRldGVybWluZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbiBmb3IgdGhlIGxpc3QgaXRlbXMuXG5JZiB5b3Ugd2FudCB0aGUgY29tbWFuZHMgZGVmaW5lZCBpbiB0aGlzIG1vZHVsZSB0byBhcHBseSB0byB5b3VyXG5saXN0IHN0cnVjdHVyZSwgaXQgc2hvdWxkIGhhdmUgYSBzaGFwZSBsaWtlIGBcInBhcmFncmFwaCBibG9jaypcImAgb3JcbmBcInBhcmFncmFwaCAob3JkZXJlZF9saXN0IHwgYnVsbGV0X2xpc3QpKlwiYC4gYGxpc3RHcm91cGAgY2FuIGJlXG5naXZlbiB0byBhc3NpZ24gYSBncm91cCBuYW1lIHRvIHRoZSBsaXN0IG5vZGUgdHlwZXMsIGZvciBleGFtcGxlXG5gXCJibG9ja1wiYC5cbiovXG5mdW5jdGlvbiBhZGRMaXN0Tm9kZXMobm9kZXMsIGl0ZW1Db250ZW50LCBsaXN0R3JvdXApIHtcbiAgICByZXR1cm4gbm9kZXMuYXBwZW5kKHtcbiAgICAgICAgb3JkZXJlZF9saXN0OiBhZGQob3JkZXJlZExpc3QsIHsgY29udGVudDogXCJsaXN0X2l0ZW0rXCIsIGdyb3VwOiBsaXN0R3JvdXAgfSksXG4gICAgICAgIGJ1bGxldF9saXN0OiBhZGQoYnVsbGV0TGlzdCwgeyBjb250ZW50OiBcImxpc3RfaXRlbStcIiwgZ3JvdXA6IGxpc3RHcm91cCB9KSxcbiAgICAgICAgbGlzdF9pdGVtOiBhZGQobGlzdEl0ZW0sIHsgY29udGVudDogaXRlbUNvbnRlbnQgfSlcbiAgICB9KTtcbn1cbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB3cmFwcyB0aGUgc2VsZWN0aW9uIGluIGEgbGlzdCB3aXRoXG50aGUgZ2l2ZW4gdHlwZSBhbiBhdHRyaWJ1dGVzLiBJZiBgZGlzcGF0Y2hgIGlzIG51bGwsIG9ubHkgcmV0dXJuIGFcbnZhbHVlIHRvIGluZGljYXRlIHdoZXRoZXIgdGhpcyBpcyBwb3NzaWJsZSwgYnV0IGRvbid0IGFjdHVhbGx5XG5wZXJmb3JtIHRoZSBjaGFuZ2UuXG4qL1xuZnVuY3Rpb24gd3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIGRvSm9pbiA9IGZhbHNlLCBvdXRlclJhbmdlID0gcmFuZ2U7XG4gICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFRoaXMgaXMgYXQgdGhlIHRvcCBvZiBhbiBleGlzdGluZyBsaXN0IGl0ZW1cbiAgICAgICAgaWYgKHJhbmdlLmRlcHRoID49IDIgJiYgJGZyb20ubm9kZShyYW5nZS5kZXB0aCAtIDEpLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobGlzdFR5cGUpICYmIHJhbmdlLnN0YXJ0SW5kZXggPT0gMCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhpcyBpcyB0aGUgdG9wIG9mIHRoZSBsaXN0XG4gICAgICAgICAgICBpZiAoJGZyb20uaW5kZXgocmFuZ2UuZGVwdGggLSAxKSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCAkaW5zZXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUocmFuZ2Uuc3RhcnQgLSAyKTtcbiAgICAgICAgICAgIG91dGVyUmFuZ2UgPSBuZXcgTm9kZVJhbmdlKCRpbnNlcnQsICRpbnNlcnQsIHJhbmdlLmRlcHRoKTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbmRJbmRleCA8IHJhbmdlLnBhcmVudC5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IE5vZGVSYW5nZSgkZnJvbSwgc3RhdGUuZG9jLnJlc29sdmUoJHRvLmVuZChyYW5nZS5kZXB0aCkpLCByYW5nZS5kZXB0aCk7XG4gICAgICAgICAgICBkb0pvaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3cmFwID0gZmluZFdyYXBwaW5nKG91dGVyUmFuZ2UsIGxpc3RUeXBlLCBhdHRycywgcmFuZ2UpO1xuICAgICAgICBpZiAoIXdyYXApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKGRvV3JhcEluTGlzdChzdGF0ZS50ciwgcmFuZ2UsIHdyYXAsIGRvSm9pbiwgbGlzdFR5cGUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZG9XcmFwSW5MaXN0KHRyLCByYW5nZSwgd3JhcHBlcnMsIGpvaW5CZWZvcmUsIGxpc3RUeXBlKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHdyYXBwZXJzW2ldLnR5cGUuY3JlYXRlKHdyYXBwZXJzW2ldLmF0dHJzLCBjb250ZW50KSk7XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAocmFuZ2Uuc3RhcnQgLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgcmFuZ2UuZW5kLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xuICAgIGxldCBmb3VuZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwcGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKHdyYXBwZXJzW2ldLnR5cGUgPT0gbGlzdFR5cGUpXG4gICAgICAgICAgICBmb3VuZCA9IGkgKyAxO1xuICAgIGxldCBzcGxpdERlcHRoID0gd3JhcHBlcnMubGVuZ3RoIC0gZm91bmQ7XG4gICAgbGV0IHNwbGl0UG9zID0gcmFuZ2Uuc3RhcnQgKyB3cmFwcGVycy5sZW5ndGggLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuICAgIGZvciAobGV0IGkgPSByYW5nZS5zdGFydEluZGV4LCBlID0gcmFuZ2UuZW5kSW5kZXgsIGZpcnN0ID0gdHJ1ZTsgaSA8IGU7IGkrKywgZmlyc3QgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIWZpcnN0ICYmIGNhblNwbGl0KHRyLmRvYywgc3BsaXRQb3MsIHNwbGl0RGVwdGgpKSB7XG4gICAgICAgICAgICB0ci5zcGxpdChzcGxpdFBvcywgc3BsaXREZXB0aCk7XG4gICAgICAgICAgICBzcGxpdFBvcyArPSAyICogc3BsaXREZXB0aDtcbiAgICAgICAgfVxuICAgICAgICBzcGxpdFBvcyArPSBwYXJlbnQuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbi8qKlxuQnVpbGQgYSBjb21tYW5kIHRoYXQgc3BsaXRzIGEgbm9uLWVtcHR5IHRleHRibG9jayBhdCB0aGUgdG9wIGxldmVsXG5vZiBhIGxpc3QgaXRlbSBieSBhbHNvIHNwbGl0dGluZyB0aGF0IGxpc3QgaXRlbS5cbiovXG5mdW5jdGlvbiBzcGxpdExpc3RJdGVtKGl0ZW1UeXBlLCBpdGVtQXR0cnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvLCBub2RlIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICgobm9kZSAmJiBub2RlLmlzQmxvY2spIHx8ICRmcm9tLmRlcHRoIDwgMiB8fCAhJGZyb20uc2FtZVBhcmVudCgkdG8pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKTtcbiAgICAgICAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT0gaXRlbVR5cGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICgkZnJvbS5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgICAgICAgICAgLy8gSW4gYW4gZW1wdHkgYmxvY2suIElmIHRoaXMgaXMgYSBuZXN0ZWQgbGlzdCwgdGhlIHdyYXBwaW5nXG4gICAgICAgICAgICAvLyBsaXN0IGl0ZW0gc2hvdWxkIGJlIHNwbGl0LiBPdGhlcndpc2UsIGJhaWwgb3V0IGFuZCBsZXQgbmV4dFxuICAgICAgICAgICAgLy8gY29tbWFuZCBoYW5kbGUgbGlmdGluZy5cbiAgICAgICAgICAgIGlmICgkZnJvbS5kZXB0aCA9PSAzIHx8ICRmcm9tLm5vZGUoLTMpLnR5cGUgIT0gaXRlbVR5cGUgfHxcbiAgICAgICAgICAgICAgICAkZnJvbS5pbmRleCgtMikgIT0gJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXAgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGhCZWZvcmUgPSAkZnJvbS5pbmRleCgtMSkgPyAxIDogJGZyb20uaW5kZXgoLTIpID8gMiA6IDM7XG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgYSBmcmFnbWVudCBjb250YWluaW5nIGVtcHR5IHZlcnNpb25zIG9mIHRoZSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBvdXRlciBsaXN0IGl0ZW0gdG8gdGhlIHBhcmVudCBub2RlIG9mIHRoZSBjdXJzb3JcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGggLSBkZXB0aEJlZm9yZTsgZCA+PSAkZnJvbS5kZXB0aCAtIDM7IGQtLSlcbiAgICAgICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGhBZnRlciA9ICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCA/IDFcbiAgICAgICAgICAgICAgICAgICAgOiAkZnJvbS5pbmRleEFmdGVyKC0yKSA8ICRmcm9tLm5vZGUoLTMpLmNoaWxkQ291bnQgPyAyIDogMztcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBzZWNvbmQgbGlzdCBpdGVtIHdpdGggYW4gZW1wdHkgZGVmYXVsdCBzdGFydCBub2RlXG4gICAgICAgICAgICAgICAgd3JhcCA9IHdyYXAuYXBwZW5kKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlQW5kRmlsbCgpKSk7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uYmVmb3JlKCRmcm9tLmRlcHRoIC0gKGRlcHRoQmVmb3JlIC0gMSkpO1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IFNsaWNlKHdyYXAsIDQgLSBkZXB0aEJlZm9yZSwgMCkpO1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSAtMTtcbiAgICAgICAgICAgICAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKHN0YXJ0LCB0ci5kb2MuY29udGVudC5zaXplLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWwgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0YmxvY2sgJiYgbm9kZS5jb250ZW50LnNpemUgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoc2VsKSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRUeXBlID0gJHRvLnBvcyA9PSAkZnJvbS5lbmQoKSA/IGdyYW5kUGFyZW50LmNvbnRlbnRNYXRjaEF0KDApLmRlZmF1bHRUeXBlIDogbnVsbDtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcyk7XG4gICAgICAgIGxldCB0eXBlcyA9IG5leHRUeXBlID8gW2l0ZW1BdHRycyA/IHsgdHlwZTogaXRlbVR5cGUsIGF0dHJzOiBpdGVtQXR0cnMgfSA6IG51bGwsIHsgdHlwZTogbmV4dFR5cGUgfV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghY2FuU3BsaXQodHIuZG9jLCAkZnJvbS5wb3MsIDIsIHR5cGVzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgdG8gbGlmdCB0aGUgbGlzdCBpdGVtIGFyb3VuZCB0aGUgc2VsZWN0aW9uIHVwIGludG9cbmEgd3JhcHBpbmcgbGlzdC5cbiovXG5mdW5jdGlvbiBsaWZ0TGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBub2RlID0+IG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGUpO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRpc3BhdGNoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICgkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZSA9PSBpdGVtVHlwZSkgLy8gSW5zaWRlIGEgcGFyZW50IGxpc3RcbiAgICAgICAgICAgIHJldHVybiBsaWZ0VG9PdXRlckxpc3Qoc3RhdGUsIGRpc3BhdGNoLCBpdGVtVHlwZSwgcmFuZ2UpO1xuICAgICAgICBlbHNlIC8vIE91dGVyIGxpc3Qgbm9kZVxuICAgICAgICAgICAgcmV0dXJuIGxpZnRPdXRPZkxpc3Qoc3RhdGUsIGRpc3BhdGNoLCByYW5nZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpZnRUb091dGVyTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIGl0ZW1UeXBlLCByYW5nZSkge1xuICAgIGxldCB0ciA9IHN0YXRlLnRyLCBlbmQgPSByYW5nZS5lbmQsIGVuZE9mTGlzdCA9IHJhbmdlLiR0by5lbmQocmFuZ2UuZGVwdGgpO1xuICAgIGlmIChlbmQgPCBlbmRPZkxpc3QpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHNpYmxpbmdzIGFmdGVyIHRoZSBsaWZ0ZWQgaXRlbXMsIHdoaWNoIG11c3QgYmVjb21lXG4gICAgICAgIC8vIGNoaWxkcmVuIG9mIHRoZSBsYXN0IGl0ZW1cbiAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoZW5kIC0gMSwgZW5kT2ZMaXN0LCBlbmQsIGVuZE9mTGlzdCwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlKG51bGwsIHJhbmdlLnBhcmVudC5jb3B5KCkpKSwgMSwgMCksIDEsIHRydWUpKTtcbiAgICAgICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKHRyLmRvYy5yZXNvbHZlKHJhbmdlLiRmcm9tLnBvcyksIHRyLmRvYy5yZXNvbHZlKGVuZE9mTGlzdCksIHJhbmdlLmRlcHRoKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHIubGlmdChyYW5nZSwgdGFyZ2V0KTtcbiAgICBsZXQgYWZ0ZXIgPSB0ci5tYXBwaW5nLm1hcChlbmQsIC0xKSAtIDE7XG4gICAgaWYgKGNhbkpvaW4odHIuZG9jLCBhZnRlcikpXG4gICAgICAgIHRyLmpvaW4oYWZ0ZXIpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbGlmdE91dE9mTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIHJhbmdlKSB7XG4gICAgbGV0IHRyID0gc3RhdGUudHIsIGxpc3QgPSByYW5nZS5wYXJlbnQ7XG4gICAgLy8gTWVyZ2UgdGhlIGxpc3QgaXRlbXMgaW50byBhIHNpbmdsZSBiaWcgaXRlbVxuICAgIGZvciAobGV0IHBvcyA9IHJhbmdlLmVuZCwgaSA9IHJhbmdlLmVuZEluZGV4IC0gMSwgZSA9IHJhbmdlLnN0YXJ0SW5kZXg7IGkgPiBlOyBpLS0pIHtcbiAgICAgICAgcG9zIC09IGxpc3QuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICAgIHRyLmRlbGV0ZShwb3MgLSAxLCBwb3MgKyAxKTtcbiAgICB9XG4gICAgbGV0ICRzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0KSwgaXRlbSA9ICRzdGFydC5ub2RlQWZ0ZXI7XG4gICAgaWYgKHRyLm1hcHBpbmcubWFwKHJhbmdlLmVuZCkgIT0gcmFuZ2Uuc3RhcnQgKyAkc3RhcnQubm9kZUFmdGVyLm5vZGVTaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGF0U3RhcnQgPSByYW5nZS5zdGFydEluZGV4ID09IDAsIGF0RW5kID0gcmFuZ2UuZW5kSW5kZXggPT0gbGlzdC5jaGlsZENvdW50O1xuICAgIGxldCBwYXJlbnQgPSAkc3RhcnQubm9kZSgtMSksIGluZGV4QmVmb3JlID0gJHN0YXJ0LmluZGV4KC0xKTtcbiAgICBpZiAoIXBhcmVudC5jYW5SZXBsYWNlKGluZGV4QmVmb3JlICsgKGF0U3RhcnQgPyAwIDogMSksIGluZGV4QmVmb3JlICsgMSwgaXRlbS5jb250ZW50LmFwcGVuZChhdEVuZCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0KSkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHN0YXJ0ID0gJHN0YXJ0LnBvcywgZW5kID0gc3RhcnQgKyBpdGVtLm5vZGVTaXplO1xuICAgIC8vIFN0cmlwIG9mZiB0aGUgc3Vycm91bmRpbmcgbGlzdC4gQXQgdGhlIHNpZGVzIHdoZXJlIHdlJ3JlIG5vdCBhdFxuICAgIC8vIHRoZSBlbmQgb2YgdGhlIGxpc3QsIHRoZSBleGlzdGluZyBsaXN0IGlzIGNsb3NlZC4gQXQgc2lkZXMgd2hlcmVcbiAgICAvLyB0aGlzIGlzIHRoZSBlbmQsIGl0IGlzIG92ZXJ3cml0dGVuIHRvIGl0cyBlbmQuXG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQgLSAoYXRTdGFydCA/IDEgOiAwKSwgZW5kICsgKGF0RW5kID8gMSA6IDApLCBzdGFydCArIDEsIGVuZCAtIDEsIG5ldyBTbGljZSgoYXRTdGFydCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSlcbiAgICAgICAgLmFwcGVuZChhdEVuZCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSksIGF0U3RhcnQgPyAwIDogMSwgYXRFbmQgPyAwIDogMSksIGF0U3RhcnQgPyAwIDogMSkpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5DcmVhdGUgYSBjb21tYW5kIHRvIHNpbmsgdGhlIGxpc3QgaXRlbSBhcm91bmQgdGhlIHNlbGVjdGlvbiBkb3duXG5pbnRvIGFuIGlubmVyIGxpc3QuXG4qL1xuZnVuY3Rpb24gc2lua0xpc3RJdGVtKGl0ZW1UeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bywgbm9kZSA9PiBub2RlLmNoaWxkQ291bnQgPiAwICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09IGl0ZW1UeXBlKTtcbiAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSByYW5nZS5zdGFydEluZGV4O1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgcGFyZW50ID0gcmFuZ2UucGFyZW50LCBub2RlQmVmb3JlID0gcGFyZW50LmNoaWxkKHN0YXJ0SW5kZXggLSAxKTtcbiAgICAgICAgaWYgKG5vZGVCZWZvcmUudHlwZSAhPSBpdGVtVHlwZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgbmVzdGVkQmVmb3JlID0gbm9kZUJlZm9yZS5sYXN0Q2hpbGQgJiYgbm9kZUJlZm9yZS5sYXN0Q2hpbGQudHlwZSA9PSBwYXJlbnQudHlwZTtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IEZyYWdtZW50LmZyb20obmVzdGVkQmVmb3JlID8gaXRlbVR5cGUuY3JlYXRlKCkgOiBudWxsKTtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKHBhcmVudC50eXBlLmNyZWF0ZShudWxsLCBpbm5lcikpKSksIG5lc3RlZEJlZm9yZSA/IDMgOiAxLCAwKTtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSByYW5nZS5zdGFydCwgYWZ0ZXIgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChiZWZvcmUgLSAobmVzdGVkQmVmb3JlID8gMyA6IDEpLCBhZnRlciwgYmVmb3JlLCBhZnRlciwgc2xpY2UsIDEsIHRydWUpKVxuICAgICAgICAgICAgICAgIC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBhZGRMaXN0Tm9kZXMsIGJ1bGxldExpc3QsIGxpZnRMaXN0SXRlbSwgbGlzdEl0ZW0sIG9yZGVyZWRMaXN0LCBzaW5rTGlzdEl0ZW0sIHNwbGl0TGlzdEl0ZW0sIHdyYXBJbkxpc3QgfTtcbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoY29uZmlnOiB7XG4gIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblxuICBzdGF0ZTogRWRpdG9yU3RhdGVcbn0pOiBFZGl0b3JTdGF0ZSB7XG4gIGNvbnN0IHsgc3RhdGUsIHRyYW5zYWN0aW9uIH0gPSBjb25maWdcbiAgbGV0IHsgc2VsZWN0aW9uIH0gPSB0cmFuc2FjdGlvblxuICBsZXQgeyBkb2MgfSA9IHRyYW5zYWN0aW9uXG4gIGxldCB7IHN0b3JlZE1hcmtzIH0gPSB0cmFuc2FjdGlvblxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgYXBwbHk6IHN0YXRlLmFwcGx5LmJpbmQoc3RhdGUpLFxuICAgIGFwcGx5VHJhbnNhY3Rpb246IHN0YXRlLmFwcGx5VHJhbnNhY3Rpb24uYmluZChzdGF0ZSksXG4gICAgZmlsdGVyVHJhbnNhY3Rpb246IHN0YXRlLmZpbHRlclRyYW5zYWN0aW9uLFxuICAgIHBsdWdpbnM6IHN0YXRlLnBsdWdpbnMsXG4gICAgc2NoZW1hOiBzdGF0ZS5zY2hlbWEsXG4gICAgcmVjb25maWd1cmU6IHN0YXRlLnJlY29uZmlndXJlLmJpbmQoc3RhdGUpLFxuICAgIHRvSlNPTjogc3RhdGUudG9KU09OLmJpbmQoc3RhdGUpLFxuICAgIGdldCBzdG9yZWRNYXJrcygpIHtcbiAgICAgIHJldHVybiBzdG9yZWRNYXJrc1xuICAgIH0sXG4gICAgZ2V0IHNlbGVjdGlvbigpIHtcbiAgICAgIHJldHVybiBzZWxlY3Rpb25cbiAgICB9LFxuICAgIGdldCBkb2MoKSB7XG4gICAgICByZXR1cm4gZG9jXG4gICAgfSxcbiAgICBnZXQgdHIoKSB7XG4gICAgICBzZWxlY3Rpb24gPSB0cmFuc2FjdGlvbi5zZWxlY3Rpb25cbiAgICAgIGRvYyA9IHRyYW5zYWN0aW9uLmRvY1xuICAgICAgc3RvcmVkTWFya3MgPSB0cmFuc2FjdGlvbi5zdG9yZWRNYXJrc1xuXG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb25cbiAgICB9LFxuICB9XG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUsIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBjcmVhdGVDaGFpbmFibGVTdGF0ZSB9IGZyb20gJy4vaGVscGVycy9jcmVhdGVDaGFpbmFibGVTdGF0ZS5qcydcbmltcG9ydCB7XG4gIEFueUNvbW1hbmRzLCBDYW5Db21tYW5kcywgQ2hhaW5lZENvbW1hbmRzLCBDb21tYW5kUHJvcHMsIFNpbmdsZUNvbW1hbmRzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuXG5leHBvcnQgY2xhc3MgQ29tbWFuZE1hbmFnZXIge1xuICBlZGl0b3I6IEVkaXRvclxuXG4gIHJhd0NvbW1hbmRzOiBBbnlDb21tYW5kc1xuXG4gIGN1c3RvbVN0YXRlPzogRWRpdG9yU3RhdGVcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogeyBlZGl0b3I6IEVkaXRvcjsgc3RhdGU/OiBFZGl0b3JTdGF0ZSB9KSB7XG4gICAgdGhpcy5lZGl0b3IgPSBwcm9wcy5lZGl0b3JcbiAgICB0aGlzLnJhd0NvbW1hbmRzID0gdGhpcy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5jb21tYW5kc1xuICAgIHRoaXMuY3VzdG9tU3RhdGUgPSBwcm9wcy5zdGF0ZVxuICB9XG5cbiAgZ2V0IGhhc0N1c3RvbVN0YXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuY3VzdG9tU3RhdGVcbiAgfVxuXG4gIGdldCBzdGF0ZSgpOiBFZGl0b3JTdGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuY3VzdG9tU3RhdGUgfHwgdGhpcy5lZGl0b3Iuc3RhdGVcbiAgfVxuXG4gIGdldCBjb21tYW5kcygpOiBTaW5nbGVDb21tYW5kcyB7XG4gICAgY29uc3QgeyByYXdDb21tYW5kcywgZWRpdG9yLCBzdGF0ZSB9ID0gdGhpc1xuICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yXG4gICAgY29uc3QgeyB0ciB9ID0gc3RhdGVcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0cilcblxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKVxuXG4gICAgICAgICAgaWYgKCF0ci5nZXRNZXRhKCdwcmV2ZW50RGlzcGF0Y2gnKSAmJiAhdGhpcy5oYXNDdXN0b21TdGF0ZSkge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2tcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbmFtZSwgbWV0aG9kXVxuICAgICAgfSksXG4gICAgKSBhcyB1bmtub3duIGFzIFNpbmdsZUNvbW1hbmRzXG4gIH1cblxuICBnZXQgY2hhaW4oKTogKCkgPT4gQ2hhaW5lZENvbW1hbmRzIHtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5jcmVhdGVDaGFpbigpXG4gIH1cblxuICBnZXQgY2FuKCk6ICgpID0+IENhbkNvbW1hbmRzIHtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5jcmVhdGVDYW4oKVxuICB9XG5cbiAgcHVibGljIGNyZWF0ZUNoYWluKHN0YXJ0VHI/OiBUcmFuc2FjdGlvbiwgc2hvdWxkRGlzcGF0Y2ggPSB0cnVlKTogQ2hhaW5lZENvbW1hbmRzIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzXG4gICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3JcbiAgICBjb25zdCBjYWxsYmFja3M6IGJvb2xlYW5bXSA9IFtdXG4gICAgY29uc3QgaGFzU3RhcnRUcmFuc2FjdGlvbiA9ICEhc3RhcnRUclxuICAgIGNvbnN0IHRyID0gc3RhcnRUciB8fCBzdGF0ZS50clxuXG4gICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAhaGFzU3RhcnRUcmFuc2FjdGlvblxuICAgICAgICAmJiBzaG91bGREaXNwYXRjaFxuICAgICAgICAmJiAhdHIuZ2V0TWV0YSgncHJldmVudERpc3BhdGNoJylcbiAgICAgICAgJiYgIXRoaXMuaGFzQ3VzdG9tU3RhdGVcbiAgICAgICkge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbGJhY2tzLmV2ZXJ5KGNhbGxiYWNrID0+IGNhbGxiYWNrID09PSB0cnVlKVxuICAgIH1cblxuICAgIGNvbnN0IGNoYWluID0ge1xuICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgICBjb25zdCBjaGFpbmVkQ29tbWFuZCA9ICguLi5hcmdzOiBuZXZlcltdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0ciwgc2hvdWxkRGlzcGF0Y2gpXG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGNvbW1hbmQoLi4uYXJncykocHJvcHMpXG5cbiAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKVxuXG4gICAgICAgICAgICByZXR1cm4gY2hhaW5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW25hbWUsIGNoYWluZWRDb21tYW5kXVxuICAgICAgICB9KSxcbiAgICAgICksXG4gICAgICBydW4sXG4gICAgfSBhcyB1bmtub3duIGFzIENoYWluZWRDb21tYW5kc1xuXG4gICAgcmV0dXJuIGNoYWluXG4gIH1cblxuICBwdWJsaWMgY3JlYXRlQ2FuKHN0YXJ0VHI/OiBUcmFuc2FjdGlvbik6IENhbkNvbW1hbmRzIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBzdGF0ZSB9ID0gdGhpc1xuICAgIGNvbnN0IGRpc3BhdGNoID0gZmFsc2VcbiAgICBjb25zdCB0ciA9IHN0YXJ0VHIgfHwgc3RhdGUudHJcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0ciwgZGlzcGF0Y2gpXG4gICAgY29uc3QgZm9ybWF0dGVkQ29tbWFuZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgcmV0dXJuIFtuYW1lLCAoLi4uYXJnczogbmV2ZXJbXSkgPT4gY29tbWFuZCguLi5hcmdzKSh7IC4uLnByb3BzLCBkaXNwYXRjaDogdW5kZWZpbmVkIH0pXVxuICAgICAgfSksXG4gICAgKSBhcyB1bmtub3duIGFzIFNpbmdsZUNvbW1hbmRzXG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZm9ybWF0dGVkQ29tbWFuZHMsXG4gICAgICBjaGFpbjogKCkgPT4gdGhpcy5jcmVhdGVDaGFpbih0ciwgZGlzcGF0Y2gpLFxuICAgIH0gYXMgQ2FuQ29tbWFuZHNcbiAgfVxuXG4gIHB1YmxpYyBidWlsZFByb3BzKHRyOiBUcmFuc2FjdGlvbiwgc2hvdWxkRGlzcGF0Y2ggPSB0cnVlKTogQ29tbWFuZFByb3BzIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzXG4gICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3JcblxuICAgIGNvbnN0IHByb3BzOiBDb21tYW5kUHJvcHMgPSB7XG4gICAgICB0cixcbiAgICAgIGVkaXRvcixcbiAgICAgIHZpZXcsXG4gICAgICBzdGF0ZTogY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgICAgfSksXG4gICAgICBkaXNwYXRjaDogc2hvdWxkRGlzcGF0Y2ggPyAoKSA9PiB1bmRlZmluZWQgOiB1bmRlZmluZWQsXG4gICAgICBjaGFpbjogKCkgPT4gdGhpcy5jcmVhdGVDaGFpbih0ciwgc2hvdWxkRGlzcGF0Y2gpLFxuICAgICAgY2FuOiAoKSA9PiB0aGlzLmNyZWF0ZUNhbih0ciksXG4gICAgICBnZXQgY29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmRdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW25hbWUsICguLi5hcmdzOiBuZXZlcltdKSA9PiBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKV1cbiAgICAgICAgICB9KSxcbiAgICAgICAgKSBhcyB1bmtub3duIGFzIFNpbmdsZUNvbW1hbmRzXG4gICAgICB9LFxuICAgIH1cblxuICAgIHJldHVybiBwcm9wc1xuICB9XG59XG4iLCAidHlwZSBTdHJpbmdLZXlPZjxUPiA9IEV4dHJhY3Q8a2V5b2YgVCwgc3RyaW5nPlxudHlwZSBDYWxsYmFja1R5cGU8XG4gIFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBFdmVudE5hbWUgZXh0ZW5kcyBTdHJpbmdLZXlPZjxUPixcbj4gPSBUW0V2ZW50TmFtZV0gZXh0ZW5kcyBhbnlbXSA/IFRbRXZlbnROYW1lXSA6IFtUW0V2ZW50TmFtZV1dXG50eXBlIENhbGxiYWNrRnVuY3Rpb248XG4gIFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBFdmVudE5hbWUgZXh0ZW5kcyBTdHJpbmdLZXlPZjxUPixcbj4gPSAoLi4ucHJvcHM6IENhbGxiYWNrVHlwZTxULCBFdmVudE5hbWU+KSA9PiBhbnlcblxuZXhwb3J0IGNsYXNzIEV2ZW50RW1pdHRlcjxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4ge1xuXG4gIHByaXZhdGUgY2FsbGJhY2tzOiB7IFtrZXk6IHN0cmluZ106IEZ1bmN0aW9uW10gfSA9IHt9XG5cbiAgcHVibGljIG9uPEV2ZW50TmFtZSBleHRlbmRzIFN0cmluZ0tleU9mPFQ+PihldmVudDogRXZlbnROYW1lLCBmbjogQ2FsbGJhY2tGdW5jdGlvbjxULCBFdmVudE5hbWU+KTogdGhpcyB7XG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrc1tldmVudF0pIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IFtdXG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdLnB1c2goZm4pXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJvdGVjdGVkIGVtaXQ8RXZlbnROYW1lIGV4dGVuZHMgU3RyaW5nS2V5T2Y8VD4+KGV2ZW50OiBFdmVudE5hbWUsIC4uLmFyZ3M6IENhbGxiYWNrVHlwZTxULCBFdmVudE5hbWU+KTogdGhpcyB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3NbZXZlbnRdXG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBjYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHVibGljIG9mZjxFdmVudE5hbWUgZXh0ZW5kcyBTdHJpbmdLZXlPZjxUPj4oZXZlbnQ6IEV2ZW50TmFtZSwgZm4/OiBDYWxsYmFja0Z1bmN0aW9uPFQsIEV2ZW50TmFtZT4pOiB0aGlzIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF1cblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGlmIChmbikge1xuICAgICAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0gPSBjYWxsYmFja3MuZmlsdGVyKGNhbGxiYWNrID0+IGNhbGxiYWNrICE9PSBmbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tldmVudF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlbW92ZUFsbExpc3RlbmVycygpOiB2b2lkIHtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHt9XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBBbnlFeHRlbnNpb24sIE1heWJlVGhpc1BhcmFtZXRlclR5cGUsIFJlbW92ZVRoaXMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEV4dGVuc2lvbkZpZWxkPFQgPSBhbnk+KFxuICBleHRlbnNpb246IEFueUV4dGVuc2lvbixcbiAgZmllbGQ6IHN0cmluZyxcbiAgY29udGV4dD86IE9taXQ8TWF5YmVUaGlzUGFyYW1ldGVyVHlwZTxUPiwgJ3BhcmVudCc+LFxuKTogUmVtb3ZlVGhpczxUPiB7XG5cbiAgaWYgKGV4dGVuc2lvbi5jb25maWdbZmllbGRdID09PSB1bmRlZmluZWQgJiYgZXh0ZW5zaW9uLnBhcmVudCkge1xuICAgIHJldHVybiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24ucGFyZW50LCBmaWVsZCwgY29udGV4dClcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5jb25maWdbZmllbGRdLmJpbmQoe1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIHBhcmVudDogZXh0ZW5zaW9uLnBhcmVudFxuICAgICAgICA/IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbi5wYXJlbnQsIGZpZWxkLCBjb250ZXh0KVxuICAgICAgICA6IG51bGwsXG4gICAgfSlcblxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcmV0dXJuIGV4dGVuc2lvbi5jb25maWdbZmllbGRdXG59XG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuaW1wb3J0IHsgTWFyayB9IGZyb20gJy4uL01hcmsuanMnXG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi4vTm9kZS5qcydcbmltcG9ydCB7IEV4dGVuc2lvbnMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zOiBFeHRlbnNpb25zKSB7XG4gIGNvbnN0IGJhc2VFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi50eXBlID09PSAnZXh0ZW5zaW9uJykgYXMgRXh0ZW5zaW9uW11cbiAgY29uc3Qgbm9kZUV4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdub2RlJykgYXMgTm9kZVtdXG4gIGNvbnN0IG1hcmtFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi50eXBlID09PSAnbWFyaycpIGFzIE1hcmtbXVxuXG4gIHJldHVybiB7XG4gICAgYmFzZUV4dGVuc2lvbnMsXG4gICAgbm9kZUV4dGVuc2lvbnMsXG4gICAgbWFya0V4dGVuc2lvbnMsXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBNYXJrQ29uZmlnLCBOb2RlQ29uZmlnIH0gZnJvbSAnLi4vaW5kZXguanMnXG5pbXBvcnQge1xuICBBbnlDb25maWcsXG4gIEF0dHJpYnV0ZSxcbiAgQXR0cmlidXRlcyxcbiAgRXh0ZW5zaW9uQXR0cmlidXRlLFxuICBFeHRlbnNpb25zLFxuICBHbG9iYWxBdHRyaWJ1dGVzLFxufSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnLi9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IHNwbGl0RXh0ZW5zaW9ucyB9IGZyb20gJy4vc3BsaXRFeHRlbnNpb25zLmpzJ1xuXG4vKipcbiAqIEdldCBhIGxpc3Qgb2YgYWxsIGV4dGVuc2lvbiBhdHRyaWJ1dGVzIGRlZmluZWQgaW4gYGFkZEF0dHJpYnV0ZWAgYW5kIGBhZGRHbG9iYWxBdHRyaWJ1dGVgLlxuICogQHBhcmFtIGV4dGVuc2lvbnMgTGlzdCBvZiBleHRlbnNpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IEV4dGVuc2lvbkF0dHJpYnV0ZVtdIHtcbiAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlczogRXh0ZW5zaW9uQXR0cmlidXRlW10gPSBbXVxuICBjb25zdCB7IG5vZGVFeHRlbnNpb25zLCBtYXJrRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpXG4gIGNvbnN0IG5vZGVBbmRNYXJrRXh0ZW5zaW9ucyA9IFsuLi5ub2RlRXh0ZW5zaW9ucywgLi4ubWFya0V4dGVuc2lvbnNdXG4gIGNvbnN0IGRlZmF1bHRBdHRyaWJ1dGU6IFJlcXVpcmVkPEF0dHJpYnV0ZT4gPSB7XG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICByZW5kZXJlZDogdHJ1ZSxcbiAgICByZW5kZXJIVE1MOiBudWxsLFxuICAgIHBhcnNlSFRNTDogbnVsbCxcbiAgICBrZWVwT25TcGxpdDogdHJ1ZSxcbiAgICBpc1JlcXVpcmVkOiBmYWxzZSxcbiAgfVxuXG4gIGV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgfVxuXG4gICAgY29uc3QgYWRkR2xvYmFsQXR0cmlidXRlcyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkR2xvYmFsQXR0cmlidXRlcyddPihcbiAgICAgIGV4dGVuc2lvbixcbiAgICAgICdhZGRHbG9iYWxBdHRyaWJ1dGVzJyxcbiAgICAgIGNvbnRleHQsXG4gICAgKVxuXG4gICAgaWYgKCFhZGRHbG9iYWxBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFzIEdsb2JhbEF0dHJpYnV0ZXNgXG4gICAgY29uc3QgZ2xvYmFsQXR0cmlidXRlcyA9IGFkZEdsb2JhbEF0dHJpYnV0ZXMoKSBhcyBHbG9iYWxBdHRyaWJ1dGVzXG5cbiAgICBnbG9iYWxBdHRyaWJ1dGVzLmZvckVhY2goZ2xvYmFsQXR0cmlidXRlID0+IHtcbiAgICAgIGdsb2JhbEF0dHJpYnV0ZS50eXBlcy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICBPYmplY3RcbiAgICAgICAgICAuZW50cmllcyhnbG9iYWxBdHRyaWJ1dGUuYXR0cmlidXRlcylcbiAgICAgICAgICAuZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZV0pID0+IHtcbiAgICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZToge1xuICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG4gIG5vZGVBbmRNYXJrRXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICB9XG5cbiAgICBjb25zdCBhZGRBdHRyaWJ1dGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snYWRkQXR0cmlidXRlcyddIHwgTWFya0NvbmZpZ1snYWRkQXR0cmlidXRlcyddPihcbiAgICAgIGV4dGVuc2lvbixcbiAgICAgICdhZGRBdHRyaWJ1dGVzJyxcbiAgICAgIGNvbnRleHQsXG4gICAgKVxuXG4gICAgaWYgKCFhZGRBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFzIEF0dHJpYnV0ZXNgXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGFkZEF0dHJpYnV0ZXMoKSBhcyBBdHRyaWJ1dGVzXG5cbiAgICBPYmplY3RcbiAgICAgIC5lbnRyaWVzKGF0dHJpYnV0ZXMpXG4gICAgICAuZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZV0pID0+IHtcbiAgICAgICAgY29uc3QgbWVyZ2VkQXR0ciA9IHtcbiAgICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlLFxuICAgICAgICAgIC4uLmF0dHJpYnV0ZSxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVyZ2VkQXR0cj8uZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG1lcmdlZEF0dHIuZGVmYXVsdCA9IG1lcmdlZEF0dHIuZGVmYXVsdCgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVyZ2VkQXR0cj8uaXNSZXF1aXJlZCAmJiBtZXJnZWRBdHRyPy5kZWZhdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgbWVyZ2VkQXR0ci5kZWZhdWx0XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgYXR0cmlidXRlOiBtZXJnZWRBdHRyLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgfSlcblxuICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlc1xufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZVR5cGUobmFtZU9yVHlwZTogc3RyaW5nIHwgTm9kZVR5cGUsIHNjaGVtYTogU2NoZW1hKTogTm9kZVR5cGUge1xuICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFzY2hlbWEubm9kZXNbbmFtZU9yVHlwZV0pIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgVGhlcmUgaXMgbm8gbm9kZSB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gLFxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWEubm9kZXNbbmFtZU9yVHlwZV1cbiAgfVxuXG4gIHJldHVybiBuYW1lT3JUeXBlXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQXR0cmlidXRlcyguLi5vYmplY3RzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+W10pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgcmV0dXJuIG9iamVjdHNcbiAgICAuZmlsdGVyKGl0ZW0gPT4gISFpdGVtKVxuICAgIC5yZWR1Y2UoKGl0ZW1zLCBpdGVtKSA9PiB7XG4gICAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGVzID0geyAuLi5pdGVtcyB9XG5cbiAgICAgIE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBjb25zdCBleGlzdHMgPSBtZXJnZWRBdHRyaWJ1dGVzW2tleV1cblxuICAgICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlXG5cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZUNsYXNzZXM6IHN0cmluZ1tdID0gdmFsdWUgPyB2YWx1ZS5zcGxpdCgnICcpIDogW11cbiAgICAgICAgICBjb25zdCBleGlzdGluZ0NsYXNzZXM6IHN0cmluZ1tdID0gbWVyZ2VkQXR0cmlidXRlc1trZXldID8gbWVyZ2VkQXR0cmlidXRlc1trZXldLnNwbGl0KCcgJykgOiBbXVxuXG4gICAgICAgICAgY29uc3QgaW5zZXJ0Q2xhc3NlcyA9IHZhbHVlQ2xhc3Nlcy5maWx0ZXIoXG4gICAgICAgICAgICB2YWx1ZUNsYXNzID0+ICFleGlzdGluZ0NsYXNzZXMuaW5jbHVkZXModmFsdWVDbGFzcyksXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gWy4uLmV4aXN0aW5nQ2xhc3NlcywgLi4uaW5zZXJ0Q2xhc3Nlc10uam9pbignICcpXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gW21lcmdlZEF0dHJpYnV0ZXNba2V5XSwgdmFsdWVdLmpvaW4oJzsgJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gbWVyZ2VkQXR0cmlidXRlc1xuICAgIH0sIHt9KVxufVxuIiwgImltcG9ydCB7IE1hcmssIE5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb25BdHRyaWJ1dGUgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9tZXJnZUF0dHJpYnV0ZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMoXG4gIG5vZGVPck1hcms6IE5vZGUgfCBNYXJrLFxuICBleHRlbnNpb25BdHRyaWJ1dGVzOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSxcbik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlc1xuICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJlZClcbiAgICAubWFwKGl0ZW0gPT4ge1xuICAgICAgaWYgKCFpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgW2l0ZW0ubmFtZV06IG5vZGVPck1hcmsuYXR0cnNbaXRlbS5uYW1lXSxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbS5hdHRyaWJ1dGUucmVuZGVySFRNTChub2RlT3JNYXJrLmF0dHJzKSB8fCB7fVxuICAgIH0pXG4gICAgLnJlZHVjZSgoYXR0cmlidXRlcywgYXR0cmlidXRlKSA9PiBtZXJnZUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgYXR0cmlidXRlKSwge30pXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWU6IGFueSk6IHZhbHVlIGlzIEZ1bmN0aW9uIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xufVxuIiwgImltcG9ydCB7IE1heWJlUmV0dXJuVHlwZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vaXNGdW5jdGlvbi5qcydcblxuLyoqXG4gKiBPcHRpb25hbGx5IGNhbGxzIGB2YWx1ZWAgYXMgYSBmdW5jdGlvbi5cbiAqIE90aGVyd2lzZSBpdCBpcyByZXR1cm5lZCBkaXJlY3RseS5cbiAqIEBwYXJhbSB2YWx1ZSBGdW5jdGlvbiBvciBhbnkgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dCBPcHRpb25hbCBjb250ZXh0IHRvIGJpbmQgdG8gZnVuY3Rpb24uXG4gKiBAcGFyYW0gcHJvcHMgT3B0aW9uYWwgcHJvcHMgdG8gcGFzcyB0byBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGxPclJldHVybjxUPih2YWx1ZTogVCwgY29udGV4dDogYW55ID0gdW5kZWZpbmVkLCAuLi5wcm9wczogYW55W10pOiBNYXliZVJldHVyblR5cGU8VD4ge1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHZhbHVlLmJpbmQoY29udGV4dCkoLi4ucHJvcHMpXG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlKC4uLnByb3BzKVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlIGFzIE1heWJlUmV0dXJuVHlwZTxUPlxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5T2JqZWN0KHZhbHVlID0ge30pOiBib29sZWFuIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDAgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdFxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlOiBhbnkpOiBhbnkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgaWYgKHZhbHVlLm1hdGNoKC9eWystXT8oPzpcXGQqXFwuKT9cXGQrJC8pKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJ3RydWUnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlXG59XG4iLCAiaW1wb3J0IHsgUGFyc2VSdWxlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRXh0ZW5zaW9uQXR0cmlidXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBmcm9tU3RyaW5nIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2Zyb21TdHJpbmcuanMnXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBtZXJnZXMgZXh0ZW5zaW9uIGF0dHJpYnV0ZXMgaW50byBwYXJzZXJ1bGUgYXR0cmlidXRlcyAoYGF0dHJzYCBvciBgZ2V0QXR0cnNgKS5cbiAqIENhbmNlbHMgd2hlbiBgZ2V0QXR0cnNgIHJldHVybmVkIGBmYWxzZWAuXG4gKiBAcGFyYW0gcGFyc2VSdWxlIFByb3NlTWlycm9yIFBhcnNlUnVsZVxuICogQHBhcmFtIGV4dGVuc2lvbkF0dHJpYnV0ZXMgTGlzdCBvZiBhdHRyaWJ1dGVzIHRvIGluamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKFxuICBwYXJzZVJ1bGU6IFBhcnNlUnVsZSxcbiAgZXh0ZW5zaW9uQXR0cmlidXRlczogRXh0ZW5zaW9uQXR0cmlidXRlW10sXG4pOiBQYXJzZVJ1bGUge1xuICBpZiAocGFyc2VSdWxlLnN0eWxlKSB7XG4gICAgcmV0dXJuIHBhcnNlUnVsZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJzZVJ1bGUsXG4gICAgZ2V0QXR0cnM6IG5vZGUgPT4ge1xuICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IHBhcnNlUnVsZS5nZXRBdHRycyA/IHBhcnNlUnVsZS5nZXRBdHRycyhub2RlKSA6IHBhcnNlUnVsZS5hdHRyc1xuXG4gICAgICBpZiAob2xkQXR0cmlidXRlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBleHRlbnNpb25BdHRyaWJ1dGVzLnJlZHVjZSgoaXRlbXMsIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUxcbiAgICAgICAgICA/IGl0ZW0uYXR0cmlidXRlLnBhcnNlSFRNTChub2RlIGFzIEhUTUxFbGVtZW50KVxuICAgICAgICAgIDogZnJvbVN0cmluZygobm9kZSBhcyBIVE1MRWxlbWVudCkuZ2V0QXR0cmlidXRlKGl0ZW0ubmFtZSkpXG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gaXRlbXNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uaXRlbXMsXG4gICAgICAgICAgW2l0ZW0ubmFtZV06IHZhbHVlLFxuICAgICAgICB9XG4gICAgICB9LCB7fSlcblxuICAgICAgcmV0dXJuIHsgLi4ub2xkQXR0cmlidXRlcywgLi4ubmV3QXR0cmlidXRlcyB9XG4gICAgfSxcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtTcGVjLCBOb2RlU3BlYywgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRWRpdG9yLCBNYXJrQ29uZmlnLCBOb2RlQ29uZmlnIH0gZnJvbSAnLi4vaW5kZXguanMnXG5pbXBvcnQgeyBBbnlDb25maWcsIEV4dGVuc2lvbnMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4uL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBpc0VtcHR5T2JqZWN0IH0gZnJvbSAnLi4vdXRpbGl0aWVzL2lzRW1wdHlPYmplY3QuanMnXG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMgfSBmcm9tICcuL2dldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucy5qcydcbmltcG9ydCB7IGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnLi9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IGdldFJlbmRlcmVkQXR0cmlidXRlcyB9IGZyb20gJy4vZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlIH0gZnJvbSAnLi9pbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUuanMnXG5pbXBvcnQgeyBzcGxpdEV4dGVuc2lvbnMgfSBmcm9tICcuL3NwbGl0RXh0ZW5zaW9ucy5qcydcblxuZnVuY3Rpb24gY2xlYW5VcFNjaGVtYUl0ZW08VD4oZGF0YTogVCkge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBPYmplY3QuZW50cmllcyhkYXRhKS5maWx0ZXIoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gJ2F0dHJzJyAmJiBpc0VtcHR5T2JqZWN0KHZhbHVlIGFzIHt9IHwgdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWRcbiAgICB9KSxcbiAgKSBhcyBUXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyhleHRlbnNpb25zOiBFeHRlbnNpb25zLCBlZGl0b3I/OiBFZGl0b3IpOiBTY2hlbWEge1xuICBjb25zdCBhbGxBdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zKGV4dGVuc2lvbnMpXG4gIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMsIG1hcmtFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9ucylcbiAgY29uc3QgdG9wTm9kZSA9IG5vZGVFeHRlbnNpb25zLmZpbmQoZXh0ZW5zaW9uID0+IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3RvcE5vZGUnKSk/Lm5hbWVcblxuICBjb25zdCBub2RlcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBub2RlRXh0ZW5zaW9ucy5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLmZpbHRlcihcbiAgICAgICAgYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSxcbiAgICAgIClcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgIGVkaXRvcixcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXh0cmFOb2RlRmllbGRzID0gZXh0ZW5zaW9ucy5yZWR1Y2UoKGZpZWxkcywgZSkgPT4ge1xuICAgICAgICBjb25zdCBleHRlbmROb2RlU2NoZW1hID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydleHRlbmROb2RlU2NoZW1hJ10+KFxuICAgICAgICAgIGUsXG4gICAgICAgICAgJ2V4dGVuZE5vZGVTY2hlbWEnLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAuLi4oZXh0ZW5kTm9kZVNjaGVtYSA/IGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSA6IHt9KSxcbiAgICAgICAgfVxuICAgICAgfSwge30pXG5cbiAgICAgIGNvbnN0IHNjaGVtYTogTm9kZVNwZWMgPSBjbGVhblVwU2NoZW1hSXRlbSh7XG4gICAgICAgIC4uLmV4dHJhTm9kZUZpZWxkcyxcbiAgICAgICAgY29udGVudDogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2NvbnRlbnQnXT4oZXh0ZW5zaW9uLCAnY29udGVudCcsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBtYXJrczogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ21hcmtzJ10+KGV4dGVuc2lvbiwgJ21hcmtzJywgY29udGV4dCkpLFxuICAgICAgICBncm91cDogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2dyb3VwJ10+KGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpLFxuICAgICAgICBpbmxpbmU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydpbmxpbmUnXT4oZXh0ZW5zaW9uLCAnaW5saW5lJywgY29udGV4dCkpLFxuICAgICAgICBhdG9tOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snYXRvbSddPihleHRlbnNpb24sICdhdG9tJywgY29udGV4dCkpLFxuICAgICAgICBzZWxlY3RhYmxlOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snc2VsZWN0YWJsZSddPihleHRlbnNpb24sICdzZWxlY3RhYmxlJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGRyYWdnYWJsZTogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2RyYWdnYWJsZSddPihleHRlbnNpb24sICdkcmFnZ2FibGUnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgY29kZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2NvZGUnXT4oZXh0ZW5zaW9uLCAnY29kZScsIGNvbnRleHQpKSxcbiAgICAgICAgZGVmaW5pbmc6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydkZWZpbmluZyddPihleHRlbnNpb24sICdkZWZpbmluZycsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBpc29sYXRpbmc6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydpc29sYXRpbmcnXT4oZXh0ZW5zaW9uLCAnaXNvbGF0aW5nJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGF0dHJzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5tYXAoZXh0ZW5zaW9uQXR0cmlidXRlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsIHsgZGVmYXVsdDogZXh0ZW5zaW9uQXR0cmlidXRlPy5hdHRyaWJ1dGU/LmRlZmF1bHQgfV1cbiAgICAgICAgICB9KSxcbiAgICAgICAgKSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHBhcnNlSFRNTCA9IGNhbGxPclJldHVybihcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1sncGFyc2VIVE1MJ10+KGV4dGVuc2lvbiwgJ3BhcnNlSFRNTCcsIGNvbnRleHQpLFxuICAgICAgKVxuXG4gICAgICBpZiAocGFyc2VIVE1MKSB7XG4gICAgICAgIHNjaGVtYS5wYXJzZURPTSA9IHBhcnNlSFRNTC5tYXAocGFyc2VSdWxlID0+IGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZShwYXJzZVJ1bGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZW5kZXJIVE1MID0gZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1sncmVuZGVySFRNTCddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAncmVuZGVySFRNTCcsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICAgIGlmIChyZW5kZXJIVE1MKSB7XG4gICAgICAgIHNjaGVtYS50b0RPTSA9IG5vZGUgPT4gcmVuZGVySFRNTCh7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBIVE1MQXR0cmlidXRlczogZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZW5kZXJUZXh0ID0gZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1sncmVuZGVyVGV4dCddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAncmVuZGVyVGV4dCcsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICAgIGlmIChyZW5kZXJUZXh0KSB7XG4gICAgICAgIHNjaGVtYS50b1RleHQgPSByZW5kZXJUZXh0XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV1cbiAgICB9KSxcbiAgKVxuXG4gIGNvbnN0IG1hcmtzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIG1hcmtFeHRlbnNpb25zLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMuZmlsdGVyKFxuICAgICAgICBhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLnR5cGUgPT09IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgKVxuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgZWRpdG9yLFxuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRyYU1hcmtGaWVsZHMgPSBleHRlbnNpb25zLnJlZHVjZSgoZmllbGRzLCBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuZE1hcmtTY2hlbWEgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2V4dGVuZE1hcmtTY2hlbWEnXT4oXG4gICAgICAgICAgZSxcbiAgICAgICAgICAnZXh0ZW5kTWFya1NjaGVtYScsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgIC4uLihleHRlbmRNYXJrU2NoZW1hID8gZXh0ZW5kTWFya1NjaGVtYShleHRlbnNpb24pIDoge30pLFxuICAgICAgICB9XG4gICAgICB9LCB7fSlcblxuICAgICAgY29uc3Qgc2NoZW1hOiBNYXJrU3BlYyA9IGNsZWFuVXBTY2hlbWFJdGVtKHtcbiAgICAgICAgLi4uZXh0cmFNYXJrRmllbGRzLFxuICAgICAgICBpbmNsdXNpdmU6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydpbmNsdXNpdmUnXT4oZXh0ZW5zaW9uLCAnaW5jbHVzaXZlJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGV4Y2x1ZGVzOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1snZXhjbHVkZXMnXT4oZXh0ZW5zaW9uLCAnZXhjbHVkZXMnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgZ3JvdXA6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydncm91cCddPihleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKSxcbiAgICAgICAgc3Bhbm5pbmc6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydzcGFubmluZyddPihleHRlbnNpb24sICdzcGFubmluZycsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1snY29kZSddPihleHRlbnNpb24sICdjb2RlJywgY29udGV4dCkpLFxuICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKGV4dGVuc2lvbkF0dHJpYnV0ZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbkF0dHJpYnV0ZS5uYW1lLCB7IGRlZmF1bHQ6IGV4dGVuc2lvbkF0dHJpYnV0ZT8uYXR0cmlidXRlPy5kZWZhdWx0IH1dXG4gICAgICAgICAgfSksXG4gICAgICAgICksXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBwYXJzZUhUTUwgPSBjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ3BhcnNlSFRNTCddPihleHRlbnNpb24sICdwYXJzZUhUTUwnLCBjb250ZXh0KSxcbiAgICAgIClcblxuICAgICAgaWYgKHBhcnNlSFRNTCkge1xuICAgICAgICBzY2hlbWEucGFyc2VET00gPSBwYXJzZUhUTUwubWFwKHBhcnNlUnVsZSA9PiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ3JlbmRlckhUTUwnXT4oXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgJ3JlbmRlckhUTUwnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAocmVuZGVySFRNTCkge1xuICAgICAgICBzY2hlbWEudG9ET00gPSBtYXJrID0+IHJlbmRlckhUTUwoe1xuICAgICAgICAgIG1hcmssXG4gICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhtYXJrLCBleHRlbnNpb25BdHRyaWJ1dGVzKSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgc2NoZW1hXVxuICAgIH0pLFxuICApXG5cbiAgcmV0dXJuIG5ldyBTY2hlbWEoe1xuICAgIHRvcE5vZGUsXG4gICAgbm9kZXMsXG4gICAgbWFya3MsXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIE5vZGVUeXBlLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZUJ5TmFtZShuYW1lOiBzdHJpbmcsIHNjaGVtYTogU2NoZW1hKTogTm9kZVR5cGUgfCBNYXJrVHlwZSB8IG51bGwge1xuICByZXR1cm4gc2NoZW1hLm5vZGVzW25hbWVdIHx8IHNjaGVtYS5tYXJrc1tuYW1lXSB8fCBudWxsXG59XG4iLCAiaW1wb3J0IHsgQW55RXh0ZW5zaW9uLCBFbmFibGVSdWxlcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uOiBBbnlFeHRlbnNpb24sIGVuYWJsZWQ6IEVuYWJsZVJ1bGVzKTogYm9vbGVhbiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGVuYWJsZWQpKSB7XG4gICAgcmV0dXJuIGVuYWJsZWQuc29tZShlbmFibGVkRXh0ZW5zaW9uID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgZW5hYmxlZEV4dGVuc2lvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBlbmFibGVkRXh0ZW5zaW9uXG4gICAgICAgIDogZW5hYmxlZEV4dGVuc2lvbi5uYW1lXG5cbiAgICAgIHJldHVybiBuYW1lID09PSBleHRlbnNpb24ubmFtZVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gZW5hYmxlZFxufVxuIiwgImltcG9ydCB7IFJlc29sdmVkUG9zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGNvbnN0IGdldFRleHRDb250ZW50RnJvbU5vZGVzID0gKCRmcm9tOiBSZXNvbHZlZFBvcywgbWF4TWF0Y2ggPSA1MDApID0+IHtcbiAgbGV0IHRleHRCZWZvcmUgPSAnJ1xuXG4gIGNvbnN0IHNsaWNlRW5kUG9zID0gJGZyb20ucGFyZW50T2Zmc2V0XG5cbiAgJGZyb20ucGFyZW50Lm5vZGVzQmV0d2VlbihcbiAgICBNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIG1heE1hdGNoKSxcbiAgICBzbGljZUVuZFBvcyxcbiAgICAobm9kZSwgcG9zLCBwYXJlbnQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjaHVuayA9IG5vZGUudHlwZS5zcGVjLnRvVGV4dD8uKHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgcG9zLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIGluZGV4LFxuICAgICAgfSlcbiAgICAgICAgfHwgbm9kZS50ZXh0Q29udGVudFxuICAgICAgICB8fCAnJWxlYWYlJ1xuXG4gICAgICB0ZXh0QmVmb3JlICs9IGNodW5rLnNsaWNlKDAsIE1hdGgubWF4KDAsIHNsaWNlRW5kUG9zIC0gcG9zKSlcbiAgICB9LFxuICApXG5cbiAgcmV0dXJuIHRleHRCZWZvcmVcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNSZWdFeHAodmFsdWU6IGFueSk6IHZhbHVlIGlzIFJlZ0V4cCB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlLCBQbHVnaW4sIFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBDb21tYW5kTWFuYWdlciB9IGZyb20gJy4vQ29tbWFuZE1hbmFnZXIuanMnXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGNyZWF0ZUNoYWluYWJsZVN0YXRlIH0gZnJvbSAnLi9oZWxwZXJzL2NyZWF0ZUNoYWluYWJsZVN0YXRlLmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMgfSBmcm9tICcuL2hlbHBlcnMvZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMuanMnXG5pbXBvcnQge1xuICBDYW5Db21tYW5kcyxcbiAgQ2hhaW5lZENvbW1hbmRzLFxuICBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXksXG4gIFJhbmdlLFxuICBTaW5nbGVDb21tYW5kcyxcbn0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGlzUmVnRXhwIH0gZnJvbSAnLi91dGlsaXRpZXMvaXNSZWdFeHAuanMnXG5cbmV4cG9ydCB0eXBlIElucHV0UnVsZU1hdGNoID0ge1xuICBpbmRleDogbnVtYmVyXG4gIHRleHQ6IHN0cmluZ1xuICByZXBsYWNlV2l0aD86IHN0cmluZ1xuICBtYXRjaD86IFJlZ0V4cE1hdGNoQXJyYXlcbiAgZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuZXhwb3J0IHR5cGUgSW5wdXRSdWxlRmluZGVyID0gUmVnRXhwIHwgKCh0ZXh0OiBzdHJpbmcpID0+IElucHV0UnVsZU1hdGNoIHwgbnVsbClcblxuZXhwb3J0IGNsYXNzIElucHV0UnVsZSB7XG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlclxuXG4gIGhhbmRsZXI6IChwcm9wczoge1xuICAgIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICAgIHJhbmdlOiBSYW5nZVxuICAgIG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXlcbiAgICBjb21tYW5kczogU2luZ2xlQ29tbWFuZHNcbiAgICBjaGFpbjogKCkgPT4gQ2hhaW5lZENvbW1hbmRzXG4gICAgY2FuOiAoKSA9PiBDYW5Db21tYW5kc1xuICB9KSA9PiB2b2lkIHwgbnVsbFxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzoge1xuICAgIGZpbmQ6IElucHV0UnVsZUZpbmRlclxuICAgIGhhbmRsZXI6IChwcm9wczoge1xuICAgICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgICByYW5nZTogUmFuZ2VcbiAgICAgIG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXlcbiAgICAgIGNvbW1hbmRzOiBTaW5nbGVDb21tYW5kc1xuICAgICAgY2hhaW46ICgpID0+IENoYWluZWRDb21tYW5kc1xuICAgICAgY2FuOiAoKSA9PiBDYW5Db21tYW5kc1xuICAgIH0pID0+IHZvaWQgfCBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmZpbmQgPSBjb25maWcuZmluZFxuICAgIHRoaXMuaGFuZGxlciA9IGNvbmZpZy5oYW5kbGVyXG4gIH1cbn1cblxuY29uc3QgaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIgPSAoXG4gIHRleHQ6IHN0cmluZyxcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyLFxuKTogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IHwgbnVsbCA9PiB7XG4gIGlmIChpc1JlZ0V4cChmaW5kKSkge1xuICAgIHJldHVybiBmaW5kLmV4ZWModGV4dClcbiAgfVxuXG4gIGNvbnN0IGlucHV0UnVsZU1hdGNoID0gZmluZCh0ZXh0KVxuXG4gIGlmICghaW5wdXRSdWxlTWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgcmVzdWx0OiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgPSBbaW5wdXRSdWxlTWF0Y2gudGV4dF1cblxuICByZXN1bHQuaW5kZXggPSBpbnB1dFJ1bGVNYXRjaC5pbmRleFxuICByZXN1bHQuaW5wdXQgPSB0ZXh0XG4gIHJlc3VsdC5kYXRhID0gaW5wdXRSdWxlTWF0Y2guZGF0YVxuXG4gIGlmIChpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkge1xuICAgIGlmICghaW5wdXRSdWxlTWF0Y2gudGV4dC5pbmNsdWRlcyhpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1t0aXB0YXAgd2Fybl06IFwiaW5wdXRSdWxlTWF0Y2gucmVwbGFjZVdpdGhcIiBtdXN0IGJlIHBhcnQgb2YgXCJpbnB1dFJ1bGVNYXRjaC50ZXh0XCIuJyxcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gcnVuKGNvbmZpZzoge1xuICBlZGl0b3I6IEVkaXRvclxuICBmcm9tOiBudW1iZXJcbiAgdG86IG51bWJlclxuICB0ZXh0OiBzdHJpbmdcbiAgcnVsZXM6IElucHV0UnVsZVtdXG4gIHBsdWdpbjogUGx1Z2luXG59KTogYm9vbGVhbiB7XG4gIGNvbnN0IHtcbiAgICBlZGl0b3IsIGZyb20sIHRvLCB0ZXh0LCBydWxlcywgcGx1Z2luLFxuICB9ID0gY29uZmlnXG4gIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yXG5cbiAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCAkZnJvbSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSlcblxuICBpZiAoXG4gICAgLy8gY2hlY2sgZm9yIGNvZGUgbm9kZVxuICAgICRmcm9tLnBhcmVudC50eXBlLnNwZWMuY29kZVxuICAgIC8vIGNoZWNrIGZvciBjb2RlIG1hcmtcbiAgICB8fCAhISgkZnJvbS5ub2RlQmVmb3JlIHx8ICRmcm9tLm5vZGVBZnRlcik/Lm1hcmtzLmZpbmQobWFyayA9PiBtYXJrLnR5cGUuc3BlYy5jb2RlKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGxldCBtYXRjaGVkID0gZmFsc2VcblxuICBjb25zdCB0ZXh0QmVmb3JlID0gZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMoJGZyb20pICsgdGV4dFxuXG4gIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoID0gaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIodGV4dEJlZm9yZSwgcnVsZS5maW5kKVxuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyXG4gICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICBzdGF0ZTogdmlldy5zdGF0ZSxcbiAgICAgIHRyYW5zYWN0aW9uOiB0cixcbiAgICB9KVxuICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgZnJvbTogZnJvbSAtIChtYXRjaFswXS5sZW5ndGggLSB0ZXh0Lmxlbmd0aCksXG4gICAgICB0byxcbiAgICB9XG5cbiAgICBjb25zdCB7IGNvbW1hbmRzLCBjaGFpbiwgY2FuIH0gPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgICAgZWRpdG9yLFxuICAgICAgc3RhdGUsXG4gICAgfSlcblxuICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgc3RhdGUsXG4gICAgICByYW5nZSxcbiAgICAgIG1hdGNoLFxuICAgICAgY29tbWFuZHMsXG4gICAgICBjaGFpbixcbiAgICAgIGNhbixcbiAgICB9KVxuXG4gICAgLy8gc3RvcCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlc1xuICAgIGlmIChoYW5kbGVyID09PSBudWxsIHx8ICF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHN0b3JlIHRyYW5zZm9ybSBhcyBtZXRhIGRhdGFcbiAgICAvLyBzbyB3ZSBjYW4gdW5kbyBpbnB1dCBydWxlcyB3aXRoaW4gdGhlIGB1bmRvSW5wdXRSdWxlc2AgY29tbWFuZFxuICAgIHRyLnNldE1ldGEocGx1Z2luLCB7XG4gICAgICB0cmFuc2Zvcm06IHRyLFxuICAgICAgZnJvbSxcbiAgICAgIHRvLFxuICAgICAgdGV4dCxcbiAgICB9KVxuXG4gICAgdmlldy5kaXNwYXRjaCh0cilcbiAgICBtYXRjaGVkID0gdHJ1ZVxuICB9KVxuXG4gIHJldHVybiBtYXRjaGVkXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGlucHV0IHJ1bGVzIHBsdWdpbi4gV2hlbiBlbmFibGVkLCBpdCB3aWxsIGNhdXNlIHRleHRcbiAqIGlucHV0IHRoYXQgbWF0Y2hlcyBhbnkgb2YgdGhlIGdpdmVuIHJ1bGVzIHRvIHRyaWdnZXIgdGhlIHJ1bGXigJlzXG4gKiBhY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnB1dFJ1bGVzUGx1Z2luKHByb3BzOiB7IGVkaXRvcjogRWRpdG9yOyBydWxlczogSW5wdXRSdWxlW10gfSk6IFBsdWdpbiB7XG4gIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHNcbiAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbih7XG4gICAgc3RhdGU6IHtcbiAgICAgIGluaXQoKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9LFxuICAgICAgYXBwbHkodHIsIHByZXYpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVkID0gdHIuZ2V0TWV0YShwbHVnaW4pXG5cbiAgICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICAgIHJldHVybiBzdG9yZWRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ci5zZWxlY3Rpb25TZXQgfHwgdHIuZG9jQ2hhbmdlZCA/IG51bGwgOiBwcmV2XG4gICAgICB9LFxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlVGV4dElucHV0KHZpZXcsIGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiBydW4oe1xuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRvLFxuICAgICAgICAgIHRleHQsXG4gICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgcGx1Z2luLFxuICAgICAgICB9KVxuICAgICAgfSxcblxuICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgIGNvbXBvc2l0aW9uZW5kOiB2aWV3ID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvblxuXG4gICAgICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgICAgICBydW4oe1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICBmcm9tOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgICAgICB0bzogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICAgICAgcGx1Z2luLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSxcbiAgICAgIH0sXG5cbiAgICAgIC8vIGFkZCBzdXBwb3J0IGZvciBpbnB1dCBydWxlcyB0byB0cmlnZ2VyIG9uIGVudGVyXG4gICAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3IgZXhhbXBsZSBmb3IgY29kZSBibG9ja3NcbiAgICAgIGhhbmRsZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSAhPT0gJ0VudGVyJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uXG5cbiAgICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgICByZXR1cm4gcnVuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGZyb206ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgdG86ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgdGV4dDogJ1xcbicsXG4gICAgICAgICAgICBydWxlcyxcbiAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9LFxuICAgIH0sXG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaXNJbnB1dFJ1bGVzOiB0cnVlLFxuICB9KSBhcyBQbHVnaW5cblxuICByZXR1cm4gcGx1Z2luXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBudW1iZXIge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlLCBQbHVnaW4gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBDb21tYW5kTWFuYWdlciB9IGZyb20gJy4vQ29tbWFuZE1hbmFnZXIuanMnXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGNyZWF0ZUNoYWluYWJsZVN0YXRlIH0gZnJvbSAnLi9oZWxwZXJzL2NyZWF0ZUNoYWluYWJsZVN0YXRlLmpzJ1xuaW1wb3J0IHtcbiAgQ2FuQ29tbWFuZHMsXG4gIENoYWluZWRDb21tYW5kcyxcbiAgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5LFxuICBSYW5nZSxcbiAgU2luZ2xlQ29tbWFuZHMsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc051bWJlciB9IGZyb20gJy4vdXRpbGl0aWVzL2lzTnVtYmVyLmpzJ1xuaW1wb3J0IHsgaXNSZWdFeHAgfSBmcm9tICcuL3V0aWxpdGllcy9pc1JlZ0V4cC5qcydcblxuZXhwb3J0IHR5cGUgUGFzdGVSdWxlTWF0Y2ggPSB7XG4gIGluZGV4OiBudW1iZXJcbiAgdGV4dDogc3RyaW5nXG4gIHJlcGxhY2VXaXRoPzogc3RyaW5nXG4gIG1hdGNoPzogUmVnRXhwTWF0Y2hBcnJheVxuICBkYXRhPzogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5leHBvcnQgdHlwZSBQYXN0ZVJ1bGVGaW5kZXIgPSBSZWdFeHAgfCAoKHRleHQ6IHN0cmluZywgZXZlbnQ/OiBDbGlwYm9hcmRFdmVudCkgPT4gUGFzdGVSdWxlTWF0Y2hbXSB8IG51bGwgfCB1bmRlZmluZWQpXG5cbmV4cG9ydCBjbGFzcyBQYXN0ZVJ1bGUge1xuICBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXJcblxuICBoYW5kbGVyOiAocHJvcHM6IHtcbiAgICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgICByYW5nZTogUmFuZ2VcbiAgICBtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5XG4gICAgY29tbWFuZHM6IFNpbmdsZUNvbW1hbmRzXG4gICAgY2hhaW46ICgpID0+IENoYWluZWRDb21tYW5kc1xuICAgIGNhbjogKCkgPT4gQ2FuQ29tbWFuZHNcbiAgICBwYXN0ZUV2ZW50OiBDbGlwYm9hcmRFdmVudFxuICAgIGRyb3BFdmVudDogRHJhZ0V2ZW50XG4gIH0pID0+IHZvaWQgfCBudWxsXG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiB7XG4gICAgZmluZDogUGFzdGVSdWxlRmluZGVyXG4gICAgaGFuZGxlcjogKHByb3BzOiB7XG4gICAgICBjYW46ICgpID0+IENhbkNvbW1hbmRzXG4gICAgICBjaGFpbjogKCkgPT4gQ2hhaW5lZENvbW1hbmRzXG4gICAgICBjb21tYW5kczogU2luZ2xlQ29tbWFuZHNcbiAgICAgIGRyb3BFdmVudDogRHJhZ0V2ZW50XG4gICAgICBtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5XG4gICAgICBwYXN0ZUV2ZW50OiBDbGlwYm9hcmRFdmVudFxuICAgICAgcmFuZ2U6IFJhbmdlXG4gICAgICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgICB9KSA9PiB2b2lkIHwgbnVsbFxuICB9KSB7XG4gICAgdGhpcy5maW5kID0gY29uZmlnLmZpbmRcbiAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlclxuICB9XG59XG5cbmNvbnN0IHBhc3RlUnVsZU1hdGNoZXJIYW5kbGVyID0gKFxuICB0ZXh0OiBzdHJpbmcsXG4gIGZpbmQ6IFBhc3RlUnVsZUZpbmRlcixcbiAgZXZlbnQ/OiBDbGlwYm9hcmRFdmVudCxcbik6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheVtdID0+IHtcbiAgaWYgKGlzUmVnRXhwKGZpbmQpKSB7XG4gICAgcmV0dXJuIFsuLi50ZXh0Lm1hdGNoQWxsKGZpbmQpXVxuICB9XG5cbiAgY29uc3QgbWF0Y2hlcyA9IGZpbmQodGV4dCwgZXZlbnQpXG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcy5tYXAocGFzdGVSdWxlTWF0Y2ggPT4ge1xuICAgIGNvbnN0IHJlc3VsdDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5ID0gW3Bhc3RlUnVsZU1hdGNoLnRleHRdXG5cbiAgICByZXN1bHQuaW5kZXggPSBwYXN0ZVJ1bGVNYXRjaC5pbmRleFxuICAgIHJlc3VsdC5pbnB1dCA9IHRleHRcbiAgICByZXN1bHQuZGF0YSA9IHBhc3RlUnVsZU1hdGNoLmRhdGFcblxuICAgIGlmIChwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkge1xuICAgICAgaWYgKCFwYXN0ZVJ1bGVNYXRjaC50ZXh0LmluY2x1ZGVzKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1t0aXB0YXAgd2Fybl06IFwicGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGhcIiBtdXN0IGJlIHBhcnQgb2YgXCJwYXN0ZVJ1bGVNYXRjaC50ZXh0XCIuJyxcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICByZXN1bHQucHVzaChwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJ1bihjb25maWc6IHtcbiAgZWRpdG9yOiBFZGl0b3JcbiAgc3RhdGU6IEVkaXRvclN0YXRlXG4gIGZyb206IG51bWJlclxuICB0bzogbnVtYmVyXG4gIHJ1bGU6IFBhc3RlUnVsZVxuICBwYXN0ZUV2ZW50OiBDbGlwYm9hcmRFdmVudFxuICBkcm9wRXZlbnQ6IERyYWdFdmVudFxufSk6IGJvb2xlYW4ge1xuICBjb25zdCB7XG4gICAgZWRpdG9yLCBzdGF0ZSwgZnJvbSwgdG8sIHJ1bGUsIHBhc3RlRXZlbnQsIGRyb3BFdmVudCxcbiAgfSA9IGNvbmZpZ1xuXG4gIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgZWRpdG9yLFxuICAgIHN0YXRlLFxuICB9KVxuXG4gIGNvbnN0IGhhbmRsZXJzOiAodm9pZCB8IG51bGwpW10gPSBbXVxuXG4gIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICBpZiAoIW5vZGUuaXNUZXh0YmxvY2sgfHwgbm9kZS50eXBlLnNwZWMuY29kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVzb2x2ZWRGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKVxuICAgIGNvbnN0IHJlc29sdmVkVG8gPSBNYXRoLm1pbih0bywgcG9zICsgbm9kZS5jb250ZW50LnNpemUpXG4gICAgY29uc3QgdGV4dFRvTWF0Y2ggPSBub2RlLnRleHRCZXR3ZWVuKHJlc29sdmVkRnJvbSAtIHBvcywgcmVzb2x2ZWRUbyAtIHBvcywgdW5kZWZpbmVkLCAnXFx1ZmZmYycpXG5cbiAgICBjb25zdCBtYXRjaGVzID0gcGFzdGVSdWxlTWF0Y2hlckhhbmRsZXIodGV4dFRvTWF0Y2gsIHJ1bGUuZmluZCwgcGFzdGVFdmVudClcblxuICAgIG1hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICBpZiAobWF0Y2guaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhcnQgPSByZXNvbHZlZEZyb20gKyBtYXRjaC5pbmRleCArIDFcbiAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgZnJvbTogc3RhdGUudHIubWFwcGluZy5tYXAoc3RhcnQpLFxuICAgICAgICB0bzogc3RhdGUudHIubWFwcGluZy5tYXAoZW5kKSxcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGFuZGxlciA9IHJ1bGUuaGFuZGxlcih7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICByYW5nZSxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGNvbW1hbmRzLFxuICAgICAgICBjaGFpbixcbiAgICAgICAgY2FuLFxuICAgICAgICBwYXN0ZUV2ZW50LFxuICAgICAgICBkcm9wRXZlbnQsXG4gICAgICB9KVxuXG4gICAgICBoYW5kbGVycy5wdXNoKGhhbmRsZXIpXG4gICAgfSlcbiAgfSlcblxuICBjb25zdCBzdWNjZXNzID0gaGFuZGxlcnMuZXZlcnkoaGFuZGxlciA9PiBoYW5kbGVyICE9PSBudWxsKVxuXG4gIHJldHVybiBzdWNjZXNzXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIHBhc3RlIHJ1bGVzIHBsdWdpbi4gV2hlbiBlbmFibGVkLCBpdCB3aWxsIGNhdXNlIHBhc3RlZFxuICogdGV4dCB0aGF0IG1hdGNoZXMgYW55IG9mIHRoZSBnaXZlbiBydWxlcyB0byB0cmlnZ2VyIHRoZSBydWxl4oCZc1xuICogYWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFzdGVSdWxlc1BsdWdpbihwcm9wczogeyBlZGl0b3I6IEVkaXRvcjsgcnVsZXM6IFBhc3RlUnVsZVtdIH0pOiBQbHVnaW5bXSB7XG4gIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHNcbiAgbGV0IGRyYWdTb3VyY2VFbGVtZW50OiBFbGVtZW50IHwgbnVsbCA9IG51bGxcbiAgbGV0IGlzUGFzdGVkRnJvbVByb3NlTWlycm9yID0gZmFsc2VcbiAgbGV0IGlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlXG4gIGxldCBwYXN0ZUV2ZW50ID0gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScpXG4gIGxldCBkcm9wRXZlbnQgPSBuZXcgRHJhZ0V2ZW50KCdkcm9wJylcblxuICBjb25zdCBwbHVnaW5zID0gcnVsZXMubWFwKHJ1bGUgPT4ge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgIC8vIHdlIHJlZ2lzdGVyIGEgZ2xvYmFsIGRyYWcgaGFuZGxlciB0byB0cmFjayB0aGUgY3VycmVudCBkcmFnIHNvdXJjZSBlbGVtZW50XG4gICAgICB2aWV3KHZpZXcpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlRHJhZ3N0YXJ0ID0gKGV2ZW50OiBEcmFnRXZlbnQpID0+IHtcbiAgICAgICAgICBkcmFnU291cmNlRWxlbWVudCA9IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQ/LmNvbnRhaW5zKGV2ZW50LnRhcmdldCBhcyBFbGVtZW50KVxuICAgICAgICAgICAgPyB2aWV3LmRvbS5wYXJlbnRFbGVtZW50XG4gICAgICAgICAgICA6IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnc3RhcnQpXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIGhhbmRsZURyYWdzdGFydClcbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICBkcm9wOiAodmlldywgZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3IgPSBkcmFnU291cmNlRWxlbWVudCA9PT0gdmlldy5kb20ucGFyZW50RWxlbWVudFxuICAgICAgICAgICAgZHJvcEV2ZW50ID0gZXZlbnQgYXMgRHJhZ0V2ZW50XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBwYXN0ZTogKF92aWV3LCBldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAoZXZlbnQgYXMgQ2xpcGJvYXJkRXZlbnQpLmNsaXBib2FyZERhdGE/LmdldERhdGEoJ3RleHQvaHRtbCcpXG5cbiAgICAgICAgICAgIHBhc3RlRXZlbnQgPSBldmVudCBhcyBDbGlwYm9hcmRFdmVudFxuXG4gICAgICAgICAgICBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9ICEhaHRtbD8uaW5jbHVkZXMoJ2RhdGEtcG0tc2xpY2UnKVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcblxuICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uc1swXVxuICAgICAgICBjb25zdCBpc1Bhc3RlID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgndWlFdmVudCcpID09PSAncGFzdGUnICYmICFpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvclxuICAgICAgICBjb25zdCBpc0Ryb3AgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCd1aUV2ZW50JykgPT09ICdkcm9wJyAmJiAhaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yXG5cbiAgICAgICAgaWYgKCFpc1Bhc3RlICYmICFpc0Ryb3ApIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3AgaWYgdGhlcmUgaXMgbm8gY2hhbmdlZCByYW5nZVxuICAgICAgICBjb25zdCBmcm9tID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZTdGFydChzdGF0ZS5kb2MuY29udGVudClcbiAgICAgICAgY29uc3QgdG8gPSBvbGRTdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZkVuZChzdGF0ZS5kb2MuY29udGVudClcblxuICAgICAgICBpZiAoIWlzTnVtYmVyKGZyb20pIHx8ICF0byB8fCBmcm9tID09PSB0by5iKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBidWlsZCBhIGNoYWluYWJsZSBzdGF0ZVxuICAgICAgICAvLyBzbyB3ZSBjYW4gdXNlIGEgc2luZ2xlIHRyYW5zYWN0aW9uIGZvciBhbGwgcGFzdGUgcnVsZXNcbiAgICAgICAgY29uc3QgdHIgPSBzdGF0ZS50clxuICAgICAgICBjb25zdCBjaGFpbmFibGVTdGF0ZSA9IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHJ1bih7XG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIHN0YXRlOiBjaGFpbmFibGVTdGF0ZSxcbiAgICAgICAgICBmcm9tOiBNYXRoLm1heChmcm9tIC0gMSwgMCksXG4gICAgICAgICAgdG86IHRvLmIgLSAxLFxuICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgcGFzdGVFdmVudCxcbiAgICAgICAgICBkcm9wRXZlbnQsXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gc3RvcCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlc1xuICAgICAgICBpZiAoIWhhbmRsZXIgfHwgIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgZHJvcEV2ZW50ID0gbmV3IERyYWdFdmVudCgnZHJvcCcpXG4gICAgICAgIHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJylcblxuICAgICAgICByZXR1cm4gdHJcbiAgICAgIH0sXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gcGx1Z2luc1xufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBmaW5kRHVwbGljYXRlcyhpdGVtczogYW55W10pOiBhbnlbXSB7XG4gIGNvbnN0IGZpbHRlcmVkID0gaXRlbXMuZmlsdGVyKChlbCwgaW5kZXgpID0+IGl0ZW1zLmluZGV4T2YoZWwpICE9PSBpbmRleClcblxuICByZXR1cm4gWy4uLm5ldyBTZXQoZmlsdGVyZWQpXVxufVxuIiwgImltcG9ydCB7IGtleW1hcCB9IGZyb20gJ0B0aXB0YXAvcG0va2V5bWFwJ1xuaW1wb3J0IHsgTm9kZSBhcyBQcm9zZW1pcnJvck5vZGUsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRWRpdG9yVmlldyB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMgfSBmcm9tICcuL2hlbHBlcnMvZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zLmpzJ1xuaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGdldFJlbmRlcmVkQXR0cmlidXRlcyB9IGZyb20gJy4vaGVscGVycy9nZXRSZW5kZXJlZEF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyB9IGZyb20gJy4vaGVscGVycy9nZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucy5qcydcbmltcG9ydCB7IGdldFNjaGVtYVR5cGVCeU5hbWUgfSBmcm9tICcuL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZUJ5TmFtZS5qcydcbmltcG9ydCB7IGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkIH0gZnJvbSAnLi9oZWxwZXJzL2lzRXh0ZW5zaW9uUnVsZXNFbmFibGVkLmpzJ1xuaW1wb3J0IHsgc3BsaXRFeHRlbnNpb25zIH0gZnJvbSAnLi9oZWxwZXJzL3NwbGl0RXh0ZW5zaW9ucy5qcydcbmltcG9ydCB7IE1hcmssIE5vZGVDb25maWcgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHsgaW5wdXRSdWxlc1BsdWdpbiB9IGZyb20gJy4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgcGFzdGVSdWxlc1BsdWdpbiB9IGZyb20gJy4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHsgQW55Q29uZmlnLCBFeHRlbnNpb25zLCBSYXdDb21tYW5kcyB9IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBmaW5kRHVwbGljYXRlcyB9IGZyb20gJy4vdXRpbGl0aWVzL2ZpbmREdXBsaWNhdGVzLmpzJ1xuXG5leHBvcnQgY2xhc3MgRXh0ZW5zaW9uTWFuYWdlciB7XG4gIGVkaXRvcjogRWRpdG9yXG5cbiAgc2NoZW1hOiBTY2hlbWFcblxuICBleHRlbnNpb25zOiBFeHRlbnNpb25zXG5cbiAgc3BsaXR0YWJsZU1hcmtzOiBzdHJpbmdbXSA9IFtdXG5cbiAgY29uc3RydWN0b3IoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucywgZWRpdG9yOiBFZGl0b3IpIHtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIucmVzb2x2ZShleHRlbnNpb25zKVxuICAgIHRoaXMuc2NoZW1hID0gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zLCBlZGl0b3IpXG5cbiAgICB0aGlzLmV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgLy8gc3RvcmUgZXh0ZW5zaW9uIHN0b3JhZ2UgaW4gZWRpdG9yXG4gICAgICB0aGlzLmVkaXRvci5leHRlbnNpb25TdG9yYWdlW2V4dGVuc2lvbi5uYW1lXSA9IGV4dGVuc2lvbi5zdG9yYWdlXG5cbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcbiAgICAgIH1cblxuICAgICAgaWYgKGV4dGVuc2lvbi50eXBlID09PSAnbWFyaycpIHtcbiAgICAgICAgY29uc3Qga2VlcE9uU3BsaXQgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAna2VlcE9uU3BsaXQnLCBjb250ZXh0KSkgPz8gdHJ1ZVxuXG4gICAgICAgIGlmIChrZWVwT25TcGxpdCkge1xuICAgICAgICAgIHRoaXMuc3BsaXR0YWJsZU1hcmtzLnB1c2goZXh0ZW5zaW9uLm5hbWUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25CZWZvcmVDcmVhdGUgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uQmVmb3JlQ3JlYXRlJ10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdvbkJlZm9yZUNyZWF0ZScsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICAgIGlmIChvbkJlZm9yZUNyZWF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignYmVmb3JlQ3JlYXRlJywgb25CZWZvcmVDcmVhdGUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uQ3JlYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkNyZWF0ZSddPihleHRlbnNpb24sICdvbkNyZWF0ZScsIGNvbnRleHQpXG5cbiAgICAgIGlmIChvbkNyZWF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignY3JlYXRlJywgb25DcmVhdGUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uVXBkYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvblVwZGF0ZSddPihleHRlbnNpb24sICdvblVwZGF0ZScsIGNvbnRleHQpXG5cbiAgICAgIGlmIChvblVwZGF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbigndXBkYXRlJywgb25VcGRhdGUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uU2VsZWN0aW9uVXBkYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvblNlbGVjdGlvblVwZGF0ZSddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAnb25TZWxlY3Rpb25VcGRhdGUnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAob25TZWxlY3Rpb25VcGRhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3NlbGVjdGlvblVwZGF0ZScsIG9uU2VsZWN0aW9uVXBkYXRlKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvblRyYW5zYWN0aW9uID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvblRyYW5zYWN0aW9uJ10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdvblRyYW5zYWN0aW9uJyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKG9uVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3RyYW5zYWN0aW9uJywgb25UcmFuc2FjdGlvbilcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25Gb2N1cyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25Gb2N1cyddPihleHRlbnNpb24sICdvbkZvY3VzJywgY29udGV4dClcblxuICAgICAgaWYgKG9uRm9jdXMpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2ZvY3VzJywgb25Gb2N1cylcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25CbHVyID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkJsdXInXT4oZXh0ZW5zaW9uLCAnb25CbHVyJywgY29udGV4dClcblxuICAgICAgaWYgKG9uQmx1cikge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignYmx1cicsIG9uQmx1cilcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25EZXN0cm95ID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkRlc3Ryb3knXT4oZXh0ZW5zaW9uLCAnb25EZXN0cm95JywgY29udGV4dClcblxuICAgICAgaWYgKG9uRGVzdHJveSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignZGVzdHJveScsIG9uRGVzdHJveSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIHJlc29sdmUoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IEV4dGVuc2lvbnMge1xuICAgIGNvbnN0IHJlc29sdmVkRXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIuc29ydChFeHRlbnNpb25NYW5hZ2VyLmZsYXR0ZW4oZXh0ZW5zaW9ucykpXG4gICAgY29uc3QgZHVwbGljYXRlZE5hbWVzID0gZmluZER1cGxpY2F0ZXMocmVzb2x2ZWRFeHRlbnNpb25zLm1hcChleHRlbnNpb24gPT4gZXh0ZW5zaW9uLm5hbWUpKVxuXG4gICAgaWYgKGR1cGxpY2F0ZWROYW1lcy5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFt0aXB0YXAgd2Fybl06IER1cGxpY2F0ZSBleHRlbnNpb24gbmFtZXMgZm91bmQ6IFske2R1cGxpY2F0ZWROYW1lc1xuICAgICAgICAgIC5tYXAoaXRlbSA9PiBgJyR7aXRlbX0nYClcbiAgICAgICAgICAuam9pbignLCAnKX1dLiBUaGlzIGNhbiBsZWFkIHRvIGlzc3Vlcy5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiByZXNvbHZlZEV4dGVuc2lvbnNcbiAgfVxuXG4gIHN0YXRpYyBmbGF0dGVuKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBFeHRlbnNpb25zIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXh0ZW5zaW9uc1xuICAgICAgICAubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBhZGRFeHRlbnNpb25zID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRFeHRlbnNpb25zJ10+KFxuICAgICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICAgJ2FkZEV4dGVuc2lvbnMnLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICApXG5cbiAgICAgICAgICBpZiAoYWRkRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIFtleHRlbnNpb24sIC4uLnRoaXMuZmxhdHRlbihhZGRFeHRlbnNpb25zKCkpXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBleHRlbnNpb25cbiAgICAgICAgfSlcbiAgICAgICAgLy8gYEluZmluaXR5YCB3aWxsIGJyZWFrIFR5cGVTY3JpcHQgc28gd2Ugc2V0IGEgbnVtYmVyIHRoYXQgaXMgcHJvYmFibHkgaGlnaCBlbm91Z2hcbiAgICAgICAgLmZsYXQoMTApXG4gICAgKVxuICB9XG5cbiAgc3RhdGljIHNvcnQoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IEV4dGVuc2lvbnMge1xuICAgIGNvbnN0IGRlZmF1bHRQcmlvcml0eSA9IDEwMFxuXG4gICAgcmV0dXJuIGV4dGVuc2lvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgcHJpb3JpdHlBID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydwcmlvcml0eSddPihhLCAncHJpb3JpdHknKSB8fCBkZWZhdWx0UHJpb3JpdHlcbiAgICAgIGNvbnN0IHByaW9yaXR5QiA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1sncHJpb3JpdHknXT4oYiwgJ3ByaW9yaXR5JykgfHwgZGVmYXVsdFByaW9yaXR5XG5cbiAgICAgIGlmIChwcmlvcml0eUEgPiBwcmlvcml0eUIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG5cbiAgICAgIGlmIChwcmlvcml0eUEgPCBwcmlvcml0eUIpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDBcbiAgICB9KVxuICB9XG5cbiAgZ2V0IGNvbW1hbmRzKCk6IFJhd0NvbW1hbmRzIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zLnJlZHVjZSgoY29tbWFuZHMsIGV4dGVuc2lvbikgPT4ge1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgfVxuXG4gICAgICBjb25zdCBhZGRDb21tYW5kcyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkQ29tbWFuZHMnXT4oXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgJ2FkZENvbW1hbmRzJyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKCFhZGRDb21tYW5kcykge1xuICAgICAgICByZXR1cm4gY29tbWFuZHNcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29tbWFuZHMsXG4gICAgICAgIC4uLmFkZENvbW1hbmRzKCksXG4gICAgICB9XG4gICAgfSwge30gYXMgUmF3Q29tbWFuZHMpXG4gIH1cblxuICBnZXQgcGx1Z2lucygpOiBQbHVnaW5bXSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXNcblxuICAgIC8vIFdpdGggUHJvc2VNaXJyb3IsIGZpcnN0IHBsdWdpbnMgd2l0aGluIGFuIGFycmF5IGFyZSBleGVjdXRlZCBmaXJzdC5cbiAgICAvLyBJbiBUaXB0YXAsIHdlIHByb3ZpZGUgdGhlIGFiaWxpdHkgdG8gb3ZlcnJpZGUgcGx1Z2lucyxcbiAgICAvLyBzbyBpdCBmZWVscyBtb3JlIG5hdHVyYWwgdG8gcnVuIHBsdWdpbnMgYXQgdGhlIGVuZCBvZiBhbiBhcnJheSBmaXJzdC5cbiAgICAvLyBUaGF04oCZcyB3aHkgd2UgaGF2ZSB0byByZXZlcnNlIHRoZSBgZXh0ZW5zaW9uc2AgYXJyYXkgYW5kIHNvcnQgYWdhaW5cbiAgICAvLyBiYXNlZCBvbiB0aGUgYHByaW9yaXR5YCBvcHRpb24uXG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIuc29ydChbLi4udGhpcy5leHRlbnNpb25zXS5yZXZlcnNlKCkpXG5cbiAgICBjb25zdCBpbnB1dFJ1bGVzOiBhbnlbXSA9IFtdXG4gICAgY29uc3QgcGFzdGVSdWxlczogYW55W10gPSBbXVxuXG4gICAgY29uc3QgYWxsUGx1Z2lucyA9IGV4dGVuc2lvbnNcbiAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGx1Z2luczogUGx1Z2luW10gPSBbXVxuXG4gICAgICAgIGNvbnN0IGFkZEtleWJvYXJkU2hvcnRjdXRzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRLZXlib2FyZFNob3J0Y3V0cyddPihcbiAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgJ2FkZEtleWJvYXJkU2hvcnRjdXRzJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgbGV0IGRlZmF1bHRCaW5kaW5nczogUmVjb3JkPHN0cmluZywgKCkgPT4gYm9vbGVhbj4gPSB7fVxuXG4gICAgICAgIC8vIGJpbmQgZXhpdCBoYW5kbGluZ1xuICAgICAgICBpZiAoZXh0ZW5zaW9uLnR5cGUgPT09ICdtYXJrJyAmJiBleHRlbnNpb24uY29uZmlnLmV4aXRhYmxlKSB7XG4gICAgICAgICAgZGVmYXVsdEJpbmRpbmdzLkFycm93UmlnaHQgPSAoKSA9PiBNYXJrLmhhbmRsZUV4aXQoeyBlZGl0b3IsIG1hcms6IGV4dGVuc2lvbiBhcyBNYXJrIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWRkS2V5Ym9hcmRTaG9ydGN1dHMpIHtcbiAgICAgICAgICBjb25zdCBiaW5kaW5ncyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGFkZEtleWJvYXJkU2hvcnRjdXRzKCkpLm1hcCgoW3Nob3J0Y3V0LCBtZXRob2RdKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBbc2hvcnRjdXQsICgpID0+IG1ldGhvZCh7IGVkaXRvciB9KV1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIClcblxuICAgICAgICAgIGRlZmF1bHRCaW5kaW5ncyA9IHsgLi4uZGVmYXVsdEJpbmRpbmdzLCAuLi5iaW5kaW5ncyB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBrZXlNYXBQbHVnaW4gPSBrZXltYXAoZGVmYXVsdEJpbmRpbmdzKVxuXG4gICAgICAgIHBsdWdpbnMucHVzaChrZXlNYXBQbHVnaW4pXG5cbiAgICAgICAgY29uc3QgYWRkSW5wdXRSdWxlcyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkSW5wdXRSdWxlcyddPihcbiAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgJ2FkZElucHV0UnVsZXMnLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIClcblxuICAgICAgICBpZiAoaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlZGl0b3Iub3B0aW9ucy5lbmFibGVJbnB1dFJ1bGVzKSAmJiBhZGRJbnB1dFJ1bGVzKSB7XG4gICAgICAgICAgaW5wdXRSdWxlcy5wdXNoKC4uLmFkZElucHV0UnVsZXMoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFkZFBhc3RlUnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFBhc3RlUnVsZXMnXT4oXG4gICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICdhZGRQYXN0ZVJ1bGVzJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbiwgZWRpdG9yLm9wdGlvbnMuZW5hYmxlUGFzdGVSdWxlcykgJiYgYWRkUGFzdGVSdWxlcykge1xuICAgICAgICAgIHBhc3RlUnVsZXMucHVzaCguLi5hZGRQYXN0ZVJ1bGVzKCkpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhZGRQcm9zZU1pcnJvclBsdWdpbnMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFByb3NlTWlycm9yUGx1Z2lucyddPihcbiAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgJ2FkZFByb3NlTWlycm9yUGx1Z2lucycsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChhZGRQcm9zZU1pcnJvclBsdWdpbnMpIHtcbiAgICAgICAgICBjb25zdCBwcm9zZU1pcnJvclBsdWdpbnMgPSBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKVxuXG4gICAgICAgICAgcGx1Z2lucy5wdXNoKC4uLnByb3NlTWlycm9yUGx1Z2lucylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwbHVnaW5zXG4gICAgICB9KVxuICAgICAgLmZsYXQoKVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIGlucHV0UnVsZXNQbHVnaW4oe1xuICAgICAgICBlZGl0b3IsXG4gICAgICAgIHJ1bGVzOiBpbnB1dFJ1bGVzLFxuICAgICAgfSksXG4gICAgICAuLi5wYXN0ZVJ1bGVzUGx1Z2luKHtcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBydWxlczogcGFzdGVSdWxlcyxcbiAgICAgIH0pLFxuICAgICAgLi4uYWxsUGx1Z2lucyxcbiAgICBdXG4gIH1cblxuICBnZXQgYXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucylcbiAgfVxuXG4gIGdldCBub2RlVmlld3MoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXNcbiAgICBjb25zdCB7IG5vZGVFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKVxuXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIG5vZGVFeHRlbnNpb25zXG4gICAgICAgIC5maWx0ZXIoZXh0ZW5zaW9uID0+ICEhZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkTm9kZVZpZXcnKSlcbiAgICAgICAgLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXMuZmlsdGVyKFxuICAgICAgICAgICAgYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHR5cGU6IGdldE5vZGVUeXBlKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFkZE5vZGVWaWV3ID0gZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snYWRkTm9kZVZpZXcnXT4oXG4gICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICAnYWRkTm9kZVZpZXcnLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICApXG5cbiAgICAgICAgICBpZiAoIWFkZE5vZGVWaWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBub2RldmlldyA9IChcbiAgICAgICAgICAgIG5vZGU6IFByb3NlbWlycm9yTm9kZSxcbiAgICAgICAgICAgIHZpZXc6IEVkaXRvclZpZXcsXG4gICAgICAgICAgICBnZXRQb3M6ICgoKSA9PiBudW1iZXIpIHwgYm9vbGVhbixcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uW10sXG4gICAgICAgICAgKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBIVE1MQXR0cmlidXRlcyA9IGdldFJlbmRlcmVkQXR0cmlidXRlcyhub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuXG4gICAgICAgICAgICByZXR1cm4gYWRkTm9kZVZpZXcoKSh7XG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgZ2V0UG9zLFxuICAgICAgICAgICAgICBkZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgbm9kZXZpZXddXG4gICAgICAgIH0pLFxuICAgIClcbiAgfVxufVxuIiwgIi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL21lc3F1ZWViL2lzLXdoYXQvYmxvYi84OGQ2ZTRjYTkyZmIyYmFhYjYwMDNjNTRlMDJlZWRmNGU3MjllNWFiL3NyYy9pbmRleC50c1xuXG5mdW5jdGlvbiBnZXRUeXBlKHZhbHVlOiBhbnkpOiBzdHJpbmcge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWU6IGFueSk6IHZhbHVlIGlzIFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBpZiAoZ2V0VHlwZSh2YWx1ZSkgIT09ICdPYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBPYmplY3QucHJvdG90eXBlXG59XG4iLCAiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4vaXNQbGFpbk9iamVjdC5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGVlcCh0YXJnZXQ6IFJlY29yZDxzdHJpbmcsIGFueT4sIHNvdXJjZTogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCBvdXRwdXQgPSB7IC4uLnRhcmdldCB9XG5cbiAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiBpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3V0cHV0LCB7IFtrZXldOiBzb3VyY2Vba2V5XSB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dFtrZXldID0gbWVyZ2VEZWVwKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvdXRwdXQsIHsgW2tleV06IHNvdXJjZVtrZXldIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cbiIsICJpbXBvcnQgeyBQbHVnaW4sIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IEV4dGVuc2lvbkNvbmZpZyB9IGZyb20gJy4vaW5kZXguanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUgfSBmcm9tICcuL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IE1hcmsgfSBmcm9tICcuL01hcmsuanMnXG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi9Ob2RlLmpzJ1xuaW1wb3J0IHsgUGFzdGVSdWxlIH0gZnJvbSAnLi9QYXN0ZVJ1bGUuanMnXG5pbXBvcnQge1xuICBBbnlDb25maWcsXG4gIEV4dGVuc2lvbnMsXG4gIEdsb2JhbEF0dHJpYnV0ZXMsXG4gIEtleWJvYXJkU2hvcnRjdXRDb21tYW5kLFxuICBQYXJlbnRDb25maWcsXG4gIFJhd0NvbW1hbmRzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgbWVyZ2VEZWVwIH0gZnJvbSAnLi91dGlsaXRpZXMvbWVyZ2VEZWVwLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBFeHRlbnNpb25Db25maWc8T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICAgIFtrZXk6IHN0cmluZ106IGFueVxuXG4gICAgLyoqXG4gICAgICogTmFtZVxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZ1xuXG4gICAgLyoqXG4gICAgICogUHJpb3JpdHlcbiAgICAgKi9cbiAgICBwcmlvcml0eT86IG51bWJlclxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBvcHRpb25zXG4gICAgICovXG4gICAgZGVmYXVsdE9wdGlvbnM/OiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IE9wdGlvbnNcbiAgICAgKi9cbiAgICBhZGRPcHRpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRPcHRpb25zJ10sIHVuZGVmaW5lZD5cbiAgICB9KSA9PiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IFN0b3JhZ2VcbiAgICAgKi9cbiAgICBhZGRTdG9yYWdlPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRTdG9yYWdlJ10sIHVuZGVmaW5lZD5cbiAgICB9KSA9PiBTdG9yYWdlXG5cbiAgICAvKipcbiAgICAgKiBHbG9iYWwgYXR0cmlidXRlc1xuICAgICAqL1xuICAgIGFkZEdsb2JhbEF0dHJpYnV0ZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRHbG9iYWxBdHRyaWJ1dGVzJ11cbiAgICB9KSA9PiBHbG9iYWxBdHRyaWJ1dGVzIHwge31cblxuICAgIC8qKlxuICAgICAqIFJhd1xuICAgICAqL1xuICAgIGFkZENvbW1hbmRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZENvbW1hbmRzJ11cbiAgICB9KSA9PiBQYXJ0aWFsPFJhd0NvbW1hbmRzPlxuXG4gICAgLyoqXG4gICAgICogS2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICovXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkS2V5Ym9hcmRTaG9ydGN1dHMnXVxuICAgIH0pID0+IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IEtleWJvYXJkU2hvcnRjdXRDb21tYW5kXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5wdXQgcnVsZXNcbiAgICAgKi9cbiAgICBhZGRJbnB1dFJ1bGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZElucHV0UnVsZXMnXVxuICAgIH0pID0+IElucHV0UnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBQYXN0ZSBydWxlc1xuICAgICAqL1xuICAgIGFkZFBhc3RlUnVsZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkUGFzdGVSdWxlcyddXG4gICAgfSkgPT4gUGFzdGVSdWxlW11cblxuICAgIC8qKlxuICAgICAqIFByb3NlTWlycm9yIHBsdWdpbnNcbiAgICAgKi9cbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkUHJvc2VNaXJyb3JQbHVnaW5zJ11cbiAgICB9KSA9PiBQbHVnaW5bXVxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5zaW9uc1xuICAgICAqL1xuICAgIGFkZEV4dGVuc2lvbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRFeHRlbnNpb25zJ11cbiAgICB9KSA9PiBFeHRlbnNpb25zXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgTm9kZSBTY2hlbWFcbiAgICAgKi9cbiAgICBleHRlbmROb2RlU2NoZW1hPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE5vZGVTY2hlbWEnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBOb2RlLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBNYXJrIFNjaGVtYVxuICAgICAqL1xuICAgIGV4dGVuZE1hcmtTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXh0ZW5kTWFya1NjaGVtYSddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE1hcmssXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBub3QgcmVhZHkgeWV0LlxuICAgICAqL1xuICAgIG9uQmVmb3JlQ3JlYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQmVmb3JlQ3JlYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyByZWFkeS5cbiAgICAgKi9cbiAgICBvbkNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZW50IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVXBkYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uVXBkYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGlvbiBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblNlbGVjdGlvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblNlbGVjdGlvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3Igc3RhdGUgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25UcmFuc2FjdGlvbj86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25UcmFuc2FjdGlvbiddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGZvY3VzZWQuXG4gICAgICovXG4gICAgb25Gb2N1cz86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25Gb2N1cyddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZXZlbnQ6IEZvY3VzRXZlbnRcbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXNu4oCZdCBmb2N1c2VkIGFueW1vcmUuXG4gICAgICovXG4gICAgb25CbHVyPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJsdXInXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGV2ZW50OiBGb2N1c0V2ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBvbkRlc3Ryb3k/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25EZXN0cm95J11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFeHRlbnNpb248T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICB0eXBlID0gJ2V4dGVuc2lvbidcblxuICBuYW1lID0gJ2V4dGVuc2lvbidcblxuICBwYXJlbnQ6IEV4dGVuc2lvbiB8IG51bGwgPSBudWxsXG5cbiAgY2hpbGQ6IEV4dGVuc2lvbiB8IG51bGwgPSBudWxsXG5cbiAgb3B0aW9uczogT3B0aW9uc1xuXG4gIHN0b3JhZ2U6IFN0b3JhZ2VcblxuICBjb25maWc6IEV4dGVuc2lvbkNvbmZpZyA9IHtcbiAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxuICB9XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBQYXJ0aWFsPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj4gPSB7fSkge1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAuLi5jb25maWcsXG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25maWcubmFtZVxuXG4gICAgaWYgKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5jb25maWcuZGVmYXVsdE9wdGlvbnNcblxuICAgIGlmICh0aGlzLmNvbmZpZy5hZGRPcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPih0aGlzLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPih0aGlzLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApIHx8IHt9XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlPE8gPSBhbnksIFMgPSBhbnk+KGNvbmZpZzogUGFydGlhbDxFeHRlbnNpb25Db25maWc8TywgUz4+ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEV4dGVuc2lvbjxPLCBTPihjb25maWcpXG4gIH1cblxuICBjb25maWd1cmUob3B0aW9uczogUGFydGlhbDxPcHRpb25zPiA9IHt9KSB7XG4gICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXG4gICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcbiAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCgpXG5cbiAgICBleHRlbnNpb24ub3B0aW9ucyA9IG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMgYXMgUmVjb3JkPHN0cmluZywgYW55Piwgb3B0aW9ucykgYXMgT3B0aW9uc1xuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG5cbiAgZXh0ZW5kPEV4dGVuZGVkT3B0aW9ucyA9IE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZSA9IFN0b3JhZ2U+KFxuICAgIGV4dGVuZGVkQ29uZmlnOiBQYXJ0aWFsPEV4dGVuc2lvbkNvbmZpZzxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4+ID0ge30sXG4gICkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBFeHRlbnNpb248RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+KGV4dGVuZGVkQ29uZmlnKVxuXG4gICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXNcblxuICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb25cblxuICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWVcblxuICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHtleHRlbnNpb24ubmFtZX1cIi5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRPcHRpb25zJ10+KGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBSYW5nZSwgVGV4dFNlcmlhbGl6ZXIgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRleHRCZXR3ZWVuKFxuICBzdGFydE5vZGU6IFByb3NlTWlycm9yTm9kZSxcbiAgcmFuZ2U6IFJhbmdlLFxuICBvcHRpb25zPzoge1xuICAgIGJsb2NrU2VwYXJhdG9yPzogc3RyaW5nXG4gICAgdGV4dFNlcmlhbGl6ZXJzPzogUmVjb3JkPHN0cmluZywgVGV4dFNlcmlhbGl6ZXI+XG4gIH0sXG4pOiBzdHJpbmcge1xuICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZVxuICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9XG4gIGxldCB0ZXh0ID0gJydcbiAgbGV0IHNlcGFyYXRlZCA9IHRydWVcblxuICBzdGFydE5vZGUubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zLCBwYXJlbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgdGV4dFNlcmlhbGl6ZXIgPSB0ZXh0U2VyaWFsaXplcnM/Lltub2RlLnR5cGUubmFtZV1cblxuICAgIGlmICh0ZXh0U2VyaWFsaXplcikge1xuICAgICAgaWYgKG5vZGUuaXNCbG9jayAmJiAhc2VwYXJhdGVkKSB7XG4gICAgICAgIHRleHQgKz0gYmxvY2tTZXBhcmF0b3JcbiAgICAgICAgc2VwYXJhdGVkID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHRleHQgKz0gdGV4dFNlcmlhbGl6ZXIoe1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgcG9zLFxuICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICByYW5nZSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICB0ZXh0ICs9IG5vZGU/LnRleHQ/LnNsaWNlKE1hdGgubWF4KGZyb20sIHBvcykgLSBwb3MsIHRvIC0gcG9zKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBzZXBhcmF0ZWQgPSBmYWxzZVxuICAgIH0gZWxzZSBpZiAobm9kZS5pc0Jsb2NrICYmICFzZXBhcmF0ZWQpIHtcbiAgICAgIHRleHQgKz0gYmxvY2tTZXBhcmF0b3JcbiAgICAgIHNlcGFyYXRlZCA9IHRydWVcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHRleHRcbn1cbiIsICJpbXBvcnQgeyBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBUZXh0U2VyaWFsaXplciB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWE6IFNjaGVtYSk6IFJlY29yZDxzdHJpbmcsIFRleHRTZXJpYWxpemVyPiB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLm5vZGVzKVxuICAgICAgLmZpbHRlcigoWywgbm9kZV0pID0+IG5vZGUuc3BlYy50b1RleHQpXG4gICAgICAubWFwKChbbmFtZSwgbm9kZV0pID0+IFtuYW1lLCBub2RlLnNwZWMudG9UZXh0XSksXG4gIClcbn1cbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcbmltcG9ydCB7IGdldFRleHRCZXR3ZWVuIH0gZnJvbSAnLi4vaGVscGVycy9nZXRUZXh0QmV0d2Vlbi5qcydcbmltcG9ydCB7IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEgfSBmcm9tICcuLi9oZWxwZXJzL2dldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEuanMnXG5cbmV4cG9ydCBjb25zdCBDbGlwYm9hcmRUZXh0U2VyaWFsaXplciA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXInLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXInKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBjbGlwYm9hcmRUZXh0U2VyaWFsaXplcjogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXNcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUsIHNjaGVtYSB9ID0gZWRpdG9yXG4gICAgICAgICAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICAgICAgICAgICAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvblxuICAgICAgICAgICAgY29uc3QgZnJvbSA9IE1hdGgubWluKC4uLnJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuJGZyb20ucG9zKSlcbiAgICAgICAgICAgIGNvbnN0IHRvID0gTWF0aC5tYXgoLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kdG8ucG9zKSlcbiAgICAgICAgICAgIGNvbnN0IHRleHRTZXJpYWxpemVycyA9IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKVxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7IGZyb20sIHRvIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdldFRleHRCZXR3ZWVuKGRvYywgcmFuZ2UsIHtcbiAgICAgICAgICAgICAgdGV4dFNlcmlhbGl6ZXJzLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgYmx1cjoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGZvY3VzIGZyb20gdGhlIGVkaXRvci5cbiAgICAgICAqL1xuICAgICAgYmx1cjogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGJsdXI6IFJhd0NvbW1hbmRzWydibHVyJ10gPSAoKSA9PiAoeyBlZGl0b3IsIHZpZXcgfSkgPT4ge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAodmlldy5kb20gYXMgSFRNTEVsZW1lbnQpLmJsdXIoKVxuXG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgcmVtb3ZlIHRoZSBjYXJldCBvbiBibHVyIGJ1dCBzYWZhcmkgZG9lcyBub3QuXG4gICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMjQwNVxuICAgICAgd2luZG93Py5nZXRTZWxlY3Rpb24oKT8ucmVtb3ZlQWxsUmFuZ2VzKClcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY2xlYXJDb250ZW50OiB7XG4gICAgICAvKipcbiAgICAgICAqIENsZWFyIHRoZSB3aG9sZSBkb2N1bWVudC5cbiAgICAgICAqL1xuICAgICAgY2xlYXJDb250ZW50OiAoZW1pdFVwZGF0ZT86IGJvb2xlYW4pID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjbGVhckNvbnRlbnQ6IFJhd0NvbW1hbmRzWydjbGVhckNvbnRlbnQnXSA9IChlbWl0VXBkYXRlID0gZmFsc2UpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgcmV0dXJuIGNvbW1hbmRzLnNldENvbnRlbnQoJycsIGVtaXRVcGRhdGUpXG59XG4iLCAiaW1wb3J0IHsgbGlmdFRhcmdldCB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY2xlYXJOb2Rlczoge1xuICAgICAgLyoqXG4gICAgICAgKiBOb3JtYWxpemUgbm9kZXMgdG8gYSBzaW1wbGUgcGFyYWdyYXBoLlxuICAgICAgICovXG4gICAgICBjbGVhck5vZGVzOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY2xlYXJOb2RlczogUmF3Q29tbWFuZHNbJ2NsZWFyTm9kZXMnXSA9ICgpID0+ICh7IHN0YXRlLCB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJcbiAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvblxuXG4gIGlmICghZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUuaXNUZXh0KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGRvYywgbWFwcGluZyB9ID0gdHJcbiAgICAgIGNvbnN0ICRtYXBwZWRGcm9tID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zKSlcbiAgICAgIGNvbnN0ICRtYXBwZWRUbyA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHBvcyArIG5vZGUubm9kZVNpemUpKVxuICAgICAgY29uc3Qgbm9kZVJhbmdlID0gJG1hcHBlZEZyb20uYmxvY2tSYW5nZSgkbWFwcGVkVG8pXG5cbiAgICAgIGlmICghbm9kZVJhbmdlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB0YXJnZXRMaWZ0RGVwdGggPSBsaWZ0VGFyZ2V0KG5vZGVSYW5nZSlcblxuICAgICAgaWYgKG5vZGUudHlwZS5pc1RleHRibG9jaykge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHRUeXBlIH0gPSAkbWFwcGVkRnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJG1hcHBlZEZyb20uaW5kZXgoKSlcblxuICAgICAgICB0ci5zZXROb2RlTWFya3VwKG5vZGVSYW5nZS5zdGFydCwgZGVmYXVsdFR5cGUpXG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXRMaWZ0RGVwdGggfHwgdGFyZ2V0TGlmdERlcHRoID09PSAwKSB7XG4gICAgICAgIHRyLmxpZnQobm9kZVJhbmdlLCB0YXJnZXRMaWZ0RGVwdGgpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IENvbW1hbmQsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBjb21tYW5kOiB7XG4gICAgICAvKipcbiAgICAgICAqIERlZmluZSBhIGNvbW1hbmQgaW5saW5lLlxuICAgICAgICovXG4gICAgICBjb21tYW5kOiAoZm46IChwcm9wczogUGFyYW1ldGVyczxDb21tYW5kPlswXSkgPT4gYm9vbGVhbikgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNvbW1hbmQ6IFJhd0NvbW1hbmRzWydjb21tYW5kJ10gPSBmbiA9PiBwcm9wcyA9PiB7XG4gIHJldHVybiBmbihwcm9wcylcbn1cbiIsICJpbXBvcnQgeyBjcmVhdGVQYXJhZ3JhcGhOZWFyIGFzIG9yaWdpbmFsQ3JlYXRlUGFyYWdyYXBoTmVhciB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBjcmVhdGVQYXJhZ3JhcGhOZWFyOiB7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSBhIHBhcmFncmFwaCBuZWFyYnkuXG4gICAgICAgKi9cbiAgICAgIGNyZWF0ZVBhcmFncmFwaE5lYXI6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVBhcmFncmFwaE5lYXI6IFJhd0NvbW1hbmRzWydjcmVhdGVQYXJhZ3JhcGhOZWFyJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxDcmVhdGVQYXJhZ3JhcGhOZWFyKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGN1dDoge1xuICAgICAgLyoqXG4gICAgICAgKiBDdXRzIGNvbnRlbnQgZnJvbSBhIHJhbmdlIGFuZCBpbnNlcnRzIGl0IGF0IGEgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICAgKi9cbiAgICAgIGN1dDogKHsgZnJvbSwgdG8gfTogeyBmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIgfSwgdGFyZ2V0UG9zOiBudW1iZXIpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjdXQ6IFJhd0NvbW1hbmRzWydjdXQnXSA9IChvcmlnaW5SYW5nZSwgdGFyZ2V0UG9zKSA9PiAoeyBlZGl0b3IsIHRyIH0pID0+IHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yXG5cbiAgY29uc3QgY29udGVudFNsaWNlID0gc3RhdGUuZG9jLnNsaWNlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKVxuXG4gIHRyLmRlbGV0ZVJhbmdlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKVxuICBjb25zdCBuZXdQb3MgPSB0ci5tYXBwaW5nLm1hcCh0YXJnZXRQb3MpXG5cbiAgdHIuaW5zZXJ0KG5ld1BvcywgY29udGVudFNsaWNlLmNvbnRlbnQpXG5cbiAgdHIuc2V0U2VsZWN0aW9uKG5ldyBUZXh0U2VsZWN0aW9uKHRyLmRvYy5yZXNvbHZlKG5ld1BvcyAtIDEpKSlcblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBkZWxldGVDdXJyZW50Tm9kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgdGhlIG5vZGUgdGhhdCBjdXJyZW50bHkgaGFzIHRoZSBzZWxlY3Rpb24gYW5jaG9yLlxuICAgICAgICovXG4gICAgICBkZWxldGVDdXJyZW50Tm9kZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZUN1cnJlbnROb2RlOiBSYXdDb21tYW5kc1snZGVsZXRlQ3VycmVudE5vZGUnXSA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICBjb25zdCBjdXJyZW50Tm9kZSA9IHNlbGVjdGlvbi4kYW5jaG9yLm5vZGUoKVxuXG4gIC8vIGlmIHRoZXJlIGlzIGNvbnRlbnQgaW5zaWRlIHRoZSBjdXJyZW50IG5vZGUsIGJyZWFrIG91dCBvZiB0aGlzIGNvbW1hbmRcbiAgaWYgKGN1cnJlbnROb2RlLmNvbnRlbnQuc2l6ZSA+IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0ICRwb3MgPSB0ci5zZWxlY3Rpb24uJGFuY2hvclxuXG4gIGZvciAobGV0IGRlcHRoID0gJHBvcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aCAtPSAxKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShkZXB0aClcblxuICAgIGlmIChub2RlLnR5cGUgPT09IGN1cnJlbnROb2RlLnR5cGUpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCBmcm9tID0gJHBvcy5iZWZvcmUoZGVwdGgpXG4gICAgICAgIGNvbnN0IHRvID0gJHBvcy5hZnRlcihkZXB0aClcblxuICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pLnNjcm9sbEludG9WaWV3KClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBkZWxldGVOb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIERlbGV0ZSBhIG5vZGUuXG4gICAgICAgKi9cbiAgICAgIGRlbGV0ZU5vZGU6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZU5vZGU6IFJhd0NvbW1hbmRzWydkZWxldGVOb2RlJ10gPSB0eXBlT3JOYW1lID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCAkcG9zID0gdHIuc2VsZWN0aW9uLiRhbmNob3JcblxuICBmb3IgKGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGggLT0gMSkge1xuICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoZGVwdGgpXG5cbiAgICBpZiAobm9kZS50eXBlID09PSB0eXBlKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9ICRwb3MuYmVmb3JlKGRlcHRoKVxuICAgICAgICBjb25zdCB0byA9ICRwb3MuYWZ0ZXIoZGVwdGgpXG5cbiAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKS5zY3JvbGxJbnRvVmlldygpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCAiaW1wb3J0IHsgUmFuZ2UsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBkZWxldGVSYW5nZToge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgYSBnaXZlbiByYW5nZS5cbiAgICAgICAqL1xuICAgICAgZGVsZXRlUmFuZ2U6IChyYW5nZTogUmFuZ2UpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWxldGVSYW5nZTogUmF3Q29tbWFuZHNbJ2RlbGV0ZVJhbmdlJ10gPSByYW5nZSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLmRlbGV0ZShmcm9tLCB0bylcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgZGVsZXRlU2VsZWN0aW9uIGFzIG9yaWdpbmFsRGVsZXRlU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGRlbGV0ZVNlbGVjdGlvbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgdGhlIHNlbGVjdGlvbiwgaWYgdGhlcmUgaXMgb25lLlxuICAgICAgICovXG4gICAgICBkZWxldGVTZWxlY3Rpb246ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVNlbGVjdGlvbjogUmF3Q29tbWFuZHNbJ2RlbGV0ZVNlbGVjdGlvbiddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsRGVsZXRlU2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZW50ZXI6IHtcbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlciBlbnRlci5cbiAgICAgICAqL1xuICAgICAgZW50ZXI6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBlbnRlcjogUmF3Q29tbWFuZHNbJ2VudGVyJ10gPSAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gIHJldHVybiBjb21tYW5kcy5rZXlib2FyZFNob3J0Y3V0KCdFbnRlcicpXG59XG4iLCAiaW1wb3J0IHsgZXhpdENvZGUgYXMgb3JpZ2luYWxFeGl0Q29kZSB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBleGl0Q29kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBFeGl0IGZyb20gYSBjb2RlIGJsb2NrLlxuICAgICAgICovXG4gICAgICBleGl0Q29kZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZXhpdENvZGU6IFJhd0NvbW1hbmRzWydleGl0Q29kZSddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsRXhpdENvZGUoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IGlzUmVnRXhwIH0gZnJvbSAnLi9pc1JlZ0V4cC5qcydcblxuLyoqXG4gKiBDaGVjayBpZiBvYmplY3QxIGluY2x1ZGVzIG9iamVjdDJcbiAqIEBwYXJhbSBvYmplY3QxIE9iamVjdFxuICogQHBhcmFtIG9iamVjdDIgT2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3RJbmNsdWRlcyhcbiAgb2JqZWN0MTogUmVjb3JkPHN0cmluZywgYW55PixcbiAgb2JqZWN0MjogUmVjb3JkPHN0cmluZywgYW55PixcbiAgb3B0aW9uczogeyBzdHJpY3Q6IGJvb2xlYW4gfSA9IHsgc3RyaWN0OiB0cnVlIH0sXG4pOiBib29sZWFuIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdDIpXG5cbiAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4ga2V5cy5ldmVyeShrZXkgPT4ge1xuICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xuICAgICAgcmV0dXJuIG9iamVjdDJba2V5XSA9PT0gb2JqZWN0MVtrZXldXG4gICAgfVxuXG4gICAgaWYgKGlzUmVnRXhwKG9iamVjdDJba2V5XSkpIHtcbiAgICAgIHJldHVybiBvYmplY3QyW2tleV0udGVzdChvYmplY3QxW2tleV0pXG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDJba2V5XSA9PT0gb2JqZWN0MVtrZXldXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgTWFyayBhcyBQcm9zZU1pcnJvck1hcmssIE1hcmtUeXBlLCBSZXNvbHZlZFBvcyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBvYmplY3RJbmNsdWRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9vYmplY3RJbmNsdWRlcy5qcydcblxuZnVuY3Rpb24gZmluZE1hcmtJblNldChcbiAgbWFya3M6IFByb3NlTWlycm9yTWFya1tdLFxuICB0eXBlOiBNYXJrVHlwZSxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogUHJvc2VNaXJyb3JNYXJrIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIG1hcmtzLmZpbmQoaXRlbSA9PiB7XG4gICAgcmV0dXJuIGl0ZW0udHlwZSA9PT0gdHlwZSAmJiBvYmplY3RJbmNsdWRlcyhpdGVtLmF0dHJzLCBhdHRyaWJ1dGVzKVxuICB9KVxufVxuXG5mdW5jdGlvbiBpc01hcmtJblNldChcbiAgbWFya3M6IFByb3NlTWlycm9yTWFya1tdLFxuICB0eXBlOiBNYXJrVHlwZSxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogYm9vbGVhbiB7XG4gIHJldHVybiAhIWZpbmRNYXJrSW5TZXQobWFya3MsIHR5cGUsIGF0dHJpYnV0ZXMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJrUmFuZ2UoXG4gICRwb3M6IFJlc29sdmVkUG9zLFxuICB0eXBlOiBNYXJrVHlwZSxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogUmFuZ2UgfCB2b2lkIHtcbiAgaWYgKCEkcG9zIHx8ICF0eXBlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgc3RhcnQgPSAkcG9zLnBhcmVudC5jaGlsZEFmdGVyKCRwb3MucGFyZW50T2Zmc2V0KVxuXG4gIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PT0gc3RhcnQub2Zmc2V0ICYmIHN0YXJ0Lm9mZnNldCAhPT0gMCkge1xuICAgIHN0YXJ0ID0gJHBvcy5wYXJlbnQuY2hpbGRCZWZvcmUoJHBvcy5wYXJlbnRPZmZzZXQpXG4gIH1cblxuICBpZiAoIXN0YXJ0Lm5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IG1hcmsgPSBmaW5kTWFya0luU2V0KFsuLi5zdGFydC5ub2RlLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcylcblxuICBpZiAoIW1hcmspIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaW5kZXhcbiAgbGV0IHN0YXJ0UG9zID0gJHBvcy5zdGFydCgpICsgc3RhcnQub2Zmc2V0XG4gIGxldCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyAxXG4gIGxldCBlbmRQb3MgPSBzdGFydFBvcyArIHN0YXJ0Lm5vZGUubm9kZVNpemVcblxuICBmaW5kTWFya0luU2V0KFsuLi5zdGFydC5ub2RlLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcylcblxuICB3aGlsZSAoc3RhcnRJbmRleCA+IDAgJiYgbWFyay5pc0luU2V0KCRwb3MucGFyZW50LmNoaWxkKHN0YXJ0SW5kZXggLSAxKS5tYXJrcykpIHtcbiAgICBzdGFydEluZGV4IC09IDFcbiAgICBzdGFydFBvcyAtPSAkcG9zLnBhcmVudC5jaGlsZChzdGFydEluZGV4KS5ub2RlU2l6ZVxuICB9XG5cbiAgd2hpbGUgKFxuICAgIGVuZEluZGV4IDwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudFxuICAgICYmIGlzTWFya0luU2V0KFsuLi4kcG9zLnBhcmVudC5jaGlsZChlbmRJbmRleCkubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKVxuICApIHtcbiAgICBlbmRQb3MgKz0gJHBvcy5wYXJlbnQuY2hpbGQoZW5kSW5kZXgpLm5vZGVTaXplXG4gICAgZW5kSW5kZXggKz0gMVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmcm9tOiBzdGFydFBvcyxcbiAgICB0bzogZW5kUG9zLFxuICB9XG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJrVHlwZShuYW1lT3JUeXBlOiBzdHJpbmcgfCBNYXJrVHlwZSwgc2NoZW1hOiBTY2hlbWEpOiBNYXJrVHlwZSB7XG4gIGlmICh0eXBlb2YgbmFtZU9yVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIXNjaGVtYS5tYXJrc1tuYW1lT3JUeXBlXSkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBUaGVyZSBpcyBubyBtYXJrIHR5cGUgbmFtZWQgJyR7bmFtZU9yVHlwZX0nLiBNYXliZSB5b3UgZm9yZ290IHRvIGFkZCB0aGUgZXh0ZW5zaW9uP2AsXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS5tYXJrc1tuYW1lT3JUeXBlXVxuICB9XG5cbiAgcmV0dXJuIG5hbWVPclR5cGVcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZ2V0TWFya1JhbmdlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrUmFuZ2UuanMnXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZXh0ZW5kTWFya1JhbmdlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEV4dGVuZHMgdGhlIHRleHQgc2VsZWN0aW9uIHRvIHRoZSBjdXJyZW50IG1hcmsuXG4gICAgICAgKi9cbiAgICAgIGV4dGVuZE1hcmtSYW5nZTogKFxuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBNYXJrVHlwZSxcbiAgICAgICAgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGV4dGVuZE1hcmtSYW5nZTogUmF3Q29tbWFuZHNbJ2V4dGVuZE1hcmtSYW5nZSddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHsgJGZyb20sIGZyb20sIHRvIH0gPSBzZWxlY3Rpb25cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cmlidXRlcylcblxuICAgIGlmIChyYW5nZSAmJiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8pIHtcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pXG5cbiAgICAgIHRyLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBDb21tYW5kLCBDb21tYW5kUHJvcHMsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBmaXJzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBSdW5zIG9uZSBjb21tYW5kIGFmdGVyIHRoZSBvdGhlciBhbmQgc3RvcHMgYXQgdGhlIGZpcnN0IHdoaWNoIHJldHVybnMgdHJ1ZS5cbiAgICAgICAqL1xuICAgICAgZmlyc3Q6IChjb21tYW5kczogQ29tbWFuZFtdIHwgKChwcm9wczogQ29tbWFuZFByb3BzKSA9PiBDb21tYW5kW10pKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZmlyc3Q6IFJhd0NvbW1hbmRzWydmaXJzdCddID0gY29tbWFuZHMgPT4gcHJvcHMgPT4ge1xuICBjb25zdCBpdGVtcyA9IHR5cGVvZiBjb21tYW5kcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gY29tbWFuZHMocHJvcHMpXG4gICAgOiBjb21tYW5kc1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoaXRlbXNbaV0ocHJvcHMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNUZXh0U2VsZWN0aW9uKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgVGV4dFNlbGVjdGlvbiB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb25cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gbWluTWF4KHZhbHVlID0gMCwgbWluID0gMCwgbWF4ID0gMCk6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEZvY3VzUG9zaXRpb24gfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG1pbk1heCB9IGZyb20gJy4uL3V0aWxpdGllcy9taW5NYXguanMnXG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlRm9jdXNQb3NpdGlvbihcbiAgZG9jOiBQcm9zZU1pcnJvck5vZGUsXG4gIHBvc2l0aW9uOiBGb2N1c1Bvc2l0aW9uID0gbnVsbCxcbik6IFNlbGVjdGlvbiB8IG51bGwge1xuICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHNlbGVjdGlvbkF0U3RhcnQgPSBTZWxlY3Rpb24uYXRTdGFydChkb2MpXG4gIGNvbnN0IHNlbGVjdGlvbkF0RW5kID0gU2VsZWN0aW9uLmF0RW5kKGRvYylcblxuICBpZiAocG9zaXRpb24gPT09ICdzdGFydCcgfHwgcG9zaXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uQXRTdGFydFxuICB9XG5cbiAgaWYgKHBvc2l0aW9uID09PSAnZW5kJykge1xuICAgIHJldHVybiBzZWxlY3Rpb25BdEVuZFxuICB9XG5cbiAgY29uc3QgbWluUG9zID0gc2VsZWN0aW9uQXRTdGFydC5mcm9tXG4gIGNvbnN0IG1heFBvcyA9IHNlbGVjdGlvbkF0RW5kLnRvXG5cbiAgaWYgKHBvc2l0aW9uID09PSAnYWxsJykge1xuICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShcbiAgICAgIGRvYyxcbiAgICAgIG1pbk1heCgwLCBtaW5Qb3MsIG1heFBvcyksXG4gICAgICBtaW5NYXgoZG9jLmNvbnRlbnQuc2l6ZSwgbWluUG9zLCBtYXhQb3MpLFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShcbiAgICBkb2MsXG4gICAgbWluTWF4KHBvc2l0aW9uLCBtaW5Qb3MsIG1heFBvcyksXG4gICAgbWluTWF4KHBvc2l0aW9uLCBtaW5Qb3MsIG1heFBvcyksXG4gIClcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNpT1MoKTogYm9vbGVhbiB7XG4gIHJldHVybiBbXG4gICAgJ2lQYWQgU2ltdWxhdG9yJyxcbiAgICAnaVBob25lIFNpbXVsYXRvcicsXG4gICAgJ2lQb2QgU2ltdWxhdG9yJyxcbiAgICAnaVBhZCcsXG4gICAgJ2lQaG9uZScsXG4gICAgJ2lQb2QnLFxuICBdLmluY2x1ZGVzKG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgLy8gaVBhZCBvbiBpT1MgMTMgZGV0ZWN0aW9uXG4gIHx8IChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdNYWMnKSAmJiAnb250b3VjaGVuZCcgaW4gZG9jdW1lbnQpXG59XG4iLCAiaW1wb3J0IHsgaXNUZXh0U2VsZWN0aW9uIH0gZnJvbSAnLi4vaGVscGVycy9pc1RleHRTZWxlY3Rpb24uanMnXG5pbXBvcnQgeyByZXNvbHZlRm9jdXNQb3NpdGlvbiB9IGZyb20gJy4uL2hlbHBlcnMvcmVzb2x2ZUZvY3VzUG9zaXRpb24uanMnXG5pbXBvcnQgeyBGb2N1c1Bvc2l0aW9uLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNpT1MgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNpT1MuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBmb2N1czoge1xuICAgICAgLyoqXG4gICAgICAgKiBGb2N1cyB0aGUgZWRpdG9yIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgICAqL1xuICAgICAgZm9jdXM6IChcbiAgICAgICAgcG9zaXRpb24/OiBGb2N1c1Bvc2l0aW9uLFxuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIHNjcm9sbEludG9WaWV3PzogYm9vbGVhbixcbiAgICAgICAgfSxcbiAgICAgICkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGZvY3VzOiBSYXdDb21tYW5kc1snZm9jdXMnXSA9IChwb3NpdGlvbiA9IG51bGwsIG9wdGlvbnMgPSB7fSkgPT4gKHtcbiAgZWRpdG9yLFxuICB2aWV3LFxuICB0cixcbiAgZGlzcGF0Y2gsXG59KSA9PiB7XG4gIG9wdGlvbnMgPSB7XG4gICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxuXG4gIGNvbnN0IGRlbGF5ZWRGb2N1cyA9ICgpID0+IHtcbiAgICAvLyBmb2N1cyB3aXRoaW4gYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYnJlYWtzIGZvY3VzIG9uIGlPU1xuICAgIC8vIHNvIHdlIGhhdmUgdG8gY2FsbCB0aGlzXG4gICAgaWYgKGlzaU9TKCkpIHtcbiAgICAgICh2aWV3LmRvbSBhcyBIVE1MRWxlbWVudCkuZm9jdXMoKVxuICAgIH1cblxuICAgIC8vIEZvciBSZWFjdCB3ZSBoYXZlIHRvIGZvY3VzIGFzeW5jaHJvbm91c2x5LiBPdGhlcndpc2Ugd2lsZCB0aGluZ3MgaGFwcGVuLlxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8xNTIwXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIHZpZXcuZm9jdXMoKVxuXG4gICAgICAgIGlmIChvcHRpb25zPy5zY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgIGVkaXRvci5jb21tYW5kcy5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaWYgKCh2aWV3Lmhhc0ZvY3VzKCkgJiYgcG9zaXRpb24gPT09IG51bGwpIHx8IHBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyB3ZSBkb27igJl0IHRyeSB0byByZXNvbHZlIGEgTm9kZVNlbGVjdGlvbiBvciBDZWxsU2VsZWN0aW9uXG4gIGlmIChkaXNwYXRjaCAmJiBwb3NpdGlvbiA9PT0gbnVsbCAmJiAhaXNUZXh0U2VsZWN0aW9uKGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24pKSB7XG4gICAgZGVsYXllZEZvY3VzKClcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gcGFzcyB0aHJvdWdoIHRyLmRvYyBpbnN0ZWFkIG9mIGVkaXRvci5zdGF0ZS5kb2NcbiAgLy8gc2luY2UgdHJhbnNhY3Rpb25zIGNvdWxkIGNoYW5nZSB0aGUgZWRpdG9ycyBzdGF0ZSBiZWZvcmUgdGhpcyBjb21tYW5kIGhhcyBiZWVuIHJ1blxuICBjb25zdCBzZWxlY3Rpb24gPSByZXNvbHZlRm9jdXNQb3NpdGlvbih0ci5kb2MsIHBvc2l0aW9uKSB8fCBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IGlzU2FtZVNlbGVjdGlvbiA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZXEoc2VsZWN0aW9uKVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGlmICghaXNTYW1lU2VsZWN0aW9uKSB7XG4gICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuICAgIH1cblxuICAgIC8vIGB0ci5zZXRTZWxlY3Rpb25gIHJlc2V0cyB0aGUgc3RvcmVkIG1hcmtzXG4gICAgLy8gc28gd2XigJlsbCByZXN0b3JlIHRoZW0gaWYgdGhlIHNlbGVjdGlvbiBpcyB0aGUgc2FtZSBhcyBiZWZvcmVcbiAgICBpZiAoaXNTYW1lU2VsZWN0aW9uICYmIHRyLnN0b3JlZE1hcmtzKSB7XG4gICAgICB0ci5zZXRTdG9yZWRNYXJrcyh0ci5zdG9yZWRNYXJrcylcbiAgICB9XG5cbiAgICBkZWxheWVkRm9jdXMoKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBDb21tYW5kUHJvcHMsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBmb3JFYWNoOiB7XG4gICAgICAvKipcbiAgICAgICAqIExvb3AgdGhyb3VnaCBhbiBhcnJheSBvZiBpdGVtcy5cbiAgICAgICAqL1xuICAgICAgZm9yRWFjaDogPFQ+KFxuICAgICAgICBpdGVtczogVFtdLFxuICAgICAgICBmbjogKFxuICAgICAgICAgIGl0ZW06IFQsXG4gICAgICAgICAgcHJvcHM6IENvbW1hbmRQcm9wcyAmIHtcbiAgICAgICAgICAgIGluZGV4OiBudW1iZXIsXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiBib29sZWFuLFxuICAgICAgKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZm9yRWFjaDogUmF3Q29tbWFuZHNbJ2ZvckVhY2gnXSA9IChpdGVtcywgZm4pID0+IHByb3BzID0+IHtcbiAgcmV0dXJuIGl0ZW1zLmV2ZXJ5KChpdGVtLCBpbmRleCkgPT4gZm4oaXRlbSwgeyAuLi5wcm9wcywgaW5kZXggfSkpXG59XG4iLCAiaW1wb3J0IHsgUGFyc2VPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgQ29udGVudCwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGluc2VydENvbnRlbnQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSW5zZXJ0IGEgbm9kZSBvciBzdHJpbmcgb2YgSFRNTCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAqL1xuICAgICAgaW5zZXJ0Q29udGVudDogKFxuICAgICAgICB2YWx1ZTogQ29udGVudCxcbiAgICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgICBwYXJzZU9wdGlvbnM/OiBQYXJzZU9wdGlvbnNcbiAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24/OiBib29sZWFuXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGluc2VydENvbnRlbnQ6IFJhd0NvbW1hbmRzWydpbnNlcnRDb250ZW50J10gPSAodmFsdWUsIG9wdGlvbnMpID0+ICh7IHRyLCBjb21tYW5kcyB9KSA9PiB7XG4gIHJldHVybiBjb21tYW5kcy5pbnNlcnRDb250ZW50QXQoXG4gICAgeyBmcm9tOiB0ci5zZWxlY3Rpb24uZnJvbSwgdG86IHRyLnNlbGVjdGlvbi50byB9LFxuICAgIHZhbHVlLFxuICAgIG9wdGlvbnMsXG4gIClcbn1cbiIsICJjb25zdCByZW1vdmVXaGl0ZXNwYWNlcyA9IChub2RlOiBIVE1MRWxlbWVudCkgPT4ge1xuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2Rlc1xuXG4gIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV1cblxuICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMyAmJiBjaGlsZC5ub2RlVmFsdWUgJiYgIS9cXFMvLnRlc3QoY2hpbGQubm9kZVZhbHVlKSkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZClcbiAgICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICByZW1vdmVXaGl0ZXNwYWNlcyhjaGlsZCBhcyBIVE1MRWxlbWVudClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudEZyb21TdHJpbmcodmFsdWU6IHN0cmluZyk6IEhUTUxFbGVtZW50IHtcbiAgLy8gYWRkIGEgd3JhcHBlciB0byBwcmVzZXJ2ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gIGNvbnN0IHdyYXBwZWRWYWx1ZSA9IGA8Ym9keT4ke3ZhbHVlfTwvYm9keT5gXG5cbiAgY29uc3QgaHRtbCA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHdyYXBwZWRWYWx1ZSwgJ3RleHQvaHRtbCcpLmJvZHlcblxuICByZW1vdmVXaGl0ZXNwYWNlcyhodG1sKVxuXG4gIHJldHVybiByZW1vdmVXaGl0ZXNwYWNlcyhodG1sKVxufVxuIiwgImltcG9ydCB7XG4gIERPTVBhcnNlcixcbiAgRnJhZ21lbnQsXG4gIE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLFxuICBQYXJzZU9wdGlvbnMsXG4gIFNjaGVtYSxcbn0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgQ29udGVudCB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZWxlbWVudEZyb21TdHJpbmcgfSBmcm9tICcuLi91dGlsaXRpZXMvZWxlbWVudEZyb21TdHJpbmcuanMnXG5cbmV4cG9ydCB0eXBlIENyZWF0ZU5vZGVGcm9tQ29udGVudE9wdGlvbnMgPSB7XG4gIHNsaWNlPzogYm9vbGVhblxuICBwYXJzZU9wdGlvbnM/OiBQYXJzZU9wdGlvbnNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5vZGVGcm9tQ29udGVudChcbiAgY29udGVudDogQ29udGVudCxcbiAgc2NoZW1hOiBTY2hlbWEsXG4gIG9wdGlvbnM/OiBDcmVhdGVOb2RlRnJvbUNvbnRlbnRPcHRpb25zLFxuKTogUHJvc2VNaXJyb3JOb2RlIHwgRnJhZ21lbnQge1xuICBvcHRpb25zID0ge1xuICAgIHNsaWNlOiB0cnVlLFxuICAgIHBhcnNlT3B0aW9uczoge30sXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ29iamVjdCcgJiYgY29udGVudCAhPT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50KSAmJiBjb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb21BcnJheShjb250ZW50Lm1hcChpdGVtID0+IHNjaGVtYS5ub2RlRnJvbUpTT04oaXRlbSkpKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2NoZW1hLm5vZGVGcm9tSlNPTihjb250ZW50KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IEludmFsaWQgY29udGVudC4nLCAnUGFzc2VkIHZhbHVlOicsIGNvbnRlbnQsICdFcnJvcjonLCBlcnJvcilcblxuICAgICAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudCgnJywgc2NoZW1hLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBET01QYXJzZXIuZnJvbVNjaGVtYShzY2hlbWEpXG5cbiAgICByZXR1cm4gb3B0aW9ucy5zbGljZVxuICAgICAgPyBwYXJzZXIucGFyc2VTbGljZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpLmNvbnRlbnRcbiAgICAgIDogcGFyc2VyLnBhcnNlKGVsZW1lbnRGcm9tU3RyaW5nKGNvbnRlbnQpLCBvcHRpb25zLnBhcnNlT3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoJycsIHNjaGVtYSwgb3B0aW9ucylcbn1cbiIsICJpbXBvcnQgeyBTZWxlY3Rpb24sIFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IFJlcGxhY2VBcm91bmRTdGVwLCBSZXBsYWNlU3RlcCB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci1zdGF0ZS9ibG9iL21hc3Rlci9zcmMvc2VsZWN0aW9uLmpzI0w0NjZcbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0cjogVHJhbnNhY3Rpb24sIHN0YXJ0TGVuOiBudW1iZXIsIGJpYXM6IG51bWJlcikge1xuICBjb25zdCBsYXN0ID0gdHIuc3RlcHMubGVuZ3RoIC0gMVxuXG4gIGlmIChsYXN0IDwgc3RhcnRMZW4pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHN0ZXAgPSB0ci5zdGVwc1tsYXN0XVxuXG4gIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCB8fCBzdGVwIGluc3RhbmNlb2YgUmVwbGFjZUFyb3VuZFN0ZXApKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbbGFzdF1cbiAgbGV0IGVuZCA9IDBcblxuICBtYXAuZm9yRWFjaCgoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSA9PiB7XG4gICAgaWYgKGVuZCA9PT0gMCkge1xuICAgICAgZW5kID0gbmV3VG9cbiAgICB9XG4gIH0pXG5cbiAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKGVuZCksIGJpYXMpKVxufVxuIiwgImltcG9ydCB7IEZyYWdtZW50LCBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgUGFyc2VPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgY3JlYXRlTm9kZUZyb21Db250ZW50IH0gZnJvbSAnLi4vaGVscGVycy9jcmVhdGVOb2RlRnJvbUNvbnRlbnQuanMnXG5pbXBvcnQgeyBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCB9IGZyb20gJy4uL2hlbHBlcnMvc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQuanMnXG5pbXBvcnQgeyBDb250ZW50LCBSYW5nZSwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGluc2VydENvbnRlbnRBdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBJbnNlcnQgYSBub2RlIG9yIHN0cmluZyBvZiBIVE1MIGF0IGEgc3BlY2lmaWMgcG9zaXRpb24uXG4gICAgICAgKi9cbiAgICAgIGluc2VydENvbnRlbnRBdDogKFxuICAgICAgICBwb3NpdGlvbjogbnVtYmVyIHwgUmFuZ2UsXG4gICAgICAgIHZhbHVlOiBDb250ZW50LFxuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIHBhcnNlT3B0aW9ucz86IFBhcnNlT3B0aW9uc1xuICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbj86IGJvb2xlYW5cbiAgICAgICAgfSxcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBpc0ZyYWdtZW50ID0gKG5vZGVPckZyYWdtZW50OiBQcm9zZU1pcnJvck5vZGUgfCBGcmFnbWVudCk6IG5vZGVPckZyYWdtZW50IGlzIEZyYWdtZW50ID0+IHtcbiAgcmV0dXJuIG5vZGVPckZyYWdtZW50LnRvU3RyaW5nKCkuc3RhcnRzV2l0aCgnPCcpXG59XG5cbmV4cG9ydCBjb25zdCBpbnNlcnRDb250ZW50QXQ6IFJhd0NvbW1hbmRzWydpbnNlcnRDb250ZW50QXQnXSA9IChwb3NpdGlvbiwgdmFsdWUsIG9wdGlvbnMpID0+ICh7IHRyLCBkaXNwYXRjaCwgZWRpdG9yIH0pID0+IHtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHBhcnNlT3B0aW9uczoge30sXG4gICAgICB1cGRhdGVTZWxlY3Rpb246IHRydWUsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH1cblxuICAgIGNvbnN0IGNvbnRlbnQgPSBjcmVhdGVOb2RlRnJvbUNvbnRlbnQodmFsdWUsIGVkaXRvci5zY2hlbWEsIHtcbiAgICAgIHBhcnNlT3B0aW9uczoge1xuICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICdmdWxsJyxcbiAgICAgICAgLi4ub3B0aW9ucy5wYXJzZU9wdGlvbnMsXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICAvLyBkb27igJl0IGRpc3BhdGNoIGFuIGVtcHR5IGZyYWdtZW50IGJlY2F1c2UgdGhpcyBjYW4gbGVhZCB0byBzdHJhbmdlIGVycm9yc1xuICAgIGlmIChjb250ZW50LnRvU3RyaW5nKCkgPT09ICc8PicpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgbGV0IHsgZnJvbSwgdG8gfSA9IHR5cGVvZiBwb3NpdGlvbiA9PT0gJ251bWJlcicgPyB7IGZyb206IHBvc2l0aW9uLCB0bzogcG9zaXRpb24gfSA6IHsgZnJvbTogcG9zaXRpb24uZnJvbSwgdG86IHBvc2l0aW9uLnRvIH1cblxuICAgIGxldCBpc09ubHlUZXh0Q29udGVudCA9IHRydWVcbiAgICBsZXQgaXNPbmx5QmxvY2tDb250ZW50ID0gdHJ1ZVxuICAgIGNvbnN0IG5vZGVzID0gaXNGcmFnbWVudChjb250ZW50KSA/IGNvbnRlbnQgOiBbY29udGVudF1cblxuICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAvLyBjaGVjayBpZiBhZGRlZCBub2RlIGlzIHZhbGlkXG4gICAgICBub2RlLmNoZWNrKClcblxuICAgICAgaXNPbmx5VGV4dENvbnRlbnQgPSBpc09ubHlUZXh0Q29udGVudCA/IG5vZGUuaXNUZXh0ICYmIG5vZGUubWFya3MubGVuZ3RoID09PSAwIDogZmFsc2VcblxuICAgICAgaXNPbmx5QmxvY2tDb250ZW50ID0gaXNPbmx5QmxvY2tDb250ZW50ID8gbm9kZS5pc0Jsb2NrIDogZmFsc2VcbiAgICB9KVxuXG4gICAgLy8gY2hlY2sgaWYgd2UgY2FuIHJlcGxhY2UgdGhlIHdyYXBwaW5nIG5vZGUgYnlcbiAgICAvLyB0aGUgbmV3bHkgaW5zZXJ0ZWQgY29udGVudFxuICAgIC8vIGV4YW1wbGU6XG4gICAgLy8gcmVwbGFjZSBhbiBlbXB0eSBwYXJhZ3JhcGggYnkgYW4gaW5zZXJ0ZWQgaW1hZ2VcbiAgICAvLyBpbnN0ZWFkIG9mIGluc2VydGluZyB0aGUgaW1hZ2UgYmVsb3cgdGhlIHBhcmFncmFwaFxuICAgIGlmIChmcm9tID09PSB0byAmJiBpc09ubHlCbG9ja0NvbnRlbnQpIHtcbiAgICAgIGNvbnN0IHsgcGFyZW50IH0gPSB0ci5kb2MucmVzb2x2ZShmcm9tKVxuICAgICAgY29uc3QgaXNFbXB0eVRleHRCbG9jayA9IHBhcmVudC5pc1RleHRibG9jayAmJiAhcGFyZW50LnR5cGUuc3BlYy5jb2RlICYmICFwYXJlbnQuY2hpbGRDb3VudFxuXG4gICAgICBpZiAoaXNFbXB0eVRleHRCbG9jaykge1xuICAgICAgICBmcm9tIC09IDFcbiAgICAgICAgdG8gKz0gMVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgcGxhaW4gdGV4dCB3ZSBoYXZlIHRvIHVzZSBgaW5zZXJ0VGV4dGBcbiAgICAvLyBiZWNhdXNlIHRoaXMgd2lsbCBrZWVwIHRoZSBjdXJyZW50IG1hcmtzXG4gICAgaWYgKGlzT25seVRleHRDb250ZW50KSB7XG4gICAgICAvLyBpZiB2YWx1ZSBpcyBzdHJpbmcsIHdlIGNhbiB1c2UgaXQgZGlyZWN0bHlcbiAgICAgIC8vIG90aGVyd2lzZSBpZiBpdCBpcyBhbiBhcnJheSwgd2UgaGF2ZSB0byBqb2luIGl0XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdHIuaW5zZXJ0VGV4dCh2YWx1ZS5tYXAodiA9PiB2LnRleHQgfHwgJycpLmpvaW4oJycpLCBmcm9tLCB0bylcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhIXZhbHVlICYmICEhdmFsdWUudGV4dCkge1xuICAgICAgICB0ci5pbnNlcnRUZXh0KHZhbHVlLnRleHQsIGZyb20sIHRvKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHIuaW5zZXJ0VGV4dCh2YWx1ZSBhcyBzdHJpbmcsIGZyb20sIHRvKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ci5yZXBsYWNlV2l0aChmcm9tLCB0bywgY29udGVudClcbiAgICB9XG5cbiAgICAvLyBzZXQgY3Vyc29yIGF0IGVuZCBvZiBpbnNlcnRlZCBjb250ZW50XG4gICAgaWYgKG9wdGlvbnMudXBkYXRlU2VsZWN0aW9uKSB7XG4gICAgICBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgdHIuc3RlcHMubGVuZ3RoIC0gMSwgLTEpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQge1xuICBqb2luQmFja3dhcmQgYXMgb3JpZ2luYWxKb2luQmFja3dhcmQsXG4gIGpvaW5Eb3duIGFzIG9yaWdpbmFsSm9pbkRvd24sXG4gIGpvaW5Gb3J3YXJkIGFzIG9yaWdpbmFsSm9pbkZvcndhcmQsXG4gIGpvaW5VcCBhcyBvcmlnaW5hbEpvaW5VcCxcbn0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGpvaW5VcDoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHR3byBub2RlcyBVcC5cbiAgICAgICAqL1xuICAgICAgam9pblVwOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICAgIGpvaW5Eb3duOiB7XG4gICAgICAvKipcbiAgICAgICAqIEpvaW4gdHdvIG5vZGVzIERvd24uXG4gICAgICAgKi9cbiAgICAgIGpvaW5Eb3duOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICAgIGpvaW5CYWNrd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHR3byBub2RlcyBCYWNrd2FyZHMuXG4gICAgICAgKi9cbiAgICAgIGpvaW5CYWNrd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgICBqb2luRm9yd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHR3byBub2RlcyBGb3J3YXJkcy5cbiAgICAgICAqL1xuICAgICAgam9pbkZvcndhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5VcDogUmF3Q29tbWFuZHNbJ2pvaW5VcCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pblVwKHN0YXRlLCBkaXNwYXRjaClcbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5Eb3duOiBSYXdDb21tYW5kc1snam9pbkRvd24nXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5Eb3duKHN0YXRlLCBkaXNwYXRjaClcbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5CYWNrd2FyZDogUmF3Q29tbWFuZHNbJ2pvaW5CYWNrd2FyZCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsSm9pbkJhY2t3YXJkKHN0YXRlLCBkaXNwYXRjaClcbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5Gb3J3YXJkOiBSYXdDb21tYW5kc1snam9pbkZvcndhcmQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5Gb3J3YXJkKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBqb2luUG9pbnQgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGpvaW5JdGVtQmFja3dhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gbm9kZXMgRm9yd2FyZHMuXG4gICAgICAgKi9cbiAgICAgIGpvaW5JdGVtQmFja3dhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5JdGVtQmFja3dhcmQ6IFJhd0NvbW1hbmRzWydqb2luSXRlbUJhY2t3YXJkJ10gPSAoKSA9PiAoe1xuICB0ciwgc3RhdGUsIGRpc3BhdGNoLFxufSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgLTEpXG5cbiAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdHIuam9pbihwb2ludCwgMilcblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgZGlzcGF0Y2godHIpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBqb2luUG9pbnQgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGpvaW5JdGVtRm9yd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHR3byBub2RlcyBGb3J3YXJkcy5cbiAgICAgICAqL1xuICAgICAgam9pbkl0ZW1Gb3J3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBqb2luSXRlbUZvcndhcmQ6IFJhd0NvbW1hbmRzWydqb2luSXRlbUZvcndhcmQnXSA9ICgpID0+ICh7XG4gIHN0YXRlLFxuICBkaXNwYXRjaCxcbiAgdHIsXG59KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ucG9zLCArMSlcblxuICAgIGlmIChwb2ludCA9PT0gbnVsbCB8fCBwb2ludCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0ci5qb2luKHBvaW50LCAyKVxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBkaXNwYXRjaCh0cilcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNNYWNPUygpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnXG4gICAgPyAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgICA6IGZhbHNlXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGlzaU9TIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2lzaU9TLmpzJ1xuaW1wb3J0IHsgaXNNYWNPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc01hY09TLmpzJ1xuXG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWU6IHN0cmluZykge1xuICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pXG4gIGxldCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXVxuXG4gIGlmIChyZXN1bHQgPT09ICdTcGFjZScpIHtcbiAgICByZXN1bHQgPSAnICdcbiAgfVxuXG4gIGxldCBhbHRcbiAgbGV0IGN0cmxcbiAgbGV0IHNoaWZ0XG4gIGxldCBtZXRhXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICBjb25zdCBtb2QgPSBwYXJ0c1tpXVxuXG4gICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSkge1xuICAgICAgbWV0YSA9IHRydWVcbiAgICB9IGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSkge1xuICAgICAgYWx0ID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSkge1xuICAgICAgY3RybCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKSB7XG4gICAgICBzaGlmdCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgaWYgKGlzaU9TKCkgfHwgaXNNYWNPUygpKSB7XG4gICAgICAgIG1ldGEgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHJsID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiAke21vZH1gKVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbHQpIHtcbiAgICByZXN1bHQgPSBgQWx0LSR7cmVzdWx0fWBcbiAgfVxuXG4gIGlmIChjdHJsKSB7XG4gICAgcmVzdWx0ID0gYEN0cmwtJHtyZXN1bHR9YFxuICB9XG5cbiAgaWYgKG1ldGEpIHtcbiAgICByZXN1bHQgPSBgTWV0YS0ke3Jlc3VsdH1gXG4gIH1cblxuICBpZiAoc2hpZnQpIHtcbiAgICByZXN1bHQgPSBgU2hpZnQtJHtyZXN1bHR9YFxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAga2V5Ym9hcmRTaG9ydGN1dDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUcmlnZ2VyIGEga2V5Ym9hcmQgc2hvcnRjdXQuXG4gICAgICAgKi9cbiAgICAgIGtleWJvYXJkU2hvcnRjdXQ6IChuYW1lOiBzdHJpbmcpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBrZXlib2FyZFNob3J0Y3V0OiBSYXdDb21tYW5kc1sna2V5Ym9hcmRTaG9ydGN1dCddID0gbmFtZSA9PiAoe1xuICBlZGl0b3IsXG4gIHZpZXcsXG4gIHRyLFxuICBkaXNwYXRjaCxcbn0pID0+IHtcbiAgY29uc3Qga2V5cyA9IG5vcm1hbGl6ZUtleU5hbWUobmFtZSkuc3BsaXQoLy0oPyEkKS8pXG4gIGNvbnN0IGtleSA9IGtleXMuZmluZChpdGVtID0+ICFbJ0FsdCcsICdDdHJsJywgJ01ldGEnLCAnU2hpZnQnXS5pbmNsdWRlcyhpdGVtKSlcbiAgY29uc3QgZXZlbnQgPSBuZXcgS2V5Ym9hcmRFdmVudCgna2V5ZG93bicsIHtcbiAgICBrZXk6IGtleSA9PT0gJ1NwYWNlJ1xuICAgICAgPyAnICdcbiAgICAgIDoga2V5LFxuICAgIGFsdEtleToga2V5cy5pbmNsdWRlcygnQWx0JyksXG4gICAgY3RybEtleToga2V5cy5pbmNsdWRlcygnQ3RybCcpLFxuICAgIG1ldGFLZXk6IGtleXMuaW5jbHVkZXMoJ01ldGEnKSxcbiAgICBzaGlmdEtleToga2V5cy5pbmNsdWRlcygnU2hpZnQnKSxcbiAgICBidWJibGVzOiB0cnVlLFxuICAgIGNhbmNlbGFibGU6IHRydWUsXG4gIH0pXG5cbiAgY29uc3QgY2FwdHVyZWRUcmFuc2FjdGlvbiA9IGVkaXRvci5jYXB0dXJlVHJhbnNhY3Rpb24oKCkgPT4ge1xuICAgIHZpZXcuc29tZVByb3AoJ2hhbmRsZUtleURvd24nLCBmID0+IGYodmlldywgZXZlbnQpKVxuICB9KVxuXG4gIGNhcHR1cmVkVHJhbnNhY3Rpb24/LnN0ZXBzLmZvckVhY2goc3RlcCA9PiB7XG4gICAgY29uc3QgbmV3U3RlcCA9IHN0ZXAubWFwKHRyLm1hcHBpbmcpXG5cbiAgICBpZiAobmV3U3RlcCAmJiBkaXNwYXRjaCkge1xuICAgICAgdHIubWF5YmVTdGVwKG5ld1N0ZXApXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBOb2RlUmFuZ2UgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG9iamVjdEluY2x1ZGVzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL29iamVjdEluY2x1ZGVzLmpzJ1xuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuL2dldE5vZGVUeXBlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNOb2RlQWN0aXZlKFxuICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gIHR5cGVPck5hbWU6IE5vZGVUeXBlIHwgc3RyaW5nIHwgbnVsbCxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgZnJvbSwgdG8sIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb25cbiAgY29uc3QgdHlwZSA9IHR5cGVPck5hbWUgPyBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpIDogbnVsbFxuXG4gIGNvbnN0IG5vZGVSYW5nZXM6IE5vZGVSYW5nZVtdID0gW11cblxuICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZWxhdGl2ZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpXG4gICAgY29uc3QgcmVsYXRpdmVUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLm5vZGVTaXplKVxuXG4gICAgbm9kZVJhbmdlcy5wdXNoKHtcbiAgICAgIG5vZGUsXG4gICAgICBmcm9tOiByZWxhdGl2ZUZyb20sXG4gICAgICB0bzogcmVsYXRpdmVUbyxcbiAgICB9KVxuICB9KVxuXG4gIGNvbnN0IHNlbGVjdGlvblJhbmdlID0gdG8gLSBmcm9tXG4gIGNvbnN0IG1hdGNoZWROb2RlUmFuZ2VzID0gbm9kZVJhbmdlc1xuICAgIC5maWx0ZXIobm9kZVJhbmdlID0+IHtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBub2RlUmFuZ2Uubm9kZS50eXBlLm5hbWVcbiAgICB9KVxuICAgIC5maWx0ZXIobm9kZVJhbmdlID0+IG9iamVjdEluY2x1ZGVzKG5vZGVSYW5nZS5ub2RlLmF0dHJzLCBhdHRyaWJ1dGVzLCB7IHN0cmljdDogZmFsc2UgfSkpXG5cbiAgaWYgKGVtcHR5KSB7XG4gICAgcmV0dXJuICEhbWF0Y2hlZE5vZGVSYW5nZXMubGVuZ3RoXG4gIH1cblxuICBjb25zdCByYW5nZSA9IG1hdGNoZWROb2RlUmFuZ2VzLnJlZHVjZSgoc3VtLCBub2RlUmFuZ2UpID0+IHN1bSArIG5vZGVSYW5nZS50byAtIG5vZGVSYW5nZS5mcm9tLCAwKVxuXG4gIHJldHVybiByYW5nZSA+PSBzZWxlY3Rpb25SYW5nZVxufVxuIiwgImltcG9ydCB7IGxpZnQgYXMgb3JpZ2luYWxMaWZ0IH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcbmltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgaXNOb2RlQWN0aXZlIH0gZnJvbSAnLi4vaGVscGVycy9pc05vZGVBY3RpdmUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgbGlmdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFuIGV4aXN0aW5nIHdyYXAuXG4gICAgICAgKi9cbiAgICAgIGxpZnQ6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxpZnQ6IFJhd0NvbW1hbmRzWydsaWZ0J10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCBpc0FjdGl2ZSA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcylcblxuICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gb3JpZ2luYWxMaWZ0KHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBsaWZ0RW1wdHlCbG9jayBhcyBvcmlnaW5hbExpZnRFbXB0eUJsb2NrIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGxpZnRFbXB0eUJsb2NrOiB7XG4gICAgICAvKipcbiAgICAgICAqIExpZnQgYmxvY2sgaWYgZW1wdHkuXG4gICAgICAgKi9cbiAgICAgIGxpZnRFbXB0eUJsb2NrOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbGlmdEVtcHR5QmxvY2s6IFJhd0NvbW1hbmRzWydsaWZ0RW1wdHlCbG9jayddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsTGlmdEVtcHR5QmxvY2soc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IGxpZnRMaXN0SXRlbSBhcyBvcmlnaW5hbExpZnRMaXN0SXRlbSB9IGZyb20gJ0B0aXB0YXAvcG0vc2NoZW1hLWxpc3QnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBsaWZ0TGlzdEl0ZW06IHtcbiAgICAgIC8qKlxuICAgICAgICogTGlmdCB0aGUgbGlzdCBpdGVtIGludG8gYSB3cmFwcGluZyBsaXN0LlxuICAgICAgICovXG4gICAgICBsaWZ0TGlzdEl0ZW06ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbGlmdExpc3RJdGVtOiBSYXdDb21tYW5kc1snbGlmdExpc3RJdGVtJ10gPSB0eXBlT3JOYW1lID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgcmV0dXJuIG9yaWdpbmFsTGlmdExpc3RJdGVtKHR5cGUpKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBuZXdsaW5lSW5Db2RlIGFzIG9yaWdpbmFsTmV3bGluZUluQ29kZSB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBuZXdsaW5lSW5Db2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhIG5ld2xpbmUgY2hhcmFjdGVyIGluIGNvZGUuXG4gICAgICAgKi9cbiAgICAgIG5ld2xpbmVJbkNvZGU6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG5ld2xpbmVJbkNvZGU6IFJhd0NvbW1hbmRzWyduZXdsaW5lSW5Db2RlJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxOZXdsaW5lSW5Db2RlKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUobmFtZTogc3RyaW5nLCBzY2hlbWE6IFNjaGVtYSk6ICdub2RlJyB8ICdtYXJrJyB8IG51bGwge1xuICBpZiAoc2NoZW1hLm5vZGVzW25hbWVdKSB7XG4gICAgcmV0dXJuICdub2RlJ1xuICB9XG5cbiAgaWYgKHNjaGVtYS5tYXJrc1tuYW1lXSkge1xuICAgIHJldHVybiAnbWFyaydcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iLCAiLyoqXG4gKiBSZW1vdmUgYSBwcm9wZXJ0eSBvciBhbiBhcnJheSBvZiBwcm9wZXJ0aWVzIGZyb20gYW4gb2JqZWN0XG4gKiBAcGFyYW0gb2JqIE9iamVjdFxuICogQHBhcmFtIGtleSBLZXkgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVQcm9wcyhvYmo6IFJlY29yZDxzdHJpbmcsIGFueT4sIHByb3BPclByb3BzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCBwcm9wcyA9IHR5cGVvZiBwcm9wT3JQcm9wcyA9PT0gJ3N0cmluZydcbiAgICA/IFtwcm9wT3JQcm9wc11cbiAgICA6IHByb3BPclByb3BzXG5cbiAgcmV0dXJuIE9iamVjdFxuICAgIC5rZXlzKG9iailcbiAgICAucmVkdWNlKChuZXdPYmo6IFJlY29yZDxzdHJpbmcsIGFueT4sIHByb3ApID0+IHtcbiAgICAgIGlmICghcHJvcHMuaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgICAgbmV3T2JqW3Byb3BdID0gb2JqW3Byb3BdXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdPYmpcbiAgICB9LCB7fSlcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZGVsZXRlUHJvcHMgfSBmcm9tICcuLi91dGlsaXRpZXMvZGVsZXRlUHJvcHMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICByZXNldEF0dHJpYnV0ZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVzZXRzIHNvbWUgbm9kZSBhdHRyaWJ1dGVzIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICovXG4gICAgICByZXNldEF0dHJpYnV0ZXM6IChcbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUgfCBNYXJrVHlwZSxcbiAgICAgICAgYXR0cmlidXRlczogc3RyaW5nIHwgc3RyaW5nW10sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlc2V0QXR0cmlidXRlczogUmF3Q29tbWFuZHNbJ3Jlc2V0QXR0cmlidXRlcyddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMpID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBsZXQgbm9kZVR5cGU6IE5vZGVUeXBlIHwgbnVsbCA9IG51bGxcbiAgbGV0IG1hcmtUeXBlOiBNYXJrVHlwZSB8IG51bGwgPSBudWxsXG5cbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKFxuICAgIHR5cGVvZiB0eXBlT3JOYW1lID09PSAnc3RyaW5nJyA/IHR5cGVPck5hbWUgOiB0eXBlT3JOYW1lLm5hbWUsXG4gICAgc3RhdGUuc2NoZW1hLFxuICApXG5cbiAgaWYgKCFzY2hlbWFUeXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lIGFzIE5vZGVUeXBlLCBzdGF0ZS5zY2hlbWEpXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgbWFya1R5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lIGFzIE1hcmtUeXBlLCBzdGF0ZS5zY2hlbWEpXG4gIH1cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5zZWxlY3Rpb24ucmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbihyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlID09PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCBkZWxldGVQcm9wcyhub2RlLmF0dHJzLCBhdHRyaWJ1dGVzKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXJrVHlwZSAmJiBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaChtYXJrID0+IHtcbiAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgIHBvcyArIG5vZGUubm9kZVNpemUsXG4gICAgICAgICAgICAgICAgbWFya1R5cGUuY3JlYXRlKGRlbGV0ZVByb3BzKG1hcmsuYXR0cnMsIGF0dHJpYnV0ZXMpKSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNjcm9sbEludG9WaWV3OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCB0aGUgc2VsZWN0aW9uIGludG8gdmlldy5cbiAgICAgICAqL1xuICAgICAgc2Nyb2xsSW50b1ZpZXc6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzY3JvbGxJbnRvVmlldzogUmF3Q29tbWFuZHNbJ3Njcm9sbEludG9WaWV3J10gPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3RBbGw6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0IHRoZSB3aG9sZSBkb2N1bWVudC5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0QWxsOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0QWxsOiBSYXdDb21tYW5kc1snc2VsZWN0QWxsJ10gPSAoKSA9PiAoeyB0ciwgY29tbWFuZHMgfSkgPT4ge1xuICByZXR1cm4gY29tbWFuZHMuc2V0VGV4dFNlbGVjdGlvbih7XG4gICAgZnJvbTogMCxcbiAgICB0bzogdHIuZG9jLmNvbnRlbnQuc2l6ZSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBzZWxlY3ROb2RlQmFja3dhcmQgYXMgb3JpZ2luYWxTZWxlY3ROb2RlQmFja3dhcmQgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0Tm9kZUJhY2t3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNlbGVjdCBhIG5vZGUgYmFja3dhcmQuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdE5vZGVCYWNrd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0Tm9kZUJhY2t3YXJkOiBSYXdDb21tYW5kc1snc2VsZWN0Tm9kZUJhY2t3YXJkJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3ROb2RlQmFja3dhcmQoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IHNlbGVjdE5vZGVGb3J3YXJkIGFzIG9yaWdpbmFsU2VsZWN0Tm9kZUZvcndhcmQgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0Tm9kZUZvcndhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0IGEgbm9kZSBmb3J3YXJkLlxuICAgICAgICovXG4gICAgICBzZWxlY3ROb2RlRm9yd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0Tm9kZUZvcndhcmQ6IFJhd0NvbW1hbmRzWydzZWxlY3ROb2RlRm9yd2FyZCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0Tm9kZUZvcndhcmQoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IHNlbGVjdFBhcmVudE5vZGUgYXMgb3JpZ2luYWxTZWxlY3RQYXJlbnROb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdFBhcmVudE5vZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0IHRoZSBwYXJlbnQgbm9kZS5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0UGFyZW50Tm9kZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0UGFyZW50Tm9kZTogUmF3Q29tbWFuZHNbJ3NlbGVjdFBhcmVudE5vZGUnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbFNlbGVjdFBhcmVudE5vZGUoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgIi8vIEB0cy1pZ25vcmVcbi8vIFRPRE86IGFkZCB0eXBlcyB0byBAdHlwZXMvcHJvc2VtaXJyb3ItY29tbWFuZHNcbmltcG9ydCB7IHNlbGVjdFRleHRibG9ja0VuZCBhcyBvcmlnaW5hbFNlbGVjdFRleHRibG9ja0VuZCB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3RUZXh0YmxvY2tFbmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgZW5kIG9mIGN1cnJlbnQgdGV4dCBibG9jay5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0VGV4dGJsb2NrRW5kOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RUZXh0YmxvY2tFbmQ6IFJhd0NvbW1hbmRzWydzZWxlY3RUZXh0YmxvY2tFbmQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbFNlbGVjdFRleHRibG9ja0VuZChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiLy8gQHRzLWlnbm9yZVxuLy8gVE9ETzogYWRkIHR5cGVzIHRvIEB0eXBlcy9wcm9zZW1pcnJvci1jb21tYW5kc1xuaW1wb3J0IHsgc2VsZWN0VGV4dGJsb2NrU3RhcnQgYXMgb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tTdGFydCB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3RUZXh0YmxvY2tTdGFydDoge1xuICAgICAgLyoqXG4gICAgICAgKiBNb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBzdGFydCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdFRleHRibG9ja1N0YXJ0OiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RUZXh0YmxvY2tTdGFydDogUmF3Q29tbWFuZHNbJ3NlbGVjdFRleHRibG9ja1N0YXJ0J10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tTdGFydChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIFBhcnNlT3B0aW9ucywgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgQ29udGVudCB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY3JlYXRlTm9kZUZyb21Db250ZW50IH0gZnJvbSAnLi9jcmVhdGVOb2RlRnJvbUNvbnRlbnQuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEb2N1bWVudChcbiAgY29udGVudDogQ29udGVudCxcbiAgc2NoZW1hOiBTY2hlbWEsXG4gIHBhcnNlT3B0aW9uczogUGFyc2VPcHRpb25zID0ge30sXG4pOiBQcm9zZU1pcnJvck5vZGUge1xuICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KGNvbnRlbnQsIHNjaGVtYSwgeyBzbGljZTogZmFsc2UsIHBhcnNlT3B0aW9ucyB9KSBhcyBQcm9zZU1pcnJvck5vZGVcbn1cbiIsICJpbXBvcnQgeyBQYXJzZU9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBjcmVhdGVEb2N1bWVudCB9IGZyb20gJy4uL2hlbHBlcnMvY3JlYXRlRG9jdW1lbnQuanMnXG5pbXBvcnQgeyBDb250ZW50LCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0Q29udGVudDoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXBsYWNlIHRoZSB3aG9sZSBkb2N1bWVudCB3aXRoIG5ldyBjb250ZW50LlxuICAgICAgICovXG4gICAgICBzZXRDb250ZW50OiAoXG4gICAgICAgIGNvbnRlbnQ6IENvbnRlbnQsXG4gICAgICAgIGVtaXRVcGRhdGU/OiBib29sZWFuLFxuICAgICAgICBwYXJzZU9wdGlvbnM/OiBQYXJzZU9wdGlvbnMsXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldENvbnRlbnQ6IFJhd0NvbW1hbmRzWydzZXRDb250ZW50J10gPSAoY29udGVudCwgZW1pdFVwZGF0ZSA9IGZhbHNlLCBwYXJzZU9wdGlvbnMgPSB7fSkgPT4gKHsgdHIsIGVkaXRvciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IGRvYyB9ID0gdHJcbiAgY29uc3QgZG9jdW1lbnQgPSBjcmVhdGVEb2N1bWVudChjb250ZW50LCBlZGl0b3Iuc2NoZW1hLCBwYXJzZU9wdGlvbnMpXG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIucmVwbGFjZVdpdGgoMCwgZG9jLmNvbnRlbnQuc2l6ZSwgZG9jdW1lbnQpLnNldE1ldGEoJ3ByZXZlbnRVcGRhdGUnLCAhZW1pdFVwZGF0ZSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgTWFyaywgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4vZ2V0TWFya1R5cGUuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJrQXR0cmlidXRlcyhcbiAgc3RhdGU6IEVkaXRvclN0YXRlLFxuICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBNYXJrVHlwZSxcbik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCB7IGZyb20sIHRvLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IG1hcmtzOiBNYXJrW10gPSBbXVxuXG4gIGlmIChlbXB0eSkge1xuICAgIGlmIChzdGF0ZS5zdG9yZWRNYXJrcykge1xuICAgICAgbWFya3MucHVzaCguLi5zdGF0ZS5zdG9yZWRNYXJrcylcbiAgICB9XG5cbiAgICBtYXJrcy5wdXNoKC4uLnN0YXRlLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKVxuICB9IGVsc2Uge1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIG5vZGUgPT4ge1xuICAgICAgbWFya3MucHVzaCguLi5ub2RlLm1hcmtzKVxuICAgIH0pXG4gIH1cblxuICBjb25zdCBtYXJrID0gbWFya3MuZmluZChtYXJrSXRlbSA9PiBtYXJrSXRlbS50eXBlLm5hbWUgPT09IHR5cGUubmFtZSlcblxuICBpZiAoIW1hcmspIHtcbiAgICByZXR1cm4ge31cbiAgfVxuXG4gIHJldHVybiB7IC4uLm1hcmsuYXR0cnMgfVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgYFRyYW5zZm9ybWAgYmFzZWQgb24gYWxsIHN0ZXBzIG9mIHRoZSBwYXNzZWQgdHJhbnNhY3Rpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZVRyYW5zYWN0aW9uU3RlcHMoXG4gIG9sZERvYzogUHJvc2VNaXJyb3JOb2RlLFxuICB0cmFuc2FjdGlvbnM6IFRyYW5zYWN0aW9uW10sXG4pOiBUcmFuc2Zvcm0ge1xuICBjb25zdCB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKG9sZERvYylcblxuICB0cmFuc2FjdGlvbnMuZm9yRWFjaCh0cmFuc2FjdGlvbiA9PiB7XG4gICAgdHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaChzdGVwID0+IHtcbiAgICAgIHRyYW5zZm9ybS5zdGVwKHN0ZXApXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gdHJhbnNmb3JtXG59XG4iLCAiaW1wb3J0IHsgQ29udGVudE1hdGNoLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0QmxvY2tBdChtYXRjaDogQ29udGVudE1hdGNoKTogTm9kZVR5cGUgfCBudWxsIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkgKz0gMSkge1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gbWF0Y2guZWRnZShpKVxuXG4gICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSB7XG4gICAgICByZXR1cm4gdHlwZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBOb2RlV2l0aFBvcywgUHJlZGljYXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ2hpbGRyZW4obm9kZTogUHJvc2VNaXJyb3JOb2RlLCBwcmVkaWNhdGU6IFByZWRpY2F0ZSk6IE5vZGVXaXRoUG9zW10ge1xuICBjb25zdCBub2Rlc1dpdGhQb3M6IE5vZGVXaXRoUG9zW10gPSBbXVxuXG4gIG5vZGUuZGVzY2VuZGFudHMoKGNoaWxkLCBwb3MpID0+IHtcbiAgICBpZiAocHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xuICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgcG9zLFxuICAgICAgfSlcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIG5vZGVzV2l0aFBvc1xufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgTm9kZVdpdGhQb3MsIFByZWRpY2F0ZSwgUmFuZ2UgfSBmcm9tICcuLi90eXBlcy5qcydcblxuLyoqXG4gKiBTYW1lIGFzIGBmaW5kQ2hpbGRyZW5gIGJ1dCBzZWFyY2hlcyBvbmx5IHdpdGhpbiBhIGByYW5nZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ2hpbGRyZW5JblJhbmdlKFxuICBub2RlOiBQcm9zZU1pcnJvck5vZGUsXG4gIHJhbmdlOiBSYW5nZSxcbiAgcHJlZGljYXRlOiBQcmVkaWNhdGUsXG4pOiBOb2RlV2l0aFBvc1tdIHtcbiAgY29uc3Qgbm9kZXNXaXRoUG9zOiBOb2RlV2l0aFBvc1tdID0gW11cblxuICAvLyBpZiAocmFuZ2UuZnJvbSA9PT0gcmFuZ2UudG8pIHtcbiAgLy8gICBjb25zdCBub2RlQXQgPSBub2RlLm5vZGVBdChyYW5nZS5mcm9tKVxuXG4gIC8vICAgaWYgKG5vZGVBdCkge1xuICAvLyAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xuICAvLyAgICAgICBub2RlOiBub2RlQXQsXG4gIC8vICAgICAgIHBvczogcmFuZ2UuZnJvbSxcbiAgLy8gICAgIH0pXG4gIC8vICAgfVxuICAvLyB9XG5cbiAgbm9kZS5ub2Rlc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIChjaGlsZCwgcG9zKSA9PiB7XG4gICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgIHBvcyxcbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBub2Rlc1dpdGhQb3Ncbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgUmVzb2x2ZWRQb3MgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBQcmVkaWNhdGUgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zKFxuICAkcG9zOiBSZXNvbHZlZFBvcyxcbiAgcHJlZGljYXRlOiBQcmVkaWNhdGUsXG4pOlxuICB8IHtcbiAgICAgIHBvczogbnVtYmVyXG4gICAgICBzdGFydDogbnVtYmVyXG4gICAgICBkZXB0aDogbnVtYmVyXG4gICAgICBub2RlOiBQcm9zZU1pcnJvck5vZGVcbiAgICB9XG4gIHwgdW5kZWZpbmVkIHtcbiAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGg7IGkgPiAwOyBpIC09IDEpIHtcbiAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGkpXG5cbiAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IGkgPiAwID8gJHBvcy5iZWZvcmUoaSkgOiAwLFxuICAgICAgICBzdGFydDogJHBvcy5zdGFydChpKSxcbiAgICAgICAgZGVwdGg6IGksXG4gICAgICAgIG5vZGUsXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHsgU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgUHJlZGljYXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1BvcyB9IGZyb20gJy4vZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUGFyZW50Tm9kZShwcmVkaWNhdGU6IFByZWRpY2F0ZSkge1xuICByZXR1cm4gKHNlbGVjdGlvbjogU2VsZWN0aW9uKSA9PiBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1BvcyhzZWxlY3Rpb24uJGZyb20sIHByZWRpY2F0ZSlcbn1cbiIsICJpbXBvcnQgeyBET01TZXJpYWxpemVyLCBGcmFnbWVudCwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhUTUxGcm9tRnJhZ21lbnQoZnJhZ21lbnQ6IEZyYWdtZW50LCBzY2hlbWE6IFNjaGVtYSk6IHN0cmluZyB7XG4gIGNvbnN0IGRvY3VtZW50RnJhZ21lbnQgPSBET01TZXJpYWxpemVyLmZyb21TY2hlbWEoc2NoZW1hKS5zZXJpYWxpemVGcmFnbWVudChmcmFnbWVudClcblxuICBjb25zdCB0ZW1wb3JhcnlEb2N1bWVudCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgpXG4gIGNvbnN0IGNvbnRhaW5lciA9IHRlbXBvcmFyeURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50RnJhZ21lbnQpXG5cbiAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbn1cbiIsICJpbXBvcnQgeyBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBFeHRlbnNpb25NYW5hZ2VyIH0gZnJvbSAnLi4vRXh0ZW5zaW9uTWFuYWdlci5qcydcbmltcG9ydCB7IEV4dGVuc2lvbnMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zIH0gZnJvbSAnLi9nZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYShleHRlbnNpb25zOiBFeHRlbnNpb25zLCBlZGl0b3I/OiBFZGl0b3IpOiBTY2hlbWEge1xuICBjb25zdCByZXNvbHZlZEV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnJlc29sdmUoZXh0ZW5zaW9ucylcblxuICByZXR1cm4gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMocmVzb2x2ZWRFeHRlbnNpb25zLCBlZGl0b3IpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEV4dGVuc2lvbnMsIEpTT05Db250ZW50IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRIVE1MRnJvbUZyYWdtZW50IH0gZnJvbSAnLi9nZXRIVE1MRnJvbUZyYWdtZW50LmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hIH0gZnJvbSAnLi9nZXRTY2hlbWEuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUhUTUwoZG9jOiBKU09OQ29udGVudCwgZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IHN0cmluZyB7XG4gIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKVxuICBjb25zdCBjb250ZW50Tm9kZSA9IE5vZGUuZnJvbUpTT04oc2NoZW1hLCBkb2MpXG5cbiAgcmV0dXJuIGdldEhUTUxGcm9tRnJhZ21lbnQoY29udGVudE5vZGUuY29udGVudCwgc2NoZW1hKVxufVxuIiwgImltcG9ydCB7IERPTVBhcnNlciB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEV4dGVuc2lvbnMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGVsZW1lbnRGcm9tU3RyaW5nIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2VsZW1lbnRGcm9tU3RyaW5nLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hIH0gZnJvbSAnLi9nZXRTY2hlbWEuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUpTT04oaHRtbDogc3RyaW5nLCBleHRlbnNpb25zOiBFeHRlbnNpb25zKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKVxuICBjb25zdCBkb20gPSBlbGVtZW50RnJvbVN0cmluZyhodG1sKVxuXG4gIHJldHVybiBET01QYXJzZXIuZnJvbVNjaGVtYShzY2hlbWEpLnBhcnNlKGRvbSkudG9KU09OKClcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IFRleHRTZXJpYWxpemVyIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRUZXh0QmV0d2VlbiB9IGZyb20gJy4vZ2V0VGV4dEJldHdlZW4uanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0KFxuICBub2RlOiBQcm9zZU1pcnJvck5vZGUsXG4gIG9wdGlvbnM/OiB7XG4gICAgYmxvY2tTZXBhcmF0b3I/OiBzdHJpbmdcbiAgICB0ZXh0U2VyaWFsaXplcnM/OiBSZWNvcmQ8c3RyaW5nLCBUZXh0U2VyaWFsaXplcj5cbiAgfSxcbikge1xuICBjb25zdCByYW5nZSA9IHtcbiAgICBmcm9tOiAwLFxuICAgIHRvOiBub2RlLmNvbnRlbnQuc2l6ZSxcbiAgfVxuXG4gIHJldHVybiBnZXRUZXh0QmV0d2Vlbihub2RlLCByYW5nZSwgb3B0aW9ucylcbn1cbiIsICJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRXh0ZW5zaW9ucywgSlNPTkNvbnRlbnQsIFRleHRTZXJpYWxpemVyIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWEgfSBmcm9tICcuL2dldFNjaGVtYS5qcydcbmltcG9ydCB7IGdldFRleHQgfSBmcm9tICcuL2dldFRleHQuanMnXG5pbXBvcnQgeyBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hIH0gZnJvbSAnLi9nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVUZXh0KFxuICBkb2M6IEpTT05Db250ZW50LFxuICBleHRlbnNpb25zOiBFeHRlbnNpb25zLFxuICBvcHRpb25zPzoge1xuICAgIGJsb2NrU2VwYXJhdG9yPzogc3RyaW5nXG4gICAgdGV4dFNlcmlhbGl6ZXJzPzogUmVjb3JkPHN0cmluZywgVGV4dFNlcmlhbGl6ZXI+XG4gIH0sXG4pOiBzdHJpbmcge1xuICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9XG4gIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKVxuICBjb25zdCBjb250ZW50Tm9kZSA9IE5vZGUuZnJvbUpTT04oc2NoZW1hLCBkb2MpXG5cbiAgcmV0dXJuIGdldFRleHQoY29udGVudE5vZGUsIHtcbiAgICBibG9ja1NlcGFyYXRvcixcbiAgICB0ZXh0U2VyaWFsaXplcnM6IHtcbiAgICAgIC4uLmdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKSxcbiAgICAgIC4uLnRleHRTZXJpYWxpemVycyxcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IE5vZGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuL2dldE5vZGVUeXBlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZUF0dHJpYnV0ZXMoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsXG4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgeyBmcm9tLCB0byB9ID0gc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IG5vZGVzOiBOb2RlW10gPSBbXVxuXG4gIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIG5vZGUgPT4ge1xuICAgIG5vZGVzLnB1c2gobm9kZSlcbiAgfSlcblxuICBjb25zdCBub2RlID0gbm9kZXMucmV2ZXJzZSgpLmZpbmQobm9kZUl0ZW0gPT4gbm9kZUl0ZW0udHlwZS5uYW1lID09PSB0eXBlLm5hbWUpXG5cbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cblxuICByZXR1cm4geyAuLi5ub2RlLmF0dHJzIH1cbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRNYXJrQXR0cmlidXRlcyB9IGZyb20gJy4vZ2V0TWFya0F0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXROb2RlQXR0cmlidXRlcyB9IGZyb20gJy4vZ2V0Tm9kZUF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSB9IGZyb20gJy4vZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKFxuICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gIHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlIHwgTWFya1R5cGUsXG4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKFxuICAgIHR5cGVvZiB0eXBlT3JOYW1lID09PSAnc3RyaW5nJyA/IHR5cGVPck5hbWUgOiB0eXBlT3JOYW1lLm5hbWUsXG4gICAgc3RhdGUuc2NoZW1hLFxuICApXG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xuICAgIHJldHVybiBnZXROb2RlQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSBhcyBOb2RlVHlwZSlcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICByZXR1cm4gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUgYXMgTWFya1R5cGUpXG4gIH1cblxuICByZXR1cm4ge31cbn1cbiIsICIvKipcbiAqIFJlbW92ZXMgZHVwbGljYXRlZCB2YWx1ZXMgd2l0aGluIGFuIGFycmF5LlxuICogU3VwcG9ydHMgbnVtYmVycywgc3RyaW5ncyBhbmQgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZXM8VD4oYXJyYXk6IFRbXSwgYnkgPSBKU09OLnN0cmluZ2lmeSk6IFRbXSB7XG4gIGNvbnN0IHNlZW46IFJlY29yZDxhbnksIGFueT4gPSB7fVxuXG4gIHJldHVybiBhcnJheS5maWx0ZXIoaXRlbSA9PiB7XG4gICAgY29uc3Qga2V5ID0gYnkoaXRlbSlcblxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2Vlbiwga2V5KVxuICAgICAgPyBmYWxzZVxuICAgICAgOiAoc2VlbltrZXldID0gdHJ1ZSlcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBTdGVwLCBUcmFuc2Zvcm0gfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IHJlbW92ZUR1cGxpY2F0ZXMgfSBmcm9tICcuLi91dGlsaXRpZXMvcmVtb3ZlRHVwbGljYXRlcy5qcydcblxuZXhwb3J0IHR5cGUgQ2hhbmdlZFJhbmdlID0ge1xuICBvbGRSYW5nZTogUmFuZ2UsXG4gIG5ld1JhbmdlOiBSYW5nZSxcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGR1cGxpY2F0ZWQgcmFuZ2VzIGFuZCByYW5nZXMgdGhhdCBhcmVcbiAqIGZ1bGx5IGNhcHR1cmVkIGJ5IG90aGVyIHJhbmdlcy5cbiAqL1xuZnVuY3Rpb24gc2ltcGxpZnlDaGFuZ2VkUmFuZ2VzKGNoYW5nZXM6IENoYW5nZWRSYW5nZVtdKTogQ2hhbmdlZFJhbmdlW10ge1xuICBjb25zdCB1bmlxdWVDaGFuZ2VzID0gcmVtb3ZlRHVwbGljYXRlcyhjaGFuZ2VzKVxuXG4gIHJldHVybiB1bmlxdWVDaGFuZ2VzLmxlbmd0aCA9PT0gMVxuICAgID8gdW5pcXVlQ2hhbmdlc1xuICAgIDogdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKGNoYW5nZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3QgPSB1bmlxdWVDaGFuZ2VzLmZpbHRlcigoXywgaSkgPT4gaSAhPT0gaW5kZXgpXG5cbiAgICAgIHJldHVybiAhcmVzdC5zb21lKG90aGVyQ2hhbmdlID0+IHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZS5vbGRSYW5nZS5mcm9tID49IG90aGVyQ2hhbmdlLm9sZFJhbmdlLmZyb21cbiAgICAgICAgICAmJiBjaGFuZ2Uub2xkUmFuZ2UudG8gPD0gb3RoZXJDaGFuZ2Uub2xkUmFuZ2UudG9cbiAgICAgICAgICAmJiBjaGFuZ2UubmV3UmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5uZXdSYW5nZS5mcm9tXG4gICAgICAgICAgJiYgY2hhbmdlLm5ld1JhbmdlLnRvIDw9IG90aGVyQ2hhbmdlLm5ld1JhbmdlLnRvXG4gICAgICB9KVxuICAgIH0pXG59XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgY2hhbmdlZCByYW5nZXNcbiAqIGJhc2VkIG9uIHRoZSBmaXJzdCBhbmQgbGFzdCBzdGF0ZSBvZiBhbGwgc3RlcHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFuZ2VkUmFuZ2VzKHRyYW5zZm9ybTogVHJhbnNmb3JtKTogQ2hhbmdlZFJhbmdlW10ge1xuICBjb25zdCB7IG1hcHBpbmcsIHN0ZXBzIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgY2hhbmdlczogQ2hhbmdlZFJhbmdlW10gPSBbXVxuXG4gIG1hcHBpbmcubWFwcy5mb3JFYWNoKChzdGVwTWFwLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHJhbmdlczogUmFuZ2VbXSA9IFtdXG5cbiAgICAvLyBUaGlzIGFjY291bnRzIGZvciBzdGVwIGNoYW5nZXMgd2hlcmUgbm8gcmFuZ2Ugd2FzIGFjdHVhbGx5IGFsdGVyZWRcbiAgICAvLyBlLmcuIHdoZW4gc2V0dGluZyBhIG1hcmssIG5vZGUgYXR0cmlidXRlLCBldGMuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICghc3RlcE1hcC5yYW5nZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSBzdGVwc1tpbmRleF0gYXMgU3RlcCAmIHtcbiAgICAgICAgZnJvbT86IG51bWJlcixcbiAgICAgICAgdG8/OiBudW1iZXIsXG4gICAgICB9XG5cbiAgICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQgfHwgdG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGVwTWFwLmZvckVhY2goKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmFuZ2VzLmZvckVhY2goKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgY29uc3QgbmV3U3RhcnQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAoZnJvbSwgLTEpXG4gICAgICBjb25zdCBuZXdFbmQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAodG8pXG4gICAgICBjb25zdCBvbGRTdGFydCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld1N0YXJ0LCAtMSlcbiAgICAgIGNvbnN0IG9sZEVuZCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld0VuZClcblxuICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgb2xkUmFuZ2U6IHtcbiAgICAgICAgICBmcm9tOiBvbGRTdGFydCxcbiAgICAgICAgICB0bzogb2xkRW5kLFxuICAgICAgICB9LFxuICAgICAgICBuZXdSYW5nZToge1xuICAgICAgICAgIGZyb206IG5ld1N0YXJ0LFxuICAgICAgICAgIHRvOiBuZXdFbmQsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzKVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgSlNPTkNvbnRlbnQgfSBmcm9tICcuLi90eXBlcy5qcydcblxuaW50ZXJmYWNlIERlYnVnSlNPTkNvbnRlbnQgZXh0ZW5kcyBKU09OQ29udGVudCB7XG4gIGZyb206IG51bWJlclxuICB0bzogbnVtYmVyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWJ1Z0pTT04obm9kZTogUHJvc2VNaXJyb3JOb2RlLCBzdGFydE9mZnNldCA9IDApOiBEZWJ1Z0pTT05Db250ZW50IHtcbiAgY29uc3QgaXNUb3BOb2RlID0gbm9kZS50eXBlID09PSBub2RlLnR5cGUuc2NoZW1hLnRvcE5vZGVUeXBlXG4gIGNvbnN0IGluY3JlbWVudCA9IGlzVG9wTm9kZSA/IDAgOiAxXG4gIGNvbnN0IGZyb20gPSBzdGFydE9mZnNldFxuICBjb25zdCB0byA9IGZyb20gKyBub2RlLm5vZGVTaXplXG4gIGNvbnN0IG1hcmtzID0gbm9kZS5tYXJrcy5tYXAobWFyayA9PiB7XG4gICAgY29uc3Qgb3V0cHV0OiB7IHR5cGU6IHN0cmluZzsgYXR0cnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+IH0gPSB7XG4gICAgICB0eXBlOiBtYXJrLnR5cGUubmFtZSxcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXMobWFyay5hdHRycykubGVuZ3RoKSB7XG4gICAgICBvdXRwdXQuYXR0cnMgPSB7IC4uLm1hcmsuYXR0cnMgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXRcbiAgfSlcbiAgY29uc3QgYXR0cnMgPSB7IC4uLm5vZGUuYXR0cnMgfVxuICBjb25zdCBvdXRwdXQ6IERlYnVnSlNPTkNvbnRlbnQgPSB7XG4gICAgdHlwZTogbm9kZS50eXBlLm5hbWUsXG4gICAgZnJvbSxcbiAgICB0byxcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoKSB7XG4gICAgb3V0cHV0LmF0dHJzID0gYXR0cnNcbiAgfVxuXG4gIGlmIChtYXJrcy5sZW5ndGgpIHtcbiAgICBvdXRwdXQubWFya3MgPSBtYXJrc1xuICB9XG5cbiAgaWYgKG5vZGUuY29udGVudC5jaGlsZENvdW50KSB7XG4gICAgb3V0cHV0LmNvbnRlbnQgPSBbXVxuXG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZCwgb2Zmc2V0KSA9PiB7XG4gICAgICBvdXRwdXQuY29udGVudD8ucHVzaChnZXREZWJ1Z0pTT04oY2hpbGQsIHN0YXJ0T2Zmc2V0ICsgb2Zmc2V0ICsgaW5jcmVtZW50KSlcbiAgICB9KVxuICB9XG5cbiAgaWYgKG5vZGUudGV4dCkge1xuICAgIG91dHB1dC50ZXh0ID0gbm9kZS50ZXh0XG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBNYXJrUmFuZ2UgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldE1hcmtSYW5nZSB9IGZyb20gJy4vZ2V0TWFya1JhbmdlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFya3NCZXR3ZWVuKGZyb206IG51bWJlciwgdG86IG51bWJlciwgZG9jOiBQcm9zZU1pcnJvck5vZGUpOiBNYXJrUmFuZ2VbXSB7XG4gIGNvbnN0IG1hcmtzOiBNYXJrUmFuZ2VbXSA9IFtdXG5cbiAgLy8gZ2V0IGFsbCBpbmNsdXNpdmUgbWFya3Mgb24gZW1wdHkgc2VsZWN0aW9uXG4gIGlmIChmcm9tID09PSB0bykge1xuICAgIGRvY1xuICAgICAgLnJlc29sdmUoZnJvbSlcbiAgICAgIC5tYXJrcygpXG4gICAgICAuZm9yRWFjaChtYXJrID0+IHtcbiAgICAgICAgY29uc3QgJHBvcyA9IGRvYy5yZXNvbHZlKGZyb20gLSAxKVxuICAgICAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkcG9zLCBtYXJrLnR5cGUpXG5cbiAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgbWFyayxcbiAgICAgICAgICAuLi5yYW5nZSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbWFya3MucHVzaChcbiAgICAgICAgLi4ubm9kZS5tYXJrcy5tYXAobWFyayA9PiAoe1xuICAgICAgICAgIGZyb206IHBvcyxcbiAgICAgICAgICB0bzogcG9zICsgbm9kZS5ub2RlU2l6ZSxcbiAgICAgICAgICBtYXJrLFxuICAgICAgICB9KSksXG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBtYXJrc1xufVxuIiwgImltcG9ydCB7IE5vZGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3Qgbm9kZSBvZiBhIGdpdmVuIHR5cGUgb3IgbmFtZSBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKiBAcGFyYW0gc3RhdGUgVGhlIGVkaXRvciBzdGF0ZS5cbiAqIEBwYXJhbSB0eXBlT3JOYW1lIFRoZSBub2RlIHR5cGUgb3IgbmFtZS5cbiAqIEBwYXJhbSBwb3MgVGhlIHBvc2l0aW9uIHRvIHN0YXJ0IHNlYXJjaGluZyBmcm9tLlxuICogQHBhcmFtIG1heERlcHRoIFRoZSBtYXhpbXVtIGRlcHRoIHRvIHNlYXJjaC5cbiAqIEByZXR1cm5zIFRoZSBub2RlIGFuZCB0aGUgZGVwdGggYXMgYW4gYXJyYXkuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXROb2RlQXRQb3NpdGlvbiA9IChzdGF0ZTogRWRpdG9yU3RhdGUsIHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBwb3M6IG51bWJlciwgbWF4RGVwdGggPSAyMCkgPT4ge1xuICBjb25zdCAkcG9zID0gc3RhdGUuZG9jLnJlc29sdmUocG9zKVxuXG4gIGxldCBjdXJyZW50RGVwdGggPSBtYXhEZXB0aFxuICBsZXQgbm9kZTogTm9kZSB8IG51bGwgPSBudWxsXG5cbiAgd2hpbGUgKGN1cnJlbnREZXB0aCA+IDAgJiYgbm9kZSA9PT0gbnVsbCkge1xuICAgIGNvbnN0IGN1cnJlbnROb2RlID0gJHBvcy5ub2RlKGN1cnJlbnREZXB0aClcblxuICAgIGlmIChjdXJyZW50Tm9kZT8udHlwZS5uYW1lID09PSB0eXBlT3JOYW1lKSB7XG4gICAgICBub2RlID0gY3VycmVudE5vZGVcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudERlcHRoIC09IDFcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW25vZGUsIGN1cnJlbnREZXB0aF0gYXMgW05vZGUgfCBudWxsLCBudW1iZXJdXG59XG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uQXR0cmlidXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoXG4gIGV4dGVuc2lvbkF0dHJpYnV0ZXM6IEV4dGVuc2lvbkF0dHJpYnV0ZVtdLFxuICB0eXBlTmFtZTogc3RyaW5nLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0XG4gICAgLmVudHJpZXMoYXR0cmlidXRlcylcbiAgICAuZmlsdGVyKChbbmFtZV0pID0+IHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZSA9IGV4dGVuc2lvbkF0dHJpYnV0ZXMuZmluZChpdGVtID0+IHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PT0gdHlwZU5hbWUgJiYgaXRlbS5uYW1lID09PSBuYW1lXG4gICAgICB9KVxuXG4gICAgICBpZiAoIWV4dGVuc2lvbkF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZS5hdHRyaWJ1dGUua2VlcE9uU3BsaXRcbiAgICB9KSlcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IE1hcmtSYW5nZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgb2JqZWN0SW5jbHVkZXMgfSBmcm9tICcuLi91dGlsaXRpZXMvb2JqZWN0SW5jbHVkZXMuanMnXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4vZ2V0TWFya1R5cGUuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc01hcmtBY3RpdmUoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgdHlwZU9yTmFtZTogTWFya1R5cGUgfCBzdHJpbmcgfCBudWxsLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30sXG4pOiBib29sZWFuIHtcbiAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzdGF0ZS5zZWxlY3Rpb25cbiAgY29uc3QgdHlwZSA9IHR5cGVPck5hbWUgPyBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpIDogbnVsbFxuXG4gIGlmIChlbXB0eSkge1xuICAgIHJldHVybiAhIShzdGF0ZS5zdG9yZWRNYXJrcyB8fCBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcbiAgICAgIC5maWx0ZXIobWFyayA9PiB7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBtYXJrLnR5cGUubmFtZVxuICAgICAgfSlcbiAgICAgIC5maW5kKG1hcmsgPT4gb2JqZWN0SW5jbHVkZXMobWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKVxuICB9XG5cbiAgbGV0IHNlbGVjdGlvblJhbmdlID0gMFxuICBjb25zdCBtYXJrUmFuZ2VzOiBNYXJrUmFuZ2VbXSA9IFtdXG5cbiAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgY29uc3QgZnJvbSA9ICRmcm9tLnBvc1xuICAgIGNvbnN0IHRvID0gJHRvLnBvc1xuXG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgaWYgKCFub2RlLmlzVGV4dCAmJiAhbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlbGF0aXZlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcylcbiAgICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBNYXRoLm1pbih0bywgcG9zICsgbm9kZS5ub2RlU2l6ZSlcbiAgICAgIGNvbnN0IHJhbmdlID0gcmVsYXRpdmVUbyAtIHJlbGF0aXZlRnJvbVxuXG4gICAgICBzZWxlY3Rpb25SYW5nZSArPSByYW5nZVxuXG4gICAgICBtYXJrUmFuZ2VzLnB1c2goXG4gICAgICAgIC4uLm5vZGUubWFya3MubWFwKG1hcmsgPT4gKHtcbiAgICAgICAgICBtYXJrLFxuICAgICAgICAgIGZyb206IHJlbGF0aXZlRnJvbSxcbiAgICAgICAgICB0bzogcmVsYXRpdmVUbyxcbiAgICAgICAgfSkpLFxuICAgICAgKVxuICAgIH0pXG4gIH0pXG5cbiAgaWYgKHNlbGVjdGlvblJhbmdlID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBjYWxjdWxhdGUgcmFuZ2Ugb2YgbWF0Y2hlZCBtYXJrXG4gIGNvbnN0IG1hdGNoZWRSYW5nZSA9IG1hcmtSYW5nZXNcbiAgICAuZmlsdGVyKG1hcmtSYW5nZSA9PiB7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gbWFya1JhbmdlLm1hcmsudHlwZS5uYW1lXG4gICAgfSlcbiAgICAuZmlsdGVyKG1hcmtSYW5nZSA9PiBvYmplY3RJbmNsdWRlcyhtYXJrUmFuZ2UubWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKVxuICAgIC5yZWR1Y2UoKHN1bSwgbWFya1JhbmdlKSA9PiBzdW0gKyBtYXJrUmFuZ2UudG8gLSBtYXJrUmFuZ2UuZnJvbSwgMClcblxuICAvLyBjYWxjdWxhdGUgcmFuZ2Ugb2YgbWFya3MgdGhhdCBleGNsdWRlcyB0aGUgc2VhcmNoZWQgbWFya1xuICAvLyBmb3IgZXhhbXBsZSBgY29kZWAgZG9lc27igJl0IGFsbG93IGFueSBvdGhlciBtYXJrc1xuICBjb25zdCBleGNsdWRlZFJhbmdlID0gbWFya1Jhbmdlc1xuICAgIC5maWx0ZXIobWFya1JhbmdlID0+IHtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFya1JhbmdlLm1hcmsudHlwZSAhPT0gdHlwZSAmJiBtYXJrUmFuZ2UubWFyay50eXBlLmV4Y2x1ZGVzKHR5cGUpXG4gICAgfSlcbiAgICAucmVkdWNlKChzdW0sIG1hcmtSYW5nZSkgPT4gc3VtICsgbWFya1JhbmdlLnRvIC0gbWFya1JhbmdlLmZyb20sIDApXG5cbiAgLy8gd2Ugb25seSBpbmNsdWRlIHRoZSByZXN1bHQgb2YgYGV4Y2x1ZGVkUmFuZ2VgXG4gIC8vIGlmIHRoZXJlIGlzIGEgbWF0Y2ggYXQgYWxsXG4gIGNvbnN0IHJhbmdlID0gbWF0Y2hlZFJhbmdlID4gMCA/IG1hdGNoZWRSYW5nZSArIGV4Y2x1ZGVkUmFuZ2UgOiBtYXRjaGVkUmFuZ2VcblxuICByZXR1cm4gcmFuZ2UgPj0gc2VsZWN0aW9uUmFuZ2Vcbn1cbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lIH0gZnJvbSAnLi9nZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZS5qcydcbmltcG9ydCB7IGlzTWFya0FjdGl2ZSB9IGZyb20gJy4vaXNNYXJrQWN0aXZlLmpzJ1xuaW1wb3J0IHsgaXNOb2RlQWN0aXZlIH0gZnJvbSAnLi9pc05vZGVBY3RpdmUuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FjdGl2ZShcbiAgc3RhdGU6IEVkaXRvclN0YXRlLFxuICBuYW1lOiBzdHJpbmcgfCBudWxsLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30sXG4pOiBib29sZWFuIHtcbiAgaWYgKCFuYW1lKSB7XG4gICAgcmV0dXJuIGlzTm9kZUFjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcykgfHwgaXNNYXJrQWN0aXZlKHN0YXRlLCBudWxsLCBhdHRyaWJ1dGVzKVxuICB9XG5cbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKG5hbWUsIHN0YXRlLnNjaGVtYSlcblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgcmV0dXJuIGlzTm9kZUFjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcylcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICByZXR1cm4gaXNNYXJrQWN0aXZlKHN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzKVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBmaW5kUGFyZW50Tm9kZSB9IGZyb20gJy4vZmluZFBhcmVudE5vZGUuanMnXG5cbmV4cG9ydCBjb25zdCBpc0F0RW5kT2ZOb2RlID0gKHN0YXRlOiBFZGl0b3JTdGF0ZSwgbm9kZVR5cGU/OiBzdHJpbmcpID0+IHtcbiAgY29uc3QgeyAkZnJvbSwgJHRvLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb25cblxuICBpZiAobm9kZVR5cGUpIHtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUubmFtZSA9PT0gbm9kZVR5cGUpKHN0YXRlLnNlbGVjdGlvbilcblxuICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgJHBhcmVudFBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBhcmVudE5vZGUucG9zICsgMSlcblxuICAgIGlmICgkYW5jaG9yLnBvcyArIDEgPT09ICRwYXJlbnRQb3MuZW5kKCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoJHRvLnBhcmVudE9mZnNldCA8ICR0by5wYXJlbnQubm9kZVNpemUgLSAyIHx8ICRmcm9tLnBvcyAhPT0gJHRvLnBvcykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBjb25zdCBpc0F0U3RhcnRPZk5vZGUgPSAoc3RhdGU6IEVkaXRvclN0YXRlKSA9PiB7XG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uXG5cbiAgaWYgKCRmcm9tLnBhcmVudE9mZnNldCA+IDAgfHwgJGZyb20ucG9zICE9PSAkdG8ucG9zKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnLi4vaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IE5vZGVDb25maWcgfSBmcm9tICcuLi9pbmRleC5qcydcbmltcG9ydCB7IEV4dGVuc2lvbnMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4uL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBzcGxpdEV4dGVuc2lvbnMgfSBmcm9tICcuL3NwbGl0RXh0ZW5zaW9ucy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTGlzdChuYW1lOiBzdHJpbmcsIGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBib29sZWFuIHtcbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpXG4gIGNvbnN0IGV4dGVuc2lvbiA9IG5vZGVFeHRlbnNpb25zLmZpbmQoaXRlbSA9PiBpdGVtLm5hbWUgPT09IG5hbWUpXG5cbiAgaWYgKCFleHRlbnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gIH1cbiAgY29uc3QgZ3JvdXAgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snZ3JvdXAnXT4oZXh0ZW5zaW9uLCAnZ3JvdXAnLCBjb250ZXh0KSlcblxuICBpZiAodHlwZW9mIGdyb3VwICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGdyb3VwLnNwbGl0KCcgJykuaW5jbHVkZXMoJ2xpc3QnKVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZUVtcHR5KG5vZGU6IFByb3NlTWlycm9yTm9kZSk6IGJvb2xlYW4ge1xuICBjb25zdCBkZWZhdWx0Q29udGVudCA9IG5vZGUudHlwZS5jcmVhdGVBbmRGaWxsKCk/LnRvSlNPTigpXG4gIGNvbnN0IGNvbnRlbnQgPSBub2RlLnRvSlNPTigpXG5cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRlZmF1bHRDb250ZW50KSA9PT0gSlNPTi5zdHJpbmdpZnkoY29udGVudClcbn1cbiIsICJpbXBvcnQgeyBOb2RlU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZVNlbGVjdGlvbih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIE5vZGVTZWxlY3Rpb24ge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHsgbWluTWF4IH0gZnJvbSAnLi4vdXRpbGl0aWVzL21pbk1heC5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIHBvc1RvRE9NUmVjdCh2aWV3OiBFZGl0b3JWaWV3LCBmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpOiBET01SZWN0IHtcbiAgY29uc3QgbWluUG9zID0gMFxuICBjb25zdCBtYXhQb3MgPSB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemVcbiAgY29uc3QgcmVzb2x2ZWRGcm9tID0gbWluTWF4KGZyb20sIG1pblBvcywgbWF4UG9zKVxuICBjb25zdCByZXNvbHZlZEVuZCA9IG1pbk1heCh0bywgbWluUG9zLCBtYXhQb3MpXG4gIGNvbnN0IHN0YXJ0ID0gdmlldy5jb29yZHNBdFBvcyhyZXNvbHZlZEZyb20pXG4gIGNvbnN0IGVuZCA9IHZpZXcuY29vcmRzQXRQb3MocmVzb2x2ZWRFbmQsIC0xKVxuICBjb25zdCB0b3AgPSBNYXRoLm1pbihzdGFydC50b3AsIGVuZC50b3ApXG4gIGNvbnN0IGJvdHRvbSA9IE1hdGgubWF4KHN0YXJ0LmJvdHRvbSwgZW5kLmJvdHRvbSlcbiAgY29uc3QgbGVmdCA9IE1hdGgubWluKHN0YXJ0LmxlZnQsIGVuZC5sZWZ0KVxuICBjb25zdCByaWdodCA9IE1hdGgubWF4KHN0YXJ0LnJpZ2h0LCBlbmQucmlnaHQpXG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0XG4gIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcFxuICBjb25zdCB4ID0gbGVmdFxuICBjb25zdCB5ID0gdG9wXG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgdG9wLFxuICAgIGJvdHRvbSxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHksXG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgdG9KU09OOiAoKSA9PiBkYXRhLFxuICB9XG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIFJlc29sdmVkUG9zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEVkaXRvclN0YXRlLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGdldE1hcmtBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrQXR0cmlidXRlcy5qcydcbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrVHlwZS5qcydcbmltcG9ydCB7IGlzVGV4dFNlbGVjdGlvbiB9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0TWFyazoge1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYSBtYXJrIHdpdGggbmV3IGF0dHJpYnV0ZXMuXG4gICAgICAgKi9cbiAgICAgIHNldE1hcms6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBNYXJrVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuU2V0TWFyayhzdGF0ZTogRWRpdG9yU3RhdGUsIHRyOiBUcmFuc2FjdGlvbiwgbmV3TWFya1R5cGU6IE1hcmtUeXBlKSB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICBsZXQgY3Vyc29yOiBSZXNvbHZlZFBvcyB8IG51bGwgPSBudWxsXG5cbiAgaWYgKGlzVGV4dFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY3Vyc29yID0gc2VsZWN0aW9uLiRjdXJzb3JcbiAgfVxuXG4gIGlmIChjdXJzb3IpIHtcbiAgICBjb25zdCBjdXJyZW50TWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyA/PyBjdXJzb3IubWFya3MoKVxuXG4gICAgLy8gVGhlcmUgY2FuIGJlIG5vIGN1cnJlbnQgbWFya3MgdGhhdCBleGNsdWRlIHRoZSBuZXcgbWFya1xuICAgIHJldHVybiAoXG4gICAgICAhIW5ld01hcmtUeXBlLmlzSW5TZXQoY3VycmVudE1hcmtzKVxuICAgICAgfHwgIWN1cnJlbnRNYXJrcy5zb21lKG1hcmsgPT4gbWFyay50eXBlLmV4Y2x1ZGVzKG5ld01hcmtUeXBlKSlcbiAgICApXG4gIH1cblxuICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uXG5cbiAgcmV0dXJuIHJhbmdlcy5zb21lKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIGxldCBzb21lTm9kZVN1cHBvcnRzTWFyayA9ICRmcm9tLmRlcHRoID09PSAwXG4gICAgICA/IHN0YXRlLmRvYy5pbmxpbmVDb250ZW50ICYmIHN0YXRlLmRvYy50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKVxuICAgICAgOiBmYWxzZVxuXG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIChub2RlLCBfcG9zLCBwYXJlbnQpID0+IHtcbiAgICAgIC8vIElmIHdlIGFscmVhZHkgZm91bmQgYSBtYXJrIHRoYXQgd2UgY2FuIGVuYWJsZSwgcmV0dXJuIGZhbHNlIHRvIGJ5cGFzcyB0aGUgcmVtYWluaW5nIHNlYXJjaFxuICAgICAgaWYgKHNvbWVOb2RlU3VwcG9ydHNNYXJrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5pc0lubGluZSkge1xuICAgICAgICBjb25zdCBwYXJlbnRBbGxvd3NNYXJrVHlwZSA9ICFwYXJlbnQgfHwgcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUobmV3TWFya1R5cGUpXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNYXJrc0FsbG93TWFya1R5cGUgPSAhIW5ld01hcmtUeXBlLmlzSW5TZXQobm9kZS5tYXJrcylcbiAgICAgICAgICB8fCAhbm9kZS5tYXJrcy5zb21lKG90aGVyTWFyayA9PiBvdGhlck1hcmsudHlwZS5leGNsdWRlcyhuZXdNYXJrVHlwZSkpXG5cbiAgICAgICAgc29tZU5vZGVTdXBwb3J0c01hcmsgPSBwYXJlbnRBbGxvd3NNYXJrVHlwZSAmJiBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlXG4gICAgICB9XG4gICAgICByZXR1cm4gIXNvbWVOb2RlU3VwcG9ydHNNYXJrXG4gICAgfSlcblxuICAgIHJldHVybiBzb21lTm9kZVN1cHBvcnRzTWFya1xuICB9KVxufVxuZXhwb3J0IGNvbnN0IHNldE1hcms6IFJhd0NvbW1hbmRzWydzZXRNYXJrJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uXG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHR5cGUpXG5cbiAgICAgIHRyLmFkZFN0b3JlZE1hcmsoXG4gICAgICAgIHR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAuLi5vbGRBdHRyaWJ1dGVzLFxuICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICAgIGNvbnN0IGZyb20gPSByYW5nZS4kZnJvbS5wb3NcbiAgICAgICAgY29uc3QgdG8gPSByYW5nZS4kdG8ucG9zXG5cbiAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCBmcm9tKVxuICAgICAgICAgIGNvbnN0IHRyaW1tZWRUbyA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKVxuICAgICAgICAgIGNvbnN0IHNvbWVIYXNNYXJrID0gbm9kZS5tYXJrcy5maW5kKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKVxuXG4gICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYWxyZWFkeSBhIG1hcmsgb2YgdGhpcyB0eXBlXG4gICAgICAgICAgLy8gd2Uga25vdyB0aGF0IHdlIGhhdmUgdG8gbWVyZ2UgaXRzIGF0dHJpYnV0ZXNcbiAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgYWRkIGEgZnJlc2ggbmV3IG1hcmtcbiAgICAgICAgICBpZiAoc29tZUhhc01hcmspIHtcbiAgICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaChtYXJrID0+IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgICB0cmltbWVkRnJvbSxcbiAgICAgICAgICAgICAgICAgIHRyaW1tZWRUbyxcbiAgICAgICAgICAgICAgICAgIHR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubWFyay5hdHRycyxcbiAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHIuYWRkTWFyayh0cmltbWVkRnJvbSwgdHJpbW1lZFRvLCB0eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYW5TZXRNYXJrKHN0YXRlLCB0ciwgdHlwZSlcbn1cbiIsICJpbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0TWV0YToge1xuICAgICAgLyoqXG4gICAgICAgKiBTdG9yZSBhIG1ldGFkYXRhIHByb3BlcnR5IGluIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLlxuICAgICAgICovXG4gICAgICBzZXRNZXRhOiAoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZXRNZXRhOiBSYXdDb21tYW5kc1snc2V0TWV0YSddID0gKGtleSwgdmFsdWUpID0+ICh7IHRyIH0pID0+IHtcbiAgdHIuc2V0TWV0YShrZXksIHZhbHVlKVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgc2V0QmxvY2tUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcbmltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldE5vZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVwbGFjZSBhIGdpdmVuIHJhbmdlIHdpdGggYSBub2RlLlxuICAgICAgICovXG4gICAgICBzZXROb2RlOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZXROb2RlOiBSYXdDb21tYW5kc1snc2V0Tm9kZSddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCBjaGFpbiB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgLy8gVE9ETzogdXNlIGEgZmFsbGJhY2sgbGlrZSBpbnNlcnRDb250ZW50P1xuICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spIHtcbiAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IEN1cnJlbnRseSBcInNldE5vZGUoKVwiIG9ubHkgc3VwcG9ydHMgdGV4dCBibG9jayBub2Rlcy4nKVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gKFxuICAgIGNoYWluKClcbiAgICAvLyB0cnkgdG8gY29udmVydCBub2RlIHRvIGRlZmF1bHQgbm9kZSBpZiBuZWVkZWRcbiAgICAgIC5jb21tYW5kKCh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgY29uc3QgY2FuU2V0QmxvY2sgPSBzZXRCbG9ja1R5cGUodHlwZSwgYXR0cmlidXRlcykoc3RhdGUpXG5cbiAgICAgICAgaWYgKGNhblNldEJsb2NrKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKClcbiAgICAgIH0pXG4gICAgICAuY29tbWFuZCgoeyBzdGF0ZTogdXBkYXRlZFN0YXRlIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHNldEJsb2NrVHlwZSh0eXBlLCBhdHRyaWJ1dGVzKSh1cGRhdGVkU3RhdGUsIGRpc3BhdGNoKVxuICAgICAgfSlcbiAgICAgIC5ydW4oKVxuICApXG59XG4iLCAiaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBtaW5NYXggfSBmcm9tICcuLi91dGlsaXRpZXMvbWluTWF4LmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0Tm9kZVNlbGVjdGlvbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgTm9kZVNlbGVjdGlvbi5cbiAgICAgICAqL1xuICAgICAgc2V0Tm9kZVNlbGVjdGlvbjogKHBvc2l0aW9uOiBudW1iZXIpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldE5vZGVTZWxlY3Rpb246IFJhd0NvbW1hbmRzWydzZXROb2RlU2VsZWN0aW9uJ10gPSBwb3NpdGlvbiA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCB7IGRvYyB9ID0gdHJcbiAgICBjb25zdCBmcm9tID0gbWluTWF4KHBvc2l0aW9uLCAwLCBkb2MuY29udGVudC5zaXplKVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKGRvYywgZnJvbSlcblxuICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBSYW5nZSwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG1pbk1heCB9IGZyb20gJy4uL3V0aWxpdGllcy9taW5NYXguanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXRUZXh0U2VsZWN0aW9uOiB7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBUZXh0U2VsZWN0aW9uLlxuICAgICAgICovXG4gICAgICBzZXRUZXh0U2VsZWN0aW9uOiAocG9zaXRpb246IG51bWJlciB8IFJhbmdlKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZXRUZXh0U2VsZWN0aW9uOiBSYXdDb21tYW5kc1snc2V0VGV4dFNlbGVjdGlvbiddID0gcG9zaXRpb24gPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgeyBkb2MgfSA9IHRyXG4gICAgY29uc3QgeyBmcm9tLCB0byB9ID0gdHlwZW9mIHBvc2l0aW9uID09PSAnbnVtYmVyJyA/IHsgZnJvbTogcG9zaXRpb24sIHRvOiBwb3NpdGlvbiB9IDogcG9zaXRpb25cbiAgICBjb25zdCBtaW5Qb3MgPSBUZXh0U2VsZWN0aW9uLmF0U3RhcnQoZG9jKS5mcm9tXG4gICAgY29uc3QgbWF4UG9zID0gVGV4dFNlbGVjdGlvbi5hdEVuZChkb2MpLnRvXG4gICAgY29uc3QgcmVzb2x2ZWRGcm9tID0gbWluTWF4KGZyb20sIG1pblBvcywgbWF4UG9zKVxuICAgIGNvbnN0IHJlc29sdmVkRW5kID0gbWluTWF4KHRvLCBtaW5Qb3MsIG1heFBvcylcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHJlc29sdmVkRnJvbSwgcmVzb2x2ZWRFbmQpXG5cbiAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBzaW5rTGlzdEl0ZW0gYXMgb3JpZ2luYWxTaW5rTGlzdEl0ZW0gfSBmcm9tICdAdGlwdGFwL3BtL3NjaGVtYS1saXN0J1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2lua0xpc3RJdGVtOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNpbmsgdGhlIGxpc3QgaXRlbSBkb3duIGludG8gYW4gaW5uZXIgbGlzdC5cbiAgICAgICAqL1xuICAgICAgc2lua0xpc3RJdGVtOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNpbmtMaXN0SXRlbTogUmF3Q29tbWFuZHNbJ3NpbmtMaXN0SXRlbSddID0gdHlwZU9yTmFtZSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIHJldHVybiBvcmlnaW5hbFNpbmtMaXN0SXRlbSh0eXBlKShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUsIE5vZGVTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgY2FuU3BsaXQgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgZGVmYXVsdEJsb2NrQXQgfSBmcm9tICcuLi9oZWxwZXJzL2RlZmF1bHRCbG9ja0F0LmpzJ1xuaW1wb3J0IHsgZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vaGVscGVycy9nZXRTcGxpdHRlZEF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5mdW5jdGlvbiBlbnN1cmVNYXJrcyhzdGF0ZTogRWRpdG9yU3RhdGUsIHNwbGl0dGFibGVNYXJrcz86IHN0cmluZ1tdKSB7XG4gIGNvbnN0IG1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgfHwgKHN0YXRlLnNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxuXG4gIGlmIChtYXJrcykge1xuICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3M/LmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSlcblxuICAgIHN0YXRlLnRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpXG4gIH1cbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNwbGl0QmxvY2s6IHtcbiAgICAgIC8qKlxuICAgICAgICogRm9ya3MgYSBuZXcgbm9kZSBmcm9tIGFuIGV4aXN0aW5nIG5vZGUuXG4gICAgICAgKi9cbiAgICAgIHNwbGl0QmxvY2s6IChvcHRpb25zPzogeyBrZWVwTWFya3M/OiBib29sZWFuIH0pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNwbGl0QmxvY2s6IFJhd0NvbW1hbmRzWydzcGxpdEJsb2NrJ10gPSAoeyBrZWVwTWFya3MgPSB0cnVlIH0gPSB7fSkgPT4gKHtcbiAgdHIsIHN0YXRlLCBkaXNwYXRjaCwgZWRpdG9yLFxufSkgPT4ge1xuICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSB0clxuICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHNlbGVjdGlvblxuICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuYXR0cmlidXRlc1xuICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKFxuICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMsXG4gICAgJGZyb20ubm9kZSgpLnR5cGUubmFtZSxcbiAgICAkZnJvbS5ub2RlKCkuYXR0cnMsXG4gIClcblxuICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzZWxlY3Rpb24ubm9kZS5pc0Jsb2NrKSB7XG4gICAgaWYgKCEkZnJvbS5wYXJlbnRPZmZzZXQgfHwgIWNhblNwbGl0KGRvYywgJGZyb20ucG9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBpZiAoa2VlcE1hcmtzKSB7XG4gICAgICAgIGVuc3VyZU1hcmtzKHN0YXRlLCBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5zcGxpdHRhYmxlTWFya3MpXG4gICAgICB9XG5cbiAgICAgIHRyLnNwbGl0KCRmcm9tLnBvcykuc2Nyb2xsSW50b1ZpZXcoKVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoISRmcm9tLnBhcmVudC5pc0Jsb2NrKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCBhdEVuZCA9ICR0by5wYXJlbnRPZmZzZXQgPT09ICR0by5wYXJlbnQuY29udGVudC5zaXplXG5cbiAgICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xuICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKClcbiAgICB9XG5cbiAgICBjb25zdCBkZWZsdCA9ICRmcm9tLmRlcHRoID09PSAwXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiBkZWZhdWx0QmxvY2tBdCgkZnJvbS5ub2RlKC0xKS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKC0xKSkpXG5cbiAgICBsZXQgdHlwZXMgPSBhdEVuZCAmJiBkZWZsdFxuICAgICAgPyBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBkZWZsdCxcbiAgICAgICAgICBhdHRyczogbmV3QXR0cmlidXRlcyxcbiAgICAgICAgfSxcbiAgICAgIF1cbiAgICAgIDogdW5kZWZpbmVkXG5cbiAgICBsZXQgY2FuID0gY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcylcblxuICAgIGlmIChcbiAgICAgICF0eXBlc1xuICAgICAgICAmJiAhY2FuXG4gICAgICAgICYmIGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgZGVmbHQgPyBbeyB0eXBlOiBkZWZsdCB9XSA6IHVuZGVmaW5lZClcbiAgICApIHtcbiAgICAgIGNhbiA9IHRydWVcbiAgICAgIHR5cGVzID0gZGVmbHRcbiAgICAgICAgPyBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogZGVmbHQsXG4gICAgICAgICAgICBhdHRyczogbmV3QXR0cmlidXRlcyxcbiAgICAgICAgICB9LFxuICAgICAgICBdXG4gICAgICAgIDogdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKGNhbikge1xuICAgICAgdHIuc3BsaXQodHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpXG5cbiAgICAgIGlmIChkZWZsdCAmJiAhYXRFbmQgJiYgISRmcm9tLnBhcmVudE9mZnNldCAmJiAkZnJvbS5wYXJlbnQudHlwZSAhPT0gZGVmbHQpIHtcbiAgICAgICAgY29uc3QgZmlyc3QgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSlcbiAgICAgICAgY29uc3QgJGZpcnN0ID0gdHIuZG9jLnJlc29sdmUoZmlyc3QpXG5cbiAgICAgICAgaWYgKCRmcm9tLm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRmaXJzdC5pbmRleCgpLCAkZmlyc3QuaW5kZXgoKSArIDEsIGRlZmx0KSkge1xuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLCBkZWZsdClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZWVwTWFya3MpIHtcbiAgICAgIGVuc3VyZU1hcmtzKHN0YXRlLCBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5zcGxpdHRhYmxlTWFya3MpXG4gICAgfVxuXG4gICAgdHIuc2Nyb2xsSW50b1ZpZXcoKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQge1xuICBGcmFnbWVudCwgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIE5vZGVUeXBlLCBTbGljZSxcbn0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgY2FuU3BsaXQgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vaGVscGVycy9nZXRTcGxpdHRlZEF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc3BsaXRMaXN0SXRlbToge1xuICAgICAgLyoqXG4gICAgICAgKiBTcGxpdHMgb25lIGxpc3QgaXRlbSBpbnRvIHR3byBsaXN0IGl0ZW1zLlxuICAgICAgICovXG4gICAgICBzcGxpdExpc3RJdGVtOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNwbGl0TGlzdEl0ZW06IFJhd0NvbW1hbmRzWydzcGxpdExpc3RJdGVtJ10gPSB0eXBlT3JOYW1lID0+ICh7XG4gIHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGVkaXRvcixcbn0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb25cblxuICAvLyBAdHMtaWdub3JlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGNvbnN0IG5vZGU6IFByb3NlTWlycm9yTm9kZSA9IHN0YXRlLnNlbGVjdGlvbi5ub2RlXG5cbiAgaWYgKChub2RlICYmIG5vZGUuaXNCbG9jaykgfHwgJGZyb20uZGVwdGggPCAyIHx8ICEkZnJvbS5zYW1lUGFyZW50KCR0bykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGdyYW5kUGFyZW50ID0gJGZyb20ubm9kZSgtMSlcblxuICBpZiAoZ3JhbmRQYXJlbnQudHlwZSAhPT0gdHlwZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXNcblxuICBpZiAoJGZyb20ucGFyZW50LmNvbnRlbnQuc2l6ZSA9PT0gMCAmJiAkZnJvbS5ub2RlKC0xKS5jaGlsZENvdW50ID09PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgIC8vIEluIGFuIGVtcHR5IGJsb2NrLiBJZiB0aGlzIGlzIGEgbmVzdGVkIGxpc3QsIHRoZSB3cmFwcGluZ1xuICAgIC8vIGxpc3QgaXRlbSBzaG91bGQgYmUgc3BsaXQuIE90aGVyd2lzZSwgYmFpbCBvdXQgYW5kIGxldCBuZXh0XG4gICAgLy8gY29tbWFuZCBoYW5kbGUgbGlmdGluZy5cbiAgICBpZiAoXG4gICAgICAkZnJvbS5kZXB0aCA9PT0gMlxuICAgICAgICB8fCAkZnJvbS5ub2RlKC0zKS50eXBlICE9PSB0eXBlXG4gICAgICAgIHx8ICRmcm9tLmluZGV4KC0yKSAhPT0gJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCAtIDFcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgbGV0IHdyYXAgPSBGcmFnbWVudC5lbXB0eVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGNvbnN0IGRlcHRoQmVmb3JlID0gJGZyb20uaW5kZXgoLTEpID8gMSA6ICRmcm9tLmluZGV4KC0yKSA/IDIgOiAzXG5cbiAgICAgIC8vIEJ1aWxkIGEgZnJhZ21lbnQgY29udGFpbmluZyBlbXB0eSB2ZXJzaW9ucyBvZiB0aGUgc3RydWN0dXJlXG4gICAgICAvLyBmcm9tIHRoZSBvdXRlciBsaXN0IGl0ZW0gdG8gdGhlIHBhcmVudCBub2RlIG9mIHRoZSBjdXJzb3JcbiAgICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCAtIGRlcHRoQmVmb3JlOyBkID49ICRmcm9tLmRlcHRoIC0gMzsgZCAtPSAxKSB7XG4gICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoZCkuY29weSh3cmFwKSlcbiAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGNvbnN0IGRlcHRoQWZ0ZXIgPSAkZnJvbS5pbmRleEFmdGVyKC0xKSA8ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgPyAxIDogJGZyb20uaW5kZXhBZnRlcigtMikgPCAkZnJvbS5ub2RlKC0zKS5jaGlsZENvdW50ID8gMiA6IDNcblxuICAgICAgLy8gQWRkIGEgc2Vjb25kIGxpc3QgaXRlbSB3aXRoIGFuIGVtcHR5IGRlZmF1bHQgc3RhcnQgbm9kZVxuICAgICAgY29uc3QgbmV3TmV4dFR5cGVBdHRyaWJ1dGVzID0gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKFxuICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLFxuICAgICAgICAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLFxuICAgICAgICAkZnJvbS5ub2RlKCkuYXR0cnMsXG4gICAgICApXG4gICAgICBjb25zdCBuZXh0VHlwZSA9IHR5cGUuY29udGVudE1hdGNoLmRlZmF1bHRUeXBlPy5jcmVhdGVBbmRGaWxsKG5ld05leHRUeXBlQXR0cmlidXRlcykgfHwgdW5kZWZpbmVkXG5cbiAgICAgIHdyYXAgPSB3cmFwLmFwcGVuZChGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlQW5kRmlsbChudWxsLCBuZXh0VHlwZSkgfHwgdW5kZWZpbmVkKSlcblxuICAgICAgY29uc3Qgc3RhcnQgPSAkZnJvbS5iZWZvcmUoJGZyb20uZGVwdGggLSAoZGVwdGhCZWZvcmUgLSAxKSlcblxuICAgICAgdHIucmVwbGFjZShzdGFydCwgJGZyb20uYWZ0ZXIoLWRlcHRoQWZ0ZXIpLCBuZXcgU2xpY2Uod3JhcCwgNCAtIGRlcHRoQmVmb3JlLCAwKSlcblxuICAgICAgbGV0IHNlbCA9IC0xXG5cbiAgICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oc3RhcnQsIHRyLmRvYy5jb250ZW50LnNpemUsIChuLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKHNlbCA+IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobi5pc1RleHRibG9jayAmJiBuLmNvbnRlbnQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHNlbCA9IHBvcyArIDFcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgaWYgKHNlbCA+IC0xKSB7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoc2VsKSkpXG4gICAgICB9XG5cbiAgICAgIHRyLnNjcm9sbEludG9WaWV3KClcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3QgbmV4dFR5cGUgPSAkdG8ucG9zID09PSAkZnJvbS5lbmQoKSA/IGdyYW5kUGFyZW50LmNvbnRlbnRNYXRjaEF0KDApLmRlZmF1bHRUeXBlIDogbnVsbFxuXG4gIGNvbnN0IG5ld1R5cGVBdHRyaWJ1dGVzID0gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKFxuICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMsXG4gICAgZ3JhbmRQYXJlbnQudHlwZS5uYW1lLFxuICAgIGdyYW5kUGFyZW50LmF0dHJzLFxuICApXG4gIGNvbnN0IG5ld05leHRUeXBlQXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhcbiAgICBleHRlbnNpb25BdHRyaWJ1dGVzLFxuICAgICRmcm9tLm5vZGUoKS50eXBlLm5hbWUsXG4gICAgJGZyb20ubm9kZSgpLmF0dHJzLFxuICApXG5cbiAgdHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcylcblxuICBjb25zdCB0eXBlcyA9IG5leHRUeXBlXG4gICAgPyBbXG4gICAgICB7IHR5cGUsIGF0dHJzOiBuZXdUeXBlQXR0cmlidXRlcyB9LFxuICAgICAgeyB0eXBlOiBuZXh0VHlwZSwgYXR0cnM6IG5ld05leHRUeXBlQXR0cmlidXRlcyB9LFxuICAgIF1cbiAgICA6IFt7IHR5cGUsIGF0dHJzOiBuZXdUeXBlQXR0cmlidXRlcyB9XVxuXG4gIGlmICghY2FuU3BsaXQodHIuZG9jLCAkZnJvbS5wb3MsIDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlXG4gICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyXG4gICAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrcyB8fCAoc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG5cbiAgICB0ci5zcGxpdCgkZnJvbS5wb3MsIDIsIHR5cGVzKS5zY3JvbGxJbnRvVmlldygpXG5cbiAgICBpZiAoIW1hcmtzIHx8ICFkaXNwYXRjaCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSlcblxuICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IGNhbkpvaW4gfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgZmluZFBhcmVudE5vZGUgfSBmcm9tICcuLi9oZWxwZXJzL2ZpbmRQYXJlbnROb2RlLmpzJ1xuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgaXNMaXN0IH0gZnJvbSAnLi4vaGVscGVycy9pc0xpc3QuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5jb25zdCBqb2luTGlzdEJhY2t3YXJkcyA9ICh0cjogVHJhbnNhY3Rpb24sIGxpc3RUeXBlOiBOb2RlVHlwZSk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBsaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUgPT09IGxpc3RUeXBlKSh0ci5zZWxlY3Rpb24pXG5cbiAgaWYgKCFsaXN0KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IGJlZm9yZSA9IHRyLmRvYy5yZXNvbHZlKE1hdGgubWF4KDAsIGxpc3QucG9zIC0gMSkpLmJlZm9yZShsaXN0LmRlcHRoKVxuXG4gIGlmIChiZWZvcmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBub2RlQmVmb3JlID0gdHIuZG9jLm5vZGVBdChiZWZvcmUpXG4gIGNvbnN0IGNhbkpvaW5CYWNrd2FyZHMgPSBsaXN0Lm5vZGUudHlwZSA9PT0gbm9kZUJlZm9yZT8udHlwZSAmJiBjYW5Kb2luKHRyLmRvYywgbGlzdC5wb3MpXG5cbiAgaWYgKCFjYW5Kb2luQmFja3dhcmRzKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHRyLmpvaW4obGlzdC5wb3MpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuY29uc3Qgam9pbkxpc3RGb3J3YXJkcyA9ICh0cjogVHJhbnNhY3Rpb24sIGxpc3RUeXBlOiBOb2RlVHlwZSk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBsaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUgPT09IGxpc3RUeXBlKSh0ci5zZWxlY3Rpb24pXG5cbiAgaWYgKCFsaXN0KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IGFmdGVyID0gdHIuZG9jLnJlc29sdmUobGlzdC5zdGFydCkuYWZ0ZXIobGlzdC5kZXB0aClcblxuICBpZiAoYWZ0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBub2RlQWZ0ZXIgPSB0ci5kb2Mubm9kZUF0KGFmdGVyKVxuICBjb25zdCBjYW5Kb2luRm9yd2FyZHMgPSBsaXN0Lm5vZGUudHlwZSA9PT0gbm9kZUFmdGVyPy50eXBlICYmIGNhbkpvaW4odHIuZG9jLCBhZnRlcilcblxuICBpZiAoIWNhbkpvaW5Gb3J3YXJkcykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB0ci5qb2luKGFmdGVyKVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0b2dnbGVMaXN0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBsaXN0IHR5cGVzLlxuICAgICAgICovXG4gICAgICB0b2dnbGVMaXN0OiAobGlzdFR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBpdGVtVHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIGtlZXBNYXJrcz86IGJvb2xlYW4sIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdG9nZ2xlTGlzdDogUmF3Q29tbWFuZHNbJ3RvZ2dsZUxpc3QnXSA9IChsaXN0VHlwZU9yTmFtZSwgaXRlbVR5cGVPck5hbWUsIGtlZXBNYXJrcywgYXR0cmlidXRlcyA9IHt9KSA9PiAoe1xuICBlZGl0b3IsIHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGNoYWluLCBjb21tYW5kcywgY2FuLFxufSkgPT4ge1xuICBjb25zdCB7IGV4dGVuc2lvbnMsIHNwbGl0dGFibGVNYXJrcyB9ID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXJcbiAgY29uc3QgbGlzdFR5cGUgPSBnZXROb2RlVHlwZShsaXN0VHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCBpdGVtVHlwZSA9IGdldE5vZGVUeXBlKGl0ZW1UeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGVcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb25cbiAgY29uc3QgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bylcblxuICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcblxuICBpZiAoIXJhbmdlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBwYXJlbnRMaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBpc0xpc3Qobm9kZS50eXBlLm5hbWUsIGV4dGVuc2lvbnMpKShzZWxlY3Rpb24pXG5cbiAgaWYgKHJhbmdlLmRlcHRoID49IDEgJiYgcGFyZW50TGlzdCAmJiByYW5nZS5kZXB0aCAtIHBhcmVudExpc3QuZGVwdGggPD0gMSkge1xuICAgIC8vIHJlbW92ZSBsaXN0XG4gICAgaWYgKHBhcmVudExpc3Qubm9kZS50eXBlID09PSBsaXN0VHlwZSkge1xuICAgICAgcmV0dXJuIGNvbW1hbmRzLmxpZnRMaXN0SXRlbShpdGVtVHlwZSlcbiAgICB9XG5cbiAgICAvLyBjaGFuZ2UgbGlzdCB0eXBlXG4gICAgaWYgKFxuICAgICAgaXNMaXN0KHBhcmVudExpc3Qubm9kZS50eXBlLm5hbWUsIGV4dGVuc2lvbnMpXG4gICAgICAgICYmIGxpc3RUeXBlLnZhbGlkQ29udGVudChwYXJlbnRMaXN0Lm5vZGUuY29udGVudClcbiAgICAgICAgJiYgZGlzcGF0Y2hcbiAgICApIHtcbiAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgIC5jb21tYW5kKCgpID0+IHtcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBhcmVudExpc3QucG9zLCBsaXN0VHlwZSlcblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0pXG4gICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgICAgLnJ1bigpXG4gICAgfVxuICB9XG4gIGlmICgha2VlcE1hcmtzIHx8ICFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcblxuICAgIHJldHVybiBjaGFpbigpXG4gICAgICAvLyB0cnkgdG8gY29udmVydCBub2RlIHRvIGRlZmF1bHQgbm9kZSBpZiBuZWVkZWRcbiAgICAgIC5jb21tYW5kKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2FuV3JhcEluTGlzdCA9IGNhbigpLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgICAgICAgaWYgKGNhbldyYXBJbkxpc3QpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuICAgICAgfSlcbiAgICAgIC53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgIC5ydW4oKVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICBjaGFpbigpXG4gICAgLy8gdHJ5IHRvIGNvbnZlcnQgbm9kZSB0byBkZWZhdWx0IG5vZGUgaWYgbmVlZGVkXG4gICAgICAuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbldyYXBJbkxpc3QgPSBjYW4oKS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKVxuXG4gICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpXG5cbiAgICAgICAgaWYgKGNhbldyYXBJbkxpc3QpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuICAgICAgfSlcbiAgICAgIC53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgIC5ydW4oKVxuICApXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBpc01hcmtBY3RpdmUgfSBmcm9tICcuLi9oZWxwZXJzL2lzTWFya0FjdGl2ZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0b2dnbGVNYXJrOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIG1hcmsgb24gYW5kIG9mZi5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlTWFyazogKFxuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBNYXJrVHlwZSxcbiAgICAgICAgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUmVtb3ZlcyB0aGUgbWFyayBldmVuIGFjcm9zcyB0aGUgY3VycmVudCBzZWxlY3Rpb24uIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgICAgICovXG4gICAgICAgICAgZXh0ZW5kRW1wdHlNYXJrUmFuZ2U/OiBib29sZWFuXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvZ2dsZU1hcms6IFJhd0NvbW1hbmRzWyd0b2dnbGVNYXJrJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9LCBvcHRpb25zID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gIGNvbnN0IHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgPSBmYWxzZSB9ID0gb3B0aW9uc1xuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCBpc0FjdGl2ZSA9IGlzTWFya0FjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcylcblxuICBpZiAoaXNBY3RpdmUpIHtcbiAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHR5cGUsIHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgfSlcbiAgfVxuXG4gIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHR5cGUsIGF0dHJpYnV0ZXMpXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBpc05vZGVBY3RpdmUgfSBmcm9tICcuLi9oZWxwZXJzL2lzTm9kZUFjdGl2ZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0b2dnbGVOb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIG5vZGUgd2l0aCBhbm90aGVyIG5vZGUuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZU5vZGU6IChcbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsXG4gICAgICAgIHRvZ2dsZVR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLFxuICAgICAgICBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdG9nZ2xlTm9kZTogUmF3Q29tbWFuZHNbJ3RvZ2dsZU5vZGUnXSA9ICh0eXBlT3JOYW1lLCB0b2dnbGVUeXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHRvZ2dsZVR5cGUgPSBnZXROb2RlVHlwZSh0b2dnbGVUeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gIGlmIChpc0FjdGl2ZSkge1xuICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRvZ2dsZVR5cGUpXG4gIH1cblxuICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0eXBlLCBhdHRyaWJ1dGVzKVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgaXNOb2RlQWN0aXZlIH0gZnJvbSAnLi4vaGVscGVycy9pc05vZGVBY3RpdmUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdG9nZ2xlV3JhcDoge1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwcyBub2RlcyBpbiBhbm90aGVyIG5vZGUsIG9yIHJlbW92ZXMgYW4gZXhpc3Rpbmcgd3JhcC5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlV3JhcDogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdG9nZ2xlV3JhcDogUmF3Q29tbWFuZHNbJ3RvZ2dsZVdyYXAnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gIGlmIChpc0FjdGl2ZSkge1xuICAgIHJldHVybiBjb21tYW5kcy5saWZ0KHR5cGUpXG4gIH1cblxuICByZXR1cm4gY29tbWFuZHMud3JhcEluKHR5cGUsIGF0dHJpYnV0ZXMpXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVuZG9JbnB1dFJ1bGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogVW5kbyBhbiBpbnB1dCBydWxlLlxuICAgICAgICovXG4gICAgICB1bmRvSW5wdXRSdWxlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdW5kb0lucHV0UnVsZTogUmF3Q29tbWFuZHNbJ3VuZG9JbnB1dFJ1bGUnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHBsdWdpbnMgPSBzdGF0ZS5wbHVnaW5zXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXVxuICAgIGxldCB1bmRvYWJsZVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGlmIChwbHVnaW4uc3BlYy5pc0lucHV0UnVsZXMgJiYgKHVuZG9hYmxlID0gcGx1Z2luLmdldFN0YXRlKHN0YXRlKSkpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCB0ciA9IHN0YXRlLnRyXG4gICAgICAgIGNvbnN0IHRvVW5kbyA9IHVuZG9hYmxlLnRyYW5zZm9ybVxuXG4gICAgICAgIGZvciAobGV0IGogPSB0b1VuZG8uc3RlcHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqIC09IDEpIHtcbiAgICAgICAgICB0ci5zdGVwKHRvVW5kby5zdGVwc1tqXS5pbnZlcnQodG9VbmRvLmRvY3Nbal0pKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVuZG9hYmxlLnRleHQpIHtcbiAgICAgICAgICBjb25zdCBtYXJrcyA9IHRyLmRvYy5yZXNvbHZlKHVuZG9hYmxlLmZyb20pLm1hcmtzKClcblxuICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvLCBzdGF0ZS5zY2hlbWEudGV4dCh1bmRvYWJsZS50ZXh0LCBtYXJrcykpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVuc2V0QWxsTWFya3M6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIGFsbCBtYXJrcyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIHVuc2V0QWxsTWFya3M6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1bnNldEFsbE1hcmtzOiBSYXdDb21tYW5kc1sndW5zZXRBbGxNYXJrcyddID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uXG5cbiAgaWYgKGVtcHR5KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya1JhbmdlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrUmFuZ2UuanMnXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdW5zZXRNYXJrOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhbGwgbWFya3MgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICovXG4gICAgICB1bnNldE1hcms6IChcbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTWFya1R5cGUsXG4gICAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUmVtb3ZlcyB0aGUgbWFyayBldmVuIGFjcm9zcyB0aGUgY3VycmVudCBzZWxlY3Rpb24uIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgICAgICovXG4gICAgICAgICAgZXh0ZW5kRW1wdHlNYXJrUmFuZ2U/OiBib29sZWFuXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVuc2V0TWFyazogUmF3Q29tbWFuZHNbJ3Vuc2V0TWFyayddID0gKHR5cGVPck5hbWUsIG9wdGlvbnMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgPSBmYWxzZSB9ID0gb3B0aW9uc1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJcbiAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgeyAkZnJvbSwgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uXG5cbiAgaWYgKCFkaXNwYXRjaCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoZW1wdHkgJiYgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UpIHtcbiAgICBsZXQgeyBmcm9tLCB0byB9ID0gc2VsZWN0aW9uXG4gICAgY29uc3QgYXR0cnMgPSAkZnJvbS5tYXJrcygpLmZpbmQobWFyayA9PiBtYXJrLnR5cGUgPT09IHR5cGUpPy5hdHRyc1xuICAgIGNvbnN0IHJhbmdlID0gZ2V0TWFya1JhbmdlKCRmcm9tLCB0eXBlLCBhdHRycylcblxuICAgIGlmIChyYW5nZSkge1xuICAgICAgZnJvbSA9IHJhbmdlLmZyb21cbiAgICAgIHRvID0gcmFuZ2UudG9cbiAgICB9XG5cbiAgICB0ci5yZW1vdmVNYXJrKGZyb20sIHRvLCB0eXBlKVxuICB9IGVsc2Uge1xuICAgIHJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zLCB0eXBlKVxuICAgIH0pXG4gIH1cblxuICB0ci5yZW1vdmVTdG9yZWRNYXJrKHR5cGUpXG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdXBkYXRlQXR0cmlidXRlczoge1xuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGUgYXR0cmlidXRlcyBvZiBhIG5vZGUgb3IgbWFyay5cbiAgICAgICAqL1xuICAgICAgdXBkYXRlQXR0cmlidXRlczogKFxuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSB8IE1hcmtUeXBlLFxuICAgICAgICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVBdHRyaWJ1dGVzOiBSYXdDb21tYW5kc1sndXBkYXRlQXR0cmlidXRlcyddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGxldCBub2RlVHlwZTogTm9kZVR5cGUgfCBudWxsID0gbnVsbFxuICBsZXQgbWFya1R5cGU6IE1hcmtUeXBlIHwgbnVsbCA9IG51bGxcblxuICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUoXG4gICAgdHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSxcbiAgICBzdGF0ZS5zY2hlbWEsXG4gIClcblxuICBpZiAoIXNjaGVtYVR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICBub2RlVHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUgYXMgTm9kZVR5cGUsIHN0YXRlLnNjaGVtYSlcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICBtYXJrVHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUgYXMgTWFya1R5cGUsIHN0YXRlLnNjaGVtYSlcbiAgfVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHRyLnNlbGVjdGlvbi5yYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICBjb25zdCBmcm9tID0gcmFuZ2UuJGZyb20ucG9zXG4gICAgICBjb25zdCB0byA9IHJhbmdlLiR0by5wb3NcblxuICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIC4uLm5vZGUuYXR0cnMsXG4gICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFya1R5cGUgJiYgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICBpZiAobWFya1R5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICBjb25zdCB0cmltbWVkRnJvbSA9IE1hdGgubWF4KHBvcywgZnJvbSlcbiAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFRvID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pXG5cbiAgICAgICAgICAgICAgdHIuYWRkTWFyayhcbiAgICAgICAgICAgICAgICB0cmltbWVkRnJvbSxcbiAgICAgICAgICAgICAgICB0cmltbWVkVG8sXG4gICAgICAgICAgICAgICAgbWFya1R5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyB3cmFwSW4gYXMgb3JpZ2luYWxXcmFwSW4gfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgd3JhcEluOiB7XG4gICAgICAvKipcbiAgICAgICAqIFdyYXBzIG5vZGVzIGluIGFub3RoZXIgbm9kZS5cbiAgICAgICAqL1xuICAgICAgd3JhcEluOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3cmFwSW46IFJhd0NvbW1hbmRzWyd3cmFwSW4nXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgcmV0dXJuIG9yaWdpbmFsV3JhcEluKHR5cGUsIGF0dHJpYnV0ZXMpKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyB3cmFwSW5MaXN0IGFzIG9yaWdpbmFsV3JhcEluTGlzdCB9IGZyb20gJ0B0aXB0YXAvcG0vc2NoZW1hLWxpc3QnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB3cmFwSW5MaXN0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFdyYXAgYSBub2RlIGluIGEgbGlzdC5cbiAgICAgICAqL1xuICAgICAgd3JhcEluTGlzdDogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgd3JhcEluTGlzdDogUmF3Q29tbWFuZHNbJ3dyYXBJbkxpc3QnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgcmV0dXJuIG9yaWdpbmFsV3JhcEluTGlzdCh0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0ICogYXMgY29tbWFuZHMgZnJvbSAnLi4vY29tbWFuZHMvaW5kZXguanMnXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5cbmV4cG9ydCAqIGZyb20gJy4uL2NvbW1hbmRzL2luZGV4LmpzJ1xuXG5leHBvcnQgY29uc3QgQ29tbWFuZHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogJ2NvbW1hbmRzJyxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29tbWFuZHMsXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcblxuZXhwb3J0IGNvbnN0IEVkaXRhYmxlID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdlZGl0YWJsZScsXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdlZGl0YWJsZScpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGVkaXRhYmxlOiAoKSA9PiB0aGlzLmVkaXRvci5vcHRpb25zLmVkaXRhYmxlLFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcblxuZXhwb3J0IGNvbnN0IEZvY3VzRXZlbnRzID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdmb2N1c0V2ZW50cycsXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzXG5cbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnZm9jdXNFdmVudHMnKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgIGZvY3VzOiAodmlldywgZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGVkaXRvci5pc0ZvY3VzZWQgPSB0cnVlXG5cbiAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBlZGl0b3Iuc3RhdGUudHJcbiAgICAgICAgICAgICAgICAuc2V0TWV0YSgnZm9jdXMnLCB7IGV2ZW50IH0pXG4gICAgICAgICAgICAgICAgLnNldE1ldGEoJ2FkZFRvSGlzdG9yeScsIGZhbHNlKVxuXG4gICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pXG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmx1cjogKHZpZXcsIGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgICBlZGl0b3IuaXNGb2N1c2VkID0gZmFsc2VcblxuICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGVkaXRvci5zdGF0ZS50clxuICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdibHVyJywgeyBldmVudCB9KVxuICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdhZGRUb0hpc3RvcnknLCBmYWxzZSlcblxuICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKVxuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSwgU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgQ29tbWFuZE1hbmFnZXIgfSBmcm9tICcuLi9Db21tYW5kTWFuYWdlci5qcydcbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcbmltcG9ydCB7IGNyZWF0ZUNoYWluYWJsZVN0YXRlIH0gZnJvbSAnLi4vaGVscGVycy9jcmVhdGVDaGFpbmFibGVTdGF0ZS5qcydcbmltcG9ydCB7IGlzaU9TIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2lzaU9TLmpzJ1xuaW1wb3J0IHsgaXNNYWNPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc01hY09TLmpzJ1xuXG5leHBvcnQgY29uc3QgS2V5bWFwID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdrZXltYXAnLFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIGNvbnN0IGhhbmRsZUJhY2tzcGFjZSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICgpID0+IGNvbW1hbmRzLnVuZG9JbnB1dFJ1bGUoKSxcblxuICAgICAgLy8gbWF5YmUgY29udmVydCBmaXJzdCB0ZXh0IGJsb2NrIG5vZGUgdG8gZGVmYXVsdCBub2RlXG4gICAgICAoKSA9PiBjb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHJcbiAgICAgICAgY29uc3QgeyBlbXB0eSwgJGFuY2hvciB9ID0gc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHsgcG9zLCBwYXJlbnQgfSA9ICRhbmNob3JcbiAgICAgICAgY29uc3QgJHBhcmVudFBvcyA9ICRhbmNob3IucGFyZW50LmlzVGV4dGJsb2NrID8gdHIuZG9jLnJlc29sdmUocG9zIC0gMSkgOiAkYW5jaG9yXG4gICAgICAgIGNvbnN0IHBhcmVudElzSXNvbGF0aW5nID0gJHBhcmVudFBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZ1xuXG4gICAgICAgIGNvbnN0IHBhcmVudFBvcyA9ICRhbmNob3IucG9zIC0gJGFuY2hvci5wYXJlbnRPZmZzZXRcblxuICAgICAgICBjb25zdCBpc0F0U3RhcnQgPSAocGFyZW50SXNJc29sYXRpbmcgJiYgJHBhcmVudFBvcy5wYXJlbnQuY2hpbGRDb3VudCA9PT0gMSlcbiAgICAgICAgICA/IHBhcmVudFBvcyA9PT0gJGFuY2hvci5wb3NcbiAgICAgICAgICA6IFNlbGVjdGlvbi5hdFN0YXJ0KGRvYykuZnJvbSA9PT0gcG9zXG5cbiAgICAgICAgaWYgKCFlbXB0eSB8fCAhaXNBdFN0YXJ0IHx8ICFwYXJlbnQudHlwZS5pc1RleHRibG9jayB8fCBwYXJlbnQudGV4dENvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpXG4gICAgICB9KSxcblxuICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlU2VsZWN0aW9uKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5qb2luQmFja3dhcmQoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLnNlbGVjdE5vZGVCYWNrd2FyZCgpLFxuICAgIF0pXG5cbiAgICBjb25zdCBoYW5kbGVEZWxldGUgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAoKSA9PiBjb21tYW5kcy5kZWxldGVTZWxlY3Rpb24oKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZUN1cnJlbnROb2RlKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5qb2luRm9yd2FyZCgpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuc2VsZWN0Tm9kZUZvcndhcmQoKSxcbiAgICBdKVxuXG4gICAgY29uc3QgaGFuZGxlRW50ZXIgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAoKSA9PiBjb21tYW5kcy5uZXdsaW5lSW5Db2RlKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5jcmVhdGVQYXJhZ3JhcGhOZWFyKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5saWZ0RW1wdHlCbG9jaygpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuc3BsaXRCbG9jaygpLFxuICAgIF0pXG5cbiAgICBjb25zdCBiYXNlS2V5bWFwID0ge1xuICAgICAgRW50ZXI6IGhhbmRsZUVudGVyLFxuICAgICAgJ01vZC1FbnRlcic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmV4aXRDb2RlKCksXG4gICAgICBCYWNrc3BhY2U6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICdNb2QtQmFja3NwYWNlJzogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgJ1NoaWZ0LUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgIERlbGV0ZTogaGFuZGxlRGVsZXRlLFxuICAgICAgJ01vZC1EZWxldGUnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnTW9kLWEnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RBbGwoKSxcbiAgICB9XG5cbiAgICBjb25zdCBwY0tleW1hcCA9IHtcbiAgICAgIC4uLmJhc2VLZXltYXAsXG4gICAgfVxuXG4gICAgY29uc3QgbWFjS2V5bWFwID0ge1xuICAgICAgLi4uYmFzZUtleW1hcCxcbiAgICAgICdDdHJsLWgnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAnQWx0LUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICdDdHJsLWQnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnQ3RybC1BbHQtQmFja3NwYWNlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ0FsdC1EZWxldGUnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnQWx0LWQnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnQ3RybC1hJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrU3RhcnQoKSxcbiAgICAgICdDdHJsLWUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RUZXh0YmxvY2tFbmQoKSxcbiAgICB9XG5cbiAgICBpZiAoaXNpT1MoKSB8fCBpc01hY09TKCkpIHtcbiAgICAgIHJldHVybiBtYWNLZXltYXBcbiAgICB9XG5cbiAgICByZXR1cm4gcGNLZXltYXBcbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIFdpdGggdGhpcyBwbHVnaW4gd2UgY2hlY2sgaWYgdGhlIHdob2xlIGRvY3VtZW50IHdhcyBzZWxlY3RlZCBhbmQgZGVsZXRlZC5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSB3aWxsIGFkZGl0aW9uYWxseSBjYWxsIGBjbGVhck5vZGVzKClgIHRvIGNvbnZlcnQgZS5nLiBhIGhlYWRpbmdcbiAgICAgIC8vIHRvIGEgcGFyYWdyYXBoIGlmIG5lY2Vzc2FyeS5cbiAgICAgIC8vIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gUHJvc2VNaXJyb3IncyBgQWxsU2VsZWN0aW9uYCwgd2hpY2ggZG9lc27igJl0IHdvcmsgd2VsbFxuICAgICAgLy8gd2l0aCBtYW55IG90aGVyIGNvbW1hbmRzLlxuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnY2xlYXJEb2N1bWVudCcpLFxuICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHRyYW5zYWN0aW9ucywgb2xkU3RhdGUsIG5ld1N0YXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZG9jQ2hhbmdlcyA9IHRyYW5zYWN0aW9ucy5zb21lKHRyYW5zYWN0aW9uID0+IHRyYW5zYWN0aW9uLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICAmJiAhb2xkU3RhdGUuZG9jLmVxKG5ld1N0YXRlLmRvYylcblxuICAgICAgICAgIGlmICghZG9jQ2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBlbXB0eSwgZnJvbSwgdG8gfSA9IG9sZFN0YXRlLnNlbGVjdGlvblxuICAgICAgICAgIGNvbnN0IGFsbEZyb20gPSBTZWxlY3Rpb24uYXRTdGFydChvbGRTdGF0ZS5kb2MpLmZyb21cbiAgICAgICAgICBjb25zdCBhbGxFbmQgPSBTZWxlY3Rpb24uYXRFbmQob2xkU3RhdGUuZG9jKS50b1xuICAgICAgICAgIGNvbnN0IGFsbFdhc1NlbGVjdGVkID0gZnJvbSA9PT0gYWxsRnJvbSAmJiB0byA9PT0gYWxsRW5kXG5cbiAgICAgICAgICBpZiAoZW1wdHkgfHwgIWFsbFdhc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpc0VtcHR5ID0gbmV3U3RhdGUuZG9jLnRleHRCZXR3ZWVuKDAsIG5ld1N0YXRlLmRvYy5jb250ZW50LnNpemUsICcgJywgJyAnKS5sZW5ndGggPT09IDBcblxuICAgICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdHIgPSBuZXdTdGF0ZS50clxuICAgICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgY29uc3QgeyBjb21tYW5kcyB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgY29tbWFuZHMuY2xlYXJOb2RlcygpXG5cbiAgICAgICAgICBpZiAoIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRyXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuXG5leHBvcnQgY29uc3QgVGFiaW5kZXggPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogJ3RhYmluZGV4JyxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ3RhYmluZGV4JyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgYXR0cmlidXRlczogdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSA/IHsgdGFiaW5kZXg6ICcwJyB9IDoge30sXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImV4cG9ydCBjb25zdCBzdHlsZSA9IGAuUHJvc2VNaXJyb3Ige1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5cbi5Qcm9zZU1pcnJvciB7XG4gIHdvcmQtd3JhcDogYnJlYWstd29yZDtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICB3aGl0ZS1zcGFjZTogYnJlYWstc3BhY2VzO1xuICAtd2Via2l0LWZvbnQtdmFyaWFudC1saWdhdHVyZXM6IG5vbmU7XG4gIGZvbnQtdmFyaWFudC1saWdhdHVyZXM6IG5vbmU7XG4gIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogXCJsaWdhXCIgMDsgLyogdGhlIGFib3ZlIGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGluIEVkZ2UgKi9cbn1cblxuLlByb3NlTWlycm9yIFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSB7XG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XG59XG5cbi5Qcm9zZU1pcnJvciBbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0gW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0ge1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG59XG5cbi5Qcm9zZU1pcnJvciBwcmUge1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG59XG5cbmltZy5Qcm9zZU1pcnJvci1zZXBhcmF0b3Ige1xuICBkaXNwbGF5OiBpbmxpbmUgIWltcG9ydGFudDtcbiAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XG4gIG1hcmdpbjogMCAhaW1wb3J0YW50O1xuICB3aWR0aDogMXB4ICFpbXBvcnRhbnQ7XG4gIGhlaWdodDogMXB4ICFpbXBvcnRhbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1nYXBjdXJzb3Ige1xuICBkaXNwbGF5OiBub25lO1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBtYXJnaW46IDA7XG59XG5cbi5Qcm9zZU1pcnJvci1nYXBjdXJzb3I6YWZ0ZXIge1xuICBjb250ZW50OiBcIlwiO1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IC0ycHg7XG4gIHdpZHRoOiAyMHB4O1xuICBib3JkZXItdG9wOiAxcHggc29saWQgYmxhY2s7XG4gIGFuaW1hdGlvbjogUHJvc2VNaXJyb3ItY3Vyc29yLWJsaW5rIDEuMXMgc3RlcHMoMiwgc3RhcnQpIGluZmluaXRlO1xufVxuXG5Aa2V5ZnJhbWVzIFByb3NlTWlycm9yLWN1cnNvci1ibGluayB7XG4gIHRvIHtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKjo6c2VsZWN0aW9uIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICo6Oi1tb3otc2VsZWN0aW9uIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICoge1xuICBjYXJldC1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1mb2N1c2VkIC5Qcm9zZU1pcnJvci1nYXBjdXJzb3Ige1xuICBkaXNwbGF5OiBibG9jaztcbn1cblxuLnRpcHB5LWJveFtkYXRhLWFuaW1hdGlvbj1mYWRlXVtkYXRhLXN0YXRlPWhpZGRlbl0ge1xuICBvcGFjaXR5OiAwXG59YFxuIiwgImV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHlsZVRhZyhzdHlsZTogc3RyaW5nLCBub25jZT86IHN0cmluZywgc3VmZml4Pzogc3RyaW5nKTogSFRNTFN0eWxlRWxlbWVudCB7XG4gIGNvbnN0IHRpcHRhcFN0eWxlVGFnID0gKDxIVE1MU3R5bGVFbGVtZW50PmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHN0eWxlW2RhdGEtdGlwdGFwLXN0eWxlJHtzdWZmaXggPyBgLSR7c3VmZml4fWAgOiAnJ31dYCkpXG5cbiAgaWYgKHRpcHRhcFN0eWxlVGFnICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRpcHRhcFN0eWxlVGFnXG4gIH1cblxuICBjb25zdCBzdHlsZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG5cbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSlcbiAgfVxuXG4gIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoYGRhdGEtdGlwdGFwLXN0eWxlJHtzdWZmaXggPyBgLSR7c3VmZml4fWAgOiAnJ31gLCAnJylcbiAgc3R5bGVOb2RlLmlubmVySFRNTCA9IHN0eWxlXG4gIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc3R5bGVOb2RlKVxuXG4gIHJldHVybiBzdHlsZU5vZGVcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSwgTm9kZVR5cGUsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQge1xuICBFZGl0b3JTdGF0ZSwgUGx1Z2luLCBQbHVnaW5LZXksIFRyYW5zYWN0aW9uLFxufSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHsgQ29tbWFuZE1hbmFnZXIgfSBmcm9tICcuL0NvbW1hbmRNYW5hZ2VyLmpzJ1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi9FdmVudEVtaXR0ZXIuanMnXG5pbXBvcnQgeyBFeHRlbnNpb25NYW5hZ2VyIH0gZnJvbSAnLi9FeHRlbnNpb25NYW5hZ2VyLmpzJ1xuaW1wb3J0ICogYXMgZXh0ZW5zaW9ucyBmcm9tICcuL2V4dGVuc2lvbnMvaW5kZXguanMnXG5pbXBvcnQgeyBjcmVhdGVEb2N1bWVudCB9IGZyb20gJy4vaGVscGVycy9jcmVhdGVEb2N1bWVudC5qcydcbmltcG9ydCB7IGdldEF0dHJpYnV0ZXMgfSBmcm9tICcuL2hlbHBlcnMvZ2V0QXR0cmlidXRlcy5qcydcbmltcG9ydCB7IGdldEhUTUxGcm9tRnJhZ21lbnQgfSBmcm9tICcuL2hlbHBlcnMvZ2V0SFRNTEZyb21GcmFnbWVudC5qcydcbmltcG9ydCB7IGdldFRleHQgfSBmcm9tICcuL2hlbHBlcnMvZ2V0VGV4dC5qcydcbmltcG9ydCB7IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEgfSBmcm9tICcuL2hlbHBlcnMvZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYS5qcydcbmltcG9ydCB7IGlzQWN0aXZlIH0gZnJvbSAnLi9oZWxwZXJzL2lzQWN0aXZlLmpzJ1xuaW1wb3J0IHsgaXNOb2RlRW1wdHkgfSBmcm9tICcuL2hlbHBlcnMvaXNOb2RlRW1wdHkuanMnXG5pbXBvcnQgeyByZXNvbHZlRm9jdXNQb3NpdGlvbiB9IGZyb20gJy4vaGVscGVycy9yZXNvbHZlRm9jdXNQb3NpdGlvbi5qcydcbmltcG9ydCB7IHN0eWxlIH0gZnJvbSAnLi9zdHlsZS5qcydcbmltcG9ydCB7XG4gIENhbkNvbW1hbmRzLFxuICBDaGFpbmVkQ29tbWFuZHMsXG4gIEVkaXRvckV2ZW50cyxcbiAgRWRpdG9yT3B0aW9ucyxcbiAgSlNPTkNvbnRlbnQsXG4gIFNpbmdsZUNvbW1hbmRzLFxuICBUZXh0U2VyaWFsaXplcixcbn0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGNyZWF0ZVN0eWxlVGFnIH0gZnJvbSAnLi91dGlsaXRpZXMvY3JlYXRlU3R5bGVUYWcuanMnXG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi91dGlsaXRpZXMvaXNGdW5jdGlvbi5qcydcblxuZXhwb3J0IHsgZXh0ZW5zaW9ucyB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgSFRNTEVsZW1lbnQge1xuICBlZGl0b3I/OiBFZGl0b3Jcbn1cblxuZXhwb3J0IGNsYXNzIEVkaXRvciBleHRlbmRzIEV2ZW50RW1pdHRlcjxFZGl0b3JFdmVudHM+IHtcbiAgcHJpdmF0ZSBjb21tYW5kTWFuYWdlciE6IENvbW1hbmRNYW5hZ2VyXG5cbiAgcHVibGljIGV4dGVuc2lvbk1hbmFnZXIhOiBFeHRlbnNpb25NYW5hZ2VyXG5cbiAgcHJpdmF0ZSBjc3MhOiBIVE1MU3R5bGVFbGVtZW50XG5cbiAgcHVibGljIHNjaGVtYSE6IFNjaGVtYVxuXG4gIHB1YmxpYyB2aWV3ITogRWRpdG9yVmlld1xuXG4gIHB1YmxpYyBpc0ZvY3VzZWQgPSBmYWxzZVxuXG4gIHB1YmxpYyBleHRlbnNpb25TdG9yYWdlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge31cblxuICBwdWJsaWMgb3B0aW9uczogRWRpdG9yT3B0aW9ucyA9IHtcbiAgICBlbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICBjb250ZW50OiAnJyxcbiAgICBpbmplY3RDU1M6IHRydWUsXG4gICAgaW5qZWN0Tm9uY2U6IHVuZGVmaW5lZCxcbiAgICBleHRlbnNpb25zOiBbXSxcbiAgICBhdXRvZm9jdXM6IGZhbHNlLFxuICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgIGVkaXRvclByb3BzOiB7fSxcbiAgICBwYXJzZU9wdGlvbnM6IHt9LFxuICAgIGVuYWJsZUlucHV0UnVsZXM6IHRydWUsXG4gICAgZW5hYmxlUGFzdGVSdWxlczogdHJ1ZSxcbiAgICBlbmFibGVDb3JlRXh0ZW5zaW9uczogdHJ1ZSxcbiAgICBvbkJlZm9yZUNyZWF0ZTogKCkgPT4gbnVsbCxcbiAgICBvbkNyZWF0ZTogKCkgPT4gbnVsbCxcbiAgICBvblVwZGF0ZTogKCkgPT4gbnVsbCxcbiAgICBvblNlbGVjdGlvblVwZGF0ZTogKCkgPT4gbnVsbCxcbiAgICBvblRyYW5zYWN0aW9uOiAoKSA9PiBudWxsLFxuICAgIG9uRm9jdXM6ICgpID0+IG51bGwsXG4gICAgb25CbHVyOiAoKSA9PiBudWxsLFxuICAgIG9uRGVzdHJveTogKCkgPT4gbnVsbCxcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFBhcnRpYWw8RWRpdG9yT3B0aW9ucz4gPSB7fSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucylcbiAgICB0aGlzLmNyZWF0ZUV4dGVuc2lvbk1hbmFnZXIoKVxuICAgIHRoaXMuY3JlYXRlQ29tbWFuZE1hbmFnZXIoKVxuICAgIHRoaXMuY3JlYXRlU2NoZW1hKClcbiAgICB0aGlzLm9uKCdiZWZvcmVDcmVhdGUnLCB0aGlzLm9wdGlvbnMub25CZWZvcmVDcmVhdGUpXG4gICAgdGhpcy5lbWl0KCdiZWZvcmVDcmVhdGUnLCB7IGVkaXRvcjogdGhpcyB9KVxuICAgIHRoaXMuY3JlYXRlVmlldygpXG4gICAgdGhpcy5pbmplY3RDU1MoKVxuICAgIHRoaXMub24oJ2NyZWF0ZScsIHRoaXMub3B0aW9ucy5vbkNyZWF0ZSlcbiAgICB0aGlzLm9uKCd1cGRhdGUnLCB0aGlzLm9wdGlvbnMub25VcGRhdGUpXG4gICAgdGhpcy5vbignc2VsZWN0aW9uVXBkYXRlJywgdGhpcy5vcHRpb25zLm9uU2VsZWN0aW9uVXBkYXRlKVxuICAgIHRoaXMub24oJ3RyYW5zYWN0aW9uJywgdGhpcy5vcHRpb25zLm9uVHJhbnNhY3Rpb24pXG4gICAgdGhpcy5vbignZm9jdXMnLCB0aGlzLm9wdGlvbnMub25Gb2N1cylcbiAgICB0aGlzLm9uKCdibHVyJywgdGhpcy5vcHRpb25zLm9uQmx1cilcbiAgICB0aGlzLm9uKCdkZXN0cm95JywgdGhpcy5vcHRpb25zLm9uRGVzdHJveSlcblxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbW1hbmRzLmZvY3VzKHRoaXMub3B0aW9ucy5hdXRvZm9jdXMpXG4gICAgICB0aGlzLmVtaXQoJ2NyZWF0ZScsIHsgZWRpdG9yOiB0aGlzIH0pXG4gICAgfSwgMClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RvcmFnZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RvcmFnZSgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb25TdG9yYWdlXG4gIH1cblxuICAvKipcbiAgICogQW4gb2JqZWN0IG9mIGFsbCByZWdpc3RlcmVkIGNvbW1hbmRzLlxuICAgKi9cbiAgcHVibGljIGdldCBjb21tYW5kcygpOiBTaW5nbGVDb21tYW5kcyB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY29tbWFuZHNcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjb21tYW5kIGNoYWluIHRvIGNhbGwgbXVsdGlwbGUgY29tbWFuZHMgYXQgb25jZS5cbiAgICovXG4gIHB1YmxpYyBjaGFpbigpOiBDaGFpbmVkQ29tbWFuZHMge1xuICAgIHJldHVybiB0aGlzLmNvbW1hbmRNYW5hZ2VyLmNoYWluKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGNvbW1hbmQgb3IgYSBjb21tYW5kIGNoYWluIGNhbiBiZSBleGVjdXRlZC4gV2l0aG91dCBleGVjdXRpbmcgaXQuXG4gICAqL1xuICBwdWJsaWMgY2FuKCk6IENhbkNvbW1hbmRzIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jYW4oKVxuICB9XG5cbiAgLyoqXG4gICAqIEluamVjdCBDU1Mgc3R5bGVzLlxuICAgKi9cbiAgcHJpdmF0ZSBpbmplY3RDU1MoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbmplY3RDU1MgJiYgZG9jdW1lbnQpIHtcbiAgICAgIHRoaXMuY3NzID0gY3JlYXRlU3R5bGVUYWcoc3R5bGUsIHRoaXMub3B0aW9ucy5pbmplY3ROb25jZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGVkaXRvciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBBIGxpc3Qgb2Ygb3B0aW9uc1xuICAgKi9cbiAgcHVibGljIHNldE9wdGlvbnMob3B0aW9uczogUGFydGlhbDxFZGl0b3JPcHRpb25zPiA9IHt9KTogdm9pZCB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudmlldyB8fCAhdGhpcy5zdGF0ZSB8fCB0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmVkaXRvclByb3BzKSB7XG4gICAgICB0aGlzLnZpZXcuc2V0UHJvcHModGhpcy5vcHRpb25zLmVkaXRvclByb3BzKVxuICAgIH1cblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZSh0aGlzLnN0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBlZGl0YWJsZSBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxuICAgKi9cbiAgcHVibGljIHNldEVkaXRhYmxlKGVkaXRhYmxlOiBib29sZWFuLCBlbWl0VXBkYXRlID0gdHJ1ZSk6IHZvaWQge1xuICAgIHRoaXMuc2V0T3B0aW9ucyh7IGVkaXRhYmxlIH0pXG5cbiAgICBpZiAoZW1pdFVwZGF0ZSkge1xuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB7IGVkaXRvcjogdGhpcywgdHJhbnNhY3Rpb246IHRoaXMuc3RhdGUudHIgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlZGl0b3IgaXMgZWRpdGFibGUuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzRWRpdGFibGUoKTogYm9vbGVhbiB7XG4gICAgLy8gc2luY2UgcGx1Z2lucyBhcmUgYXBwbGllZCBhZnRlciBjcmVhdGluZyB0aGUgdmlld1xuICAgIC8vIGBlZGl0YWJsZWAgaXMgYWx3YXlzIGB0cnVlYCBmb3Igb25lIHRpY2suXG4gICAgLy8gdGhhdOKAmXMgd2h5IHdlIGFsc28gaGF2ZSB0byBjaGVjayBmb3IgYG9wdGlvbnMuZWRpdGFibGVgXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5lZGl0YWJsZSAmJiB0aGlzLnZpZXcgJiYgdGhpcy52aWV3LmVkaXRhYmxlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRpdG9yIHN0YXRlLlxuICAgKi9cbiAgcHVibGljIGdldCBzdGF0ZSgpOiBFZGl0b3JTdGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5zdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgUHJvc2VNaXJyb3IgcGx1Z2luLlxuICAgKlxuICAgKiBAcGFyYW0gcGx1Z2luIEEgUHJvc2VNaXJyb3IgcGx1Z2luXG4gICAqIEBwYXJhbSBoYW5kbGVQbHVnaW5zIENvbnRyb2wgaG93IHRvIG1lcmdlIHRoZSBwbHVnaW4gaW50byB0aGUgZXhpc3RpbmcgcGx1Z2lucy5cbiAgICovXG4gIHB1YmxpYyByZWdpc3RlclBsdWdpbihcbiAgICBwbHVnaW46IFBsdWdpbixcbiAgICBoYW5kbGVQbHVnaW5zPzogKG5ld1BsdWdpbjogUGx1Z2luLCBwbHVnaW5zOiBQbHVnaW5bXSkgPT4gUGx1Z2luW10sXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IHBsdWdpbnMgPSBpc0Z1bmN0aW9uKGhhbmRsZVBsdWdpbnMpXG4gICAgICA/IGhhbmRsZVBsdWdpbnMocGx1Z2luLCBbLi4udGhpcy5zdGF0ZS5wbHVnaW5zXSlcbiAgICAgIDogWy4uLnRoaXMuc3RhdGUucGx1Z2lucywgcGx1Z2luXVxuXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHsgcGx1Z2lucyB9KVxuXG4gICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYSBQcm9zZU1pcnJvciBwbHVnaW4uXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lT3JQbHVnaW5LZXkgVGhlIHBsdWdpbnMgbmFtZVxuICAgKi9cbiAgcHVibGljIHVucmVnaXN0ZXJQbHVnaW4obmFtZU9yUGx1Z2luS2V5OiBzdHJpbmcgfCBQbHVnaW5LZXkpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yUGx1Z2luS2V5ID09PSAnc3RyaW5nJyA/IGAke25hbWVPclBsdWdpbktleX0kYCA6IG5hbWVPclBsdWdpbktleS5rZXlcblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBwbHVnaW5zOiB0aGlzLnN0YXRlLnBsdWdpbnMuZmlsdGVyKHBsdWdpbiA9PiAhcGx1Z2luLmtleS5zdGFydHNXaXRoKG5hbWUpKSxcbiAgICB9KVxuXG4gICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZXh0ZW5zaW9uIG1hbmFnZXIuXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZUV4dGVuc2lvbk1hbmFnZXIoKTogdm9pZCB7XG4gICAgY29uc3QgY29yZUV4dGVuc2lvbnMgPSB0aGlzLm9wdGlvbnMuZW5hYmxlQ29yZUV4dGVuc2lvbnMgPyBPYmplY3QudmFsdWVzKGV4dGVuc2lvbnMpIDogW11cbiAgICBjb25zdCBhbGxFeHRlbnNpb25zID0gWy4uLmNvcmVFeHRlbnNpb25zLCAuLi50aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc10uZmlsdGVyKGV4dGVuc2lvbiA9PiB7XG4gICAgICByZXR1cm4gWydleHRlbnNpb24nLCAnbm9kZScsICdtYXJrJ10uaW5jbHVkZXMoZXh0ZW5zaW9uPy50eXBlKVxuICAgIH0pXG5cbiAgICB0aGlzLmV4dGVuc2lvbk1hbmFnZXIgPSBuZXcgRXh0ZW5zaW9uTWFuYWdlcihhbGxFeHRlbnNpb25zLCB0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gY29tbWFuZCBtYW5hZ2VyLlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVDb21tYW5kTWFuYWdlcigpOiB2b2lkIHtcbiAgICB0aGlzLmNvbW1hbmRNYW5hZ2VyID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgIGVkaXRvcjogdGhpcyxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQcm9zZU1pcnJvciBzY2hlbWEuXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZVNjaGVtYSgpOiB2b2lkIHtcbiAgICB0aGlzLnNjaGVtYSA9IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5zY2hlbWFcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUHJvc2VNaXJyb3Igdmlldy5cbiAgICovXG4gIHByaXZhdGUgY3JlYXRlVmlldygpOiB2b2lkIHtcbiAgICBjb25zdCBkb2MgPSBjcmVhdGVEb2N1bWVudCh0aGlzLm9wdGlvbnMuY29udGVudCwgdGhpcy5zY2hlbWEsIHRoaXMub3B0aW9ucy5wYXJzZU9wdGlvbnMpXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gcmVzb2x2ZUZvY3VzUG9zaXRpb24oZG9jLCB0aGlzLm9wdGlvbnMuYXV0b2ZvY3VzKVxuXG4gICAgdGhpcy52aWV3ID0gbmV3IEVkaXRvclZpZXcodGhpcy5vcHRpb25zLmVsZW1lbnQsIHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcyxcbiAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb246IHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgc3RhdGU6IEVkaXRvclN0YXRlLmNyZWF0ZSh7XG4gICAgICAgIGRvYyxcbiAgICAgICAgc2VsZWN0aW9uOiBzZWxlY3Rpb24gfHwgdW5kZWZpbmVkLFxuICAgICAgfSksXG4gICAgfSlcblxuICAgIC8vIGBlZGl0b3Iudmlld2AgaXMgbm90IHlldCBhdmFpbGFibGUgYXQgdGhpcyB0aW1lLlxuICAgIC8vIFRoZXJlZm9yZSB3ZSB3aWxsIGFkZCBhbGwgcGx1Z2lucyBhbmQgbm9kZSB2aWV3cyBkaXJlY3RseSBhZnRlcndhcmRzLlxuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7XG4gICAgICBwbHVnaW5zOiB0aGlzLmV4dGVuc2lvbk1hbmFnZXIucGx1Z2lucyxcbiAgICB9KVxuXG4gICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKG5ld1N0YXRlKVxuXG4gICAgdGhpcy5jcmVhdGVOb2RlVmlld3MoKVxuICAgIHRoaXMucHJlcGVuZENsYXNzKClcblxuICAgIC8vIExldOKAmXMgc3RvcmUgdGhlIGVkaXRvciBpbnN0YW5jZSBpbiB0aGUgRE9NIGVsZW1lbnQuXG4gICAgLy8gU28gd2XigJlsbCBoYXZlIGFjY2VzcyB0byBpdCBmb3IgdGVzdHMuXG4gICAgY29uc3QgZG9tID0gdGhpcy52aWV3LmRvbSBhcyBIVE1MRWxlbWVudFxuXG4gICAgZG9tLmVkaXRvciA9IHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFsbCBub2RlIHZpZXdzLlxuICAgKi9cbiAgcHVibGljIGNyZWF0ZU5vZGVWaWV3cygpOiB2b2lkIHtcbiAgICB0aGlzLnZpZXcuc2V0UHJvcHMoe1xuICAgICAgbm9kZVZpZXdzOiB0aGlzLmV4dGVuc2lvbk1hbmFnZXIubm9kZVZpZXdzLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUHJlcGVuZCBjbGFzcyBuYW1lIHRvIGVsZW1lbnQuXG4gICAqL1xuICBwdWJsaWMgcHJlcGVuZENsYXNzKCk6IHZvaWQge1xuICAgIHRoaXMudmlldy5kb20uY2xhc3NOYW1lID0gYHRpcHRhcCAke3RoaXMudmlldy5kb20uY2xhc3NOYW1lfWBcbiAgfVxuXG4gIHB1YmxpYyBpc0NhcHR1cmluZ1RyYW5zYWN0aW9uID0gZmFsc2VcblxuICBwcml2YXRlIGNhcHR1cmVkVHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uIHwgbnVsbCA9IG51bGxcblxuICBwdWJsaWMgY2FwdHVyZVRyYW5zYWN0aW9uKGZuOiBGdW5jdGlvbikge1xuICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IHRydWVcbiAgICBmbigpXG4gICAgdGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uID0gZmFsc2VcblxuICAgIGNvbnN0IHRyID0gdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uXG5cbiAgICB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24gPSBudWxsXG5cbiAgICByZXR1cm4gdHJcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2FsbGJhY2sgb3ZlciB3aGljaCB0byBzZW5kIHRyYW5zYWN0aW9ucyAoc3RhdGUgdXBkYXRlcykgcHJvZHVjZWQgYnkgdGhlIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbiBBbiBlZGl0b3Igc3RhdGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIHByaXZhdGUgZGlzcGF0Y2hUcmFuc2FjdGlvbih0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICAvLyBpZiB0aGUgZWRpdG9yIC8gdGhlIHZpZXcgb2YgdGhlIGVkaXRvciB3YXMgZGVzdHJveWVkXG4gICAgLy8gdGhlIHRyYW5zYWN0aW9uIHNob3VsZCBub3QgYmUgZGlzcGF0Y2hlZCBhcyB0aGVyZSBpcyBubyB2aWV3IGFueW1vcmUuXG4gICAgaWYgKHRoaXMudmlldy5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbikge1xuICAgICAgaWYgKCF0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25cblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaChzdGVwID0+IHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbj8uc3RlcChzdGVwKSlcblxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLmFwcGx5KHRyYW5zYWN0aW9uKVxuICAgIGNvbnN0IHNlbGVjdGlvbkhhc0NoYW5nZWQgPSAhdGhpcy5zdGF0ZS5zZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKVxuXG4gICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKVxuICAgIHRoaXMuZW1pdCgndHJhbnNhY3Rpb24nLCB7XG4gICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICB9KVxuXG4gICAgaWYgKHNlbGVjdGlvbkhhc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuZW1pdCgnc2VsZWN0aW9uVXBkYXRlJywge1xuICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBmb2N1cyA9IHRyYW5zYWN0aW9uLmdldE1ldGEoJ2ZvY3VzJylcbiAgICBjb25zdCBibHVyID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgnYmx1cicpXG5cbiAgICBpZiAoZm9jdXMpIHtcbiAgICAgIHRoaXMuZW1pdCgnZm9jdXMnLCB7XG4gICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgZXZlbnQ6IGZvY3VzLmV2ZW50LFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGJsdXIpIHtcbiAgICAgIHRoaXMuZW1pdCgnYmx1cicsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICBldmVudDogYmx1ci5ldmVudCxcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICghdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZCB8fCB0cmFuc2FjdGlvbi5nZXRNZXRhKCdwcmV2ZW50VXBkYXRlJykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuZW1pdCgndXBkYXRlJywge1xuICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYXR0cmlidXRlcyBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgb3IgbWFyay5cbiAgICovXG4gIHB1YmxpYyBnZXRBdHRyaWJ1dGVzKG5hbWVPclR5cGU6IHN0cmluZyB8IE5vZGVUeXBlIHwgTWFya1R5cGUpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICByZXR1cm4gZ2V0QXR0cmlidXRlcyh0aGlzLnN0YXRlLCBuYW1lT3JUeXBlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub2RlIG9yIG1hcmsgaXMgYWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBub2RlIG9yIG1hcmtcbiAgICogQHBhcmFtIGF0dHJpYnV0ZXMgQXR0cmlidXRlcyBvZiB0aGUgbm9kZSBvciBtYXJrXG4gICAqL1xuICBwdWJsaWMgaXNBY3RpdmUobmFtZTogc3RyaW5nLCBhdHRyaWJ1dGVzPzoge30pOiBib29sZWFuXG4gIHB1YmxpYyBpc0FjdGl2ZShhdHRyaWJ1dGVzOiB7fSk6IGJvb2xlYW5cbiAgcHVibGljIGlzQWN0aXZlKG5hbWVPckF0dHJpYnV0ZXM6IHN0cmluZywgYXR0cmlidXRlc09yVW5kZWZpbmVkPzoge30pOiBib29sZWFuIHtcbiAgICBjb25zdCBuYW1lID0gdHlwZW9mIG5hbWVPckF0dHJpYnV0ZXMgPT09ICdzdHJpbmcnID8gbmFtZU9yQXR0cmlidXRlcyA6IG51bGxcblxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0eXBlb2YgbmFtZU9yQXR0cmlidXRlcyA9PT0gJ3N0cmluZycgPyBhdHRyaWJ1dGVzT3JVbmRlZmluZWQgOiBuYW1lT3JBdHRyaWJ1dGVzXG5cbiAgICByZXR1cm4gaXNBY3RpdmUodGhpcy5zdGF0ZSwgbmFtZSwgYXR0cmlidXRlcylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRvY3VtZW50IGFzIEpTT04uXG4gICAqL1xuICBwdWJsaWMgZ2V0SlNPTigpOiBKU09OQ29udGVudCB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZG9jLnRvSlNPTigpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkb2N1bWVudCBhcyBIVE1MLlxuICAgKi9cbiAgcHVibGljIGdldEhUTUwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudCh0aGlzLnN0YXRlLmRvYy5jb250ZW50LCB0aGlzLnNjaGVtYSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRvY3VtZW50IGFzIHRleHQuXG4gICAqL1xuICBwdWJsaWMgZ2V0VGV4dChvcHRpb25zPzoge1xuICAgIGJsb2NrU2VwYXJhdG9yPzogc3RyaW5nXG4gICAgdGV4dFNlcmlhbGl6ZXJzPzogUmVjb3JkPHN0cmluZywgVGV4dFNlcmlhbGl6ZXI+XG4gIH0pOiBzdHJpbmcge1xuICAgIGNvbnN0IHsgYmxvY2tTZXBhcmF0b3IgPSAnXFxuXFxuJywgdGV4dFNlcmlhbGl6ZXJzID0ge30gfSA9IG9wdGlvbnMgfHwge31cblxuICAgIHJldHVybiBnZXRUZXh0KHRoaXMuc3RhdGUuZG9jLCB7XG4gICAgICBibG9ja1NlcGFyYXRvcixcbiAgICAgIHRleHRTZXJpYWxpemVyczoge1xuICAgICAgICAuLi5nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHRoaXMuc2NoZW1hKSxcbiAgICAgICAgLi4udGV4dFNlcmlhbGl6ZXJzLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZXJlIGlzIG5vIGNvbnRlbnQuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzTm9kZUVtcHR5KHRoaXMuc3RhdGUuZG9jKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgcHVibGljIGdldENoYXJhY3RlckNvdW50KCk6IG51bWJlciB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1t0aXB0YXAgd2Fybl06IFwiZWRpdG9yLmdldENoYXJhY3RlckNvdW50KClcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiZWRpdG9yLnN0b3JhZ2UuY2hhcmFjdGVyQ291bnQuY2hhcmFjdGVycygpXCIgaW5zdGVhZC4nLFxuICAgIClcblxuICAgIHJldHVybiB0aGlzLnN0YXRlLmRvYy5jb250ZW50LnNpemUgLSAyXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgZWRpdG9yLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95JylcblxuICAgIGlmICh0aGlzLnZpZXcpIHtcbiAgICAgIHRoaXMudmlldy5kZXN0cm95KClcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGVkaXRvciBpcyBhbHJlYWR5IGRlc3Ryb3llZC5cbiAgICovXG4gIHB1YmxpYyBnZXQgaXNEZXN0cm95ZWQoKTogYm9vbGVhbiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiAhdGhpcy52aWV3Py5kb2NWaWV3XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE1hcmtzQmV0d2VlbiB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya3NCZXR3ZWVuLmpzJ1xuaW1wb3J0IHsgSW5wdXRSdWxlLCBJbnB1dFJ1bGVGaW5kZXIgfSBmcm9tICcuLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4uL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5cbi8qKlxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IGFkZHMgYSBtYXJrIHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcmtJbnB1dFJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlclxuICB0eXBlOiBNYXJrVHlwZVxuICBnZXRBdHRyaWJ1dGVzPzpcbiAgICB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICB8ICgobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICB8IGZhbHNlXG4gICAgfCBudWxsXG59KSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpXG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzID09PSBmYWxzZSB8fCBhdHRyaWJ1dGVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlXG4gICAgICBjb25zdCBjYXB0dXJlR3JvdXAgPSBtYXRjaFttYXRjaC5sZW5ndGggLSAxXVxuICAgICAgY29uc3QgZnVsbE1hdGNoID0gbWF0Y2hbMF1cblxuICAgICAgaWYgKGNhcHR1cmVHcm91cCkge1xuICAgICAgICBjb25zdCBzdGFydFNwYWNlcyA9IGZ1bGxNYXRjaC5zZWFyY2goL1xcUy8pXG4gICAgICAgIGNvbnN0IHRleHRTdGFydCA9IHJhbmdlLmZyb20gKyBmdWxsTWF0Y2guaW5kZXhPZihjYXB0dXJlR3JvdXApXG4gICAgICAgIGNvbnN0IHRleHRFbmQgPSB0ZXh0U3RhcnQgKyBjYXB0dXJlR3JvdXAubGVuZ3RoXG5cbiAgICAgICAgY29uc3QgZXhjbHVkZWRNYXJrcyA9IGdldE1hcmtzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgc3RhdGUuZG9jKVxuICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBleGNsdWRlZCA9IGl0ZW0ubWFyay50eXBlLmV4Y2x1ZGVkIGFzIE1hcmtUeXBlW11cblxuICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVkLmZpbmQodHlwZSA9PiB0eXBlID09PSBjb25maWcudHlwZSAmJiB0eXBlICE9PSBpdGVtLm1hcmsudHlwZSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnRvID4gdGV4dFN0YXJ0KVxuXG4gICAgICAgIGlmIChleGNsdWRlZE1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dEVuZCA8IHJhbmdlLnRvKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHRleHRFbmQsIHJhbmdlLnRvKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRTdGFydCA+IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICB0ci5kZWxldGUocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCB0ZXh0U3RhcnQpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYXJrRW5kID0gcmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzICsgY2FwdHVyZUdyb3VwLmxlbmd0aFxuXG4gICAgICAgIHRyLmFkZE1hcmsocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCBtYXJrRW5kLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyB8fCB7fSkpXG5cbiAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhjb25maWcudHlwZSlcbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgSW5wdXRSdWxlLCBJbnB1dFJ1bGVGaW5kZXIgfSBmcm9tICcuLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4uL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5cbi8qKlxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IGFkZHMgYSBub2RlIHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vZGVJbnB1dFJ1bGUoY29uZmlnOiB7XG4gIC8qKlxuICAgKiBUaGUgcmVnZXggdG8gbWF0Y2guXG4gICAqL1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXJcblxuICAvKipcbiAgICogVGhlIG5vZGUgdHlwZSB0byBhZGQuXG4gICAqL1xuICB0eXBlOiBOb2RlVHlwZVxuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIG5vZGVcbiAgICogY2FuIGFsc28gYmUgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXNcbiAgICovXG4gIGdldEF0dHJpYnV0ZXM/OlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5KSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgIHwgZmFsc2VcbiAgICB8IG51bGxcbn0pIHtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCkgfHwge31cbiAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlXG4gICAgICBjb25zdCBzdGFydCA9IHJhbmdlLmZyb21cbiAgICAgIGxldCBlbmQgPSByYW5nZS50b1xuXG4gICAgICBjb25zdCBuZXdOb2RlID0gY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpXG5cbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXRjaFswXS5sYXN0SW5kZXhPZihtYXRjaFsxXSlcbiAgICAgICAgbGV0IG1hdGNoU3RhcnQgPSBzdGFydCArIG9mZnNldFxuXG4gICAgICAgIGlmIChtYXRjaFN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgbWF0Y2hTdGFydCA9IGVuZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZCA9IG1hdGNoU3RhcnQgKyBtYXRjaFsxXS5sZW5ndGhcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluc2VydCBsYXN0IHR5cGVkIGNoYXJhY3RlclxuICAgICAgICBjb25zdCBsYXN0Q2hhciA9IG1hdGNoWzBdW21hdGNoWzBdLmxlbmd0aCAtIDFdXG5cbiAgICAgICAgdHIuaW5zZXJ0VGV4dChsYXN0Q2hhciwgc3RhcnQgKyBtYXRjaFswXS5sZW5ndGggLSAxKVxuXG4gICAgICAgIC8vIGluc2VydCBub2RlIGZyb20gaW5wdXQgcnVsZVxuICAgICAgICB0ci5yZXBsYWNlV2l0aChtYXRjaFN0YXJ0LCBlbmQsIG5ld05vZGUpXG4gICAgICB9IGVsc2UgaWYgKG1hdGNoWzBdKSB7XG4gICAgICAgIHRyLmluc2VydChzdGFydCAtIDEsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKSkuZGVsZXRlKFxuICAgICAgICAgIHRyLm1hcHBpbmcubWFwKHN0YXJ0KSxcbiAgICAgICAgICB0ci5tYXBwaW5nLm1hcChlbmQpLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHRyLnNjcm9sbEludG9WaWV3KClcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgSW5wdXRSdWxlLCBJbnB1dFJ1bGVGaW5kZXIgfSBmcm9tICcuLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4uL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5cbi8qKlxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IGNoYW5nZXMgdGhlIHR5cGUgb2YgYSB0ZXh0YmxvY2sgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LiBXaGVuIHVzaW5nIGEgcmVndWxhciBleHByZXNpb24geW914oCZbGxcbiAqIHByb2JhYmx5IHdhbnQgdGhlIHJlZ2V4cCB0byBzdGFydCB3aXRoIGBeYCwgc28gdGhhdCB0aGUgcGF0dGVybiBjYW5cbiAqIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGV4dGJsb2NrVHlwZUlucHV0UnVsZShjb25maWc6IHtcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyXG4gIHR5cGU6IE5vZGVUeXBlXG4gIGdldEF0dHJpYnV0ZXM/OlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5KSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgIHwgZmFsc2VcbiAgICB8IG51bGxcbn0pIHtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgY29uc3QgJHN0YXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSlcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpIHx8IHt9XG5cbiAgICAgIGlmICghJHN0YXJ0Lm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRzdGFydC5pbmRleCgtMSksICRzdGFydC5pbmRleEFmdGVyKC0xKSwgY29uZmlnLnR5cGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnRyXG4gICAgICAgIC5kZWxldGUocmFuZ2UuZnJvbSwgcmFuZ2UudG8pXG4gICAgICAgIC5zZXRCbG9ja1R5cGUocmFuZ2UuZnJvbSwgcmFuZ2UuZnJvbSwgY29uZmlnLnR5cGUsIGF0dHJpYnV0ZXMpXG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBJbnB1dFJ1bGUsIElucHV0UnVsZUZpbmRlciB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIHRoYXQgcmVwbGFjZXMgdGV4dCB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0SW5wdXRSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXIsXG4gIHJlcGxhY2U6IHN0cmluZyxcbn0pIHtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgbGV0IGluc2VydCA9IGNvbmZpZy5yZXBsYWNlXG4gICAgICBsZXQgc3RhcnQgPSByYW5nZS5mcm9tXG4gICAgICBjb25zdCBlbmQgPSByYW5nZS50b1xuXG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pXG5cbiAgICAgICAgaW5zZXJ0ICs9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCArIG1hdGNoWzFdLmxlbmd0aClcbiAgICAgICAgc3RhcnQgKz0gb2Zmc2V0XG5cbiAgICAgICAgY29uc3QgY3V0T2ZmID0gc3RhcnQgLSBlbmRcblxuICAgICAgICBpZiAoY3V0T2ZmID4gMCkge1xuICAgICAgICAgIGluc2VydCA9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCAtIGN1dE9mZiwgb2Zmc2V0KSArIGluc2VydFxuICAgICAgICAgIHN0YXJ0ID0gZW5kXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhdGUudHIuaW5zZXJ0VGV4dChpbnNlcnQsIHN0YXJ0LCBlbmQpXG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgY2FuSm9pbiwgZmluZFdyYXBwaW5nIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4uL0VkaXRvci5qcydcbmltcG9ydCB7IElucHV0UnVsZSwgSW5wdXRSdWxlRmluZGVyIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgYSB0ZXh0YmxvY2sgd2hlbiBhXG4gKiBnaXZlbiBzdHJpbmcgaXMgdHlwZWQuIFdoZW4gdXNpbmcgYSByZWd1bGFyIGV4cHJlc2lvbiB5b3XigJlsbFxuICogcHJvYmFibHkgd2FudCB0aGUgcmVnZXhwIHRvIHN0YXJ0IHdpdGggYF5gLCBzbyB0aGF0IHRoZSBwYXR0ZXJuIGNhblxuICogb25seSBvY2N1ciBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2suXG4gKlxuICogYHR5cGVgIGlzIHRoZSB0eXBlIG9mIG5vZGUgdG8gd3JhcCBpbi5cbiAqXG4gKiBCeSBkZWZhdWx0LCBpZiB0aGVyZeKAmXMgYSBub2RlIHdpdGggdGhlIHNhbWUgdHlwZSBhYm92ZSB0aGUgbmV3bHlcbiAqIHdyYXBwZWQgbm9kZSwgdGhlIHJ1bGUgd2lsbCB0cnkgdG8gam9pbiB0aG9zZVxuICogdHdvIG5vZGVzLiBZb3UgY2FuIHBhc3MgYSBqb2luIHByZWRpY2F0ZSwgd2hpY2ggdGFrZXMgYSByZWd1bGFyXG4gKiBleHByZXNzaW9uIG1hdGNoIGFuZCB0aGUgbm9kZSBiZWZvcmUgdGhlIHdyYXBwZWQgbm9kZSwgYW5kIGNhblxuICogcmV0dXJuIGEgYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIGEgam9pbiBzaG91bGQgaGFwcGVuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcHBpbmdJbnB1dFJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlcixcbiAgdHlwZTogTm9kZVR5cGUsXG4gIGtlZXBNYXJrcz86IGJvb2xlYW4sXG4gIGtlZXBBdHRyaWJ1dGVzPzogYm9vbGVhbixcbiAgZWRpdG9yPzogRWRpdG9yXG4gIGdldEF0dHJpYnV0ZXM/OlxuICB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgfCAoKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gIHwgZmFsc2VcbiAgfCBudWxsXG4gICxcbiAgam9pblByZWRpY2F0ZT86IChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5LCBub2RlOiBQcm9zZU1pcnJvck5vZGUpID0+IGJvb2xlYW4sXG59KSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoe1xuICAgICAgc3RhdGUsIHJhbmdlLCBtYXRjaCwgY2hhaW4sXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCkgfHwge31cbiAgICAgIGNvbnN0IHRyID0gc3RhdGUudHIuZGVsZXRlKHJhbmdlLmZyb20sIHJhbmdlLnRvKVxuICAgICAgY29uc3QgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSlcbiAgICAgIGNvbnN0IGJsb2NrUmFuZ2UgPSAkc3RhcnQuYmxvY2tSYW5nZSgpXG4gICAgICBjb25zdCB3cmFwcGluZyA9IGJsb2NrUmFuZ2UgJiYgZmluZFdyYXBwaW5nKGJsb2NrUmFuZ2UsIGNvbmZpZy50eXBlLCBhdHRyaWJ1dGVzKVxuXG4gICAgICBpZiAoIXdyYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIHRyLndyYXAoYmxvY2tSYW5nZSwgd3JhcHBpbmcpXG5cbiAgICAgIGlmIChjb25maWcua2VlcE1hcmtzICYmIGNvbmZpZy5lZGl0b3IpIHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZVxuICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gY29uZmlnLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyXG4gICAgICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxuXG4gICAgICAgIGlmIChtYXJrcykge1xuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKVxuXG4gICAgICAgICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAvKiogSWYgdGhlIG5vZGVUeXBlIGlzIGBidWxsZXRMaXN0YCBvciBgb3JkZXJlZExpc3RgIHNldCB0aGUgYG5vZGVUeXBlYCBhcyBgbGlzdEl0ZW1gICovXG4gICAgICAgIGNvbnN0IG5vZGVUeXBlID0gY29uZmlnLnR5cGUubmFtZSA9PT0gJ2J1bGxldExpc3QnIHx8IGNvbmZpZy50eXBlLm5hbWUgPT09ICdvcmRlcmVkTGlzdCcgPyAnbGlzdEl0ZW0nIDogJ3Rhc2tMaXN0J1xuXG4gICAgICAgIGNoYWluKCkudXBkYXRlQXR0cmlidXRlcyhub2RlVHlwZSwgYXR0cmlidXRlcykucnVuKClcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmVmb3JlID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSAtIDEpLm5vZGVCZWZvcmVcblxuICAgICAgaWYgKFxuICAgICAgICBiZWZvcmVcbiAgICAgICAgJiYgYmVmb3JlLnR5cGUgPT09IGNvbmZpZy50eXBlXG4gICAgICAgICYmIGNhbkpvaW4odHIuZG9jLCByYW5nZS5mcm9tIC0gMSlcbiAgICAgICAgJiYgKCFjb25maWcuam9pblByZWRpY2F0ZSB8fCBjb25maWcuam9pblByZWRpY2F0ZShtYXRjaCwgYmVmb3JlKSlcbiAgICAgICkge1xuICAgICAgICB0ci5qb2luKHJhbmdlLmZyb20gLSAxKVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHtcbiAgRE9NT3V0cHV0U3BlYywgTWFyayBhcyBQcm9zZU1pcnJvck1hcmssIE1hcmtTcGVjLCBNYXJrVHlwZSxcbn0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnLi9oZWxwZXJzL2dldEV4dGVuc2lvbkZpZWxkLmpzJ1xuaW1wb3J0IHsgTWFya0NvbmZpZyB9IGZyb20gJy4vaW5kZXguanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUgfSBmcm9tICcuL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuL05vZGUuanMnXG5pbXBvcnQgeyBQYXN0ZVJ1bGUgfSBmcm9tICcuL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7XG4gIEFueUNvbmZpZyxcbiAgQXR0cmlidXRlcyxcbiAgRXh0ZW5zaW9ucyxcbiAgR2xvYmFsQXR0cmlidXRlcyxcbiAgS2V5Ym9hcmRTaG9ydGN1dENvbW1hbmQsXG4gIFBhcmVudENvbmZpZyxcbiAgUmF3Q29tbWFuZHMsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBtZXJnZURlZXAgfSBmcm9tICcuL3V0aWxpdGllcy9tZXJnZURlZXAuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgZXhwb3J0IGludGVyZmFjZSBNYXJrQ29uZmlnPE9wdGlvbnMgPSBhbnksIFN0b3JhZ2UgPSBhbnk+IHtcbiAgICBba2V5OiBzdHJpbmddOiBhbnlcblxuICAgIC8qKlxuICAgICAqIE5hbWVcbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmdcblxuICAgIC8qKlxuICAgICAqIFByaW9yaXR5XG4gICAgICovXG4gICAgcHJpb3JpdHk/OiBudW1iZXJcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgb3B0aW9uc1xuICAgICAqL1xuICAgIGRlZmF1bHRPcHRpb25zPzogT3B0aW9uc1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBPcHRpb25zXG4gICAgICovXG4gICAgYWRkT3B0aW9ucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIHBhcmVudDogRXhjbHVkZTxQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZE9wdGlvbnMnXSwgdW5kZWZpbmVkPlxuICAgIH0pID0+IE9wdGlvbnNcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgU3RvcmFnZVxuICAgICAqL1xuICAgIGFkZFN0b3JhZ2U/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBwYXJlbnQ6IEV4Y2x1ZGU8UGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRTdG9yYWdlJ10sIHVuZGVmaW5lZD5cbiAgICB9KSA9PiBTdG9yYWdlXG5cbiAgICAvKipcbiAgICAgKiBHbG9iYWwgYXR0cmlidXRlc1xuICAgICAqL1xuICAgIGFkZEdsb2JhbEF0dHJpYnV0ZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkR2xvYmFsQXR0cmlidXRlcyddXG4gICAgfSkgPT4gR2xvYmFsQXR0cmlidXRlcyB8IHt9XG5cbiAgICAvKipcbiAgICAgKiBSYXdcbiAgICAgKi9cbiAgICBhZGRDb21tYW5kcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZENvbW1hbmRzJ11cbiAgICB9KSA9PiBQYXJ0aWFsPFJhd0NvbW1hbmRzPlxuXG4gICAgLyoqXG4gICAgICogS2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICovXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRLZXlib2FyZFNob3J0Y3V0cyddXG4gICAgfSkgPT4ge1xuICAgICAgW2tleTogc3RyaW5nXTogS2V5Ym9hcmRTaG9ydGN1dENvbW1hbmRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnB1dCBydWxlc1xuICAgICAqL1xuICAgIGFkZElucHV0UnVsZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRJbnB1dFJ1bGVzJ11cbiAgICB9KSA9PiBJbnB1dFJ1bGVbXVxuXG4gICAgLyoqXG4gICAgICogUGFzdGUgcnVsZXNcbiAgICAgKi9cbiAgICBhZGRQYXN0ZVJ1bGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkUGFzdGVSdWxlcyddXG4gICAgfSkgPT4gUGFzdGVSdWxlW11cblxuICAgIC8qKlxuICAgICAqIFByb3NlTWlycm9yIHBsdWdpbnNcbiAgICAgKi9cbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRQcm9zZU1pcnJvclBsdWdpbnMnXVxuICAgIH0pID0+IFBsdWdpbltdXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbnNpb25zXG4gICAgICovXG4gICAgYWRkRXh0ZW5zaW9ucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRFeHRlbnNpb25zJ11cbiAgICB9KSA9PiBFeHRlbnNpb25zXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgTm9kZSBTY2hlbWFcbiAgICAgKi9cbiAgICBleHRlbmROb2RlU2NoZW1hPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydleHRlbmROb2RlU2NoZW1hJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4dGVuc2lvbjogTm9kZSxcbiAgICAgICAgKSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgTWFyayBTY2hlbWFcbiAgICAgKi9cbiAgICBleHRlbmRNYXJrU2NoZW1hPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydleHRlbmRNYXJrU2NoZW1hJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4dGVuc2lvbjogTWFyayxcbiAgICAgICAgKSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIG5vdCByZWFkeSB5ZXQuXG4gICAgICovXG4gICAgb25CZWZvcmVDcmVhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25CZWZvcmVDcmVhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIHJlYWR5LlxuICAgICAqL1xuICAgIG9uQ3JlYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQ3JlYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRlbnQgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25VcGRhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25VcGRhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uU2VsZWN0aW9uVXBkYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uU2VsZWN0aW9uVXBkYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBzdGF0ZSBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblRyYW5zYWN0aW9uPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uVHJhbnNhY3Rpb24nXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBmb2N1c2VkLlxuICAgICAqL1xuICAgIG9uRm9jdXM/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25Gb2N1cyddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZXZlbnQ6IEZvY3VzRXZlbnRcbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXNu4oCZdCBmb2N1c2VkIGFueW1vcmUuXG4gICAgICovXG4gICAgb25CbHVyPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQmx1ciddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZXZlbnQ6IEZvY3VzRXZlbnRcbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIG9uRGVzdHJveT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkRlc3Ryb3knXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBLZWVwIG1hcmsgYWZ0ZXIgc3BsaXQgbm9kZVxuICAgICAqL1xuICAgIGtlZXBPblNwbGl0PzogYm9vbGVhbiB8ICgoKSA9PiBib29sZWFuKVxuXG4gICAgLyoqXG4gICAgICogSW5jbHVzaXZlXG4gICAgICovXG4gICAgaW5jbHVzaXZlPzpcbiAgICAgIHwgTWFya1NwZWNbJ2luY2x1c2l2ZSddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2luY2x1c2l2ZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE1hcmtTcGVjWydpbmNsdXNpdmUnXSlcblxuICAgIC8qKlxuICAgICAqIEV4Y2x1ZGVzXG4gICAgICovXG4gICAgZXhjbHVkZXM/OlxuICAgICAgfCBNYXJrU3BlY1snZXhjbHVkZXMnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydleGNsdWRlcyddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE1hcmtTcGVjWydleGNsdWRlcyddKVxuXG4gICAgLyoqXG4gICAgICogTWFya3MgdGhpcyBNYXJrIGFzIGV4aXRhYmxlXG4gICAgICovXG4gICAgZXhpdGFibGU/OiBib29sZWFuIHwgKCgpID0+IGJvb2xlYW4pXG5cbiAgICAvKipcbiAgICAgKiBHcm91cFxuICAgICAqL1xuICAgIGdyb3VwPzpcbiAgICAgIHwgTWFya1NwZWNbJ2dyb3VwJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZ3JvdXAnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBNYXJrU3BlY1snZ3JvdXAnXSlcblxuICAgIC8qKlxuICAgICAqIFNwYW5uaW5nXG4gICAgICovXG4gICAgc3Bhbm5pbmc/OlxuICAgICAgfCBNYXJrU3BlY1snc3Bhbm5pbmcnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydzcGFubmluZyddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE1hcmtTcGVjWydzcGFubmluZyddKVxuXG4gICAgLyoqXG4gICAgICogQ29kZVxuICAgICAqL1xuICAgIGNvZGU/OlxuICAgICAgfCBib29sZWFuXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2NvZGUnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBib29sZWFuKVxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgSFRNTFxuICAgICAqL1xuICAgIHBhcnNlSFRNTD86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydwYXJzZUhUTUwnXVxuICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgfSkgPT4gTWFya1NwZWNbJ3BhcnNlRE9NJ11cblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBIVE1MXG4gICAgICovXG4gICAgcmVuZGVySFRNTD86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsncmVuZGVySFRNTCddXG4gICAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBtYXJrOiBQcm9zZU1pcnJvck1hcmtcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiBET01PdXRwdXRTcGVjKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBBdHRyaWJ1dGVzXG4gICAgICovXG4gICAgYWRkQXR0cmlidXRlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRBdHRyaWJ1dGVzJ11cbiAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgIH0pID0+IEF0dHJpYnV0ZXMgfCB7fVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNYXJrPE9wdGlvbnMgPSBhbnksIFN0b3JhZ2UgPSBhbnk+IHtcbiAgdHlwZSA9ICdtYXJrJ1xuXG4gIG5hbWUgPSAnbWFyaydcblxuICBwYXJlbnQ6IE1hcmsgfCBudWxsID0gbnVsbFxuXG4gIGNoaWxkOiBNYXJrIHwgbnVsbCA9IG51bGxcblxuICBvcHRpb25zOiBPcHRpb25zXG5cbiAgc3RvcmFnZTogU3RvcmFnZVxuXG4gIGNvbmZpZzogTWFya0NvbmZpZyA9IHtcbiAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxuICB9XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBQYXJ0aWFsPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+ID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgLi4uY29uZmlnLFxuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uZmlnLm5hbWVcblxuICAgIGlmIChjb25maWcuZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7dGhpcy5uYW1lfVwiLmAsXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGBhZGRPcHRpb25zYCBmYWxsYmFja1xuICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29uZmlnLmRlZmF1bHRPcHRpb25zXG5cbiAgICBpZiAodGhpcy5jb25maWcuYWRkT3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gY2FsbE9yUmV0dXJuKFxuICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZE9wdGlvbnMnXT4odGhpcywgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4odGhpcywgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKSB8fCB7fVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZTxPID0gYW55LCBTID0gYW55Pihjb25maWc6IFBhcnRpYWw8TWFya0NvbmZpZzxPLCBTPj4gPSB7fSkge1xuICAgIHJldHVybiBuZXcgTWFyazxPLCBTPihjb25maWcpXG4gIH1cblxuICBjb25maWd1cmUob3B0aW9uczogUGFydGlhbDxPcHRpb25zPiA9IHt9KSB7XG4gICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXG4gICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcbiAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCgpXG5cbiAgICBleHRlbnNpb24ub3B0aW9ucyA9IG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMgYXMgUmVjb3JkPHN0cmluZywgYW55Piwgb3B0aW9ucykgYXMgT3B0aW9uc1xuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG5cbiAgZXh0ZW5kPEV4dGVuZGVkT3B0aW9ucyA9IE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZSA9IFN0b3JhZ2U+KFxuICAgIGV4dGVuZGVkQ29uZmlnOiBQYXJ0aWFsPE1hcmtDb25maWc8RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+PiA9IHt9LFxuICApIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgTWFyazxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4oZXh0ZW5kZWRDb25maWcpXG5cbiAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpc1xuXG4gICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvblxuXG4gICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZVxuXG4gICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke2V4dGVuc2lvbi5uYW1lfVwiLmAsXG4gICAgICApXG4gICAgfVxuXG4gICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZE9wdGlvbnMnXT4oZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPihleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uXG4gIH1cblxuICBzdGF0aWMgaGFuZGxlRXhpdCh7IGVkaXRvciwgbWFyayB9OiB7IGVkaXRvcjogRWRpdG9yOyBtYXJrOiBNYXJrIH0pIHtcbiAgICBjb25zdCB7IHRyIH0gPSBlZGl0b3Iuc3RhdGVcbiAgICBjb25zdCBjdXJyZW50UG9zID0gZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi4kZnJvbVxuICAgIGNvbnN0IGlzQXRFbmQgPSBjdXJyZW50UG9zLnBvcyA9PT0gY3VycmVudFBvcy5lbmQoKVxuXG4gICAgaWYgKGlzQXRFbmQpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRNYXJrcyA9IGN1cnJlbnRQb3MubWFya3MoKVxuICAgICAgY29uc3QgaXNJbk1hcmsgPSAhIWN1cnJlbnRNYXJrcy5maW5kKG0gPT4gbT8udHlwZS5uYW1lID09PSBtYXJrLm5hbWUpXG5cbiAgICAgIGlmICghaXNJbk1hcmspIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlbW92ZU1hcmsgPSBjdXJyZW50TWFya3MuZmluZChtID0+IG0/LnR5cGUubmFtZSA9PT0gbWFyay5uYW1lKVxuXG4gICAgICBpZiAocmVtb3ZlTWFyaykge1xuICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKHJlbW92ZU1hcmspXG4gICAgICB9XG4gICAgICB0ci5pbnNlcnRUZXh0KCcgJywgY3VycmVudFBvcy5wb3MpXG5cbiAgICAgIGVkaXRvci52aWV3LmRpc3BhdGNoKHRyKVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgRE9NT3V0cHV0U3BlYywgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIE5vZGVTcGVjLCBOb2RlVHlwZSxcbn0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnLi9oZWxwZXJzL2dldEV4dGVuc2lvbkZpZWxkLmpzJ1xuaW1wb3J0IHsgTm9kZUNvbmZpZyB9IGZyb20gJy4vaW5kZXguanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUgfSBmcm9tICcuL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IFBhc3RlUnVsZSB9IGZyb20gJy4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHtcbiAgQW55Q29uZmlnLFxuICBBdHRyaWJ1dGVzLFxuICBFeHRlbnNpb25zLFxuICBHbG9iYWxBdHRyaWJ1dGVzLFxuICBLZXlib2FyZFNob3J0Y3V0Q29tbWFuZCxcbiAgTm9kZVZpZXdSZW5kZXJlcixcbiAgUGFyZW50Q29uZmlnLFxuICBSYXdDb21tYW5kcyxcbn0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcbmltcG9ydCB7IG1lcmdlRGVlcCB9IGZyb20gJy4vdXRpbGl0aWVzL21lcmdlRGVlcC5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgTm9kZUNvbmZpZzxPcHRpb25zID0gYW55LCBTdG9yYWdlID0gYW55PiB7XG4gICAgW2tleTogc3RyaW5nXTogYW55XG5cbiAgICAvKipcbiAgICAgKiBOYW1lXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nXG5cbiAgICAvKipcbiAgICAgKiBQcmlvcml0eVxuICAgICAqL1xuICAgIHByaW9yaXR5PzogbnVtYmVyXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBkZWZhdWx0T3B0aW9ucz86IE9wdGlvbnNcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgT3B0aW9uc1xuICAgICAqL1xuICAgIGFkZE9wdGlvbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBwYXJlbnQ6IEV4Y2x1ZGU8UGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRPcHRpb25zJ10sIHVuZGVmaW5lZD5cbiAgICB9KSA9PiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IFN0b3JhZ2VcbiAgICAgKi9cbiAgICBhZGRTdG9yYWdlPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkU3RvcmFnZSddLCB1bmRlZmluZWQ+XG4gICAgfSkgPT4gU3RvcmFnZVxuXG4gICAgLyoqXG4gICAgICogR2xvYmFsIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBhZGRHbG9iYWxBdHRyaWJ1dGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEdsb2JhbEF0dHJpYnV0ZXMnXVxuICAgIH0pID0+IEdsb2JhbEF0dHJpYnV0ZXMgfCB7fVxuXG4gICAgLyoqXG4gICAgICogUmF3XG4gICAgICovXG4gICAgYWRkQ29tbWFuZHM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRDb21tYW5kcyddXG4gICAgfSkgPT4gUGFydGlhbDxSYXdDb21tYW5kcz5cblxuICAgIC8qKlxuICAgICAqIEtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAqL1xuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkS2V5Ym9hcmRTaG9ydGN1dHMnXVxuICAgIH0pID0+IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IEtleWJvYXJkU2hvcnRjdXRDb21tYW5kXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5wdXQgcnVsZXNcbiAgICAgKi9cbiAgICBhZGRJbnB1dFJ1bGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkSW5wdXRSdWxlcyddXG4gICAgfSkgPT4gSW5wdXRSdWxlW11cblxuICAgIC8qKlxuICAgICAqIFBhc3RlIHJ1bGVzXG4gICAgICovXG4gICAgYWRkUGFzdGVSdWxlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFBhc3RlUnVsZXMnXVxuICAgIH0pID0+IFBhc3RlUnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBQcm9zZU1pcnJvciBwbHVnaW5zXG4gICAgICovXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkUHJvc2VNaXJyb3JQbHVnaW5zJ11cbiAgICB9KSA9PiBQbHVnaW5bXVxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5zaW9uc1xuICAgICAqL1xuICAgIGFkZEV4dGVuc2lvbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkRXh0ZW5zaW9ucyddXG4gICAgfSkgPT4gRXh0ZW5zaW9uc1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIE5vZGUgU2NoZW1hXG4gICAgICovXG4gICAgZXh0ZW5kTm9kZVNjaGVtYT86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXh0ZW5kTm9kZVNjaGVtYSddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE5vZGUsXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIE1hcmsgU2NoZW1hXG4gICAgICovXG4gICAgZXh0ZW5kTWFya1NjaGVtYT86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXh0ZW5kTWFya1NjaGVtYSddXG4gICAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4dGVuc2lvbjogTm9kZSxcbiAgICAgICAgKSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIG5vdCByZWFkeSB5ZXQuXG4gICAgICovXG4gICAgb25CZWZvcmVDcmVhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25CZWZvcmVDcmVhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIHJlYWR5LlxuICAgICAqL1xuICAgIG9uQ3JlYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQ3JlYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRlbnQgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25VcGRhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25VcGRhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uU2VsZWN0aW9uVXBkYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uU2VsZWN0aW9uVXBkYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBzdGF0ZSBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblRyYW5zYWN0aW9uPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uVHJhbnNhY3Rpb24nXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBmb2N1c2VkLlxuICAgICAqL1xuICAgIG9uRm9jdXM/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25Gb2N1cyddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZXZlbnQ6IEZvY3VzRXZlbnRcbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXNu4oCZdCBmb2N1c2VkIGFueW1vcmUuXG4gICAgICovXG4gICAgb25CbHVyPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQmx1ciddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZXZlbnQ6IEZvY3VzRXZlbnRcbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIG9uRGVzdHJveT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkRlc3Ryb3knXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBOb2RlIFZpZXdcbiAgICAgKi9cbiAgICBhZGROb2RlVmlldz86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGROb2RlVmlldyddXG4gICAgICAgIH0pID0+IE5vZGVWaWV3UmVuZGVyZXIpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRvcE5vZGVcbiAgICAgKi9cbiAgICB0b3BOb2RlPzogYm9vbGVhblxuXG4gICAgLyoqXG4gICAgICogQ29udGVudFxuICAgICAqL1xuICAgIGNvbnRlbnQ/OlxuICAgICAgfCBOb2RlU3BlY1snY29udGVudCddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2NvbnRlbnQnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snY29udGVudCddKVxuXG4gICAgLyoqXG4gICAgICogTWFya3NcbiAgICAgKi9cbiAgICBtYXJrcz86XG4gICAgICB8IE5vZGVTcGVjWydtYXJrcyddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ21hcmtzJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ21hcmtzJ10pXG5cbiAgICAvKipcbiAgICAgKiBHcm91cFxuICAgICAqL1xuICAgIGdyb3VwPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2dyb3VwJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZ3JvdXAnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snZ3JvdXAnXSlcblxuICAgIC8qKlxuICAgICAqIElubGluZVxuICAgICAqL1xuICAgIGlubGluZT86XG4gICAgICB8IE5vZGVTcGVjWydpbmxpbmUnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydpbmxpbmUnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snaW5saW5lJ10pXG5cbiAgICAvKipcbiAgICAgKiBBdG9tXG4gICAgICovXG4gICAgYXRvbT86XG4gICAgICB8IE5vZGVTcGVjWydhdG9tJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYXRvbSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydhdG9tJ10pXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RhYmxlXG4gICAgICovXG4gICAgc2VsZWN0YWJsZT86XG4gICAgICB8IE5vZGVTcGVjWydzZWxlY3RhYmxlJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnc2VsZWN0YWJsZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydzZWxlY3RhYmxlJ10pXG5cbiAgICAvKipcbiAgICAgKiBEcmFnZ2FibGVcbiAgICAgKi9cbiAgICBkcmFnZ2FibGU/OlxuICAgICAgfCBOb2RlU3BlY1snZHJhZ2dhYmxlJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZHJhZ2dhYmxlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2RyYWdnYWJsZSddKVxuXG4gICAgLyoqXG4gICAgICogQ29kZVxuICAgICAqL1xuICAgIGNvZGU/OlxuICAgICAgfCBOb2RlU3BlY1snY29kZSddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2NvZGUnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snY29kZSddKVxuXG4gICAgLyoqXG4gICAgICogV2hpdGVzcGFjZVxuICAgICAqL1xuICAgIHdoaXRlc3BhY2U/OlxuICAgICAgfCBOb2RlU3BlY1snd2hpdGVzcGFjZSddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3doaXRlc3BhY2UnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snd2hpdGVzcGFjZSddKVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5pbmdcbiAgICAgKi9cbiAgICBkZWZpbmluZz86XG4gICAgICB8IE5vZGVTcGVjWydkZWZpbmluZyddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2RlZmluaW5nJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2RlZmluaW5nJ10pXG5cbiAgICAvKipcbiAgICAgKiBJc29sYXRpbmdcbiAgICAgKi9cbiAgICBpc29sYXRpbmc/OlxuICAgICAgfCBOb2RlU3BlY1snaXNvbGF0aW5nJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnaXNvbGF0aW5nJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2lzb2xhdGluZyddKVxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgSFRNTFxuICAgICAqL1xuICAgIHBhcnNlSFRNTD86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydwYXJzZUhUTUwnXVxuICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgfSkgPT4gTm9kZVNwZWNbJ3BhcnNlRE9NJ11cblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBIVE1MXG4gICAgICovXG4gICAgcmVuZGVySFRNTD86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsncmVuZGVySFRNTCddXG4gICAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBub2RlOiBQcm9zZU1pcnJvck5vZGVcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiBET01PdXRwdXRTcGVjKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgVGV4dFxuICAgICAqL1xuICAgIHJlbmRlclRleHQ/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3JlbmRlclRleHQnXVxuICAgICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgbm9kZTogUHJvc2VNaXJyb3JOb2RlXG4gICAgICAgICAgICBwb3M6IG51bWJlclxuICAgICAgICAgICAgcGFyZW50OiBQcm9zZU1pcnJvck5vZGVcbiAgICAgICAgICAgIGluZGV4OiBudW1iZXJcbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHN0cmluZylcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogQWRkIEF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBhZGRBdHRyaWJ1dGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEF0dHJpYnV0ZXMnXVxuICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgfSkgPT4gQXR0cmlidXRlcyB8IHt9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5vZGU8T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICB0eXBlID0gJ25vZGUnXG5cbiAgbmFtZSA9ICdub2RlJ1xuXG4gIHBhcmVudDogTm9kZSB8IG51bGwgPSBudWxsXG5cbiAgY2hpbGQ6IE5vZGUgfCBudWxsID0gbnVsbFxuXG4gIG9wdGlvbnM6IE9wdGlvbnNcblxuICBzdG9yYWdlOiBTdG9yYWdlXG5cbiAgY29uZmlnOiBOb2RlQ29uZmlnID0ge1xuICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICBkZWZhdWx0T3B0aW9uczoge30sXG4gIH1cblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFBhcnRpYWw8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj4gPSB7fSkge1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAuLi5jb25maWcsXG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25maWcubmFtZVxuXG4gICAgaWYgKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5jb25maWcuZGVmYXVsdE9wdGlvbnNcblxuICAgIGlmICh0aGlzLmNvbmZpZy5hZGRPcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPih0aGlzLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPih0aGlzLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApIHx8IHt9XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlPE8gPSBhbnksIFMgPSBhbnk+KGNvbmZpZzogUGFydGlhbDxOb2RlQ29uZmlnPE8sIFM+PiA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlPE8sIFM+KGNvbmZpZylcbiAgfVxuXG4gIGNvbmZpZ3VyZShvcHRpb25zOiBQYXJ0aWFsPE9wdGlvbnM+ID0ge30pIHtcbiAgICAvLyByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBleHRlbnNpb25cbiAgICAvLyB3aXRoIGRpZmZlcmVudCBjYWxscyBvZiBgY29uZmlndXJlYFxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5kKClcblxuICAgIGV4dGVuc2lvbi5vcHRpb25zID0gbWVyZ2VEZWVwKHRoaXMub3B0aW9ucyBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBvcHRpb25zKSBhcyBPcHRpb25zXG5cbiAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPihleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uXG4gIH1cblxuICBleHRlbmQ8RXh0ZW5kZWRPcHRpb25zID0gT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlID0gU3RvcmFnZT4oXG4gICAgZXh0ZW5kZWRDb25maWc6IFBhcnRpYWw8Tm9kZUNvbmZpZzxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4+ID0ge30sXG4gICkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBOb2RlPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPihleHRlbmRlZENvbmZpZylcblxuICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzXG5cbiAgICB0aGlzLmNoaWxkID0gZXh0ZW5zaW9uXG5cbiAgICBleHRlbnNpb24ubmFtZSA9IGV4dGVuZGVkQ29uZmlnLm5hbWUgPyBleHRlbmRlZENvbmZpZy5uYW1lIDogZXh0ZW5zaW9uLnBhcmVudC5uYW1lXG5cbiAgICBpZiAoZXh0ZW5kZWRDb25maWcuZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7ZXh0ZW5zaW9uLm5hbWV9XCIuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICBleHRlbnNpb24ub3B0aW9ucyA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPihleHRlbnNpb24sICdhZGRPcHRpb25zJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIHJldHVybiBleHRlbnNpb25cbiAgfVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc0FuZHJvaWQoKTogYm9vbGVhbiB7XG4gIHJldHVybiBuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdBbmRyb2lkJyB8fCAvYW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IE5vZGVWaWV3IGFzIFByb3NlTWlycm9yTm9kZVZpZXcgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5cbmltcG9ydCB7IEVkaXRvciBhcyBDb3JlRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi9Ob2RlLmpzJ1xuaW1wb3J0IHsgRGVjb3JhdGlvbldpdGhUeXBlLCBOb2RlVmlld1JlbmRlcmVyT3B0aW9ucywgTm9kZVZpZXdSZW5kZXJlclByb3BzIH0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGlzQW5kcm9pZCB9IGZyb20gJy4vdXRpbGl0aWVzL2lzQW5kcm9pZC5qcydcbmltcG9ydCB7IGlzaU9TIH0gZnJvbSAnLi91dGlsaXRpZXMvaXNpT1MuanMnXG5cbmV4cG9ydCBjbGFzcyBOb2RlVmlldzxcbiAgQ29tcG9uZW50LFxuICBOb2RlRWRpdG9yIGV4dGVuZHMgQ29yZUVkaXRvciA9IENvcmVFZGl0b3IsXG4gIE9wdGlvbnMgZXh0ZW5kcyBOb2RlVmlld1JlbmRlcmVyT3B0aW9ucyA9IE5vZGVWaWV3UmVuZGVyZXJPcHRpb25zLFxuPiBpbXBsZW1lbnRzIFByb3NlTWlycm9yTm9kZVZpZXcge1xuICBjb21wb25lbnQ6IENvbXBvbmVudFxuXG4gIGVkaXRvcjogTm9kZUVkaXRvclxuXG4gIG9wdGlvbnM6IE9wdGlvbnNcblxuICBleHRlbnNpb246IE5vZGVcblxuICBub2RlOiBQcm9zZU1pcnJvck5vZGVcblxuICBkZWNvcmF0aW9uczogRGVjb3JhdGlvbldpdGhUeXBlW11cblxuICBnZXRQb3M6IGFueVxuXG4gIGlzRHJhZ2dpbmcgPSBmYWxzZVxuXG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudDogQ29tcG9uZW50LCBwcm9wczogTm9kZVZpZXdSZW5kZXJlclByb3BzLCBvcHRpb25zPzogUGFydGlhbDxPcHRpb25zPikge1xuICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50XG4gICAgdGhpcy5lZGl0b3IgPSBwcm9wcy5lZGl0b3IgYXMgTm9kZUVkaXRvclxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHN0b3BFdmVudDogbnVsbCxcbiAgICAgIGlnbm9yZU11dGF0aW9uOiBudWxsLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9IGFzIE9wdGlvbnNcbiAgICB0aGlzLmV4dGVuc2lvbiA9IHByb3BzLmV4dGVuc2lvblxuICAgIHRoaXMubm9kZSA9IHByb3BzLm5vZGVcbiAgICB0aGlzLmRlY29yYXRpb25zID0gcHJvcHMuZGVjb3JhdGlvbnMgYXMgRGVjb3JhdGlvbldpdGhUeXBlW11cbiAgICB0aGlzLmdldFBvcyA9IHByb3BzLmdldFBvc1xuICAgIHRoaXMubW91bnQoKVxuICB9XG5cbiAgbW91bnQoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgcmV0dXJuXG4gIH1cblxuICBnZXQgZG9tKCk6IEhUTUxFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3Iudmlldy5kb20gYXMgSFRNTEVsZW1lbnRcbiAgfVxuXG4gIGdldCBjb250ZW50RE9NKCk6IEhUTUxFbGVtZW50IHwgbnVsbCB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9uRHJhZ1N0YXJ0KGV2ZW50OiBEcmFnRXZlbnQpIHtcbiAgICBjb25zdCB7IHZpZXcgfSA9IHRoaXMuZWRpdG9yXG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG5cbiAgICAvLyBnZXQgdGhlIGRyYWcgaGFuZGxlIGVsZW1lbnRcbiAgICAvLyBgY2xvc2VzdGAgaXMgbm90IGF2YWlsYWJsZSBmb3IgdGV4dCBub2RlcyBzbyB3ZSBtYXkgaGF2ZSB0byB1c2UgaXRzIHBhcmVudFxuICAgIGNvbnN0IGRyYWdIYW5kbGUgPSB0YXJnZXQubm9kZVR5cGUgPT09IDNcbiAgICAgID8gdGFyZ2V0LnBhcmVudEVsZW1lbnQ/LmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpXG4gICAgICA6IHRhcmdldC5jbG9zZXN0KCdbZGF0YS1kcmFnLWhhbmRsZV0nKVxuXG4gICAgaWYgKCF0aGlzLmRvbSB8fCB0aGlzLmNvbnRlbnRET00/LmNvbnRhaW5zKHRhcmdldCkgfHwgIWRyYWdIYW5kbGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCB4ID0gMFxuICAgIGxldCB5ID0gMFxuXG4gICAgLy8gY2FsY3VsYXRlIG9mZnNldCBmb3IgZHJhZyBlbGVtZW50IGlmIHdlIHVzZSBhIGRpZmZlcmVudCBkcmFnIGhhbmRsZSBlbGVtZW50XG4gICAgaWYgKHRoaXMuZG9tICE9PSBkcmFnSGFuZGxlKSB7XG4gICAgICBjb25zdCBkb21Cb3ggPSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgY29uc3QgaGFuZGxlQm94ID0gZHJhZ0hhbmRsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgICAvLyBJbiBSZWFjdCwgd2UgaGF2ZSB0byBnbyB0aHJvdWdoIG5hdGl2ZUV2ZW50IHRvIHJlYWNoIG9mZnNldFgvb2Zmc2V0WS5cbiAgICAgIGNvbnN0IG9mZnNldFggPSBldmVudC5vZmZzZXRYID8/IChldmVudCBhcyBhbnkpLm5hdGl2ZUV2ZW50Py5vZmZzZXRYXG4gICAgICBjb25zdCBvZmZzZXRZID0gZXZlbnQub2Zmc2V0WSA/PyAoZXZlbnQgYXMgYW55KS5uYXRpdmVFdmVudD8ub2Zmc2V0WVxuXG4gICAgICB4ID0gaGFuZGxlQm94LnggLSBkb21Cb3gueCArIG9mZnNldFhcbiAgICAgIHkgPSBoYW5kbGVCb3gueSAtIGRvbUJveC55ICsgb2Zmc2V0WVxuICAgIH1cblxuICAgIGV2ZW50LmRhdGFUcmFuc2Zlcj8uc2V0RHJhZ0ltYWdlKHRoaXMuZG9tLCB4LCB5KVxuXG4gICAgLy8gd2UgbmVlZCB0byB0ZWxsIFByb3NlTWlycm9yIHRoYXQgd2Ugd2FudCB0byBtb3ZlIHRoZSB3aG9sZSBub2RlXG4gICAgLy8gc28gd2UgY3JlYXRlIGEgTm9kZVNlbGVjdGlvblxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCB0aGlzLmdldFBvcygpKVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuXG4gICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbilcbiAgfVxuXG4gIHN0b3BFdmVudChldmVudDogRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zdG9wRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc3RvcEV2ZW50KHsgZXZlbnQgfSlcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnRcbiAgICBjb25zdCBpc0luRWxlbWVudCA9IHRoaXMuZG9tLmNvbnRhaW5zKHRhcmdldCkgJiYgIXRoaXMuY29udGVudERPTT8uY29udGFpbnModGFyZ2V0KVxuXG4gICAgLy8gYW55IGV2ZW50IGZyb20gY2hpbGQgbm9kZXMgc2hvdWxkIGJlIGhhbmRsZWQgYnkgUHJvc2VNaXJyb3JcbiAgICBpZiAoIWlzSW5FbGVtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBpc0RyYWdFdmVudCA9IGV2ZW50LnR5cGUuc3RhcnRzV2l0aCgnZHJhZycpXG4gICAgY29uc3QgaXNEcm9wRXZlbnQgPSBldmVudC50eXBlID09PSAnZHJvcCdcbiAgICBjb25zdCBpc0lucHV0ID0gWydJTlBVVCcsICdCVVRUT04nLCAnU0VMRUNUJywgJ1RFWFRBUkVBJ10uaW5jbHVkZXModGFyZ2V0LnRhZ05hbWUpIHx8IHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZVxuXG4gICAgLy8gYW55IGlucHV0IGV2ZW50IHdpdGhpbiBub2RlIHZpZXdzIHNob3VsZCBiZSBpZ25vcmVkIGJ5IFByb3NlTWlycm9yXG4gICAgaWYgKGlzSW5wdXQgJiYgIWlzRHJvcEV2ZW50ICYmICFpc0RyYWdFdmVudCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdCB7IGlzRWRpdGFibGUgfSA9IHRoaXMuZWRpdG9yXG4gICAgY29uc3QgeyBpc0RyYWdnaW5nIH0gPSB0aGlzXG4gICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlXG4gICAgY29uc3QgaXNTZWxlY3RhYmxlID0gTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUodGhpcy5ub2RlKVxuICAgIGNvbnN0IGlzQ29weUV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2NvcHknXG4gICAgY29uc3QgaXNQYXN0ZUV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ3Bhc3RlJ1xuICAgIGNvbnN0IGlzQ3V0RXZlbnQgPSBldmVudC50eXBlID09PSAnY3V0J1xuICAgIGNvbnN0IGlzQ2xpY2tFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nXG5cbiAgICAvLyBQcm9zZU1pcnJvciB0cmllcyB0byBkcmFnIHNlbGVjdGFibGUgbm9kZXNcbiAgICAvLyBldmVuIGlmIGBkcmFnZ2FibGVgIGlzIHNldCB0byBgZmFsc2VgXG4gICAgLy8gdGhpcyBmaXggcHJldmVudHMgdGhhdFxuICAgIGlmICghaXNEcmFnZ2FibGUgJiYgaXNTZWxlY3RhYmxlICYmIGlzRHJhZ0V2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgfVxuXG4gICAgaWYgKGlzRHJhZ2dhYmxlICYmIGlzRHJhZ0V2ZW50ICYmICFpc0RyYWdnaW5nKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyB3ZSBoYXZlIHRvIHN0b3JlIHRoYXQgZHJhZ2dpbmcgc3RhcnRlZFxuICAgIGlmIChpc0RyYWdnYWJsZSAmJiBpc0VkaXRhYmxlICYmICFpc0RyYWdnaW5nICYmIGlzQ2xpY2tFdmVudCkge1xuICAgICAgY29uc3QgZHJhZ0hhbmRsZSA9IHRhcmdldC5jbG9zZXN0KCdbZGF0YS1kcmFnLWhhbmRsZV0nKVxuICAgICAgY29uc3QgaXNWYWxpZERyYWdIYW5kbGUgPSBkcmFnSGFuZGxlICYmICh0aGlzLmRvbSA9PT0gZHJhZ0hhbmRsZSB8fCB0aGlzLmRvbS5jb250YWlucyhkcmFnSGFuZGxlKSlcblxuICAgICAgaWYgKGlzVmFsaWREcmFnSGFuZGxlKSB7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWVcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICdkcmFnZW5kJyxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBvbmNlOiB0cnVlIH0sXG4gICAgICAgIClcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICdkcm9wJyxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBvbmNlOiB0cnVlIH0sXG4gICAgICAgIClcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICdtb3VzZXVwJyxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBvbmNlOiB0cnVlIH0sXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aGVzZSBldmVudHMgYXJlIGhhbmRsZWQgYnkgcHJvc2VtaXJyb3JcbiAgICBpZiAoXG4gICAgICBpc0RyYWdnaW5nXG4gICAgICB8fCBpc0Ryb3BFdmVudFxuICAgICAgfHwgaXNDb3B5RXZlbnRcbiAgICAgIHx8IGlzUGFzdGVFdmVudFxuICAgICAgfHwgaXNDdXRFdmVudFxuICAgICAgfHwgKGlzQ2xpY2tFdmVudCAmJiBpc1NlbGVjdGFibGUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWdub3JlTXV0YXRpb24obXV0YXRpb246IE11dGF0aW9uUmVjb3JkIHwgeyB0eXBlOiAnc2VsZWN0aW9uJzsgdGFyZ2V0OiBFbGVtZW50IH0pIHtcbiAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaWdub3JlTXV0YXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaWdub3JlTXV0YXRpb24oeyBtdXRhdGlvbiB9KVxuICAgIH1cblxuICAgIC8vIGEgbGVhZi9hdG9tIG5vZGUgaXMgbGlrZSBhIGJsYWNrIGJveCBmb3IgUHJvc2VNaXJyb3JcbiAgICAvLyBhbmQgc2hvdWxkIGJlIGZ1bGx5IGhhbmRsZWQgYnkgdGhlIG5vZGUgdmlld1xuICAgIGlmICh0aGlzLm5vZGUuaXNMZWFmIHx8IHRoaXMubm9kZS5pc0F0b20pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gUHJvc2VNaXJyb3Igc2hvdWxkIGhhbmRsZSBhbnkgc2VsZWN0aW9uc1xuICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnc2VsZWN0aW9uJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gdHJ5IHRvIHByZXZlbnQgYSBidWcgb24gaU9TIGFuZCBBbmRyb2lkIHRoYXQgd2lsbCBicmVhayBub2RlIHZpZXdzIG9uIGVudGVyXG4gICAgLy8gdGhpcyBpcyBiZWNhdXNlIFByb3NlTWlycm9yIGNhbuKAmXQgcHJldmVudERpc3BhdGNoIG9uIGVudGVyXG4gICAgLy8gdGhpcyB3aWxsIGxlYWQgdG8gYSByZS1yZW5kZXIgb2YgdGhlIG5vZGUgdmlldyBvbiBlbnRlclxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8xMjE0XG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzI1MzRcbiAgICBpZiAoXG4gICAgICB0aGlzLmRvbS5jb250YWlucyhtdXRhdGlvbi50YXJnZXQpXG4gICAgICAmJiBtdXRhdGlvbi50eXBlID09PSAnY2hpbGRMaXN0J1xuICAgICAgJiYgKGlzaU9TKCkgfHwgaXNBbmRyb2lkKCkpXG4gICAgICAmJiB0aGlzLmVkaXRvci5pc0ZvY3VzZWRcbiAgICApIHtcbiAgICAgIGNvbnN0IGNoYW5nZWROb2RlcyA9IFtcbiAgICAgICAgLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5hZGRlZE5vZGVzKSxcbiAgICAgICAgLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5yZW1vdmVkTm9kZXMpLFxuICAgICAgXSBhcyBIVE1MRWxlbWVudFtdXG5cbiAgICAgIC8vIHdl4oCZbGwgY2hlY2sgaWYgZXZlcnkgY2hhbmdlZCBub2RlIGlzIGNvbnRlbnRFZGl0YWJsZVxuICAgICAgLy8gdG8gbWFrZSBzdXJlIGl04oCZcyBwcm9iYWJseSBtdXRhdGVkIGJ5IFByb3NlTWlycm9yXG4gICAgICBpZiAoY2hhbmdlZE5vZGVzLmV2ZXJ5KG5vZGUgPT4gbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gd2Ugd2lsbCBhbGxvdyBtdXRhdGlvbiBjb250ZW50RE9NIHdpdGggYXR0cmlidXRlc1xuICAgIC8vIHNvIHdlIGNhbiBmb3IgZXhhbXBsZSBhZGRpbmcgY2xhc3NlcyB3aXRoaW4gb3VyIG5vZGUgdmlld1xuICAgIGlmICh0aGlzLmNvbnRlbnRET00gPT09IG11dGF0aW9uLnRhcmdldCAmJiBtdXRhdGlvbi50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gUHJvc2VNaXJyb3Igc2hvdWxkIGhhbmRsZSBhbnkgY2hhbmdlcyB3aXRoaW4gY29udGVudERPTVxuICAgIGlmICh0aGlzLmNvbnRlbnRET00uY29udGFpbnMobXV0YXRpb24udGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlczoge30pIHtcbiAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKClcblxuICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHVuZGVmaW5lZCwge1xuICAgICAgICAuLi50aGlzLm5vZGUuYXR0cnMsXG4gICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG4gIH1cblxuICBkZWxldGVOb2RlKCk6IHZvaWQge1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLmdldFBvcygpXG4gICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5ub2RlLm5vZGVTaXplXG5cbiAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5kZWxldGVSYW5nZSh7IGZyb20sIHRvIH0pXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE1hcmtzQmV0d2VlbiB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya3NCZXR3ZWVuLmpzJ1xuaW1wb3J0IHsgUGFzdGVSdWxlLCBQYXN0ZVJ1bGVGaW5kZXIgfSBmcm9tICcuLi9QYXN0ZVJ1bGUuanMnXG5pbXBvcnQgeyBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4uL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5cbi8qKlxuICogQnVpbGQgYW4gcGFzdGUgcnVsZSB0aGF0IGFkZHMgYSBtYXJrIHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgcGFzdGVkIGludG8gaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrUGFzdGVSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXJcbiAgdHlwZTogTWFya1R5cGVcbiAgZ2V0QXR0cmlidXRlcz86XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgfCAoKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXksIGV2ZW50OiBDbGlwYm9hcmRFdmVudCkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICB8IGZhbHNlXG4gICAgfCBudWxsXG59KSB7XG4gIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoe1xuICAgICAgc3RhdGUsIHJhbmdlLCBtYXRjaCwgcGFzdGVFdmVudCxcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoLCBwYXN0ZUV2ZW50KVxuXG4gICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZVxuICAgICAgY29uc3QgY2FwdHVyZUdyb3VwID0gbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV1cbiAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IG1hdGNoWzBdXG4gICAgICBsZXQgbWFya0VuZCA9IHJhbmdlLnRvXG5cbiAgICAgIGlmIChjYXB0dXJlR3JvdXApIHtcbiAgICAgICAgY29uc3Qgc3RhcnRTcGFjZXMgPSBmdWxsTWF0Y2guc2VhcmNoKC9cXFMvKVxuICAgICAgICBjb25zdCB0ZXh0U3RhcnQgPSByYW5nZS5mcm9tICsgZnVsbE1hdGNoLmluZGV4T2YoY2FwdHVyZUdyb3VwKVxuICAgICAgICBjb25zdCB0ZXh0RW5kID0gdGV4dFN0YXJ0ICsgY2FwdHVyZUdyb3VwLmxlbmd0aFxuXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVkTWFya3MgPSBnZXRNYXJrc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHN0YXRlLmRvYylcbiAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgZXhjbHVkZWQgPSBpdGVtLm1hcmsudHlwZS5leGNsdWRlZCBhcyBNYXJrVHlwZVtdXG5cbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlZC5maW5kKHR5cGUgPT4gdHlwZSA9PT0gY29uZmlnLnR5cGUgJiYgdHlwZSAhPT0gaXRlbS5tYXJrLnR5cGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS50byA+IHRleHRTdGFydClcblxuICAgICAgICBpZiAoZXhjbHVkZWRNYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRFbmQgPCByYW5nZS50bykge1xuICAgICAgICAgIHRyLmRlbGV0ZSh0ZXh0RW5kLCByYW5nZS50bylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0U3RhcnQgPiByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgdGV4dFN0YXJ0KVxuICAgICAgICB9XG5cbiAgICAgICAgbWFya0VuZCA9IHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcyArIGNhcHR1cmVHcm91cC5sZW5ndGhcblxuICAgICAgICB0ci5hZGRNYXJrKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgbWFya0VuZCwgY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMgfHwge30pKVxuXG4gICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsoY29uZmlnLnR5cGUpXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiIsICIvLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82OTY5NDg2XG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlRm9yUmVnRXgoc3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1stL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZTogYW55KTogdmFsdWUgaXMgc3RyaW5nIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZydcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IFBhc3RlUnVsZSwgUGFzdGVSdWxlRmluZGVyIH0gZnJvbSAnLi4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvaW5kZXguanMnXG5cbi8qKlxuICogQnVpbGQgYW4gcGFzdGUgcnVsZSB0aGF0IGFkZHMgYSBub2RlIHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgcGFzdGVkIGludG8gaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub2RlUGFzdGVSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXJcbiAgdHlwZTogTm9kZVR5cGVcbiAgZ2V0QXR0cmlidXRlcz86XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgfCAoKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXksIGV2ZW50OiBDbGlwYm9hcmRFdmVudCkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICB8IGZhbHNlXG4gICAgfCBudWxsXG59KSB7XG4gIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyKHtcbiAgICAgIG1hdGNoLCBjaGFpbiwgcmFuZ2UsIHBhc3RlRXZlbnQsXG4gICAgfSkge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCwgcGFzdGVFdmVudClcblxuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoLmlucHV0KSB7XG4gICAgICAgIGNoYWluKCkuZGVsZXRlUmFuZ2UocmFuZ2UpLmluc2VydENvbnRlbnRBdChyYW5nZS5mcm9tLCB7XG4gICAgICAgICAgdHlwZTogY29uZmlnLnR5cGUubmFtZSxcbiAgICAgICAgICBhdHRyczogYXR0cmlidXRlcyxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IFBhc3RlUnVsZSwgUGFzdGVSdWxlRmluZGVyIH0gZnJvbSAnLi4vUGFzdGVSdWxlLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCByZXBsYWNlcyB0ZXh0IHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgcGFzdGVkIGludG8gaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0UGFzdGVSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXIsXG4gIHJlcGxhY2U6IHN0cmluZyxcbn0pIHtcbiAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgbGV0IGluc2VydCA9IGNvbmZpZy5yZXBsYWNlXG4gICAgICBsZXQgc3RhcnQgPSByYW5nZS5mcm9tXG4gICAgICBjb25zdCBlbmQgPSByYW5nZS50b1xuXG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pXG5cbiAgICAgICAgaW5zZXJ0ICs9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCArIG1hdGNoWzFdLmxlbmd0aClcbiAgICAgICAgc3RhcnQgKz0gb2Zmc2V0XG5cbiAgICAgICAgY29uc3QgY3V0T2ZmID0gc3RhcnQgLSBlbmRcblxuICAgICAgICBpZiAoY3V0T2ZmID4gMCkge1xuICAgICAgICAgIGluc2VydCA9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCAtIGN1dE9mZiwgb2Zmc2V0KSArIGluc2VydFxuICAgICAgICAgIHN0YXJ0ID0gZW5kXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhdGUudHIuaW5zZXJ0VGV4dChpbnNlcnQsIHN0YXJ0LCBlbmQpXG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2tlclJlc3VsdCB7XG4gIHBvc2l0aW9uOiBudW1iZXJcbiAgZGVsZXRlZDogYm9vbGVhblxufVxuXG5leHBvcnQgY2xhc3MgVHJhY2tlciB7XG4gIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblxuXG4gIGN1cnJlbnRTdGVwOiBudW1iZXJcblxuICBjb25zdHJ1Y3Rvcih0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24pIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25cbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gdGhpcy50cmFuc2FjdGlvbi5zdGVwcy5sZW5ndGhcbiAgfVxuXG4gIG1hcChwb3NpdGlvbjogbnVtYmVyKTogVHJhY2tlclJlc3VsdCB7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZVxuXG4gICAgY29uc3QgbWFwcGVkUG9zaXRpb24gPSB0aGlzLnRyYW5zYWN0aW9uLnN0ZXBzXG4gICAgICAuc2xpY2UodGhpcy5jdXJyZW50U3RlcClcbiAgICAgIC5yZWR1Y2UoKG5ld1Bvc2l0aW9uLCBzdGVwKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcFJlc3VsdCA9IHN0ZXAuZ2V0TWFwKCkubWFwUmVzdWx0KG5ld1Bvc2l0aW9uKVxuXG4gICAgICAgIGlmIChtYXBSZXN1bHQuZGVsZXRlZCkge1xuICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFwUmVzdWx0LnBvc1xuICAgICAgfSwgcG9zaXRpb24pXG5cbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IG1hcHBlZFBvc2l0aW9uLFxuICAgICAgZGVsZXRlZCxcbiAgICB9XG4gIH1cbn1cbiIsICJleHBvcnQgdmFyIHRvcCA9ICd0b3AnO1xuZXhwb3J0IHZhciBib3R0b20gPSAnYm90dG9tJztcbmV4cG9ydCB2YXIgcmlnaHQgPSAncmlnaHQnO1xuZXhwb3J0IHZhciBsZWZ0ID0gJ2xlZnQnO1xuZXhwb3J0IHZhciBhdXRvID0gJ2F1dG8nO1xuZXhwb3J0IHZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuZXhwb3J0IHZhciBzdGFydCA9ICdzdGFydCc7XG5leHBvcnQgdmFyIGVuZCA9ICdlbmQnO1xuZXhwb3J0IHZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbmV4cG9ydCB2YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xuZXhwb3J0IHZhciBwb3BwZXIgPSAncG9wcGVyJztcbmV4cG9ydCB2YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG5leHBvcnQgdmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbmV4cG9ydCB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuXG5leHBvcnQgdmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG5leHBvcnQgdmFyIHJlYWQgPSAncmVhZCc7XG5leHBvcnQgdmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuXG5leHBvcnQgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG5leHBvcnQgdmFyIG1haW4gPSAnbWFpbic7XG5leHBvcnQgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5cbmV4cG9ydCB2YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xuZXhwb3J0IHZhciB3cml0ZSA9ICd3cml0ZSc7XG5leHBvcnQgdmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XG5leHBvcnQgdmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdOyIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlTmFtZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsICJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuZXhwb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfTsiLCAiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjsgLy8gVGhpcyBtb2RpZmllciB0YWtlcyB0aGUgc3R5bGVzIHByZXBhcmVkIGJ5IHRoZSBgY29tcHV0ZVN0eWxlc2AgbW9kaWZpZXJcbi8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcblxuZnVuY3Rpb24gYXBwbHlTdHlsZXMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuXG5cbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcbiAgdmFyIGluaXRpYWxTdHlsZXMgPSB7XG4gICAgcG9wcGVyOiB7XG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGxlZnQ6ICcwJyxcbiAgICAgIHRvcDogJzAnLFxuICAgICAgbWFyZ2luOiAnMCdcbiAgICB9LFxuICAgIGFycm93OiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fVxuICB9O1xuICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuICBzdGF0ZS5zdHlsZXMgPSBpbml0aWFsU3R5bGVzO1xuXG4gIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICAgIHZhciBzdHlsZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhzdGF0ZS5zdHlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBzdGF0ZS5zdHlsZXNbbmFtZV0gOiBpbml0aWFsU3R5bGVzW25hbWVdKTsgLy8gU2V0IGFsbCB2YWx1ZXMgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIHVuc2V0IHRoZW1cblxuICAgICAgdmFyIHN0eWxlID0gc3R5bGVQcm9wZXJ0aWVzLnJlZHVjZShmdW5jdGlvbiAoc3R5bGUsIHByb3BlcnR5KSB7XG4gICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9LCB7fSk7IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGFwcGx5U3R5bGVzLFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXG59OyIsICJpbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59IiwgImV4cG9ydCB2YXIgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgdmFyIG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IHZhciByb3VuZCA9IE1hdGgucm91bmQ7IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVBU3RyaW5nKCkge1xuICB2YXIgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG5cbiAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5icmFuZHMgJiYgQXJyYXkuaXNBcnJheSh1YURhdGEuYnJhbmRzKSkge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uYnJhbmQgKyBcIi9cIiArIGl0ZW0udmVyc2lvbjtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cblxuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn0iLCAiaW1wb3J0IGdldFVBU3RyaW5nIGZyb20gXCIuLi91dGlscy91c2VyQWdlbnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzTGF5b3V0Vmlld3BvcnQoKSB7XG4gIHJldHVybiAhL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChnZXRVQVN0cmluZygpKTtcbn0iLCAiaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBpc0xheW91dFZpZXdwb3J0IGZyb20gXCIuL2lzTGF5b3V0Vmlld3BvcnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWRTdHJhdGVneSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gMTtcbiAgdmFyIHNjYWxlWSA9IDE7XG5cbiAgaWYgKGluY2x1ZGVTY2FsZSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgc2NhbGVYID0gZWxlbWVudC5vZmZzZXRXaWR0aCA+IDAgPyByb3VuZChjbGllbnRSZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSA6IDE7XG4gICAgc2NhbGVZID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgPiAwID8gcm91bmQoY2xpZW50UmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSA6IDE7XG4gIH1cblxuICB2YXIgX3JlZiA9IGlzRWxlbWVudChlbGVtZW50KSA/IGdldFdpbmRvdyhlbGVtZW50KSA6IHdpbmRvdyxcbiAgICAgIHZpc3VhbFZpZXdwb3J0ID0gX3JlZi52aXN1YWxWaWV3cG9ydDtcblxuICB2YXIgYWRkVmlzdWFsT2Zmc2V0cyA9ICFpc0xheW91dFZpZXdwb3J0KCkgJiYgaXNGaXhlZFN0cmF0ZWd5O1xuICB2YXIgeCA9IChjbGllbnRSZWN0LmxlZnQgKyAoYWRkVmlzdWFsT2Zmc2V0cyAmJiB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQgOiAwKSkgLyBzY2FsZVg7XG4gIHZhciB5ID0gKGNsaWVudFJlY3QudG9wICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3AgOiAwKSkgLyBzY2FsZVk7XG4gIHZhciB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZVg7XG4gIHZhciBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodCAvIHNjYWxlWTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdG9wOiB5LFxuICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxuICAgIGxlZnQ6IHgsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59IiwgImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7IC8vIFJldHVybnMgdGhlIGxheW91dCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC4gTGF5b3V0XG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn0iLCAiaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59IiwgImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59IiwgImltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgcmV0dXJuICgoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufSIsICJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG5cbiAgKTtcbn0iLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGlzVGFibGVFbGVtZW50IGZyb20gXCIuL2lzVGFibGVFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0VUFTdHJpbmcgZnJvbSBcIi4uL3V0aWxzL3VzZXJBZ2VudC5qc1wiO1xuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbn0gLy8gYC5vZmZzZXRQYXJlbnRgIHJlcG9ydHMgYG51bGxgIGZvciBmaXhlZCBlbGVtZW50cywgd2hpbGUgYWJzb2x1dGUgZWxlbWVudHNcbi8vIHJldHVybiB0aGUgY29udGFpbmluZyBibG9ja1xuXG5cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIHZhciBpc0ZpcmVmb3ggPSAvZmlyZWZveC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG4gIHZhciBpc0lFID0gL1RyaWRlbnQvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuXG4gIGlmIChpc0lFICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAvLyBJbiBJRSA5LCAxMCBhbmQgMTEgZml4ZWQgZWxlbWVudHMgY29udGFpbmluZyBibG9jayBpcyBhbHdheXMgZXN0YWJsaXNoZWQgYnkgdGhlIHZpZXdwb3J0XG4gICAgdmFyIGVsZW1lbnRDc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKGVsZW1lbnRDc3MucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgaWYgKGlzU2hhZG93Um9vdChjdXJyZW50Tm9kZSkpIHtcbiAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmhvc3Q7XG4gIH1cblxuICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgWydodG1sJywgJ2JvZHknXS5pbmRleE9mKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkgPCAwKSB7XG4gICAgdmFyIGNzcyA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpOyAvLyBUaGlzIGlzIG5vbi1leGhhdXN0aXZlIGJ1dCBjb3ZlcnMgdGhlIG1vc3QgY29tbW9uIENTUyBwcm9wZXJ0aWVzIHRoYXRcbiAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG5cbiAgICBpZiAoY3NzLnRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8IGNzcy5wZXJzcGVjdGl2ZSAhPT0gJ25vbmUnIHx8IGNzcy5jb250YWluID09PSAncGFpbnQnIHx8IFsndHJhbnNmb3JtJywgJ3BlcnNwZWN0aXZlJ10uaW5kZXhPZihjc3Mud2lsbENoYW5nZSkgIT09IC0xIHx8IGlzRmlyZWZveCAmJiBjc3Mud2lsbENoYW5nZSA9PT0gJ2ZpbHRlcicgfHwgaXNGaXJlZm94ICYmIGNzcy5maWx0ZXIgJiYgY3NzLmZpbHRlciAhPT0gJ25vbmUnKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcblxuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5Jztcbn0iLCAiaW1wb3J0IHsgbWF4IGFzIG1hdGhNYXgsIG1pbiBhcyBtYXRoTWluIH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgcmV0dXJuIG1hdGhNYXgobWluLCBtYXRoTWluKHZhbHVlLCBtYXgpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW5NYXhDbGFtcChtaW4sIHZhbHVlLCBtYXgpIHtcbiAgdmFyIHYgPSB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KTtcbiAgcmV0dXJuIHYgPiBtYXggPyBtYXggOiB2O1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59IiwgImltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4vZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RnJlc2hTaWRlT2JqZWN0KCksIHBhZGRpbmdPYmplY3QpO1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHBhbmRUb0hhc2hNYXAodmFsdWUsIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoTWFwLCBrZXkpIHtcbiAgICBoYXNoTWFwW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gaGFzaE1hcDtcbiAgfSwge30pO1xufSIsICJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4uL2RvbS11dGlscy9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB3aXRoaW4gfSBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuLi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4uL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qc1wiO1xuaW1wb3J0IHsgbGVmdCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB0b3AsIGJvdHRvbSB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB0b1BhZGRpbmdPYmplY3QgPSBmdW5jdGlvbiB0b1BhZGRpbmdPYmplY3QocGFkZGluZywgc3RhdGUpIHtcbiAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHBhZGRpbmc7XG4gIHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xufTtcblxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICB2YXIgYXJyb3dSZWN0ID0gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpO1xuICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gIHZhciBlbmREaWZmID0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gKyBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgdmFyIGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XG4gIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xuICAvLyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYm91bmRzXG5cbiAgdmFyIG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XG4gIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgdmFyIG9mZnNldCA9IHdpdGhpbihtaW4sIGNlbnRlciwgbWF4KTsgLy8gUHJldmVudHMgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy4uLlxuXG4gIHZhciBheGlzUHJvcCA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSAoX3N0YXRlJG1vZGlmaWVyc0RhdGEkID0ge30sIF9zdGF0ZSRtb2RpZmllcnNEYXRhJFtheGlzUHJvcF0gPSBvZmZzZXQsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJC5jZW50ZXJPZmZzZXQgPSBvZmZzZXQgLSBjZW50ZXIsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJCk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCxcbiAgICAgIGFycm93RWxlbWVudCA9IF9vcHRpb25zJGVsZW1lbnQgPT09IHZvaWQgMCA/ICdbZGF0YS1wb3BwZXItYXJyb3ddJyA6IF9vcHRpb25zJGVsZW1lbnQ7XG5cbiAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIENTUyBzZWxlY3RvclxuXG5cbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2Fycm93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGFycm93LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXG59OyIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn0iLCAiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB1bnNldFNpZGVzID0ge1xuICB0b3A6ICdhdXRvJyxcbiAgcmlnaHQ6ICdhdXRvJyxcbiAgYm90dG9tOiAnYXV0bycsXG4gIGxlZnQ6ICdhdXRvJ1xufTsgLy8gUm91bmQgdGhlIG9mZnNldHMgdG8gdGhlIG5lYXJlc3Qgc3VpdGFibGUgc3VicGl4ZWwgYmFzZWQgb24gdGhlIERQUi5cbi8vIFpvb21pbmcgY2FuIGNoYW5nZSB0aGUgRFBSLCBidXQgaXQgc2VlbXMgdG8gcmVwb3J0IGEgdmFsdWUgdGhhdCB3aWxsXG4vLyBjbGVhbmx5IGRpdmlkZSB0aGUgdmFsdWVzIGludG8gdGhlIGFwcHJvcHJpYXRlIHN1YnBpeGVscy5cblxuZnVuY3Rpb24gcm91bmRPZmZzZXRzQnlEUFIoX3JlZiwgd2luKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoeCAqIGRwcikgLyBkcHIgfHwgMCxcbiAgICB5OiByb3VuZCh5ICogZHByKSAvIGRwciB8fCAwXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb1N0eWxlcyhfcmVmMikge1xuICB2YXIgX09iamVjdCRhc3NpZ24yO1xuXG4gIHZhciBwb3BwZXIgPSBfcmVmMi5wb3BwZXIsXG4gICAgICBwb3BwZXJSZWN0ID0gX3JlZjIucG9wcGVyUmVjdCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcbiAgICAgIHZhcmlhdGlvbiA9IF9yZWYyLnZhcmlhdGlvbixcbiAgICAgIG9mZnNldHMgPSBfcmVmMi5vZmZzZXRzLFxuICAgICAgcG9zaXRpb24gPSBfcmVmMi5wb3NpdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9yZWYyLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGFkYXB0aXZlID0gX3JlZjIuYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHMgPSBfcmVmMi5yb3VuZE9mZnNldHMsXG4gICAgICBpc0ZpeGVkID0gX3JlZjIuaXNGaXhlZDtcbiAgdmFyIF9vZmZzZXRzJHggPSBvZmZzZXRzLngsXG4gICAgICB4ID0gX29mZnNldHMkeCA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHgsXG4gICAgICBfb2Zmc2V0cyR5ID0gb2Zmc2V0cy55LFxuICAgICAgeSA9IF9vZmZzZXRzJHkgPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR5O1xuXG4gIHZhciBfcmVmMyA9IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9KSA6IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcblxuICB4ID0gX3JlZjMueDtcbiAgeSA9IF9yZWYzLnk7XG4gIHZhciBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xuICB2YXIgaGFzWSA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3knKTtcbiAgdmFyIHNpZGVYID0gbGVmdDtcbiAgdmFyIHNpZGVZID0gdG9wO1xuICB2YXIgd2luID0gd2luZG93O1xuXG4gIGlmIChhZGFwdGl2ZSkge1xuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKTtcbiAgICB2YXIgaGVpZ2h0UHJvcCA9ICdjbGllbnRIZWlnaHQnO1xuICAgIHZhciB3aWR0aFByb3AgPSAnY2xpZW50V2lkdGgnO1xuXG4gICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xuXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJyAmJiBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJykge1xuICAgICAgICBoZWlnaHRQcm9wID0gJ3Njcm9sbEhlaWdodCc7XG4gICAgICAgIHdpZHRoUHJvcCA9ICdzY3JvbGxXaWR0aCc7XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcblxuXG4gICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gdG9wIHx8IChwbGFjZW1lbnQgPT09IGxlZnQgfHwgcGxhY2VtZW50ID09PSByaWdodCkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVZID0gYm90dG9tO1xuICAgICAgdmFyIG9mZnNldFkgPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFtoZWlnaHRQcm9wXTtcbiAgICAgIHkgLT0gb2Zmc2V0WSAtIHBvcHBlclJlY3QuaGVpZ2h0O1xuICAgICAgeSAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCAocGxhY2VtZW50ID09PSB0b3AgfHwgcGxhY2VtZW50ID09PSBib3R0b20pICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWCA9IHJpZ2h0O1xuICAgICAgdmFyIG9mZnNldFggPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC53aWR0aCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W3dpZHRoUHJvcF07XG4gICAgICB4IC09IG9mZnNldFggLSBwb3BwZXJSZWN0LndpZHRoO1xuICAgICAgeCAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9LCBhZGFwdGl2ZSAmJiB1bnNldFNpZGVzKTtcblxuICB2YXIgX3JlZjQgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUih7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0sIGdldFdpbmRvdyhwb3BwZXIpKSA6IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcblxuICB4ID0gX3JlZjQueDtcbiAgeSA9IF9yZWY0Lnk7XG5cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xuICAgIHZhciBfT2JqZWN0JGFzc2lnbjtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnbltzaWRlWV0gPSBoYXNZID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduW3NpZGVYXSA9IGhhc1ggPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ24udHJhbnNmb3JtID0gKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKVwiLCBfT2JqZWN0JGFzc2lnbikpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduMiA9IHt9LCBfT2JqZWN0JGFzc2lnbjJbc2lkZVldID0gaGFzWSA/IHkgKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yW3NpZGVYXSA9IGhhc1ggPyB4ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMi50cmFuc2Zvcm0gPSAnJywgX09iamVjdCRhc3NpZ24yKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoX3JlZjUpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjUuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjUub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZ3B1QWNjZWxlcmF0LFxuICAgICAgX29wdGlvbnMkYWRhcHRpdmUgPSBvcHRpb25zLmFkYXB0aXZlLFxuICAgICAgYWRhcHRpdmUgPSBfb3B0aW9ucyRhZGFwdGl2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFkYXB0aXZlLFxuICAgICAgX29wdGlvbnMkcm91bmRPZmZzZXRzID0gb3B0aW9ucy5yb3VuZE9mZnNldHMsXG4gICAgICByb3VuZE9mZnNldHMgPSBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyb3VuZE9mZnNldHM7XG4gIHZhciBjb21tb25TdHlsZXMgPSB7XG4gICAgcGxhY2VtZW50OiBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCksXG4gICAgdmFyaWF0aW9uOiBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHN0YXRlLmVsZW1lbnRzLnBvcHBlcixcbiAgICBwb3BwZXJSZWN0OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiBncHVBY2NlbGVyYXRpb24sXG4gICAgaXNGaXhlZDogc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJ1xuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMucG9wcGVyLCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgYWRhcHRpdmU6IGFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5hcnJvdywgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBhZGFwdGl2ZTogZmFsc2UsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCc6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ2JlZm9yZVdyaXRlJyxcbiAgZm46IGNvbXB1dGVTdHlsZXMsXG4gIGRhdGE6IHt9XG59OyIsICJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHBhc3NpdmUgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwsXG4gICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXG4gICAgICBfb3B0aW9ucyRyZXNpemUgPSBvcHRpb25zLnJlc2l6ZSxcbiAgICAgIHJlc2l6ZSA9IF9vcHRpb25zJHJlc2l6ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJlc2l6ZTtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xuICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuXG4gIGlmIChzY3JvbGwpIHtcbiAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVzaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfVxuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGZ1bmN0aW9uIGZuKCkge30sXG4gIGVmZmVjdDogZWZmZWN0LFxuICBkYXRhOiB7fVxufTsiLCAidmFyIGhhc2ggPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwgInZhciBoYXNoID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCAiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlKSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xuICB2YXIgc2Nyb2xsVG9wID0gd2luLnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3BcbiAgfTtcbn0iLCAiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSB7XG4gIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IGZvciBSVEwuXG4gIC8vIFBvcHBlciAxIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UgYW5kIG5ldmVyIGhhZCBhIGJ1ZyByZXBvcnQgc28gbGV0J3MgYXNzdW1lXG4gIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cbiAgLy8gYW55d2F5LlxuICAvLyBCcm93c2VycyB3aGVyZSB0aGUgbGVmdCBzY3JvbGxiYXIgZG9lc24ndCBjYXVzZSBhbiBpc3N1ZSByZXBvcnQgYDBgIGZvclxuICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldFdpbmRvd1Njcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xufSIsICJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBpc0xheW91dFZpZXdwb3J0IGZyb20gXCIuL2lzTGF5b3V0Vmlld3BvcnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICB2YXIgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwO1xuXG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgIHZhciBsYXlvdXRWaWV3cG9ydCA9IGlzTGF5b3V0Vmlld3BvcnQoKTtcblxuICAgIGlmIChsYXlvdXRWaWV3cG9ydCB8fCAhbGF5b3V0Vmlld3BvcnQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSxcbiAgICB5OiB5XG4gIH07XG59IiwgImltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IHsgbWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgdmFyIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xuICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59IiwgImltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gRmlyZWZveCB3YW50cyB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcblxuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcbn0iLCAiaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihnZXROb2RlTmFtZShub2RlKSkgPj0gMCkge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSAmJiBpc1Njcm9sbFBhcmVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKG5vZGUpKTtcbn0iLCAiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tIFwiLi9nZXRTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgdG9wOiByZWN0LnksXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9KTtcbn0iLCAiaW1wb3J0IHsgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWaWV3cG9ydFJlY3QgZnJvbSBcIi4vZ2V0Vmlld3BvcnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRSZWN0IGZyb20gXCIuL2dldERvY3VtZW50UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4vY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4uL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IG1heCwgbWluIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgZmFsc2UsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgcmVjdC50b3AgPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICByZWN0LmxlZnQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3Qud2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LmhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnggPSByZWN0LmxlZnQ7XG4gIHJlY3QueSA9IHJlY3QudG9wO1xuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkpIDogaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSA/IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkgOiByZWN0VG9DbGllbnRSZWN0KGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpKTtcbn0gLy8gQSBcImNsaXBwaW5nIHBhcmVudFwiIGlzIGFuIG92ZXJmbG93YWJsZSBjb250YWluZXIgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIG92ZXJmbG93aW5nIGVsZW1lbnRzIHdpdGggYSBwb3NpdGlvbiBkaWZmZXJlbnQgZnJvbVxuLy8gYGluaXRpYWxgXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIHtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xuICB2YXIgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uKSA+PSAwO1xuICB2YXIgY2xpcHBlckVsZW1lbnQgPSBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIDogZWxlbWVudDtcblxuICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzE0MTRcblxuXG4gIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGlwcGluZ1BhcmVudCkge1xuICAgIHJldHVybiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpICYmIGNvbnRhaW5zKGNsaXBwaW5nUGFyZW50LCBjbGlwcGVyRWxlbWVudCkgJiYgZ2V0Tm9kZU5hbWUoY2xpcHBpbmdQYXJlbnQpICE9PSAnYm9keSc7XG4gIH0pO1xufSAvLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBwYXJlbnRzXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KGVsZW1lbnQsIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KSB7XG4gIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IFtdLmNvbmNhdChtYWluQ2xpcHBpbmdQYXJlbnRzLCBbcm9vdEJvdW5kYXJ5XSk7XG4gIHZhciBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSk7XG4gICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcbiAgICByZXR1cm4gYWNjUmVjdDtcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgZmlyc3RDbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpKTtcbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xuICByZXR1cm4gY2xpcHBpbmdSZWN0O1xufSIsICJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgc3RhcnQsIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZU9mZnNldHMoX3JlZikge1xuICB2YXIgcmVmZXJlbmNlID0gX3JlZi5yZWZlcmVuY2UsXG4gICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZi5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50ID8gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudCA/IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcbiAgdmFyIGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZWxlbWVudC5oZWlnaHQgLyAyO1xuICB2YXIgb2Zmc2V0cztcblxuICBzd2l0Y2ggKGJhc2VQbGFjZW1lbnQpIHtcbiAgICBjYXNlIHRvcDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYm90dG9tOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHJpZ2h0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgbGVmdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZWxlbWVudC53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuXG4gIHZhciBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnQgPyBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCkgOiBudWxsO1xuXG4gIGlmIChtYWluQXhpcyAhPSBudWxsKSB7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xuICAgICAgY2FzZSBzdGFydDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSAtIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZW5kOlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdICsgKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn0iLCAiaW1wb3J0IGdldENsaXBwaW5nUmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gXCIuL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBjbGlwcGluZ1BhcmVudHMsIHJlZmVyZW5jZSwgcG9wcGVyLCBib3R0b20sIHRvcCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi9leHBhbmRUb0hhc2hNYXAuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zJHBsYWNlbWVudCA9PT0gdm9pZCAwID8gc3RhdGUucGxhY2VtZW50IDogX29wdGlvbnMkcGxhY2VtZW50LFxuICAgICAgX29wdGlvbnMkc3RyYXRlZ3kgPSBfb3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIHN0cmF0ZWd5ID0gX29wdGlvbnMkc3RyYXRlZ3kgPT09IHZvaWQgMCA/IHN0YXRlLnN0cmF0ZWd5IDogX29wdGlvbnMkc3RyYXRlZ3ksXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpO1xuICB2YXIgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2UpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgZWxlbWVudDogcG9wcGVyUmVjdCxcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KTtcbiAgdmFyIHBvcHBlckNsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHBvcHBlck9mZnNldHMpKTtcbiAgdmFyIGVsZW1lbnRDbGllbnRSZWN0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHBvcHBlckNsaWVudFJlY3QgOiByZWZlcmVuY2VDbGllbnRSZWN0OyAvLyBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyByZWN0XG4gIC8vIDAgb3IgbmVnYXRpdmUgPSB3aXRoaW4gdGhlIGNsaXBwaW5nIHJlY3RcblxuICB2YXIgb3ZlcmZsb3dPZmZzZXRzID0ge1xuICAgIHRvcDogY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wLFxuICAgIGJvdHRvbTogZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tLFxuICAgIGxlZnQ6IGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCxcbiAgICByaWdodDogZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0XG4gIH07XG4gIHZhciBvZmZzZXREYXRhID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7IC8vIE9mZnNldHMgY2FuIGJlIGFwcGxpZWQgb25seSB0byB0aGUgcG9wcGVyIGVsZW1lbnRcblxuICBpZiAoZWxlbWVudENvbnRleHQgPT09IHBvcHBlciAmJiBvZmZzZXREYXRhKSB7XG4gICAgdmFyIG9mZnNldCA9IG9mZnNldERhdGFbcGxhY2VtZW50XTtcbiAgICBPYmplY3Qua2V5cyhvdmVyZmxvd09mZnNldHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG11bHRpcGx5ID0gW3JpZ2h0LCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xuICAgICAgdmFyIGF4aXMgPSBbdG9wLCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gJ3knIDogJ3gnO1xuICAgICAgb3ZlcmZsb3dPZmZzZXRzW2tleV0gKz0gb2Zmc2V0W2F4aXNdICogbXVsdGlwbHk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb3ZlcmZsb3dPZmZzZXRzO1xufSIsICJpbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IHsgdmFyaWF0aW9uUGxhY2VtZW50cywgYmFzZVBsYWNlbWVudHMsIHBsYWNlbWVudHMgYXMgYWxsUGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPSBfb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPT09IHZvaWQgMCA/IGFsbFBsYWNlbWVudHMgOiBfb3B0aW9ucyRhbGxvd2VkQXV0b1A7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KTtcbiAgdmFyIHBsYWNlbWVudHMgPSB2YXJpYXRpb24gPyBmbGlwVmFyaWF0aW9ucyA/IHZhcmlhdGlvblBsYWNlbWVudHMgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSB2YXJpYXRpb247XG4gIH0pIDogYmFzZVBsYWNlbWVudHM7XG4gIHZhciBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWxsb3dlZEF1dG9QbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KSA+PSAwO1xuICB9KTtcblxuICBpZiAoYWxsb3dlZFBsYWNlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdOiBGbG93IHNlZW1zIHRvIGhhdmUgcHJvYmxlbXMgd2l0aCB0d28gYXJyYXkgdW5pb25zLi4uXG5cblxuICB2YXIgb3ZlcmZsb3dzID0gYWxsb3dlZFBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSlbZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpXTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dzW2FdIC0gb3ZlcmZsb3dzW2JdO1xuICB9KTtcbn0iLCAiaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IGJvdHRvbSwgdG9wLCBzdGFydCwgcmlnaHQsIGxlZnQsIGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIFx1MjAxMyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59OyIsICJpbXBvcnQgeyB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QsIHByZXZlbnRlZE9mZnNldHMpIHtcbiAgaWYgKHByZXZlbnRlZE9mZnNldHMgPT09IHZvaWQgMCkge1xuICAgIHByZXZlbnRlZE9mZnNldHMgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQgLSBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoIC0gcHJldmVudGVkT2Zmc2V0cy54XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0uc29tZShmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBvdmVyZmxvd1tzaWRlXSA+PSAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGlkZShfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBwcmV2ZW50ZWRPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3c7XG4gIHZhciByZWZlcmVuY2VPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gIH0pO1xuICB2YXIgcG9wcGVyQWx0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGFsdEJvdW5kYXJ5OiB0cnVlXG4gIH0pO1xuICB2YXIgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocmVmZXJlbmNlT3ZlcmZsb3csIHJlZmVyZW5jZVJlY3QpO1xuICB2YXIgcG9wcGVyRXNjYXBlT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHBvcHBlckFsdE92ZXJmbG93LCBwb3BwZXJSZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKTtcbiAgdmFyIGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XG4gIHZhciBoYXNQb3BwZXJFc2NhcGVkID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHBvcHBlckVzY2FwZU9mZnNldHMpO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0ge1xuICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzLFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IHBvcHBlckVzY2FwZU9mZnNldHMsXG4gICAgaXNSZWZlcmVuY2VIaWRkZW46IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgIGhhc1BvcHBlckVzY2FwZWQ6IGhhc1BvcHBlckVzY2FwZWRcbiAgfTtcbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgJ2RhdGEtcG9wcGVyLWVzY2FwZWQnOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnaGlkZScsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXG4gIGZuOiBoaWRlXG59OyIsICJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgcGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KSkgOiBvZmZzZXQsXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgeDogZGlzdGFuY2UsXG4gICAgeTogc2tpZGRpbmdcbiAgfSA6IHtcbiAgICB4OiBza2lkZGluZyxcbiAgICB5OiBkaXN0YW5jZVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59OyIsICJpbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5cbmZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QWx0QXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59IiwgImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgc3RhcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRBbHRBeGlzIGZyb20gXCIuLi91dGlscy9nZXRBbHRBeGlzLmpzXCI7XG5pbXBvcnQgeyB3aXRoaW4sIHdpdGhpbk1heENsYW1wIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4uL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuaW1wb3J0IHsgbWluIGFzIG1hdGhNaW4sIG1heCBhcyBtYXRoTWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcbiAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnlcbiAgfSk7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiB0ZXRoZXJPZmZzZXQ7XG4gIHZhciBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSxcbiAgICBhbHRBeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZVxuICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgYWx0QXhpczogMFxuICB9LCB0ZXRoZXJPZmZzZXRWYWx1ZSk7XG4gIHZhciBvZmZzZXRNb2RpZmllclN0YXRlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdIDogbnVsbDtcbiAgdmFyIGRhdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkO1xuXG4gICAgdmFyIG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuICAgIHZhciBtaW4gPSBvZmZzZXQgKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgdmFyIG1heCA9IG9mZnNldCAtIG92ZXJmbG93W2FsdFNpZGVdO1xuICAgIHZhciBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcbiAgICB2YXIgbWluTGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IHJlZmVyZW5jZVJlY3RbbGVuXSA6IHBvcHBlclJlY3RbbGVuXTtcbiAgICB2YXIgbWF4TGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IC1wb3BwZXJSZWN0W2xlbl0gOiAtcmVmZXJlbmNlUmVjdFtsZW5dOyAvLyBXZSBuZWVkIHRvIGluY2x1ZGUgdGhlIGFycm93IGluIHRoZSBjYWxjdWxhdGlvbiBzbyB0aGUgYXJyb3cgZG9lc24ndCBnb1xuICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcblxuICAgIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KSA6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddID8gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddLnBhZGRpbmcgOiBnZXRGcmVzaFNpZGVPYmplY3QoKTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWluID0gYXJyb3dQYWRkaW5nT2JqZWN0W21haW5TaWRlXTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGluY2x1ZGUgaXRzIGZ1bGwgc2l6ZSBpbiB0aGUgY2FsY3VsYXRpb24uIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGxcbiAgICAvLyBhbmQgbmVhciB0aGUgZWRnZSBvZiBhIGJvdW5kYXJ5LCB0aGUgcG9wcGVyIGNhbiBvdmVyZmxvdyBldmVuIGlmIHRoZVxuICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cbiAgICAvLyB3aWR0aCBvciBoZWlnaHQpXG5cbiAgICB2YXIgYXJyb3dMZW4gPSB3aXRoaW4oMCwgcmVmZXJlbmNlUmVjdFtsZW5dLCBhcnJvd1JlY3RbbGVuXSk7XG4gICAgdmFyIG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IHJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgLSBhZGRpdGl2ZSAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIG1heE9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IC1yZWZlcmVuY2VSZWN0W2xlbl0gLyAyICsgYWRkaXRpdmUgKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIGdldE9mZnNldFBhcmVudChzdGF0ZS5lbGVtZW50cy5hcnJvdyk7XG4gICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcbiAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW21haW5BeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJCA6IDA7XG4gICAgdmFyIHRldGhlck1pbiA9IG9mZnNldCArIG1pbk9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWUgLSBjbGllbnRPZmZzZXQ7XG4gICAgdmFyIHRldGhlck1heCA9IG9mZnNldCArIG1heE9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWU7XG4gICAgdmFyIHByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtYXRoTWluKG1pbiwgdGV0aGVyTWluKSA6IG1pbiwgb2Zmc2V0LCB0ZXRoZXIgPyBtYXRoTWF4KG1heCwgdGV0aGVyTWF4KSA6IG1heCk7XG4gICAgcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gIH1cblxuICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDI7XG5cbiAgICB2YXIgX21haW5TaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IHRvcCA6IGxlZnQ7XG5cbiAgICB2YXIgX2FsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gYm90dG9tIDogcmlnaHQ7XG5cbiAgICB2YXIgX29mZnNldCA9IHBvcHBlck9mZnNldHNbYWx0QXhpc107XG5cbiAgICB2YXIgX2xlbiA9IGFsdEF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHZhciBfbWluID0gX29mZnNldCArIG92ZXJmbG93W19tYWluU2lkZV07XG5cbiAgICB2YXIgX21heCA9IF9vZmZzZXQgLSBvdmVyZmxvd1tfYWx0U2lkZV07XG5cbiAgICB2YXIgaXNPcmlnaW5TaWRlID0gW3RvcCwgbGVmdF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICB2YXIgX29mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkMiA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbYWx0QXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyIDogMDtcblxuICAgIHZhciBfdGV0aGVyTWluID0gaXNPcmlnaW5TaWRlID8gX21pbiA6IF9vZmZzZXQgLSByZWZlcmVuY2VSZWN0W19sZW5dIC0gcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXM7XG5cbiAgICB2YXIgX3RldGhlck1heCA9IGlzT3JpZ2luU2lkZSA/IF9vZmZzZXQgKyByZWZlcmVuY2VSZWN0W19sZW5dICsgcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXMgOiBfbWF4O1xuXG4gICAgdmFyIF9wcmV2ZW50ZWRPZmZzZXQgPSB0ZXRoZXIgJiYgaXNPcmlnaW5TaWRlID8gd2l0aGluTWF4Q2xhbXAoX3RldGhlck1pbiwgX29mZnNldCwgX3RldGhlck1heCkgOiB3aXRoaW4odGV0aGVyID8gX3RldGhlck1pbiA6IF9taW4sIF9vZmZzZXQsIHRldGhlciA/IF90ZXRoZXJNYXggOiBfbWF4KTtcblxuICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0IC0gX29mZnNldDtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXVxufTsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gIH07XG59IiwgImltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRIVE1MRWxlbWVudFNjcm9sbCBmcm9tIFwiLi9nZXRIVE1MRWxlbWVudFNjcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XG4gIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcbiAgfVxufSIsICJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldE5vZGVTY3JvbGwgZnJvbSBcIi4vZ2V0Tm9kZVNjcm9sbC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnRTY2FsZWQoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgdmFyIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHJldHVybiBzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxO1xufSAvLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4vLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50LCBpc0ZpeGVkKSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnRJc1NjYWxlZCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc0VsZW1lbnRTY2FsZWQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50SXNTY2FsZWQsIGlzRml4ZWQpO1xuICB2YXIgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn0iLCAiaW1wb3J0IHsgbW9kaWZpZXJQaGFzZXMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTg3NTI1NVxuXG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufSIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWJvdW5jZShmbikge1xuICB2YXIgcGVuZGluZztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH07XG59IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBjdXJyZW50LCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5vcHRpb25zLCBjdXJyZW50Lm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxuICAgIH0pIDogY3VycmVudDtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XG4gIH0pO1xufSIsICJpbXBvcnQgZ2V0Q29tcG9zaXRlUmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IG9yZGVyTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcIi4vdXRpbHMvZGVib3VuY2UuanNcIjtcbmltcG9ydCBtZXJnZUJ5TmFtZSBmcm9tIFwiLi91dGlscy9tZXJnZUJ5TmFtZS5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcbn07XG5cbmZ1bmN0aW9uIGFyZVZhbGlkRWxlbWVudHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3BwZXJHZW5lcmF0b3IoZ2VuZXJhdG9yT3B0aW9ucykge1xuICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgZ2VuZXJhdG9yT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXG4gICAgICBkZWZhdWx0TW9kaWZpZXJzID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmID09PSB2b2lkIDAgPyBbXSA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZixcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfTtcbiAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZhciBpbnN0YW5jZSA9IHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzZXRPcHRpb25zQWN0aW9uID09PSAnZnVuY3Rpb24nID8gc2V0T3B0aW9uc0FjdGlvbihzdGF0ZS5vcHRpb25zKSA6IHNldE9wdGlvbnNBY3Rpb247XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIFx1MjAxMyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIHBvcHBlciA9IF9zdGF0ZSRlbGVtZW50cy5wb3BwZXI7IC8vIERvbid0IHByb2NlZWQgaWYgYHJlZmVyZW5jZWAgb3IgYHBvcHBlcmAgYXJlIG5vdCB2YWxpZCBlbGVtZW50c1xuICAgICAgICAvLyBhbnltb3JlXG5cbiAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZSA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnNbaW5kZXhdLFxuICAgICAgICAgICAgICBmbiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5mbixcbiAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxuICAgICAgICAgICAgICBfb3B0aW9ucyA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPT09IHZvaWQgMCA/IHt9IDogX3N0YXRlJG9yZGVyZWRNb2RpZmllMixcbiAgICAgICAgICAgICAgbmFtZSA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5uYW1lO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3RhdGUgPSBmbih7XG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVxuICAgICAgICAgICAgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUgXHUyMDEzIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBpc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcbiAgICAvLyBjeWNsZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG1vZGlmaWVyIGFkZHMgc29tZSBwZXJzaXN0ZW50IGRhdGEgdGhhdFxuICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxuICAgIC8vIG9uZS5cblxuICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgICAgIF9yZWYkb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRvcHRpb25zLFxuICAgICAgICAgICAgZWZmZWN0ID0gX3JlZi5lZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuZXhwb3J0IHZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgZGV0ZWN0T3ZlcmZsb3cgfTsiLCAiaW1wb3J0IHsgcG9wcGVyR2VuZXJhdG9yLCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gXCIuL2NyZWF0ZVBvcHBlci5qc1wiO1xuaW1wb3J0IGV2ZW50TGlzdGVuZXJzIGZyb20gXCIuL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qc1wiO1xuaW1wb3J0IHBvcHBlck9mZnNldHMgZnJvbSBcIi4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanNcIjtcbmltcG9ydCBjb21wdXRlU3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzXCI7XG5pbXBvcnQgYXBwbHlTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzXCI7XG5pbXBvcnQgb2Zmc2V0IGZyb20gXCIuL21vZGlmaWVycy9vZmZzZXQuanNcIjtcbmltcG9ydCBmbGlwIGZyb20gXCIuL21vZGlmaWVycy9mbGlwLmpzXCI7XG5pbXBvcnQgcHJldmVudE92ZXJmbG93IGZyb20gXCIuL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBhcnJvdyBmcm9tIFwiLi9tb2RpZmllcnMvYXJyb3cuanNcIjtcbmltcG9ydCBoaWRlIGZyb20gXCIuL21vZGlmaWVycy9oaWRlLmpzXCI7XG52YXIgZGVmYXVsdE1vZGlmaWVycyA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cywgY29tcHV0ZVN0eWxlcywgYXBwbHlTdHlsZXMsIG9mZnNldCwgZmxpcCwgcHJldmVudE92ZXJmbG93LCBhcnJvdywgaGlkZV07XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciBhcyBjcmVhdGVQb3BwZXJMaXRlIH0gZnJvbSBcIi4vcG9wcGVyLWxpdGUuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgKiBmcm9tIFwiLi9tb2RpZmllcnMvaW5kZXguanNcIjsiLCAiZXhwb3J0IGNvbnN0IFJPVU5EX0FSUk9XID1cbiAgJzxzdmcgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk0wIDZzMS43OTYtLjAxMyA0LjY3LTMuNjE1QzUuODUxLjkgNi45My4wMDYgOCAwYzEuMDctLjAwNiAyLjE0OC44ODcgMy4zNDMgMi4zODVDMTQuMjMzIDYuMDA1IDE2IDYgMTYgNkgwelwiPjwvc3ZnPic7XG5cbmV4cG9ydCBjb25zdCBCT1hfQ0xBU1MgPSBgX19OQU1FU1BBQ0VfUFJFRklYX18tYm94YDtcbmV4cG9ydCBjb25zdCBDT05URU5UX0NMQVNTID0gYF9fTkFNRVNQQUNFX1BSRUZJWF9fLWNvbnRlbnRgO1xuZXhwb3J0IGNvbnN0IEJBQ0tEUk9QX0NMQVNTID0gYF9fTkFNRVNQQUNFX1BSRUZJWF9fLWJhY2tkcm9wYDtcbmV4cG9ydCBjb25zdCBBUlJPV19DTEFTUyA9IGBfX05BTUVTUEFDRV9QUkVGSVhfXy1hcnJvd2A7XG5leHBvcnQgY29uc3QgU1ZHX0FSUk9XX0NMQVNTID0gYF9fTkFNRVNQQUNFX1BSRUZJWF9fLXN2Zy1hcnJvd2A7XG5cbmV4cG9ydCBjb25zdCBUT1VDSF9PUFRJT05TID0ge3Bhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWV9O1xuXG5leHBvcnQgY29uc3QgVElQUFlfREVGQVVMVF9BUFBFTkRfVE8gPSAoKSA9PiBkb2N1bWVudC5ib2R5O1xuIiwgImltcG9ydCB7QmFzZVBsYWNlbWVudCwgUGxhY2VtZW50fSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc093blByb3BlcnR5KFxuICBvYmo6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBrZXk6IHN0cmluZ1xuKTogYm9vbGVhbiB7XG4gIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlQXRJbmRleE9yUmV0dXJuPFQ+KFxuICB2YWx1ZTogVCB8IFtUIHwgbnVsbCwgVCB8IG51bGxdLFxuICBpbmRleDogbnVtYmVyLFxuICBkZWZhdWx0VmFsdWU6IFQgfCBbVCwgVF1cbik6IFQge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCB2ID0gdmFsdWVbaW5kZXhdO1xuICAgIHJldHVybiB2ID09IG51bGxcbiAgICAgID8gQXJyYXkuaXNBcnJheShkZWZhdWx0VmFsdWUpXG4gICAgICAgID8gZGVmYXVsdFZhbHVlW2luZGV4XVxuICAgICAgICA6IGRlZmF1bHRWYWx1ZVxuICAgICAgOiB2O1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUeXBlKHZhbHVlOiBhbnksIHR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBzdHIgPSB7fS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKCdbb2JqZWN0JykgPT09IDAgJiYgc3RyLmluZGV4T2YoYCR7dHlwZX1dYCkgPiAtMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludm9rZVdpdGhBcmdzT3JSZXR1cm4odmFsdWU6IGFueSwgYXJnczogYW55W10pOiBhbnkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUoLi4uYXJncykgOiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlPFQ+KFxuICBmbjogKGFyZzogVCkgPT4gdm9pZCxcbiAgbXM6IG51bWJlclxuKTogKGFyZzogVCkgPT4gdm9pZCB7XG4gIC8vIEF2b2lkIHdyYXBwaW5nIGluIGBzZXRUaW1lb3V0YCBpZiBtcyBpcyAwIGFueXdheVxuICBpZiAobXMgPT09IDApIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBsZXQgdGltZW91dDogYW55O1xuXG4gIHJldHVybiAoYXJnKTogdm9pZCA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGZuKGFyZyk7XG4gICAgfSwgbXMpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUHJvcGVydGllczxUPihvYmo6IFQsIGtleXM6IHN0cmluZ1tdKTogUGFydGlhbDxUPiB7XG4gIGNvbnN0IGNsb25lID0gey4uLm9ian07XG4gIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgZGVsZXRlIChjbG9uZSBhcyBhbnkpW2tleV07XG4gIH0pO1xuICByZXR1cm4gY2xvbmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdEJ5U3BhY2VzKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIHJldHVybiB2YWx1ZS5zcGxpdCgvXFxzKy8pLmZpbHRlcihCb29sZWFuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXk8VD4odmFsdWU6IFQgfCBUW10pOiBUW10ge1xuICByZXR1cm4gKFtdIGFzIFRbXSkuY29uY2F0KHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHB1c2hJZlVuaXF1ZTxUPihhcnI6IFRbXSwgdmFsdWU6IFQpOiB2b2lkIHtcbiAgaWYgKGFyci5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICBhcnIucHVzaCh2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZFB4SWZOdW1iZXIodmFsdWU6IHN0cmluZyB8IG51bWJlcik6IHN0cmluZyB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gYCR7dmFsdWV9cHhgIDogdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmlxdWU8VD4oYXJyOiBUW10pOiBUW10ge1xuICByZXR1cm4gYXJyLmZpbHRlcigoaXRlbSwgaW5kZXgpID0+IGFyci5pbmRleE9mKGl0ZW0pID09PSBpbmRleCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXIodmFsdWU6IHN0cmluZyB8IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiBwYXJzZUZsb2F0KHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50OiBQbGFjZW1lbnQpOiBCYXNlUGxhY2VtZW50IHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdIGFzIEJhc2VQbGFjZW1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUZyb20odmFsdWU6IEFycmF5TGlrZTxhbnk+KTogYW55W10ge1xuICByZXR1cm4gW10uc2xpY2UuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVVbmRlZmluZWRQcm9wcyhcbiAgb2JqOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuKTogUGFydGlhbDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4ge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgaWYgKG9ialtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIChhY2MgYXMgYW55KVtrZXldID0gb2JqW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuIiwgImltcG9ydCB7UmVmZXJlbmNlRWxlbWVudCwgVGFyZ2V0c30gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1BvcHBlclRyZWVEYXRhfSBmcm9tICcuL3R5cGVzLWludGVybmFsJztcbmltcG9ydCB7YXJyYXlGcm9tLCBpc1R5cGUsIG5vcm1hbGl6ZVRvQXJyYXksIGdldEJhc2VQbGFjZW1lbnR9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZGl2KCk6IEhUTUxEaXZFbGVtZW50IHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgRWxlbWVudCB8IERvY3VtZW50RnJhZ21lbnQge1xuICByZXR1cm4gWydFbGVtZW50JywgJ0ZyYWdtZW50J10uc29tZSgodHlwZSkgPT4gaXNUeXBlKHZhbHVlLCB0eXBlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVMaXN0KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgTm9kZUxpc3Qge1xuICByZXR1cm4gaXNUeXBlKHZhbHVlLCAnTm9kZUxpc3QnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTW91c2VFdmVudCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIE1vdXNlRXZlbnQge1xuICByZXR1cm4gaXNUeXBlKHZhbHVlLCAnTW91c2VFdmVudCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWZlcmVuY2VFbGVtZW50KHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBSZWZlcmVuY2VFbGVtZW50IHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl90aXBweSAmJiB2YWx1ZS5fdGlwcHkucmVmZXJlbmNlID09PSB2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcnJheU9mRWxlbWVudHModmFsdWU6IFRhcmdldHMpOiBFbGVtZW50W10ge1xuICBpZiAoaXNFbGVtZW50KHZhbHVlKSkge1xuICAgIHJldHVybiBbdmFsdWVdO1xuICB9XG5cbiAgaWYgKGlzTm9kZUxpc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGFycmF5RnJvbSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gYXJyYXlGcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodmFsdWUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFRyYW5zaXRpb25EdXJhdGlvbihcbiAgZWxzOiAoSFRNTERpdkVsZW1lbnQgfCBudWxsKVtdLFxuICB2YWx1ZTogbnVtYmVyXG4pOiB2b2lkIHtcbiAgZWxzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBgJHt2YWx1ZX1tc2A7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFZpc2liaWxpdHlTdGF0ZShcbiAgZWxzOiAoSFRNTERpdkVsZW1lbnQgfCBudWxsKVtdLFxuICBzdGF0ZTogJ3Zpc2libGUnIHwgJ2hpZGRlbidcbik6IHZvaWQge1xuICBlbHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsIHN0YXRlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudChcbiAgZWxlbWVudE9yRWxlbWVudHM6IEVsZW1lbnQgfCBFbGVtZW50W11cbik6IERvY3VtZW50IHtcbiAgY29uc3QgW2VsZW1lbnRdID0gbm9ybWFsaXplVG9BcnJheShlbGVtZW50T3JFbGVtZW50cyk7XG5cbiAgLy8gRWxlbWVudHMgY3JlYXRlZCB2aWEgYSA8dGVtcGxhdGU+IGhhdmUgYW4gb3duZXJEb2N1bWVudCB3aXRoIG5vIHJlZmVyZW5jZSB0byB0aGUgYm9keVxuICByZXR1cm4gZWxlbWVudD8ub3duZXJEb2N1bWVudD8uYm9keSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IGRvY3VtZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDdXJzb3JPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIoXG4gIHBvcHBlclRyZWVEYXRhOiBQb3BwZXJUcmVlRGF0YVtdLFxuICBldmVudDogTW91c2VFdmVudFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IHtjbGllbnRYLCBjbGllbnRZfSA9IGV2ZW50O1xuXG4gIHJldHVybiBwb3BwZXJUcmVlRGF0YS5ldmVyeSgoe3BvcHBlclJlY3QsIHBvcHBlclN0YXRlLCBwcm9wc30pID0+IHtcbiAgICBjb25zdCB7aW50ZXJhY3RpdmVCb3JkZXJ9ID0gcHJvcHM7XG4gICAgY29uc3QgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocG9wcGVyU3RhdGUucGxhY2VtZW50KTtcbiAgICBjb25zdCBvZmZzZXREYXRhID0gcG9wcGVyU3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7XG5cbiAgICBpZiAoIW9mZnNldERhdGEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHRvcERpc3RhbmNlID0gYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScgPyBvZmZzZXREYXRhLnRvcCEueSA6IDA7XG4gICAgY29uc3QgYm90dG9tRGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAndG9wJyA/IG9mZnNldERhdGEuYm90dG9tIS55IDogMDtcbiAgICBjb25zdCBsZWZ0RGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnID8gb2Zmc2V0RGF0YS5sZWZ0IS54IDogMDtcbiAgICBjb25zdCByaWdodERpc3RhbmNlID0gYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnID8gb2Zmc2V0RGF0YS5yaWdodCEueCA6IDA7XG5cbiAgICBjb25zdCBleGNlZWRzVG9wID1cbiAgICAgIHBvcHBlclJlY3QudG9wIC0gY2xpZW50WSArIHRvcERpc3RhbmNlID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgY29uc3QgZXhjZWVkc0JvdHRvbSA9XG4gICAgICBjbGllbnRZIC0gcG9wcGVyUmVjdC5ib3R0b20gLSBib3R0b21EaXN0YW5jZSA+IGludGVyYWN0aXZlQm9yZGVyO1xuICAgIGNvbnN0IGV4Y2VlZHNMZWZ0ID1cbiAgICAgIHBvcHBlclJlY3QubGVmdCAtIGNsaWVudFggKyBsZWZ0RGlzdGFuY2UgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICBjb25zdCBleGNlZWRzUmlnaHQgPVxuICAgICAgY2xpZW50WCAtIHBvcHBlclJlY3QucmlnaHQgLSByaWdodERpc3RhbmNlID4gaW50ZXJhY3RpdmVCb3JkZXI7XG5cbiAgICByZXR1cm4gZXhjZWVkc1RvcCB8fCBleGNlZWRzQm90dG9tIHx8IGV4Y2VlZHNMZWZ0IHx8IGV4Y2VlZHNSaWdodDtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIoXG4gIGJveDogSFRNTERpdkVsZW1lbnQsXG4gIGFjdGlvbjogJ2FkZCcgfCAncmVtb3ZlJyxcbiAgbGlzdGVuZXI6IChldmVudDogVHJhbnNpdGlvbkV2ZW50KSA9PiB2b2lkXG4pOiB2b2lkIHtcbiAgY29uc3QgbWV0aG9kID0gYCR7YWN0aW9ufUV2ZW50TGlzdGVuZXJgIGFzXG4gICAgfCAnYWRkRXZlbnRMaXN0ZW5lcidcbiAgICB8ICdyZW1vdmVFdmVudExpc3RlbmVyJztcblxuICAvLyBzb21lIGJyb3dzZXJzIGFwcGFyZW50bHkgc3VwcG9ydCBgdHJhbnNpdGlvbmAgKHVucHJlZml4ZWQpIGJ1dCBvbmx5IGZpcmVcbiAgLy8gYHdlYmtpdFRyYW5zaXRpb25FbmRgLi4uXG4gIFsndHJhbnNpdGlvbmVuZCcsICd3ZWJraXRUcmFuc2l0aW9uRW5kJ10uZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICBib3hbbWV0aG9kXShldmVudCwgbGlzdGVuZXIgYXMgRXZlbnRMaXN0ZW5lcik7XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbXBhcmVkIHRvIHh4eC5jb250YWlucywgdGhpcyBmdW5jdGlvbiB3b3JrcyBmb3IgZG9tIHN0cnVjdHVyZXMgd2l0aCBzaGFkb3dcbiAqIGRvbVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWN0dWFsQ29udGFpbnMocGFyZW50OiBFbGVtZW50LCBjaGlsZDogRWxlbWVudCk6IGJvb2xlYW4ge1xuICBsZXQgdGFyZ2V0ID0gY2hpbGQ7XG4gIHdoaWxlICh0YXJnZXQpIHtcbiAgICBpZiAocGFyZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0YXJnZXQgPSAodGFyZ2V0LmdldFJvb3ROb2RlPy4oKSBhcyBhbnkpPy5ob3N0O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsICJpbXBvcnQge1RPVUNIX09QVElPTlN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7aXNSZWZlcmVuY2VFbGVtZW50fSBmcm9tICcuL2RvbS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBjdXJyZW50SW5wdXQgPSB7aXNUb3VjaDogZmFsc2V9O1xubGV0IGxhc3RNb3VzZU1vdmVUaW1lID0gMDtcblxuLyoqXG4gKiBXaGVuIGEgYHRvdWNoc3RhcnRgIGV2ZW50IGlzIGZpcmVkLCBpdCdzIGFzc3VtZWQgdGhlIHVzZXIgaXMgdXNpbmcgdG91Y2hcbiAqIGlucHV0LiBXZSdsbCBiaW5kIGEgYG1vdXNlbW92ZWAgZXZlbnQgbGlzdGVuZXIgdG8gbGlzdGVuIGZvciBtb3VzZSBpbnB1dCBpblxuICogdGhlIGZ1dHVyZS4gVGhpcyB3YXksIHRoZSBgaXNUb3VjaGAgcHJvcGVydHkgaXMgZnVsbHkgZHluYW1pYyBhbmQgd2lsbCBoYW5kbGVcbiAqIGh5YnJpZCBkZXZpY2VzIHRoYXQgdXNlIGEgbWl4IG9mIHRvdWNoICsgbW91c2UgaW5wdXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkRvY3VtZW50VG91Y2hTdGFydCgpOiB2b2lkIHtcbiAgaWYgKGN1cnJlbnRJbnB1dC5pc1RvdWNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3VycmVudElucHV0LmlzVG91Y2ggPSB0cnVlO1xuXG4gIGlmICh3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbkRvY3VtZW50TW91c2VNb3ZlKTtcbiAgfVxufVxuXG4vKipcbiAqIFdoZW4gdHdvIGBtb3VzZW1vdmVgIGV2ZW50IGFyZSBmaXJlZCBjb25zZWN1dGl2ZWx5IHdpdGhpbiAyMG1zLCBpdCdzIGFzc3VtZWRcbiAqIHRoZSB1c2VyIGlzIHVzaW5nIG1vdXNlIGlucHV0IGFnYWluLiBgbW91c2Vtb3ZlYCBjYW4gZmlyZSBvbiB0b3VjaCBkZXZpY2VzIGFzXG4gKiB3ZWxsLCBidXQgdmVyeSByYXJlbHkgdGhhdCBxdWlja2x5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gb25Eb2N1bWVudE1vdXNlTW92ZSgpOiB2b2lkIHtcbiAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgaWYgKG5vdyAtIGxhc3RNb3VzZU1vdmVUaW1lIDwgMjApIHtcbiAgICBjdXJyZW50SW5wdXQuaXNUb3VjaCA9IGZhbHNlO1xuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Eb2N1bWVudE1vdXNlTW92ZSk7XG4gIH1cblxuICBsYXN0TW91c2VNb3ZlVGltZSA9IG5vdztcbn1cblxuLyoqXG4gKiBXaGVuIGFuIGVsZW1lbnQgaXMgaW4gZm9jdXMgYW5kIGhhcyBhIHRpcHB5LCBsZWF2aW5nIHRoZSB0YWIvd2luZG93IGFuZFxuICogcmV0dXJuaW5nIGNhdXNlcyBpdCB0byBzaG93IGFnYWluLiBGb3IgbW91c2UgdXNlcnMgdGhpcyBpcyB1bmV4cGVjdGVkLCBidXRcbiAqIGZvciBrZXlib2FyZCB1c2UgaXQgbWFrZXMgc2Vuc2UuXG4gKiBUT0RPOiBmaW5kIGEgYmV0dGVyIHRlY2huaXF1ZSB0byBzb2x2ZSB0aGlzIHByb2JsZW1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uV2luZG93Qmx1cigpOiB2b2lkIHtcbiAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xuXG4gIGlmIChpc1JlZmVyZW5jZUVsZW1lbnQoYWN0aXZlRWxlbWVudCkpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGFjdGl2ZUVsZW1lbnQuX3RpcHB5ITtcblxuICAgIGlmIChhY3RpdmVFbGVtZW50LmJsdXIgJiYgIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRHbG9iYWxFdmVudExpc3RlbmVycygpOiB2b2lkIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uRG9jdW1lbnRUb3VjaFN0YXJ0LCBUT1VDSF9PUFRJT05TKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbldpbmRvd0JsdXIpO1xufVxuIiwgImV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPVxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG5leHBvcnQgY29uc3QgaXNJRTExID0gaXNCcm93c2VyXG4gID8gLy8gQHRzLWlnbm9yZVxuICAgICEhd2luZG93Lm1zQ3J5cHRvXG4gIDogZmFsc2U7XG4iLCAiaW1wb3J0IHtUYXJnZXRzfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKG1ldGhvZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgdHh0ID0gbWV0aG9kID09PSAnZGVzdHJveScgPyAnbiBhbHJlYWR5LScgOiAnICc7XG5cbiAgcmV0dXJuIFtcbiAgICBgJHttZXRob2R9KCkgd2FzIGNhbGxlZCBvbiBhJHt0eHR9ZGVzdHJveWVkIGluc3RhbmNlLiBUaGlzIGlzIGEgbm8tb3AgYnV0YCxcbiAgICAnaW5kaWNhdGVzIGEgcG90ZW50aWFsIG1lbW9yeSBsZWFrLicsXG4gIF0uam9pbignICcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYW4odmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHNwYWNlc0FuZFRhYnMgPSAvWyBcXHRdezIsfS9nO1xuICBjb25zdCBsaW5lU3RhcnRXaXRoU3BhY2VzID0gL15bIFxcdF0qL2dtO1xuXG4gIHJldHVybiB2YWx1ZVxuICAgIC5yZXBsYWNlKHNwYWNlc0FuZFRhYnMsICcgJylcbiAgICAucmVwbGFjZShsaW5lU3RhcnRXaXRoU3BhY2VzLCAnJylcbiAgICAudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBnZXREZXZNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBjbGVhbihgXG4gICVjdGlwcHkuanNcblxuICAlYyR7Y2xlYW4obWVzc2FnZSl9XG5cbiAgJWPwn5G34oCNIFRoaXMgaXMgYSBkZXZlbG9wbWVudC1vbmx5IG1lc3NhZ2UuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uLlxuICBgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZvcm1hdHRlZE1lc3NhZ2UobWVzc2FnZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICByZXR1cm4gW1xuICAgIGdldERldk1lc3NhZ2UobWVzc2FnZSksXG4gICAgLy8gdGl0bGVcbiAgICAnY29sb3I6ICMwMEM1ODQ7IGZvbnQtc2l6ZTogMS4zZW07IGZvbnQtd2VpZ2h0OiBib2xkOycsXG4gICAgLy8gbWVzc2FnZVxuICAgICdsaW5lLWhlaWdodDogMS41JyxcbiAgICAvLyBmb290ZXJcbiAgICAnY29sb3I6ICNhNmEwOTU7JyxcbiAgXTtcbn1cblxuLy8gQXNzdW1lIHdhcm5pbmdzIGFuZCBlcnJvcnMgbmV2ZXIgaGF2ZSB0aGUgc2FtZSBtZXNzYWdlXG5sZXQgdmlzaXRlZE1lc3NhZ2VzOiBTZXQ8c3RyaW5nPjtcbmlmIChfX0RFVl9fKSB7XG4gIHJlc2V0VmlzaXRlZE1lc3NhZ2VzKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldFZpc2l0ZWRNZXNzYWdlcygpOiB2b2lkIHtcbiAgdmlzaXRlZE1lc3NhZ2VzID0gbmV3IFNldCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2FybldoZW4oY29uZGl0aW9uOiBib29sZWFuLCBtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKGNvbmRpdGlvbiAmJiAhdmlzaXRlZE1lc3NhZ2VzLmhhcyhtZXNzYWdlKSkge1xuICAgIHZpc2l0ZWRNZXNzYWdlcy5hZGQobWVzc2FnZSk7XG4gICAgY29uc29sZS53YXJuKC4uLmdldEZvcm1hdHRlZE1lc3NhZ2UobWVzc2FnZSkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvcldoZW4oY29uZGl0aW9uOiBib29sZWFuLCBtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKGNvbmRpdGlvbiAmJiAhdmlzaXRlZE1lc3NhZ2VzLmhhcyhtZXNzYWdlKSkge1xuICAgIHZpc2l0ZWRNZXNzYWdlcy5hZGQobWVzc2FnZSk7XG4gICAgY29uc29sZS5lcnJvciguLi5nZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVUYXJnZXRzKHRhcmdldHM6IFRhcmdldHMpOiB2b2lkIHtcbiAgY29uc3QgZGlkUGFzc0ZhbHN5VmFsdWUgPSAhdGFyZ2V0cztcbiAgY29uc3QgZGlkUGFzc1BsYWluT2JqZWN0ID1cbiAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFyZ2V0cykgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmXG4gICAgISh0YXJnZXRzIGFzIGFueSkuYWRkRXZlbnRMaXN0ZW5lcjtcblxuICBlcnJvcldoZW4oXG4gICAgZGlkUGFzc0ZhbHN5VmFsdWUsXG4gICAgW1xuICAgICAgJ3RpcHB5KCkgd2FzIHBhc3NlZCcsXG4gICAgICAnYCcgKyBTdHJpbmcodGFyZ2V0cykgKyAnYCcsXG4gICAgICAnYXMgaXRzIHRhcmdldHMgKGZpcnN0KSBhcmd1bWVudC4gVmFsaWQgdHlwZXMgYXJlOiBTdHJpbmcsIEVsZW1lbnQsJyxcbiAgICAgICdFbGVtZW50W10sIG9yIE5vZGVMaXN0LicsXG4gICAgXS5qb2luKCcgJylcbiAgKTtcblxuICBlcnJvcldoZW4oXG4gICAgZGlkUGFzc1BsYWluT2JqZWN0LFxuICAgIFtcbiAgICAgICd0aXBweSgpIHdhcyBwYXNzZWQgYSBwbGFpbiBvYmplY3Qgd2hpY2ggaXMgbm90IHN1cHBvcnRlZCBhcyBhbiBhcmd1bWVudCcsXG4gICAgICAnZm9yIHZpcnR1YWwgcG9zaXRpb25pbmcuIFVzZSBwcm9wcy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0IGluc3RlYWQuJyxcbiAgICBdLmpvaW4oJyAnKVxuICApO1xufVxuIiwgImltcG9ydCB7RGVmYXVsdFByb3BzLCBQbHVnaW4sIFByb3BzLCBSZWZlcmVuY2VFbGVtZW50LCBUaXBweX0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1xuICBoYXNPd25Qcm9wZXJ0eSxcbiAgcmVtb3ZlUHJvcGVydGllcyxcbiAgaW52b2tlV2l0aEFyZ3NPclJldHVybixcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge3dhcm5XaGVufSBmcm9tICcuL3ZhbGlkYXRpb24nO1xuaW1wb3J0IHtUSVBQWV9ERUZBVUxUX0FQUEVORF9UT30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5jb25zdCBwbHVnaW5Qcm9wcyA9IHtcbiAgYW5pbWF0ZUZpbGw6IGZhbHNlLFxuICBmb2xsb3dDdXJzb3I6IGZhbHNlLFxuICBpbmxpbmVQb3NpdGlvbmluZzogZmFsc2UsXG4gIHN0aWNreTogZmFsc2UsXG59O1xuXG5jb25zdCByZW5kZXJQcm9wcyA9IHtcbiAgYWxsb3dIVE1MOiBmYWxzZSxcbiAgYW5pbWF0aW9uOiAnZmFkZScsXG4gIGFycm93OiB0cnVlLFxuICBjb250ZW50OiAnJyxcbiAgaW5lcnRpYTogZmFsc2UsXG4gIG1heFdpZHRoOiAzNTAsXG4gIHJvbGU6ICd0b29sdGlwJyxcbiAgdGhlbWU6ICcnLFxuICB6SW5kZXg6IDk5OTksXG59O1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdFByb3BzOiBEZWZhdWx0UHJvcHMgPSB7XG4gIGFwcGVuZFRvOiBUSVBQWV9ERUZBVUxUX0FQUEVORF9UTyxcbiAgYXJpYToge1xuICAgIGNvbnRlbnQ6ICdhdXRvJyxcbiAgICBleHBhbmRlZDogJ2F1dG8nLFxuICB9LFxuICBkZWxheTogMCxcbiAgZHVyYXRpb246IFszMDAsIDI1MF0sXG4gIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IG51bGwsXG4gIGhpZGVPbkNsaWNrOiB0cnVlLFxuICBpZ25vcmVBdHRyaWJ1dGVzOiBmYWxzZSxcbiAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICBpbnRlcmFjdGl2ZUJvcmRlcjogMixcbiAgaW50ZXJhY3RpdmVEZWJvdW5jZTogMCxcbiAgbW92ZVRyYW5zaXRpb246ICcnLFxuICBvZmZzZXQ6IFswLCAxMF0sXG4gIG9uQWZ0ZXJVcGRhdGUoKSB7fSxcbiAgb25CZWZvcmVVcGRhdGUoKSB7fSxcbiAgb25DcmVhdGUoKSB7fSxcbiAgb25EZXN0cm95KCkge30sXG4gIG9uSGlkZGVuKCkge30sXG4gIG9uSGlkZSgpIHt9LFxuICBvbk1vdW50KCkge30sXG4gIG9uU2hvdygpIHt9LFxuICBvblNob3duKCkge30sXG4gIG9uVHJpZ2dlcigpIHt9LFxuICBvblVudHJpZ2dlcigpIHt9LFxuICBvbkNsaWNrT3V0c2lkZSgpIHt9LFxuICBwbGFjZW1lbnQ6ICd0b3AnLFxuICBwbHVnaW5zOiBbXSxcbiAgcG9wcGVyT3B0aW9uczoge30sXG4gIHJlbmRlcjogbnVsbCxcbiAgc2hvd09uQ3JlYXRlOiBmYWxzZSxcbiAgdG91Y2g6IHRydWUsXG4gIHRyaWdnZXI6ICdtb3VzZWVudGVyIGZvY3VzJyxcbiAgdHJpZ2dlclRhcmdldDogbnVsbCxcbiAgLi4ucGx1Z2luUHJvcHMsXG4gIC4uLnJlbmRlclByb3BzLFxufTtcblxuY29uc3QgZGVmYXVsdEtleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0UHJvcHMpO1xuXG5leHBvcnQgY29uc3Qgc2V0RGVmYXVsdFByb3BzOiBUaXBweVsnc2V0RGVmYXVsdFByb3BzJ10gPSAocGFydGlhbFByb3BzKSA9PiB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgdmFsaWRhdGVQcm9wcyhwYXJ0aWFsUHJvcHMsIFtdKTtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwYXJ0aWFsUHJvcHMpIGFzIEFycmF5PGtleW9mIERlZmF1bHRQcm9wcz47XG4gIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgKGRlZmF1bHRQcm9wcyBhcyBhbnkpW2tleV0gPSBwYXJ0aWFsUHJvcHNba2V5XTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wcyhcbiAgcGFzc2VkUHJvcHM6IFBhcnRpYWw8UHJvcHM+ICYgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbik6IFBhcnRpYWw8UHJvcHM+IHtcbiAgY29uc3QgcGx1Z2lucyA9IHBhc3NlZFByb3BzLnBsdWdpbnMgfHwgW107XG4gIGNvbnN0IHBsdWdpblByb3BzID0gcGx1Z2lucy5yZWR1Y2U8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KChhY2MsIHBsdWdpbikgPT4ge1xuICAgIGNvbnN0IHtuYW1lLCBkZWZhdWx0VmFsdWV9ID0gcGx1Z2luO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGFjY1tuYW1lXSA9XG4gICAgICAgIHBhc3NlZFByb3BzW25hbWVdICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHBhc3NlZFByb3BzW25hbWVdXG4gICAgICAgICAgOiAoZGVmYXVsdFByb3BzIGFzIGFueSlbbmFtZV0gPz8gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICByZXR1cm4ge1xuICAgIC4uLnBhc3NlZFByb3BzLFxuICAgIC4uLnBsdWdpblByb3BzLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YUF0dHJpYnV0ZVByb3BzKFxuICByZWZlcmVuY2U6IFJlZmVyZW5jZUVsZW1lbnQsXG4gIHBsdWdpbnM6IFBsdWdpbltdXG4pOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XG4gIGNvbnN0IHByb3BLZXlzID0gcGx1Z2luc1xuICAgID8gT2JqZWN0LmtleXMoZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wcyh7Li4uZGVmYXVsdFByb3BzLCBwbHVnaW5zfSkpXG4gICAgOiBkZWZhdWx0S2V5cztcblxuICBjb25zdCBwcm9wcyA9IHByb3BLZXlzLnJlZHVjZShcbiAgICAoYWNjOiBQYXJ0aWFsPFByb3BzPiAmIFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlQXNTdHJpbmcgPSAoXG4gICAgICAgIHJlZmVyZW5jZS5nZXRBdHRyaWJ1dGUoYGRhdGEtdGlwcHktJHtrZXl9YCkgfHwgJydcbiAgICAgICkudHJpbSgpO1xuXG4gICAgICBpZiAoIXZhbHVlQXNTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgIGFjY1trZXldID0gdmFsdWVBc1N0cmluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYWNjW2tleV0gPSBKU09OLnBhcnNlKHZhbHVlQXNTdHJpbmcpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZUFzU3RyaW5nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICB7fVxuICApO1xuXG4gIHJldHVybiBwcm9wcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2YWx1YXRlUHJvcHMoXG4gIHJlZmVyZW5jZTogUmVmZXJlbmNlRWxlbWVudCxcbiAgcHJvcHM6IFByb3BzXG4pOiBQcm9wcyB7XG4gIGNvbnN0IG91dCA9IHtcbiAgICAuLi5wcm9wcyxcbiAgICBjb250ZW50OiBpbnZva2VXaXRoQXJnc09yUmV0dXJuKHByb3BzLmNvbnRlbnQsIFtyZWZlcmVuY2VdKSxcbiAgICAuLi4ocHJvcHMuaWdub3JlQXR0cmlidXRlc1xuICAgICAgPyB7fVxuICAgICAgOiBnZXREYXRhQXR0cmlidXRlUHJvcHMocmVmZXJlbmNlLCBwcm9wcy5wbHVnaW5zKSksXG4gIH07XG5cbiAgb3V0LmFyaWEgPSB7XG4gICAgLi4uZGVmYXVsdFByb3BzLmFyaWEsXG4gICAgLi4ub3V0LmFyaWEsXG4gIH07XG5cbiAgb3V0LmFyaWEgPSB7XG4gICAgZXhwYW5kZWQ6XG4gICAgICBvdXQuYXJpYS5leHBhbmRlZCA9PT0gJ2F1dG8nID8gcHJvcHMuaW50ZXJhY3RpdmUgOiBvdXQuYXJpYS5leHBhbmRlZCxcbiAgICBjb250ZW50OlxuICAgICAgb3V0LmFyaWEuY29udGVudCA9PT0gJ2F1dG8nXG4gICAgICAgID8gcHJvcHMuaW50ZXJhY3RpdmVcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6ICdkZXNjcmliZWRieSdcbiAgICAgICAgOiBvdXQuYXJpYS5jb250ZW50LFxuICB9O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVByb3BzKFxuICBwYXJ0aWFsUHJvcHM6IFBhcnRpYWw8UHJvcHM+ID0ge30sXG4gIHBsdWdpbnM6IFBsdWdpbltdID0gW11cbik6IHZvaWQge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocGFydGlhbFByb3BzKSBhcyBBcnJheTxrZXlvZiBQcm9wcz47XG4gIGtleXMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGNvbnN0IG5vblBsdWdpblByb3BzID0gcmVtb3ZlUHJvcGVydGllcyhcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIE9iamVjdC5rZXlzKHBsdWdpblByb3BzKVxuICAgICk7XG5cbiAgICBsZXQgZGlkUGFzc1Vua25vd25Qcm9wID0gIWhhc093blByb3BlcnR5KG5vblBsdWdpblByb3BzLCBwcm9wKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBwcm9wIGV4aXN0cyBpbiBgcGx1Z2luc2BcbiAgICBpZiAoZGlkUGFzc1Vua25vd25Qcm9wKSB7XG4gICAgICBkaWRQYXNzVW5rbm93blByb3AgPVxuICAgICAgICBwbHVnaW5zLmZpbHRlcigocGx1Z2luKSA9PiBwbHVnaW4ubmFtZSA9PT0gcHJvcCkubGVuZ3RoID09PSAwO1xuICAgIH1cblxuICAgIHdhcm5XaGVuKFxuICAgICAgZGlkUGFzc1Vua25vd25Qcm9wLFxuICAgICAgW1xuICAgICAgICBgXFxgJHtwcm9wfVxcYGAsXG4gICAgICAgIFwiaXMgbm90IGEgdmFsaWQgcHJvcC4gWW91IG1heSBoYXZlIHNwZWxsZWQgaXQgaW5jb3JyZWN0bHksIG9yIGlmIGl0J3NcIixcbiAgICAgICAgJ2EgcGx1Z2luLCBmb3Jnb3QgdG8gcGFzcyBpdCBpbiBhbiBhcnJheSBhcyBwcm9wcy5wbHVnaW5zLicsXG4gICAgICAgICdcXG5cXG4nLFxuICAgICAgICAnQWxsIHByb3BzOiBodHRwczovL2F0b21pa3MuZ2l0aHViLmlvL3RpcHB5anMvdjYvYWxsLXByb3BzL1xcbicsXG4gICAgICAgICdQbHVnaW5zOiBodHRwczovL2F0b21pa3MuZ2l0aHViLmlvL3RpcHB5anMvdjYvcGx1Z2lucy8nLFxuICAgICAgXS5qb2luKCcgJylcbiAgICApO1xuICB9KTtcbn1cbiIsICJpbXBvcnQge1xuICBBUlJPV19DTEFTUyxcbiAgQkFDS0RST1BfQ0xBU1MsXG4gIEJPWF9DTEFTUyxcbiAgQ09OVEVOVF9DTEFTUyxcbiAgU1ZHX0FSUk9XX0NMQVNTLFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge2RpdiwgaXNFbGVtZW50fSBmcm9tICcuL2RvbS11dGlscyc7XG5pbXBvcnQge0luc3RhbmNlLCBQb3BwZXJFbGVtZW50LCBQcm9wc30gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1BvcHBlckNoaWxkcmVufSBmcm9tICcuL3R5cGVzLWludGVybmFsJztcbmltcG9ydCB7YXJyYXlGcm9tfSBmcm9tICcuL3V0aWxzJztcblxuLy8gRmlyZWZveCBleHRlbnNpb25zIGRvbid0IGFsbG93IC5pbm5lckhUTUwgPSBcIi4uLlwiIHByb3BlcnR5LiBUaGlzIHRyaWNrcyBpdC5cbmNvbnN0IGlubmVySFRNTCA9ICgpOiAnaW5uZXJIVE1MJyA9PiAnaW5uZXJIVE1MJztcblxuZnVuY3Rpb24gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwoZWxlbWVudDogRWxlbWVudCwgaHRtbDogc3RyaW5nKTogdm9pZCB7XG4gIGVsZW1lbnRbaW5uZXJIVE1MKCldID0gaHRtbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyb3dFbGVtZW50KHZhbHVlOiBQcm9wc1snYXJyb3cnXSk6IEhUTUxEaXZFbGVtZW50IHtcbiAgY29uc3QgYXJyb3cgPSBkaXYoKTtcblxuICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICBhcnJvdy5jbGFzc05hbWUgPSBBUlJPV19DTEFTUztcbiAgfSBlbHNlIHtcbiAgICBhcnJvdy5jbGFzc05hbWUgPSBTVkdfQVJST1dfQ0xBU1M7XG5cbiAgICBpZiAoaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAgYXJyb3cuYXBwZW5kQ2hpbGQodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTChhcnJvdywgdmFsdWUgYXMgc3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyb3c7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb250ZW50KGNvbnRlbnQ6IEhUTUxEaXZFbGVtZW50LCBwcm9wczogUHJvcHMpOiB2b2lkIHtcbiAgaWYgKGlzRWxlbWVudChwcm9wcy5jb250ZW50KSkge1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKGNvbnRlbnQsICcnKTtcbiAgICBjb250ZW50LmFwcGVuZENoaWxkKHByb3BzLmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wcy5jb250ZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb3BzLmFsbG93SFRNTCkge1xuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwoY29udGVudCwgcHJvcHMuY29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQudGV4dENvbnRlbnQgPSBwcm9wcy5jb250ZW50O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hpbGRyZW4ocG9wcGVyOiBQb3BwZXJFbGVtZW50KTogUG9wcGVyQ2hpbGRyZW4ge1xuICBjb25zdCBib3ggPSBwb3BwZXIuZmlyc3RFbGVtZW50Q2hpbGQgYXMgSFRNTERpdkVsZW1lbnQ7XG4gIGNvbnN0IGJveENoaWxkcmVuID0gYXJyYXlGcm9tKGJveC5jaGlsZHJlbik7XG5cbiAgcmV0dXJuIHtcbiAgICBib3gsXG4gICAgY29udGVudDogYm94Q2hpbGRyZW4uZmluZCgobm9kZSkgPT4gbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoQ09OVEVOVF9DTEFTUykpLFxuICAgIGFycm93OiBib3hDaGlsZHJlbi5maW5kKFxuICAgICAgKG5vZGUpID0+XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKEFSUk9XX0NMQVNTKSB8fFxuICAgICAgICBub2RlLmNsYXNzTGlzdC5jb250YWlucyhTVkdfQVJST1dfQ0xBU1MpXG4gICAgKSxcbiAgICBiYWNrZHJvcDogYm94Q2hpbGRyZW4uZmluZCgobm9kZSkgPT5cbiAgICAgIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKEJBQ0tEUk9QX0NMQVNTKVxuICAgICksXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIoXG4gIGluc3RhbmNlOiBJbnN0YW5jZVxuKToge1xuICBwb3BwZXI6IFBvcHBlckVsZW1lbnQ7XG4gIG9uVXBkYXRlPzogKHByZXZQcm9wczogUHJvcHMsIG5leHRQcm9wczogUHJvcHMpID0+IHZvaWQ7XG59IHtcbiAgY29uc3QgcG9wcGVyID0gZGl2KCk7XG5cbiAgY29uc3QgYm94ID0gZGl2KCk7XG4gIGJveC5jbGFzc05hbWUgPSBCT1hfQ0xBU1M7XG4gIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnLCAnaGlkZGVuJyk7XG4gIGJveC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG5cbiAgY29uc3QgY29udGVudCA9IGRpdigpO1xuICBjb250ZW50LmNsYXNzTmFtZSA9IENPTlRFTlRfQ0xBU1M7XG4gIGNvbnRlbnQuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywgJ2hpZGRlbicpO1xuXG4gIHNldENvbnRlbnQoY29udGVudCwgaW5zdGFuY2UucHJvcHMpO1xuXG4gIHBvcHBlci5hcHBlbmRDaGlsZChib3gpO1xuICBib3guYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgb25VcGRhdGUoaW5zdGFuY2UucHJvcHMsIGluc3RhbmNlLnByb3BzKTtcblxuICBmdW5jdGlvbiBvblVwZGF0ZShwcmV2UHJvcHM6IFByb3BzLCBuZXh0UHJvcHM6IFByb3BzKTogdm9pZCB7XG4gICAgY29uc3Qge2JveCwgY29udGVudCwgYXJyb3d9ID0gZ2V0Q2hpbGRyZW4ocG9wcGVyKTtcblxuICAgIGlmIChuZXh0UHJvcHMudGhlbWUpIHtcbiAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnLCBuZXh0UHJvcHMudGhlbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3gucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXRoZW1lJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXh0UHJvcHMuYW5pbWF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nLCBuZXh0UHJvcHMuYW5pbWF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dFByb3BzLmluZXJ0aWEpIHtcbiAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5lcnRpYScsICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1pbmVydGlhJyk7XG4gICAgfVxuXG4gICAgYm94LnN0eWxlLm1heFdpZHRoID1cbiAgICAgIHR5cGVvZiBuZXh0UHJvcHMubWF4V2lkdGggPT09ICdudW1iZXInXG4gICAgICAgID8gYCR7bmV4dFByb3BzLm1heFdpZHRofXB4YFxuICAgICAgICA6IG5leHRQcm9wcy5tYXhXaWR0aDtcblxuICAgIGlmIChuZXh0UHJvcHMucm9sZSkge1xuICAgICAgYm94LnNldEF0dHJpYnV0ZSgncm9sZScsIG5leHRQcm9wcy5yb2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHByZXZQcm9wcy5jb250ZW50ICE9PSBuZXh0UHJvcHMuY29udGVudCB8fFxuICAgICAgcHJldlByb3BzLmFsbG93SFRNTCAhPT0gbmV4dFByb3BzLmFsbG93SFRNTFxuICAgICkge1xuICAgICAgc2V0Q29udGVudChjb250ZW50LCBpbnN0YW5jZS5wcm9wcyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRQcm9wcy5hcnJvdykge1xuICAgICAgaWYgKCFhcnJvdykge1xuICAgICAgICBib3guYXBwZW5kQ2hpbGQoY3JlYXRlQXJyb3dFbGVtZW50KG5leHRQcm9wcy5hcnJvdykpO1xuICAgICAgfSBlbHNlIGlmIChwcmV2UHJvcHMuYXJyb3cgIT09IG5leHRQcm9wcy5hcnJvdykge1xuICAgICAgICBib3gucmVtb3ZlQ2hpbGQoYXJyb3cpO1xuICAgICAgICBib3guYXBwZW5kQ2hpbGQoY3JlYXRlQXJyb3dFbGVtZW50KG5leHRQcm9wcy5hcnJvdykpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJyb3cpIHtcbiAgICAgIGJveC5yZW1vdmVDaGlsZChhcnJvdyEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9wcGVyLFxuICAgIG9uVXBkYXRlLFxuICB9O1xufVxuXG4vLyBSdW50aW1lIGNoZWNrIHRvIGlkZW50aWZ5IGlmIHRoZSByZW5kZXIgZnVuY3Rpb24gaXMgdGhlIGRlZmF1bHQgb25lOyB0aGlzXG4vLyB3YXkgd2UgY2FuIGFwcGx5IGRlZmF1bHQgQ1NTIHRyYW5zaXRpb25zIGxvZ2ljIGFuZCBpdCBjYW4gYmUgdHJlZS1zaGFrZW4gYXdheVxucmVuZGVyLiQkdGlwcHkgPSB0cnVlO1xuIiwgImltcG9ydCB7Y3JlYXRlUG9wcGVyLCBTdHJpY3RNb2RpZmllcnMsIE1vZGlmaWVyfSBmcm9tICdAcG9wcGVyanMvY29yZSc7XG5pbXBvcnQge2N1cnJlbnRJbnB1dH0gZnJvbSAnLi9iaW5kR2xvYmFsRXZlbnRMaXN0ZW5lcnMnO1xuaW1wb3J0IHtpc0lFMTF9IGZyb20gJy4vYnJvd3Nlcic7XG5pbXBvcnQge1RJUFBZX0RFRkFVTFRfQVBQRU5EX1RPLCBUT1VDSF9PUFRJT05TfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBhY3R1YWxDb250YWlucyxcbiAgZGl2LFxuICBnZXRPd25lckRvY3VtZW50LFxuICBpc0N1cnNvck91dHNpZGVJbnRlcmFjdGl2ZUJvcmRlcixcbiAgaXNNb3VzZUV2ZW50LFxuICBzZXRUcmFuc2l0aW9uRHVyYXRpb24sXG4gIHNldFZpc2liaWxpdHlTdGF0ZSxcbiAgdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyLFxufSBmcm9tICcuL2RvbS11dGlscyc7XG5pbXBvcnQge2RlZmF1bHRQcm9wcywgZXZhbHVhdGVQcm9wcywgZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wc30gZnJvbSAnLi9wcm9wcyc7XG5pbXBvcnQge2dldENoaWxkcmVufSBmcm9tICcuL3RlbXBsYXRlJztcbmltcG9ydCB7XG4gIENvbnRlbnQsXG4gIEluc3RhbmNlLFxuICBMaWZlY3ljbGVIb29rcyxcbiAgUG9wcGVyRWxlbWVudCxcbiAgUHJvcHMsXG4gIFJlZmVyZW5jZUVsZW1lbnQsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtMaXN0ZW5lck9iamVjdCwgUG9wcGVyVHJlZURhdGEsIFBvcHBlckNoaWxkcmVufSBmcm9tICcuL3R5cGVzLWludGVybmFsJztcbmltcG9ydCB7XG4gIGFycmF5RnJvbSxcbiAgZGVib3VuY2UsXG4gIGdldFZhbHVlQXRJbmRleE9yUmV0dXJuLFxuICBpbnZva2VXaXRoQXJnc09yUmV0dXJuLFxuICBub3JtYWxpemVUb0FycmF5LFxuICBwdXNoSWZVbmlxdWUsXG4gIHNwbGl0QnlTcGFjZXMsXG4gIHVuaXF1ZSxcbiAgcmVtb3ZlVW5kZWZpbmVkUHJvcHMsXG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHtjcmVhdGVNZW1vcnlMZWFrV2FybmluZywgZXJyb3JXaGVuLCB3YXJuV2hlbn0gZnJvbSAnLi92YWxpZGF0aW9uJztcblxubGV0IGlkQ291bnRlciA9IDE7XG5sZXQgbW91c2VNb3ZlTGlzdGVuZXJzOiAoKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB2b2lkKVtdID0gW107XG5cbi8vIFVzZWQgYnkgYGhpZGVBbGwoKWBcbmV4cG9ydCBsZXQgbW91bnRlZEluc3RhbmNlczogSW5zdGFuY2VbXSA9IFtdO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVUaXBweShcbiAgcmVmZXJlbmNlOiBSZWZlcmVuY2VFbGVtZW50LFxuICBwYXNzZWRQcm9wczogUGFydGlhbDxQcm9wcz5cbik6IEluc3RhbmNlIHtcbiAgY29uc3QgcHJvcHMgPSBldmFsdWF0ZVByb3BzKHJlZmVyZW5jZSwge1xuICAgIC4uLmRlZmF1bHRQcm9wcyxcbiAgICAuLi5nZXRFeHRlbmRlZFBhc3NlZFByb3BzKHJlbW92ZVVuZGVmaW5lZFByb3BzKHBhc3NlZFByb3BzKSksXG4gIH0pO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyDwn5SSIFByaXZhdGUgbWVtYmVyc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgbGV0IHNob3dUaW1lb3V0OiBhbnk7XG4gIGxldCBoaWRlVGltZW91dDogYW55O1xuICBsZXQgc2NoZWR1bGVIaWRlQW5pbWF0aW9uRnJhbWU6IG51bWJlcjtcbiAgbGV0IGlzVmlzaWJsZUZyb21DbGljayA9IGZhbHNlO1xuICBsZXQgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24gPSBmYWxzZTtcbiAgbGV0IGRpZFRvdWNoTW92ZSA9IGZhbHNlO1xuICBsZXQgaWdub3JlT25GaXJzdFVwZGF0ZSA9IGZhbHNlO1xuICBsZXQgbGFzdFRyaWdnZXJFdmVudDogRXZlbnQgfCB1bmRlZmluZWQ7XG4gIGxldCBjdXJyZW50VHJhbnNpdGlvbkVuZExpc3RlbmVyOiAoZXZlbnQ6IFRyYW5zaXRpb25FdmVudCkgPT4gdm9pZDtcbiAgbGV0IG9uRmlyc3RVcGRhdGU6ICgpID0+IHZvaWQ7XG4gIGxldCBsaXN0ZW5lcnM6IExpc3RlbmVyT2JqZWN0W10gPSBbXTtcbiAgbGV0IGRlYm91bmNlZE9uTW91c2VNb3ZlID0gZGVib3VuY2Uob25Nb3VzZU1vdmUsIHByb3BzLmludGVyYWN0aXZlRGVib3VuY2UpO1xuICBsZXQgY3VycmVudFRhcmdldDogRWxlbWVudDtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8g8J+UkSBQdWJsaWMgbWVtYmVyc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgaWQgPSBpZENvdW50ZXIrKztcbiAgY29uc3QgcG9wcGVySW5zdGFuY2UgPSBudWxsO1xuICBjb25zdCBwbHVnaW5zID0gdW5pcXVlKHByb3BzLnBsdWdpbnMpO1xuXG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIC8vIElzIHRoZSBpbnN0YW5jZSBjdXJyZW50bHkgZW5hYmxlZD9cbiAgICBpc0VuYWJsZWQ6IHRydWUsXG4gICAgLy8gSXMgdGhlIHRpcHB5IGN1cnJlbnRseSBzaG93aW5nIGFuZCBub3QgdHJhbnNpdGlvbmluZyBvdXQ/XG4gICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAvLyBIYXMgdGhlIGluc3RhbmNlIGJlZW4gZGVzdHJveWVkP1xuICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAvLyBJcyB0aGUgdGlwcHkgY3VycmVudGx5IG1vdW50ZWQgdG8gdGhlIERPTT9cbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIC8vIEhhcyB0aGUgdGlwcHkgZmluaXNoZWQgdHJhbnNpdGlvbmluZyBpbj9cbiAgICBpc1Nob3duOiBmYWxzZSxcbiAgfTtcblxuICBjb25zdCBpbnN0YW5jZTogSW5zdGFuY2UgPSB7XG4gICAgLy8gcHJvcGVydGllc1xuICAgIGlkLFxuICAgIHJlZmVyZW5jZSxcbiAgICBwb3BwZXI6IGRpdigpLFxuICAgIHBvcHBlckluc3RhbmNlLFxuICAgIHByb3BzLFxuICAgIHN0YXRlLFxuICAgIHBsdWdpbnMsXG4gICAgLy8gbWV0aG9kc1xuICAgIGNsZWFyRGVsYXlUaW1lb3V0cyxcbiAgICBzZXRQcm9wcyxcbiAgICBzZXRDb250ZW50LFxuICAgIHNob3csXG4gICAgaGlkZSxcbiAgICBoaWRlV2l0aEludGVyYWN0aXZpdHksXG4gICAgZW5hYmxlLFxuICAgIGRpc2FibGUsXG4gICAgdW5tb3VudCxcbiAgICBkZXN0cm95LFxuICB9O1xuXG4gIC8vIFRPRE86IEludmVzdGlnYXRlIHdoeSB0aGlzIGVhcmx5IHJldHVybiBjYXVzZXMgYSBURFogZXJyb3IgaW4gdGhlIHRlc3RzIOKAlFxuICAvLyBpdCBkb2Vzbid0IHNlZW0gdG8gaGFwcGVuIGluIHRoZSBicm93c2VyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIXByb3BzLnJlbmRlcikge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBlcnJvcldoZW4odHJ1ZSwgJ3JlbmRlcigpIGZ1bmN0aW9uIGhhcyBub3QgYmVlbiBzdXBwbGllZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gSW5pdGlhbCBtdXRhdGlvbnNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IHtwb3BwZXIsIG9uVXBkYXRlfSA9IHByb3BzLnJlbmRlcihpbnN0YW5jZSk7XG5cbiAgcG9wcGVyLnNldEF0dHJpYnV0ZSgnZGF0YS1fX05BTUVTUEFDRV9QUkVGSVhfXy1yb290JywgJycpO1xuICBwb3BwZXIuaWQgPSBgX19OQU1FU1BBQ0VfUFJFRklYX18tJHtpbnN0YW5jZS5pZH1gO1xuXG4gIGluc3RhbmNlLnBvcHBlciA9IHBvcHBlcjtcbiAgcmVmZXJlbmNlLl90aXBweSA9IGluc3RhbmNlO1xuICBwb3BwZXIuX3RpcHB5ID0gaW5zdGFuY2U7XG5cbiAgY29uc3QgcGx1Z2luc0hvb2tzID0gcGx1Z2lucy5tYXAoKHBsdWdpbikgPT4gcGx1Z2luLmZuKGluc3RhbmNlKSk7XG4gIGNvbnN0IGhhc0FyaWFFeHBhbmRlZCA9IHJlZmVyZW5jZS5oYXNBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcblxuICBhZGRMaXN0ZW5lcnMoKTtcbiAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG4gIGhhbmRsZVN0eWxlcygpO1xuXG4gIGludm9rZUhvb2soJ29uQ3JlYXRlJywgW2luc3RhbmNlXSk7XG5cbiAgaWYgKHByb3BzLnNob3dPbkNyZWF0ZSkge1xuICAgIHNjaGVkdWxlU2hvdygpO1xuICB9XG5cbiAgLy8gUHJldmVudCBhIHRpcHB5IHdpdGggYSBkZWxheSBmcm9tIGhpZGluZyBpZiB0aGUgY3Vyc29yIGxlZnQgdGhlbiByZXR1cm5lZFxuICAvLyBiZWZvcmUgaXQgc3RhcnRlZCBoaWRpbmdcbiAgcG9wcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCAoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG4gICAgfVxuICB9KTtcblxuICBwb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsICgpID0+IHtcbiAgICBpZiAoXG4gICAgICBpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJlxuICAgICAgaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdtb3VzZWVudGVyJykgPj0gMFxuICAgICkge1xuICAgICAgZ2V0RG9jdW1lbnQoKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCflJIgUHJpdmF0ZSBtZXRob2RzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBmdW5jdGlvbiBnZXROb3JtYWxpemVkVG91Y2hTZXR0aW5ncygpOiBbc3RyaW5nIHwgYm9vbGVhbiwgbnVtYmVyXSB7XG4gICAgY29uc3Qge3RvdWNofSA9IGluc3RhbmNlLnByb3BzO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRvdWNoKSA/IHRvdWNoIDogW3RvdWNoLCAwXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElzQ3VzdG9tVG91Y2hCZWhhdmlvcigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZ2V0Tm9ybWFsaXplZFRvdWNoU2V0dGluZ3MoKVswXSA9PT0gJ2hvbGQnO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKTogYm9vbGVhbiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiAhIWluc3RhbmNlLnByb3BzLnJlbmRlcj8uJCR0aXBweTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRUYXJnZXQoKTogRWxlbWVudCB7XG4gICAgcmV0dXJuIGN1cnJlbnRUYXJnZXQgfHwgcmVmZXJlbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKTogRG9jdW1lbnQge1xuICAgIGNvbnN0IHBhcmVudCA9IGdldEN1cnJlbnRUYXJnZXQoKS5wYXJlbnROb2RlIGFzIEVsZW1lbnQ7XG4gICAgcmV0dXJuIHBhcmVudCA/IGdldE93bmVyRG9jdW1lbnQocGFyZW50KSA6IGRvY3VtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKTogUG9wcGVyQ2hpbGRyZW4ge1xuICAgIHJldHVybiBnZXRDaGlsZHJlbihwb3BwZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGVsYXkoaXNTaG93OiBib29sZWFuKTogbnVtYmVyIHtcbiAgICAvLyBGb3IgdG91Y2ggb3Iga2V5Ym9hcmQgaW5wdXQsIGZvcmNlIGAwYCBkZWxheSBmb3IgVVggcmVhc29uc1xuICAgIC8vIEFsc28gaWYgdGhlIGluc3RhbmNlIGlzIG1vdW50ZWQgYnV0IG5vdCB2aXNpYmxlICh0cmFuc2l0aW9uaW5nIG91dCksXG4gICAgLy8gaWdub3JlIGRlbGF5XG4gICAgaWYgKFxuICAgICAgKGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCAmJiAhaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB8fFxuICAgICAgY3VycmVudElucHV0LmlzVG91Y2ggfHxcbiAgICAgIChsYXN0VHJpZ2dlckV2ZW50ICYmIGxhc3RUcmlnZ2VyRXZlbnQudHlwZSA9PT0gJ2ZvY3VzJylcbiAgICApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRWYWx1ZUF0SW5kZXhPclJldHVybihcbiAgICAgIGluc3RhbmNlLnByb3BzLmRlbGF5LFxuICAgICAgaXNTaG93ID8gMCA6IDEsXG4gICAgICBkZWZhdWx0UHJvcHMuZGVsYXlcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3R5bGVzKGZyb21IaWRlID0gZmFsc2UpOiB2b2lkIHtcbiAgICBwb3BwZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9XG4gICAgICBpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJiAhZnJvbUhpZGUgPyAnJyA6ICdub25lJztcbiAgICBwb3BwZXIuc3R5bGUuekluZGV4ID0gYCR7aW5zdGFuY2UucHJvcHMuekluZGV4fWA7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VIb29rKFxuICAgIGhvb2s6IGtleW9mIExpZmVjeWNsZUhvb2tzLFxuICAgIGFyZ3M6IFtJbnN0YW5jZSwgYW55P10sXG4gICAgc2hvdWxkSW52b2tlUHJvcHNIb29rID0gdHJ1ZVxuICApOiB2b2lkIHtcbiAgICBwbHVnaW5zSG9va3MuZm9yRWFjaCgocGx1Z2luSG9va3MpID0+IHtcbiAgICAgIGlmIChwbHVnaW5Ib29rc1tob29rXSkge1xuICAgICAgICBwbHVnaW5Ib29rc1tob29rXSEoLi4uYXJncyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc2hvdWxkSW52b2tlUHJvcHNIb29rKSB7XG4gICAgICBpbnN0YW5jZS5wcm9wc1tob29rXSguLi5hcmdzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVBcmlhQ29udGVudEF0dHJpYnV0ZSgpOiB2b2lkIHtcbiAgICBjb25zdCB7YXJpYX0gPSBpbnN0YW5jZS5wcm9wcztcblxuICAgIGlmICghYXJpYS5jb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXR0ciA9IGBhcmlhLSR7YXJpYS5jb250ZW50fWA7XG4gICAgY29uc3QgaWQgPSBwb3BwZXIuaWQ7XG4gICAgY29uc3Qgbm9kZXMgPSBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcblxuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHIpO1xuXG4gICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIGN1cnJlbnRWYWx1ZSA/IGAke2N1cnJlbnRWYWx1ZX0gJHtpZH1gIDogaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5yZXBsYWNlKGlkLCAnJykudHJpbSgpO1xuXG4gICAgICAgIGlmIChuZXh0VmFsdWUpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCBuZXh0VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTogdm9pZCB7XG4gICAgaWYgKGhhc0FyaWFFeHBhbmRlZCB8fCAhaW5zdGFuY2UucHJvcHMuYXJpYS5leHBhbmRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGVzID0gbm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG5cbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnLFxuICAgICAgICAgIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSAmJiBub2RlID09PSBnZXRDdXJyZW50VGFyZ2V0KClcbiAgICAgICAgICAgID8gJ3RydWUnXG4gICAgICAgICAgICA6ICdmYWxzZSdcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycygpOiB2b2lkIHtcbiAgICBnZXREb2N1bWVudCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGRlYm91bmNlZE9uTW91c2VNb3ZlKTtcbiAgICBtb3VzZU1vdmVMaXN0ZW5lcnMgPSBtb3VzZU1vdmVMaXN0ZW5lcnMuZmlsdGVyKFxuICAgICAgKGxpc3RlbmVyKSA9PiBsaXN0ZW5lciAhPT0gZGVib3VuY2VkT25Nb3VzZU1vdmVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Eb2N1bWVudFByZXNzKGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCk6IHZvaWQge1xuICAgIC8vIE1vdmVkIGZpbmdlciB0byBzY3JvbGwgaW5zdGVhZCBvZiBhbiBpbnRlbnRpb25hbCB0YXAgb3V0c2lkZVxuICAgIGlmIChjdXJyZW50SW5wdXQuaXNUb3VjaCkge1xuICAgICAgaWYgKGRpZFRvdWNoTW92ZSB8fCBldmVudC50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYWN0dWFsVGFyZ2V0ID1cbiAgICAgIChldmVudC5jb21wb3NlZFBhdGggJiYgZXZlbnQuY29tcG9zZWRQYXRoKClbMF0pIHx8IGV2ZW50LnRhcmdldDtcblxuICAgIC8vIENsaWNrZWQgb24gaW50ZXJhY3RpdmUgcG9wcGVyXG4gICAgaWYgKFxuICAgICAgaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiZcbiAgICAgIGFjdHVhbENvbnRhaW5zKHBvcHBlciwgYWN0dWFsVGFyZ2V0IGFzIEVsZW1lbnQpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2xpY2tlZCBvbiB0aGUgZXZlbnQgbGlzdGVuZXJzIHRhcmdldFxuICAgIGlmIChcbiAgICAgIG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpLnNvbWUoKGVsKSA9PlxuICAgICAgICBhY3R1YWxDb250YWlucyhlbCwgYWN0dWFsVGFyZ2V0IGFzIEVsZW1lbnQpXG4gICAgICApXG4gICAgKSB7XG4gICAgICBpZiAoY3VycmVudElucHV0LmlzVG91Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSAmJlxuICAgICAgICBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2NsaWNrJykgPj0gMFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW52b2tlSG9vaygnb25DbGlja091dHNpZGUnLCBbaW5zdGFuY2UsIGV2ZW50XSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmhpZGVPbkNsaWNrID09PSB0cnVlKSB7XG4gICAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICAgIGluc3RhbmNlLmhpZGUoKTtcblxuICAgICAgLy8gYG1vdXNlZG93bmAgZXZlbnQgaXMgZmlyZWQgcmlnaHQgYmVmb3JlIGBmb2N1c2AgaWYgcHJlc3NpbmcgdGhlXG4gICAgICAvLyBjdXJyZW50VGFyZ2V0LiBUaGlzIGxldHMgYSB0aXBweSB3aXRoIGBmb2N1c2AgdHJpZ2dlciBrbm93IHRoYXQgaXRcbiAgICAgIC8vIHNob3VsZCBub3Qgc2hvd1xuICAgICAgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24gPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duID0gZmFsc2U7XG4gICAgICB9KTtcblxuICAgICAgLy8gVGhlIGxpc3RlbmVyIGdldHMgYWRkZWQgaW4gYHNjaGVkdWxlU2hvdygpYCwgYnV0IHRoaXMgbWF5IGJlIGhpZGluZyBpdFxuICAgICAgLy8gYmVmb3JlIGl0IHNob3dzLCBhbmQgaGlkZSgpJ3MgZWFybHkgYmFpbC1vdXQgYmVoYXZpb3IgY2FuIHByZXZlbnQgaXRcbiAgICAgIC8vIGZyb20gYmVpbmcgY2xlYW5lZCB1cFxuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgcmVtb3ZlRG9jdW1lbnRQcmVzcygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKCk6IHZvaWQge1xuICAgIGRpZFRvdWNoTW92ZSA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoU3RhcnQoKTogdm9pZCB7XG4gICAgZGlkVG91Y2hNb3ZlID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBhZGREb2N1bWVudFByZXNzKCk6IHZvaWQge1xuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KCk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uRG9jdW1lbnRQcmVzcywgdHJ1ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Eb2N1bWVudFByZXNzLCBUT1VDSF9PUFRJT05TKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgVE9VQ0hfT1BUSU9OUyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBUT1VDSF9PUFRJT05TKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZURvY3VtZW50UHJlc3MoKTogdm9pZCB7XG4gICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Eb2N1bWVudFByZXNzLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvbkRvY3VtZW50UHJlc3MsIFRPVUNIX09QVElPTlMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBUT1VDSF9PUFRJT05TKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIFRPVUNIX09QVElPTlMpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uZWRPdXQoZHVyYXRpb246IG51bWJlciwgY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBvblRyYW5zaXRpb25FbmQoZHVyYXRpb24sICgpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSAmJlxuICAgICAgICBwb3BwZXIucGFyZW50Tm9kZSAmJlxuICAgICAgICBwb3BwZXIucGFyZW50Tm9kZS5jb250YWlucyhwb3BwZXIpXG4gICAgICApIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbmVkSW4oZHVyYXRpb246IG51bWJlciwgY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBvblRyYW5zaXRpb25FbmQoZHVyYXRpb24sIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZChkdXJhdGlvbjogbnVtYmVyLCBjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIGNvbnN0IGJveCA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCkuYm94O1xuXG4gICAgZnVuY3Rpb24gbGlzdGVuZXIoZXZlbnQ6IFRyYW5zaXRpb25FdmVudCk6IHZvaWQge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gYm94KSB7XG4gICAgICAgIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcihib3gsICdyZW1vdmUnLCBsaXN0ZW5lcik7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFrZSBjYWxsYmFjayBzeW5jaHJvbm91cyBpZiBkdXJhdGlvbiBpcyAwXG4gICAgLy8gYHRyYW5zaXRpb25lbmRgIHdvbid0IGZpcmUgb3RoZXJ3aXNlXG4gICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIoYm94LCAncmVtb3ZlJywgY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lcik7XG4gICAgdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKGJveCwgJ2FkZCcsIGxpc3RlbmVyKTtcblxuICAgIGN1cnJlbnRUcmFuc2l0aW9uRW5kTGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uKFxuICAgIGV2ZW50VHlwZTogc3RyaW5nLFxuICAgIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIsXG4gICAgb3B0aW9uczogYm9vbGVhbiB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0gZmFsc2VcbiAgKTogdm9pZCB7XG4gICAgY29uc3Qgbm9kZXMgPSBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgIGxpc3RlbmVycy5wdXNoKHtub2RlLCBldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnN9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVycygpOiB2b2lkIHtcbiAgICBpZiAoZ2V0SXNDdXN0b21Ub3VjaEJlaGF2aW9yKCkpIHtcbiAgICAgIG9uKCd0b3VjaHN0YXJ0Jywgb25UcmlnZ2VyLCB7cGFzc2l2ZTogdHJ1ZX0pO1xuICAgICAgb24oJ3RvdWNoZW5kJywgb25Nb3VzZUxlYXZlIGFzIEV2ZW50TGlzdGVuZXIsIHtwYXNzaXZlOiB0cnVlfSk7XG4gICAgfVxuXG4gICAgc3BsaXRCeVNwYWNlcyhpbnN0YW5jZS5wcm9wcy50cmlnZ2VyKS5mb3JFYWNoKChldmVudFR5cGUpID0+IHtcbiAgICAgIGlmIChldmVudFR5cGUgPT09ICdtYW51YWwnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb24oZXZlbnRUeXBlLCBvblRyaWdnZXIpO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50VHlwZSkge1xuICAgICAgICBjYXNlICdtb3VzZWVudGVyJzpcbiAgICAgICAgICBvbignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSBhcyBFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgIG9uKGlzSUUxMSA/ICdmb2N1c291dCcgOiAnYmx1cicsIG9uQmx1ck9yRm9jdXNPdXQgYXMgRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZvY3VzaW4nOlxuICAgICAgICAgIG9uKCdmb2N1c291dCcsIG9uQmx1ck9yRm9jdXNPdXQgYXMgRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goKHtub2RlLCBldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnN9OiBMaXN0ZW5lck9iamVjdCkgPT4ge1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgbGlzdGVuZXJzID0gW107XG4gIH1cblxuICBmdW5jdGlvbiBvblRyaWdnZXIoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgbGV0IHNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlID0gZmFsc2U7XG5cbiAgICBpZiAoXG4gICAgICAhaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkIHx8XG4gICAgICBpc0V2ZW50TGlzdGVuZXJTdG9wcGVkKGV2ZW50KSB8fFxuICAgICAgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd25cbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB3YXNGb2N1c2VkID0gbGFzdFRyaWdnZXJFdmVudD8udHlwZSA9PT0gJ2ZvY3VzJztcblxuICAgIGxhc3RUcmlnZ2VyRXZlbnQgPSBldmVudDtcbiAgICBjdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBFbGVtZW50O1xuXG4gICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSAmJiBpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAvLyBJZiBzY3JvbGxpbmcsIGBtb3VzZWVudGVyYCBldmVudHMgY2FuIGJlIGZpcmVkIGlmIHRoZSBjdXJzb3IgbGFuZHNcbiAgICAgIC8vIG92ZXIgYSBuZXcgdGFyZ2V0LCBidXQgYG1vdXNlbW92ZWAgZXZlbnRzIGRvbid0IGdldCBmaXJlZC4gVGhpc1xuICAgICAgLy8gY2F1c2VzIGludGVyYWN0aXZlIHRvb2x0aXBzIHRvIGdldCBzdHVjayBvcGVuIHVudGlsIHRoZSBjdXJzb3IgaXNcbiAgICAgIC8vIG1vdmVkXG4gICAgICBtb3VzZU1vdmVMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKGV2ZW50KSk7XG4gICAgfVxuXG4gICAgLy8gVG9nZ2xlIHNob3cvaGlkZSB3aGVuIGNsaWNraW5nIGNsaWNrLXRyaWdnZXJlZCB0b29sdGlwc1xuICAgIGlmIChcbiAgICAgIGV2ZW50LnR5cGUgPT09ICdjbGljaycgJiZcbiAgICAgIChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ21vdXNlZW50ZXInKSA8IDAgfHxcbiAgICAgICAgaXNWaXNpYmxlRnJvbUNsaWNrKSAmJlxuICAgICAgaW5zdGFuY2UucHJvcHMuaGlkZU9uQ2xpY2sgIT09IGZhbHNlICYmXG4gICAgICBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGVcbiAgICApIHtcbiAgICAgIHNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVTaG93KGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgaXNWaXNpYmxlRnJvbUNsaWNrID0gIXNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRTY2hlZHVsZUNsaWNrSGlkZSAmJiAhd2FzRm9jdXNlZCkge1xuICAgICAgc2NoZWR1bGVIaWRlKGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBOb2RlO1xuICAgIGNvbnN0IGlzQ3Vyc29yT3ZlclJlZmVyZW5jZU9yUG9wcGVyID1cbiAgICAgIGdldEN1cnJlbnRUYXJnZXQoKS5jb250YWlucyh0YXJnZXQpIHx8IHBvcHBlci5jb250YWlucyh0YXJnZXQpO1xuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZW1vdmUnICYmIGlzQ3Vyc29yT3ZlclJlZmVyZW5jZU9yUG9wcGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcG9wcGVyVHJlZURhdGEgPSBnZXROZXN0ZWRQb3BwZXJUcmVlKClcbiAgICAgIC5jb25jYXQocG9wcGVyKVxuICAgICAgLm1hcCgocG9wcGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gcG9wcGVyLl90aXBweSE7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gaW5zdGFuY2UucG9wcGVySW5zdGFuY2U/LnN0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3BwZXJSZWN0OiBwb3BwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBwb3BwZXJTdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihCb29sZWFuKSBhcyBQb3BwZXJUcmVlRGF0YVtdO1xuXG4gICAgaWYgKGlzQ3Vyc29yT3V0c2lkZUludGVyYWN0aXZlQm9yZGVyKHBvcHBlclRyZWVEYXRhLCBldmVudCkpIHtcbiAgICAgIGNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzKCk7XG4gICAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW91c2VMZWF2ZShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IHNob3VsZEJhaWwgPVxuICAgICAgaXNFdmVudExpc3RlbmVyU3RvcHBlZChldmVudCkgfHxcbiAgICAgIChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2NsaWNrJykgPj0gMCAmJiBpc1Zpc2libGVGcm9tQ2xpY2spO1xuXG4gICAgaWYgKHNob3VsZEJhaWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUpIHtcbiAgICAgIGluc3RhbmNlLmhpZGVXaXRoSW50ZXJhY3Rpdml0eShldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2NoZWR1bGVIaWRlKGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQmx1ck9yRm9jdXNPdXQoZXZlbnQ6IEZvY3VzRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAoXG4gICAgICBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2ZvY3VzaW4nKSA8IDAgJiZcbiAgICAgIGV2ZW50LnRhcmdldCAhPT0gZ2V0Q3VycmVudFRhcmdldCgpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgZm9jdXMgd2FzIG1vdmVkIHRvIHdpdGhpbiB0aGUgcG9wcGVyXG4gICAgaWYgKFxuICAgICAgaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiZcbiAgICAgIGV2ZW50LnJlbGF0ZWRUYXJnZXQgJiZcbiAgICAgIHBvcHBlci5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0IGFzIEVsZW1lbnQpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2NoZWR1bGVIaWRlKGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRXZlbnRMaXN0ZW5lclN0b3BwZWQoZXZlbnQ6IEV2ZW50KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGN1cnJlbnRJbnB1dC5pc1RvdWNoXG4gICAgICA/IGdldElzQ3VzdG9tVG91Y2hCZWhhdmlvcigpICE9PSBldmVudC50eXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMFxuICAgICAgOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlckluc3RhbmNlKCk6IHZvaWQge1xuICAgIGRlc3Ryb3lQb3BwZXJJbnN0YW5jZSgpO1xuXG4gICAgY29uc3Qge1xuICAgICAgcG9wcGVyT3B0aW9ucyxcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIG9mZnNldCxcbiAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgICBtb3ZlVHJhbnNpdGlvbixcbiAgICB9ID0gaW5zdGFuY2UucHJvcHM7XG5cbiAgICBjb25zdCBhcnJvdyA9IGdldElzRGVmYXVsdFJlbmRlckZuKCkgPyBnZXRDaGlsZHJlbihwb3BwZXIpLmFycm93IDogbnVsbDtcblxuICAgIGNvbnN0IGNvbXB1dGVkUmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdFxuICAgICAgPyB7XG4gICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBnZXRSZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgICAgICAgIGNvbnRleHRFbGVtZW50OlxuICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdC5jb250ZXh0RWxlbWVudCB8fCBnZXRDdXJyZW50VGFyZ2V0KCksXG4gICAgICAgIH1cbiAgICAgIDogcmVmZXJlbmNlO1xuXG4gICAgY29uc3QgdGlwcHlNb2RpZmllcjogTW9kaWZpZXI8JyQkdGlwcHknLCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4gPSB7XG4gICAgICBuYW1lOiAnJCR0aXBweScsXG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gICAgICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ10sXG4gICAgICBmbih7c3RhdGV9KSB7XG4gICAgICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICAgICAgY29uc3Qge2JveH0gPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpO1xuXG4gICAgICAgICAgWydwbGFjZW1lbnQnLCAncmVmZXJlbmNlLWhpZGRlbicsICdlc2NhcGVkJ10uZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgICAgICAgaWYgKGF0dHIgPT09ICdwbGFjZW1lbnQnKSB7XG4gICAgICAgICAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGxhY2VtZW50Jywgc3RhdGUucGxhY2VtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlcltgZGF0YS1wb3BwZXItJHthdHRyfWBdKSB7XG4gICAgICAgICAgICAgICAgYm94LnNldEF0dHJpYnV0ZShgZGF0YS0ke2F0dHJ9YCwgJycpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtJHthdHRyfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IHt9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG5cbiAgICB0eXBlIFRpcHB5TW9kaWZpZXIgPSBNb2RpZmllcjwnJCR0aXBweScsIFJlY29yZDxzdHJpbmcsIHVua25vd24+PjtcbiAgICB0eXBlIEV4dGVuZGVkTW9kaWZpZXJzID0gU3RyaWN0TW9kaWZpZXJzIHwgUGFydGlhbDxUaXBweU1vZGlmaWVyPjtcblxuICAgIGNvbnN0IG1vZGlmaWVyczogQXJyYXk8RXh0ZW5kZWRNb2RpZmllcnM+ID0gW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgdG9wOiAyLFxuICAgICAgICAgICAgYm90dG9tOiAyLFxuICAgICAgICAgICAgbGVmdDogNSxcbiAgICAgICAgICAgIHJpZ2h0OiA1LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnZmxpcCcsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBwYWRkaW5nOiA1LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgYWRhcHRpdmU6ICFtb3ZlVHJhbnNpdGlvbixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB0aXBweU1vZGlmaWVyLFxuICAgIF07XG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSAmJiBhcnJvdykge1xuICAgICAgbW9kaWZpZXJzLnB1c2goe1xuICAgICAgICBuYW1lOiAnYXJyb3cnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgZWxlbWVudDogYXJyb3csXG4gICAgICAgICAgcGFkZGluZzogMyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZGlmaWVycy5wdXNoKC4uLihwb3BwZXJPcHRpb25zPy5tb2RpZmllcnMgfHwgW10pKTtcblxuICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlID0gY3JlYXRlUG9wcGVyPEV4dGVuZGVkTW9kaWZpZXJzPihcbiAgICAgIGNvbXB1dGVkUmVmZXJlbmNlLFxuICAgICAgcG9wcGVyLFxuICAgICAge1xuICAgICAgICAuLi5wb3BwZXJPcHRpb25zLFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG9uRmlyc3RVcGRhdGUsXG4gICAgICAgIG1vZGlmaWVycyxcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveVBvcHBlckluc3RhbmNlKCk6IHZvaWQge1xuICAgIGlmIChpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdW50KCk6IHZvaWQge1xuICAgIGNvbnN0IHthcHBlbmRUb30gPSBpbnN0YW5jZS5wcm9wcztcblxuICAgIGxldCBwYXJlbnROb2RlOiBhbnk7XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSdsbCBhcHBlbmQgdGhlIHBvcHBlciB0byB0aGUgdHJpZ2dlclRhcmdldHMncyBwYXJlbnROb2RlIHNvXG4gICAgLy8gaXQncyBkaXJlY3RseSBhZnRlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgc28gdGhlIGVsZW1lbnRzIGluc2lkZSB0aGVcbiAgICAvLyB0aXBweSBjYW4gYmUgdGFiYmVkIHRvXG4gICAgLy8gSWYgdGhlcmUgYXJlIGNsaXBwaW5nIGlzc3VlcywgdGhlIHVzZXIgY2FuIHNwZWNpZnkgYSBkaWZmZXJlbnQgYXBwZW5kVG9cbiAgICAvLyBhbmQgZW5zdXJlIGZvY3VzIG1hbmFnZW1lbnQgaXMgaGFuZGxlZCBjb3JyZWN0bHkgbWFudWFsbHlcbiAgICBjb25zdCBub2RlID0gZ2V0Q3VycmVudFRhcmdldCgpO1xuXG4gICAgaWYgKFxuICAgICAgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGFwcGVuZFRvID09PSBUSVBQWV9ERUZBVUxUX0FQUEVORF9UTykgfHxcbiAgICAgIGFwcGVuZFRvID09PSAncGFyZW50J1xuICAgICkge1xuICAgICAgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Tm9kZSA9IGludm9rZVdpdGhBcmdzT3JSZXR1cm4oYXBwZW5kVG8sIFtub2RlXSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIHBvcHBlciBlbGVtZW50IG5lZWRzIHRvIGV4aXN0IG9uIHRoZSBET00gYmVmb3JlIGl0cyBwb3NpdGlvbiBjYW4gYmVcbiAgICAvLyB1cGRhdGVkIGFzIFBvcHBlciBuZWVkcyB0byByZWFkIGl0cyBkaW1lbnNpb25zXG4gICAgaWYgKCFwYXJlbnROb2RlLmNvbnRhaW5zKHBvcHBlcikpIHtcbiAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQocG9wcGVyKTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgPSB0cnVlO1xuXG4gICAgY3JlYXRlUG9wcGVySW5zdGFuY2UoKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIC8vIEFjY2Vzc2liaWxpdHkgY2hlY2tcbiAgICAgIHdhcm5XaGVuKFxuICAgICAgICBpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJlxuICAgICAgICAgIGFwcGVuZFRvID09PSBkZWZhdWx0UHJvcHMuYXBwZW5kVG8gJiZcbiAgICAgICAgICBub2RlLm5leHRFbGVtZW50U2libGluZyAhPT0gcG9wcGVyLFxuICAgICAgICBbXG4gICAgICAgICAgJ0ludGVyYWN0aXZlIHRpcHB5IGVsZW1lbnQgbWF5IG5vdCBiZSBhY2Nlc3NpYmxlIHZpYSBrZXlib2FyZCcsXG4gICAgICAgICAgJ25hdmlnYXRpb24gYmVjYXVzZSBpdCBpcyBub3QgZGlyZWN0bHkgYWZ0ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50JyxcbiAgICAgICAgICAnaW4gdGhlIERPTSBzb3VyY2Ugb3JkZXIuJyxcbiAgICAgICAgICAnXFxuXFxuJyxcbiAgICAgICAgICAnVXNpbmcgYSB3cmFwcGVyIDxkaXY+IG9yIDxzcGFuPiB0YWcgYXJvdW5kIHRoZSByZWZlcmVuY2UgZWxlbWVudCcsXG4gICAgICAgICAgJ3NvbHZlcyB0aGlzIGJ5IGNyZWF0aW5nIGEgbmV3IHBhcmVudE5vZGUgY29udGV4dC4nLFxuICAgICAgICAgICdcXG5cXG4nLFxuICAgICAgICAgICdTcGVjaWZ5aW5nIGBhcHBlbmRUbzogZG9jdW1lbnQuYm9keWAgc2lsZW5jZXMgdGhpcyB3YXJuaW5nLCBidXQgaXQnLFxuICAgICAgICAgICdhc3N1bWVzIHlvdSBhcmUgdXNpbmcgYSBmb2N1cyBtYW5hZ2VtZW50IHNvbHV0aW9uIHRvIGhhbmRsZScsXG4gICAgICAgICAgJ2tleWJvYXJkIG5hdmlnYXRpb24uJyxcbiAgICAgICAgICAnXFxuXFxuJyxcbiAgICAgICAgICAnU2VlOiBodHRwczovL2F0b21pa3MuZ2l0aHViLmlvL3RpcHB5anMvdjYvYWNjZXNzaWJpbGl0eS8jaW50ZXJhY3Rpdml0eScsXG4gICAgICAgIF0uam9pbignICcpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5lc3RlZFBvcHBlclRyZWUoKTogUG9wcGVyRWxlbWVudFtdIHtcbiAgICByZXR1cm4gYXJyYXlGcm9tKFxuICAgICAgcG9wcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLV9fTkFNRVNQQUNFX1BSRUZJWF9fLXJvb3RdJylcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVTaG93KGV2ZW50PzogRXZlbnQpOiB2b2lkIHtcbiAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcblxuICAgIGlmIChldmVudCkge1xuICAgICAgaW52b2tlSG9vaygnb25UcmlnZ2VyJywgW2luc3RhbmNlLCBldmVudF0pO1xuICAgIH1cblxuICAgIGFkZERvY3VtZW50UHJlc3MoKTtcblxuICAgIGxldCBkZWxheSA9IGdldERlbGF5KHRydWUpO1xuICAgIGNvbnN0IFt0b3VjaFZhbHVlLCB0b3VjaERlbGF5XSA9IGdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzKCk7XG5cbiAgICBpZiAoY3VycmVudElucHV0LmlzVG91Y2ggJiYgdG91Y2hWYWx1ZSA9PT0gJ2hvbGQnICYmIHRvdWNoRGVsYXkpIHtcbiAgICAgIGRlbGF5ID0gdG91Y2hEZWxheTtcbiAgICB9XG5cbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIHNob3dUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGluc3RhbmNlLnNob3coKTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2Uuc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlSGlkZShldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcblxuICAgIGludm9rZUhvb2soJ29uVW50cmlnZ2VyJywgW2luc3RhbmNlLCBldmVudF0pO1xuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIHJlbW92ZURvY3VtZW50UHJlc3MoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZvciBpbnRlcmFjdGl2ZSB0aXBwaWVzLCBzY2hlZHVsZUhpZGUgaXMgYWRkZWQgdG8gYSBkb2N1bWVudC5ib2R5IGhhbmRsZXJcbiAgICAvLyBmcm9tIG9uTW91c2VMZWF2ZSBzbyBtdXN0IGludGVyY2VwdCBzY2hlZHVsZWQgaGlkZXMgZnJvbSBtb3VzZW1vdmUvbGVhdmVcbiAgICAvLyBldmVudHMgd2hlbiB0cmlnZ2VyIGNvbnRhaW5zIG1vdXNlZW50ZXIgYW5kIGNsaWNrLCBhbmQgdGhlIHRpcCBpc1xuICAgIC8vIGN1cnJlbnRseSBzaG93biBhcyBhIHJlc3VsdCBvZiBhIGNsaWNrLlxuICAgIGlmIChcbiAgICAgIGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignbW91c2VlbnRlcicpID49IDAgJiZcbiAgICAgIGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignY2xpY2snKSA+PSAwICYmXG4gICAgICBbJ21vdXNlbGVhdmUnLCAnbW91c2Vtb3ZlJ10uaW5kZXhPZihldmVudC50eXBlKSA+PSAwICYmXG4gICAgICBpc1Zpc2libGVGcm9tQ2xpY2tcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkZWxheSA9IGdldERlbGF5KGZhbHNlKTtcblxuICAgIGlmIChkZWxheSkge1xuICAgICAgaGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSwgZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaXhlcyBhIGB0cmFuc2l0aW9uZW5kYCBwcm9ibGVtIHdoZW4gaXQgZmlyZXMgMSBmcmFtZSB0b29cbiAgICAgIC8vIGxhdGUgc29tZXRpbWVzLCB3ZSBkb24ndCB3YW50IGhpZGUoKSB0byBiZSBjYWxsZWQuXG4gICAgICBzY2hlZHVsZUhpZGVBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyDwn5SRIFB1YmxpYyBtZXRob2RzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBmdW5jdGlvbiBlbmFibGUoKTogdm9pZCB7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc2FibGUoKTogdm9pZCB7XG4gICAgLy8gRGlzYWJsaW5nIHRoZSBpbnN0YW5jZSBzaG91bGQgYWxzbyBoaWRlIGl0XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F0b21pa3MvdGlwcHkuanMtcmVhY3QvaXNzdWVzLzEwNlxuICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyRGVsYXlUaW1lb3V0cygpOiB2b2lkIHtcbiAgICBjbGVhclRpbWVvdXQoc2hvd1RpbWVvdXQpO1xuICAgIGNsZWFyVGltZW91dChoaWRlVGltZW91dCk7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoc2NoZWR1bGVIaWRlQW5pbWF0aW9uRnJhbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJvcHMocGFydGlhbFByb3BzOiBQYXJ0aWFsPFByb3BzPik6IHZvaWQge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnc2V0UHJvcHMnKSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25CZWZvcmVVcGRhdGUnLCBbaW5zdGFuY2UsIHBhcnRpYWxQcm9wc10pO1xuXG4gICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG5cbiAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcbiAgICBjb25zdCBuZXh0UHJvcHMgPSBldmFsdWF0ZVByb3BzKHJlZmVyZW5jZSwge1xuICAgICAgLi4ucHJldlByb3BzLFxuICAgICAgLi4ucmVtb3ZlVW5kZWZpbmVkUHJvcHMocGFydGlhbFByb3BzKSxcbiAgICAgIGlnbm9yZUF0dHJpYnV0ZXM6IHRydWUsXG4gICAgfSk7XG5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IG5leHRQcm9wcztcblxuICAgIGFkZExpc3RlbmVycygpO1xuXG4gICAgaWYgKHByZXZQcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlICE9PSBuZXh0UHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSkge1xuICAgICAgY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKTtcbiAgICAgIGRlYm91bmNlZE9uTW91c2VNb3ZlID0gZGVib3VuY2UoXG4gICAgICAgIG9uTW91c2VNb3ZlLFxuICAgICAgICBuZXh0UHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgc3RhbGUgYXJpYS1leHBhbmRlZCBhdHRyaWJ1dGVzIGFyZSByZW1vdmVkXG4gICAgaWYgKHByZXZQcm9wcy50cmlnZ2VyVGFyZ2V0ICYmICFuZXh0UHJvcHMudHJpZ2dlclRhcmdldCkge1xuICAgICAgbm9ybWFsaXplVG9BcnJheShwcmV2UHJvcHMudHJpZ2dlclRhcmdldCkuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcHMudHJpZ2dlclRhcmdldCkge1xuICAgICAgcmVmZXJlbmNlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICAgIH1cblxuICAgIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuICAgIGhhbmRsZVN0eWxlcygpO1xuXG4gICAgaWYgKG9uVXBkYXRlKSB7XG4gICAgICBvblVwZGF0ZShwcmV2UHJvcHMsIG5leHRQcm9wcyk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICBjcmVhdGVQb3BwZXJJbnN0YW5jZSgpO1xuXG4gICAgICAvLyBGaXhlcyBhbiBpc3N1ZSB3aXRoIG5lc3RlZCB0aXBwaWVzIGlmIHRoZXkgYXJlIGFsbCBnZXR0aW5nIHJlLXJlbmRlcmVkLFxuICAgICAgLy8gYW5kIHRoZSBuZXN0ZWQgb25lcyBnZXQgcmUtcmVuZGVyZWQgZmlyc3QuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXRvbWlrcy90aXBweWpzLXJlYWN0L2lzc3Vlcy8xNzdcbiAgICAgIC8vIFRPRE86IGZpbmQgYSBjbGVhbmVyIC8gbW9yZSBlZmZpY2llbnQgc29sdXRpb24oISlcbiAgICAgIGdldE5lc3RlZFBvcHBlclRyZWUoKS5mb3JFYWNoKChuZXN0ZWRQb3BwZXIpID0+IHtcbiAgICAgICAgLy8gUmVhY3QgKGFuZCBvdGhlciBVSSBsaWJzIGxpa2VseSkgcmVxdWlyZXMgYSByQUYgd3JhcHBlciBhcyBpdCBmbHVzaGVzXG4gICAgICAgIC8vIGl0cyB3b3JrIGluIG9uZVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobmVzdGVkUG9wcGVyLl90aXBweSEucG9wcGVySW5zdGFuY2UhLmZvcmNlVXBkYXRlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGludm9rZUhvb2soJ29uQWZ0ZXJVcGRhdGUnLCBbaW5zdGFuY2UsIHBhcnRpYWxQcm9wc10pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q29udGVudChjb250ZW50OiBDb250ZW50KTogdm9pZCB7XG4gICAgaW5zdGFuY2Uuc2V0UHJvcHMoe2NvbnRlbnR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3coKTogdm9pZCB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdzaG93JykpO1xuICAgIH1cblxuICAgIC8vIEVhcmx5IGJhaWwtb3V0XG4gICAgY29uc3QgaXNBbHJlYWR5VmlzaWJsZSA9IGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZTtcbiAgICBjb25zdCBpc0Rlc3Ryb3llZCA9IGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkO1xuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSAhaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkO1xuICAgIGNvbnN0IGlzVG91Y2hBbmRUb3VjaERpc2FibGVkID1cbiAgICAgIGN1cnJlbnRJbnB1dC5pc1RvdWNoICYmICFpbnN0YW5jZS5wcm9wcy50b3VjaDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKFxuICAgICAgaW5zdGFuY2UucHJvcHMuZHVyYXRpb24sXG4gICAgICAwLFxuICAgICAgZGVmYXVsdFByb3BzLmR1cmF0aW9uXG4gICAgKTtcblxuICAgIGlmIChcbiAgICAgIGlzQWxyZWFkeVZpc2libGUgfHxcbiAgICAgIGlzRGVzdHJveWVkIHx8XG4gICAgICBpc0Rpc2FibGVkIHx8XG4gICAgICBpc1RvdWNoQW5kVG91Y2hEaXNhYmxlZFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBgZGlzYWJsZWRgIGJlaGF2aW9yIGFjcm9zcyBicm93c2Vycy5cbiAgICAvLyBGaXJlZm94IGFsbG93cyBldmVudHMgb24gZGlzYWJsZWQgZWxlbWVudHMsIGJ1dCBDaHJvbWUgZG9lc24ndC5cbiAgICAvLyBVc2luZyBhIHdyYXBwZXIgZWxlbWVudCAoaS5lLiA8c3Bhbj4pIGlzIHJlY29tbWVuZGVkLlxuICAgIGlmIChnZXRDdXJyZW50VGFyZ2V0KCkuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25TaG93JywgW2luc3RhbmNlXSwgZmFsc2UpO1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5vblNob3coaW5zdGFuY2UpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSA9IHRydWU7XG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgcG9wcGVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgfVxuXG4gICAgaGFuZGxlU3R5bGVzKCk7XG4gICAgYWRkRG9jdW1lbnRQcmVzcygpO1xuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgIHBvcHBlci5zdHlsZS50cmFuc2l0aW9uID0gJ25vbmUnO1xuICAgIH1cblxuICAgIC8vIElmIGZsaXBwaW5nIHRvIHRoZSBvcHBvc2l0ZSBzaWRlIGFmdGVyIGhpZGluZyBhdCBsZWFzdCBvbmNlLCB0aGVcbiAgICAvLyBhbmltYXRpb24gd2lsbCB1c2UgdGhlIHdyb25nIHBsYWNlbWVudCB3aXRob3V0IHJlc2V0dGluZyB0aGUgZHVyYXRpb25cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgY29uc3Qge2JveCwgY29udGVudH0gPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpO1xuICAgICAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFtib3gsIGNvbnRlbnRdLCAwKTtcbiAgICB9XG5cbiAgICBvbkZpcnN0VXBkYXRlID0gKCk6IHZvaWQgPT4ge1xuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgfHwgaWdub3JlT25GaXJzdFVwZGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlnbm9yZU9uRmlyc3RVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAvLyByZWZsb3dcbiAgICAgIHZvaWQgcG9wcGVyLm9mZnNldEhlaWdodDtcblxuICAgICAgcG9wcGVyLnN0eWxlLnRyYW5zaXRpb24gPSBpbnN0YW5jZS5wcm9wcy5tb3ZlVHJhbnNpdGlvbjtcblxuICAgICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkgJiYgaW5zdGFuY2UucHJvcHMuYW5pbWF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHtib3gsIGNvbnRlbnR9ID0gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKTtcbiAgICAgICAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFtib3gsIGNvbnRlbnRdLCBkdXJhdGlvbik7XG4gICAgICAgIHNldFZpc2liaWxpdHlTdGF0ZShbYm94LCBjb250ZW50XSwgJ3Zpc2libGUnKTtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlQXJpYUNvbnRlbnRBdHRyaWJ1dGUoKTtcbiAgICAgIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuXG4gICAgICBwdXNoSWZVbmlxdWUobW91bnRlZEluc3RhbmNlcywgaW5zdGFuY2UpO1xuXG4gICAgICAvLyBjZXJ0YWluIG1vZGlmaWVycyAoZS5nLiBgbWF4U2l6ZWApIHJlcXVpcmUgYSBzZWNvbmQgdXBkYXRlIGFmdGVyIHRoZVxuICAgICAgLy8gcG9wcGVyIGhhcyBiZWVuIHBvc2l0aW9uZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZT8uZm9yY2VVcGRhdGUoKTtcblxuICAgICAgaW52b2tlSG9vaygnb25Nb3VudCcsIFtpbnN0YW5jZV0pO1xuXG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuYW5pbWF0aW9uICYmIGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgICAgb25UcmFuc2l0aW9uZWRJbihkdXJhdGlvbiwgKCkgPT4ge1xuICAgICAgICAgIGluc3RhbmNlLnN0YXRlLmlzU2hvd24gPSB0cnVlO1xuICAgICAgICAgIGludm9rZUhvb2soJ29uU2hvd24nLCBbaW5zdGFuY2VdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIG1vdW50KCk7XG4gIH1cblxuICBmdW5jdGlvbiBoaWRlKCk6IHZvaWQge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnaGlkZScpKTtcbiAgICB9XG5cbiAgICAvLyBFYXJseSBiYWlsLW91dFxuICAgIGNvbnN0IGlzQWxyZWFkeUhpZGRlbiA9ICFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGU7XG4gICAgY29uc3QgaXNEZXN0cm95ZWQgPSBpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZDtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gIWluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKFxuICAgICAgaW5zdGFuY2UucHJvcHMuZHVyYXRpb24sXG4gICAgICAxLFxuICAgICAgZGVmYXVsdFByb3BzLmR1cmF0aW9uXG4gICAgKTtcblxuICAgIGlmIChpc0FscmVhZHlIaWRkZW4gfHwgaXNEZXN0cm95ZWQgfHwgaXNEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludm9rZUhvb2soJ29uSGlkZScsIFtpbnN0YW5jZV0sIGZhbHNlKTtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMub25IaWRlKGluc3RhbmNlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc1Nob3duID0gZmFsc2U7XG4gICAgaWdub3JlT25GaXJzdFVwZGF0ZSA9IGZhbHNlO1xuICAgIGlzVmlzaWJsZUZyb21DbGljayA9IGZhbHNlO1xuXG4gICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgIHBvcHBlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgfVxuXG4gICAgY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKTtcbiAgICByZW1vdmVEb2N1bWVudFByZXNzKCk7XG4gICAgaGFuZGxlU3R5bGVzKHRydWUpO1xuXG4gICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgIGNvbnN0IHtib3gsIGNvbnRlbnR9ID0gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKTtcblxuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmFuaW1hdGlvbikge1xuICAgICAgICBzZXRUcmFuc2l0aW9uRHVyYXRpb24oW2JveCwgY29udGVudF0sIGR1cmF0aW9uKTtcbiAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtib3gsIGNvbnRlbnRdLCAnaGlkZGVuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlQXJpYUNvbnRlbnRBdHRyaWJ1dGUoKTtcbiAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hbmltYXRpb24pIHtcbiAgICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICAgIG9uVHJhbnNpdGlvbmVkT3V0KGR1cmF0aW9uLCBpbnN0YW5jZS51bm1vdW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UudW5tb3VudCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZGVXaXRoSW50ZXJhY3Rpdml0eShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIHdhcm5XaGVuKFxuICAgICAgICBpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCxcbiAgICAgICAgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ2hpZGVXaXRoSW50ZXJhY3Rpdml0eScpXG4gICAgICApO1xuICAgIH1cblxuICAgIGdldERvY3VtZW50KCkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIHB1c2hJZlVuaXF1ZShtb3VzZU1vdmVMaXN0ZW5lcnMsIGRlYm91bmNlZE9uTW91c2VNb3ZlKTtcbiAgICBkZWJvdW5jZWRPbk1vdXNlTW92ZShldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50KCk6IHZvaWQge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygndW5tb3VudCcpKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZXN0cm95UG9wcGVySW5zdGFuY2UoKTtcblxuICAgIC8vIElmIGEgcG9wcGVyIGlzIG5vdCBpbnRlcmFjdGl2ZSwgaXQgd2lsbCBiZSBhcHBlbmRlZCBvdXRzaWRlIHRoZSBwb3BwZXJcbiAgICAvLyB0cmVlIGJ5IGRlZmF1bHQuIFRoaXMgc2VlbXMgbWFpbmx5IGZvciBpbnRlcmFjdGl2ZSB0aXBwaWVzLCBidXQgd2Ugc2hvdWxkXG4gICAgLy8gZmluZCBhIHdvcmthcm91bmQgaWYgcG9zc2libGVcbiAgICBnZXROZXN0ZWRQb3BwZXJUcmVlKCkuZm9yRWFjaCgobmVzdGVkUG9wcGVyKSA9PiB7XG4gICAgICBuZXN0ZWRQb3BwZXIuX3RpcHB5IS51bm1vdW50KCk7XG4gICAgfSk7XG5cbiAgICBpZiAocG9wcGVyLnBhcmVudE5vZGUpIHtcbiAgICAgIHBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBvcHBlcik7XG4gICAgfVxuXG4gICAgbW91bnRlZEluc3RhbmNlcyA9IG1vdW50ZWRJbnN0YW5jZXMuZmlsdGVyKChpKSA9PiBpICE9PSBpbnN0YW5jZSk7XG5cbiAgICBpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICBpbnZva2VIb29rKCdvbkhpZGRlbicsIFtpbnN0YW5jZV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpOiB2b2lkIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ2Rlc3Ryb3knKSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG4gICAgaW5zdGFuY2UudW5tb3VudCgpO1xuXG4gICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG5cbiAgICBkZWxldGUgcmVmZXJlbmNlLl90aXBweTtcblxuICAgIGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkID0gdHJ1ZTtcblxuICAgIGludm9rZUhvb2soJ29uRGVzdHJveScsIFtpbnN0YW5jZV0pO1xuICB9XG59XG4iLCAiaW1wb3J0IGJpbmRHbG9iYWxFdmVudExpc3RlbmVycywge1xuICBjdXJyZW50SW5wdXQsXG59IGZyb20gJy4vYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzJztcbmltcG9ydCBjcmVhdGVUaXBweSwge21vdW50ZWRJbnN0YW5jZXN9IGZyb20gJy4vY3JlYXRlVGlwcHknO1xuaW1wb3J0IHtnZXRBcnJheU9mRWxlbWVudHMsIGlzRWxlbWVudCwgaXNSZWZlcmVuY2VFbGVtZW50fSBmcm9tICcuL2RvbS11dGlscyc7XG5pbXBvcnQge2RlZmF1bHRQcm9wcywgc2V0RGVmYXVsdFByb3BzLCB2YWxpZGF0ZVByb3BzfSBmcm9tICcuL3Byb3BzJztcbmltcG9ydCB7SGlkZUFsbCwgSGlkZUFsbE9wdGlvbnMsIEluc3RhbmNlLCBQcm9wcywgVGFyZ2V0c30gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge3ZhbGlkYXRlVGFyZ2V0cywgd2FybldoZW59IGZyb20gJy4vdmFsaWRhdGlvbic7XG5cbmZ1bmN0aW9uIHRpcHB5KFxuICB0YXJnZXRzOiBUYXJnZXRzLFxuICBvcHRpb25hbFByb3BzOiBQYXJ0aWFsPFByb3BzPiA9IHt9XG4pOiBJbnN0YW5jZSB8IEluc3RhbmNlW10ge1xuICBjb25zdCBwbHVnaW5zID0gZGVmYXVsdFByb3BzLnBsdWdpbnMuY29uY2F0KG9wdGlvbmFsUHJvcHMucGx1Z2lucyB8fCBbXSk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKF9fREVWX18pIHtcbiAgICB2YWxpZGF0ZVRhcmdldHModGFyZ2V0cyk7XG4gICAgdmFsaWRhdGVQcm9wcyhvcHRpb25hbFByb3BzLCBwbHVnaW5zKTtcbiAgfVxuXG4gIGJpbmRHbG9iYWxFdmVudExpc3RlbmVycygpO1xuXG4gIGNvbnN0IHBhc3NlZFByb3BzOiBQYXJ0aWFsPFByb3BzPiA9IHsuLi5vcHRpb25hbFByb3BzLCBwbHVnaW5zfTtcblxuICBjb25zdCBlbGVtZW50cyA9IGdldEFycmF5T2ZFbGVtZW50cyh0YXJnZXRzKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoX19ERVZfXykge1xuICAgIGNvbnN0IGlzU2luZ2xlQ29udGVudEVsZW1lbnQgPSBpc0VsZW1lbnQocGFzc2VkUHJvcHMuY29udGVudCk7XG4gICAgY29uc3QgaXNNb3JlVGhhbk9uZVJlZmVyZW5jZUVsZW1lbnQgPSBlbGVtZW50cy5sZW5ndGggPiAxO1xuICAgIHdhcm5XaGVuKFxuICAgICAgaXNTaW5nbGVDb250ZW50RWxlbWVudCAmJiBpc01vcmVUaGFuT25lUmVmZXJlbmNlRWxlbWVudCxcbiAgICAgIFtcbiAgICAgICAgJ3RpcHB5KCkgd2FzIHBhc3NlZCBhbiBFbGVtZW50IGFzIHRoZSBgY29udGVudGAgcHJvcCwgYnV0IG1vcmUgdGhhbicsXG4gICAgICAgICdvbmUgdGlwcHkgaW5zdGFuY2Ugd2FzIGNyZWF0ZWQgYnkgdGhpcyBpbnZvY2F0aW9uLiBUaGlzIG1lYW5zIHRoZScsXG4gICAgICAgICdjb250ZW50IGVsZW1lbnQgd2lsbCBvbmx5IGJlIGFwcGVuZGVkIHRvIHRoZSBsYXN0IHRpcHB5IGluc3RhbmNlLicsXG4gICAgICAgICdcXG5cXG4nLFxuICAgICAgICAnSW5zdGVhZCwgcGFzcyB0aGUgLmlubmVySFRNTCBvZiB0aGUgZWxlbWVudCwgb3IgdXNlIGEgZnVuY3Rpb24gdGhhdCcsXG4gICAgICAgICdyZXR1cm5zIGEgY2xvbmVkIHZlcnNpb24gb2YgdGhlIGVsZW1lbnQgaW5zdGVhZC4nLFxuICAgICAgICAnXFxuXFxuJyxcbiAgICAgICAgJzEpIGNvbnRlbnQ6IGVsZW1lbnQuaW5uZXJIVE1MXFxuJyxcbiAgICAgICAgJzIpIGNvbnRlbnQ6ICgpID0+IGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpJyxcbiAgICAgIF0uam9pbignICcpXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGluc3RhbmNlcyA9IGVsZW1lbnRzLnJlZHVjZTxJbnN0YW5jZVtdPihcbiAgICAoYWNjLCByZWZlcmVuY2UpOiBJbnN0YW5jZVtdID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gcmVmZXJlbmNlICYmIGNyZWF0ZVRpcHB5KHJlZmVyZW5jZSwgcGFzc2VkUHJvcHMpO1xuXG4gICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgYWNjLnB1c2goaW5zdGFuY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sXG4gICAgW11cbiAgKTtcblxuICByZXR1cm4gaXNFbGVtZW50KHRhcmdldHMpID8gaW5zdGFuY2VzWzBdIDogaW5zdGFuY2VzO1xufVxuXG50aXBweS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG50aXBweS5zZXREZWZhdWx0UHJvcHMgPSBzZXREZWZhdWx0UHJvcHM7XG50aXBweS5jdXJyZW50SW5wdXQgPSBjdXJyZW50SW5wdXQ7XG5cbmV4cG9ydCBkZWZhdWx0IHRpcHB5O1xuXG5leHBvcnQgY29uc3QgaGlkZUFsbDogSGlkZUFsbCA9ICh7XG4gIGV4Y2x1ZGU6IGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSxcbiAgZHVyYXRpb24sXG59OiBIaWRlQWxsT3B0aW9ucyA9IHt9KSA9PiB7XG4gIG1vdW50ZWRJbnN0YW5jZXMuZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICBsZXQgaXNFeGNsdWRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSkge1xuICAgICAgaXNFeGNsdWRlZCA9IGlzUmVmZXJlbmNlRWxlbWVudChleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UpXG4gICAgICAgID8gaW5zdGFuY2UucmVmZXJlbmNlID09PSBleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2VcbiAgICAgICAgOiBpbnN0YW5jZS5wb3BwZXIgPT09IChleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UgYXMgSW5zdGFuY2UpLnBvcHBlcjtcbiAgICB9XG5cbiAgICBpZiAoIWlzRXhjbHVkZWQpIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsRHVyYXRpb24gPSBpbnN0YW5jZS5wcm9wcy5kdXJhdGlvbjtcblxuICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe2R1cmF0aW9ufSk7XG4gICAgICBpbnN0YW5jZS5oaWRlKCk7XG5cbiAgICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe2R1cmF0aW9uOiBvcmlnaW5hbER1cmF0aW9ufSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG4iLCAiaW1wb3J0IHRpcHB5IGZyb20gJy4uJztcbmltcG9ydCB7ZGl2fSBmcm9tICcuLi9kb20tdXRpbHMnO1xuaW1wb3J0IHtcbiAgQ3JlYXRlU2luZ2xldG9uLFxuICBQbHVnaW4sXG4gIENyZWF0ZVNpbmdsZXRvblByb3BzLFxuICBSZWZlcmVuY2VFbGVtZW50LFxuICBDcmVhdGVTaW5nbGV0b25JbnN0YW5jZSxcbiAgSW5zdGFuY2UsXG4gIFByb3BzLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge25vcm1hbGl6ZVRvQXJyYXksIHJlbW92ZVByb3BlcnRpZXN9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7ZXJyb3JXaGVufSBmcm9tICcuLi92YWxpZGF0aW9uJztcbmltcG9ydCB7YXBwbHlTdHlsZXMsIE1vZGlmaWVyfSBmcm9tICdAcG9wcGVyanMvY29yZSc7XG5cbi8vIFRoZSBkZWZhdWx0IGBhcHBseVN0eWxlc2AgbW9kaWZpZXIgaGFzIGEgY2xlYW51cCBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkXG4vLyBldmVyeSB0aW1lIHRoZSBwb3BwZXIgaXMgZGVzdHJveWVkIChpLmUuIGEgbmV3IHRhcmdldCksIHJlbW92aW5nIHRoZSBzdHlsZXNcbi8vIGFuZCBjYXVzaW5nIHRyYW5zaXRpb25zIHRvIGJyZWFrIGZvciBzaW5nbGV0b25zIHdoZW4gdGhlIGNvbnNvbGUgaXMgb3BlbiwgYnV0XG4vLyBtb3N0IG5vdGFibHkgZm9yIG5vbi10cmFuc2Zvcm0gc3R5bGVzIGJlaW5nIHVzZWQsIGBncHVBY2NlbGVyYXRpb246IGZhbHNlYC5cbmNvbnN0IGFwcGx5U3R5bGVzTW9kaWZpZXI6IE1vZGlmaWVyPCdhcHBseVN0eWxlcycsIFJlY29yZDxzdHJpbmcsIHVua25vd24+PiA9IHtcbiAgLi4uYXBwbHlTdHlsZXMsXG4gIGVmZmVjdCh7c3RhdGV9KSB7XG4gICAgY29uc3QgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICAgIHBvcHBlcjoge1xuICAgICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgICAgbGVmdDogJzAnLFxuICAgICAgICB0b3A6ICcwJyxcbiAgICAgICAgbWFyZ2luOiAnMCcsXG4gICAgICB9LFxuICAgICAgYXJyb3c6IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB9LFxuICAgICAgcmVmZXJlbmNlOiB7fSxcbiAgICB9O1xuXG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgICBzdGF0ZS5zdHlsZXMgPSBpbml0aWFsU3R5bGVzO1xuXG4gICAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgICB9XG5cbiAgICAvLyBpbnRlbnRpb25hbGx5IHJldHVybiBubyBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgLy8gcmV0dXJuICgpID0+IHsgLi4uIH1cbiAgfSxcbn07XG5cbmNvbnN0IGNyZWF0ZVNpbmdsZXRvbjogQ3JlYXRlU2luZ2xldG9uID0gKFxuICB0aXBweUluc3RhbmNlcyxcbiAgb3B0aW9uYWxQcm9wcyA9IHt9XG4pID0+IHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKF9fREVWX18pIHtcbiAgICBlcnJvcldoZW4oXG4gICAgICAhQXJyYXkuaXNBcnJheSh0aXBweUluc3RhbmNlcyksXG4gICAgICBbXG4gICAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVNpbmdsZXRvbigpIG11c3QgYmUgYW4gYXJyYXkgb2YnLFxuICAgICAgICAndGlwcHkgaW5zdGFuY2VzLiBUaGUgcGFzc2VkIHZhbHVlIHdhcycsXG4gICAgICAgIFN0cmluZyh0aXBweUluc3RhbmNlcyksXG4gICAgICBdLmpvaW4oJyAnKVxuICAgICk7XG4gIH1cblxuICBsZXQgaW5kaXZpZHVhbEluc3RhbmNlcyA9IHRpcHB5SW5zdGFuY2VzO1xuICBsZXQgcmVmZXJlbmNlczogQXJyYXk8UmVmZXJlbmNlRWxlbWVudD4gPSBbXTtcbiAgbGV0IHRyaWdnZXJUYXJnZXRzOiBBcnJheTxFbGVtZW50PiA9IFtdO1xuICBsZXQgY3VycmVudFRhcmdldDogRWxlbWVudCB8IG51bGw7XG4gIGxldCBvdmVycmlkZXMgPSBvcHRpb25hbFByb3BzLm92ZXJyaWRlcztcbiAgbGV0IGludGVyY2VwdFNldFByb3BzQ2xlYW51cHM6IEFycmF5PCgpID0+IHZvaWQ+ID0gW107XG4gIGxldCBzaG93bk9uQ3JlYXRlID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gc2V0VHJpZ2dlclRhcmdldHMoKTogdm9pZCB7XG4gICAgdHJpZ2dlclRhcmdldHMgPSBpbmRpdmlkdWFsSW5zdGFuY2VzXG4gICAgICAubWFwKChpbnN0YW5jZSkgPT5cbiAgICAgICAgbm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IGluc3RhbmNlLnJlZmVyZW5jZSlcbiAgICAgIClcbiAgICAgIC5yZWR1Y2UoKGFjYywgaXRlbSkgPT4gYWNjLmNvbmNhdChpdGVtKSwgW10pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UmVmZXJlbmNlcygpOiB2b2lkIHtcbiAgICByZWZlcmVuY2VzID0gaW5kaXZpZHVhbEluc3RhbmNlcy5tYXAoKGluc3RhbmNlKSA9PiBpbnN0YW5jZS5yZWZlcmVuY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5hYmxlSW5zdGFuY2VzKGlzRW5hYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIGluZGl2aWR1YWxJbnN0YW5jZXMuZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICAgIGlmIChpc0VuYWJsZWQpIHtcbiAgICAgICAgaW5zdGFuY2UuZW5hYmxlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcmNlcHRTZXRQcm9wcyhzaW5nbGV0b246IEluc3RhbmNlKTogQXJyYXk8KCkgPT4gdm9pZD4ge1xuICAgIHJldHVybiBpbmRpdmlkdWFsSW5zdGFuY2VzLm1hcCgoaW5zdGFuY2UpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsU2V0UHJvcHMgPSBpbnN0YW5jZS5zZXRQcm9wcztcblxuICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMgPSAocHJvcHMpOiB2b2lkID0+IHtcbiAgICAgICAgb3JpZ2luYWxTZXRQcm9wcyhwcm9wcyk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlLnJlZmVyZW5jZSA9PT0gY3VycmVudFRhcmdldCkge1xuICAgICAgICAgIHNpbmdsZXRvbi5zZXRQcm9wcyhwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiAoKTogdm9pZCA9PiB7XG4gICAgICAgIGluc3RhbmNlLnNldFByb3BzID0gb3JpZ2luYWxTZXRQcm9wcztcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvLyBoYXZlIHRvIHBhc3Mgc2luZ2xldG9uLCBhcyBpdCBtYXliZSB1bmRlZmluZWQgb24gZmlyc3QgY2FsbFxuICBmdW5jdGlvbiBwcmVwYXJlSW5zdGFuY2UoXG4gICAgc2luZ2xldG9uOiBJbnN0YW5jZSxcbiAgICB0YXJnZXQ6IFJlZmVyZW5jZUVsZW1lbnRcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgaW5kZXggPSB0cmlnZ2VyVGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7XG5cbiAgICAvLyBiYWlsLW91dFxuICAgIGlmICh0YXJnZXQgPT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgY29uc3Qgb3ZlcnJpZGVQcm9wczogUGFydGlhbDxQcm9wcz4gPSAob3ZlcnJpZGVzIHx8IFtdKVxuICAgICAgLmNvbmNhdCgnY29udGVudCcpXG4gICAgICAucmVkdWNlKChhY2MsIHByb3ApID0+IHtcbiAgICAgICAgKGFjYyBhcyBhbnkpW3Byb3BdID0gaW5kaXZpZHVhbEluc3RhbmNlc1tpbmRleF0ucHJvcHNbcHJvcF07XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG5cbiAgICBzaW5nbGV0b24uc2V0UHJvcHMoe1xuICAgICAgLi4ub3ZlcnJpZGVQcm9wcyxcbiAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6XG4gICAgICAgIHR5cGVvZiBvdmVycmlkZVByb3BzLmdldFJlZmVyZW5jZUNsaWVudFJlY3QgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IG92ZXJyaWRlUHJvcHMuZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdFxuICAgICAgICAgIDogKCk6IENsaWVudFJlY3QgPT4gcmVmZXJlbmNlc1tpbmRleF0/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgIH0pO1xuICB9XG5cbiAgZW5hYmxlSW5zdGFuY2VzKGZhbHNlKTtcbiAgc2V0UmVmZXJlbmNlcygpO1xuICBzZXRUcmlnZ2VyVGFyZ2V0cygpO1xuXG4gIGNvbnN0IHBsdWdpbjogUGx1Z2luID0ge1xuICAgIGZuKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICAgIGVuYWJsZUluc3RhbmNlcyh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25IaWRkZW4oKTogdm9pZCB7XG4gICAgICAgICAgY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2xpY2tPdXRzaWRlKGluc3RhbmNlKTogdm9pZCB7XG4gICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLnNob3dPbkNyZWF0ZSAmJiAhc2hvd25PbkNyZWF0ZSkge1xuICAgICAgICAgICAgc2hvd25PbkNyZWF0ZSA9IHRydWU7XG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uU2hvdyhpbnN0YW5jZSk6IHZvaWQge1xuICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5zaG93T25DcmVhdGUgJiYgIXNob3duT25DcmVhdGUpIHtcbiAgICAgICAgICAgIHNob3duT25DcmVhdGUgPSB0cnVlO1xuICAgICAgICAgICAgcHJlcGFyZUluc3RhbmNlKGluc3RhbmNlLCByZWZlcmVuY2VzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uVHJpZ2dlcihpbnN0YW5jZSwgZXZlbnQpOiB2b2lkIHtcbiAgICAgICAgICBwcmVwYXJlSW5zdGFuY2UoaW5zdGFuY2UsIGV2ZW50LmN1cnJlbnRUYXJnZXQgYXMgRWxlbWVudCk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG4gIH07XG5cbiAgY29uc3Qgc2luZ2xldG9uID0gdGlwcHkoZGl2KCksIHtcbiAgICAuLi5yZW1vdmVQcm9wZXJ0aWVzKG9wdGlvbmFsUHJvcHMsIFsnb3ZlcnJpZGVzJ10pLFxuICAgIHBsdWdpbnM6IFtwbHVnaW4sIC4uLihvcHRpb25hbFByb3BzLnBsdWdpbnMgfHwgW10pXSxcbiAgICB0cmlnZ2VyVGFyZ2V0OiB0cmlnZ2VyVGFyZ2V0cyxcbiAgICBwb3BwZXJPcHRpb25zOiB7XG4gICAgICAuLi5vcHRpb25hbFByb3BzLnBvcHBlck9wdGlvbnMsXG4gICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAgLi4uKG9wdGlvbmFsUHJvcHMucG9wcGVyT3B0aW9ucz8ubW9kaWZpZXJzIHx8IFtdKSxcbiAgICAgICAgYXBwbHlTdHlsZXNNb2RpZmllcixcbiAgICAgIF0sXG4gICAgfSxcbiAgfSkgYXMgQ3JlYXRlU2luZ2xldG9uSW5zdGFuY2U8Q3JlYXRlU2luZ2xldG9uUHJvcHM+O1xuXG4gIGNvbnN0IG9yaWdpbmFsU2hvdyA9IHNpbmdsZXRvbi5zaG93O1xuXG4gIHNpbmdsZXRvbi5zaG93ID0gKHRhcmdldD86IFJlZmVyZW5jZUVsZW1lbnQgfCBJbnN0YW5jZSB8IG51bWJlcik6IHZvaWQgPT4ge1xuICAgIG9yaWdpbmFsU2hvdygpO1xuXG4gICAgLy8gZmlyc3QgdGltZSwgc2hvd09uQ3JlYXRlIG9yIHByb2dyYW1tYXRpYyBjYWxsIHdpdGggbm8gcGFyYW1zXG4gICAgLy8gZGVmYXVsdCB0byBzaG93aW5nIGZpcnN0IGluc3RhbmNlXG4gICAgaWYgKCFjdXJyZW50VGFyZ2V0ICYmIHRhcmdldCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcHJlcGFyZUluc3RhbmNlKHNpbmdsZXRvbiwgcmVmZXJlbmNlc1swXSk7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlcmVkIGZyb20gZXZlbnQgKGRvIG5vdGhpbmcgYXMgcHJlcGFyZUluc3RhbmNlIGFscmVhZHkgY2FsbGVkIGJ5IG9uVHJpZ2dlcilcbiAgICAvLyBwcm9ncmFtbWF0aWMgY2FsbCB3aXRoIG5vIHBhcmFtcyB3aGVuIGFscmVhZHkgdmlzaWJsZSAoZG8gbm90aGluZyBhZ2FpbilcbiAgICBpZiAoY3VycmVudFRhcmdldCAmJiB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHRhcmdldCBpcyBpbmRleCBvZiBpbnN0YW5jZVxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgcmVmZXJlbmNlc1t0YXJnZXRdICYmIHByZXBhcmVJbnN0YW5jZShzaW5nbGV0b24sIHJlZmVyZW5jZXNbdGFyZ2V0XSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gdGFyZ2V0IGlzIGEgY2hpbGQgdGlwcHkgaW5zdGFuY2VcbiAgICBpZiAoaW5kaXZpZHVhbEluc3RhbmNlcy5pbmRleE9mKHRhcmdldCBhcyBJbnN0YW5jZSkgPj0gMCkge1xuICAgICAgY29uc3QgcmVmID0gKHRhcmdldCBhcyBJbnN0YW5jZSkucmVmZXJlbmNlO1xuICAgICAgcmV0dXJuIHByZXBhcmVJbnN0YW5jZShzaW5nbGV0b24sIHJlZik7XG4gICAgfVxuXG4gICAgLy8gdGFyZ2V0IGlzIGEgUmVmZXJlbmNlRWxlbWVudFxuICAgIGlmIChyZWZlcmVuY2VzLmluZGV4T2YodGFyZ2V0IGFzIFJlZmVyZW5jZUVsZW1lbnQpID49IDApIHtcbiAgICAgIHJldHVybiBwcmVwYXJlSW5zdGFuY2Uoc2luZ2xldG9uLCB0YXJnZXQgYXMgUmVmZXJlbmNlRWxlbWVudCk7XG4gICAgfVxuICB9O1xuXG4gIHNpbmdsZXRvbi5zaG93TmV4dCA9ICgpOiB2b2lkID0+IHtcbiAgICBjb25zdCBmaXJzdCA9IHJlZmVyZW5jZXNbMF07XG4gICAgaWYgKCFjdXJyZW50VGFyZ2V0KSB7XG4gICAgICByZXR1cm4gc2luZ2xldG9uLnNob3coMCk7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gcmVmZXJlbmNlcy5pbmRleE9mKGN1cnJlbnRUYXJnZXQpO1xuICAgIHNpbmdsZXRvbi5zaG93KHJlZmVyZW5jZXNbaW5kZXggKyAxXSB8fCBmaXJzdCk7XG4gIH07XG5cbiAgc2luZ2xldG9uLnNob3dQcmV2aW91cyA9ICgpOiB2b2lkID0+IHtcbiAgICBjb25zdCBsYXN0ID0gcmVmZXJlbmNlc1tyZWZlcmVuY2VzLmxlbmd0aCAtIDFdO1xuICAgIGlmICghY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIHNpbmdsZXRvbi5zaG93KGxhc3QpO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHJlZmVyZW5jZXMuaW5kZXhPZihjdXJyZW50VGFyZ2V0KTtcbiAgICBjb25zdCB0YXJnZXQgPSByZWZlcmVuY2VzW2luZGV4IC0gMV0gfHwgbGFzdDtcbiAgICBzaW5nbGV0b24uc2hvdyh0YXJnZXQpO1xuICB9O1xuXG4gIGNvbnN0IG9yaWdpbmFsU2V0UHJvcHMgPSBzaW5nbGV0b24uc2V0UHJvcHM7XG5cbiAgc2luZ2xldG9uLnNldFByb3BzID0gKHByb3BzKTogdm9pZCA9PiB7XG4gICAgb3ZlcnJpZGVzID0gcHJvcHMub3ZlcnJpZGVzIHx8IG92ZXJyaWRlcztcbiAgICBvcmlnaW5hbFNldFByb3BzKHByb3BzKTtcbiAgfTtcblxuICBzaW5nbGV0b24uc2V0SW5zdGFuY2VzID0gKG5leHRJbnN0YW5jZXMpOiB2b2lkID0+IHtcbiAgICBlbmFibGVJbnN0YW5jZXModHJ1ZSk7XG4gICAgaW50ZXJjZXB0U2V0UHJvcHNDbGVhbnVwcy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG5cbiAgICBpbmRpdmlkdWFsSW5zdGFuY2VzID0gbmV4dEluc3RhbmNlcztcblxuICAgIGVuYWJsZUluc3RhbmNlcyhmYWxzZSk7XG4gICAgc2V0UmVmZXJlbmNlcygpO1xuICAgIHNldFRyaWdnZXJUYXJnZXRzKCk7XG4gICAgaW50ZXJjZXB0U2V0UHJvcHNDbGVhbnVwcyA9IGludGVyY2VwdFNldFByb3BzKHNpbmdsZXRvbik7XG5cbiAgICBzaW5nbGV0b24uc2V0UHJvcHMoe3RyaWdnZXJUYXJnZXQ6IHRyaWdnZXJUYXJnZXRzfSk7XG4gIH07XG5cbiAgaW50ZXJjZXB0U2V0UHJvcHNDbGVhbnVwcyA9IGludGVyY2VwdFNldFByb3BzKHNpbmdsZXRvbik7XG5cbiAgcmV0dXJuIHNpbmdsZXRvbjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVNpbmdsZXRvbjtcbiIsICJpbXBvcnQgdGlwcHkgZnJvbSAnLi4nO1xuaW1wb3J0IHtUT1VDSF9PUFRJT05TfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHtkZWZhdWx0UHJvcHN9IGZyb20gJy4uL3Byb3BzJztcbmltcG9ydCB7SW5zdGFuY2UsIFByb3BzLCBUYXJnZXRzfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge0xpc3RlbmVyT2JqZWN0fSBmcm9tICcuLi90eXBlcy1pbnRlcm5hbCc7XG5pbXBvcnQge25vcm1hbGl6ZVRvQXJyYXksIHJlbW92ZVByb3BlcnRpZXN9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7ZXJyb3JXaGVufSBmcm9tICcuLi92YWxpZGF0aW9uJztcblxuY29uc3QgQlVCQkxJTkdfRVZFTlRTX01BUCA9IHtcbiAgbW91c2VvdmVyOiAnbW91c2VlbnRlcicsXG4gIGZvY3VzaW46ICdmb2N1cycsXG4gIGNsaWNrOiAnY2xpY2snLFxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVsZWdhdGUgaW5zdGFuY2UgdGhhdCBjb250cm9scyB0aGUgY3JlYXRpb24gb2YgdGlwcHkgaW5zdGFuY2VzXG4gKiBmb3IgY2hpbGQgZWxlbWVudHMgKGB0YXJnZXRgIENTUyBzZWxlY3RvcikuXG4gKi9cbmZ1bmN0aW9uIGRlbGVnYXRlKFxuICB0YXJnZXRzOiBUYXJnZXRzLFxuICBwcm9wczogUGFydGlhbDxQcm9wcz4gJiB7dGFyZ2V0OiBzdHJpbmd9XG4pOiBJbnN0YW5jZSB8IEluc3RhbmNlW10ge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoX19ERVZfXykge1xuICAgIGVycm9yV2hlbihcbiAgICAgICEocHJvcHMgJiYgcHJvcHMudGFyZ2V0KSxcbiAgICAgIFtcbiAgICAgICAgJ1lvdSBtdXN0IHNwZWNpdHkgYSBgdGFyZ2V0YCBwcm9wIGluZGljYXRpbmcgYSBDU1Mgc2VsZWN0b3Igc3RyaW5nIG1hdGNoaW5nJyxcbiAgICAgICAgJ3RoZSB0YXJnZXQgZWxlbWVudHMgdGhhdCBzaG91bGQgcmVjZWl2ZSBhIHRpcHB5LicsXG4gICAgICBdLmpvaW4oJyAnKVxuICAgICk7XG4gIH1cblxuICBsZXQgbGlzdGVuZXJzOiBMaXN0ZW5lck9iamVjdFtdID0gW107XG4gIGxldCBjaGlsZFRpcHB5SW5zdGFuY2VzOiBJbnN0YW5jZVtdID0gW107XG4gIGxldCBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gIGNvbnN0IHt0YXJnZXR9ID0gcHJvcHM7XG5cbiAgY29uc3QgbmF0aXZlUHJvcHMgPSByZW1vdmVQcm9wZXJ0aWVzKHByb3BzLCBbJ3RhcmdldCddKTtcbiAgY29uc3QgcGFyZW50UHJvcHMgPSB7Li4ubmF0aXZlUHJvcHMsIHRyaWdnZXI6ICdtYW51YWwnLCB0b3VjaDogZmFsc2V9O1xuICBjb25zdCBjaGlsZFByb3BzID0ge1xuICAgIHRvdWNoOiBkZWZhdWx0UHJvcHMudG91Y2gsXG4gICAgLi4ubmF0aXZlUHJvcHMsXG4gICAgc2hvd09uQ3JlYXRlOiB0cnVlLFxuICB9O1xuXG4gIGNvbnN0IHJldHVyblZhbHVlID0gdGlwcHkodGFyZ2V0cywgcGFyZW50UHJvcHMpO1xuICBjb25zdCBub3JtYWxpemVkUmV0dXJuVmFsdWUgPSBub3JtYWxpemVUb0FycmF5KHJldHVyblZhbHVlKTtcblxuICBmdW5jdGlvbiBvblRyaWdnZXIoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgaWYgKCFldmVudC50YXJnZXQgfHwgZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXROb2RlID0gKGV2ZW50LnRhcmdldCBhcyBFbGVtZW50KS5jbG9zZXN0KHRhcmdldCk7XG5cbiAgICBpZiAoIXRhcmdldE5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgcmVsZXZhbnQgdHJpZ2dlciB3aXRoIGZhbGxiYWNrczpcbiAgICAvLyAxLiBDaGVjayBgZGF0YS10aXBweS10cmlnZ2VyYCBhdHRyaWJ1dGUgb24gdGFyZ2V0IG5vZGVcbiAgICAvLyAyLiBGYWxsYmFjayB0byBgdHJpZ2dlcmAgcGFzc2VkIHRvIGBkZWxlZ2F0ZSgpYFxuICAgIC8vIDMuIEZhbGxiYWNrIHRvIGBkZWZhdWx0UHJvcHMudHJpZ2dlcmBcbiAgICBjb25zdCB0cmlnZ2VyID1cbiAgICAgIHRhcmdldE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXRpcHB5LXRyaWdnZXInKSB8fFxuICAgICAgcHJvcHMudHJpZ2dlciB8fFxuICAgICAgZGVmYXVsdFByb3BzLnRyaWdnZXI7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHRhcmdldE5vZGUuX3RpcHB5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JyAmJiB0eXBlb2YgY2hpbGRQcm9wcy50b3VjaCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgZXZlbnQudHlwZSAhPT0gJ3RvdWNoc3RhcnQnICYmXG4gICAgICB0cmlnZ2VyLmluZGV4T2YoKEJVQkJMSU5HX0VWRU5UU19NQVAgYXMgYW55KVtldmVudC50eXBlXSkgPCAwXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aXBweSh0YXJnZXROb2RlLCBjaGlsZFByb3BzKTtcblxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgY2hpbGRUaXBweUluc3RhbmNlcyA9IGNoaWxkVGlwcHlJbnN0YW5jZXMuY29uY2F0KGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbihcbiAgICBub2RlOiBFbGVtZW50LFxuICAgIGV2ZW50VHlwZTogc3RyaW5nLFxuICAgIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIsXG4gICAgb3B0aW9uczogYm9vbGVhbiB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0gZmFsc2VcbiAgKTogdm9pZCB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgbGlzdGVuZXJzLnB1c2goe25vZGUsIGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9uc30pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoaW5zdGFuY2U6IEluc3RhbmNlKTogdm9pZCB7XG4gICAgY29uc3Qge3JlZmVyZW5jZX0gPSBpbnN0YW5jZTtcblxuICAgIG9uKHJlZmVyZW5jZSwgJ3RvdWNoc3RhcnQnLCBvblRyaWdnZXIsIFRPVUNIX09QVElPTlMpO1xuICAgIG9uKHJlZmVyZW5jZSwgJ21vdXNlb3ZlcicsIG9uVHJpZ2dlcik7XG4gICAgb24ocmVmZXJlbmNlLCAnZm9jdXNpbicsIG9uVHJpZ2dlcik7XG4gICAgb24ocmVmZXJlbmNlLCAnY2xpY2snLCBvblRyaWdnZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goKHtub2RlLCBldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnN9OiBMaXN0ZW5lck9iamVjdCkgPT4ge1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgbGlzdGVuZXJzID0gW107XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseU11dGF0aW9ucyhpbnN0YW5jZTogSW5zdGFuY2UpOiB2b2lkIHtcbiAgICBjb25zdCBvcmlnaW5hbERlc3Ryb3kgPSBpbnN0YW5jZS5kZXN0cm95O1xuICAgIGNvbnN0IG9yaWdpbmFsRW5hYmxlID0gaW5zdGFuY2UuZW5hYmxlO1xuICAgIGNvbnN0IG9yaWdpbmFsRGlzYWJsZSA9IGluc3RhbmNlLmRpc2FibGU7XG5cbiAgICBpbnN0YW5jZS5kZXN0cm95ID0gKHNob3VsZERlc3Ryb3lDaGlsZEluc3RhbmNlcyA9IHRydWUpOiB2b2lkID0+IHtcbiAgICAgIGlmIChzaG91bGREZXN0cm95Q2hpbGRJbnN0YW5jZXMpIHtcbiAgICAgICAgY2hpbGRUaXBweUluc3RhbmNlcy5mb3JFYWNoKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgIGluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkVGlwcHlJbnN0YW5jZXMgPSBbXTtcblxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIG9yaWdpbmFsRGVzdHJveSgpO1xuICAgIH07XG5cbiAgICBpbnN0YW5jZS5lbmFibGUgPSAoKTogdm9pZCA9PiB7XG4gICAgICBvcmlnaW5hbEVuYWJsZSgpO1xuICAgICAgY2hpbGRUaXBweUluc3RhbmNlcy5mb3JFYWNoKChpbnN0YW5jZSkgPT4gaW5zdGFuY2UuZW5hYmxlKCkpO1xuICAgICAgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgaW5zdGFuY2UuZGlzYWJsZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgIG9yaWdpbmFsRGlzYWJsZSgpO1xuICAgICAgY2hpbGRUaXBweUluc3RhbmNlcy5mb3JFYWNoKChpbnN0YW5jZSkgPT4gaW5zdGFuY2UuZGlzYWJsZSgpKTtcbiAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoaW5zdGFuY2UpO1xuICB9XG5cbiAgbm9ybWFsaXplZFJldHVyblZhbHVlLmZvckVhY2goYXBwbHlNdXRhdGlvbnMpO1xuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVsZWdhdGU7XG4iLCAiaW1wb3J0IHtCQUNLRFJPUF9DTEFTU30gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7ZGl2LCBzZXRWaXNpYmlsaXR5U3RhdGV9IGZyb20gJy4uL2RvbS11dGlscyc7XG5pbXBvcnQge2dldENoaWxkcmVufSBmcm9tICcuLi90ZW1wbGF0ZSc7XG5pbXBvcnQge0FuaW1hdGVGaWxsfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge2Vycm9yV2hlbn0gZnJvbSAnLi4vdmFsaWRhdGlvbic7XG5cbmNvbnN0IGFuaW1hdGVGaWxsOiBBbmltYXRlRmlsbCA9IHtcbiAgbmFtZTogJ2FuaW1hdGVGaWxsJyxcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgZm4oaW5zdGFuY2UpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKCFpbnN0YW5jZS5wcm9wcy5yZW5kZXI/LiQkdGlwcHkpIHtcbiAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIGVycm9yV2hlbihcbiAgICAgICAgICBpbnN0YW5jZS5wcm9wcy5hbmltYXRlRmlsbCxcbiAgICAgICAgICAnVGhlIGBhbmltYXRlRmlsbGAgcGx1Z2luIHJlcXVpcmVzIHRoZSBkZWZhdWx0IHJlbmRlciBmdW5jdGlvbi4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCB7Ym94LCBjb250ZW50fSA9IGdldENoaWxkcmVuKGluc3RhbmNlLnBvcHBlcik7XG5cbiAgICBjb25zdCBiYWNrZHJvcCA9IGluc3RhbmNlLnByb3BzLmFuaW1hdGVGaWxsXG4gICAgICA/IGNyZWF0ZUJhY2tkcm9wRWxlbWVudCgpXG4gICAgICA6IG51bGw7XG5cbiAgICByZXR1cm4ge1xuICAgICAgb25DcmVhdGUoKTogdm9pZCB7XG4gICAgICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgICAgIGJveC5pbnNlcnRCZWZvcmUoYmFja2Ryb3AsIGJveC5maXJzdEVsZW1lbnRDaGlsZCEpO1xuICAgICAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0ZWZpbGwnLCAnJyk7XG4gICAgICAgICAgYm94LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7YXJyb3c6IGZhbHNlLCBhbmltYXRpb246ICdzaGlmdC1hd2F5J30pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Nb3VudCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgY29uc3Qge3RyYW5zaXRpb25EdXJhdGlvbn0gPSBib3guc3R5bGU7XG4gICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBOdW1iZXIodHJhbnNpdGlvbkR1cmF0aW9uLnJlcGxhY2UoJ21zJywgJycpKTtcblxuICAgICAgICAgIC8vIFRoZSBjb250ZW50IHNob3VsZCBmYWRlIGluIGFmdGVyIHRoZSBiYWNrZHJvcCBoYXMgbW9zdGx5IGZpbGxlZCB0aGVcbiAgICAgICAgICAvLyB0b29sdGlwIGVsZW1lbnQuIGBjbGlwLXBhdGhgIGlzIHRoZSBvdGhlciBhbHRlcm5hdGl2ZSBidXQgaXMgbm90XG4gICAgICAgICAgLy8gd2VsbC1zdXBwb3J0ZWQgYW5kIGlzIGJ1Z2d5IG9uIHNvbWUgZGV2aWNlcy5cbiAgICAgICAgICBjb250ZW50LnN0eWxlLnRyYW5zaXRpb25EZWxheSA9IGAke01hdGgucm91bmQoZHVyYXRpb24gLyAxMCl9bXNgO1xuXG4gICAgICAgICAgYmFja2Ryb3Auc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICAgICAgIHNldFZpc2liaWxpdHlTdGF0ZShbYmFja2Ryb3BdLCAndmlzaWJsZScpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25TaG93KCk6IHZvaWQge1xuICAgICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgICBiYWNrZHJvcC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMG1zJztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uSGlkZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtiYWNrZHJvcF0sICdoaWRkZW4nKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9O1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgYW5pbWF0ZUZpbGw7XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhY2tkcm9wRWxlbWVudCgpOiBIVE1MRGl2RWxlbWVudCB7XG4gIGNvbnN0IGJhY2tkcm9wID0gZGl2KCk7XG4gIGJhY2tkcm9wLmNsYXNzTmFtZSA9IEJBQ0tEUk9QX0NMQVNTO1xuICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JhY2tkcm9wXSwgJ2hpZGRlbicpO1xuICByZXR1cm4gYmFja2Ryb3A7XG59XG4iLCAiaW1wb3J0IHtnZXRPd25lckRvY3VtZW50LCBpc01vdXNlRXZlbnR9IGZyb20gJy4uL2RvbS11dGlscyc7XG5pbXBvcnQge0ZvbGxvd0N1cnNvciwgSW5zdGFuY2V9IGZyb20gJy4uL3R5cGVzJztcblxubGV0IG1vdXNlQ29vcmRzID0ge2NsaWVudFg6IDAsIGNsaWVudFk6IDB9O1xubGV0IGFjdGl2ZUluc3RhbmNlczogQXJyYXk8e2luc3RhbmNlOiBJbnN0YW5jZTsgZG9jOiBEb2N1bWVudH0+ID0gW107XG5cbmZ1bmN0aW9uIHN0b3JlTW91c2VDb29yZHMoe2NsaWVudFgsIGNsaWVudFl9OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gIG1vdXNlQ29vcmRzID0ge2NsaWVudFgsIGNsaWVudFl9O1xufVxuXG5mdW5jdGlvbiBhZGRNb3VzZUNvb3Jkc0xpc3RlbmVyKGRvYzogRG9jdW1lbnQpOiB2b2lkIHtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHN0b3JlTW91c2VDb29yZHMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVNb3VzZUNvb3Jkc0xpc3RlbmVyKGRvYzogRG9jdW1lbnQpOiB2b2lkIHtcbiAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHN0b3JlTW91c2VDb29yZHMpO1xufVxuXG5jb25zdCBmb2xsb3dDdXJzb3I6IEZvbGxvd0N1cnNvciA9IHtcbiAgbmFtZTogJ2ZvbGxvd0N1cnNvcicsXG4gIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gIGZuKGluc3RhbmNlKSB7XG4gICAgY29uc3QgcmVmZXJlbmNlID0gaW5zdGFuY2UucmVmZXJlbmNlO1xuICAgIGNvbnN0IGRvYyA9IGdldE93bmVyRG9jdW1lbnQoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpO1xuXG4gICAgbGV0IGlzSW50ZXJuYWxVcGRhdGUgPSBmYWxzZTtcbiAgICBsZXQgd2FzRm9jdXNFdmVudCA9IGZhbHNlO1xuICAgIGxldCBpc1VubW91bnRlZCA9IHRydWU7XG4gICAgbGV0IHByZXZQcm9wcyA9IGluc3RhbmNlLnByb3BzO1xuXG4gICAgZnVuY3Rpb24gZ2V0SXNJbml0aWFsQmVoYXZpb3IoKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3IgPT09ICdpbml0aWFsJyAmJiBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTGlzdGVuZXIoKTogdm9pZCB7XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKCk6IHZvaWQge1xuICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnNldEdldFJlZmVyZW5jZUNsaWVudFJlY3QoKTogdm9pZCB7XG4gICAgICBpc0ludGVybmFsVXBkYXRlID0gdHJ1ZTtcbiAgICAgIGluc3RhbmNlLnNldFByb3BzKHtnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBudWxsfSk7XG4gICAgICBpc0ludGVybmFsVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgIC8vIElmIHRoZSBpbnN0YW5jZSBpcyBpbnRlcmFjdGl2ZSwgYXZvaWQgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHVubGVzcyBpdCdzXG4gICAgICAvLyBvdmVyIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICAgICAgY29uc3QgaXNDdXJzb3JPdmVyUmVmZXJlbmNlID0gZXZlbnQudGFyZ2V0XG4gICAgICAgID8gcmVmZXJlbmNlLmNvbnRhaW5zKGV2ZW50LnRhcmdldCBhcyBOb2RlKVxuICAgICAgICA6IHRydWU7XG4gICAgICBjb25zdCB7Zm9sbG93Q3Vyc29yfSA9IGluc3RhbmNlLnByb3BzO1xuICAgICAgY29uc3Qge2NsaWVudFgsIGNsaWVudFl9ID0gZXZlbnQ7XG5cbiAgICAgIGNvbnN0IHJlY3QgPSByZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCByZWxhdGl2ZVggPSBjbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgY29uc3QgcmVsYXRpdmVZID0gY2xpZW50WSAtIHJlY3QudG9wO1xuXG4gICAgICBpZiAoaXNDdXJzb3JPdmVyUmVmZXJlbmNlIHx8ICFpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIHVubmVlZGVkIERPTVJlY3QgcHJvcGVydGllc1xuICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3QoKSB7XG4gICAgICAgICAgICBjb25zdCByZWN0ID0gcmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICBsZXQgeCA9IGNsaWVudFg7XG4gICAgICAgICAgICBsZXQgeSA9IGNsaWVudFk7XG5cbiAgICAgICAgICAgIGlmIChmb2xsb3dDdXJzb3IgPT09ICdpbml0aWFsJykge1xuICAgICAgICAgICAgICB4ID0gcmVjdC5sZWZ0ICsgcmVsYXRpdmVYO1xuICAgICAgICAgICAgICB5ID0gcmVjdC50b3AgKyByZWxhdGl2ZVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGZvbGxvd0N1cnNvciA9PT0gJ2hvcml6b250YWwnID8gcmVjdC50b3AgOiB5O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBmb2xsb3dDdXJzb3IgPT09ICd2ZXJ0aWNhbCcgPyByZWN0LnJpZ2h0IDogeDtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IGZvbGxvd0N1cnNvciA9PT0gJ2hvcml6b250YWwnID8gcmVjdC5ib3R0b20gOiB5O1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGZvbGxvd0N1cnNvciA9PT0gJ3ZlcnRpY2FsJyA/IHJlY3QubGVmdCA6IHg7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHdpZHRoOiByaWdodCAtIGxlZnQsXG4gICAgICAgICAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wLFxuICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZSgpOiB2b2lkIHtcbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VzLnB1c2goe2luc3RhbmNlLCBkb2N9KTtcbiAgICAgICAgYWRkTW91c2VDb29yZHNMaXN0ZW5lcihkb2MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgICBhY3RpdmVJbnN0YW5jZXMgPSBhY3RpdmVJbnN0YW5jZXMuZmlsdGVyKFxuICAgICAgICAoZGF0YSkgPT4gZGF0YS5pbnN0YW5jZSAhPT0gaW5zdGFuY2VcbiAgICAgICk7XG5cbiAgICAgIGlmIChhY3RpdmVJbnN0YW5jZXMuZmlsdGVyKChkYXRhKSA9PiBkYXRhLmRvYyA9PT0gZG9jKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTW91c2VDb29yZHNMaXN0ZW5lcihkb2MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvbkNyZWF0ZTogY3JlYXRlLFxuICAgICAgb25EZXN0cm95OiBkZXN0cm95LFxuICAgICAgb25CZWZvcmVVcGRhdGUoKTogdm9pZCB7XG4gICAgICAgIHByZXZQcm9wcyA9IGluc3RhbmNlLnByb3BzO1xuICAgICAgfSxcbiAgICAgIG9uQWZ0ZXJVcGRhdGUoXywge2ZvbGxvd0N1cnNvcn0pOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzSW50ZXJuYWxVcGRhdGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgZm9sbG93Q3Vyc29yICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBwcmV2UHJvcHMuZm9sbG93Q3Vyc29yICE9PSBmb2xsb3dDdXJzb3JcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGVzdHJveSgpO1xuXG4gICAgICAgICAgaWYgKGZvbGxvd0N1cnNvcikge1xuICAgICAgICAgICAgY3JlYXRlKCk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkICYmXG4gICAgICAgICAgICAgICF3YXNGb2N1c0V2ZW50ICYmXG4gICAgICAgICAgICAgICFnZXRJc0luaXRpYWxCZWhhdmlvcigpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgYWRkTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHVuc2V0R2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uTW91bnQoKTogdm9pZCB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3IgJiYgIXdhc0ZvY3VzRXZlbnQpIHtcbiAgICAgICAgICBpZiAoaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlKG1vdXNlQ29vcmRzIGFzIE1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgaXNVbm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWdldElzSW5pdGlhbEJlaGF2aW9yKCkpIHtcbiAgICAgICAgICAgIGFkZExpc3RlbmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25UcmlnZ2VyKF8sIGV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgbW91c2VDb29yZHMgPSB7Y2xpZW50WDogZXZlbnQuY2xpZW50WCwgY2xpZW50WTogZXZlbnQuY2xpZW50WX07XG4gICAgICAgIH1cbiAgICAgICAgd2FzRm9jdXNFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdmb2N1cyc7XG4gICAgICB9LFxuICAgICAgb25IaWRkZW4oKTogdm9pZCB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgICB1bnNldEdldFJlZmVyZW5jZUNsaWVudFJlY3QoKTtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgIGlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9O1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZm9sbG93Q3Vyc29yO1xuIiwgImltcG9ydCB7TW9kaWZpZXIsIFBsYWNlbWVudH0gZnJvbSAnQHBvcHBlcmpzL2NvcmUnO1xuaW1wb3J0IHtpc01vdXNlRXZlbnR9IGZyb20gJy4uL2RvbS11dGlscyc7XG5pbXBvcnQge0Jhc2VQbGFjZW1lbnQsIElubGluZVBvc2l0aW9uaW5nLCBQcm9wc30gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHthcnJheUZyb20sIGdldEJhc2VQbGFjZW1lbnR9IGZyb20gJy4uL3V0aWxzJztcblxuZnVuY3Rpb24gZ2V0UHJvcHMocHJvcHM6IFByb3BzLCBtb2RpZmllcjogTW9kaWZpZXI8YW55LCBhbnk+KTogUGFydGlhbDxQcm9wcz4ge1xuICByZXR1cm4ge1xuICAgIHBvcHBlck9wdGlvbnM6IHtcbiAgICAgIC4uLnByb3BzLnBvcHBlck9wdGlvbnMsXG4gICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAgLi4uKHByb3BzLnBvcHBlck9wdGlvbnM/Lm1vZGlmaWVycyB8fCBbXSkuZmlsdGVyKFxuICAgICAgICAgICh7bmFtZX0pID0+IG5hbWUgIT09IG1vZGlmaWVyLm5hbWVcbiAgICAgICAgKSxcbiAgICAgICAgbW9kaWZpZXIsXG4gICAgICBdLFxuICAgIH0sXG4gIH07XG59XG5cbmNvbnN0IGlubGluZVBvc2l0aW9uaW5nOiBJbmxpbmVQb3NpdGlvbmluZyA9IHtcbiAgbmFtZTogJ2lubGluZVBvc2l0aW9uaW5nJyxcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgZm4oaW5zdGFuY2UpIHtcbiAgICBjb25zdCB7cmVmZXJlbmNlfSA9IGluc3RhbmNlO1xuXG4gICAgZnVuY3Rpb24gaXNFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuICEhaW5zdGFuY2UucHJvcHMuaW5saW5lUG9zaXRpb25pbmc7XG4gICAgfVxuXG4gICAgbGV0IHBsYWNlbWVudDogUGxhY2VtZW50O1xuICAgIGxldCBjdXJzb3JSZWN0SW5kZXggPSAtMTtcbiAgICBsZXQgaXNJbnRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIGxldCB0cmllZFBsYWNlbWVudHM6IEFycmF5PHN0cmluZz4gPSBbXTtcblxuICAgIGNvbnN0IG1vZGlmaWVyOiBNb2RpZmllcjxcbiAgICAgICd0aXBweUlubGluZVBvc2l0aW9uaW5nJyxcbiAgICAgIFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICAgPiA9IHtcbiAgICAgIG5hbWU6ICd0aXBweUlubGluZVBvc2l0aW9uaW5nJyxcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBwaGFzZTogJ2FmdGVyV3JpdGUnLFxuICAgICAgZm4oe3N0YXRlfSkge1xuICAgICAgICBpZiAoaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICBpZiAodHJpZWRQbGFjZW1lbnRzLmluZGV4T2Yoc3RhdGUucGxhY2VtZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRyaWVkUGxhY2VtZW50cyA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHBsYWNlbWVudCAhPT0gc3RhdGUucGxhY2VtZW50ICYmXG4gICAgICAgICAgICB0cmllZFBsYWNlbWVudHMuaW5kZXhPZihzdGF0ZS5wbGFjZW1lbnQpID09PSAtMVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdHJpZWRQbGFjZW1lbnRzLnB1c2goc3RhdGUucGxhY2VtZW50KTtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIHVubmVlZGVkIERPTVJlY3QgcHJvcGVydGllc1xuICAgICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiAoKSA9PlxuICAgICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Qoc3RhdGUucGxhY2VtZW50KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBsYWNlbWVudCA9IHN0YXRlLnBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdChwbGFjZW1lbnQ6IFBsYWNlbWVudCk6IFBhcnRpYWw8RE9NUmVjdD4ge1xuICAgICAgcmV0dXJuIGdldElubGluZUJvdW5kaW5nQ2xpZW50UmVjdChcbiAgICAgICAgZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpLFxuICAgICAgICByZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGFycmF5RnJvbShyZWZlcmVuY2UuZ2V0Q2xpZW50UmVjdHMoKSksXG4gICAgICAgIGN1cnNvclJlY3RJbmRleFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRJbnRlcm5hbFByb3BzKHBhcnRpYWxQcm9wczogUGFydGlhbDxQcm9wcz4pOiB2b2lkIHtcbiAgICAgIGlzSW50ZXJuYWxVcGRhdGUgPSB0cnVlO1xuICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMocGFydGlhbFByb3BzKTtcbiAgICAgIGlzSW50ZXJuYWxVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRNb2RpZmllcigpOiB2b2lkIHtcbiAgICAgIGlmICghaXNJbnRlcm5hbFVwZGF0ZSkge1xuICAgICAgICBzZXRJbnRlcm5hbFByb3BzKGdldFByb3BzKGluc3RhbmNlLnByb3BzLCBtb2RpZmllcikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvbkNyZWF0ZTogYWRkTW9kaWZpZXIsXG4gICAgICBvbkFmdGVyVXBkYXRlOiBhZGRNb2RpZmllcixcbiAgICAgIG9uVHJpZ2dlcihfLCBldmVudCk6IHZvaWQge1xuICAgICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgIGNvbnN0IHJlY3RzID0gYXJyYXlGcm9tKGluc3RhbmNlLnJlZmVyZW5jZS5nZXRDbGllbnRSZWN0cygpKTtcbiAgICAgICAgICBjb25zdCBjdXJzb3JSZWN0ID0gcmVjdHMuZmluZChcbiAgICAgICAgICAgIChyZWN0KSA9PlxuICAgICAgICAgICAgICByZWN0LmxlZnQgLSAyIDw9IGV2ZW50LmNsaWVudFggJiZcbiAgICAgICAgICAgICAgcmVjdC5yaWdodCArIDIgPj0gZXZlbnQuY2xpZW50WCAmJlxuICAgICAgICAgICAgICByZWN0LnRvcCAtIDIgPD0gZXZlbnQuY2xpZW50WSAmJlxuICAgICAgICAgICAgICByZWN0LmJvdHRvbSArIDIgPj0gZXZlbnQuY2xpZW50WVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSByZWN0cy5pbmRleE9mKGN1cnNvclJlY3QpO1xuICAgICAgICAgIGN1cnNvclJlY3RJbmRleCA9IGluZGV4ID4gLTEgPyBpbmRleCA6IGN1cnNvclJlY3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uSGlkZGVuKCk6IHZvaWQge1xuICAgICAgICBjdXJzb3JSZWN0SW5kZXggPSAtMTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlubGluZVBvc2l0aW9uaW5nO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5saW5lQm91bmRpbmdDbGllbnRSZWN0KFxuICBjdXJyZW50QmFzZVBsYWNlbWVudDogQmFzZVBsYWNlbWVudCB8IG51bGwsXG4gIGJvdW5kaW5nUmVjdDogRE9NUmVjdCxcbiAgY2xpZW50UmVjdHM6IERPTVJlY3RbXSxcbiAgY3Vyc29yUmVjdEluZGV4OiBudW1iZXJcbik6IHtcbiAgdG9wOiBudW1iZXI7XG4gIGJvdHRvbTogbnVtYmVyO1xuICBsZWZ0OiBudW1iZXI7XG4gIHJpZ2h0OiBudW1iZXI7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xufSB7XG4gIC8vIE5vdCBhbiBpbmxpbmUgZWxlbWVudCwgb3IgcGxhY2VtZW50IGlzIG5vdCB5ZXQga25vd25cbiAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA8IDIgfHwgY3VycmVudEJhc2VQbGFjZW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gYm91bmRpbmdSZWN0O1xuICB9XG5cbiAgLy8gVGhlcmUgYXJlIHR3byByZWN0cyBhbmQgdGhleSBhcmUgZGlzam9pbmVkXG4gIGlmIChcbiAgICBjbGllbnRSZWN0cy5sZW5ndGggPT09IDIgJiZcbiAgICBjdXJzb3JSZWN0SW5kZXggPj0gMCAmJlxuICAgIGNsaWVudFJlY3RzWzBdLmxlZnQgPiBjbGllbnRSZWN0c1sxXS5yaWdodFxuICApIHtcbiAgICByZXR1cm4gY2xpZW50UmVjdHNbY3Vyc29yUmVjdEluZGV4XSB8fCBib3VuZGluZ1JlY3Q7XG4gIH1cblxuICBzd2l0Y2ggKGN1cnJlbnRCYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICBjYXNlICdib3R0b20nOiB7XG4gICAgICBjb25zdCBmaXJzdFJlY3QgPSBjbGllbnRSZWN0c1swXTtcbiAgICAgIGNvbnN0IGxhc3RSZWN0ID0gY2xpZW50UmVjdHNbY2xpZW50UmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBpc1RvcCA9IGN1cnJlbnRCYXNlUGxhY2VtZW50ID09PSAndG9wJztcblxuICAgICAgY29uc3QgdG9wID0gZmlyc3RSZWN0LnRvcDtcbiAgICAgIGNvbnN0IGJvdHRvbSA9IGxhc3RSZWN0LmJvdHRvbTtcbiAgICAgIGNvbnN0IGxlZnQgPSBpc1RvcCA/IGZpcnN0UmVjdC5sZWZ0IDogbGFzdFJlY3QubGVmdDtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gaXNUb3AgPyBmaXJzdFJlY3QucmlnaHQgOiBsYXN0UmVjdC5yaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuXG4gICAgICByZXR1cm4ge3RvcCwgYm90dG9tLCBsZWZ0LCByaWdodCwgd2lkdGgsIGhlaWdodH07XG4gICAgfVxuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3JpZ2h0Jzoge1xuICAgICAgY29uc3QgbWluTGVmdCA9IE1hdGgubWluKC4uLmNsaWVudFJlY3RzLm1hcCgocmVjdHMpID0+IHJlY3RzLmxlZnQpKTtcbiAgICAgIGNvbnN0IG1heFJpZ2h0ID0gTWF0aC5tYXgoLi4uY2xpZW50UmVjdHMubWFwKChyZWN0cykgPT4gcmVjdHMucmlnaHQpKTtcbiAgICAgIGNvbnN0IG1lYXN1cmVSZWN0cyA9IGNsaWVudFJlY3RzLmZpbHRlcigocmVjdCkgPT5cbiAgICAgICAgY3VycmVudEJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0J1xuICAgICAgICAgID8gcmVjdC5sZWZ0ID09PSBtaW5MZWZ0XG4gICAgICAgICAgOiByZWN0LnJpZ2h0ID09PSBtYXhSaWdodFxuICAgICAgKTtcblxuICAgICAgY29uc3QgdG9wID0gbWVhc3VyZVJlY3RzWzBdLnRvcDtcbiAgICAgIGNvbnN0IGJvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgY29uc3QgbGVmdCA9IG1pbkxlZnQ7XG4gICAgICBjb25zdCByaWdodCA9IG1heFJpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG5cbiAgICAgIHJldHVybiB7dG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0LCB3aWR0aCwgaGVpZ2h0fTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIGJvdW5kaW5nUmVjdDtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQge1ZpcnR1YWxFbGVtZW50fSBmcm9tICdAcG9wcGVyanMvY29yZSc7XG5pbXBvcnQge1JlZmVyZW5jZUVsZW1lbnQsIFN0aWNreX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCBzdGlja3k6IFN0aWNreSA9IHtcbiAgbmFtZTogJ3N0aWNreScsXG4gIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gIGZuKGluc3RhbmNlKSB7XG4gICAgY29uc3Qge3JlZmVyZW5jZSwgcG9wcGVyfSA9IGluc3RhbmNlO1xuXG4gICAgZnVuY3Rpb24gZ2V0UmVmZXJlbmNlKCk6IFJlZmVyZW5jZUVsZW1lbnQgfCBWaXJ0dWFsRWxlbWVudCB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UucG9wcGVySW5zdGFuY2VcbiAgICAgICAgPyBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5zdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2VcbiAgICAgICAgOiByZWZlcmVuY2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvdWxkQ2hlY2sodmFsdWU6ICdyZWZlcmVuY2UnIHwgJ3BvcHBlcicpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5wcm9wcy5zdGlja3kgPT09IHRydWUgfHwgaW5zdGFuY2UucHJvcHMuc3RpY2t5ID09PSB2YWx1ZTtcbiAgICB9XG5cbiAgICBsZXQgcHJldlJlZlJlY3Q6IENsaWVudFJlY3QgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgcHJldlBvcFJlY3Q6IENsaWVudFJlY3QgfCBudWxsID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKCk6IHZvaWQge1xuICAgICAgY29uc3QgY3VycmVudFJlZlJlY3QgPSBzaG91bGRDaGVjaygncmVmZXJlbmNlJylcbiAgICAgICAgPyBnZXRSZWZlcmVuY2UoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICA6IG51bGw7XG4gICAgICBjb25zdCBjdXJyZW50UG9wUmVjdCA9IHNob3VsZENoZWNrKCdwb3BwZXInKVxuICAgICAgICA/IHBvcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICA6IG51bGw7XG5cbiAgICAgIGlmIChcbiAgICAgICAgKGN1cnJlbnRSZWZSZWN0ICYmIGFyZVJlY3RzRGlmZmVyZW50KHByZXZSZWZSZWN0LCBjdXJyZW50UmVmUmVjdCkpIHx8XG4gICAgICAgIChjdXJyZW50UG9wUmVjdCAmJiBhcmVSZWN0c0RpZmZlcmVudChwcmV2UG9wUmVjdCwgY3VycmVudFBvcFJlY3QpKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByZXZSZWZSZWN0ID0gY3VycmVudFJlZlJlY3Q7XG4gICAgICBwcmV2UG9wUmVjdCA9IGN1cnJlbnRQb3BSZWN0O1xuXG4gICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGVQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uTW91bnQoKTogdm9pZCB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5zdGlja3kpIHtcbiAgICAgICAgICB1cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzdGlja3k7XG5cbmZ1bmN0aW9uIGFyZVJlY3RzRGlmZmVyZW50KFxuICByZWN0QTogQ2xpZW50UmVjdCB8IG51bGwsXG4gIHJlY3RCOiBDbGllbnRSZWN0IHwgbnVsbFxuKTogYm9vbGVhbiB7XG4gIGlmIChyZWN0QSAmJiByZWN0Qikge1xuICAgIHJldHVybiAoXG4gICAgICByZWN0QS50b3AgIT09IHJlY3RCLnRvcCB8fFxuICAgICAgcmVjdEEucmlnaHQgIT09IHJlY3RCLnJpZ2h0IHx8XG4gICAgICByZWN0QS5ib3R0b20gIT09IHJlY3RCLmJvdHRvbSB8fFxuICAgICAgcmVjdEEubGVmdCAhPT0gcmVjdEIubGVmdFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsICJpbXBvcnQgdGlwcHkgZnJvbSAnLi4vc3JjJztcbmltcG9ydCB7cmVuZGVyfSBmcm9tICcuLi9zcmMvdGVtcGxhdGUnO1xuXG50aXBweS5zZXREZWZhdWx0UHJvcHMoe3JlbmRlcn0pO1xuXG5leHBvcnQge2RlZmF1bHQsIGhpZGVBbGx9IGZyb20gJy4uL3NyYyc7XG5leHBvcnQge2RlZmF1bHQgYXMgY3JlYXRlU2luZ2xldG9ufSBmcm9tICcuLi9zcmMvYWRkb25zL2NyZWF0ZVNpbmdsZXRvbic7XG5leHBvcnQge2RlZmF1bHQgYXMgZGVsZWdhdGV9IGZyb20gJy4uL3NyYy9hZGRvbnMvZGVsZWdhdGUnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGFuaW1hdGVGaWxsfSBmcm9tICcuLi9zcmMvcGx1Z2lucy9hbmltYXRlRmlsbCc7XG5leHBvcnQge2RlZmF1bHQgYXMgZm9sbG93Q3Vyc29yfSBmcm9tICcuLi9zcmMvcGx1Z2lucy9mb2xsb3dDdXJzb3InO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGlubGluZVBvc2l0aW9uaW5nfSBmcm9tICcuLi9zcmMvcGx1Z2lucy9pbmxpbmVQb3NpdGlvbmluZyc7XG5leHBvcnQge2RlZmF1bHQgYXMgc3RpY2t5fSBmcm9tICcuLi9zcmMvcGx1Z2lucy9zdGlja3knO1xuZXhwb3J0IHtST1VORF9BUlJPVyBhcyByb3VuZEFycm93fSBmcm9tICcuLi9zcmMvY29uc3RhbnRzJztcbiIsICJpbXBvcnQge1xuICBFZGl0b3IsIGlzTm9kZVNlbGVjdGlvbiwgaXNUZXh0U2VsZWN0aW9uLCBwb3NUb0RPTVJlY3QsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IEVkaXRvclN0YXRlLCBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuaW1wb3J0IHRpcHB5LCB7IEluc3RhbmNlLCBQcm9wcyB9IGZyb20gJ3RpcHB5LmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEJ1YmJsZU1lbnVQbHVnaW5Qcm9wcyB7XG4gIHBsdWdpbktleTogUGx1Z2luS2V5IHwgc3RyaW5nXG4gIGVkaXRvcjogRWRpdG9yXG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50XG4gIHRpcHB5T3B0aW9ucz86IFBhcnRpYWw8UHJvcHM+XG4gIHVwZGF0ZURlbGF5PzogbnVtYmVyXG4gIHNob3VsZFNob3c/OlxuICAgIHwgKChwcm9wczoge1xuICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICB2aWV3OiBFZGl0b3JWaWV3XG4gICAgICAgIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICAgICAgICBvbGRTdGF0ZT86IEVkaXRvclN0YXRlXG4gICAgICAgIGZyb206IG51bWJlclxuICAgICAgICB0bzogbnVtYmVyXG4gICAgICB9KSA9PiBib29sZWFuKVxuICAgIHwgbnVsbFxufVxuXG5leHBvcnQgdHlwZSBCdWJibGVNZW51Vmlld1Byb3BzID0gQnViYmxlTWVudVBsdWdpblByb3BzICYge1xuICB2aWV3OiBFZGl0b3JWaWV3XG59XG5cbmV4cG9ydCBjbGFzcyBCdWJibGVNZW51VmlldyB7XG4gIHB1YmxpYyBlZGl0b3I6IEVkaXRvclxuXG4gIHB1YmxpYyBlbGVtZW50OiBIVE1MRWxlbWVudFxuXG4gIHB1YmxpYyB2aWV3OiBFZGl0b3JWaWV3XG5cbiAgcHVibGljIHByZXZlbnRIaWRlID0gZmFsc2VcblxuICBwdWJsaWMgdGlwcHk6IEluc3RhbmNlIHwgdW5kZWZpbmVkXG5cbiAgcHVibGljIHRpcHB5T3B0aW9ucz86IFBhcnRpYWw8UHJvcHM+XG5cbiAgcHVibGljIHVwZGF0ZURlbGF5OiBudW1iZXJcblxuICBwcml2YXRlIHVwZGF0ZURlYm91bmNlVGltZXI6IG51bWJlciB8IHVuZGVmaW5lZFxuXG4gIHB1YmxpYyBzaG91bGRTaG93OiBFeGNsdWRlPEJ1YmJsZU1lbnVQbHVnaW5Qcm9wc1snc2hvdWxkU2hvdyddLCBudWxsPiA9ICh7XG4gICAgdmlldyxcbiAgICBzdGF0ZSxcbiAgICBmcm9tLFxuICAgIHRvLFxuICB9KSA9PiB7XG4gICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgICBjb25zdCB7IGVtcHR5IH0gPSBzZWxlY3Rpb25cblxuICAgIC8vIFNvbWV0aW1lIGNoZWNrIGZvciBgZW1wdHlgIGlzIG5vdCBlbm91Z2guXG4gICAgLy8gRG91YmxlY2xpY2sgYW4gZW1wdHkgcGFyYWdyYXBoIHJldHVybnMgYSBub2RlIHNpemUgb2YgMi5cbiAgICAvLyBTbyB3ZSBjaGVjayBhbHNvIGZvciBhbiBlbXB0eSB0ZXh0IHNpemUuXG4gICAgY29uc3QgaXNFbXB0eVRleHRCbG9jayA9ICFkb2MudGV4dEJldHdlZW4oZnJvbSwgdG8pLmxlbmd0aCAmJiBpc1RleHRTZWxlY3Rpb24oc3RhdGUuc2VsZWN0aW9uKVxuXG4gICAgLy8gV2hlbiBjbGlja2luZyBvbiBhIGVsZW1lbnQgaW5zaWRlIHRoZSBidWJibGUgbWVudSB0aGUgZWRpdG9yIFwiYmx1clwiIGV2ZW50XG4gICAgLy8gaXMgY2FsbGVkIGFuZCB0aGUgYnViYmxlIG1lbnUgaXRlbSBpcyBmb2N1c3NlZC4gSW4gdGhpcyBjYXNlIHdlIHNob3VsZFxuICAgIC8vIGNvbnNpZGVyIHRoZSBtZW51IGFzIHBhcnQgb2YgdGhlIGVkaXRvciBhbmQga2VlcCBzaG93aW5nIHRoZSBtZW51XG4gICAgY29uc3QgaXNDaGlsZE9mTWVudSA9IHRoaXMuZWxlbWVudC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuXG4gICAgY29uc3QgaGFzRWRpdG9yRm9jdXMgPSB2aWV3Lmhhc0ZvY3VzKCkgfHwgaXNDaGlsZE9mTWVudVxuXG4gICAgaWYgKCFoYXNFZGl0b3JGb2N1cyB8fCBlbXB0eSB8fCBpc0VtcHR5VGV4dEJsb2NrIHx8ICF0aGlzLmVkaXRvci5pc0VkaXRhYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIGVkaXRvcixcbiAgICBlbGVtZW50LFxuICAgIHZpZXcsXG4gICAgdGlwcHlPcHRpb25zID0ge30sXG4gICAgdXBkYXRlRGVsYXkgPSAyNTAsXG4gICAgc2hvdWxkU2hvdyxcbiAgfTogQnViYmxlTWVudVZpZXdQcm9wcykge1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudFxuICAgIHRoaXMudmlldyA9IHZpZXdcbiAgICB0aGlzLnVwZGF0ZURlbGF5ID0gdXBkYXRlRGVsYXlcblxuICAgIGlmIChzaG91bGRTaG93KSB7XG4gICAgICB0aGlzLnNob3VsZFNob3cgPSBzaG91bGRTaG93XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2Vkb3duSGFuZGxlciwgeyBjYXB0dXJlOiB0cnVlIH0pXG4gICAgdGhpcy52aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLmRyYWdzdGFydEhhbmRsZXIpXG4gICAgdGhpcy5lZGl0b3Iub24oJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpXG4gICAgdGhpcy5lZGl0b3Iub24oJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKVxuICAgIHRoaXMudGlwcHlPcHRpb25zID0gdGlwcHlPcHRpb25zXG4gICAgLy8gRGV0YWNoZXMgbWVudSBjb250ZW50IGZyb20gaXRzIGN1cnJlbnQgcGFyZW50XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZSgpXG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgfVxuXG4gIG1vdXNlZG93bkhhbmRsZXIgPSAoKSA9PiB7XG4gICAgdGhpcy5wcmV2ZW50SGlkZSA9IHRydWVcbiAgfVxuXG4gIGRyYWdzdGFydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgdGhpcy5oaWRlKClcbiAgfVxuXG4gIGZvY3VzSGFuZGxlciA9ICgpID0+IHtcbiAgICAvLyB3ZSB1c2UgYHNldFRpbWVvdXRgIHRvIG1ha2Ugc3VyZSBgc2VsZWN0aW9uYCBpcyBhbHJlYWR5IHVwZGF0ZWRcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlKHRoaXMuZWRpdG9yLnZpZXcpKVxuICB9XG5cbiAgYmx1ckhhbmRsZXIgPSAoeyBldmVudCB9OiB7IGV2ZW50OiBGb2N1c0V2ZW50IH0pID0+IHtcbiAgICBpZiAodGhpcy5wcmV2ZW50SGlkZSkge1xuICAgICAgdGhpcy5wcmV2ZW50SGlkZSA9IGZhbHNlXG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChldmVudD8ucmVsYXRlZFRhcmdldCAmJiB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZT8uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCBhcyBOb2RlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5oaWRlKClcbiAgfVxuXG4gIHRpcHB5Qmx1ckhhbmRsZXIgPSAoZXZlbnQ6IEZvY3VzRXZlbnQpID0+IHtcbiAgICB0aGlzLmJsdXJIYW5kbGVyKHsgZXZlbnQgfSlcbiAgfVxuXG4gIGNyZWF0ZVRvb2x0aXAoKSB7XG4gICAgY29uc3QgeyBlbGVtZW50OiBlZGl0b3JFbGVtZW50IH0gPSB0aGlzLmVkaXRvci5vcHRpb25zXG4gICAgY29uc3QgZWRpdG9ySXNBdHRhY2hlZCA9ICEhZWRpdG9yRWxlbWVudC5wYXJlbnRFbGVtZW50XG5cbiAgICBpZiAodGhpcy50aXBweSB8fCAhZWRpdG9ySXNBdHRhY2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy50aXBweSA9IHRpcHB5KGVkaXRvckVsZW1lbnQsIHtcbiAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogbnVsbCxcbiAgICAgIGNvbnRlbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgICAgdHJpZ2dlcjogJ21hbnVhbCcsXG4gICAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgICAgaGlkZU9uQ2xpY2s6ICd0b2dnbGUnLFxuICAgICAgLi4udGhpcy50aXBweU9wdGlvbnMsXG4gICAgfSlcblxuICAgIC8vIG1heWJlIHdlIGhhdmUgdG8gaGlkZSB0aXBweSBvbiBpdHMgb3duIGJsdXIgZXZlbnQgYXMgd2VsbFxuICAgIGlmICh0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkKSB7XG4gICAgICAodGhpcy50aXBweS5wb3BwZXIuZmlyc3RDaGlsZCBhcyBIVE1MRWxlbWVudCkuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMudGlwcHlCbHVySGFuZGxlcilcbiAgICB9XG4gIH1cblxuICB1cGRhdGUodmlldzogRWRpdG9yVmlldywgb2xkU3RhdGU/OiBFZGl0b3JTdGF0ZSkge1xuICAgIGNvbnN0IHsgc3RhdGUgfSA9IHZpZXdcbiAgICBjb25zdCBoYXNWYWxpZFNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wb3MgIT09IHN0YXRlLnNlbGVjdGlvbi4kdG8ucG9zXG5cbiAgICBpZiAodGhpcy51cGRhdGVEZWxheSA+IDAgJiYgaGFzVmFsaWRTZWxlY3Rpb24pIHtcbiAgICAgIHRoaXMuaGFuZGxlRGVib3VuY2VkVXBkYXRlKHZpZXcsIG9sZFN0YXRlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0aW9uQ2hhbmdlZCA9ICFvbGRTdGF0ZT8uc2VsZWN0aW9uLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKVxuICAgIGNvbnN0IGRvY0NoYW5nZWQgPSAhb2xkU3RhdGU/LmRvYy5lcSh2aWV3LnN0YXRlLmRvYylcblxuICAgIHRoaXMudXBkYXRlSGFuZGxlcih2aWV3LCBzZWxlY3Rpb25DaGFuZ2VkLCBkb2NDaGFuZ2VkLCBvbGRTdGF0ZSlcbiAgfVxuXG4gIGhhbmRsZURlYm91bmNlZFVwZGF0ZSA9ICh2aWV3OiBFZGl0b3JWaWV3LCBvbGRTdGF0ZT86IEVkaXRvclN0YXRlKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uQ2hhbmdlZCA9ICFvbGRTdGF0ZT8uc2VsZWN0aW9uLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKVxuICAgIGNvbnN0IGRvY0NoYW5nZWQgPSAhb2xkU3RhdGU/LmRvYy5lcSh2aWV3LnN0YXRlLmRvYylcblxuICAgIGlmICghc2VsZWN0aW9uQ2hhbmdlZCAmJiAhZG9jQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudXBkYXRlRGVib3VuY2VUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudXBkYXRlRGVib3VuY2VUaW1lcilcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZURlYm91bmNlVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZUhhbmRsZXIodmlldywgc2VsZWN0aW9uQ2hhbmdlZCwgZG9jQ2hhbmdlZCwgb2xkU3RhdGUpXG4gICAgfSwgdGhpcy51cGRhdGVEZWxheSlcbiAgfVxuXG4gIHVwZGF0ZUhhbmRsZXIgPSAodmlldzogRWRpdG9yVmlldywgc2VsZWN0aW9uQ2hhbmdlZDogYm9vbGVhbiwgZG9jQ2hhbmdlZDogYm9vbGVhbiwgb2xkU3RhdGU/OiBFZGl0b3JTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IHsgc3RhdGUsIGNvbXBvc2luZyB9ID0gdmlld1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuXG4gICAgY29uc3QgaXNTYW1lID0gIXNlbGVjdGlvbkNoYW5nZWQgJiYgIWRvY0NoYW5nZWRcblxuICAgIGlmIChjb21wb3NpbmcgfHwgaXNTYW1lKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmNyZWF0ZVRvb2x0aXAoKVxuXG4gICAgLy8gc3VwcG9ydCBmb3IgQ2VsbFNlbGVjdGlvbnNcbiAgICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uXG4gICAgY29uc3QgZnJvbSA9IE1hdGgubWluKC4uLnJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuJGZyb20ucG9zKSlcbiAgICBjb25zdCB0byA9IE1hdGgubWF4KC4uLnJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuJHRvLnBvcykpXG5cbiAgICBjb25zdCBzaG91bGRTaG93ID0gdGhpcy5zaG91bGRTaG93Py4oe1xuICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgIHZpZXcsXG4gICAgICBzdGF0ZSxcbiAgICAgIG9sZFN0YXRlLFxuICAgICAgZnJvbSxcbiAgICAgIHRvLFxuICAgIH0pXG5cbiAgICBpZiAoIXNob3VsZFNob3cpIHtcbiAgICAgIHRoaXMuaGlkZSgpXG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMudGlwcHk/LnNldFByb3BzKHtcbiAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6XG4gICAgICAgIHRoaXMudGlwcHlPcHRpb25zPy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0XG4gICAgICAgIHx8ICgoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzTm9kZVNlbGVjdGlvbihzdGF0ZS5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHZpZXcubm9kZURPTShmcm9tKSBhcyBIVE1MRWxlbWVudFxuXG4gICAgICAgICAgICBjb25zdCBub2RlVmlld1dyYXBwZXIgPSBub2RlLmRhdGFzZXQubm9kZVZpZXdXcmFwcGVyID8gbm9kZSA6IG5vZGUucXVlcnlTZWxlY3RvcignW2RhdGEtbm9kZS12aWV3LXdyYXBwZXJdJylcblxuICAgICAgICAgICAgaWYgKG5vZGVWaWV3V3JhcHBlcikge1xuICAgICAgICAgICAgICBub2RlID0gbm9kZVZpZXdXcmFwcGVyLmZpcnN0Q2hpbGQgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcG9zVG9ET01SZWN0KHZpZXcsIGZyb20sIHRvKVxuICAgICAgICB9KSxcbiAgICB9KVxuXG4gICAgdGhpcy5zaG93KClcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgdGhpcy50aXBweT8uc2hvdygpXG4gIH1cblxuICBoaWRlKCkge1xuICAgIHRoaXMudGlwcHk/LmhpZGUoKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy50aXBweT8ucG9wcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICh0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkIGFzIEhUTUxFbGVtZW50KS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAnYmx1cicsXG4gICAgICAgIHRoaXMudGlwcHlCbHVySGFuZGxlcixcbiAgICAgIClcbiAgICB9XG4gICAgdGhpcy50aXBweT8uZGVzdHJveSgpXG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2Vkb3duSGFuZGxlciwgeyBjYXB0dXJlOiB0cnVlIH0pXG4gICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLmRyYWdzdGFydEhhbmRsZXIpXG4gICAgdGhpcy5lZGl0b3Iub2ZmKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyKVxuICAgIHRoaXMuZWRpdG9yLm9mZignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXIpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEJ1YmJsZU1lbnVQbHVnaW4gPSAob3B0aW9uczogQnViYmxlTWVudVBsdWdpblByb3BzKSA9PiB7XG4gIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICBrZXk6XG4gICAgICB0eXBlb2Ygb3B0aW9ucy5wbHVnaW5LZXkgPT09ICdzdHJpbmcnID8gbmV3IFBsdWdpbktleShvcHRpb25zLnBsdWdpbktleSkgOiBvcHRpb25zLnBsdWdpbktleSxcbiAgICB2aWV3OiB2aWV3ID0+IG5ldyBCdWJibGVNZW51Vmlldyh7IHZpZXcsIC4uLm9wdGlvbnMgfSksXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5pbXBvcnQgeyBCdWJibGVNZW51UGx1Z2luLCBCdWJibGVNZW51UGx1Z2luUHJvcHMgfSBmcm9tICcuL2J1YmJsZS1tZW51LXBsdWdpbi5qcydcblxuZXhwb3J0IHR5cGUgQnViYmxlTWVudU9wdGlvbnMgPSBPbWl0PEJ1YmJsZU1lbnVQbHVnaW5Qcm9wcywgJ2VkaXRvcicgfCAnZWxlbWVudCc+ICYge1xuICBlbGVtZW50OiBIVE1MRWxlbWVudCB8IG51bGwsXG59XG5cbmV4cG9ydCBjb25zdCBCdWJibGVNZW51ID0gRXh0ZW5zaW9uLmNyZWF0ZTxCdWJibGVNZW51T3B0aW9ucz4oe1xuICBuYW1lOiAnYnViYmxlTWVudScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudDogbnVsbCxcbiAgICAgIHRpcHB5T3B0aW9uczoge30sXG4gICAgICBwbHVnaW5LZXk6ICdidWJibGVNZW51JyxcbiAgICAgIHVwZGF0ZURlbGF5OiB1bmRlZmluZWQsXG4gICAgICBzaG91bGRTaG93OiBudWxsLFxuICAgIH1cbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZWxlbWVudCkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIEJ1YmJsZU1lbnVQbHVnaW4oe1xuICAgICAgICBwbHVnaW5LZXk6IHRoaXMub3B0aW9ucy5wbHVnaW5LZXksXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgIGVsZW1lbnQ6IHRoaXMub3B0aW9ucy5lbGVtZW50LFxuICAgICAgICB0aXBweU9wdGlvbnM6IHRoaXMub3B0aW9ucy50aXBweU9wdGlvbnMsXG4gICAgICAgIHVwZGF0ZURlbGF5OiB0aGlzLm9wdGlvbnMudXBkYXRlRGVsYXksXG4gICAgICAgIHNob3VsZFNob3c6IHRoaXMub3B0aW9ucy5zaG91bGRTaG93LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQge0V4dGVuc2lvbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgY29uc3QgQ2xhc3NFeHRlbnNpb24gPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnY2xhc3NFeHRlbnNpb24nLFxuXG4gICAgYWRkR2xvYmFsQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlczogW1xuICAgICAgICAgICAgICAgICAgICAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgICAgICdwYXJhZ3JhcGgnLFxuICAgICAgICAgICAgICAgICAgICAnbGluaycsXG4gICAgICAgICAgICAgICAgICAgICdpbWFnZScsXG4gICAgICAgICAgICAgICAgICAgICdsaXN0SXRlbScsXG4gICAgICAgICAgICAgICAgICAgICdidWxsZXRMaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ29yZGVyZWRMaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ3RhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RhYmxlSGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RhYmxlUm93JyxcbiAgICAgICAgICAgICAgICAgICAgJ3RhYmxlQ2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0U3R5bGUnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSFRNTDogZWxlbWVudCA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA/PyBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVySFRNTDogYXR0cmlidXRlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogYXR0cmlidXRlcy5jbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF1cbiAgICB9XG59KSIsICJpbXBvcnQge0V4dGVuc2lvbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgY29uc3QgSWRFeHRlbnNpb24gPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnaWRFeHRlbnNpb24nLFxuXG4gICAgYWRkR2xvYmFsQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlczogW1xuICAgICAgICAgICAgICAgICAgICAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgICAgICdsaW5rJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJykgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckhUTUw6IGF0dHJpYnV0ZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXR0cmlidXRlcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGF0dHJpYnV0ZXMuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdXG4gICAgfVxufSlcbiIsICIvLyBUSElTIEZJTEUgSVMgQVVUT01BVElDQUxMWSBHRU5FUkFURUQgRE8gTk9UIEVESVQgRElSRUNUTFlcbi8vIFNlZSB1cGRhdGUtdGxkcy5qcyBmb3IgZW5jb2RpbmcvZGVjb2RpbmcgZm9ybWF0XG4vLyBodHRwczovL2RhdGEuaWFuYS5vcmcvVExEL3RsZHMtYWxwaGEtYnktZG9tYWluLnR4dFxuY29uc3QgZW5jb2RlZFRsZHMgPSAnYWFhMXJwM2JiMG90dDN2aWU0YzFsZTJvZ2FkbzV1ZGhhYmk3YzBhZGVteTVjZW50dXJlNm91bnRhbnQwczlvMXRvcjRkMHMxdWx0NGUwZzFybzJ0bmE0ZjBsMXJpY2E1ZzBha2hhbjVlbmN5NWkwZzFyYnVzM2ZvcmNlNXRlbDVrZG4zbDBpYmFiYTRwYXk0bGZpbmFuejZzdGF0ZTV5MnNhY2UzdG9tNW0wYXpvbjRlcmljYW5leHByZXNzN2ZhbWlseTExeDJmYW0zaWNhM3N0ZXJkYW04bmFseXRpY3M3ZHJvaWQ1cXVhbjR6Mm8wbDJwYXJ0bWVudHM4cDBsZTRxMHVhcmVsbGU4cjBhYjFtY280Y2hpM215MnBhMnQwZTNzMGRhMmlhMnNvY2lhdGVzOXQwaGxldGE1dG9ybmV5N3UwY3Rpb241ZGkwYmxlM28zc3Bvc3Q1dGhvcjNvMHM0dmlhbmNhNncwczJ4MGEyejB1cmU1YmEwYnkyaWR1M25hbWV4M25hcmVwdWJsaWMxMWQxazJyMGNlbG9uYTVsYXljYXJkNHM1ZWZvb3Q1Z2FpbnM2c2ViYWxsNWtldGJhbGw4dWhhdXM1eWVybjViMGMxdDF2YTNjZzFuMmQxZTBhdHMydXR5NGVyMm50bGV5NXJsaW40c3QwYnV5NXQyZjFnMWgwYXJ0aTVpMGJsZTNkMWtlMm5nMG8zbzF6MmoxbGFjazBmcmlkYXk5b2NrYnVzdGVyOGcxb21iZXJnN3VlM20wczF3Mm4wcHBhcmliYXM5bzBhdHMzZWhyaW5nZXI4ZmEybTFuZDJvMGswaW5nNXNjaDJ0aWsyb240dDF1dGlxdWU2eDJyMGFkZXNjbzZpZGdlc3RvbmU5b2Fkd2F5NWtlcjN0aGVyNXVzc2VsczdzMXQxdWlsZDBlcnM2c2luZXNzNnkxenozdjF3MXkxejBoM2NhMGIxZmUybDBsMXZpbmtsZWluOW0wZXJhM3Aybm9uM3BldG93bjVpdGFsMG9uZThyMGF2YW40ZHMyZTBlcjBzNHMyc2ExZTFoMWlubzR0MGVyaW5nNWhvbGljN2JhMW4xcmUzYzFkMWVudGVyNG8xcm4zZjBhMWQyZzFoMGFuZWwybmVsNHJpdHk0c2UydDJlYXAzaW50YWk1cmlzdG1hczZvbWU0dXJjaDVpMHByaWFuaTZyY2xlNHNjbzN0YWRlbDRpMGMyeTNrMWwwYWltczRlYW5pbmc2aWNrMm5pYzFxdWU2b3RoaW5nNXVkM3ViMG1lZDZtMW4xbzBhY2gzZGVzM2ZmZWU0bGxlZ2U0b2duZTVtMGNhc3Q0bWJhbms0dW5pdHk2cGFueTJyZTN1dGVyNXNlYzRuZG9zM3N0cnVjdGlvbjh1bHRpbmc3dGFjdDNyYWN0b3JzOW9raW5nNGwxcDJyc2ljYTV1bnRyeTRwb24wczRyc2VzNnBhMnIwZWRpdDBjYXJkNHVuaW9uOWlja2V0NW93bjNzMXVpc2UwczZ1MGlzaW5lbGxhOXYxdzF4MXkwbXJ1M291M3oyZGFidXIzZDFuY2UzdGExZTFpbmczc3VuNHkyY2xrM2RzMmUwYWwwZXIyczNncmVlNGxpdmVyeTVsMW9pdHRlNXRhM21vY3JhdDZudGFsMmlzdDVzaTBnbjR2MmhsMmlhbW9uZHM2ZXQyZ2l0YWw1cmVjdDBvcnk3c2NvdW50M3ZlcjVoMnkyajFrMW0xbnAybzBjczF0b3I0ZzFtYWluczV0MXdubG9hZDdyaXZlNHR2MnViYWkzbmxvcDRwb250NHJiYW41dmFnMnIyejJlYXJ0aDN0MmMwbzJkZWthM3UwY2F0aW9uOGUxZzFtYWlsM2VyY2s1bmVyZ3k0Z2luZWVyMGluZzl0ZXJwcmlzZXMxMHBzb240cXVpcG1lbnQ4cjBpY3Nzb242bmkzczBxMXRhdGU1dDF1MHJvdmlzaW9uOHMydmVudHM1eGNoYW5nZTZwZXJ0M29zZWQ0cmVzczV0cmFzcGFjZTEwZmFnZTJpbDFyd2luZHM2dGgzbWlseTRuMHMycm0wZXJzNXNoaW9uNHQzZWRleDNlZGJhY2s2cnJhcmkzZXJvNmkwZGVsaXR5NW8ybG0ybmFsMW5jZTFpYWw3cmUwc3RvbmU2bWRhbGU2c2gwaW5nNXQwbmVzczZqMWsxbGlja3IzZ2h0czRyMm9yaXN0NHdlcnM1eTJtMW8wbzBkMXRiYWxsNnJkMWV4MnNhbGU0dW0zdW5kYXRpb244eDJyMGVlMXNlbml1czdsMW9nYW5zNG50aWVyN3RyMnVqaXRzdTVuMGQycm5pdHVyZTd0Ym9sNXlpM2dhMGwwbGVyeTNvMXVwNG1lMHMzcDFyZGVuNHkyYjBpejNkMG4yZTBhMW50MGluZzVvcmdlNWYxZzBlZTNoMWkwZnQwczN2ZXMyaW5nNWwwYXNzM2Uxb2JhbDJvNG0wYWlsM2JoMm8xeDJuMW9kYWRkeTVsZDBwb2ludDZmMm8wZHllYXI1ZzBsZTRwMXQxdjJwMXExcjBhaW5nZXI1cGhpY3M1dGlzNGVlbjNpcGUzb2Nlcnk0dXA0czF0MXUwYXJkaWFuNmNjaTNnZTJpZGUydGFyczVydTN3MXkyaGFpcjJtYnVyZzVuZ291dDV1czNibzJkZmMwYmFuazdlYWx0aDBjYXJlOGxwMXNpbmtpNnJlMW1lczVpcGhvcDRzYW1pdHN1N3RhY2hpNXYyazB0Mm0xbjFvY2tleTRsZGluZ3M1aWRheTVtZWRlcG90NWdvb2RzNXMwZW5zZTduZGEzcnNlM3NwaXRhbDV0MGluZzV0MGVsczNtYWlsNXVzZTN3MnIxc2JjM3QxdTBnaGVzNXlhdHQzdW5kYWk3aWJtMmNiYzJlMXUyZDFlMGVlM2ZtMmthbm80bDFtMGFtYXQ0ZGIybW8wYmlsaWVuOW4wYzFkdXN0cmllczhmaW5pdGk1bzJnMWsxc3RpdHV0ZTZ1cmFuY2U0ZTR0MGVybmF0aW9uYWwxMHVpdDR2ZXN0bWVudHMxMG8xcGlyYW5nYTdxMXIwaXNoNHMwbWFpbGk1dDBhbmJ1bDd0MGF1MnYzamFndWFyNHZhM2NiMmUwZXAydHp0M3dlbHJ5NmlvMmxsMm0wcDJuajJvMGJzMXVyZzR0MXkycDBtb3JnYW42cnMzdWVnb3M0bmlwZXI3a2F1ZmVuNWRkaTNlMHJyeWhvdGVsczZsb2dpc3RpY3M5cHJvcGVydGllczE0ZmgyZzFoMWkwYTFkczJtMW5kbGU0dGNoZW41d2kzbTFuMW9lbG4zbWF0c3U1c2hlcjVwMG1nMm4ycjBkMWVkM3Vva2dyb3VwOHcxeTBvdG80ejJsYTBjYWl4YTVtYm9yZ2hpbmk4ZXIzbmNhc3RlcjZkMHJvdmVyNnhlc3M1c2FsbGU1dDBpbm8zcm9iZTV3MHllcjViMWMxZHMyZWFzZTNjbGVyYzVmcmFrNGdhbDJvMnh1czRnYnQzaTBkbDJmZTBpbnN1cmFuY2U5c3R5bGU3Z2h0aW5nNmtlMmxseTNtaXRlZDRvMm5jb2xuNGsycHN5M3ZlMWluZzVrMWxjMXAyb2FuMHMzY2tlcjN1czNsMW5kb240dHRlMW8zdmUzcGwwZmluYW5jaWFsMTFyMXMxdDBkMGEzdTBuZGJlY2s2eGUxdXJ5NXYxeTJtYTBkcmlkNGlmMXNvbjRrZXVwNG4wYWdlbWVudDdnbzNwMXJrZXQwaW5nM3M0cmlvdHQ1c2hhbGxzN3R0ZWw1YmEyYzBraW5zZXk3ZDFlMGQwaWEzZXQybGJvdXJuZTdtZTFvcmlhbDZuMHUycmNrbXNkN2cxaDFpYW1pM2Nyb3NvZnQ3bDFuaTF0MnQwc3ViaXNoaTlrMWwwYjFzMm0wYTJuMW8wYmkwbGU0ZGEyZTFpMW0xbmFzaDNleTJzdGVyNXJtb24zdGdhZ2U2c2NvdzR0bzByY3ljbGVzOXYwaWU0cDFxMXIxczBkMnQwbjFyMnUwc2V1bTNpYzR2MXcxeDF5MXoybmEwYjFnb3lhNG1lMnR1cmE0dnkzYmEyYzFlMGMxdDBiYW5rNGZsaXg0d29yazV1c3RhcjV3MHMyeHQwZGlyZWN0N3VzNGYwbDJnMG8yaGsyaTBjbzJrZTFvbjNuamEzc3NhbjF5NWwxbzBraWEzcnRvbjR3MHJ1ejN0djRwMXIwYTF3MnR0MnUxeWMyejJvYmkxc2VydmVyN2ZmaWNlNWtpbmF3YTZsYXlhbjBncm91cDlkbmF2eTVsbzNtMGVnYTRuZTFnMWwwaW5lNW9vMnBlbjNyYWNsZTNuZ2U0ZzBhbmljNWlnaW5zNnNha2E0dHN1a2E0dDJ2aDNwYTBnZTJuYXNvbmljN3JpczJzMXRuZXJzNHMxeTN5MmNjdzNlMHQyZjBpemVyNWcxaDBhcm1hY3k2ZDFpbGlwczVvbmUydG8wZ3JhcGh5NnM0eXNpbzVpY3MxdGV0MnVyZXM2ZDFuMGcxazJvbmVlcjV6emE0azFsMGFjZTJ5MHN0YXRpb245dW1iaW5nNXMzbTFuMGMyb2hsMmtlcjNsaXRpZTVybjJzdDNyMGFtZXJpY2E2eGkzZXNzM2ltZTNvMGQwdWN0aW9uczhmMWdyZXNzaXZlOG1vMnBlcnRpZXMzeTV0ZWN0aW9uOHUwZGVudGlhbDlzMXQxdWIydzBjMnkycWExcG9uM3VlYmVjM3N0NXJhY2luZzRkaW80ZTBhZDFsZXN0YXRlNnRvcjJ5NGNpcGVzNWQwc3RvbmU1dW1icmVsbGE5aGFiM2lzZTBuM3QybGlhbmNlNm4wdDBhbHM1cGFpcjNvcnQzdWJsaWNhbjhzdDBhdXJhbnQ4dmlldzBzNXhyb3RoNmljaDBhcmRsaTZvaDNsMW8xcDJvMGNrczNkZW8zZ2VyczRvbTNzMHZwM3UwZ2J5M2hyMm4ydzBlMnl1a3l1NnNhMGFybGFuZDZmZTB0eTRrdXJhNGxlMW9uM21zY2x1YjR1bmc1bmR2aWswY29yb21hbnQxMm9maTRwMXJsMnMxdmUyeG8zYjBpMXMyYzBhMWIxaGFlZmZsZXI3bWlkdDRvbGFyc2hpcHM4b2wzdWxlM3dhcno1aWVuY2U1b3QzZDFlMGFyY2gzdDJjdXJlMWl0eTZlazJsZWN0NG5lcjNydmljZXM2dmVuM3cxeDB5M2ZyMmcxaDBhbmdyaWxhNnJwMncyZWxsM2lhMWtzaGE1b2VzMnAwcGluZzV1amkzdzNpMGxrMm5hMWdsZXM1dGUzajFrMGkwbjJ5MHBlNGwwaW5nNG0wYXJ0M2lsZTRuMGNmM28wY2NlcjNpYWw0ZnRiYW5rNHdhcmU2aHUybGFyMnV0aW9uczduZzF5MnkycGEwY2Uzb3J0MnQzcjBsMnMxdDBhZGEycGxlczRyMXRlYmFuazRmYXJtN2MwZ3JvdXA2b2NraG9sbTZyYWdlM2UzcmVhbTR1ZGlvMnkzeWxlNHUwY2tzM3BwbGllczN5Mm9ydDVyZjFnZXJ5NXp1a2k1djF3YXRjaDRpc3M0eDF5MGRuZXk0c3RlbXM2ejJ0YWIxaXBlaTRsazJvYmFvNHJnZXQ0dGFtb3RvcnM2cjJ0b280eDBpM2MwaTJkMGsyZWFtMmNoMG5vbG9neThsMW1hc2VrNW5uaXM0dmEzZjFnMWgwZDFlYXRlcjJyZTZpYWEyY2tldHM1ZW5kYTRwczJyZXMyb2w0ajBtYXh4NHgyazBtYXh4NWwxbTBhbGw0bjFvMGRheTNreW8zb2xzM3AxcmF5M3NoaWJhNXRhbDN1cnMzd24yeW90YTNzM3IwYWRlMWluZzRpbmluZzV2ZWwwZXJzMGluc3VyYW5jZTE2dXN0M3YydDF1YmUyaTFuZXMzc2h1NHYwczJ3MXoydWExYmFuazNzMmcxazFuaWNvbTN2ZXJzaXR5OG8yb2wycHMyczF5MXoydmEwY2F0aW9uczduYTFndWFyZDdjMWUwZ2FzM250dXJlczZyaXNpZ241bVx1MDBGNmdlbnNiZXJhdGVyMnVuZzE0c2ljaGVydW5nMTB0MmcxaTBhamVzNGRlbzNnMWtpbmc0bGxhczRuMXAxcmdpbjRzYTFpb240dmExbzNsYWFuZGVyZW45bjFvZGthM2x2bzN0ZTFpbmczbzJ5YWdlNXUyd2FsZXMybWFydDR0ZXI0bmcwZ291NXRjaDBlczZlYXRoZXIwY2hhbm5lbDEyYmNhbTNlcjJzaXRlNWQwZGluZzVpYm8ycjNmMWhvc3dobzZpZW4ya2kybGxpYW1oaWxsOW4wZG93czRlMW5lcnM2bWUyb2x0ZXJza2x1d2VyMTFvZHNpZGU2cmswczJsZDN3MnMxdGMxZjN4Ym94M2Vyb3g0ZmluaXR5NmlodWFuNG4yeHgyeXozeWFjaHRzNGhvbzNtYXh1bjVuZGV4NWUxb2RvYmFzaGk3Z2Eya29oYW1hNnUwdHViZTZ0MXVuM3phMHBwb3M0cmEzZXJvM2lwMm0xb25lM3VlcmljaDZ3Mic7XG4vLyBJbnRlcm5hdGlvbmFsaXplZCBkb21haW4gbmFtZXMgY29udGFpbmluZyBub24tQVNDSUlcbmNvbnN0IGVuY29kZWRVdGxkcyA9ICdcdTAzQjVcdTAzQkIxXHUwM0M1Mlx1MDQzMVx1MDQzMzFcdTA0MzVcdTA0M0IzXHUwNDM0XHUwNDM1XHUwNDQyXHUwNDM4NFx1MDQzNVx1MDQ0RTJcdTA0M0FcdTA0MzBcdTA0NDJcdTA0M0VcdTA0M0JcdTA0MzhcdTA0M0E2XHUwNDNFXHUwNDNDM1x1MDQzQ1x1MDQzQVx1MDQzNDJcdTA0M0VcdTA0M0QxXHUwNDQxXHUwNDNBXHUwNDMyXHUwNDMwNlx1MDQzRVx1MDQzRFx1MDQzQlx1MDQzMFx1MDQzOVx1MDQzRDVcdTA0NDBcdTA0MzMzXHUwNDQwXHUwNDQzXHUwNDQxMlx1MDQ0NDJcdTA0NDFcdTA0MzBcdTA0MzlcdTA0NDIzXHUwNDQwXHUwNDMxM1x1MDQ0M1x1MDQzQVx1MDQ0MDNcdTA0OUJcdTA0MzBcdTA0MzczXHUwNTcwXHUwNTYxXHUwNTc1M1x1MDVEOVx1MDVFOVx1MDVFOFx1MDVEMFx1MDVEQzVcdTA1RTdcdTA1RDVcdTA1REQzXHUwNjI3XHUwNjI4XHUwNjQ4XHUwNjM4XHUwNjI4XHUwNjRBNVx1MDYzMVx1MDYyN1x1MDY0NVx1MDY0M1x1MDY0ODVcdTA2NDRcdTA2MjdcdTA2MzFcdTA2MkZcdTA2NDY0XHUwNjI4XHUwNjJEXHUwNjMxXHUwNjRBXHUwNjQ2NVx1MDYyQ1x1MDYzMlx1MDYyN1x1MDYyNlx1MDYzMTVcdTA2MzNcdTA2MzlcdTA2NDhcdTA2MkZcdTA2NEFcdTA2Mjk2XHUwNjM5XHUwNjQ0XHUwNjRBXHUwNjI3XHUwNjQ2NVx1MDY0NVx1MDYzQVx1MDYzMVx1MDYyODVcdTA2NDVcdTA2MjdcdTA2MzFcdTA2MjdcdTA2MkE1XHUwNkNDXHUwNjMxXHUwNjI3XHUwNjQ2NVx1MDYyOFx1MDYyN1x1MDYzMVx1MDYyQTJcdTA2MzJcdTA2MjdcdTA2MzE0XHUwNjRBXHUwNjJBXHUwNjQzM1x1MDZCRVx1MDYyN1x1MDYzMVx1MDYyQTVcdTA2MkFcdTA2NDhcdTA2NDZcdTA2MzM0XHUwNjMzXHUwNjQ4XHUwNjJGXHUwNjI3XHUwNjQ2M1x1MDYzMVx1MDY0QVx1MDYyOTVcdTA2MzRcdTA2MjhcdTA2NDNcdTA2Mjk0XHUwNjM5XHUwNjMxXHUwNjI3XHUwNjQyMlx1MDYyODJcdTA2NDVcdTA2MjdcdTA2NDY0XHUwNjQxXHUwNjQ0XHUwNjMzXHUwNjM3XHUwNjRBXHUwNjQ2Nlx1MDY0Mlx1MDYzN1x1MDYzMTNcdTA2NDNcdTA2MjdcdTA2MkJcdTA2NDhcdTA2NDRcdTA2NEFcdTA2NDM2XHUwNjQ4XHUwNjQ1M1x1MDY0NVx1MDYzNVx1MDYzMTJcdTA2NDRcdTA2NEFcdTA2MzNcdTA2NEFcdTA2Mjc1XHUwNjQ4XHUwNjMxXHUwNjRBXHUwNjJBXHUwNjI3XHUwNjQ2XHUwNjRBXHUwNjI3N1x1MDY0Mlx1MDYzOTRcdTA2NDdcdTA2NDVcdTA2MzFcdTA2MjdcdTA2NDc1XHUwNjdFXHUwNjI3XHUwNkE5XHUwNjMzXHUwNjJBXHUwNjI3XHUwNjQ2N1x1MDY4MFx1MDYyN1x1MDYzMVx1MDYyQTRcdTA5MTVcdTA5NDlcdTA5MkUzXHUwOTI4XHUwOTQ3XHUwOTFGM1x1MDkyRFx1MDkzRVx1MDkzMFx1MDkyNDBcdTA5MkVcdTA5NEQzXHUwOTRCXHUwOTI0NVx1MDkzOFx1MDkwMlx1MDkxN1x1MDkyMFx1MDkyODVcdTA5QUNcdTA5QkVcdTA5ODJcdTA5QjJcdTA5QkU1XHUwOUFEXHUwOUJFXHUwOUIwXHUwOUE0Mlx1MDlGMFx1MDlBNDRcdTBBMkRcdTBBM0VcdTBBMzBcdTBBMjQ0XHUwQUFEXHUwQUJFXHUwQUIwXHUwQUE0NFx1MEIyRFx1MEIzRVx1MEIzMFx1MEIyNDRcdTBCODdcdTBCQThcdTBCQ0RcdTBCQTRcdTBCQkZcdTBCQUZcdTBCQkU2XHUwQkIyXHUwQjk5XHUwQkNEXHUwQjk1XHUwQkM4Nlx1MEI5QVx1MEJCRlx1MEI5OVx1MEJDRFx1MEI5NVx1MEJBQVx1MEJDRFx1MEJBQVx1MEJDMlx1MEJCMFx1MEJDRDExXHUwQzJEXHUwQzNFXHUwQzMwXHUwQzI0XHUwQzRENVx1MENBRFx1MENCRVx1MENCMFx1MENBNDRcdTBEMkRcdTBEM0VcdTBEMzBcdTBEMjRcdTBEMDI1XHUwREJEXHUwRDgyXHUwRDlBXHUwRENGNFx1MEUwNFx1MEUyRFx1MEUyMTNcdTBFNDRcdTBFMTdcdTBFMjIzXHUwRUE1XHUwRUIyXHUwRUE3M1x1MTBEMlx1MTBENDJcdTMwN0ZcdTMwOTNcdTMwNkEzXHUzMEEyXHUzMERFXHUzMEJFXHUzMEYzNFx1MzBBRlx1MzBFOVx1MzBBNlx1MzBDOTRcdTMwQjBcdTMwRkNcdTMwQjBcdTMwRUI0XHUzMEIzXHUzMEUwMlx1MzBCOVx1MzBDOFx1MzBBMjNcdTMwQkJcdTMwRkNcdTMwRUIzXHUzMEQ1XHUzMEExXHUzMEMzXHUzMEI3XHUzMEU3XHUzMEYzNlx1MzBERFx1MzBBNFx1MzBGM1x1MzBDODRcdTRFMTZcdTc1NEMyXHU0RTJEXHU0RkUxMVx1NTZGRDFcdTU3MEIxXHU2NTg3XHU3RjUxM1x1NEU5QVx1OUE2Q1x1OTAwQTNcdTRGMDFcdTRFMUEyXHU0RjVCXHU1QzcxMlx1NEZFMVx1NjA2RjJcdTUwNjVcdTVFQjcyXHU1MTZCXHU1MzY2Mlx1NTE2Q1x1NTNGODFcdTc2Q0EyXHU1M0YwXHU2RTdFMVx1NzA2MzJcdTU1NDZcdTU3Q0UxXHU1RTk3MVx1NjgwNzJcdTU2MDlcdTkxQ0MwXHU1OTI3XHU5MTUyXHU1RTk3NVx1NTcyOFx1N0VCRjJcdTU5MjdcdTYyRkYyXHU1OTI5XHU0RTNCXHU2NTU5M1x1NUEzMVx1NEU1MDJcdTVCQjZcdTk2RkIyXHU1RTdGXHU0RTFDMlx1NUZBRVx1NTM1QTJcdTYxNDhcdTU1ODQyXHU2MjExXHU3MjMxXHU0RjYwM1x1NjI0Qlx1NjczQTJcdTYyREJcdTgwNTgyXHU2NTNGXHU1MkExMVx1NUU5QzJcdTY1QjBcdTUyQTBcdTU3NjEyXHU5NUZCMlx1NjVGNlx1NUMxQTJcdTY2RjhcdTdDNEQyXHU2NzNBXHU2Nzg0Mlx1NkRFMVx1OUE2Q1x1OTUyMTNcdTZFMzhcdTYyMEYyXHU2RkIzXHU5NTgwMlx1NzBCOVx1NzcwQjJcdTc5RkJcdTUyQTgyXHU3RUM0XHU3RUM3XHU2NzNBXHU2Nzg0NFx1N0Y1MVx1NTc0MDFcdTVFOTcxXHU3QUQ5MVx1N0VEQzJcdTgwNTRcdTkwMUEyXHU4QzM3XHU2QjRDMlx1OEQyRFx1NzI2OTJcdTkwMUFcdThDQTkyXHU5NkM2XHU1NkUyMlx1OTZGQlx1OEEwQVx1NzZDOFx1NzlEMTRcdTk4REVcdTUyMjlcdTZENjYzXHU5OERGXHU1NEMxMlx1OTkxMFx1NTM4NTJcdTk5OTlcdTY4M0NcdTkxQ0NcdTYyQzkzXHU2RTJGMlx1QjJGN1x1QjEzNzFcdUNFRjQyXHVDMEJDXHVDMTMxMlx1RDU1Q1x1QUQ2RDInO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBXG4gKiBAdGVtcGxhdGUgQlxuICogQHBhcmFtIHtBfSB0YXJnZXRcbiAqIEBwYXJhbSB7Qn0gcHJvcGVydGllc1xuICogQHJldHVybiB7QSAmIEJ9XG4gKi9cbmNvbnN0IGFzc2lnbiA9ICh0YXJnZXQsIHByb3BlcnRpZXMpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcGVydGllcykge1xuICAgIHRhcmdldFtrZXldID0gcHJvcGVydGllc1trZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEZpbml0ZSBTdGF0ZSBNYWNoaW5lIGdlbmVyYXRpb24gdXRpbGl0aWVzXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge3sgW2dyb3VwOiBzdHJpbmddOiBUW10gfX0gQ29sbGVjdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7IFtncm91cDogc3RyaW5nXTogdHJ1ZSB9fSBGbGFnc1xuICovXG5cbi8vIEtleXMgaW4gc2Nhbm5lciBDb2xsZWN0aW9ucyBpbnN0YW5jZXNcbmNvbnN0IG51bWVyaWMgPSAnbnVtZXJpYyc7XG5jb25zdCBhc2NpaSA9ICdhc2NpaSc7XG5jb25zdCBhbHBoYSA9ICdhbHBoYSc7XG5jb25zdCBhc2NpaW51bWVyaWMgPSAnYXNjaWludW1lcmljJztcbmNvbnN0IGFscGhhbnVtZXJpYyA9ICdhbHBoYW51bWVyaWMnO1xuY29uc3QgZG9tYWluID0gJ2RvbWFpbic7XG5jb25zdCBlbW9qaSA9ICdlbW9qaSc7XG5jb25zdCBzY2hlbWUgPSAnc2NoZW1lJztcbmNvbnN0IHNsYXNoc2NoZW1lID0gJ3NsYXNoc2NoZW1lJztcbmNvbnN0IHdoaXRlc3BhY2UgPSAnd2hpdGVzcGFjZSc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBncm91cHMgdG8gcmVnaXN0ZXIgaW5cbiAqIEByZXR1cm5zIHtUW119IEN1cnJlbnQgbGlzdCBvZiB0b2tlbnMgaW4gdGhlIGdpdmVuIGNvbGxlY3Rpb25cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJHcm91cChuYW1lLCBncm91cHMpIHtcbiAgaWYgKCEobmFtZSBpbiBncm91cHMpKSB7XG4gICAgZ3JvdXBzW25hbWVdID0gW107XG4gIH1cbiAgcmV0dXJuIGdyb3Vwc1tuYW1lXTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB0IHRva2VuIHRvIGFkZFxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gZ3JvdXBzXG4gKiBAcGFyYW0ge0ZsYWdzfSBmbGFnc1xuICovXG5mdW5jdGlvbiBhZGRUb0dyb3Vwcyh0LCBmbGFncywgZ3JvdXBzKSB7XG4gIGlmIChmbGFnc1tudW1lcmljXSkge1xuICAgIGZsYWdzW2FzY2lpbnVtZXJpY10gPSB0cnVlO1xuICAgIGZsYWdzW2FscGhhbnVtZXJpY10gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thc2NpaV0pIHtcbiAgICBmbGFnc1thc2NpaW51bWVyaWNdID0gdHJ1ZTtcbiAgICBmbGFnc1thbHBoYV0gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thc2NpaW51bWVyaWNdKSB7XG4gICAgZmxhZ3NbYWxwaGFudW1lcmljXSA9IHRydWU7XG4gIH1cbiAgaWYgKGZsYWdzW2FscGhhXSkge1xuICAgIGZsYWdzW2FscGhhbnVtZXJpY10gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thbHBoYW51bWVyaWNdKSB7XG4gICAgZmxhZ3NbZG9tYWluXSA9IHRydWU7XG4gIH1cbiAgaWYgKGZsYWdzW2Vtb2ppXSkge1xuICAgIGZsYWdzW2RvbWFpbl0gPSB0cnVlO1xuICB9XG4gIGZvciAoY29uc3QgayBpbiBmbGFncykge1xuICAgIGNvbnN0IGdyb3VwID0gcmVnaXN0ZXJHcm91cChrLCBncm91cHMpO1xuICAgIGlmIChncm91cC5pbmRleE9mKHQpIDwgMCkge1xuICAgICAgZ3JvdXAucHVzaCh0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB0IHRva2VuIHRvIGNoZWNrXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBncm91cHNcbiAqIEByZXR1cm5zIHtGbGFnc30gZ3JvdXAgZmxhZ3MgdGhhdCBjb250YWluIHRoaXMgdG9rZW5cbiAqL1xuZnVuY3Rpb24gZmxhZ3NGb3JUb2tlbih0LCBncm91cHMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgYyBpbiBncm91cHMpIHtcbiAgICBpZiAoZ3JvdXBzW2NdLmluZGV4T2YodCkgPj0gMCkge1xuICAgICAgcmVzdWx0W2NdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge251bGwgfCBUIH0gVHJhbnNpdGlvblxuICovXG5cbi8qKlxuICogRGVmaW5lIGEgYmFzaWMgc3RhdGUgbWFjaGluZSBzdGF0ZS4gaiBpcyB0aGUgbGlzdCBvZiBjaGFyYWN0ZXIgdHJhbnNpdGlvbnMsXG4gKiBqciBpcyB0aGUgbGlzdCBvZiByZWdleC1tYXRjaCB0cmFuc2l0aW9ucywgamQgaXMgdGhlIGRlZmF1bHQgc3RhdGUgdG9cbiAqIHRyYW5zaXRpb24gdG8gdCBpcyB0aGUgYWNjZXB0aW5nIHRva2VuIHR5cGUsIGlmIGFueS4gSWYgdGhpcyBpcyB0aGUgdGVybWluYWxcbiAqIHN0YXRlLCB0aGVuIGl0IGRvZXMgbm90IGVtaXQgYSB0b2tlbi5cbiAqXG4gKiBUaGUgdGVtcGxhdGUgdHlwZSBUIHJlcHJlc2VudHMgdGhlIHR5cGUgb2YgdGhlIHRva2VuIHRoaXMgc3RhdGUgYWNjZXB0cy4gVGhpc1xuICogc2hvdWxkIGJlIGEgc3RyaW5nIChzdWNoIGFzIG9mIHRoZSB0b2tlbiBleHBvcnRzIGluIGB0ZXh0LmpzYCkgb3IgYVxuICogTXVsdGlUb2tlbiBzdWJjbGFzcyAoZnJvbSBgbXVsdGkuanNgKVxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IFt0b2tlbl0gVG9rZW4gdGhhdCB0aGlzIHN0YXRlIGVtaXRzXG4gKi9cbmZ1bmN0aW9uIFN0YXRlKHRva2VuKSB7XG4gIGlmICh0b2tlbiA9PT0gdm9pZCAwKSB7XG4gICAgdG9rZW4gPSBudWxsO1xuICB9XG4gIC8vIHRoaXMubiA9IG51bGw7IC8vIERFQlVHOiBTdGF0ZSBuYW1lXG4gIC8qKiBAdHlwZSB7eyBbaW5wdXQ6IHN0cmluZ106IFN0YXRlPFQ+IH19IGogKi9cbiAgdGhpcy5qID0ge307IC8vIElNUExFTUVOVEFUSU9OIDFcbiAgLy8gdGhpcy5qID0gW107IC8vIElNUExFTUVOVEFUSU9OIDJcbiAgLyoqIEB0eXBlIHtbUmVnRXhwLCBTdGF0ZTxUPl1bXX0ganIgKi9cbiAgdGhpcy5qciA9IFtdO1xuICAvKiogQHR5cGUgez9TdGF0ZTxUPn0gamQgKi9cbiAgdGhpcy5qZCA9IG51bGw7XG4gIC8qKiBAdHlwZSB7P1R9IHQgKi9cbiAgdGhpcy50ID0gdG9rZW47XG59XG5cbi8qKlxuICogU2Nhbm5lciB0b2tlbiBncm91cHNcbiAqIEB0eXBlIENvbGxlY3Rpb25zPHN0cmluZz5cbiAqL1xuU3RhdGUuZ3JvdXBzID0ge307XG5TdGF0ZS5wcm90b3R5cGUgPSB7XG4gIGFjY2VwdHMoKSB7XG4gICAgcmV0dXJuICEhdGhpcy50O1xuICB9LFxuICAvKipcbiAgICogRm9sbG93IGFuIGV4aXN0aW5nIHRyYW5zaXRpb24gZnJvbSB0aGUgZ2l2ZW4gaW5wdXQgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAqIERvZXMgbm90IG11dGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IGNoYXJhY3RlciBvciB0b2tlbiB0eXBlIHRvIHRyYW5zaXRpb24gb25cbiAgICogQHJldHVybnMgez9TdGF0ZTxUPn0gdGhlIG5leHQgc3RhdGUsIGlmIGFueVxuICAgKi9cbiAgZ28oaW5wdXQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXM7XG4gICAgY29uc3QgbmV4dFN0YXRlID0gc3RhdGUualtpbnB1dF07XG4gICAgaWYgKG5leHRTdGF0ZSkge1xuICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5qci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVnZXggPSBzdGF0ZS5qcltpXVswXTtcbiAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IHN0YXRlLmpyW2ldWzFdOyAvLyBub3RlOiBtaWdodCBiZSBlbXB0eSB0byBwcmV2ZW50IGRlZmF1bHQganVtcFxuICAgICAgaWYgKG5leHRTdGF0ZSAmJiByZWdleC50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gbmV4dFN0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3doZXJlIGxlZnQgdG8ganVtcCEgUmV0dXJuIGRlZmF1bHQsIGlmIGFueVxuICAgIHJldHVybiBzdGF0ZS5qZDtcbiAgfSxcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHN0YXRlIGhhcyBhIHRyYW5zaXRpb24gZm9yIHRoZSBnaXZlbiBpbnB1dC4gU2V0IHRoZSBzZWNvbmRcbiAgICogYXJndW1lbnQgdG8gdHJ1ZSB0byBvbmx5IGxvb2sgZm9yIGFuIGV4YWN0IG1hdGNoIChhbmQgbm90IGEgZGVmYXVsdCBvclxuICAgKiByZWd1bGFyLWV4cHJlc3Npb24tYmFzZWQgdHJhbnNpdGlvbilcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXhhY3RPbmx5XG4gICAqL1xuICBoYXMoaW5wdXQsIGV4YWN0T25seSkge1xuICAgIGlmIChleGFjdE9ubHkgPT09IHZvaWQgMCkge1xuICAgICAgZXhhY3RPbmx5ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBleGFjdE9ubHkgPyBpbnB1dCBpbiB0aGlzLmogOiAhIXRoaXMuZ28oaW5wdXQpO1xuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidHJhbnNpdGlvbiBhbGxcIjsgY3JlYXRlIGEgdHJhbnNpdGlvbiBmcm9tIHRoZSBhcnJheSBvZiBpdGVtc1xuICAgKiBpbiB0aGUgZ2l2ZW4gbGlzdCB0byB0aGUgc2FtZSBmaW5hbCByZXN1bHRpbmcgc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGlucHV0cyBHcm91cCBvZiBpbnB1dHMgdG8gdHJhbnNpdGlvbiBvblxuICAgKiBAcGFyYW0ge1RyYW5zaXRpb248VD4gfCBTdGF0ZTxUPn0gW25leHRdIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdIENvbGxlY3Rpb25zIGZsYWdzIHRvIGFkZCB0b2tlbiB0b1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXSBNYXN0ZXIgbGlzdCBvZiB0b2tlbiBncm91cHNcbiAgICovXG4gIHRhKGlucHV0cywgbmV4dCwgZmxhZ3MsIGdyb3Vwcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnR0KGlucHV0c1tpXSwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidGFrZSByZWdleHAgdHJhbnNpdGlvblwiOyBkZWZpbmVzIGEgdHJhbnNpdGlvbiBmb3IgdGhpcyBzdGF0ZVxuICAgKiB3aGVuIGl0IGVuY291bnRlcnMgYSB0b2tlbiB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cCBSZWd1bGFyIGV4cHJlc3Npb24gdHJhbnNpdGlvbiAocG9wdWxhdGUgZmlyc3QpXG4gICAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF0gVHJhbnNpdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc10gQ29sbGVjdGlvbnMgZmxhZ3MgdG8gYWRkIHRva2VuIHRvXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdIE1hc3RlciBsaXN0IG9mIHRva2VuIGdyb3Vwc1xuICAgKiBAcmV0dXJucyB7U3RhdGU8VD59IHRha2VuIGFmdGVyIHRoZSBnaXZlbiBpbnB1dFxuICAgKi9cbiAgdHIocmVnZXhwLCBuZXh0LCBmbGFncywgZ3JvdXBzKSB7XG4gICAgZ3JvdXBzID0gZ3JvdXBzIHx8IFN0YXRlLmdyb3VwcztcbiAgICBsZXQgbmV4dFN0YXRlO1xuICAgIGlmIChuZXh0ICYmIG5leHQuaikge1xuICAgICAgbmV4dFN0YXRlID0gbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9rZW4gd2l0aCBtYXliZSB0b2tlbiBncm91cHNcbiAgICAgIG5leHRTdGF0ZSA9IG5ldyBTdGF0ZShuZXh0KTtcbiAgICAgIGlmIChmbGFncyAmJiBncm91cHMpIHtcbiAgICAgICAgYWRkVG9Hcm91cHMobmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuanIucHVzaChbcmVnZXhwLCBuZXh0U3RhdGVdKTtcbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidGFrZSB0cmFuc2l0aW9uc1wiLCB3aWxsIHRha2UgYXMgbWFueSBzZXF1ZW50aWFsIHRyYW5zaXRpb25zIGFzXG4gICAqIHRoZSBsZW5ndGggb2YgdGhlIGdpdmVuIGlucHV0IGFuZCByZXR1cm5zIHRoZVxuICAgKiByZXN1bHRpbmcgZmluYWwgc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGlucHV0XG4gICAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF0gVHJhbnNpdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc10gQ29sbGVjdGlvbnMgZmxhZ3MgdG8gYWRkIHRva2VuIHRvXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdIE1hc3RlciBsaXN0IG9mIHRva2VuIGdyb3Vwc1xuICAgKiBAcmV0dXJucyB7U3RhdGU8VD59IHRha2VuIGFmdGVyIHRoZSBnaXZlbiBpbnB1dFxuICAgKi9cbiAgdHMoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzO1xuICAgIGNvbnN0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICBpZiAoIWxlbikge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgc3RhdGUgPSBzdGF0ZS50dChpbnB1dFtpXSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS50dChpbnB1dFtsZW4gLSAxXSwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBTaG9ydCBmb3IgXCJ0YWtlIHRyYW5zaXRpb25cIiwgdGhpcyBpcyBhIG1ldGhvZCBmb3IgYnVpbGRpbmcvd29ya2luZyB3aXRoXG4gICAqIHN0YXRlIG1hY2hpbmVzLlxuICAgKlxuICAgKiBJZiBhIHN0YXRlIGFscmVhZHkgZXhpc3RzIGZvciB0aGUgZ2l2ZW4gaW5wdXQsIHJldHVybnMgaXQuXG4gICAqXG4gICAqIElmIGEgdG9rZW4gaXMgc3BlY2lmaWVkLCB0aGF0IHN0YXRlIHdpbGwgZW1pdCB0aGF0IHRva2VuIHdoZW4gcmVhY2hlZCBieVxuICAgKiB0aGUgbGlua2lmeSBlbmdpbmUuXG4gICAqXG4gICAqIElmIG5vIHN0YXRlIGV4aXN0cywgaXQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIHNvbWUgZGVmYXVsdCB0cmFuc2l0aW9uc1xuICAgKiB0aGF0IHJlc2VtYmxlIGV4aXN0aW5nIGRlZmF1bHQgdHJhbnNpdGlvbnMuXG4gICAqXG4gICAqIElmIGEgc3RhdGUgaXMgZ2l2ZW4gZm9yIHRoZSBzZWNvbmQgYXJndW1lbnQsIHRoYXQgc3RhdGUgd2lsbCBiZVxuICAgKiB0cmFuc2l0aW9uZWQgdG8gb24gdGhlIGdpdmVuIGlucHV0IHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGF0IGlucHV0XG4gICAqIHByZXZpb3VzbHkgZGlkLlxuICAgKlxuICAgKiBTcGVjaWZ5IGEgdG9rZW4gZ3JvdXAgZmxhZ3MgdG8gZGVmaW5lIGdyb3VwcyB0aGF0IHRoaXMgdG9rZW4gYmVsb25ncyB0by5cbiAgICogVGhlIHRva2VuIHdpbGwgYmUgYWRkZWQgdG8gY29ycmVzcG9uZGluZyBlbnRpcmVzIGluIHRoZSBnaXZlbiBncm91cHNcbiAgICogb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgY2hhcmFjdGVyLCB0b2tlbiB0eXBlIHRvIHRyYW5zaXRpb24gb25cbiAgICogQHBhcmFtIHtUIHwgU3RhdGU8VD59IFtuZXh0XSBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXSBDb2xsZWN0aW9ucyBmbGFncyB0byBhZGQgdG9rZW4gdG9cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc10gTWFzdGVyIGxpc3Qgb2YgZ3JvdXBzXG4gICAqIEByZXR1cm5zIHtTdGF0ZTxUPn0gdGFrZW4gYWZ0ZXIgdGhlIGdpdmVuIGlucHV0XG4gICAqL1xuICB0dChpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcykge1xuICAgIGdyb3VwcyA9IGdyb3VwcyB8fCBTdGF0ZS5ncm91cHM7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzO1xuXG4gICAgLy8gQ2hlY2sgaWYgZXhpc3Rpbmcgc3RhdGUgZ2l2ZW4sIGp1c3QgYSBiYXNpYyB0cmFuc2l0aW9uXG4gICAgaWYgKG5leHQgJiYgbmV4dC5qKSB7XG4gICAgICBzdGF0ZS5qW2lucHV0XSA9IG5leHQ7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gICAgY29uc3QgdCA9IG5leHQ7XG5cbiAgICAvLyBUYWtlIHRoZSB0cmFuc2l0aW9uIHdpdGggdGhlIHVzdWFsIGRlZmF1bHQgbWVjaGFuaXNtcyBhbmQgdXNlIHRoYXQgYXNcbiAgICAvLyBhIHRlbXBsYXRlIGZvciBjcmVhdGluZyB0aGUgbmV4dCBzdGF0ZVxuICAgIGxldCBuZXh0U3RhdGUsXG4gICAgICB0ZW1wbGF0ZVN0YXRlID0gc3RhdGUuZ28oaW5wdXQpO1xuICAgIGlmICh0ZW1wbGF0ZVN0YXRlKSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICAgIGFzc2lnbihuZXh0U3RhdGUuaiwgdGVtcGxhdGVTdGF0ZS5qKTtcbiAgICAgIG5leHRTdGF0ZS5qci5wdXNoLmFwcGx5KG5leHRTdGF0ZS5qciwgdGVtcGxhdGVTdGF0ZS5qcik7XG4gICAgICBuZXh0U3RhdGUuamQgPSB0ZW1wbGF0ZVN0YXRlLmpkO1xuICAgICAgbmV4dFN0YXRlLnQgPSB0ZW1wbGF0ZVN0YXRlLnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5ldyBTdGF0ZSgpO1xuICAgIH1cbiAgICBpZiAodCkge1xuICAgICAgLy8gRW5zdXJlIG5ld2x5IHRva2VuIGlzIGluIHRoZSBzYW1lIGdyb3VwcyBhcyB0aGUgb2xkIHRva2VuXG4gICAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICAgIGlmIChuZXh0U3RhdGUudCAmJiB0eXBlb2YgbmV4dFN0YXRlLnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3QgYWxsRmxhZ3MgPSBhc3NpZ24oZmxhZ3NGb3JUb2tlbihuZXh0U3RhdGUudCwgZ3JvdXBzKSwgZmxhZ3MpO1xuICAgICAgICAgIGFkZFRvR3JvdXBzKHQsIGFsbEZsYWdzLCBncm91cHMpO1xuICAgICAgICB9IGVsc2UgaWYgKGZsYWdzKSB7XG4gICAgICAgICAgYWRkVG9Hcm91cHModCwgZmxhZ3MsIGdyb3Vwcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRTdGF0ZS50ID0gdDsgLy8gb3ZlcndyaXRlIGFueXRoaW5nIHRoYXQgd2FzIHByZXZpb3VzbHkgdGhlcmVcbiAgICB9XG5cbiAgICBzdGF0ZS5qW2lucHV0XSA9IG5leHRTdGF0ZTtcbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIHRvIGltcHJvdmUgbWluaWZpY2F0aW9uIChub3QgZXhwb3J0ZWQgb3V0c2lkZSBsaW5raWZ5anMgbW9kdWxlKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N0YXRlPFQ+fSBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gaW5wdXRcbiAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc11cbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdXG4gKi9cbmNvbnN0IHRhID0gKHN0YXRlLCBpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3VwcykgPT4gc3RhdGUudGEoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N0YXRlPFQ+fSBzdGF0ZVxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICogQHBhcmFtIHtUIHwgU3RhdGU8VD59IFtuZXh0XVxuICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc11cbiAqL1xuY29uc3QgdHIgPSAoc3RhdGUsIHJlZ2V4cCwgbmV4dCwgZmxhZ3MsIGdyb3VwcykgPT4gc3RhdGUudHIocmVnZXhwLCBuZXh0LCBmbGFncywgZ3JvdXBzKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGlucHV0XG4gKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdXG4gKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXVxuICovXG5jb25zdCB0cyA9IChzdGF0ZSwgaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpID0+IHN0YXRlLnRzKGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHtUIHwgU3RhdGU8VD59IFtuZXh0XVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc11cbiAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc11cbiAqL1xuY29uc3QgdHQgPSAoc3RhdGUsIGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKSA9PiBzdGF0ZS50dChpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblRleHQgVG9rZW5zXG5JZGVudGlmaWVycyBmb3IgdG9rZW4gb3V0cHV0cyBmcm9tIHRoZSByZWdleHAgc2Nhbm5lclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBBIHZhbGlkIHdlYiBkb21haW4gdG9rZW5cbmNvbnN0IFdPUkQgPSAnV09SRCc7IC8vIG9ubHkgY29udGFpbnMgYS16XG5jb25zdCBVV09SRCA9ICdVV09SRCc7IC8vIGNvbnRhaW5zIGxldHRlcnMgb3RoZXIgdGhhbiBhLXosIHVzZWQgZm9yIElETlxuXG4vLyBTcGVjaWFsIGNhc2Ugb2Ygd29yZFxuY29uc3QgTE9DQUxIT1NUID0gJ0xPQ0FMSE9TVCc7XG5cbi8vIFZhbGlkIHRvcC1sZXZlbCBkb21haW4sIHNwZWNpYWwgY2FzZSBvZiBXT1JEIChzZWUgdGxkcy5qcylcbmNvbnN0IFRMRCA9ICdUTEQnO1xuXG4vLyBWYWxpZCBJRE4gVExELCBzcGVjaWFsIGNhc2Ugb2YgVVdPUkQgKHNlZSB0bGRzLmpzKVxuY29uc3QgVVRMRCA9ICdVVExEJztcblxuLy8gVGhlIHNjaGVtZSBwb3J0aW9uIG9mIGEgd2ViIFVSSSBwcm90b2NvbC4gU3VwcG9ydGVkIHR5cGVzIGluY2x1ZGU6IGBtYWlsdG9gLFxuLy8gYGZpbGVgLCBhbmQgdXNlci1kZWZpbmVkIGN1c3RvbSBwcm90b2NvbHMuIExpbWl0ZWQgdG8gc2NoZW1lcyB0aGF0IGNvbnRhaW5cbi8vIG9ubHkgbGV0dGVyc1xuY29uc3QgU0NIRU1FID0gJ1NDSEVNRSc7XG5cbi8vIFNpbWlsYXIgdG8gU0NIRU1FLCBleGNlcHQgbWFrZXMgZGlzdGluY3Rpb24gZm9yIHNjaGVtZXMgdGhhdCBtdXN0IGFsd2F5cyBiZVxuLy8gZm9sbG93ZWQgYnkgYDovL2AsIG5vdCBqdXN0IGA6YC4gU3VwcG9ydGVkIHR5cGVzIGluY2x1ZGUgYGh0dHBgLCBgaHR0cHNgLFxuLy8gYGZ0cGAsIGBmdHBzYFxuY29uc3QgU0xBU0hfU0NIRU1FID0gJ1NMQVNIX1NDSEVNRSc7XG5cbi8vIEFueSBzZXF1ZW5jZSBvZiBkaWdpdHMgMC05XG5jb25zdCBOVU0gPSAnTlVNJztcblxuLy8gQW55IG51bWJlciBvZiBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IG5ld2xpbmVcbmNvbnN0IFdTID0gJ1dTJztcblxuLy8gTmV3IGxpbmUgKHVuaXggc3R5bGUpXG5jb25zdCBOTCQxID0gJ05MJzsgLy8gXFxuXG5cbi8vIE9wZW5pbmcvY2xvc2luZyBicmFja2V0IGNsYXNzZXNcbi8vIFRPRE86IFJlbmFtZSBPUEVOIC0+IExFRlQgYW5kIENMT1NFIC0+IFJJR0hUIGluIHY1IHRvIGZpdCB3aXRoIFVuaWNvZGUgbmFtZXNcbi8vIEFsc28gcmVuYW1lIGFuZ2xlIGJyYWNrZXMgdG8gTEVTU1RIQU4gYW5kIEdSRUFURVIgVEhBTlxuY29uc3QgT1BFTkJSQUNFID0gJ09QRU5CUkFDRSc7IC8vIHtcbmNvbnN0IENMT1NFQlJBQ0UgPSAnQ0xPU0VCUkFDRSc7IC8vIH1cbmNvbnN0IE9QRU5CUkFDS0VUID0gJ09QRU5CUkFDS0VUJzsgLy8gW1xuY29uc3QgQ0xPU0VCUkFDS0VUID0gJ0NMT1NFQlJBQ0tFVCc7IC8vIF1cbmNvbnN0IE9QRU5QQVJFTiA9ICdPUEVOUEFSRU4nOyAvLyAoXG5jb25zdCBDTE9TRVBBUkVOID0gJ0NMT1NFUEFSRU4nOyAvLyApXG5jb25zdCBPUEVOQU5HTEVCUkFDS0VUID0gJ09QRU5BTkdMRUJSQUNLRVQnOyAvLyA8XG5jb25zdCBDTE9TRUFOR0xFQlJBQ0tFVCA9ICdDTE9TRUFOR0xFQlJBQ0tFVCc7IC8vID5cbmNvbnN0IEZVTExXSURUSExFRlRQQVJFTiA9ICdGVUxMV0lEVEhMRUZUUEFSRU4nOyAvLyBcdUZGMDhcbmNvbnN0IEZVTExXSURUSFJJR0hUUEFSRU4gPSAnRlVMTFdJRFRIUklHSFRQQVJFTic7IC8vIFx1RkYwOVxuY29uc3QgTEVGVENPUk5FUkJSQUNLRVQgPSAnTEVGVENPUk5FUkJSQUNLRVQnOyAvLyBcdTMwMENcbmNvbnN0IFJJR0hUQ09STkVSQlJBQ0tFVCA9ICdSSUdIVENPUk5FUkJSQUNLRVQnOyAvLyBcdTMwMERcbmNvbnN0IExFRlRXSElURUNPUk5FUkJSQUNLRVQgPSAnTEVGVFdISVRFQ09STkVSQlJBQ0tFVCc7IC8vIFx1MzAwRVxuY29uc3QgUklHSFRXSElURUNPUk5FUkJSQUNLRVQgPSAnUklHSFRXSElURUNPUk5FUkJSQUNLRVQnOyAvLyBcdTMwMEZcbmNvbnN0IEZVTExXSURUSExFU1NUSEFOID0gJ0ZVTExXSURUSExFU1NUSEFOJzsgLy8gXHVGRjFDXG5jb25zdCBGVUxMV0lEVEhHUkVBVEVSVEhBTiA9ICdGVUxMV0lEVEhHUkVBVEVSVEhBTic7IC8vIFx1RkYxRVxuXG4vLyBWYXJpb3VzIHN5bWJvbHNcbmNvbnN0IEFNUEVSU0FORCA9ICdBTVBFUlNBTkQnOyAvLyAmXG5jb25zdCBBUE9TVFJPUEhFID0gJ0FQT1NUUk9QSEUnOyAvLyAnXG5jb25zdCBBU1RFUklTSyA9ICdBU1RFUklTSyc7IC8vICpcbmNvbnN0IEFUID0gJ0FUJzsgLy8gQFxuY29uc3QgQkFDS1NMQVNIID0gJ0JBQ0tTTEFTSCc7IC8vIFxcXG5jb25zdCBCQUNLVElDSyA9ICdCQUNLVElDSyc7IC8vIGBcbmNvbnN0IENBUkVUID0gJ0NBUkVUJzsgLy8gXlxuY29uc3QgQ09MT04gPSAnQ09MT04nOyAvLyA6XG5jb25zdCBDT01NQSA9ICdDT01NQSc7IC8vICxcbmNvbnN0IERPTExBUiA9ICdET0xMQVInOyAvLyAkXG5jb25zdCBET1QgPSAnRE9UJzsgLy8gLlxuY29uc3QgRVFVQUxTID0gJ0VRVUFMUyc7IC8vID1cbmNvbnN0IEVYQ0xBTUFUSU9OID0gJ0VYQ0xBTUFUSU9OJzsgLy8gIVxuY29uc3QgSFlQSEVOID0gJ0hZUEhFTic7IC8vIC1cbmNvbnN0IFBFUkNFTlQgPSAnUEVSQ0VOVCc7IC8vICVcbmNvbnN0IFBJUEUgPSAnUElQRSc7IC8vIHxcbmNvbnN0IFBMVVMgPSAnUExVUyc7IC8vICtcbmNvbnN0IFBPVU5EID0gJ1BPVU5EJzsgLy8gI1xuY29uc3QgUVVFUlkgPSAnUVVFUlknOyAvLyA/XG5jb25zdCBRVU9URSA9ICdRVU9URSc7IC8vIFwiXG5cbmNvbnN0IFNFTUkgPSAnU0VNSSc7IC8vIDtcbmNvbnN0IFNMQVNIID0gJ1NMQVNIJzsgLy8gL1xuY29uc3QgVElMREUgPSAnVElMREUnOyAvLyB+XG5jb25zdCBVTkRFUlNDT1JFID0gJ1VOREVSU0NPUkUnOyAvLyBfXG5cbi8vIEVtb2ppIHN5bWJvbFxuY29uc3QgRU1PSkkkMSA9ICdFTU9KSSc7XG5cbi8vIERlZmF1bHQgdG9rZW4gLSBhbnl0aGluZyB0aGF0IGlzIG5vdCBvbmUgb2YgdGhlIGFib3ZlXG5jb25zdCBTWU0gPSAnU1lNJztcblxudmFyIHRrID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdFdPUkQ6IFdPUkQsXG5cdFVXT1JEOiBVV09SRCxcblx0TE9DQUxIT1NUOiBMT0NBTEhPU1QsXG5cdFRMRDogVExELFxuXHRVVExEOiBVVExELFxuXHRTQ0hFTUU6IFNDSEVNRSxcblx0U0xBU0hfU0NIRU1FOiBTTEFTSF9TQ0hFTUUsXG5cdE5VTTogTlVNLFxuXHRXUzogV1MsXG5cdE5MOiBOTCQxLFxuXHRPUEVOQlJBQ0U6IE9QRU5CUkFDRSxcblx0Q0xPU0VCUkFDRTogQ0xPU0VCUkFDRSxcblx0T1BFTkJSQUNLRVQ6IE9QRU5CUkFDS0VULFxuXHRDTE9TRUJSQUNLRVQ6IENMT1NFQlJBQ0tFVCxcblx0T1BFTlBBUkVOOiBPUEVOUEFSRU4sXG5cdENMT1NFUEFSRU46IENMT1NFUEFSRU4sXG5cdE9QRU5BTkdMRUJSQUNLRVQ6IE9QRU5BTkdMRUJSQUNLRVQsXG5cdENMT1NFQU5HTEVCUkFDS0VUOiBDTE9TRUFOR0xFQlJBQ0tFVCxcblx0RlVMTFdJRFRITEVGVFBBUkVOOiBGVUxMV0lEVEhMRUZUUEFSRU4sXG5cdEZVTExXSURUSFJJR0hUUEFSRU46IEZVTExXSURUSFJJR0hUUEFSRU4sXG5cdExFRlRDT1JORVJCUkFDS0VUOiBMRUZUQ09STkVSQlJBQ0tFVCxcblx0UklHSFRDT1JORVJCUkFDS0VUOiBSSUdIVENPUk5FUkJSQUNLRVQsXG5cdExFRlRXSElURUNPUk5FUkJSQUNLRVQ6IExFRlRXSElURUNPUk5FUkJSQUNLRVQsXG5cdFJJR0hUV0hJVEVDT1JORVJCUkFDS0VUOiBSSUdIVFdISVRFQ09STkVSQlJBQ0tFVCxcblx0RlVMTFdJRFRITEVTU1RIQU46IEZVTExXSURUSExFU1NUSEFOLFxuXHRGVUxMV0lEVEhHUkVBVEVSVEhBTjogRlVMTFdJRFRIR1JFQVRFUlRIQU4sXG5cdEFNUEVSU0FORDogQU1QRVJTQU5ELFxuXHRBUE9TVFJPUEhFOiBBUE9TVFJPUEhFLFxuXHRBU1RFUklTSzogQVNURVJJU0ssXG5cdEFUOiBBVCxcblx0QkFDS1NMQVNIOiBCQUNLU0xBU0gsXG5cdEJBQ0tUSUNLOiBCQUNLVElDSyxcblx0Q0FSRVQ6IENBUkVULFxuXHRDT0xPTjogQ09MT04sXG5cdENPTU1BOiBDT01NQSxcblx0RE9MTEFSOiBET0xMQVIsXG5cdERPVDogRE9ULFxuXHRFUVVBTFM6IEVRVUFMUyxcblx0RVhDTEFNQVRJT046IEVYQ0xBTUFUSU9OLFxuXHRIWVBIRU46IEhZUEhFTixcblx0UEVSQ0VOVDogUEVSQ0VOVCxcblx0UElQRTogUElQRSxcblx0UExVUzogUExVUyxcblx0UE9VTkQ6IFBPVU5ELFxuXHRRVUVSWTogUVVFUlksXG5cdFFVT1RFOiBRVU9URSxcblx0U0VNSTogU0VNSSxcblx0U0xBU0g6IFNMQVNILFxuXHRUSUxERTogVElMREUsXG5cdFVOREVSU0NPUkU6IFVOREVSU0NPUkUsXG5cdEVNT0pJOiBFTU9KSSQxLFxuXHRTWU06IFNZTVxufSk7XG5cbi8vIE5vdGUgdGhhdCB0aGVzZSB0d28gVW5pY29kZSBvbmVzIGV4cGFuZCBpbnRvIGEgcmVhbGx5IGJpZyBvbmUgd2l0aCBCYWJlbFxuY29uc3QgQVNDSUlfTEVUVEVSID0gL1thLXpdLztcbmNvbnN0IExFVFRFUiA9IC9cXHB7TH0vdTsgLy8gQW55IFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggbGV0dGVyIGRhdGEgdHlwZVxuY29uc3QgRU1PSkkgPSAvXFxwe0Vtb2ppfS91OyAvLyBBbnkgVW5pY29kZSBlbW9qaSBjaGFyYWN0ZXJcbmNvbnN0IEVNT0pJX1ZBUklBVElPTiQxID0gL1xcdWZlMGYvO1xuY29uc3QgRElHSVQgPSAvXFxkLztcbmNvbnN0IFNQQUNFID0gL1xccy87XG5cbnZhciByZWdleHAgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0QVNDSUlfTEVUVEVSOiBBU0NJSV9MRVRURVIsXG5cdExFVFRFUjogTEVUVEVSLFxuXHRFTU9KSTogRU1PSkksXG5cdEVNT0pJX1ZBUklBVElPTjogRU1PSklfVkFSSUFUSU9OJDEsXG5cdERJR0lUOiBESUdJVCxcblx0U1BBQ0U6IFNQQUNFXG59KTtcblxuLyoqXG5cdFRoZSBzY2FubmVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSB0aGF0IHRha2VzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXQsIGFuZFxuXHRvdXRwdXRzIGFuIGFycmF5IG9mIHRva2VucyBpbnN0YW5jZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZWFzeSBVUkwgcGFyc2luZy5cbiovXG5jb25zdCBOTCA9ICdcXG4nOyAvLyBOZXcgbGluZSBjaGFyYWN0ZXJcbmNvbnN0IEVNT0pJX1ZBUklBVElPTiA9ICdcXHVmZTBmJzsgLy8gVmFyaWF0aW9uIHNlbGVjdG9yLCBmb2xsb3dzIGhlYXJ0IGFuZCBvdGhlcnNcbmNvbnN0IEVNT0pJX0pPSU5FUiA9ICdcXHUyMDBkJzsgLy8gemVyby13aWR0aCBqb2luZXJcblxubGV0IHRsZHMgPSBudWxsLFxuICB1dGxkcyA9IG51bGw7IC8vIGRvbid0IGNoYW5nZSBzbyBvbmx5IGhhdmUgdG8gYmUgY29tcHV0ZWQgb25jZVxuXG4vKipcbiAqIFNjYW5uZXIgb3V0cHV0IHRva2VuOlxuICogLSBgdGAgaXMgdGhlIHRva2VuIG5hbWUgKGUuZy4sICdOVU0nLCAnRU1PSkknLCAnVExEJylcbiAqIC0gYHZgIGlzIHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gKGUuZy4sICcxMjMnLCAnXHUyNzY0XHVGRTBGJywgJ2NvbScpXG4gKiAtIGBzYCBpcyB0aGUgc3RhcnQgaW5kZXggb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAqIC0gYGVgIGlzIHRoZSBlbmQgaW5kZXggb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAqIEB0eXBlZGVmIHt7dDogc3RyaW5nLCB2OiBzdHJpbmcsIHM6IG51bWJlciwgZTogbnVtYmVyfX0gVG9rZW5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7eyBbY29sbGVjdGlvbjogc3RyaW5nXTogVFtdIH19IENvbGxlY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBzY2FubmVyIGNoYXJhY3Rlci1iYXNlZCBzdGF0ZSBtYWNoaW5lIGZvciB0aGUgZ2l2ZW4gc3RhcnRcbiAqIHN0YXRlXG4gKiBAcGFyYW0ge1tzdHJpbmcsIGJvb2xlYW5dW119IGN1c3RvbVNjaGVtZXMgTGlzdCBvZiBjdXN0b20gc2NoZW1lcywgd2hlcmUgZWFjaFxuICogaXRlbSBpcyBhIGxlbmd0aC0yIHR1cGxlIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgc2V0IHRvIHRoZSBzdHJpbmcgc2NoZW1lLCBhbmRcbiAqIHRoZSBzZWNvbmQgZWxlbWVudCBzZXQgdG8gYHRydWVgIGlmIHRoZSBgOi8vYCBhZnRlciB0aGUgc2NoZW1lIGlzIG9wdGlvbmFsXG4gKi9cbmZ1bmN0aW9uIGluaXQkMihjdXN0b21TY2hlbWVzKSB7XG4gIGlmIChjdXN0b21TY2hlbWVzID09PSB2b2lkIDApIHtcbiAgICBjdXN0b21TY2hlbWVzID0gW107XG4gIH1cbiAgLy8gRnJlcXVlbnRseSB1c2VkIHN0YXRlcyAobmFtZSBhcmd1bWVudCByZW1vdmVkIGR1cmluZyBtaW5pZmljYXRpb24pXG4gIC8qKiBAdHlwZSBDb2xsZWN0aW9uczxzdHJpbmc+ICovXG4gIGNvbnN0IGdyb3VwcyA9IHt9OyAvLyBvZiB0b2tlbnNcbiAgU3RhdGUuZ3JvdXBzID0gZ3JvdXBzO1xuICAvKiogQHR5cGUgU3RhdGU8c3RyaW5nPiAqL1xuICBjb25zdCBTdGFydCA9IG5ldyBTdGF0ZSgpO1xuICBpZiAodGxkcyA9PSBudWxsKSB7XG4gICAgdGxkcyA9IGRlY29kZVRsZHMoZW5jb2RlZFRsZHMpO1xuICB9XG4gIGlmICh1dGxkcyA9PSBudWxsKSB7XG4gICAgdXRsZHMgPSBkZWNvZGVUbGRzKGVuY29kZWRVdGxkcyk7XG4gIH1cblxuICAvLyBTdGF0ZXMgZm9yIHNwZWNpYWwgVVJMIHN5bWJvbHMgdGhhdCBhY2NlcHQgaW1tZWRpYXRlbHkgYWZ0ZXIgc3RhcnRcbiAgdHQoU3RhcnQsIFwiJ1wiLCBBUE9TVFJPUEhFKTtcbiAgdHQoU3RhcnQsICd7JywgT1BFTkJSQUNFKTtcbiAgdHQoU3RhcnQsICd9JywgQ0xPU0VCUkFDRSk7XG4gIHR0KFN0YXJ0LCAnWycsIE9QRU5CUkFDS0VUKTtcbiAgdHQoU3RhcnQsICddJywgQ0xPU0VCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICcoJywgT1BFTlBBUkVOKTtcbiAgdHQoU3RhcnQsICcpJywgQ0xPU0VQQVJFTik7XG4gIHR0KFN0YXJ0LCAnPCcsIE9QRU5BTkdMRUJSQUNLRVQpO1xuICB0dChTdGFydCwgJz4nLCBDTE9TRUFOR0xFQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnXHVGRjA4JywgRlVMTFdJRFRITEVGVFBBUkVOKTtcbiAgdHQoU3RhcnQsICdcdUZGMDknLCBGVUxMV0lEVEhSSUdIVFBBUkVOKTtcbiAgdHQoU3RhcnQsICdcdTMwMEMnLCBMRUZUQ09STkVSQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnXHUzMDBEJywgUklHSFRDT1JORVJCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICdcdTMwMEUnLCBMRUZUV0hJVEVDT1JORVJCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICdcdTMwMEYnLCBSSUdIVFdISVRFQ09STkVSQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnXHVGRjFDJywgRlVMTFdJRFRITEVTU1RIQU4pO1xuICB0dChTdGFydCwgJ1x1RkYxRScsIEZVTExXSURUSEdSRUFURVJUSEFOKTtcbiAgdHQoU3RhcnQsICcmJywgQU1QRVJTQU5EKTtcbiAgdHQoU3RhcnQsICcqJywgQVNURVJJU0spO1xuICB0dChTdGFydCwgJ0AnLCBBVCk7XG4gIHR0KFN0YXJ0LCAnYCcsIEJBQ0tUSUNLKTtcbiAgdHQoU3RhcnQsICdeJywgQ0FSRVQpO1xuICB0dChTdGFydCwgJzonLCBDT0xPTik7XG4gIHR0KFN0YXJ0LCAnLCcsIENPTU1BKTtcbiAgdHQoU3RhcnQsICckJywgRE9MTEFSKTtcbiAgdHQoU3RhcnQsICcuJywgRE9UKTtcbiAgdHQoU3RhcnQsICc9JywgRVFVQUxTKTtcbiAgdHQoU3RhcnQsICchJywgRVhDTEFNQVRJT04pO1xuICB0dChTdGFydCwgJy0nLCBIWVBIRU4pO1xuICB0dChTdGFydCwgJyUnLCBQRVJDRU5UKTtcbiAgdHQoU3RhcnQsICd8JywgUElQRSk7XG4gIHR0KFN0YXJ0LCAnKycsIFBMVVMpO1xuICB0dChTdGFydCwgJyMnLCBQT1VORCk7XG4gIHR0KFN0YXJ0LCAnPycsIFFVRVJZKTtcbiAgdHQoU3RhcnQsICdcIicsIFFVT1RFKTtcbiAgdHQoU3RhcnQsICcvJywgU0xBU0gpO1xuICB0dChTdGFydCwgJzsnLCBTRU1JKTtcbiAgdHQoU3RhcnQsICd+JywgVElMREUpO1xuICB0dChTdGFydCwgJ18nLCBVTkRFUlNDT1JFKTtcbiAgdHQoU3RhcnQsICdcXFxcJywgQkFDS1NMQVNIKTtcbiAgY29uc3QgTnVtID0gdHIoU3RhcnQsIERJR0lULCBOVU0sIHtcbiAgICBbbnVtZXJpY106IHRydWVcbiAgfSk7XG4gIHRyKE51bSwgRElHSVQsIE51bSk7XG5cbiAgLy8gU3RhdGUgd2hpY2ggZW1pdHMgYSB3b3JkIHRva2VuXG4gIGNvbnN0IFdvcmQgPSB0cihTdGFydCwgQVNDSUlfTEVUVEVSLCBXT1JELCB7XG4gICAgW2FzY2lpXTogdHJ1ZVxuICB9KTtcbiAgdHIoV29yZCwgQVNDSUlfTEVUVEVSLCBXb3JkKTtcblxuICAvLyBTYW1lIGFzIHByZXZpb3VzLCBidXQgc3BlY2lmaWMgdG8gbm9uLWZzbS5hc2NpaSBhbHBoYWJldCB3b3Jkc1xuICBjb25zdCBVV29yZCA9IHRyKFN0YXJ0LCBMRVRURVIsIFVXT1JELCB7XG4gICAgW2FscGhhXTogdHJ1ZVxuICB9KTtcbiAgdHIoVVdvcmQsIEFTQ0lJX0xFVFRFUik7IC8vIE5vbi1hY2NlcHRpbmdcbiAgdHIoVVdvcmQsIExFVFRFUiwgVVdvcmQpO1xuXG4gIC8vIFdoaXRlc3BhY2UganVtcHNcbiAgLy8gVG9rZW5zIG9mIG9ubHkgbm9uLW5ld2xpbmUgd2hpdGVzcGFjZSBhcmUgYXJiaXRyYXJpbHkgbG9uZ1xuICAvLyBJZiBhbnkgd2hpdGVzcGFjZSBleGNlcHQgbmV3bGluZSwgbW9yZSB3aGl0ZXNwYWNlIVxuICBjb25zdCBXcyA9IHRyKFN0YXJ0LCBTUEFDRSwgV1MsIHtcbiAgICBbd2hpdGVzcGFjZV06IHRydWVcbiAgfSk7XG4gIHR0KFN0YXJ0LCBOTCwgTkwkMSwge1xuICAgIFt3aGl0ZXNwYWNlXTogdHJ1ZVxuICB9KTtcbiAgdHQoV3MsIE5MKTsgLy8gbm9uLWFjY2VwdGluZyBzdGF0ZSB0byBhdm9pZCBtaXhpbmcgd2hpdGVzcGFjZXNcbiAgdHIoV3MsIFNQQUNFLCBXcyk7XG5cbiAgLy8gRW1vamkgdG9rZW5zLiBUaGV5IGFyZSBub3QgZ3JvdXBlZCBieSB0aGUgc2Nhbm5lciBleGNlcHQgaW4gY2FzZXMgd2hlcmUgYVxuICAvLyB6ZXJvLXdpZHRoIGpvaW5lciBpcyBwcmVzZW50XG4gIGNvbnN0IEVtb2ppID0gdHIoU3RhcnQsIEVNT0pJLCBFTU9KSSQxLCB7XG4gICAgW2Vtb2ppXTogdHJ1ZVxuICB9KTtcbiAgdHIoRW1vamksIEVNT0pJLCBFbW9qaSk7XG4gIHR0KEVtb2ppLCBFTU9KSV9WQVJJQVRJT04sIEVtb2ppKTtcbiAgLy8gdHQoU3RhcnQsIEVNT0pJX1ZBUklBVElPTiwgRW1vamkpOyAvLyBUaGlzIG9uZSBpcyBza2V0Y2h5XG5cbiAgY29uc3QgRW1vamlKb2luZXIgPSB0dChFbW9qaSwgRU1PSklfSk9JTkVSKTtcbiAgdHIoRW1vamlKb2luZXIsIEVNT0pJLCBFbW9qaSk7XG4gIC8vIHR0KEVtb2ppSm9pbmVyLCBFTU9KSV9WQVJJQVRJT04sIEVtb2ppKTsgLy8gYWxzbyBza2V0Y2h5XG5cbiAgLy8gR2VuZXJhdGVzIHN0YXRlcyBmb3IgdG9wLWxldmVsIGRvbWFpbnNcbiAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgbW9zdCBhY2N1cmF0ZSB3aGVuIHRsZHMgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICBjb25zdCB3b3JkanIgPSBbW0FTQ0lJX0xFVFRFUiwgV29yZF1dO1xuICBjb25zdCB1d29yZGpyID0gW1tBU0NJSV9MRVRURVIsIG51bGxdLCBbTEVUVEVSLCBVV29yZF1dO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRsZHMubGVuZ3RoOyBpKyspIHtcbiAgICBmYXN0dHMoU3RhcnQsIHRsZHNbaV0sIFRMRCwgV09SRCwgd29yZGpyKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHV0bGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZmFzdHRzKFN0YXJ0LCB1dGxkc1tpXSwgVVRMRCwgVVdPUkQsIHV3b3JkanIpO1xuICB9XG4gIGFkZFRvR3JvdXBzKFRMRCwge1xuICAgIHRsZDogdHJ1ZSxcbiAgICBhc2NpaTogdHJ1ZVxuICB9LCBncm91cHMpO1xuICBhZGRUb0dyb3VwcyhVVExELCB7XG4gICAgdXRsZDogdHJ1ZSxcbiAgICBhbHBoYTogdHJ1ZVxuICB9LCBncm91cHMpO1xuXG4gIC8vIENvbGxlY3QgdGhlIHN0YXRlcyBnZW5lcmF0ZWQgYnkgZGlmZmVyZW50IHByb3RvY29scy4gTk9URTogSWYgYW55IG5ldyBUTERzXG4gIC8vIGdldCBhZGRlZCB0aGF0IGFyZSBhbHNvIHByb3RvY29scywgc2V0IHRoZSB0b2tlbiB0byBiZSB0aGUgc2FtZSBhcyB0aGVcbiAgLy8gcHJvdG9jb2wgdG8gZW5zdXJlIHBhcnNpbmcgd29ya3MgYXMgZXhwZWN0ZWQuXG4gIGZhc3R0cyhTdGFydCwgJ2ZpbGUnLCBTQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ21haWx0bycsIFNDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgZmFzdHRzKFN0YXJ0LCAnaHR0cCcsIFNMQVNIX1NDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgZmFzdHRzKFN0YXJ0LCAnaHR0cHMnLCBTTEFTSF9TQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ2Z0cCcsIFNMQVNIX1NDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgZmFzdHRzKFN0YXJ0LCAnZnRwcycsIFNMQVNIX1NDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgYWRkVG9Hcm91cHMoU0NIRU1FLCB7XG4gICAgc2NoZW1lOiB0cnVlLFxuICAgIGFzY2lpOiB0cnVlXG4gIH0sIGdyb3Vwcyk7XG4gIGFkZFRvR3JvdXBzKFNMQVNIX1NDSEVNRSwge1xuICAgIHNsYXNoc2NoZW1lOiB0cnVlLFxuICAgIGFzY2lpOiB0cnVlXG4gIH0sIGdyb3Vwcyk7XG5cbiAgLy8gUmVnaXN0ZXIgY3VzdG9tIHNjaGVtZXMuIEFzc3VtZXMgZWFjaCBzY2hlbWUgaXMgYXNjaWludW1lcmljIHdpdGggaHlwaGVuc1xuICBjdXN0b21TY2hlbWVzID0gY3VzdG9tU2NoZW1lcy5zb3J0KChhLCBiKSA9PiBhWzBdID4gYlswXSA/IDEgOiAtMSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY3VzdG9tU2NoZW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNjaCA9IGN1c3RvbVNjaGVtZXNbaV1bMF07XG4gICAgY29uc3Qgb3B0aW9uYWxTbGFzaFNsYXNoID0gY3VzdG9tU2NoZW1lc1tpXVsxXTtcbiAgICBjb25zdCBmbGFncyA9IG9wdGlvbmFsU2xhc2hTbGFzaCA/IHtcbiAgICAgIFtzY2hlbWVdOiB0cnVlXG4gICAgfSA6IHtcbiAgICAgIFtzbGFzaHNjaGVtZV06IHRydWVcbiAgICB9O1xuICAgIGlmIChzY2guaW5kZXhPZignLScpID49IDApIHtcbiAgICAgIGZsYWdzW2RvbWFpbl0gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIUFTQ0lJX0xFVFRFUi50ZXN0KHNjaCkpIHtcbiAgICAgIGZsYWdzW251bWVyaWNdID0gdHJ1ZTsgLy8gbnVtYmVycyBvbmx5XG4gICAgfSBlbHNlIGlmIChESUdJVC50ZXN0KHNjaCkpIHtcbiAgICAgIGZsYWdzW2FzY2lpbnVtZXJpY10gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGFnc1thc2NpaV0gPSB0cnVlO1xuICAgIH1cbiAgICB0cyhTdGFydCwgc2NoLCBzY2gsIGZsYWdzKTtcbiAgfVxuXG4gIC8vIExvY2FsaG9zdCB0b2tlblxuICB0cyhTdGFydCwgJ2xvY2FsaG9zdCcsIExPQ0FMSE9TVCwge1xuICAgIGFzY2lpOiB0cnVlXG4gIH0pO1xuXG4gIC8vIFNldCBkZWZhdWx0IHRyYW5zaXRpb24gZm9yIHN0YXJ0IHN0YXRlIChzb21lIHN5bWJvbClcbiAgU3RhcnQuamQgPSBuZXcgU3RhdGUoU1lNKTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogU3RhcnQsXG4gICAgdG9rZW5zOiBhc3NpZ24oe1xuICAgICAgZ3JvdXBzXG4gICAgfSwgdGspXG4gIH07XG59XG5cbi8qKlxuXHRHaXZlbiBhIHN0cmluZywgcmV0dXJucyBhbiBhcnJheSBvZiBUT0tFTiBpbnN0YW5jZXMgcmVwcmVzZW50aW5nIHRoZVxuXHRjb21wb3NpdGlvbiBvZiB0aGF0IHN0cmluZy5cblxuXHRAbWV0aG9kIHJ1blxuXHRAcGFyYW0ge1N0YXRlPHN0cmluZz59IHN0YXJ0IHNjYW5uZXIgc3RhcnRpbmcgc3RhdGVcblx0QHBhcmFtIHtzdHJpbmd9IHN0ciBpbnB1dCBzdHJpbmcgdG8gc2NhblxuXHRAcmV0dXJuIHtUb2tlbltdfSBsaXN0IG9mIHRva2VucywgZWFjaCB3aXRoIGEgdHlwZSBhbmQgdmFsdWVcbiovXG5mdW5jdGlvbiBydW4kMShzdGFydCwgc3RyKSB7XG4gIC8vIFN0YXRlIG1hY2hpbmUgaXMgbm90IGNhc2Ugc2Vuc2l0aXZlLCBzbyBpbnB1dCBpcyB0b2tlbml6ZWQgaW4gbG93ZXJjYXNlZFxuICAvLyBmb3JtIChzdGlsbCByZXR1cm5zIHJlZ3VsYXIgY2FzZSkuIFVzZXMgc2VsZWN0aXZlIGB0b0xvd2VyQ2FzZWAgYmVjYXVzZVxuICAvLyBsb3dlcmNhc2luZyB0aGUgZW50aXJlIHN0cmluZyBjYXVzZXMgdGhlIGxlbmd0aCBhbmQgY2hhcmFjdGVyIHBvc2l0aW9uIHRvXG4gIC8vIHZhcnkgaW4gc29tZSBub24tRW5nbGlzaCBzdHJpbmdzIHdpdGggVjgtYmFzZWQgcnVudGltZXMuXG4gIGNvbnN0IGl0ZXJhYmxlID0gc3RyaW5nVG9BcnJheShzdHIucmVwbGFjZSgvW0EtWl0vZywgYyA9PiBjLnRvTG93ZXJDYXNlKCkpKTtcbiAgY29uc3QgY2hhckNvdW50ID0gaXRlcmFibGUubGVuZ3RoOyAvLyA8PSBsZW4gaWYgdGhlcmUgYXJlIGVtb2ppcywgZXRjXG4gIGNvbnN0IHRva2VucyA9IFtdOyAvLyByZXR1cm4gdmFsdWVcblxuICAvLyBjdXJzb3IgdGhyb3VnaCB0aGUgc3RyaW5nIGl0c2VsZiwgYWNjb3VudGluZyBmb3IgY2hhcmFjdGVycyB0aGF0IGhhdmVcbiAgLy8gd2lkdGggd2l0aCBsZW5ndGggMiBzdWNoIGFzIGVtb2ppc1xuICBsZXQgY3Vyc29yID0gMDtcblxuICAvLyBDdXJzb3IgdGhyb3VnaCB0aGUgYXJyYXktcmVwcmVzZW50YXRpb24gb2YgdGhlIHN0cmluZ1xuICBsZXQgY2hhckN1cnNvciA9IDA7XG5cbiAgLy8gVG9rZW5pemUgdGhlIHN0cmluZ1xuICB3aGlsZSAoY2hhckN1cnNvciA8IGNoYXJDb3VudCkge1xuICAgIGxldCBzdGF0ZSA9IHN0YXJ0O1xuICAgIGxldCBuZXh0U3RhdGUgPSBudWxsO1xuICAgIGxldCB0b2tlbkxlbmd0aCA9IDA7XG4gICAgbGV0IGxhdGVzdEFjY2VwdGluZyA9IG51bGw7XG4gICAgbGV0IHNpbmNlQWNjZXB0cyA9IC0xO1xuICAgIGxldCBjaGFyc1NpbmNlQWNjZXB0cyA9IC0xO1xuICAgIHdoaWxlIChjaGFyQ3Vyc29yIDwgY2hhckNvdW50ICYmIChuZXh0U3RhdGUgPSBzdGF0ZS5nbyhpdGVyYWJsZVtjaGFyQ3Vyc29yXSkpKSB7XG4gICAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGF0ZXN0IGFjY2VwdGluZyBzdGF0ZVxuICAgICAgaWYgKHN0YXRlLmFjY2VwdHMoKSkge1xuICAgICAgICBzaW5jZUFjY2VwdHMgPSAwO1xuICAgICAgICBjaGFyc1NpbmNlQWNjZXB0cyA9IDA7XG4gICAgICAgIGxhdGVzdEFjY2VwdGluZyA9IHN0YXRlO1xuICAgICAgfSBlbHNlIGlmIChzaW5jZUFjY2VwdHMgPj0gMCkge1xuICAgICAgICBzaW5jZUFjY2VwdHMgKz0gaXRlcmFibGVbY2hhckN1cnNvcl0ubGVuZ3RoO1xuICAgICAgICBjaGFyc1NpbmNlQWNjZXB0cysrO1xuICAgICAgfVxuICAgICAgdG9rZW5MZW5ndGggKz0gaXRlcmFibGVbY2hhckN1cnNvcl0ubGVuZ3RoO1xuICAgICAgY3Vyc29yICs9IGl0ZXJhYmxlW2NoYXJDdXJzb3JdLmxlbmd0aDtcbiAgICAgIGNoYXJDdXJzb3IrKztcbiAgICB9XG5cbiAgICAvLyBSb2xsIGJhY2sgdG8gdGhlIGxhdGVzdCBhY2NlcHRpbmcgc3RhdGVcbiAgICBjdXJzb3IgLT0gc2luY2VBY2NlcHRzO1xuICAgIGNoYXJDdXJzb3IgLT0gY2hhcnNTaW5jZUFjY2VwdHM7XG4gICAgdG9rZW5MZW5ndGggLT0gc2luY2VBY2NlcHRzO1xuXG4gICAgLy8gTm8gbW9yZSBqdW1wcywganVzdCBtYWtlIGEgbmV3IHRva2VuIGZyb20gdGhlIGxhc3QgYWNjZXB0aW5nIG9uZVxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIHQ6IGxhdGVzdEFjY2VwdGluZy50LFxuICAgICAgLy8gdG9rZW4gdHlwZS9uYW1lXG4gICAgICB2OiBzdHIuc2xpY2UoY3Vyc29yIC0gdG9rZW5MZW5ndGgsIGN1cnNvciksXG4gICAgICAvLyBzdHJpbmcgdmFsdWVcbiAgICAgIHM6IGN1cnNvciAtIHRva2VuTGVuZ3RoLFxuICAgICAgLy8gc3RhcnQgaW5kZXhcbiAgICAgIGU6IGN1cnNvciAvLyBlbmQgaW5kZXggKGV4Y2x1ZGluZylcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbi8qKlxuICogQ29udmVydCBhIFN0cmluZyB0byBhbiBBcnJheSBvZiBjaGFyYWN0ZXJzLCB0YWtpbmcgaW50byBhY2NvdW50IHRoYXQgc29tZVxuICogY2hhcmFjdGVycyBsaWtlIGVtb2ppcyB0YWtlIHVwIHR3byBzdHJpbmcgaW5kZXhlcy5cbiAqXG4gKiBBZGFwdGVkIGZyb20gY29yZS1qcyAoTUlUIGxpY2Vuc2UpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iLzJkNjljZjVmOTlhYjNlYTM0NjNjMzk1ZGY4MWU1YTE1YjY4ZjQ5ZDkvcGFja2FnZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qc1xuICpcbiAqIEBmdW5jdGlvbiBzdHJpbmdUb0FycmF5XG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICBsZXQgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBsZW4pIHtcbiAgICBsZXQgZmlyc3QgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgbGV0IHNlY29uZDtcbiAgICBsZXQgY2hhciA9IGZpcnN0IDwgMHhkODAwIHx8IGZpcnN0ID4gMHhkYmZmIHx8IGluZGV4ICsgMSA9PT0gbGVuIHx8IChzZWNvbmQgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpKSA8IDB4ZGMwMCB8fCBzZWNvbmQgPiAweGRmZmYgPyBzdHJbaW5kZXhdIC8vIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICA6IHN0ci5zbGljZShpbmRleCwgaW5kZXggKyAyKTsgLy8gdHdvLWluZGV4IGNoYXJhY3RlcnNcbiAgICByZXN1bHQucHVzaChjaGFyKTtcbiAgICBpbmRleCArPSBjaGFyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEZhc3QgdmVyc2lvbiBvZiB0cyBmdW5jdGlvbiBmb3Igd2hlbiB0cmFuc2l0aW9uIGRlZmF1bHRzIGFyZSB3ZWxsIGtub3duXG4gKiBAcGFyYW0ge1N0YXRlPHN0cmluZz59IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0XG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdHRcbiAqIEBwYXJhbSB7W1JlZ0V4cCwgU3RhdGU8c3RyaW5nPl1bXX0ganJcbiAqIEByZXR1cm5zIHtTdGF0ZTxzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBmYXN0dHMoc3RhdGUsIGlucHV0LCB0LCBkZWZhdWx0dCwganIpIHtcbiAgbGV0IG5leHQ7XG4gIGNvbnN0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgaWYgKHN0YXRlLmpbY2hhcl0pIHtcbiAgICAgIG5leHQgPSBzdGF0ZS5qW2NoYXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0ID0gbmV3IFN0YXRlKGRlZmF1bHR0KTtcbiAgICAgIG5leHQuanIgPSBqci5zbGljZSgpO1xuICAgICAgc3RhdGUualtjaGFyXSA9IG5leHQ7XG4gICAgfVxuICAgIHN0YXRlID0gbmV4dDtcbiAgfVxuICBuZXh0ID0gbmV3IFN0YXRlKHQpO1xuICBuZXh0LmpyID0ganIuc2xpY2UoKTtcbiAgc3RhdGUualtpbnB1dFtsZW4gLSAxXV0gPSBuZXh0O1xuICByZXR1cm4gbmV4dDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBUb3AtTGV2ZWwgRG9tYWluIG5hbWVzIGVuY29kZWQgaW4gdXBkYXRlLXRsZHMuanMgYmFja1xuICogaW50byBhIGxpc3Qgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSB7c3RyfSBlbmNvZGVkIGVuY29kZWQgVExEcyBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJbXX0gb3JpZ2luYWwgVExEcyBsaXN0XG4gKi9cbmZ1bmN0aW9uIGRlY29kZVRsZHMoZW5jb2RlZCkge1xuICBjb25zdCB3b3JkcyA9IFtdO1xuICBjb25zdCBzdGFjayA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIGxldCBkaWdpdHMgPSAnMDEyMzQ1Njc4OSc7XG4gIHdoaWxlIChpIDwgZW5jb2RlZC5sZW5ndGgpIHtcbiAgICBsZXQgcG9wRGlnaXRDb3VudCA9IDA7XG4gICAgd2hpbGUgKGRpZ2l0cy5pbmRleE9mKGVuY29kZWRbaSArIHBvcERpZ2l0Q291bnRdKSA+PSAwKSB7XG4gICAgICBwb3BEaWdpdENvdW50Kys7IC8vIGVuY291bnRlcmVkIHNvbWUgZGlnaXRzLCBoYXZlIHRvIHBvcCB0byBnbyBvbmUgbGV2ZWwgdXAgdHJpZVxuICAgIH1cblxuICAgIGlmIChwb3BEaWdpdENvdW50ID4gMCkge1xuICAgICAgd29yZHMucHVzaChzdGFjay5qb2luKCcnKSk7IC8vIHdoYXRldmVyIHByZWNlZGVkIHRoZSBwb3AgZGlnaXRzIG11c3QgYmUgYSB3b3JkXG4gICAgICBmb3IgKGxldCBwb3BDb3VudCA9IHBhcnNlSW50KGVuY29kZWQuc3Vic3RyaW5nKGksIGkgKyBwb3BEaWdpdENvdW50KSwgMTApOyBwb3BDb3VudCA+IDA7IHBvcENvdW50LS0pIHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICB9XG4gICAgICBpICs9IHBvcERpZ2l0Q291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrLnB1c2goZW5jb2RlZFtpXSk7IC8vIGRyb3AgZG93biBhIGxldmVsIGludG8gdGhlIHRyaWVcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHdvcmRzO1xufVxuXG4vKipcbiAqIEFuIG9iamVjdCB3aGVyZSBlYWNoIGtleSBpcyBhIHZhbGlkIERPTSBFdmVudCBOYW1lIHN1Y2ggYXMgYGNsaWNrYCBvciBgZm9jdXNgXG4gKiBhbmQgZWFjaCB2YWx1ZSBpcyBhbiBldmVudCBoYW5kbGVyIGZ1bmN0aW9uLlxuICpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50I2V2ZW50c1xuICogQHR5cGVkZWYgez97IFtldmVudDogc3RyaW5nXTogRnVuY3Rpb24gfX0gRXZlbnRMaXN0ZW5lcnNcbiAqL1xuXG4vKipcbiAqIEFsbCBmb3JtYXR0ZWQgcHJvcGVydGllcyByZXF1aXJlZCB0byByZW5kZXIgYSBsaW5rLCBpbmNsdWRpbmcgYHRhZ05hbWVgLFxuICogYGF0dHJpYnV0ZXNgLCBgY29udGVudGAgYW5kIGBldmVudExpc3RlbmVyc2AuXG4gKiBAdHlwZWRlZiB7eyB0YWdOYW1lOiBhbnksIGF0dHJpYnV0ZXM6IHtbYXR0cjogc3RyaW5nXTogYW55fSwgY29udGVudDogc3RyaW5nLFxuICogZXZlbnRMaXN0ZW5lcnM6IEV2ZW50TGlzdGVuZXJzIH19IEludGVybWVkaWF0ZVJlcHJlc2VudGF0aW9uXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZ5IGVpdGhlciBhbiBvYmplY3QgZGVzY3JpYmVkIGJ5IHRoZSB0ZW1wbGF0ZSB0eXBlIGBPYCBvciBhIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBmdW5jdGlvbiB0YWtlcyBhIHN0cmluZyB2YWx1ZSAodXN1YWxseSB0aGUgbGluaydzIGhyZWYgYXR0cmlidXRlKSwgdGhlXG4gKiBsaW5rIHR5cGUgKGAndXJsJ2AsIGAnaGFzaHRhZ2AnLCBldGMuKSBhbmQgYW4gaW50ZXJuYWwgdG9rZW4gcmVwcmVzZW50YXRpb25cbiAqIG9mIHRoZSBsaW5rLiBJdCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBvZiB0aGUgdGVtcGxhdGUgdHlwZSBgT2BcbiAqIEB0ZW1wbGF0ZSBPXG4gKiBAdHlwZWRlZiB7TyB8ICgodmFsdWU6IHN0cmluZywgdHlwZTogc3RyaW5nLCB0b2tlbjogTXVsdGlUb2tlbikgPT4gTyl9IE9wdE9ialxuICovXG5cbi8qKlxuICogU3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiBkZXNjcmliZWQgYnkgdGVtcGxhdGUgdHlwZSBgRmAgb3IgYW4gb2JqZWN0LlxuICpcbiAqIEVhY2gga2V5IGluIHRoZSBvYmplY3Qgc2hvdWxkIGJlIGEgbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikuIEVhY2hcbiAqIHZhbHVlIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHdpdGggdGVtcGxhdGUgdHlwZSBgRmAgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgbGluayB0eXBlIGlzIGVuY291bnRlcmVkLlxuICogQHRlbXBsYXRlIEZcbiAqIEB0eXBlZGVmIHtGIHwgeyBbdHlwZTogc3RyaW5nXTogRn19IE9wdEZuXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZ5IGVpdGhlciBhIHZhbHVlIHdpdGggdGVtcGxhdGUgdHlwZSBgVmAsIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGBWYCBvclxuICogYW4gb2JqZWN0IHdoZXJlIGVhY2ggdmFsdWUgcmVzb2x2ZXMgdG8gYFZgLlxuICpcbiAqIFRoZSBmdW5jdGlvbiB0YWtlcyBhIHN0cmluZyB2YWx1ZSAodXN1YWxseSB0aGUgbGluaydzIGhyZWYgYXR0cmlidXRlKSwgdGhlXG4gKiBsaW5rIHR5cGUgKGAndXJsJ2AsIGAnaGFzaHRhZ2AnLCBldGMuKSBhbmQgYW4gaW50ZXJuYWwgdG9rZW4gcmVwcmVzZW50YXRpb25cbiAqIG9mIHRoZSBsaW5rLiBJdCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBvZiB0aGUgdGVtcGxhdGUgdHlwZSBgVmBcbiAqXG4gKiBGb3IgdGhlIG9iamVjdCwgZWFjaCBrZXkgc2hvdWxkIGJlIGEgbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikuXG4gKiBFYWNoIHZhbHVlIHNob3VsZCBlaXRoZXIgaGF2ZSB0eXBlIGBWYCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBWLiBUaGlzXG4gKiBmdW5jdGlvbiBzaW1pbGFybHkgdGFrZXMgYSBzdHJpbmcgdmFsdWUgYW5kIGEgdG9rZW4uXG4gKlxuICogRXhhbXBsZSB2YWxpZCB0eXBlcyBmb3IgYE9wdDxzdHJpbmc+YDpcbiAqXG4gKiBgYGBqc1xuICogJ2hlbGxvJ1xuICogKHZhbHVlLCB0eXBlLCB0b2tlbikgPT4gJ3dvcmxkJ1xuICogeyB1cmw6ICdoZWxsbycsIGVtYWlsOiAodmFsdWUsIHRva2VuKSA9PiAnd29ybGQnfVxuICogYGBgXG4gKiBAdGVtcGxhdGUgVlxuICogQHR5cGVkZWYge1YgfCAoKHZhbHVlOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgdG9rZW46IE11bHRpVG9rZW4pID0+IFYpIHwgeyBbdHlwZTogc3RyaW5nXTogViB8ICgodmFsdWU6IHN0cmluZywgdG9rZW46IE11bHRpVG9rZW4pID0+IFYpIH19IE9wdFxuICovXG5cbi8qKlxuICogU2VlIGF2YWlsYWJsZSBvcHRpb25zOiBodHRwczovL2xpbmtpZnkuanMub3JnL2RvY3Mvb3B0aW9ucy5odG1sXG4gKiBAdHlwZWRlZiB7e1xuICogXHRkZWZhdWx0UHJvdG9jb2w/OiBzdHJpbmcsXG4gKiAgZXZlbnRzPzogT3B0T2JqPEV2ZW50TGlzdGVuZXJzPixcbiAqIFx0Zm9ybWF0PzogT3B0PHN0cmluZz4sXG4gKiBcdGZvcm1hdEhyZWY/OiBPcHQ8c3RyaW5nPixcbiAqIFx0bmwyYnI/OiBib29sZWFuLFxuICogXHR0YWdOYW1lPzogT3B0PGFueT4sXG4gKiBcdHRhcmdldD86IE9wdDxzdHJpbmc+LFxuICogXHRyZWw/OiBPcHQ8c3RyaW5nPixcbiAqIFx0dmFsaWRhdGU/OiBPcHQ8Ym9vbGVhbj4sXG4gKiBcdHRydW5jYXRlPzogT3B0PG51bWJlcj4sXG4gKiBcdGNsYXNzTmFtZT86IE9wdDxzdHJpbmc+LFxuICogXHRhdHRyaWJ1dGVzPzogT3B0T2JqPCh7IFthdHRyOiBzdHJpbmddOiBhbnkgfSk+LFxuICogIGlnbm9yZVRhZ3M/OiBzdHJpbmdbXSxcbiAqIFx0cmVuZGVyPzogT3B0Rm48KChpcjogSW50ZXJtZWRpYXRlUmVwcmVzZW50YXRpb24pID0+IGFueSk+XG4gKiB9fSBPcHRzXG4gKi9cblxuLyoqXG4gKiBAdHlwZSBSZXF1aXJlZDxPcHRzPlxuICovXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgZGVmYXVsdFByb3RvY29sOiAnaHR0cCcsXG4gIGV2ZW50czogbnVsbCxcbiAgZm9ybWF0OiBub29wLFxuICBmb3JtYXRIcmVmOiBub29wLFxuICBubDJicjogZmFsc2UsXG4gIHRhZ05hbWU6ICdhJyxcbiAgdGFyZ2V0OiBudWxsLFxuICByZWw6IG51bGwsXG4gIHZhbGlkYXRlOiB0cnVlLFxuICB0cnVuY2F0ZTogSW5maW5pdHksXG4gIGNsYXNzTmFtZTogbnVsbCxcbiAgYXR0cmlidXRlczogbnVsbCxcbiAgaWdub3JlVGFnczogW10sXG4gIHJlbmRlcjogbnVsbFxufTtcblxuLyoqXG4gKiBVdGlsaXR5IGNsYXNzIGZvciBsaW5raWZ5IGludGVyZmFjZXMgdG8gYXBwbHkgc3BlY2lmaWVkXG4gKiB7QGxpbmsgT3B0cyBmb3JtYXR0aW5nIGFuZCByZW5kZXJpbmcgb3B0aW9uc30uXG4gKlxuICogQHBhcmFtIHtPcHRzIHwgT3B0aW9uc30gW29wdHNdIE9wdGlvbiB2YWx1ZSBvdmVycmlkZXMuXG4gKiBAcGFyYW0geyhpcjogSW50ZXJtZWRpYXRlUmVwcmVzZW50YXRpb24pID0+IGFueX0gW2RlZmF1bHRSZW5kZXJdIChGb3JcbiAqICAgaW50ZXJuYWwgdXNlKSBkZWZhdWx0IHJlbmRlciBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgaG93IHRvIGdlbmVyYXRlIGFuXG4gKiAgIEhUTUwgZWxlbWVudCBiYXNlZCBvbiBhIGxpbmsgdG9rZW4ncyBkZXJpdmVkIHRhZ05hbWUsIGF0dHJpYnV0ZXMgYW5kIEhUTUwuXG4gKiAgIFNpbWlsYXIgdG8gcmVuZGVyIG9wdGlvblxuICovXG5mdW5jdGlvbiBPcHRpb25zKG9wdHMsIGRlZmF1bHRSZW5kZXIpIHtcbiAgaWYgKGRlZmF1bHRSZW5kZXIgPT09IHZvaWQgMCkge1xuICAgIGRlZmF1bHRSZW5kZXIgPSBudWxsO1xuICB9XG4gIGxldCBvID0gYXNzaWduKHt9LCBkZWZhdWx0cyk7XG4gIGlmIChvcHRzKSB7XG4gICAgbyA9IGFzc2lnbihvLCBvcHRzIGluc3RhbmNlb2YgT3B0aW9ucyA/IG9wdHMubyA6IG9wdHMpO1xuICB9XG5cbiAgLy8gRW5zdXJlIGFsbCBpZ25vcmVkIHRhZ3MgYXJlIHVwcGVyY2FzZVxuICBjb25zdCBpZ25vcmVkVGFncyA9IG8uaWdub3JlVGFncztcbiAgY29uc3QgdXBwZXJjYXNlSWdub3JlZFRhZ3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZ25vcmVkVGFncy5sZW5ndGg7IGkrKykge1xuICAgIHVwcGVyY2FzZUlnbm9yZWRUYWdzLnB1c2goaWdub3JlZFRhZ3NbaV0udG9VcHBlckNhc2UoKSk7XG4gIH1cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgdGhpcy5vID0gbztcbiAgaWYgKGRlZmF1bHRSZW5kZXIpIHtcbiAgICB0aGlzLmRlZmF1bHRSZW5kZXIgPSBkZWZhdWx0UmVuZGVyO1xuICB9XG4gIHRoaXMuaWdub3JlVGFncyA9IHVwcGVyY2FzZUlnbm9yZWRUYWdzO1xufVxuT3B0aW9ucy5wcm90b3R5cGUgPSB7XG4gIG86IGRlZmF1bHRzLFxuICAvKipcbiAgICogQHR5cGUgc3RyaW5nW11cbiAgICovXG4gIGlnbm9yZVRhZ3M6IFtdLFxuICAvKipcbiAgICogQHBhcmFtIHtJbnRlcm1lZGlhdGVSZXByZXNlbnRhdGlvbn0gaXJcbiAgICogQHJldHVybnMge2FueX1cbiAgICovXG4gIGRlZmF1bHRSZW5kZXIoaXIpIHtcbiAgICByZXR1cm4gaXI7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgYmFzZWQgb24gd2hldGhlciBhIHRva2VuIHNob3VsZCBiZSBkaXNwbGF5ZWQgYXMgYVxuICAgKiBsaW5rIGJhc2VkIG9uIHRoZSB1c2VyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7TXVsdGlUb2tlbn0gdG9rZW5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjaGVjayh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLmdldCgndmFsaWRhdGUnLCB0b2tlbi50b1N0cmluZygpLCB0b2tlbik7XG4gIH0sXG4gIC8vIFByaXZhdGUgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGFuIG9wdGlvbidzIHZhbHVlIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIGFuZCB0aGUgZ2l2ZW5cbiAgICogcGFyYW1zLiBJZiBvcGVyYXRvciBhbmQgdG9rZW4gYXJlIHNwZWNpZmllZCBhbmQgdGhlIHRhcmdldCBvcHRpb24gaXNcbiAgICogY2FsbGFibGUsIGF1dG9tYXRpY2FsbHkgY2FsbHMgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50LlxuICAgKiBAdGVtcGxhdGUge2tleW9mIE9wdHN9IEtcbiAgICogQHBhcmFtIHtLfSBrZXkgTmFtZSBvZiBvcHRpb24gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3BlcmF0b3JdIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB0YXJnZXQgb3B0aW9uIGlmIGl0J3MgYVxuICAgKiBmdW5jdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgUkFXIGZ1bmN0aW9uIHZhbHVlIGdldHMgcmV0dXJuZWRcbiAgICogQHBhcmFtIHtNdWx0aVRva2VufSBbdG9rZW5dIFRoZSB0b2tlbiBmcm9tIGxpbmtpZnkudG9rZW5pemVcbiAgICogQHJldHVybnMge09wdHNbS10gfCBhbnl9XG4gICAqL1xuICBnZXQoa2V5LCBvcGVyYXRvciwgdG9rZW4pIHtcbiAgICBjb25zdCBpc0NhbGxhYmxlID0gb3BlcmF0b3IgIT0gbnVsbDtcbiAgICBsZXQgb3B0aW9uID0gdGhpcy5vW2tleV07XG4gICAgaWYgKCFvcHRpb24pIHtcbiAgICAgIHJldHVybiBvcHRpb247XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9uID0gdG9rZW4udCBpbiBvcHRpb24gPyBvcHRpb25bdG9rZW4udF0gOiBkZWZhdWx0c1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicgJiYgaXNDYWxsYWJsZSkge1xuICAgICAgICBvcHRpb24gPSBvcHRpb24ob3BlcmF0b3IsIHRva2VuKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicgJiYgaXNDYWxsYWJsZSkge1xuICAgICAgb3B0aW9uID0gb3B0aW9uKG9wZXJhdG9yLCB0b2tlbi50LCB0b2tlbik7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb247XG4gIH0sXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUge2tleW9mIE9wdHN9IExcbiAgICogQHBhcmFtIHtMfSBrZXkgTmFtZSBvZiBvcHRpb25zIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcGVyYXRvcl1cbiAgICogQHBhcmFtIHtNdWx0aVRva2VufSBbdG9rZW5dXG4gICAqIEByZXR1cm5zIHtPcHRzW0xdIHwgYW55fVxuICAgKi9cbiAgZ2V0T2JqKGtleSwgb3BlcmF0b3IsIHRva2VuKSB7XG4gICAgbGV0IG9iaiA9IHRoaXMub1trZXldO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nICYmIG9wZXJhdG9yICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IG9iaihvcGVyYXRvciwgdG9rZW4udCwgdG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9LFxuICAvKipcbiAgICogQ29udmVydCB0aGUgZ2l2ZW4gdG9rZW4gdG8gYSByZW5kZXJlZCBlbGVtZW50IHRoYXQgbWF5IGJlIGFkZGVkIHRvIHRoZVxuICAgKiBjYWxsaW5nLWludGVyZmFjZSdzIERPTVxuICAgKiBAcGFyYW0ge011bHRpVG9rZW59IHRva2VuIFRva2VuIHRvIHJlbmRlciB0byBhbiBIVE1MIGVsZW1lbnRcbiAgICogQHJldHVybnMge2FueX0gUmVuZGVyIHJlc3VsdDsgZS5nLiwgSFRNTCBzdHJpbmcsIERPTSBlbGVtZW50LCBSZWFjdFxuICAgKiAgIENvbXBvbmVudCwgZXRjLlxuICAgKi9cbiAgcmVuZGVyKHRva2VuKSB7XG4gICAgY29uc3QgaXIgPSB0b2tlbi5yZW5kZXIodGhpcyk7IC8vIGludGVybWVkaWF0ZSByZXByZXNlbnRhdGlvblxuICAgIGNvbnN0IHJlbmRlckZuID0gdGhpcy5nZXQoJ3JlbmRlcicsIG51bGwsIHRva2VuKSB8fCB0aGlzLmRlZmF1bHRSZW5kZXI7XG4gICAgcmV0dXJuIHJlbmRlckZuKGlyLCB0b2tlbi50LCB0b2tlbik7XG4gIH1cbn07XG5mdW5jdGlvbiBub29wKHZhbCkge1xuICByZXR1cm4gdmFsO1xufVxuXG52YXIgb3B0aW9ucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRkZWZhdWx0czogZGVmYXVsdHMsXG5cdE9wdGlvbnM6IE9wdGlvbnMsXG5cdGFzc2lnbjogYXNzaWduXG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRNdWx0aS1Ub2tlbnNcblx0VG9rZW5zIGNvbXBvc2VkIG9mIGFycmF5cyBvZiBUZXh0VG9rZW5zXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge1Rva2VuW119IHRva2Vuc1xuICovXG5mdW5jdGlvbiBNdWx0aVRva2VuKHZhbHVlLCB0b2tlbnMpIHtcbiAgdGhpcy50ID0gJ3Rva2VuJztcbiAgdGhpcy52ID0gdmFsdWU7XG4gIHRoaXMudGsgPSB0b2tlbnM7XG59XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdXNlZCBmb3IgbWFudWZhY3R1cmluZyB0b2tlbnMgb2YgdGV4dCB0b2tlbnMuIFRoYXQgaXMgcmF0aGVyXG4gKiB0aGFuIHRoZSB2YWx1ZSBmb3IgYSB0b2tlbiBiZWluZyBhIHNtYWxsIHN0cmluZyBvZiB0ZXh0LCBpdCdzIHZhbHVlIGFuIGFycmF5XG4gKiBvZiB0ZXh0IHRva2Vucy5cbiAqXG4gKiBVc2VkIGZvciBncm91cGluZyB0b2dldGhlciBVUkxzLCBlbWFpbHMsIGhhc2h0YWdzLCBhbmQgb3RoZXIgcG90ZW50aWFsXG4gKiBjcmVhdGlvbnMuXG4gKiBAY2xhc3MgTXVsdGlUb2tlblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2XG4gKiBAcHJvcGVydHkge1Rva2VuW119IHRrXG4gKiBAYWJzdHJhY3RcbiAqL1xuTXVsdGlUb2tlbi5wcm90b3R5cGUgPSB7XG4gIGlzTGluazogZmFsc2UsXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHN0cmluZyB0aGlzIHRva2VuIHJlcHJlc2VudHMuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnY7XG4gIH0sXG4gIC8qKlxuICAgKiBXaGF0IHNob3VsZCB0aGUgdmFsdWUgZm9yIHRoaXMgdG9rZW4gYmUgaW4gdGhlIGBocmVmYCBIVE1MIGF0dHJpYnV0ZT9cbiAgICogUmV0dXJucyB0aGUgYC50b1N0cmluZ2AgdmFsdWUgYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzY2hlbWVdXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgKi9cbiAgdG9IcmVmKHNjaGVtZSkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgRm9ybWF0dGluZyBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdHRlZFN0cmluZyhvcHRpb25zKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy50b1N0cmluZygpO1xuICAgIGNvbnN0IHRydW5jYXRlID0gb3B0aW9ucy5nZXQoJ3RydW5jYXRlJywgdmFsLCB0aGlzKTtcbiAgICBjb25zdCBmb3JtYXR0ZWQgPSBvcHRpb25zLmdldCgnZm9ybWF0JywgdmFsLCB0aGlzKTtcbiAgICByZXR1cm4gdHJ1bmNhdGUgJiYgZm9ybWF0dGVkLmxlbmd0aCA+IHRydW5jYXRlID8gZm9ybWF0dGVkLnN1YnN0cmluZygwLCB0cnVuY2F0ZSkgKyAnXHUyMDI2JyA6IGZvcm1hdHRlZDtcbiAgfSxcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXR0ZWRIcmVmKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5nZXQoJ2Zvcm1hdEhyZWYnLCB0aGlzLnRvSHJlZihvcHRpb25zLmdldCgnZGVmYXVsdFByb3RvY29sJykpLCB0aGlzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBzdGFydCBpbmRleCBvZiB0aGlzIHRva2VuIGluIHRoZSBvcmlnaW5hbCBpbnB1dCBzdHJpbmdcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0YXJ0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudGtbMF0ucztcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBlbmQgaW5kZXggb2YgdGhpcyB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgaW5wdXQgc3RyaW5nICh1cCB0byB0aGlzXG4gICAqIGluZGV4IGJ1dCBub3QgaW5jbHVkaW5nIGl0KVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZW5kSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudGtbdGhpcy50ay5sZW5ndGggLSAxXS5lO1xuICB9LFxuICAvKipcbiAgXHRSZXR1cm5zIGFuIG9iamVjdCAgb2YgcmVsZXZhbnQgdmFsdWVzIGZvciB0aGlzIHRva2VuLCB3aGljaCBpbmNsdWRlcyBrZXlzXG4gIFx0KiB0eXBlIC0gS2luZCBvZiB0b2tlbiAoJ3VybCcsICdlbWFpbCcsIGV0Yy4pXG4gIFx0KiB2YWx1ZSAtIE9yaWdpbmFsIHRleHRcbiAgXHQqIGhyZWYgLSBUaGUgdmFsdWUgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGFuY2hvciB0YWcncyBocmVmXG4gIFx0XHRhdHRyaWJ1dGVcbiAgXHRcdEBtZXRob2QgdG9PYmplY3RcbiAgXHRAcGFyYW0ge3N0cmluZ30gW3Byb3RvY29sXSBgJ2h0dHAnYCBieSBkZWZhdWx0XG4gICovXG4gIHRvT2JqZWN0KHByb3RvY29sKSB7XG4gICAgaWYgKHByb3RvY29sID09PSB2b2lkIDApIHtcbiAgICAgIHByb3RvY29sID0gZGVmYXVsdHMuZGVmYXVsdFByb3RvY29sO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy50LFxuICAgICAgdmFsdWU6IHRoaXMudG9TdHJpbmcoKSxcbiAgICAgIGlzTGluazogdGhpcy5pc0xpbmssXG4gICAgICBocmVmOiB0aGlzLnRvSHJlZihwcm90b2NvbCksXG4gICAgICBzdGFydDogdGhpcy5zdGFydEluZGV4KCksXG4gICAgICBlbmQ6IHRoaXMuZW5kSW5kZXgoKVxuICAgIH07XG4gIH0sXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgRm9ybWF0dGluZyBvcHRpb25cbiAgICovXG4gIHRvRm9ybWF0dGVkT2JqZWN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy50LFxuICAgICAgdmFsdWU6IHRoaXMudG9Gb3JtYXR0ZWRTdHJpbmcob3B0aW9ucyksXG4gICAgICBpc0xpbms6IHRoaXMuaXNMaW5rLFxuICAgICAgaHJlZjogdGhpcy50b0Zvcm1hdHRlZEhyZWYob3B0aW9ucyksXG4gICAgICBzdGFydDogdGhpcy5zdGFydEluZGV4KCksXG4gICAgICBlbmQ6IHRoaXMuZW5kSW5kZXgoKVxuICAgIH07XG4gIH0sXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgdG9rZW4gc2hvdWxkIGJlIHJlbmRlcmVkIGFzIGEgbGluayBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgdmFsaWRhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmdldCgndmFsaWRhdGUnLCB0aGlzLnRvU3RyaW5nKCksIHRoaXMpO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJuIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgaG93IHRoaXMgbGluayBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBGb3JtYXR0aW5uZyBvcHRpb25zXG4gICAqL1xuICByZW5kZXIob3B0aW9ucykge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcztcbiAgICBjb25zdCBocmVmID0gdGhpcy50b0hyZWYob3B0aW9ucy5nZXQoJ2RlZmF1bHRQcm90b2NvbCcpKTtcbiAgICBjb25zdCBmb3JtYXR0ZWRIcmVmID0gb3B0aW9ucy5nZXQoJ2Zvcm1hdEhyZWYnLCBocmVmLCB0aGlzKTtcbiAgICBjb25zdCB0YWdOYW1lID0gb3B0aW9ucy5nZXQoJ3RhZ05hbWUnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMudG9Gb3JtYXR0ZWRTdHJpbmcob3B0aW9ucyk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IG9wdGlvbnMuZ2V0KCdjbGFzc05hbWUnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy5nZXQoJ3RhcmdldCcsIGhyZWYsIHRva2VuKTtcbiAgICBjb25zdCByZWwgPSBvcHRpb25zLmdldCgncmVsJywgaHJlZiwgdG9rZW4pO1xuICAgIGNvbnN0IGF0dHJzID0gb3B0aW9ucy5nZXRPYmooJ2F0dHJpYnV0ZXMnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLmdldE9iaignZXZlbnRzJywgaHJlZiwgdG9rZW4pO1xuICAgIGF0dHJpYnV0ZXMuaHJlZiA9IGZvcm1hdHRlZEhyZWY7XG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgYXR0cmlidXRlcy5jbGFzcyA9IGNsYXNzTmFtZTtcbiAgICB9XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgYXR0cmlidXRlcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgfVxuICAgIGlmIChyZWwpIHtcbiAgICAgIGF0dHJpYnV0ZXMucmVsID0gcmVsO1xuICAgIH1cbiAgICBpZiAoYXR0cnMpIHtcbiAgICAgIGFzc2lnbihhdHRyaWJ1dGVzLCBhdHRycyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0YWdOYW1lLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBldmVudExpc3RlbmVyc1xuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHRva2VuIHRoYXQgY2FuIGJlIGVtaXR0ZWQgYnkgdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSByZWFkYWJsZSB0eXBlIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIHByb3BlcnRpZXMgdG8gYXNzaWduIG9yIG92ZXJyaWRlLCBpbmNsdWRpbmcgaXNMaW5rID0gdHJ1ZSBvciBmYWxzZVxuICogQHJldHVybnMge25ldyAodmFsdWU6IHN0cmluZywgdG9rZW5zOiBUb2tlbltdKSA9PiBNdWx0aVRva2VufSBuZXcgdG9rZW4gY2xhc3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVG9rZW5DbGFzcyh0eXBlLCBwcm9wcykge1xuICBjbGFzcyBUb2tlbiBleHRlbmRzIE11bHRpVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0b2tlbnMpIHtcbiAgICAgIHN1cGVyKHZhbHVlLCB0b2tlbnMpO1xuICAgICAgdGhpcy50ID0gdHlwZTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBwIGluIHByb3BzKSB7XG4gICAgVG9rZW4ucHJvdG90eXBlW3BdID0gcHJvcHNbcF07XG4gIH1cbiAgVG9rZW4udCA9IHR5cGU7XG4gIHJldHVybiBUb2tlbjtcbn1cblxuLyoqXG5cdFJlcHJlc2VudHMgYSBsaXN0IG9mIHRva2VucyBtYWtpbmcgdXAgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXG4qL1xuY29uc3QgRW1haWwgPSBjcmVhdGVUb2tlbkNsYXNzKCdlbWFpbCcsIHtcbiAgaXNMaW5rOiB0cnVlLFxuICB0b0hyZWYoKSB7XG4gICAgcmV0dXJuICdtYWlsdG86JyArIHRoaXMudG9TdHJpbmcoKTtcbiAgfVxufSk7XG5cbi8qKlxuXHRSZXByZXNlbnRzIHNvbWUgcGxhaW4gdGV4dFxuKi9cbmNvbnN0IFRleHQgPSBjcmVhdGVUb2tlbkNsYXNzKCd0ZXh0Jyk7XG5cbi8qKlxuXHRNdWx0aS1saW5lYnJlYWsgdG9rZW4gLSByZXByZXNlbnRzIGEgbGluZSBicmVha1xuXHRAY2xhc3MgTmxcbiovXG5jb25zdCBObCA9IGNyZWF0ZVRva2VuQ2xhc3MoJ25sJyk7XG5cbi8qKlxuXHRSZXByZXNlbnRzIGEgbGlzdCBvZiB0ZXh0IHRva2VucyBtYWtpbmcgdXAgYSB2YWxpZCBVUkxcblx0QGNsYXNzIFVybFxuKi9cbmNvbnN0IFVybCA9IGNyZWF0ZVRva2VuQ2xhc3MoJ3VybCcsIHtcbiAgaXNMaW5rOiB0cnVlLFxuICAvKipcbiAgXHRMb3dlcmNhc2VzIHJlbGV2YW50IHBhcnRzIG9mIHRoZSBkb21haW4gYW5kIGFkZHMgdGhlIHByb3RvY29sIGlmXG4gIFx0cmVxdWlyZWQuIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IGVzY2FwZSB1bnNhZmUgSFRNTCBjaGFyYWN0ZXJzIGluIHRoZVxuICBcdFVSTC5cbiAgXHRcdEBwYXJhbSB7c3RyaW5nfSBbc2NoZW1lXSBkZWZhdWx0IHNjaGVtZSAoZS5nLiwgJ2h0dHBzJylcbiAgXHRAcmV0dXJuIHtzdHJpbmd9IHRoZSBmdWxsIGhyZWZcbiAgKi9cbiAgdG9IcmVmKHNjaGVtZSkge1xuICAgIGlmIChzY2hlbWUgPT09IHZvaWQgMCkge1xuICAgICAgc2NoZW1lID0gZGVmYXVsdHMuZGVmYXVsdFByb3RvY29sO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGhhcyBhIHByZWZpeCBzY2hlbWVcbiAgICByZXR1cm4gdGhpcy5oYXNQcm90b2NvbCgpID8gdGhpcy52IDogYCR7c2NoZW1lfTovLyR7dGhpcy52fWA7XG4gIH0sXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoaXMgVVJMIHRva2VuIGhhcyBhIHByb3RvY29sXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNQcm90b2NvbCgpIHtcbiAgICBjb25zdCB0b2tlbnMgPSB0aGlzLnRrO1xuICAgIHJldHVybiB0b2tlbnMubGVuZ3RoID49IDIgJiYgdG9rZW5zWzBdLnQgIT09IExPQ0FMSE9TVCAmJiB0b2tlbnNbMV0udCA9PT0gQ09MT047XG4gIH1cbn0pO1xuXG52YXIgbXVsdGkgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0TXVsdGlUb2tlbjogTXVsdGlUb2tlbixcblx0QmFzZTogTXVsdGlUb2tlbixcblx0Y3JlYXRlVG9rZW5DbGFzczogY3JlYXRlVG9rZW5DbGFzcyxcblx0RW1haWw6IEVtYWlsLFxuXHRUZXh0OiBUZXh0LFxuXHRObDogTmwsXG5cdFVybDogVXJsXG59KTtcblxuLyoqXG5cdE5vdCBleGFjdGx5IHBhcnNlciwgbW9yZSBsaWtlIHRoZSBzZWNvbmQtc3RhZ2Ugc2Nhbm5lciAoYWx0aG91Z2ggd2UgY2FuXG5cdHRoZW9yZXRpY2FsbHkgaG90c3dhcCB0aGUgY29kZSBoZXJlIHdpdGggYSByZWFsIHBhcnNlciBpbiB0aGUgZnV0dXJlLi4uIGJ1dFxuXHRmb3IgYSBsaXR0bGUgVVJMLWZpbmRpbmcgdXRpbGl0eSBhYnN0cmFjdCBzeW50YXggdHJlZXMgbWF5IGJlIGEgbGl0dGxlXG5cdG92ZXJraWxsKS5cblxuXHRVUkwgZm9ybWF0OiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VSSV9zY2hlbWVcblx0RW1haWwgZm9ybWF0OiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VtYWlsQWRkcmVzcyAobGlua3MgdG8gUkZDIGluXG5cdHJlZmVyZW5jZSlcblxuXHRAbW9kdWxlIGxpbmtpZnlcblx0QHN1Ym1vZHVsZSBwYXJzZXJcblx0QG1haW4gcnVuXG4qL1xuY29uc3QgbWFrZVN0YXRlID0gYXJnID0+IG5ldyBTdGF0ZShhcmcpO1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBwYXJzZXIgbXVsdGkgdG9rZW4tYmFzZWQgc3RhdGUgbWFjaGluZVxuICogQHBhcmFtIHt7IGdyb3VwczogQ29sbGVjdGlvbnM8c3RyaW5nPiB9fSB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gaW5pdCQxKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBncm91cHNcbiAgfSA9IF9yZWY7XG4gIC8vIFR5cGVzIG9mIGNoYXJhY3RlcnMgdGhlIFVSTCBjYW4gZGVmaW5pdGVseSBlbmQgaW5cbiAgY29uc3QgcXNBY2NlcHRpbmcgPSBncm91cHMuZG9tYWluLmNvbmNhdChbQU1QRVJTQU5ELCBBU1RFUklTSywgQVQsIEJBQ0tTTEFTSCwgQkFDS1RJQ0ssIENBUkVULCBET0xMQVIsIEVRVUFMUywgSFlQSEVOLCBOVU0sIFBFUkNFTlQsIFBJUEUsIFBMVVMsIFBPVU5ELCBTTEFTSCwgU1lNLCBUSUxERSwgVU5ERVJTQ09SRV0pO1xuXG4gIC8vIFR5cGVzIG9mIHRva2VucyB0aGF0IGNhbiBmb2xsb3cgYSBVUkwgYW5kIGJlIHBhcnQgb2YgdGhlIHF1ZXJ5IHN0cmluZ1xuICAvLyBidXQgY2Fubm90IGJlIHRoZSB2ZXJ5IGxhc3QgY2hhcmFjdGVyc1xuICAvLyBDaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGFwcGVhciBpbiB0aGUgVVJMIGF0IGFsbCBzaG91bGQgYmUgZXhjbHVkZWRcbiAgY29uc3QgcXNOb25BY2NlcHRpbmcgPSBbQVBPU1RST1BIRSwgQ09MT04sIENPTU1BLCBET1QsIEVYQ0xBTUFUSU9OLCBRVUVSWSwgUVVPVEUsIFNFTUksIE9QRU5BTkdMRUJSQUNLRVQsIENMT1NFQU5HTEVCUkFDS0VULCBPUEVOQlJBQ0UsIENMT1NFQlJBQ0UsIENMT1NFQlJBQ0tFVCwgT1BFTkJSQUNLRVQsIE9QRU5QQVJFTiwgQ0xPU0VQQVJFTiwgRlVMTFdJRFRITEVGVFBBUkVOLCBGVUxMV0lEVEhSSUdIVFBBUkVOLCBMRUZUQ09STkVSQlJBQ0tFVCwgUklHSFRDT1JORVJCUkFDS0VULCBMRUZUV0hJVEVDT1JORVJCUkFDS0VULCBSSUdIVFdISVRFQ09STkVSQlJBQ0tFVCwgRlVMTFdJRFRITEVTU1RIQU4sIEZVTExXSURUSEdSRUFURVJUSEFOXTtcblxuICAvLyBGb3IgYWRkcmVzc2VzIHdpdGhvdXQgdGhlIG1haWx0byBwcmVmaXhcbiAgLy8gVG9rZW5zIGFsbG93ZWQgaW4gdGhlIGxvY2FscGFydCBvZiB0aGUgZW1haWxcbiAgY29uc3QgbG9jYWxwYXJ0QWNjZXB0aW5nID0gW0FNUEVSU0FORCwgQVBPU1RST1BIRSwgQVNURVJJU0ssIEJBQ0tTTEFTSCwgQkFDS1RJQ0ssIENBUkVULCBET0xMQVIsIEVRVUFMUywgSFlQSEVOLCBPUEVOQlJBQ0UsIENMT1NFQlJBQ0UsIFBFUkNFTlQsIFBJUEUsIFBMVVMsIFBPVU5ELCBRVUVSWSwgU0xBU0gsIFNZTSwgVElMREUsIFVOREVSU0NPUkVdO1xuXG4gIC8vIFRoZSB1bml2ZXJzYWwgc3RhcnRpbmcgc3RhdGUuXG4gIC8qKlxuICAgKiBAdHlwZSBTdGF0ZTxUb2tlbj5cbiAgICovXG4gIGNvbnN0IFN0YXJ0ID0gbWFrZVN0YXRlKCk7XG4gIGNvbnN0IExvY2FscGFydCA9IHR0KFN0YXJ0LCBUSUxERSk7IC8vIExvY2FsIHBhcnQgb2YgdGhlIGVtYWlsIGFkZHJlc3NcbiAgdGEoTG9jYWxwYXJ0LCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKExvY2FscGFydCwgZ3JvdXBzLmRvbWFpbiwgTG9jYWxwYXJ0KTtcbiAgY29uc3QgRG9tYWluID0gbWFrZVN0YXRlKCksXG4gICAgU2NoZW1lID0gbWFrZVN0YXRlKCksXG4gICAgU2xhc2hTY2hlbWUgPSBtYWtlU3RhdGUoKTtcbiAgdGEoU3RhcnQsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7IC8vIHBhcnNlZCBzdHJpbmcgZW5kcyB3aXRoIGEgcG90ZW50aWFsIGRvbWFpbiBuYW1lIChBKVxuICB0YShTdGFydCwgZ3JvdXBzLnNjaGVtZSwgU2NoZW1lKTsgLy8gZS5nLiwgJ21haWx0bydcbiAgdGEoU3RhcnQsIGdyb3Vwcy5zbGFzaHNjaGVtZSwgU2xhc2hTY2hlbWUpOyAvLyBlLmcuLCAnaHR0cCdcblxuICB0YShEb21haW4sIGxvY2FscGFydEFjY2VwdGluZywgTG9jYWxwYXJ0KTtcbiAgdGEoRG9tYWluLCBncm91cHMuZG9tYWluLCBEb21haW4pO1xuICBjb25zdCBMb2NhbHBhcnRBdCA9IHR0KERvbWFpbiwgQVQpOyAvLyBMb2NhbCBwYXJ0IG9mIHRoZSBlbWFpbCBhZGRyZXNzIHBsdXMgQFxuXG4gIHR0KExvY2FscGFydCwgQVQsIExvY2FscGFydEF0KTsgLy8gY2xvc2UgdG8gYW4gZW1haWwgYWRkcmVzcyBub3dcblxuICAvLyBMb2NhbCBwYXJ0IG9mIGFuIGVtYWlsIGFkZHJlc3MgY2FuIGJlIGUuZy4gJ2h0dHAnIG9yICdtYWlsdG8nXG4gIHR0KFNjaGVtZSwgQVQsIExvY2FscGFydEF0KTtcbiAgdHQoU2xhc2hTY2hlbWUsIEFULCBMb2NhbHBhcnRBdCk7XG4gIGNvbnN0IExvY2FscGFydERvdCA9IHR0KExvY2FscGFydCwgRE9UKTsgLy8gTG9jYWwgcGFydCBvZiB0aGUgZW1haWwgYWRkcmVzcyBwbHVzICcuJyAobG9jYWxwYXJ0IGNhbm5vdCBlbmQgaW4gLilcbiAgdGEoTG9jYWxwYXJ0RG90LCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKExvY2FscGFydERvdCwgZ3JvdXBzLmRvbWFpbiwgTG9jYWxwYXJ0KTtcbiAgY29uc3QgRW1haWxEb21haW4gPSBtYWtlU3RhdGUoKTtcbiAgdGEoTG9jYWxwYXJ0QXQsIGdyb3Vwcy5kb21haW4sIEVtYWlsRG9tYWluKTsgLy8gcGFyc2VkIHN0cmluZyBzdGFydHMgd2l0aCBsb2NhbCBlbWFpbCBpbmZvICsgQCB3aXRoIGEgcG90ZW50aWFsIGRvbWFpbiBuYW1lXG4gIHRhKEVtYWlsRG9tYWluLCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIGNvbnN0IEVtYWlsRG9tYWluRG90ID0gdHQoRW1haWxEb21haW4sIERPVCk7IC8vIGRvbWFpbiBmb2xsb3dlZCBieSBET1RcbiAgdGEoRW1haWxEb21haW5Eb3QsIGdyb3Vwcy5kb21haW4sIEVtYWlsRG9tYWluKTtcbiAgY29uc3QgRW1haWwkMSA9IG1ha2VTdGF0ZShFbWFpbCk7IC8vIFBvc3NpYmxlIGVtYWlsIGFkZHJlc3MgKGNvdWxkIGhhdmUgbW9yZSB0bGRzKVxuICB0YShFbWFpbERvbWFpbkRvdCwgZ3JvdXBzLnRsZCwgRW1haWwkMSk7XG4gIHRhKEVtYWlsRG9tYWluRG90LCBncm91cHMudXRsZCwgRW1haWwkMSk7XG4gIHR0KExvY2FscGFydEF0LCBMT0NBTEhPU1QsIEVtYWlsJDEpO1xuXG4gIC8vIEh5cGhlbiBjYW4ganVtcCBiYWNrIHRvIGEgZG9tYWluIG5hbWVcbiAgY29uc3QgRW1haWxEb21haW5IeXBoZW4gPSB0dChFbWFpbERvbWFpbiwgSFlQSEVOKTsgLy8gcGFyc2VkIHN0cmluZyBzdGFydHMgd2l0aCBsb2NhbCBlbWFpbCBpbmZvICsgQCB3aXRoIGEgcG90ZW50aWFsIGRvbWFpbiBuYW1lXG4gIHRhKEVtYWlsRG9tYWluSHlwaGVuLCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIHRhKEVtYWlsJDEsIGdyb3Vwcy5kb21haW4sIEVtYWlsRG9tYWluKTtcbiAgdHQoRW1haWwkMSwgRE9ULCBFbWFpbERvbWFpbkRvdCk7XG4gIHR0KEVtYWlsJDEsIEhZUEhFTiwgRW1haWxEb21haW5IeXBoZW4pO1xuXG4gIC8vIEZpbmFsIHBvc3NpYmxlIGVtYWlsIHN0YXRlc1xuICBjb25zdCBFbWFpbENvbG9uID0gdHQoRW1haWwkMSwgQ09MT04pOyAvLyBVUkwgZm9sbG93ZWQgYnkgY29sb24gKHBvdGVudGlhbCBwb3J0IG51bWJlciBoZXJlKVxuICAvKmNvbnN0IEVtYWlsQ29sb25Qb3J0ID0gKi9cbiAgdGEoRW1haWxDb2xvbiwgZ3JvdXBzLm51bWVyaWMsIEVtYWlsKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IGNvbG9uIGFuZCBwb3J0IG51bWJlclxuXG4gIC8vIEFjY291bnQgZm9yIGRvdHMgYW5kIGh5cGhlbnMuIEh5cGhlbnMgYXJlIHVzdWFsbHkgcGFydHMgb2YgZG9tYWluIG5hbWVzXG4gIC8vIChidXQgbm90IFRMRHMpXG4gIGNvbnN0IERvbWFpbkh5cGhlbiA9IHR0KERvbWFpbiwgSFlQSEVOKTsgLy8gZG9tYWluIGZvbGxvd2VkIGJ5IGh5cGhlblxuICBjb25zdCBEb21haW5Eb3QgPSB0dChEb21haW4sIERPVCk7IC8vIGRvbWFpbiBmb2xsb3dlZCBieSBET1RcbiAgdGEoRG9tYWluSHlwaGVuLCBncm91cHMuZG9tYWluLCBEb21haW4pO1xuICB0YShEb21haW5Eb3QsIGxvY2FscGFydEFjY2VwdGluZywgTG9jYWxwYXJ0KTtcbiAgdGEoRG9tYWluRG90LCBncm91cHMuZG9tYWluLCBEb21haW4pO1xuICBjb25zdCBEb21haW5Eb3RUbGQgPSBtYWtlU3RhdGUoVXJsKTsgLy8gU2ltcGxlc3QgcG9zc2libGUgVVJMIHdpdGggbm8gcXVlcnkgc3RyaW5nXG4gIHRhKERvbWFpbkRvdCwgZ3JvdXBzLnRsZCwgRG9tYWluRG90VGxkKTtcbiAgdGEoRG9tYWluRG90LCBncm91cHMudXRsZCwgRG9tYWluRG90VGxkKTtcbiAgdGEoRG9tYWluRG90VGxkLCBncm91cHMuZG9tYWluLCBEb21haW4pO1xuICB0YShEb21haW5Eb3RUbGQsIGxvY2FscGFydEFjY2VwdGluZywgTG9jYWxwYXJ0KTtcbiAgdHQoRG9tYWluRG90VGxkLCBET1QsIERvbWFpbkRvdCk7XG4gIHR0KERvbWFpbkRvdFRsZCwgSFlQSEVOLCBEb21haW5IeXBoZW4pO1xuICB0dChEb21haW5Eb3RUbGQsIEFULCBMb2NhbHBhcnRBdCk7XG4gIGNvbnN0IERvbWFpbkRvdFRsZENvbG9uID0gdHQoRG9tYWluRG90VGxkLCBDT0xPTik7IC8vIFVSTCBmb2xsb3dlZCBieSBjb2xvbiAocG90ZW50aWFsIHBvcnQgbnVtYmVyIGhlcmUpXG4gIGNvbnN0IERvbWFpbkRvdFRsZENvbG9uUG9ydCA9IG1ha2VTdGF0ZShVcmwpOyAvLyBUTEQgZm9sbG93ZWQgYnkgYSBwb3J0IG51bWJlclxuICB0YShEb21haW5Eb3RUbGRDb2xvbiwgZ3JvdXBzLm51bWVyaWMsIERvbWFpbkRvdFRsZENvbG9uUG9ydCk7XG5cbiAgLy8gTG9uZyBVUkwgd2l0aCBvcHRpb25hbCBwb3J0IGFuZCBtYXliZSBxdWVyeSBzdHJpbmdcbiAgY29uc3QgVXJsJDEgPSBtYWtlU3RhdGUoVXJsKTtcblxuICAvLyBVUkwgd2l0aCBleHRyYSBzeW1ib2xzIGF0IHRoZSBlbmQsIGZvbGxvd2VkIGJ5IGFuIG9wZW5pbmcgYnJhY2tldFxuICBjb25zdCBVcmxOb25hY2NlcHQgPSBtYWtlU3RhdGUoKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IHNvbWUgc3ltYm9scyAod2lsbCBub3QgYmUgcGFydCBvZiB0aGUgZmluYWwgVVJMKVxuXG4gIC8vIFF1ZXJ5IHN0cmluZ3NcbiAgdGEoVXJsJDEsIHFzQWNjZXB0aW5nLCBVcmwkMSk7XG4gIHRhKFVybCQxLCBxc05vbkFjY2VwdGluZywgVXJsTm9uYWNjZXB0KTtcbiAgdGEoVXJsTm9uYWNjZXB0LCBxc0FjY2VwdGluZywgVXJsJDEpO1xuICB0YShVcmxOb25hY2NlcHQsIHFzTm9uQWNjZXB0aW5nLCBVcmxOb25hY2NlcHQpO1xuXG4gIC8vIEJlY29tZSByZWFsIFVSTHMgYWZ0ZXIgYFNMQVNIYCBvciBgQ09MT04gTlVNIFNMQVNIYFxuICAvLyBIZXJlIHdvcmtzIHdpdGggb3Igd2l0aG91dCBzY2hlbWU6Ly8gcHJlZml4XG4gIHR0KERvbWFpbkRvdFRsZCwgU0xBU0gsIFVybCQxKTtcbiAgdHQoRG9tYWluRG90VGxkQ29sb25Qb3J0LCBTTEFTSCwgVXJsJDEpO1xuXG4gIC8vIE5vdGUgdGhhdCBkb21haW5zIHRoYXQgYmVnaW4gd2l0aCBzY2hlbWVzIGFyZSB0cmVhdGVkIHNsaWdobHkgZGlmZmVyZW50bHlcbiAgY29uc3QgU2NoZW1lQ29sb24gPSB0dChTY2hlbWUsIENPTE9OKTsgLy8gZS5nLiwgJ21haWx0bzonXG4gIGNvbnN0IFNsYXNoU2NoZW1lQ29sb24gPSB0dChTbGFzaFNjaGVtZSwgQ09MT04pOyAvLyBlLmcuLCAnaHR0cDonXG4gIGNvbnN0IFNsYXNoU2NoZW1lQ29sb25TbGFzaCA9IHR0KFNsYXNoU2NoZW1lQ29sb24sIFNMQVNIKTsgLy8gZS5nLiwgJ2h0dHA6LydcblxuICBjb25zdCBVcmlQcmVmaXggPSB0dChTbGFzaFNjaGVtZUNvbG9uU2xhc2gsIFNMQVNIKTsgLy8gZS5nLiwgJ2h0dHA6Ly8nXG5cbiAgLy8gU2NoZW1lIHN0YXRlcyBjYW4gdHJhbnNpdGlvbiB0byBkb21haW4gc3RhdGVzXG4gIHRhKFNjaGVtZSwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdHQoU2NoZW1lLCBET1QsIERvbWFpbkRvdCk7XG4gIHR0KFNjaGVtZSwgSFlQSEVOLCBEb21haW5IeXBoZW4pO1xuICB0YShTbGFzaFNjaGVtZSwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdHQoU2xhc2hTY2hlbWUsIERPVCwgRG9tYWluRG90KTtcbiAgdHQoU2xhc2hTY2hlbWUsIEhZUEhFTiwgRG9tYWluSHlwaGVuKTtcblxuICAvLyBGb3JjZSBVUkwgd2l0aCBzY2hlbWUgcHJlZml4IGZvbGxvd2VkIGJ5IGFueXRoaW5nIHNhbmVcbiAgdGEoU2NoZW1lQ29sb24sIGdyb3Vwcy5kb21haW4sIFVybCQxKTtcbiAgdHQoU2NoZW1lQ29sb24sIFNMQVNILCBVcmwkMSk7XG4gIHRhKFVyaVByZWZpeCwgZ3JvdXBzLmRvbWFpbiwgVXJsJDEpO1xuICB0YShVcmlQcmVmaXgsIHFzQWNjZXB0aW5nLCBVcmwkMSk7XG4gIHR0KFVyaVByZWZpeCwgU0xBU0gsIFVybCQxKTtcbiAgY29uc3QgYnJhY2tldFBhaXJzID0gW1tPUEVOQlJBQ0UsIENMT1NFQlJBQ0VdLFxuICAvLyB7fVxuICBbT1BFTkJSQUNLRVQsIENMT1NFQlJBQ0tFVF0sXG4gIC8vIFtdXG4gIFtPUEVOUEFSRU4sIENMT1NFUEFSRU5dLFxuICAvLyAoKVxuICBbT1BFTkFOR0xFQlJBQ0tFVCwgQ0xPU0VBTkdMRUJSQUNLRVRdLFxuICAvLyA8PlxuICBbRlVMTFdJRFRITEVGVFBBUkVOLCBGVUxMV0lEVEhSSUdIVFBBUkVOXSxcbiAgLy8gXHVGRjA4XHVGRjA5XG4gIFtMRUZUQ09STkVSQlJBQ0tFVCwgUklHSFRDT1JORVJCUkFDS0VUXSxcbiAgLy8gXHUzMDBDXHUzMDBEXG4gIFtMRUZUV0hJVEVDT1JORVJCUkFDS0VULCBSSUdIVFdISVRFQ09STkVSQlJBQ0tFVF0sXG4gIC8vIFx1MzAwRVx1MzAwRlxuICBbRlVMTFdJRFRITEVTU1RIQU4sIEZVTExXSURUSEdSRUFURVJUSEFOXSAvLyBcdUZGMUNcdUZGMUVcbiAgXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJyYWNrZXRQYWlycy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFtPUEVOLCBDTE9TRV0gPSBicmFja2V0UGFpcnNbaV07XG4gICAgY29uc3QgVXJsT3BlbiA9IHR0KFVybCQxLCBPUEVOKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IG9wZW4gYnJhY2tldFxuXG4gICAgLy8gQ29udGludWUgbm90IGFjY2VwdGluZyBmb3Igb3BlbiBicmFja2V0c1xuICAgIHR0KFVybE5vbmFjY2VwdCwgT1BFTiwgVXJsT3Blbik7XG5cbiAgICAvLyBDbG9zaW5nIGJyYWNrZXQgY29tcG9uZW50LiBUaGlzIGNoYXJhY3RlciBXSUxMIGJlIGluY2x1ZGVkIGluIHRoZSBVUkxcbiAgICB0dChVcmxPcGVuLCBDTE9TRSwgVXJsJDEpO1xuXG4gICAgLy8gVVJMIHRoYXQgYmVpbmdzIHdpdGggYW4gb3BlbmluZyBicmFja2V0LCBmb2xsb3dlZCBieSBhIHN5bWJvbHMuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBmaW5hbCBzdGF0ZSBjYW4gc3RpbGwgYmUgYFVybE9wZW5gIChpZiB0aGUgVVJMIGhhcyBhXG4gICAgLy8gc2luZ2xlIG9wZW5pbmcgYnJhY2tldCBmb3Igc29tZSByZWFzb24pLlxuICAgIGNvbnN0IFVybE9wZW5RID0gbWFrZVN0YXRlKFVybCk7XG4gICAgdGEoVXJsT3BlbiwgcXNBY2NlcHRpbmcsIFVybE9wZW5RKTtcbiAgICBjb25zdCBVcmxPcGVuU3ltcyA9IG1ha2VTdGF0ZSgpOyAvLyBVcmxPcGVuIGZvbGxvd2VkIGJ5IHNvbWUgc3ltYm9scyBpdCBjYW5ub3QgZW5kIGl0XG4gICAgdGEoVXJsT3BlbiwgcXNOb25BY2NlcHRpbmcpO1xuXG4gICAgLy8gVVJMIHRoYXQgYmVnaW5zIHdpdGggYW4gb3BlbmluZyBicmFja2V0LCBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHNcbiAgICB0YShVcmxPcGVuUSwgcXNBY2NlcHRpbmcsIFVybE9wZW5RKTtcbiAgICB0YShVcmxPcGVuUSwgcXNOb25BY2NlcHRpbmcsIFVybE9wZW5TeW1zKTtcbiAgICB0YShVcmxPcGVuU3ltcywgcXNBY2NlcHRpbmcsIFVybE9wZW5RKTtcbiAgICB0YShVcmxPcGVuU3ltcywgcXNOb25BY2NlcHRpbmcsIFVybE9wZW5TeW1zKTtcblxuICAgIC8vIENsb3NlIGJyYWNlL2JyYWNrZXQgdG8gYmVjb21lIHJlZ3VsYXIgVVJMXG4gICAgdHQoVXJsT3BlblEsIENMT1NFLCBVcmwkMSk7XG4gICAgdHQoVXJsT3BlblN5bXMsIENMT1NFLCBVcmwkMSk7XG4gIH1cbiAgdHQoU3RhcnQsIExPQ0FMSE9TVCwgRG9tYWluRG90VGxkKTsgLy8gbG9jYWxob3N0IGlzIGEgdmFsaWQgVVJMIHN0YXRlXG4gIHR0KFN0YXJ0LCBOTCQxLCBObCk7IC8vIHNpbmdsZSBuZXcgbGluZVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IFN0YXJ0LFxuICAgIHRva2VuczogdGtcbiAgfTtcbn1cblxuLyoqXG4gKiBSdW4gdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lIG9uIGEgbGlzdCBvZiBzY2FubmVkIHN0cmluZy1iYXNlZCB0b2tlbnMgdG9cbiAqIGNyZWF0ZSBhIGxpc3Qgb2YgbXVsdGkgdG9rZW5zLCBlYWNoIG9mIHdoaWNoIHJlcHJlc2VudHMgYSBVUkwsIGVtYWlsIGFkZHJlc3MsXG4gKiBwbGFpbiB0ZXh0LCBldGMuXG4gKlxuICogQHBhcmFtIHtTdGF0ZTxNdWx0aVRva2VuPn0gc3RhcnQgcGFyc2VyIHN0YXJ0IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgdGhlIG9yaWdpbmFsIGlucHV0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGdpdmVuIHRva2Vuc1xuICogQHBhcmFtIHtUb2tlbltdfSB0b2tlbnMgbGlzdCBvZiBzY2FubmVkIHRva2Vuc1xuICogQHJldHVybnMge011bHRpVG9rZW5bXX1cbiAqL1xuZnVuY3Rpb24gcnVuKHN0YXJ0LCBpbnB1dCwgdG9rZW5zKSB7XG4gIGxldCBsZW4gPSB0b2tlbnMubGVuZ3RoO1xuICBsZXQgY3Vyc29yID0gMDtcbiAgbGV0IG11bHRpcyA9IFtdO1xuICBsZXQgdGV4dFRva2VucyA9IFtdO1xuICB3aGlsZSAoY3Vyc29yIDwgbGVuKSB7XG4gICAgbGV0IHN0YXRlID0gc3RhcnQ7XG4gICAgbGV0IHNlY29uZFN0YXRlID0gbnVsbDtcbiAgICBsZXQgbmV4dFN0YXRlID0gbnVsbDtcbiAgICBsZXQgbXVsdGlMZW5ndGggPSAwO1xuICAgIGxldCBsYXRlc3RBY2NlcHRpbmcgPSBudWxsO1xuICAgIGxldCBzaW5jZUFjY2VwdHMgPSAtMTtcbiAgICB3aGlsZSAoY3Vyc29yIDwgbGVuICYmICEoc2Vjb25kU3RhdGUgPSBzdGF0ZS5nbyh0b2tlbnNbY3Vyc29yXS50KSkpIHtcbiAgICAgIC8vIFN0YXJ0aW5nIHRva2VucyB3aXRoIG5vd2hlcmUgdG8ganVtcCB0by5cbiAgICAgIC8vIENvbnNpZGVyIHRoZXNlIHRvIGJlIGp1c3QgcGxhaW4gdGV4dFxuICAgICAgdGV4dFRva2Vucy5wdXNoKHRva2Vuc1tjdXJzb3IrK10pO1xuICAgIH1cbiAgICB3aGlsZSAoY3Vyc29yIDwgbGVuICYmIChuZXh0U3RhdGUgPSBzZWNvbmRTdGF0ZSB8fCBzdGF0ZS5nbyh0b2tlbnNbY3Vyc29yXS50KSkpIHtcbiAgICAgIC8vIEdldCB0aGUgbmV4dCBzdGF0ZVxuICAgICAgc2Vjb25kU3RhdGUgPSBudWxsO1xuICAgICAgc3RhdGUgPSBuZXh0U3RhdGU7XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhdGVzdCBhY2NlcHRpbmcgc3RhdGVcbiAgICAgIGlmIChzdGF0ZS5hY2NlcHRzKCkpIHtcbiAgICAgICAgc2luY2VBY2NlcHRzID0gMDtcbiAgICAgICAgbGF0ZXN0QWNjZXB0aW5nID0gc3RhdGU7XG4gICAgICB9IGVsc2UgaWYgKHNpbmNlQWNjZXB0cyA+PSAwKSB7XG4gICAgICAgIHNpbmNlQWNjZXB0cysrO1xuICAgICAgfVxuICAgICAgY3Vyc29yKys7XG4gICAgICBtdWx0aUxlbmd0aCsrO1xuICAgIH1cbiAgICBpZiAoc2luY2VBY2NlcHRzIDwgMCkge1xuICAgICAgLy8gTm8gYWNjZXB0aW5nIHN0YXRlIHdhcyBmb3VuZCwgcGFydCBvZiBhIHJlZ3VsYXIgdGV4dCB0b2tlbiBhZGRcbiAgICAgIC8vIHRoZSBmaXJzdCB0ZXh0IHRva2VuIHRvIHRoZSB0ZXh0IHRva2VucyBhcnJheSBhbmQgdHJ5IGFnYWluIGZyb21cbiAgICAgIC8vIHRoZSBuZXh0XG4gICAgICBjdXJzb3IgLT0gbXVsdGlMZW5ndGg7XG4gICAgICBpZiAoY3Vyc29yIDwgbGVuKSB7XG4gICAgICAgIHRleHRUb2tlbnMucHVzaCh0b2tlbnNbY3Vyc29yXSk7XG4gICAgICAgIGN1cnNvcisrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBY2NlcHRpbmcgc3RhdGUhXG4gICAgICAvLyBGaXJzdCBjbG9zZSBvZmYgdGhlIHRleHRUb2tlbnMgKGlmIGF2YWlsYWJsZSlcbiAgICAgIGlmICh0ZXh0VG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbXVsdGlzLnB1c2goaW5pdE11bHRpVG9rZW4oVGV4dCwgaW5wdXQsIHRleHRUb2tlbnMpKTtcbiAgICAgICAgdGV4dFRva2VucyA9IFtdO1xuICAgICAgfVxuXG4gICAgICAvLyBSb2xsIGJhY2sgdG8gdGhlIGxhdGVzdCBhY2NlcHRpbmcgc3RhdGVcbiAgICAgIGN1cnNvciAtPSBzaW5jZUFjY2VwdHM7XG4gICAgICBtdWx0aUxlbmd0aCAtPSBzaW5jZUFjY2VwdHM7XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBtdWx0aXRva2VuXG4gICAgICBjb25zdCBNdWx0aSA9IGxhdGVzdEFjY2VwdGluZy50O1xuICAgICAgY29uc3Qgc3VidG9rZW5zID0gdG9rZW5zLnNsaWNlKGN1cnNvciAtIG11bHRpTGVuZ3RoLCBjdXJzb3IpO1xuICAgICAgbXVsdGlzLnB1c2goaW5pdE11bHRpVG9rZW4oTXVsdGksIGlucHV0LCBzdWJ0b2tlbnMpKTtcbiAgICB9XG4gIH1cblxuICAvLyBGaW5hbGx5IGNsb3NlIG9mZiB0aGUgdGV4dFRva2VucyAoaWYgYXZhaWxhYmxlKVxuICBpZiAodGV4dFRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgbXVsdGlzLnB1c2goaW5pdE11bHRpVG9rZW4oVGV4dCwgaW5wdXQsIHRleHRUb2tlbnMpKTtcbiAgfVxuICByZXR1cm4gbXVsdGlzO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGluc3RhbnRpYXRpbmcgYSBuZXcgbXVsdGl0b2tlbiB3aXRoIGFsbCB0aGUgcmVsZXZhbnRcbiAqIGZpZWxkcyBkdXJpbmcgcGFyc2luZy5cbiAqIEBwYXJhbSB7bmV3ICh2YWx1ZTogc3RyaW5nLCB0b2tlbnM6IFRva2VuW10pID0+IE11bHRpVG9rZW59IE11bHRpIGNsYXNzIHRvIGluc3RhbnRpYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgb3JpZ2luYWwgaW5wdXQgc3RyaW5nXG4gKiBAcGFyYW0ge1Rva2VuW119IHRva2VucyBjb25zZWN1dGl2ZSB0b2tlbnMgc2Nhbm5lZCBmcm9tIGlucHV0IHN0cmluZ1xuICogQHJldHVybnMge011bHRpVG9rZW59XG4gKi9cbmZ1bmN0aW9uIGluaXRNdWx0aVRva2VuKE11bHRpLCBpbnB1dCwgdG9rZW5zKSB7XG4gIGNvbnN0IHN0YXJ0SWR4ID0gdG9rZW5zWzBdLnM7XG4gIGNvbnN0IGVuZElkeCA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0uZTtcbiAgY29uc3QgdmFsdWUgPSBpbnB1dC5zbGljZShzdGFydElkeCwgZW5kSWR4KTtcbiAgcmV0dXJuIG5ldyBNdWx0aSh2YWx1ZSwgdG9rZW5zKTtcbn1cblxuY29uc3Qgd2FybiA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlICYmIGNvbnNvbGUud2FybiB8fCAoKCkgPT4ge30pO1xuY29uc3Qgd2FybkFkdmljZSA9ICd1bnRpbCBtYW51YWwgY2FsbCBvZiBsaW5raWZ5LmluaXQoKS4gUmVnaXN0ZXIgYWxsIHNjaGVtZXMgYW5kIHBsdWdpbnMgYmVmb3JlIGludm9raW5nIGxpbmtpZnkgdGhlIGZpcnN0IHRpbWUuJztcblxuLy8gU2lkZS1lZmZlY3QgaW5pdGlhbGl6YXRpb24gc3RhdGVcbmNvbnN0IElOSVQgPSB7XG4gIHNjYW5uZXI6IG51bGwsXG4gIHBhcnNlcjogbnVsbCxcbiAgdG9rZW5RdWV1ZTogW10sXG4gIHBsdWdpblF1ZXVlOiBbXSxcbiAgY3VzdG9tU2NoZW1lczogW10sXG4gIGluaXRpYWxpemVkOiBmYWxzZVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogXHRzdGFydDogU3RhdGU8c3RyaW5nPixcbiAqIFx0dG9rZW5zOiB7IGdyb3VwczogQ29sbGVjdGlvbnM8c3RyaW5nPiB9ICYgdHlwZW9mIHRrXG4gKiB9fSBTY2FubmVySW5pdFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqIFx0c3RhcnQ6IFN0YXRlPE11bHRpVG9rZW4+LFxuICogXHR0b2tlbnM6IHR5cGVvZiBtdWx0aVxuICogfX0gUGFyc2VySW5pdFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhhcmc6IHsgc2Nhbm5lcjogU2Nhbm5lckluaXQgfSkgPT4gdm9pZH0gVG9rZW5QbHVnaW5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoYXJnOiB7IHNjYW5uZXI6IFNjYW5uZXJJbml0LCBwYXJzZXI6IFBhcnNlckluaXQgfSkgPT4gdm9pZH0gUGx1Z2luXG4gKi9cblxuLyoqXG4gKiBEZS1yZWdpc3RlciBhbGwgcGx1Z2lucyBhbmQgcmVzZXQgdGhlIGludGVybmFsIHN0YXRlLW1hY2hpbmUuIFVzZWQgZm9yXG4gKiB0ZXN0aW5nOyBub3QgcmVxdWlyZWQgaW4gcHJhY3RpY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNldCgpIHtcbiAgU3RhdGUuZ3JvdXBzID0ge307XG4gIElOSVQuc2Nhbm5lciA9IG51bGw7XG4gIElOSVQucGFyc2VyID0gbnVsbDtcbiAgSU5JVC50b2tlblF1ZXVlID0gW107XG4gIElOSVQucGx1Z2luUXVldWUgPSBbXTtcbiAgSU5JVC5jdXN0b21TY2hlbWVzID0gW107XG4gIElOSVQuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlciBhIHRva2VuIHBsdWdpbiB0byBhbGxvdyB0aGUgc2Nhbm5lciB0byByZWNvZ25pemUgYWRkaXRpb25hbCB0b2tlblxuICogdHlwZXMgYmVmb3JlIHRoZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBpcyBjb25zdHJ1Y3RlZCBmcm9tIHRoZSByZXN1bHRzLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgb2YgcGx1Z2luIHRvIHJlZ2lzdGVyXG4gKiBAcGFyYW0ge1Rva2VuUGx1Z2lufSBwbHVnaW4gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSBzY2FubmVyIHN0YXRlIG1hY2hpbmVcbiAqIGFuZCBhdmFpbGFibGUgc2Nhbm5lciB0b2tlbnMgYW5kIGNvbGxlY3Rpb25zIGFuZCBleHRlbmRzIHRoZSBzdGF0ZSBtYWNoaW5lIHRvXG4gKiByZWNvZ25pemUgYWRkaXRpb25hbCB0b2tlbnMgb3IgZ3JvdXBzLlxuICovXG5mdW5jdGlvbiByZWdpc3RlclRva2VuUGx1Z2luKG5hbWUsIHBsdWdpbikge1xuICBpZiAodHlwZW9mIHBsdWdpbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgbGlua2lmeWpzOiBJbnZhbGlkIHRva2VuIHBsdWdpbiAke3BsdWdpbn0gKGV4cGVjdHMgZnVuY3Rpb24pYCk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBJTklULnRva2VuUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobmFtZSA9PT0gSU5JVC50b2tlblF1ZXVlW2ldWzBdKSB7XG4gICAgICB3YXJuKGBsaW5raWZ5anM6IHRva2VuIHBsdWdpbiBcIiR7bmFtZX1cIiBhbHJlYWR5IHJlZ2lzdGVyZWQgLSB3aWxsIGJlIG92ZXJ3cml0dGVuYCk7XG4gICAgICBJTklULnRva2VuUXVldWVbaV0gPSBbbmFtZSwgcGx1Z2luXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgSU5JVC50b2tlblF1ZXVlLnB1c2goW25hbWUsIHBsdWdpbl0pO1xuICBpZiAoSU5JVC5pbml0aWFsaXplZCkge1xuICAgIHdhcm4oYGxpbmtpZnlqczogYWxyZWFkeSBpbml0aWFsaXplZCAtIHdpbGwgbm90IHJlZ2lzdGVyIHRva2VuIHBsdWdpbiBcIiR7bmFtZX1cIiAke3dhcm5BZHZpY2V9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlciBhIGxpbmtpZnkgcGx1Z2luXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBvZiBwbHVnaW4gdG8gcmVnaXN0ZXJcbiAqIEBwYXJhbSB7UGx1Z2lufSBwbHVnaW4gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBhbmRcbiAqIGV4dGVuZHMgdGhlIHBhcnNlciB0byByZWNvZ25pemUgYWRkaXRpb25hbCBsaW5rIHR5cGVzXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKG5hbWUsIHBsdWdpbikge1xuICBpZiAodHlwZW9mIHBsdWdpbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgbGlua2lmeWpzOiBJbnZhbGlkIHBsdWdpbiAke3BsdWdpbn0gKGV4cGVjdHMgZnVuY3Rpb24pYCk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBJTklULnBsdWdpblF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5hbWUgPT09IElOSVQucGx1Z2luUXVldWVbaV1bMF0pIHtcbiAgICAgIHdhcm4oYGxpbmtpZnlqczogcGx1Z2luIFwiJHtuYW1lfVwiIGFscmVhZHkgcmVnaXN0ZXJlZCAtIHdpbGwgYmUgb3ZlcndyaXR0ZW5gKTtcbiAgICAgIElOSVQucGx1Z2luUXVldWVbaV0gPSBbbmFtZSwgcGx1Z2luXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgSU5JVC5wbHVnaW5RdWV1ZS5wdXNoKFtuYW1lLCBwbHVnaW5dKTtcbiAgaWYgKElOSVQuaW5pdGlhbGl6ZWQpIHtcbiAgICB3YXJuKGBsaW5raWZ5anM6IGFscmVhZHkgaW5pdGlhbGl6ZWQgLSB3aWxsIG5vdCByZWdpc3RlciBwbHVnaW4gXCIke25hbWV9XCIgJHt3YXJuQWR2aWNlfWApO1xuICB9XG59XG5cbi8qKlxuICogRGV0ZWN0IFVSTHMgd2l0aCB0aGUgZm9sbG93aW5nIGFkZGl0aW9uYWwgcHJvdG9jb2wuIEFueXRoaW5nIHdpdGggZm9ybWF0XG4gKiBcInByb3RvY29sOi8vLi4uXCIgd2lsbCBiZSBjb25zaWRlcmVkIGEgbGluay4gSWYgYG9wdGlvbmFsU2xhc2hTbGFzaGAgaXMgc2V0IHRvXG4gKiBgdHJ1ZWAsIGFueXRoaW5nIHdpdGggZm9ybWF0IFwicHJvdG9jb2w6Li4uXCIgd2lsbCBiZSBjb25zaWRlcmVkIGEgbGluay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9uYWxTbGFzaFNsYXNoXVxuICovXG5mdW5jdGlvbiByZWdpc3RlckN1c3RvbVByb3RvY29sKHNjaGVtZSwgb3B0aW9uYWxTbGFzaFNsYXNoKSB7XG4gIGlmIChvcHRpb25hbFNsYXNoU2xhc2ggPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbmFsU2xhc2hTbGFzaCA9IGZhbHNlO1xuICB9XG4gIGlmIChJTklULmluaXRpYWxpemVkKSB7XG4gICAgd2FybihgbGlua2lmeWpzOiBhbHJlYWR5IGluaXRpYWxpemVkIC0gd2lsbCBub3QgcmVnaXN0ZXIgY3VzdG9tIHNjaGVtZSBcIiR7c2NoZW1lfVwiICR7d2FybkFkdmljZX1gKTtcbiAgfVxuICBpZiAoIS9eWzAtOWEtel0rKC1bMC05YS16XSspKiQvLnRlc3Qoc2NoZW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbGlua2lmeWpzOiBpbmNvcnJlY3Qgc2NoZW1lIGZvcm1hdC5cbjEuIE11c3Qgb25seSBjb250YWluIGRpZ2l0cywgbG93ZXJjYXNlIEFTQ0lJIGxldHRlcnMgb3IgXCItXCJcbjIuIENhbm5vdCBzdGFydCBvciBlbmQgd2l0aCBcIi1cIlxuMy4gXCItXCIgY2Fubm90IHJlcGVhdGApO1xuICB9XG4gIElOSVQuY3VzdG9tU2NoZW1lcy5wdXNoKFtzY2hlbWUsIG9wdGlvbmFsU2xhc2hTbGFzaF0pO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGxpbmtpZnkgc3RhdGUgbWFjaGluZS4gQ2FsbGVkIGF1dG9tYXRpY2FsbHkgdGhlIGZpcnN0IHRpbWVcbiAqIGxpbmtpZnkgaXMgY2FsbGVkIG9uIGEgc3RyaW5nLCBidXQgbWF5IGJlIGNhbGxlZCBtYW51YWxseSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBpbml0KCkge1xuICAvLyBJbml0aWFsaXplIHNjYW5uZXIgc3RhdGUgbWFjaGluZSBhbmQgcGx1Z2luc1xuICBJTklULnNjYW5uZXIgPSBpbml0JDIoSU5JVC5jdXN0b21TY2hlbWVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBJTklULnRva2VuUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBJTklULnRva2VuUXVldWVbaV1bMV0oe1xuICAgICAgc2Nhbm5lcjogSU5JVC5zY2FubmVyXG4gICAgfSk7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIHBhcnNlciBzdGF0ZSBtYWNoaW5lIGFuZCBwbHVnaW5zXG4gIElOSVQucGFyc2VyID0gaW5pdCQxKElOSVQuc2Nhbm5lci50b2tlbnMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IElOSVQucGx1Z2luUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBJTklULnBsdWdpblF1ZXVlW2ldWzFdKHtcbiAgICAgIHNjYW5uZXI6IElOSVQuc2Nhbm5lcixcbiAgICAgIHBhcnNlcjogSU5JVC5wYXJzZXJcbiAgICB9KTtcbiAgfVxuICBJTklULmluaXRpYWxpemVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBpbnRvIHRva2VucyB0aGF0IHJlcHJlc2VudCBsaW5rYWJsZSBhbmQgbm9uLWxpbmthYmxlIHN1Yi1jb21wb25lbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtNdWx0aVRva2VuW119IHRva2Vuc1xuICovXG5mdW5jdGlvbiB0b2tlbml6ZShzdHIpIHtcbiAgaWYgKCFJTklULmluaXRpYWxpemVkKSB7XG4gICAgaW5pdCgpO1xuICB9XG4gIHJldHVybiBydW4oSU5JVC5wYXJzZXIuc3RhcnQsIHN0ciwgcnVuJDEoSU5JVC5zY2FubmVyLnN0YXJ0LCBzdHIpKTtcbn1cblxuLyoqXG4gKiBGaW5kIGEgbGlzdCBvZiBsaW5rYWJsZSBpdGVtcyBpbiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBzdHJpbmcgdG8gZmluZCBsaW5rcyBpblxuICogQHBhcmFtIHtzdHJpbmcgfCBPcHRzfSBbdHlwZV0gZWl0aGVyIGZvcm1hdHRpbmcgb3B0aW9ucyBvciBzcGVjaWZpYyB0eXBlIG9mXG4gKiBsaW5rcyB0byBmaW5kLCBlLmcuLCAndXJsJyBvciAnZW1haWwnXG4gKiBAcGFyYW0ge09wdHN9IFtvcHRzXSBmb3JtYXR0aW5nIG9wdGlvbnMgZm9yIGZpbmFsIG91dHB1dC4gQ2Fubm90IGJlIHNwZWNpZmllZFxuICogaWYgb3B0cyBhbHJlYWR5IHByb3ZpZGVkIGluIGB0eXBlYCBhcmd1bWVudFxuICovXG5mdW5jdGlvbiBmaW5kKHN0ciwgdHlwZSwgb3B0cykge1xuICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSBudWxsO1xuICB9XG4gIGlmICh0eXBlICYmIHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChvcHRzKSB7XG4gICAgICB0aHJvdyBFcnJvcihgbGlua2lmeWpzOiBJbnZhbGlkIGxpbmsgdHlwZSAke3R5cGV9OyBtdXN0IGJlIGEgc3RyaW5nYCk7XG4gICAgfVxuICAgIG9wdHMgPSB0eXBlO1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBuZXcgT3B0aW9ucyhvcHRzKTtcbiAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUoc3RyKTtcbiAgY29uc3QgZmlsdGVyZWQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBpZiAodG9rZW4uaXNMaW5rICYmICghdHlwZSB8fCB0b2tlbi50ID09PSB0eXBlKSAmJiBvcHRpb25zLmNoZWNrKHRva2VuKSkge1xuICAgICAgZmlsdGVyZWQucHVzaCh0b2tlbi50b0Zvcm1hdHRlZE9iamVjdChvcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWx0ZXJlZDtcbn1cblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIHZhbGlkIGxpbmthYmxlIHRleHQgb2Ygc29tZSBzb3J0LiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdFxuICogdHJpbSB0aGUgdGV4dCBmb3IgeW91LlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBhIHNlY29uZCBgdHlwZWAgcGFyYW0sIHdoaWNoIGlzIHRoZSB0eXBlIG9mIGxpbmsgdG8gdGVzdFxuICogZm9yLlxuICpcbiAqIEZvciBleGFtcGxlLFxuICpcbiAqICAgICBsaW5raWZ5LnRlc3Qoc3RyLCAnZW1haWwnKTtcbiAqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBzdHIgaXMgYSB2YWxpZCBlbWFpbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgc3RyaW5nIHRvIHRlc3QgZm9yIGxpbmtzXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG9wdGlvbmFsIHNwZWNpZmljIGxpbmsgdHlwZSB0byBsb29rIGZvclxuICogQHJldHVybnMgYm9vbGVhbiB0cnVlL2ZhbHNlXG4gKi9cbmZ1bmN0aW9uIHRlc3Qoc3RyLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICB0eXBlID0gbnVsbDtcbiAgfVxuICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZShzdHIpO1xuICByZXR1cm4gdG9rZW5zLmxlbmd0aCA9PT0gMSAmJiB0b2tlbnNbMF0uaXNMaW5rICYmICghdHlwZSB8fCB0b2tlbnNbMF0udCA9PT0gdHlwZSk7XG59XG5cbmV4cG9ydCB7IE11bHRpVG9rZW4sIE9wdGlvbnMsIFN0YXRlLCBjcmVhdGVUb2tlbkNsYXNzLCBmaW5kLCBpbml0LCBtdWx0aSwgb3B0aW9ucywgcmVnZXhwLCByZWdpc3RlckN1c3RvbVByb3RvY29sLCByZWdpc3RlclBsdWdpbiwgcmVnaXN0ZXJUb2tlblBsdWdpbiwgcmVzZXQsIHN0cmluZ1RvQXJyYXksIHRlc3QsIHRva2VuaXplIH07XG4iLCAiaW1wb3J0IHtcbiAgY29tYmluZVRyYW5zYWN0aW9uU3RlcHMsXG4gIGZpbmRDaGlsZHJlbkluUmFuZ2UsXG4gIGdldENoYW5nZWRSYW5nZXMsXG4gIGdldE1hcmtzQmV0d2VlbixcbiAgTm9kZVdpdGhQb3MsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IGZpbmQgfSBmcm9tICdsaW5raWZ5anMnXG5cbnR5cGUgQXV0b2xpbmtPcHRpb25zID0ge1xuICB0eXBlOiBNYXJrVHlwZVxuICB2YWxpZGF0ZT86ICh1cmw6IHN0cmluZykgPT4gYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXV0b2xpbmsob3B0aW9uczogQXV0b2xpbmtPcHRpb25zKTogUGx1Z2luIHtcbiAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgIGtleTogbmV3IFBsdWdpbktleSgnYXV0b2xpbmsnKSxcbiAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHRyYW5zYWN0aW9ucywgb2xkU3RhdGUsIG5ld1N0YXRlKSA9PiB7XG4gICAgICBjb25zdCBkb2NDaGFuZ2VzID0gdHJhbnNhY3Rpb25zLnNvbWUodHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZCkgJiYgIW9sZFN0YXRlLmRvYy5lcShuZXdTdGF0ZS5kb2MpXG4gICAgICBjb25zdCBwcmV2ZW50QXV0b2xpbmsgPSB0cmFuc2FjdGlvbnMuc29tZSh0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5nZXRNZXRhKCdwcmV2ZW50QXV0b2xpbmsnKSlcblxuICAgICAgaWYgKCFkb2NDaGFuZ2VzIHx8IHByZXZlbnRBdXRvbGluaykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyB0ciB9ID0gbmV3U3RhdGVcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzKG9sZFN0YXRlLmRvYywgWy4uLnRyYW5zYWN0aW9uc10pXG4gICAgICBjb25zdCBjaGFuZ2VzID0gZ2V0Q2hhbmdlZFJhbmdlcyh0cmFuc2Zvcm0pXG5cbiAgICAgIGNoYW5nZXMuZm9yRWFjaCgoeyBuZXdSYW5nZSB9KSA9PiB7XG4gICAgICAgIC8vIE5vdyBsZXTigJlzIHNlZSBpZiB3ZSBjYW4gYWRkIG5ldyBsaW5rcy5cbiAgICAgICAgY29uc3Qgbm9kZXNJbkNoYW5nZWRSYW5nZXMgPSBmaW5kQ2hpbGRyZW5JblJhbmdlKFxuICAgICAgICAgIG5ld1N0YXRlLmRvYyxcbiAgICAgICAgICBuZXdSYW5nZSxcbiAgICAgICAgICBub2RlID0+IG5vZGUuaXNUZXh0YmxvY2ssXG4gICAgICAgIClcblxuICAgICAgICBsZXQgdGV4dEJsb2NrOiBOb2RlV2l0aFBvcyB8IHVuZGVmaW5lZFxuICAgICAgICBsZXQgdGV4dEJlZm9yZVdoaXRlc3BhY2U6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmIChub2Rlc0luQ2hhbmdlZFJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgLy8gR3JhYiB0aGUgZmlyc3Qgbm9kZSB3aXRoaW4gdGhlIGNoYW5nZWQgcmFuZ2VzIChleC4gdGhlIGZpcnN0IG9mIHR3byBwYXJhZ3JhcGhzIHdoZW4gaGl0dGluZyBlbnRlcikuXG4gICAgICAgICAgdGV4dEJsb2NrID0gbm9kZXNJbkNoYW5nZWRSYW5nZXNbMF1cbiAgICAgICAgICB0ZXh0QmVmb3JlV2hpdGVzcGFjZSA9IG5ld1N0YXRlLmRvYy50ZXh0QmV0d2VlbihcbiAgICAgICAgICAgIHRleHRCbG9jay5wb3MsXG4gICAgICAgICAgICB0ZXh0QmxvY2sucG9zICsgdGV4dEJsb2NrLm5vZGUubm9kZVNpemUsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAnICcsXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIG5vZGVzSW5DaGFuZ2VkUmFuZ2VzLmxlbmd0aFxuICAgICAgICAgIC8vIFdlIHdhbnQgdG8gbWFrZSBzdXJlIHRvIGluY2x1ZGUgdGhlIGJsb2NrIHNlcGVyYXRvciBhcmd1bWVudCB0byB0cmVhdCBoYXJkIGJyZWFrcyBsaWtlIHNwYWNlcy5cbiAgICAgICAgICAmJiBuZXdTdGF0ZS5kb2MudGV4dEJldHdlZW4obmV3UmFuZ2UuZnJvbSwgbmV3UmFuZ2UudG8sICcgJywgJyAnKS5lbmRzV2l0aCgnICcpXG4gICAgICAgICkge1xuICAgICAgICAgIHRleHRCbG9jayA9IG5vZGVzSW5DaGFuZ2VkUmFuZ2VzWzBdXG4gICAgICAgICAgdGV4dEJlZm9yZVdoaXRlc3BhY2UgPSBuZXdTdGF0ZS5kb2MudGV4dEJldHdlZW4oXG4gICAgICAgICAgICB0ZXh0QmxvY2sucG9zLFxuICAgICAgICAgICAgbmV3UmFuZ2UudG8sXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAnICcsXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRCbG9jayAmJiB0ZXh0QmVmb3JlV2hpdGVzcGFjZSkge1xuICAgICAgICAgIGNvbnN0IHdvcmRzQmVmb3JlV2hpdGVzcGFjZSA9IHRleHRCZWZvcmVXaGl0ZXNwYWNlLnNwbGl0KCcgJykuZmlsdGVyKHMgPT4gcyAhPT0gJycpXG5cbiAgICAgICAgICBpZiAod29yZHNCZWZvcmVXaGl0ZXNwYWNlLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBsYXN0V29yZEJlZm9yZVNwYWNlID0gd29yZHNCZWZvcmVXaGl0ZXNwYWNlW3dvcmRzQmVmb3JlV2hpdGVzcGFjZS5sZW5ndGggLSAxXVxuICAgICAgICAgIGNvbnN0IGxhc3RXb3JkQW5kQmxvY2tPZmZzZXQgPSB0ZXh0QmxvY2sucG9zICsgdGV4dEJlZm9yZVdoaXRlc3BhY2UubGFzdEluZGV4T2YobGFzdFdvcmRCZWZvcmVTcGFjZSlcblxuICAgICAgICAgIGlmICghbGFzdFdvcmRCZWZvcmVTcGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmluZChsYXN0V29yZEJlZm9yZVNwYWNlKVxuICAgICAgICAgICAgLmZpbHRlcihsaW5rID0+IGxpbmsuaXNMaW5rKVxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGxpbmsgcG9zaXRpb24uXG4gICAgICAgICAgICAubWFwKGxpbmsgPT4gKHtcbiAgICAgICAgICAgICAgLi4ubGluayxcbiAgICAgICAgICAgICAgZnJvbTogbGFzdFdvcmRBbmRCbG9ja09mZnNldCArIGxpbmsuc3RhcnQgKyAxLFxuICAgICAgICAgICAgICB0bzogbGFzdFdvcmRBbmRCbG9ja09mZnNldCArIGxpbmsuZW5kICsgMSxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLy8gaWdub3JlIGxpbmsgaW5zaWRlIGNvZGUgbWFya1xuICAgICAgICAgICAgLmZpbHRlcihsaW5rID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFuZXdTdGF0ZS5zY2hlbWEubWFya3MuY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gIW5ld1N0YXRlLmRvYy5yYW5nZUhhc01hcmsoXG4gICAgICAgICAgICAgICAgbGluay5mcm9tLFxuICAgICAgICAgICAgICAgIGxpbmsudG8sXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUuc2NoZW1hLm1hcmtzLmNvZGUsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvLyB2YWxpZGF0ZSBsaW5rXG4gICAgICAgICAgICAuZmlsdGVyKGxpbmsgPT4ge1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy52YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnZhbGlkYXRlKGxpbmsudmFsdWUpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvLyBBZGQgbGluayBtYXJrLlxuICAgICAgICAgICAgLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgICAgICAgIGlmIChnZXRNYXJrc0JldHdlZW4obGluay5mcm9tLCBsaW5rLnRvLCBuZXdTdGF0ZS5kb2MpLnNvbWUoaXRlbSA9PiBpdGVtLm1hcmsudHlwZSA9PT0gb3B0aW9ucy50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdHIuYWRkTWFyayhcbiAgICAgICAgICAgICAgICBsaW5rLmZyb20sXG4gICAgICAgICAgICAgICAgbGluay50byxcbiAgICAgICAgICAgICAgICBvcHRpb25zLnR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgIGhyZWY6IGxpbmsuaHJlZixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgaWYgKCF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0clxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgZ2V0QXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxudHlwZSBDbGlja0hhbmRsZXJPcHRpb25zID0ge1xuICB0eXBlOiBNYXJrVHlwZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xpY2tIYW5kbGVyKG9wdGlvbnM6IENsaWNrSGFuZGxlck9wdGlvbnMpOiBQbHVnaW4ge1xuICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAga2V5OiBuZXcgUGx1Z2luS2V5KCdoYW5kbGVDbGlja0xpbmsnKSxcbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlQ2xpY2s6ICh2aWV3LCBwb3MsIGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV2ZW50VGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG5cbiAgICAgICAgaWYgKGV2ZW50VGFyZ2V0Lm5vZGVOYW1lICE9PSAnQScpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGF0dHJzID0gZ2V0QXR0cmlidXRlcyh2aWV3LnN0YXRlLCBvcHRpb25zLnR5cGUubmFtZSlcbiAgICAgICAgY29uc3QgbGluayA9IChldmVudC50YXJnZXQgYXMgSFRNTExpbmtFbGVtZW50KVxuXG4gICAgICAgIGNvbnN0IGhyZWYgPSBsaW5rPy5ocmVmID8/IGF0dHJzLmhyZWZcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbGluaz8udGFyZ2V0ID8/IGF0dHJzLnRhcmdldFxuXG4gICAgICAgIGlmIChsaW5rICYmIGhyZWYpIHtcbiAgICAgICAgICBpZiAodmlldy5lZGl0YWJsZSkge1xuICAgICAgICAgICAgd2luZG93Lm9wZW4oaHJlZiwgdGFyZ2V0KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0sXG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBFZGl0b3IgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBmaW5kIH0gZnJvbSAnbGlua2lmeWpzJ1xuXG50eXBlIFBhc3RlSGFuZGxlck9wdGlvbnMgPSB7XG4gIGVkaXRvcjogRWRpdG9yXG4gIHR5cGU6IE1hcmtUeXBlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXN0ZUhhbmRsZXIob3B0aW9uczogUGFzdGVIYW5kbGVyT3B0aW9ucyk6IFBsdWdpbiB7XG4gIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2hhbmRsZVBhc3RlTGluaycpLFxuICAgIHByb3BzOiB7XG4gICAgICBoYW5kbGVQYXN0ZTogKHZpZXcsIGV2ZW50LCBzbGljZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSB2aWV3XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICAgICAgICBjb25zdCB7IGVtcHR5IH0gPSBzZWxlY3Rpb25cblxuICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0ZXh0Q29udGVudCA9ICcnXG5cbiAgICAgICAgc2xpY2UuY29udGVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgIHRleHRDb250ZW50ICs9IG5vZGUudGV4dENvbnRlbnRcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBsaW5rID0gZmluZCh0ZXh0Q29udGVudCkuZmluZChpdGVtID0+IGl0ZW0uaXNMaW5rICYmIGl0ZW0udmFsdWUgPT09IHRleHRDb250ZW50KVxuXG4gICAgICAgIGlmICghdGV4dENvbnRlbnQgfHwgIWxpbmspIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGh0bWwgPSBldmVudC5jbGlwYm9hcmREYXRhPy5nZXREYXRhKCd0ZXh0L2h0bWwnKVxuXG4gICAgICAgIGNvbnN0IGhyZWZSZWdleCA9IC9ocmVmPVwiKFteXCJdKilcIi9cblxuICAgICAgICBjb25zdCBleGlzdGluZ0xpbmsgPSBodG1sPy5tYXRjaChocmVmUmVnZXgpXG5cbiAgICAgICAgY29uc3QgdXJsID0gZXhpc3RpbmdMaW5rID8gZXhpc3RpbmdMaW5rWzFdIDogbGluay5ocmVmXG5cbiAgICAgICAgb3B0aW9ucy5lZGl0b3IuY29tbWFuZHMuc2V0TWFyayhvcHRpb25zLnR5cGUsIHtcbiAgICAgICAgICBocmVmOiB1cmwsXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0sXG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBNYXJrLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgZmluZCwgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbCwgcmVzZXQgfSBmcm9tICdsaW5raWZ5anMnXG5cbmltcG9ydCB7IGF1dG9saW5rIH0gZnJvbSAnLi9oZWxwZXJzL2F1dG9saW5rLmpzJ1xuaW1wb3J0IHsgY2xpY2tIYW5kbGVyIH0gZnJvbSAnLi9oZWxwZXJzL2NsaWNrSGFuZGxlci5qcydcbmltcG9ydCB7IHBhc3RlSGFuZGxlciB9IGZyb20gJy4vaGVscGVycy9wYXN0ZUhhbmRsZXIuanMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlua1Byb3RvY29sT3B0aW9ucyB7XG4gIHNjaGVtZTogc3RyaW5nO1xuICBvcHRpb25hbFNsYXNoZXM/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpbmtPcHRpb25zIHtcbiAgLyoqXG4gICAqIElmIGVuYWJsZWQsIGl0IGFkZHMgbGlua3MgYXMgeW91IHR5cGUuXG4gICAqL1xuICBhdXRvbGluazogYm9vbGVhblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgY3VzdG9tIHByb3RvY29scyB0byBiZSByZWdpc3RlcmVkIHdpdGggbGlua2lmeWpzLlxuICAgKi9cbiAgcHJvdG9jb2xzOiBBcnJheTxMaW5rUHJvdG9jb2xPcHRpb25zIHwgc3RyaW5nPlxuICAvKipcbiAgICogSWYgZW5hYmxlZCwgbGlua3Mgd2lsbCBiZSBvcGVuZWQgb24gY2xpY2suXG4gICAqL1xuICBvcGVuT25DbGljazogYm9vbGVhblxuICAvKipcbiAgICogQWRkcyBhIGxpbmsgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlmIHRoZSBwYXN0ZWQgY29udGVudCBvbmx5IGNvbnRhaW5zIGFuIHVybC5cbiAgICovXG4gIGxpbmtPblBhc3RlOiBib29sZWFuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgSFRNTCBhdHRyaWJ1dGVzIHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgLyoqXG4gICAqIEEgdmFsaWRhdGlvbiBmdW5jdGlvbiB0aGF0IG1vZGlmaWVzIGxpbmsgdmVyaWZpY2F0aW9uIGZvciB0aGUgYXV0byBsaW5rZXIuXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgdXJsIHRvIGJlIHZhbGlkYXRlZC5cbiAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSB1cmwgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHZhbGlkYXRlPzogKHVybDogc3RyaW5nKSA9PiBib29sZWFuXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBsaW5rOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIGxpbmsgbWFya1xuICAgICAgICovXG4gICAgICBzZXRMaW5rOiAoYXR0cmlidXRlczogeyBocmVmOiBzdHJpbmc7IHRhcmdldD86IHN0cmluZyB8IG51bGw7IHJlbD86IHN0cmluZyB8IG51bGw7IGNsYXNzPzogc3RyaW5nIHwgbnVsbCB9KSA9PiBSZXR1cm5UeXBlXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIGxpbmsgbWFya1xuICAgICAgICovXG4gICAgICB0b2dnbGVMaW5rOiAoYXR0cmlidXRlczogeyBocmVmOiBzdHJpbmc7IHRhcmdldD86IHN0cmluZyB8IG51bGw7IHJlbD86IHN0cmluZyB8IG51bGw7IGNsYXNzPzogc3RyaW5nIHwgbnVsbCB9KSA9PiBSZXR1cm5UeXBlXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGEgbGluayBtYXJrXG4gICAgICAgKi9cbiAgICAgIHVuc2V0TGluazogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgTGluayA9IE1hcmsuY3JlYXRlPExpbmtPcHRpb25zPih7XG4gIG5hbWU6ICdsaW5rJyxcblxuICBwcmlvcml0eTogMTAwMCxcblxuICBrZWVwT25TcGxpdDogZmFsc2UsXG5cbiAgb25DcmVhdGUoKSB7XG4gICAgdGhpcy5vcHRpb25zLnByb3RvY29scy5mb3JFYWNoKHByb3RvY29sID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2wgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wocHJvdG9jb2wpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbChwcm90b2NvbC5zY2hlbWUsIHByb3RvY29sLm9wdGlvbmFsU2xhc2hlcylcbiAgICB9KVxuICB9LFxuXG4gIG9uRGVzdHJveSgpIHtcbiAgICByZXNldCgpXG4gIH0sXG5cbiAgaW5jbHVzaXZlKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXV0b2xpbmtcbiAgfSxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuT25DbGljazogdHJ1ZSxcbiAgICAgIGxpbmtPblBhc3RlOiB0cnVlLFxuICAgICAgYXV0b2xpbms6IHRydWUsXG4gICAgICBwcm90b2NvbHM6IFtdLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgdGFyZ2V0OiAnX2JsYW5rJyxcbiAgICAgICAgcmVsOiAnbm9vcGVuZXIgbm9yZWZlcnJlciBub2ZvbGxvdycsXG4gICAgICAgIGNsYXNzOiBudWxsLFxuICAgICAgfSxcbiAgICAgIHZhbGlkYXRlOiB1bmRlZmluZWQsXG4gICAgfVxuICB9LFxuXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhyZWY6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIH0sXG4gICAgICB0YXJnZXQ6IHtcbiAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLnRhcmdldCxcbiAgICAgIH0sXG4gICAgICByZWw6IHtcbiAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLnJlbCxcbiAgICAgIH0sXG4gICAgICBjbGFzczoge1xuICAgICAgICBkZWZhdWx0OiB0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMuY2xhc3MsXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFt7IHRhZzogJ2FbaHJlZl06bm90KFtocmVmICo9IFwiamF2YXNjcmlwdDpcIiBpXSknIH1dXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAvLyBGYWxzZSBwb3NpdGl2ZTsgd2UncmUgZXhwbGljaXRseSBjaGVja2luZyBmb3IgamF2YXNjcmlwdDogbGlua3MgdG8gaWdub3JlIHRoZW1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2NyaXB0LXVybFxuICAgIGlmIChIVE1MQXR0cmlidXRlcy5ocmVmPy5zdGFydHNXaXRoKCdqYXZhc2NyaXB0OicpKSB7XG4gICAgICAvLyBzdHJpcCBvdXQgdGhlIGhyZWZcbiAgICAgIHJldHVybiBbJ2EnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCB7IC4uLkhUTUxBdHRyaWJ1dGVzLCBocmVmOiAnJyB9KSwgMF1cbiAgICB9XG4gICAgcmV0dXJuIFsnYScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0TGluazpcbiAgICAgICAgYXR0cmlidXRlcyA9PiAoeyBjaGFpbiB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNoYWluKCkuc2V0TWFyayh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpLnNldE1ldGEoJ3ByZXZlbnRBdXRvbGluaycsIHRydWUpLnJ1bigpXG4gICAgICAgIH0sXG5cbiAgICAgIHRvZ2dsZUxpbms6XG4gICAgICAgIGF0dHJpYnV0ZXMgPT4gKHsgY2hhaW4gfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgICAgICAudG9nZ2xlTWFyayh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMsIHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2U6IHRydWUgfSlcbiAgICAgICAgICAgIC5zZXRNZXRhKCdwcmV2ZW50QXV0b2xpbmsnLCB0cnVlKVxuICAgICAgICAgICAgLnJ1bigpXG4gICAgICAgIH0sXG5cbiAgICAgIHVuc2V0TGluazpcbiAgICAgICAgKCkgPT4gKHsgY2hhaW4gfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgICAgICAudW5zZXRNYXJrKHRoaXMubmFtZSwgeyBleHRlbmRFbXB0eU1hcmtSYW5nZTogdHJ1ZSB9KVxuICAgICAgICAgICAgLnNldE1ldGEoJ3ByZXZlbnRBdXRvbGluaycsIHRydWUpXG4gICAgICAgICAgICAucnVuKClcbiAgICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHRleHQgPT4gZmluZCh0ZXh0KVxuICAgICAgICAgIC5maWx0ZXIobGluayA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudmFsaWRhdGUobGluay52YWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maWx0ZXIobGluayA9PiBsaW5rLmlzTGluaylcbiAgICAgICAgICAubWFwKGxpbmsgPT4gKHtcbiAgICAgICAgICAgIHRleHQ6IGxpbmsudmFsdWUsXG4gICAgICAgICAgICBpbmRleDogbGluay5zdGFydCxcbiAgICAgICAgICAgIGRhdGE6IGxpbmssXG4gICAgICAgICAgfSkpLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IChtYXRjaCwgcGFzdGVFdmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGh0bWwgPSBwYXN0ZUV2ZW50Py5jbGlwYm9hcmREYXRhPy5nZXREYXRhKCd0ZXh0L2h0bWwnKVxuICAgICAgICAgIGNvbnN0IGhyZWZSZWdleCA9IC9ocmVmPVwiKFteXCJdKilcIi9cblxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTGluayA9IGh0bWw/Lm1hdGNoKGhyZWZSZWdleClcblxuICAgICAgICAgIGlmIChleGlzdGluZ0xpbmspIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGhyZWY6IGV4aXN0aW5nTGlua1sxXSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaHJlZjogbWF0Y2guZGF0YT8uaHJlZixcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIGNvbnN0IHBsdWdpbnM6IFBsdWdpbltdID0gW11cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b2xpbmspIHtcbiAgICAgIHBsdWdpbnMucHVzaChcbiAgICAgICAgYXV0b2xpbmsoe1xuICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICB2YWxpZGF0ZTogdGhpcy5vcHRpb25zLnZhbGlkYXRlLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9wZW5PbkNsaWNrKSB7XG4gICAgICBwbHVnaW5zLnB1c2goXG4gICAgICAgIGNsaWNrSGFuZGxlcih7XG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpbmtPblBhc3RlKSB7XG4gICAgICBwbHVnaW5zLnB1c2goXG4gICAgICAgIHBhc3RlSGFuZGxlcih7XG4gICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBwbHVnaW5zXG4gIH0sXG59KVxuIiwgImltcG9ydCBMaW5rIGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWxpbmsnXG5cbmV4cG9ydCBjb25zdCBMaW5rRXh0ZW5zaW9uID0gTGluay5leHRlbmQoe1xuICAgIGluY2x1c2l2ZTogZmFsc2UsXG5cbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3Blbk9uQ2xpY2s6IGZhbHNlLFxuICAgICAgICAgICAgbGlua09uUGFzdGU6IHRydWUsXG4gICAgICAgICAgICBhdXRvbGluazogZmFsc2UsXG4gICAgICAgICAgICBwcm90b2NvbHM6IFtdLFxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgICAgdmFsaWRhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaHJlZjoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcy50YXJnZXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaHJlZmxhbmc6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVmZXJyZXJwb2xpY3k6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc19idXR0b246IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcnNlSFRNTDogZWxlbWVudCA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1hcy1idXR0b24nKSA/PyBudWxsLFxuICAgICAgICAgICAgICAgIHJlbmRlckhUTUw6IGF0dHJpYnV0ZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXMuYXNfYnV0dG9uKSByZXR1cm5cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtYXMtYnV0dG9uJzogYXR0cmlidXRlcy5hc19idXR0b24sXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ1dHRvbl90aGVtZToge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWFzLWJ1dHRvbi10aGVtZScpID8/IG51bGwsXG4gICAgICAgICAgICAgICAgcmVuZGVySFRNTDogYXR0cmlidXRlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXR0cmlidXRlcy5idXR0b25fdGhlbWUpIHJldHVyblxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1hcy1idXR0b24tdGhlbWUnOiBhdHRyaWJ1dGVzLmJ1dHRvbl90aGVtZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgfSxcbn0pXG4iLCAiaW1wb3J0IHtcbiAgbWVyZ2VBdHRyaWJ1dGVzLFxuICBOb2RlLFxuICBub2RlSW5wdXRSdWxlLFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VPcHRpb25zIHtcbiAgaW5saW5lOiBib29sZWFuLFxuICBhbGxvd0Jhc2U2NDogYm9vbGVhbixcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBpbWFnZToge1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYW4gaW1hZ2VcbiAgICAgICAqL1xuICAgICAgc2V0SW1hZ2U6IChvcHRpb25zOiB7IHNyYzogc3RyaW5nLCBhbHQ/OiBzdHJpbmcsIHRpdGxlPzogc3RyaW5nIH0pID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSghXFxbKC4rfDo/KV1cXCgoXFxTKykoPzooPzpcXHMrKVtcIiddKFxcUyspW1wiJ10pP1xcKSkkL1xuXG5leHBvcnQgY29uc3QgSW1hZ2UgPSBOb2RlLmNyZWF0ZTxJbWFnZU9wdGlvbnM+KHtcbiAgbmFtZTogJ2ltYWdlJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbmxpbmU6IGZhbHNlLFxuICAgICAgYWxsb3dCYXNlNjQ6IGZhbHNlLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBpbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmxpbmVcbiAgfSxcblxuICBncm91cCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlubGluZSA/ICdpbmxpbmUnIDogJ2Jsb2NrJ1xuICB9LFxuXG4gIGRyYWdnYWJsZTogdHJ1ZSxcblxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzcmM6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIH0sXG4gICAgICBhbHQ6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIH0sXG4gICAgICB0aXRsZToge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogdGhpcy5vcHRpb25zLmFsbG93QmFzZTY0XG4gICAgICAgICAgPyAnaW1nW3NyY10nXG4gICAgICAgICAgOiAnaW1nW3NyY106bm90KFtzcmNePVwiZGF0YTpcIl0pJyxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnaW1nJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRJbWFnZTogb3B0aW9ucyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5pbnNlcnRDb250ZW50KHtcbiAgICAgICAgICB0eXBlOiB0aGlzLm5hbWUsXG4gICAgICAgICAgYXR0cnM6IG9wdGlvbnMsXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBub2RlSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiBtYXRjaCA9PiB7XG4gICAgICAgICAgY29uc3QgWywsIGFsdCwgc3JjLCB0aXRsZV0gPSBtYXRjaFxuXG4gICAgICAgICAgcmV0dXJuIHsgc3JjLCBhbHQsIHRpdGxlIH1cbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiY2xhc3MgU3ZlbHRlUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgeyBlbGVtZW50IH0pIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMuZG9tID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZCgnc3ZlbHRlLXJlbmRlcmVyJyk7XG4gICAgfVxuICAgIHVwZGF0ZVByb3BzKHByb3BzKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LiRzZXQocHJvcHMpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudC4kZGVzdHJveSgpO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFN2ZWx0ZVJlbmRlcmVyO1xuIiwgImV4cG9ydCBjb25zdCBUSVBUQVBfTk9ERV9WSUVXID0gJ1RpcFRhcE5vZGVWaWV3JztcbiIsICJpbXBvcnQgeyBOb2RlVmlldywgRWRpdG9yIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCBTdmVsdGVSZW5kZXJlciBmcm9tICcuL1N2ZWx0ZVJlbmRlcmVyJztcbmltcG9ydCB7IFRJUFRBUF9OT0RFX1ZJRVcgfSBmcm9tICcuL2NvbnRleHQnO1xuY2xhc3MgU3ZlbHRlTm9kZVZpZXcgZXh0ZW5kcyBOb2RlVmlldyB7XG4gICAgbW91bnQoKSB7XG4gICAgICAgIGNvbnN0IENvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICBub2RlOiB0aGlzLm5vZGUsXG4gICAgICAgICAgICBkZWNvcmF0aW9uczogdGhpcy5kZWNvcmF0aW9ucyxcbiAgICAgICAgICAgIHNlbGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dGVuc2lvbjogdGhpcy5leHRlbnNpb24sXG4gICAgICAgICAgICBnZXRQb3M6ICgpID0+IHRoaXMuZ2V0UG9zKCksXG4gICAgICAgICAgICB1cGRhdGVBdHRyaWJ1dGVzOiAoYXR0cmlidXRlcyA9IHt9KSA9PiB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcyksXG4gICAgICAgICAgICBkZWxldGVOb2RlOiAoKSA9PiB0aGlzLmRlbGV0ZU5vZGUoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NRWxlbWVudCA9IHRoaXMubm9kZS5pc0xlYWYgPyBudWxsIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm5vZGUuaXNJbmxpbmUgPyAnc3BhbicgOiAnZGl2Jyk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET01FbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBGb3Igc29tZSByZWFzb24gdGhlIHdoaXRlU3BhY2UgcHJvcCBpcyBub3QgaW5oZXJpdGVkIHByb3Blcmx5IGluIENocm9tZSBhbmQgU2FmYXJpXG4gICAgICAgICAgICAvLyBXaXRoIHRoaXMgZml4IGl0IHNlZW1zIHRvIHdvcmsgZmluZVxuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzExOTdcbiAgICAgICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQuc3R5bGUud2hpdGVTcGFjZSA9ICdpbmhlcml0JztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IE1hcCgpO1xuICAgICAgICBjb250ZXh0LnNldChUSVBUQVBfTk9ERV9WSUVXLCB7XG4gICAgICAgICAgICBvbkRyYWdTdGFydDogdGhpcy5vbkRyYWdTdGFydC5iaW5kKHRoaXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXMgPSB0aGlzLm9wdGlvbnMuYXMgPz8gKHRoaXMubm9kZS5pc0lubGluZSA/ICdzcGFuJyA6ICdkaXYnKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChhcyk7XG4gICAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKGBub2RlLSR7dGhpcy5ub2RlLnR5cGUubmFtZX1gKTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUgPSB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmVkaXRvci5vbignc2VsZWN0aW9uVXBkYXRlJywgdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUpO1xuICAgICAgICBjb25zdCBzdmVsdGVDb21wb25lbnQgPSBuZXcgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgU3ZlbHRlUmVuZGVyZXIoc3ZlbHRlQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlbGVtZW50OiB0YXJnZXQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwcGVuZENvbnRlbmREb20oKTtcbiAgICB9XG4gICAgYXBwZW5kQ29udGVuZERvbSgpIHtcbiAgICAgICAgY29uc3QgY29udGVudEVsZW1lbnQgPSB0aGlzLmRvbS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1ub2RlLXZpZXctY29udGVudF0nKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTUVsZW1lbnQgJiYgY29udGVudEVsZW1lbnQgJiYgIWNvbnRlbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMuY29udGVudERPTUVsZW1lbnQpKSB7XG4gICAgICAgICAgICBjb250ZW50RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET01FbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZG9tKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVuZGVyZXIuZG9tLmZpcnN0RWxlbWVudENoaWxkPy5oYXNBdHRyaWJ1dGUoJ2RhdGEtbm9kZS12aWV3LXdyYXBwZXInKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIE5vZGVWaWV3V3JhcHBlciBjb21wb25lbnQgZm9yIHlvdXIgbm9kZSB2aWV3LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmRvbTtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRET00oKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNMZWFmKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NRWxlbWVudDtcbiAgICB9XG4gICAgaGFuZGxlU2VsZWN0aW9uVXBkYXRlKCkge1xuICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmIChmcm9tIDw9IHRoaXMuZ2V0UG9zKCkgJiYgdG8gPj0gdGhpcy5nZXRQb3MoKSArIHRoaXMubm9kZS5ub2RlU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3ROb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0Tm9kZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZShub2RlLCBkZWNvcmF0aW9ucykge1xuICAgICAgICBjb25zdCB1cGRhdGVQcm9wcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlUHJvcHMoeyBub2RlLCBkZWNvcmF0aW9ucyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMudXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBvbGROb2RlID0gdGhpcy5ub2RlO1xuICAgICAgICAgICAgY29uc3Qgb2xkRGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBvbGROb2RlLFxuICAgICAgICAgICAgICAgIG9sZERlY29yYXRpb25zLFxuICAgICAgICAgICAgICAgIG5ld05vZGU6IG5vZGUsXG4gICAgICAgICAgICAgICAgbmV3RGVjb3JhdGlvbnM6IGRlY29yYXRpb25zLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVByb3BzOiAoKSA9PiB1cGRhdGVQcm9wcygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gdGhpcy5ub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5ub2RlICYmIHRoaXMuZGVjb3JhdGlvbnMgPT09IGRlY29yYXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gZGVjb3JhdGlvbnM7XG4gICAgICAgIHVwZGF0ZVByb3BzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzZWxlY3ROb2RlKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVByb3BzKHsgc2VsZWN0ZWQ6IHRydWUgfSk7XG4gICAgfVxuICAgIGRlc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVQcm9wcyh7IHNlbGVjdGVkOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9mZignc2VsZWN0aW9uVXBkYXRlJywgdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUpO1xuICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gbnVsbDtcbiAgICB9XG59XG5jb25zdCBTdmVsdGVOb2RlVmlld1JlbmRlcmVyID0gKGNvbXBvbmVudCwgb3B0aW9ucykgPT4ge1xuICAgIHJldHVybiAocHJvcHMpID0+IG5ldyBTdmVsdGVOb2RlVmlldyhjb21wb25lbnQsIHByb3BzLCBvcHRpb25zKTtcbn07XG5leHBvcnQgZGVmYXVsdCBTdmVsdGVOb2RlVmlld1JlbmRlcmVyO1xuIiwgIjxzY3JpcHQ+aW1wb3J0IHsgZ2V0Q29udGV4dCwgb25Nb3VudCwgdGljayB9IGZyb20gXCJzdmVsdGVcIjtcbmltcG9ydCB7IFRJUFRBUF9OT0RFX1ZJRVcgfSBmcm9tIFwiLi9jb250ZXh0XCI7XG5jb25zdCB7IG9uRHJhZ1N0YXJ0IH0gPSBnZXRDb250ZXh0KFRJUFRBUF9OT0RFX1ZJRVcpO1xubGV0IGVsZW1lbnQ7XG5leHBvcnQgbGV0IGFzID0gXCJkaXZcIjtcbm9uTW91bnQoYXN5bmMgKCkgPT4ge1xuICBhd2FpdCB0aWNrKCk7XG4gIGVsZW1lbnQuc3R5bGUud2hpdGVTcGFjZSA9IFwibm9ybWFsXCI7XG59KTtcbjwvc2NyaXB0PlxuXG48c3ZlbHRlOmVsZW1lbnRcbiAgdGhpcz17YXN9XG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgZGF0YS1ub2RlLXZpZXctd3JhcHBlcj1cIlwiXG4gIG9uOmRyYWdzdGFydD17b25EcmFnU3RhcnR9XG4gIHJvbGU9XCJub25lXCJcbiAgey4uLiQkcmVzdFByb3BzfVxuPlxuICA8c2xvdCAvPlxuPC9zdmVsdGU6ZWxlbWVudD5cbiIsICI8c2NyaXB0PmltcG9ydCB7IG9uTW91bnQsIHRpY2sgfSBmcm9tIFwic3ZlbHRlXCI7XG5sZXQgZWxlbWVudDtcbmV4cG9ydCBsZXQgYXMgPSBcImRpdlwiO1xub25Nb3VudChhc3luYyAoKSA9PiB7XG4gIGF3YWl0IHRpY2soKTtcbiAgZWxlbWVudC5zdHlsZS53aGl0ZVNwYWNlID0gXCJwcmUtd3JhcFwiO1xufSk7XG48L3NjcmlwdD5cblxuPHN2ZWx0ZTplbGVtZW50IHRoaXM9e2FzfSBiaW5kOnRoaXM9e2VsZW1lbnR9IGRhdGEtbm9kZS12aWV3LWNvbnRlbnQ9XCJcIiB7Li4uJCRyZXN0UHJvcHN9PlxuICA8c2xvdCAvPlxuPC9zdmVsdGU6ZWxlbWVudD5cbiIsICJleHBvcnQgY29uc3QgcG91bmNlID0gKGNvbXBvbmVudCwgYXJncykgPT4ge1xuICAgIHdpbmRvdy5MaXZld2lyZS5kaXNwYXRjaCgncG91bmNlJywgeyBjb21wb25lbnQ6IGNvbXBvbmVudCwgYXJndW1lbnRzOiBhcmdzIH0pXG59XG4iLCAiaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tICdzdmVsdGUvc3RvcmUnXG5cbmV4cG9ydCBjb25zdCBnZXRTdGF0ZVBhdGggPSB3cml0YWJsZShudWxsKVxuIiwgIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTm9kZVZpZXdXcmFwcGVyIH0gZnJvbSAnc3ZlbHRlLXRpcHRhcCdcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IHBvdW5jZSB9IGZyb20gJy4uL3V0aWxzL3BvdW5jZS5qcydcbiAgICBpbXBvcnQgeyBnZXRTdGF0ZVBhdGggfSBmcm9tICcuLi9zdG9yZXMuanMnXG5cbiAgICBleHBvcnQgbGV0IGVkaXRvcjtcbiAgICBleHBvcnQgbGV0IG5vZGU7XG4gICAgZXhwb3J0IGxldCBzZWxlY3RlZCA9IGZhbHNlO1xuICAgIGV4cG9ydCBsZXQgdXBkYXRlQXR0cmlidXRlcztcblxuICAgIGNvbnN0IG9wZW4gPSAoKSA9PiB7XG4gICAgICAgIHBvdW5jZSgnc2NyaWJibGUtbWVkaWEnLCB7XG4gICAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgICBzdGF0ZVBhdGg6ICRnZXRTdGF0ZVBhdGgsXG4gICAgICAgICAgICAuLi5ub2RlLmF0dHJzXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgcmVtb3ZlQmxvY2sgPSAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5jb21tYW5kcy5kZWxldGVTZWxlY3Rpb24oKVxuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZEJsb2NrJywgKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlLmRldGFpbC50eXBlID09PSBub2RlLmF0dHJzLnR5cGUgJiYgZS5kZXRhaWwuc3RhdGVQYXRoID09PSBub2RlLmF0dHJzLnN0YXRlUGF0aCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUF0dHJpYnV0ZXMoeyB2YWx1ZXM6IGUuZGV0YWlsLnZhbHVlcyB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pXG48L3NjcmlwdD5cblxuPE5vZGVWaWV3V3JhcHBlcj5cbiAgICA8ZGl2IGNsYXNzPVwicmVsYXRpdmUgZ3JvdXAgYmctZ3JheS05MDAvNSBkYXJrOmJnLXdoaXRlLzUgcm91bmRlZC1tZFwiIHN0eWxlPVwibWluLWhlaWdodDogM3JlbTtcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRyYW5zaXRpb24gcm91bmRlZC1tZCBvdmVyZmxvdy1oaWRkZW4gei0xMCByZWxhdGl2ZSB7c2VsZWN0ZWQgPyAnUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlJyA6ICcnfVwiPlxuICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgIHNyYz17bm9kZS5hdHRycy5zcmN9XG4gICAgICAgICAgICAgICAgYWx0PXtub2RlLmF0dHJzLmFsdH1cbiAgICAgICAgICAgICAgICB0aXRsZT17bm9kZS5hdHRycz8udGl0bGUgPz8gbnVsbH1cbiAgICAgICAgICAgICAgICB3aWR0aD17bm9kZS5hdHRycy53aWR0aH1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9e25vZGUuYXR0cnMuaGVpZ2h0fVxuICAgICAgICAgICAgICAgIGxvYWRpbmc9e25vZGUuYXR0cnMubG9hZGluZ31cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwic2NyaWJibGUtYmxvY2stYWN0aW9ucyB0cmFuc2l0aW9uIG9wYWNpdHktMCBhYnNvbHV0ZSB6LTIwIHRvcC0wIHJpZ2h0LTAgcC0xIHJvdW5kZWQtdHItbWQgcm91bmRlZC1ibC1sZyBmbGV4IGl0ZW1zLWNlbnRlciBiZy1ncmF5LTk1MCBncm91cC1ob3ZlcjpvcGFjaXR5LTEwMFwiPlxuICAgICAgICAgICAgPGRpdiBkYXRhLWRyYWctaGFuZGxlIGNsYXNzPVwiY3Vyc29yLWdyYWJiaW5nIHRleHQtd2hpdGUgYmxvY2sgcm91bmRlZCBwLTEgaG92ZXI6dGV4dC1wcmltYXJ5LTUwMCBob3ZlcjpiZy1ncmF5LTgwMFwiPlxuICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJzaXplLTRcIj5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cIm0yMi42NyAxMmwtNC40OSA0LjVsLTIuNTEtMi41bDEuOTgtMmwtMS45OC0xLjk2bDIuNTEtMi41MXpNMTIgMS4zM2w0LjQ3IDQuNDlsLTIuNTEgMi41MUwxMiA2LjM1bC0yIDEuOThsLTIuNS0yLjUxem0wIDIxLjM0bC00LjQ3LTQuNDlsMi41MS0yLjUxTDEyIDE3LjY1bDItMS45OGwyLjUgMi41MXpNMS4zMyAxMmw0LjQ5LTQuNUw4LjMzIDEwbC0xLjk4IDJsMS45OCAxLjk2bC0yLjUxIDIuNTF6TTEyIDEwYTIgMiAwIDAgMSAyIDJhMiAyIDAgMCAxLTIgMmEyIDIgMCAwIDEtMi0yYTIgMiAwIDAgMSAyLTJcIi8+XG4gICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxidXR0b24gb246Y2xpY2t8cHJldmVudERlZmF1bHR8c3RvcFByb3BhZ2F0aW9uPXtvcGVufSB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJ0ZXh0LXdoaXRlIGJsb2NrIHJvdW5kZWQgcC0xIGhvdmVyOnRleHQtcHJpbWFyeS01MDAgaG92ZXI6YmctZ3JheS04MDBcIj5cbiAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwic2l6ZS00XCI+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTE1IDQuNUEzLjUgMy41IDAgMCAxIDExLjQzNSA4Yy0uOTktLjAxOS0yLjA5My4xMzItMi43LjkxM2wtNC4xMyA1LjMxYTIuMDE1IDIuMDE1IDAgMSAxLTIuODI3LTIuODI4bDUuMzA5LTQuMTNjLjc4LS42MDcuOTMyLTEuNzEuOTE0LTIuN0w4IDQuNWEzLjUgMy41IDAgMCAxIDQuNDc3LTMuMzYyYy4zMjUuMDk0LjM5LjQ5Ny4xNS43MzZMMTAuNiAzLjkwMmEuNDguNDggMCAwIDAtLjAzMy42NTNjLjI3MS4zMTQuNTY1LjYwOC44NzkuODc5YS40OC40OCAwIDAgMCAuNjUzLS4wMzNsMi4wMjctMi4wMjdjLjIzOS0uMjQuNjQyLS4xNzUuNzM2LjE1LjA5LjMxLjEzOC42MzcuMTM4Ljk3NlpNMy43NSAxM2EuNzUuNzUgMCAxIDEtMS41IDAgLjc1Ljc1IDAgMCAxIDEuNSAwWlwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTExLjUgOS41Yy4zMTMgMCAuNjItLjAyOS45MTctLjA4NGwxLjk2MiAxLjk2MmEyLjEyMSAyLjEyMSAwIDAgMS0zIDNsLTIuODEtMi44MSAxLjM1LTEuNzM0Yy4wNS0uMDY0LjE1OC0uMTU4LjQyNi0uMjMzLjI3OC0uMDc4LjYzOS0uMTEgMS4wNjItLjEwMmwuMDkzLjAwMVpNNSA0bDEuNDQ2IDEuNDQ1YTIuMjU2IDIuMjU2IDAgMCAxLS4wNDcuMjFjLS4wNzUuMjY4LS4xNjkuMzc3LS4yMzMuNDI3bC0uNjEuNDc0TDQgNUgyLjY1NWEuMjUuMjUgMCAwIDEtLjIyNC0uMTM5bC0xLjM1LTIuN2EuMjUuMjUgMCAwIDEgLjA0Ny0uMjg5bC43NDUtLjc0NWEuMjUuMjUgMCAwIDEgLjI4OS0uMDQ3bDIuNyAxLjM1QS4yNS4yNSAwIDAgMSA1IDIuNjU0VjRaXCIgLz5cbiAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBvbjpjbGlja3xwcmV2ZW50RGVmYXVsdHxzdG9wUHJvcGFnYXRpb249e3JlbW92ZUJsb2NrfSB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJ0ZXh0LXdoaXRlIGJsb2NrIHJvdW5kZWQgcC0xIGhvdmVyOnRleHQtcHJpbWFyeS01MDAgaG92ZXI6YmctZ3JheS04MDBcIj5cbiAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwic2l6ZS00XCI+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTUgMy4yNVY0SDIuNzVhLjc1Ljc1IDAgMCAwIDAgMS41aC4zbC44MTUgOC4xNUExLjUgMS41IDAgMCAwIDUuMzU3IDE1aDUuMjg1YTEuNSAxLjUgMCAwIDAgMS40OTMtMS4zNWwuODE1LTguMTVoLjNhLjc1Ljc1IDAgMCAwIDAtMS41SDExdi0uNzVBMi4yNSAyLjI1IDAgMCAwIDguNzUgMWgtMS41QTIuMjUgMi4yNSAwIDAgMCA1IDMuMjVabTIuMjUtLjc1YS43NS43NSAwIDAgMC0uNzUuNzVWNGgzdi0uNzVhLjc1Ljc1IDAgMCAwLS43NS0uNzVoLTEuNVpNNi4wNSA2YS43NS43NSAwIDAgMSAuNzg3LjcxM2wuMjc1IDUuNWEuNzUuNzUgMCAwIDEtMS40OTguMDc1bC0uMjc1LTUuNUEuNzUuNzUgMCAwIDEgNi4wNSA2Wm0zLjkgMGEuNzUuNzUgMCAwIDEgLjcxMi43ODdsLS4yNzUgNS41YS43NS43NSAwIDAgMS0xLjQ5OC0uMDc1bC4yNzUtNS41YS43NS43NSAwIDAgMSAuNzg2LS43MTFaXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L05vZGVWaWV3V3JhcHBlcj5cbiIsICJpbXBvcnQgSW1hZ2UgZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWltYWdlXCI7XG5pbXBvcnQgeyBTdmVsdGVOb2RlVmlld1JlbmRlcmVyIH0gZnJvbSAnc3ZlbHRlLXRpcHRhcCdcbmltcG9ydCBNZWRpYVZpZXcgZnJvbSAnLi4vY29tcG9uZW50cy9NZWRpYVZpZXcuc3ZlbHRlJ1xuXG5leHBvcnQgY29uc3QgTWVkaWFFeHRlbnNpb24gPSBJbWFnZS5leHRlbmQoe1xuICAgIHNlbGVjdGFibGU6IHRydWUsXG5cbiAgICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3JjOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbHQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3aWR0aDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2FkaW5nOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaXplczoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3Jjc2V0OiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYWRkTm9kZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBTdmVsdGVOb2RlVmlld1JlbmRlcmVyKE1lZGlhVmlldylcbiAgICB9XG59KTtcbiIsICJpbXBvcnQgeyBFZGl0b3IsIEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IE5vZGUgYXMgUHJvc2VtaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGxhY2Vob2xkZXJPcHRpb25zIHtcbiAgZW1wdHlFZGl0b3JDbGFzczogc3RyaW5nXG4gIGVtcHR5Tm9kZUNsYXNzOiBzdHJpbmdcbiAgcGxhY2Vob2xkZXI6XG4gICAgfCAoKFBsYWNlaG9sZGVyUHJvcHM6IHtcbiAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgbm9kZTogUHJvc2VtaXJyb3JOb2RlXG4gICAgICAgIHBvczogbnVtYmVyXG4gICAgICAgIGhhc0FuY2hvcjogYm9vbGVhblxuICAgICAgfSkgPT4gc3RyaW5nKVxuICAgIHwgc3RyaW5nXG4gIHNob3dPbmx5V2hlbkVkaXRhYmxlOiBib29sZWFuXG4gIHNob3dPbmx5Q3VycmVudDogYm9vbGVhblxuICBpbmNsdWRlQ2hpbGRyZW46IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNvbnN0IFBsYWNlaG9sZGVyID0gRXh0ZW5zaW9uLmNyZWF0ZTxQbGFjZWhvbGRlck9wdGlvbnM+KHtcbiAgbmFtZTogJ3BsYWNlaG9sZGVyJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlbXB0eUVkaXRvckNsYXNzOiAnaXMtZWRpdG9yLWVtcHR5JyxcbiAgICAgIGVtcHR5Tm9kZUNsYXNzOiAnaXMtZW1wdHknLFxuICAgICAgcGxhY2Vob2xkZXI6ICdXcml0ZSBzb21ldGhpbmcg4oCmJyxcbiAgICAgIHNob3dPbmx5V2hlbkVkaXRhYmxlOiB0cnVlLFxuICAgICAgc2hvd09ubHlDdXJyZW50OiB0cnVlLFxuICAgICAgaW5jbHVkZUNoaWxkcmVuOiBmYWxzZSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdwbGFjZWhvbGRlcicpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGRlY29yYXRpb25zOiAoeyBkb2MsIHNlbGVjdGlvbiB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmVkaXRvci5pc0VkaXRhYmxlIHx8ICF0aGlzLm9wdGlvbnMuc2hvd09ubHlXaGVuRWRpdGFibGVcbiAgICAgICAgICAgIGNvbnN0IHsgYW5jaG9yIH0gPSBzZWxlY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IGRlY29yYXRpb25zOiBEZWNvcmF0aW9uW10gPSBbXVxuXG4gICAgICAgICAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvbmx5IGNhbGN1bGF0ZSBpc0VtcHR5IG9uY2UgZHVlIHRvIGl0cyBwZXJmb3JtYW5jZSBpbXBhY3RzIChzZWUgaXNzdWUgIzMzNjApXG4gICAgICAgICAgICBjb25zdCBlbXB0eURvY0luc3RhbmNlID0gZG9jLnR5cGUuY3JlYXRlQW5kRmlsbCgpXG4gICAgICAgICAgICBjb25zdCBpc0VkaXRvckVtcHR5ID0gZW1wdHlEb2NJbnN0YW5jZT8uc2FtZU1hcmt1cChkb2MpXG4gICAgICAgICAgICAgICYmIGVtcHR5RG9jSW5zdGFuY2UuY29udGVudC5maW5kRGlmZlN0YXJ0KGRvYy5jb250ZW50KSA9PT0gbnVsbFxuXG4gICAgICAgICAgICBkb2MuZGVzY2VuZGFudHMoKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBoYXNBbmNob3IgPSBhbmNob3IgPj0gcG9zICYmIGFuY2hvciA8PSBwb3MgKyBub2RlLm5vZGVTaXplXG4gICAgICAgICAgICAgIGNvbnN0IGlzRW1wdHkgPSAhbm9kZS5pc0xlYWYgJiYgIW5vZGUuY2hpbGRDb3VudFxuXG4gICAgICAgICAgICAgIGlmICgoaGFzQW5jaG9yIHx8ICF0aGlzLm9wdGlvbnMuc2hvd09ubHlDdXJyZW50KSAmJiBpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IFt0aGlzLm9wdGlvbnMuZW1wdHlOb2RlQ2xhc3NdXG5cbiAgICAgICAgICAgICAgICBpZiAoaXNFZGl0b3JFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHRoaXMub3B0aW9ucy5lbXB0eUVkaXRvckNsYXNzKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29yYXRpb24gPSBEZWNvcmF0aW9uLm5vZGUocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCB7XG4gICAgICAgICAgICAgICAgICBjbGFzczogY2xhc3Nlcy5qb2luKCcgJyksXG4gICAgICAgICAgICAgICAgICAnZGF0YS1wbGFjZWhvbGRlcic6XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0FuY2hvcixcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKGRlY29yYXRpb24pXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmluY2x1ZGVDaGlsZHJlblxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKGRvYywgZGVjb3JhdGlvbnMpXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB3cmFwcGluZ0lucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBCbG9ja3F1b3RlT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgYmxvY2tRdW90ZToge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBibG9ja3F1b3RlIG5vZGVcbiAgICAgICAqL1xuICAgICAgc2V0QmxvY2txdW90ZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgYmxvY2txdW90ZSBub2RlXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUJsb2NrcXVvdGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGEgYmxvY2txdW90ZSBub2RlXG4gICAgICAgKi9cbiAgICAgIHVuc2V0QmxvY2txdW90ZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGlucHV0UmVnZXggPSAvXlxccyo+XFxzJC9cblxuZXhwb3J0IGNvbnN0IEJsb2NrcXVvdGUgPSBOb2RlLmNyZWF0ZTxCbG9ja3F1b3RlT3B0aW9ucz4oe1xuXG4gIG5hbWU6ICdibG9ja3F1b3RlJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIGNvbnRlbnQ6ICdibG9jaysnLFxuXG4gIGdyb3VwOiAnYmxvY2snLFxuXG4gIGRlZmluaW5nOiB0cnVlLFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB0YWc6ICdibG9ja3F1b3RlJyB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ2Jsb2NrcXVvdGUnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEJsb2NrcXVvdGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLndyYXBJbih0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdG9nZ2xlQmxvY2txdW90ZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlV3JhcCh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdW5zZXRCbG9ja3F1b3RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0KHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLVNoaWZ0LWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCbG9ja3F1b3RlKCksXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQge1xuICBNYXJrLFxuICBtYXJrSW5wdXRSdWxlLFxuICBtYXJrUGFzdGVSdWxlLFxuICBtZXJnZUF0dHJpYnV0ZXMsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBCb2xkT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgYm9sZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBib2xkIG1hcmtcbiAgICAgICAqL1xuICAgICAgc2V0Qm9sZDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgYm9sZCBtYXJrXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUJvbGQ6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGEgYm9sZCBtYXJrXG4gICAgICAgKi9cbiAgICAgIHVuc2V0Qm9sZDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHN0YXJJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpcXCpcXCopKCg/OlteKl0rKSkoPzpcXCpcXCopKSQvXG5leHBvcnQgY29uc3Qgc3RhclBhc3RlUmVnZXggPSAvKD86XnxcXHMpKCg/OlxcKlxcKikoKD86W14qXSspKSg/OlxcKlxcKikpL2dcbmV4cG9ydCBjb25zdCB1bmRlcnNjb3JlSW5wdXRSZWdleCA9IC8oPzpefFxccykoKD86X18pKCg/OlteX19dKykpKD86X18pKSQvXG5leHBvcnQgY29uc3QgdW5kZXJzY29yZVBhc3RlUmVnZXggPSAvKD86XnxcXHMpKCg/Ol9fKSgoPzpbXl9fXSspKSg/Ol9fKSkvZ1xuXG5leHBvcnQgY29uc3QgQm9sZCA9IE1hcmsuY3JlYXRlPEJvbGRPcHRpb25zPih7XG4gIG5hbWU6ICdib2xkJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdzdHJvbmcnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnYicsXG4gICAgICAgIGdldEF0dHJzOiBub2RlID0+IChub2RlIGFzIEhUTUxFbGVtZW50KS5zdHlsZS5mb250V2VpZ2h0ICE9PSAnbm9ybWFsJyAmJiBudWxsLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6ICdmb250LXdlaWdodCcsXG4gICAgICAgIGdldEF0dHJzOiB2YWx1ZSA9PiAvXihib2xkKGVyKT98WzUtOV1cXGR7Mix9KSQvLnRlc3QodmFsdWUgYXMgc3RyaW5nKSAmJiBudWxsLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydzdHJvbmcnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEJvbGQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZUJvbGQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHVuc2V0Qm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCb2xkKCksXG4gICAgICAnTW9kLUInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVCb2xkKCksXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFySW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcblxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogc3RhclBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBMaXN0SXRlbU9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PixcbiAgYnVsbGV0TGlzdFR5cGVOYW1lOiBzdHJpbmdcbiAgb3JkZXJlZExpc3RUeXBlTmFtZTogc3RyaW5nXG59XG5cbmV4cG9ydCBjb25zdCBMaXN0SXRlbSA9IE5vZGUuY3JlYXRlPExpc3RJdGVtT3B0aW9ucz4oe1xuICBuYW1lOiAnbGlzdEl0ZW0nLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGJ1bGxldExpc3RUeXBlTmFtZTogJ2J1bGxldExpc3QnLFxuICAgICAgb3JkZXJlZExpc3RUeXBlTmFtZTogJ29yZGVyZWRMaXN0JyxcbiAgICB9XG4gIH0sXG5cbiAgY29udGVudDogJ3BhcmFncmFwaCBibG9jayonLFxuXG4gIGRlZmluaW5nOiB0cnVlLFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdsaScsXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ2xpJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBFbnRlcjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc3BsaXRMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgVGFiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zaW5rTGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgICdTaGlmdC1UYWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7XG4gIGdldE1hcmtBdHRyaWJ1dGVzLFxuICBNYXJrLFxuICBtZXJnZUF0dHJpYnV0ZXMsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBUZXh0U3R5bGVPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHNwYW5zIHdpdGhvdXQgaW5saW5lIHN0eWxlIGF0dHJpYnV0ZXMuXG4gICAgICAgKi9cbiAgICAgIHJlbW92ZUVtcHR5VGV4dFN0eWxlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgVGV4dFN0eWxlID0gTWFyay5jcmVhdGU8VGV4dFN0eWxlT3B0aW9ucz4oe1xuICBuYW1lOiAndGV4dFN0eWxlJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdzcGFuJyxcbiAgICAgICAgZ2V0QXR0cnM6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IGhhc1N0eWxlcyA9IChlbGVtZW50IGFzIEhUTUxFbGVtZW50KS5oYXNBdHRyaWJ1dGUoJ3N0eWxlJylcblxuICAgICAgICAgIGlmICghaGFzU3R5bGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge31cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnc3BhbicsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlRW1wdHlUZXh0U3R5bGU6ICgpID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdGhpcy50eXBlKVxuICAgICAgICBjb25zdCBoYXNTdHlsZXMgPSBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5zb21lKChbLCB2YWx1ZV0pID0+ICEhdmFsdWUpXG5cbiAgICAgICAgaWYgKGhhc1N0eWxlcykge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSwgd3JhcHBpbmdJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmltcG9ydCBMaXN0SXRlbSBmcm9tICcuLi8uLi9leHRlbnNpb24tbGlzdC1pdGVtL3NyYy9pbmRleC5qcydcbmltcG9ydCBUZXh0U3R5bGUgZnJvbSAnLi4vLi4vZXh0ZW5zaW9uLXRleHQtc3R5bGUvc3JjL2luZGV4LmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEJ1bGxldExpc3RPcHRpb25zIHtcbiAgaXRlbVR5cGVOYW1lOiBzdHJpbmcsXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBrZWVwTWFya3M6IGJvb2xlYW4sXG4gIGtlZXBBdHRyaWJ1dGVzOiBib29sZWFuLFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgYnVsbGV0TGlzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBidWxsZXQgbGlzdFxuICAgICAgICovXG4gICAgICB0b2dnbGVCdWxsZXRMaXN0OiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaW5wdXRSZWdleCA9IC9eXFxzKihbLSsqXSlcXHMkL1xuXG5leHBvcnQgY29uc3QgQnVsbGV0TGlzdCA9IE5vZGUuY3JlYXRlPEJ1bGxldExpc3RPcHRpb25zPih7XG4gIG5hbWU6ICdidWxsZXRMaXN0JyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtVHlwZU5hbWU6ICdsaXN0SXRlbScsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICBrZWVwTWFya3M6IGZhbHNlLFxuICAgICAga2VlcEF0dHJpYnV0ZXM6IGZhbHNlLFxuICAgIH1cbiAgfSxcblxuICBncm91cDogJ2Jsb2NrIGxpc3QnLFxuXG4gIGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWV9K2BcbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgdGFnOiAndWwnIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsndWwnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvZ2dsZUJ1bGxldExpc3Q6ICgpID0+ICh7IGNvbW1hbmRzLCBjaGFpbiB9KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4oKS50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcykudXBkYXRlQXR0cmlidXRlcyhMaXN0SXRlbS5uYW1lLCB0aGlzLmVkaXRvci5nZXRBdHRyaWJ1dGVzKFRleHRTdHlsZS5uYW1lKSkucnVuKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1TaGlmdC04JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQnVsbGV0TGlzdCgpLFxuICAgIH1cbiAgfSxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIGxldCBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBNYXJrcyB8fCB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBrZWVwTWFya3M6IHRoaXMub3B0aW9ucy5rZWVwTWFya3MsXG4gICAgICAgIGtlZXBBdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6ICgpID0+IHsgcmV0dXJuIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlLm5hbWUpIH0sXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgaW5wdXRSdWxlLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHtcbiAgTWFyayxcbiAgbWFya0lucHV0UnVsZSxcbiAgbWFya1Bhc3RlUnVsZSxcbiAgbWVyZ2VBdHRyaWJ1dGVzLFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZU9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNvZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgY29kZSBtYXJrXG4gICAgICAgKi9cbiAgICAgIHNldENvZGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBpbmxpbmUgY29kZVxuICAgICAgICovXG4gICAgICB0b2dnbGVDb2RlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBVbnNldCBhIGNvZGUgbWFya1xuICAgICAgICovXG4gICAgICB1bnNldENvZGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpgKSgoPzpbXmBdKykpKD86YCkpJC9cbmV4cG9ydCBjb25zdCBwYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpgKSgoPzpbXmBdKykpKD86YCkpL2dcblxuZXhwb3J0IGNvbnN0IENvZGUgPSBNYXJrLmNyZWF0ZTxDb2RlT3B0aW9ucz4oe1xuICBuYW1lOiAnY29kZScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBleGNsdWRlczogJ18nLFxuXG4gIGNvZGU6IHRydWUsXG5cbiAgZXhpdGFibGU6IHRydWUsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHRhZzogJ2NvZGUnIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnY29kZScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0Q29kZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdG9nZ2xlQ29kZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdW5zZXRDb2RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtZSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUNvZGUoKSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcblxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogcGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZUJsb2NrT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBBZGRzIGEgcHJlZml4IHRvIGxhbmd1YWdlIGNsYXNzZXMgdGhhdCBhcmUgYXBwbGllZCB0byBjb2RlIHRhZ3MuXG4gICAqIERlZmF1bHRzIHRvIGAnbGFuZ3VhZ2UtJ2AuXG4gICAqL1xuICBsYW5ndWFnZUNsYXNzUHJlZml4OiBzdHJpbmdcbiAgLyoqXG4gICAqIERlZmluZSB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBleGl0ZWQgb24gdHJpcGxlIGVudGVyLlxuICAgKiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqL1xuICBleGl0T25UcmlwbGVFbnRlcjogYm9vbGVhblxuICAvKipcbiAgICogRGVmaW5lIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGV4aXRlZCBvbiBhcnJvdyBkb3duIGlmIHRoZXJlIGlzIG5vIG5vZGUgYWZ0ZXIgaXQuXG4gICAqIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICovXG4gIGV4aXRPbkFycm93RG93bjogYm9vbGVhblxuICAvKipcbiAgICogQ3VzdG9tIEhUTUwgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB0aGUgcmVuZGVyZWQgSFRNTCB0YWcuXG4gICAqL1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY29kZUJsb2NrOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIGNvZGUgYmxvY2tcbiAgICAgICAqL1xuICAgICAgc2V0Q29kZUJsb2NrOiAoYXR0cmlidXRlcz86IHsgbGFuZ3VhZ2U6IHN0cmluZyB9KSA9PiBSZXR1cm5UeXBlXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIGNvZGUgYmxvY2tcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlQ29kZUJsb2NrOiAoYXR0cmlidXRlcz86IHsgbGFuZ3VhZ2U6IHN0cmluZyB9KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBiYWNrdGlja0lucHV0UmVnZXggPSAvXmBgYChbYS16XSspP1tcXHNcXG5dJC9cbmV4cG9ydCBjb25zdCB0aWxkZUlucHV0UmVnZXggPSAvXn5+fihbYS16XSspP1tcXHNcXG5dJC9cblxuZXhwb3J0IGNvbnN0IENvZGVCbG9jayA9IE5vZGUuY3JlYXRlPENvZGVCbG9ja09wdGlvbnM+KHtcbiAgbmFtZTogJ2NvZGVCbG9jaycsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFuZ3VhZ2VDbGFzc1ByZWZpeDogJ2xhbmd1YWdlLScsXG4gICAgICBleGl0T25UcmlwbGVFbnRlcjogdHJ1ZSxcbiAgICAgIGV4aXRPbkFycm93RG93bjogdHJ1ZSxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgY29udGVudDogJ3RleHQqJyxcblxuICBtYXJrczogJycsXG5cbiAgZ3JvdXA6ICdibG9jaycsXG5cbiAgY29kZTogdHJ1ZSxcblxuICBkZWZpbmluZzogdHJ1ZSxcblxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsYW5ndWFnZToge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgbGFuZ3VhZ2VDbGFzc1ByZWZpeCB9ID0gdGhpcy5vcHRpb25zXG4gICAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IFsuLi4oZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZD8uY2xhc3NMaXN0IHx8IFtdKV1cbiAgICAgICAgICBjb25zdCBsYW5ndWFnZXMgPSBjbGFzc05hbWVzXG4gICAgICAgICAgICAuZmlsdGVyKGNsYXNzTmFtZSA9PiBjbGFzc05hbWUuc3RhcnRzV2l0aChsYW5ndWFnZUNsYXNzUHJlZml4KSlcbiAgICAgICAgICAgIC5tYXAoY2xhc3NOYW1lID0+IGNsYXNzTmFtZS5yZXBsYWNlKGxhbmd1YWdlQ2xhc3NQcmVmaXgsICcnKSlcbiAgICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGxhbmd1YWdlc1swXVxuXG4gICAgICAgICAgaWYgKCFsYW5ndWFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2VcbiAgICAgICAgfSxcbiAgICAgICAgcmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ3ByZScsXG4gICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJ2Z1bGwnLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ3ByZScsXG4gICAgICBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksXG4gICAgICBbXG4gICAgICAgICdjb2RlJyxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzOiBub2RlLmF0dHJzLmxhbmd1YWdlXG4gICAgICAgICAgICA/IHRoaXMub3B0aW9ucy5sYW5ndWFnZUNsYXNzUHJlZml4ICsgbm9kZS5hdHRycy5sYW5ndWFnZVxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICB9LFxuICAgICAgICAwLFxuICAgICAgXSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldENvZGVCbG9jazpcbiAgICAgICAgYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodGhpcy5uYW1lLCBhdHRyaWJ1dGVzKVxuICAgICAgICB9LFxuICAgICAgdG9nZ2xlQ29kZUJsb2NrOlxuICAgICAgICBhdHRyaWJ1dGVzID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTm9kZSh0aGlzLm5hbWUsICdwYXJhZ3JhcGgnLCBhdHRyaWJ1dGVzKVxuICAgICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1BbHQtYyc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUNvZGVCbG9jaygpLFxuXG4gICAgICAvLyByZW1vdmUgY29kZSBibG9jayB3aGVuIGF0IHN0YXJ0IG9mIGRvY3VtZW50IG9yIGNvZGUgYmxvY2sgaXMgZW1wdHlcbiAgICAgIEJhY2tzcGFjZTogKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGVtcHR5LCAkYW5jaG9yIH0gPSB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb25cbiAgICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gJGFuY2hvci5wb3MgPT09IDFcblxuICAgICAgICBpZiAoIWVtcHR5IHx8ICRhbmNob3IucGFyZW50LnR5cGUubmFtZSAhPT0gdGhpcy5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBdFN0YXJ0IHx8ICEkYW5jaG9yLnBhcmVudC50ZXh0Q29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IuY29tbWFuZHMuY2xlYXJOb2RlcygpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIC8vIGV4aXQgbm9kZSBvbiB0cmlwbGUgZW50ZXJcbiAgICAgIEVudGVyOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5leGl0T25UcmlwbGVFbnRlcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yXG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICAgICAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSB9ID0gc2VsZWN0aW9uXG5cbiAgICAgICAgaWYgKCFlbXB0eSB8fCAkZnJvbS5wYXJlbnQudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0F0RW5kID0gJGZyb20ucGFyZW50T2Zmc2V0ID09PSAkZnJvbS5wYXJlbnQubm9kZVNpemUgLSAyXG4gICAgICAgIGNvbnN0IGVuZHNXaXRoRG91YmxlTmV3bGluZSA9ICRmcm9tLnBhcmVudC50ZXh0Q29udGVudC5lbmRzV2l0aCgnXFxuXFxuJylcblxuICAgICAgICBpZiAoIWlzQXRFbmQgfHwgIWVuZHNXaXRoRG91YmxlTmV3bGluZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVkaXRvclxuICAgICAgICAgIC5jaGFpbigpXG4gICAgICAgICAgLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICAgICAgdHIuZGVsZXRlKCRmcm9tLnBvcyAtIDIsICRmcm9tLnBvcylcblxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5leGl0Q29kZSgpXG4gICAgICAgICAgLnJ1bigpXG4gICAgICB9LFxuXG4gICAgICAvLyBleGl0IG5vZGUgb24gYXJyb3cgZG93blxuICAgICAgQXJyb3dEb3duOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5leGl0T25BcnJvd0Rvd24pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvclxuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSBzdGF0ZVxuICAgICAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSB9ID0gc2VsZWN0aW9uXG5cbiAgICAgICAgaWYgKCFlbXB0eSB8fCAkZnJvbS5wYXJlbnQudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0F0RW5kID0gJGZyb20ucGFyZW50T2Zmc2V0ID09PSAkZnJvbS5wYXJlbnQubm9kZVNpemUgLSAyXG5cbiAgICAgICAgaWYgKCFpc0F0RW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhZnRlciA9ICRmcm9tLmFmdGVyKClcblxuICAgICAgICBpZiAoYWZ0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9kZUFmdGVyID0gZG9jLm5vZGVBdChhZnRlcilcblxuICAgICAgICBpZiAobm9kZUFmdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmV4aXRDb2RlKClcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBiYWNrdGlja0lucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHtcbiAgICAgICAgICBsYW5ndWFnZTogbWF0Y2hbMV0sXG4gICAgICAgIH0pLFxuICAgICAgfSksXG4gICAgICB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogdGlsZGVJbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7XG4gICAgICAgICAgbGFuZ3VhZ2U6IG1hdGNoWzFdLFxuICAgICAgICB9KSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIHRoaXMgcGx1Z2luIGNyZWF0ZXMgYSBjb2RlIGJsb2NrIGZvciBwYXN0ZWQgY29udGVudCBmcm9tIFZTIENvZGVcbiAgICAgIC8vIHdlIGNhbiBhbHNvIGRldGVjdCB0aGUgY29waWVkIGNvZGUgbGFuZ3VhZ2VcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NvZGVCbG9ja1ZTQ29kZUhhbmRsZXInKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVQYXN0ZTogKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LmNsaXBib2FyZERhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvbuKAmXQgY3JlYXRlIGEgbmV3IGNvZGUgYmxvY2sgd2l0aGluIGNvZGUgYmxvY2tzXG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0b3IuaXNBY3RpdmUodGhpcy50eXBlLm5hbWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJylcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZSA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndnNjb2RlLWVkaXRvci1kYXRhJylcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZURhdGEgPSB2c2NvZGUgPyBKU09OLnBhcnNlKHZzY29kZSkgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlID0gdnNjb2RlRGF0YT8ubW9kZVxuXG4gICAgICAgICAgICBpZiAoIXRleHQgfHwgIWxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB7IHRyIH0gPSB2aWV3LnN0YXRlXG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBjb2RlIGJsb2NrXG4gICAgICAgICAgICB0ci5yZXBsYWNlU2VsZWN0aW9uV2l0aCh0aGlzLnR5cGUuY3JlYXRlKHsgbGFuZ3VhZ2UgfSkpXG5cbiAgICAgICAgICAgIC8vIHB1dCBjdXJzb3IgaW5zaWRlIHRoZSBuZXdseSBjcmVhdGVkIGNvZGUgYmxvY2tcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoTWF0aC5tYXgoMCwgdHIuc2VsZWN0aW9uLmZyb20gLSAyKSkpKVxuXG4gICAgICAgICAgICAvLyBhZGQgdGV4dCB0byBjb2RlIGJsb2NrXG4gICAgICAgICAgICAvLyBzdHJpcCBjYXJyaWFnZSByZXR1cm4gY2hhcnMgZnJvbSB0ZXh0IHBhc3RlZCBhcyBjb2RlXG4gICAgICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci12aWV3L2NvbW1pdC9hNTBhNmJjY2ViNGNlNTJhYzhmY2M2MTYyNDg4ZDg4NzU2MTNhYWNkXG4gICAgICAgICAgICB0ci5pbnNlcnRUZXh0KHRleHQucmVwbGFjZSgvXFxyXFxuPy9nLCAnXFxuJykpXG5cbiAgICAgICAgICAgIC8vIHN0b3JlIG1ldGEgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciBvdGhlciBwbHVnaW5zIHRoYXQgZGVwZW5kcyBvbiB0aGUgcGFzdGUgZXZlbnRcbiAgICAgICAgICAgIC8vIGxpa2UgdGhlIHBhc3RlIHJ1bGUgcGx1Z2luXG4gICAgICAgICAgICB0ci5zZXRNZXRhKCdwYXN0ZScsIHRydWUpXG5cbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpXG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGNvbnN0IERvY3VtZW50ID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiAnZG9jJyxcbiAgdG9wTm9kZTogdHJ1ZSxcbiAgY29udGVudDogJ2Jsb2NrKycsXG59KVxuIiwgImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IGRyb3BQb2ludCB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbi8qKlxuQ3JlYXRlIGEgcGx1Z2luIHRoYXQsIHdoZW4gYWRkZWQgdG8gYSBQcm9zZU1pcnJvciBpbnN0YW5jZSxcbmNhdXNlcyBhIGRlY29yYXRpb24gdG8gc2hvdyB1cCBhdCB0aGUgZHJvcCBwb3NpdGlvbiB3aGVuIHNvbWV0aGluZ1xuaXMgZHJhZ2dlZCBvdmVyIHRoZSBlZGl0b3IuXG5cbk5vZGVzIG1heSBhZGQgYSBgZGlzYWJsZURyb3BDdXJzb3JgIHByb3BlcnR5IHRvIHRoZWlyIHNwZWMgdG9cbmNvbnRyb2wgdGhlIHNob3dpbmcgb2YgYSBkcm9wIGN1cnNvciBpbnNpZGUgdGhlbS4gVGhpcyBtYXkgYmUgYVxuYm9vbGVhbiBvciBhIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgdmlldyBhbmQgYVxucG9zaXRpb24sIGFuZCBzaG91bGQgcmV0dXJuIGEgYm9vbGVhbi5cbiovXG5mdW5jdGlvbiBkcm9wQ3Vyc29yKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgdmlldyhlZGl0b3JWaWV3KSB7IHJldHVybiBuZXcgRHJvcEN1cnNvclZpZXcoZWRpdG9yVmlldywgb3B0aW9ucyk7IH1cbiAgICB9KTtcbn1cbmNsYXNzIERyb3BDdXJzb3JWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihlZGl0b3JWaWV3LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5lZGl0b3JWaWV3ID0gZWRpdG9yVmlldztcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy53aWR0aCA9IChfYSA9IG9wdGlvbnMud2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IChvcHRpb25zLmNvbG9yIHx8IFwiYmxhY2tcIik7XG4gICAgICAgIHRoaXMuY2xhc3MgPSBvcHRpb25zLmNsYXNzO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gW1wiZHJhZ292ZXJcIiwgXCJkcmFnZW5kXCIsIFwiZHJvcFwiLCBcImRyYWdsZWF2ZVwiXS5tYXAobmFtZSA9PiB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlciA9IChlKSA9PiB7IHRoaXNbbmFtZV0oZSk7IH07XG4gICAgICAgICAgICBlZGl0b3JWaWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgaGFuZGxlciB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5mb3JFYWNoKCh7IG5hbWUsIGhhbmRsZXIgfSkgPT4gdGhpcy5lZGl0b3JWaWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpKTtcbiAgICB9XG4gICAgdXBkYXRlKGVkaXRvclZpZXcsIHByZXZTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3JQb3MgIT0gbnVsbCAmJiBwcmV2U3RhdGUuZG9jICE9IGVkaXRvclZpZXcuc3RhdGUuZG9jKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJzb3JQb3MgPiBlZGl0b3JWaWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IobnVsbCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q3Vyc29yKHBvcykge1xuICAgICAgICBpZiAocG9zID09IHRoaXMuY3Vyc29yUG9zKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IHBvcztcbiAgICAgICAgaWYgKHBvcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlT3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZU92ZXJsYXkoKSB7XG4gICAgICAgIGxldCAkcG9zID0gdGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYy5yZXNvbHZlKHRoaXMuY3Vyc29yUG9zKTtcbiAgICAgICAgbGV0IGlzQmxvY2sgPSAhJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCwgcmVjdDtcbiAgICAgICAgaWYgKGlzQmxvY2spIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmUsIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgICAgICBpZiAoYmVmb3JlIHx8IGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmVkaXRvclZpZXcubm9kZURPTSh0aGlzLmN1cnNvclBvcyAtIChiZWZvcmUgPyBiZWZvcmUubm9kZVNpemUgOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvcCA9IGJlZm9yZSA/IG5vZGVSZWN0LmJvdHRvbSA6IG5vZGVSZWN0LnRvcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZSAmJiBhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9ICh0b3AgKyB0aGlzLmVkaXRvclZpZXcubm9kZURPTSh0aGlzLmN1cnNvclBvcykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IG5vZGVSZWN0LmxlZnQsIHJpZ2h0OiBub2RlUmVjdC5yaWdodCwgdG9wOiB0b3AgLSB0aGlzLndpZHRoIC8gMiwgYm90dG9tOiB0b3AgKyB0aGlzLndpZHRoIC8gMiB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgICAgIGxldCBjb29yZHMgPSB0aGlzLmVkaXRvclZpZXcuY29vcmRzQXRQb3ModGhpcy5jdXJzb3JQb3MpO1xuICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogY29vcmRzLmxlZnQgLSB0aGlzLndpZHRoIC8gMiwgcmlnaHQ6IGNvb3Jkcy5sZWZ0ICsgdGhpcy53aWR0aCAvIDIsIHRvcDogY29vcmRzLnRvcCwgYm90dG9tOiBjb29yZHMuYm90dG9tIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuZWRpdG9yVmlldy5kb20ub2Zmc2V0UGFyZW50O1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xhc3MpXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3M7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGFic29sdXRlOyB6LWluZGV4OiA1MDsgcG9pbnRlci1ldmVudHM6IG5vbmU7XCI7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwicHJvc2VtaXJyb3ItZHJvcGN1cnNvci1ibG9ja1wiLCBpc0Jsb2NrKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJwcm9zZW1pcnJvci1kcm9wY3Vyc29yLWlubGluZVwiLCAhaXNCbG9jayk7XG4gICAgICAgIGxldCBwYXJlbnRMZWZ0LCBwYXJlbnRUb3A7XG4gICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudCA9PSBkb2N1bWVudC5ib2R5ICYmIGdldENvbXB1dGVkU3R5bGUocGFyZW50KS5wb3NpdGlvbiA9PSBcInN0YXRpY1wiKSB7XG4gICAgICAgICAgICBwYXJlbnRMZWZ0ID0gLXBhZ2VYT2Zmc2V0O1xuICAgICAgICAgICAgcGFyZW50VG9wID0gLXBhZ2VZT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBwYXJlbnRMZWZ0ID0gcmVjdC5sZWZ0IC0gcGFyZW50LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICBwYXJlbnRUb3AgPSByZWN0LnRvcCAtIHBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSAocmVjdC5sZWZ0IC0gcGFyZW50TGVmdCkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS50b3AgPSAocmVjdC50b3AgLSBwYXJlbnRUb3ApICsgXCJweFwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSAocmVjdC5yaWdodCAtIHJlY3QubGVmdCkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAocmVjdC5ib3R0b20gLSByZWN0LnRvcCkgKyBcInB4XCI7XG4gICAgfVxuICAgIHNjaGVkdWxlUmVtb3ZhbCh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2V0Q3Vyc29yKG51bGwpLCB0aW1lb3V0KTtcbiAgICB9XG4gICAgZHJhZ292ZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVkaXRvclZpZXcuZWRpdGFibGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmVkaXRvclZpZXcucG9zQXRDb29yZHMoeyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfSk7XG4gICAgICAgIGxldCBub2RlID0gcG9zICYmIHBvcy5pbnNpZGUgPj0gMCAmJiB0aGlzLmVkaXRvclZpZXcuc3RhdGUuZG9jLm5vZGVBdChwb3MuaW5zaWRlKTtcbiAgICAgICAgbGV0IGRpc2FibGVEcm9wQ3Vyc29yID0gbm9kZSAmJiBub2RlLnR5cGUuc3BlYy5kaXNhYmxlRHJvcEN1cnNvcjtcbiAgICAgICAgbGV0IGRpc2FibGVkID0gdHlwZW9mIGRpc2FibGVEcm9wQ3Vyc29yID09IFwiZnVuY3Rpb25cIiA/IGRpc2FibGVEcm9wQ3Vyc29yKHRoaXMuZWRpdG9yVmlldywgcG9zLCBldmVudCkgOiBkaXNhYmxlRHJvcEN1cnNvcjtcbiAgICAgICAgaWYgKHBvcyAmJiAhZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBwb3MucG9zO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdG9yVmlldy5kcmFnZ2luZyAmJiB0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcuc2xpY2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnQgPSBkcm9wUG9pbnQodGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYywgdGFyZ2V0LCB0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcuc2xpY2UpO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBwb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKHRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVtb3ZhbCg1MDAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmFnZW5kKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVtb3ZhbCgyMCk7XG4gICAgfVxuICAgIGRyb3AoKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZW1vdmFsKDIwKTtcbiAgICB9XG4gICAgZHJhZ2xlYXZlKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT0gdGhpcy5lZGl0b3JWaWV3LmRvbSB8fCAhdGhpcy5lZGl0b3JWaWV3LmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKG51bGwpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgZHJvcEN1cnNvciB9O1xuIiwgImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IGRyb3BDdXJzb3IgfSBmcm9tICdAdGlwdGFwL3BtL2Ryb3BjdXJzb3InXG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcGN1cnNvck9wdGlvbnMge1xuICBjb2xvcjogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICB3aWR0aDogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICBjbGFzczogc3RyaW5nIHwgdW5kZWZpbmVkLFxufVxuXG5leHBvcnQgY29uc3QgRHJvcGN1cnNvciA9IEV4dGVuc2lvbi5jcmVhdGU8RHJvcGN1cnNvck9wdGlvbnM+KHtcbiAgbmFtZTogJ2Ryb3BDdXJzb3InLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgY2xhc3M6IHVuZGVmaW5lZCxcbiAgICB9XG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBkcm9wQ3Vyc29yKHRoaXMub3B0aW9ucyksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBrZXlkb3duSGFuZGxlciB9IGZyb20gJ3Byb3NlbWlycm9yLWtleW1hcCc7XG5pbXBvcnQgeyBTZWxlY3Rpb24sIE5vZGVTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24sIFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IFNsaWNlLCBGcmFnbWVudCB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IERlY29yYXRpb25TZXQsIERlY29yYXRpb24gfSBmcm9tICdwcm9zZW1pcnJvci12aWV3JztcblxuLyoqXG5HYXAgY3Vyc29yIHNlbGVjdGlvbnMgYXJlIHJlcHJlc2VudGVkIHVzaW5nIHRoaXMgY2xhc3MuIEl0c1xuYCRhbmNob3JgIGFuZCBgJGhlYWRgIHByb3BlcnRpZXMgYm90aCBwb2ludCBhdCB0aGUgY3Vyc29yIHBvc2l0aW9uLlxuKi9cbmNsYXNzIEdhcEN1cnNvciBleHRlbmRzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZ2FwIGN1cnNvci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRwb3MpIHtcbiAgICAgICAgc3VwZXIoJHBvcywgJHBvcyk7XG4gICAgfVxuICAgIG1hcChkb2MsIG1hcHBpbmcpIHtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICAgICAgcmV0dXJuIEdhcEN1cnNvci52YWxpZCgkcG9zKSA/IG5ldyBHYXBDdXJzb3IoJHBvcykgOiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG4gICAgY29udGVudCgpIHsgcmV0dXJuIFNsaWNlLmVtcHR5OyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgR2FwQ3Vyc29yICYmIG90aGVyLmhlYWQgPT0gdGhpcy5oZWFkO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZ2FwY3Vyc29yXCIsIHBvczogdGhpcy5oZWFkIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEdhcEN1cnNvci5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBHYXBDdXJzb3IoZG9jLnJlc29sdmUoanNvbi5wb3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXRCb29rbWFyaygpIHsgcmV0dXJuIG5ldyBHYXBCb29rbWFyayh0aGlzLmFuY2hvcik7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyB2YWxpZCgkcG9zKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudC5pc1RleHRibG9jayB8fCAhY2xvc2VkQmVmb3JlKCRwb3MpIHx8ICFjbG9zZWRBZnRlcigkcG9zKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG92ZXJyaWRlID0gcGFyZW50LnR5cGUuc3BlYy5hbGxvd0dhcEN1cnNvcjtcbiAgICAgICAgaWYgKG92ZXJyaWRlICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGU7XG4gICAgICAgIGxldCBkZWZsdCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgkcG9zLmluZGV4KCkpLmRlZmF1bHRUeXBlO1xuICAgICAgICByZXR1cm4gZGVmbHQgJiYgZGVmbHQuaXNUZXh0YmxvY2s7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZpbmRHYXBDdXJzb3JGcm9tKCRwb3MsIGRpciwgbXVzdE1vdmUgPSBmYWxzZSkge1xuICAgICAgICBzZWFyY2g6IGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICghbXVzdE1vdmUgJiYgR2FwQ3Vyc29yLnZhbGlkKCRwb3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zO1xuICAgICAgICAgICAgbGV0IHBvcyA9ICRwb3MucG9zLCBuZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFNjYW4gdXAgZnJvbSB0aGlzIHBvc2l0aW9uXG4gICAgICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDs7IGQtLSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDAgPyAkcG9zLmluZGV4QWZ0ZXIoZCkgPCBwYXJlbnQuY2hpbGRDb3VudCA6ICRwb3MuaW5kZXgoZCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBwYXJlbnQuY2hpbGQoZGlyID4gMCA/ICRwb3MuaW5kZXhBZnRlcihkKSA6ICRwb3MuaW5kZXgoZCkgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zICs9IGRpcjtcbiAgICAgICAgICAgICAgICBsZXQgJGN1ciA9ICRwb3MuZG9jLnJlc29sdmUocG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoR2FwQ3Vyc29yLnZhbGlkKCRjdXIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFuZCB0aGVuIGRvd24gaW50byB0aGUgbmV4dCBub2RlXG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGluc2lkZSA9IGRpciA+IDAgPyBuZXh0LmZpcnN0Q2hpbGQgOiBuZXh0Lmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBpZiAoIWluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5pc0F0b20gJiYgIW5leHQuaXNUZXh0ICYmICFOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShuZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHBvcyA9ICRwb3MuZG9jLnJlc29sdmUocG9zICsgbmV4dC5ub2RlU2l6ZSAqIGRpcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgc2VhcmNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0ID0gaW5zaWRlO1xuICAgICAgICAgICAgICAgIHBvcyArPSBkaXI7XG4gICAgICAgICAgICAgICAgbGV0ICRjdXIgPSAkcG9zLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKEdhcEN1cnNvci52YWxpZCgkY3VyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbkdhcEN1cnNvci5wcm90b3R5cGUudmlzaWJsZSA9IGZhbHNlO1xuR2FwQ3Vyc29yLmZpbmRGcm9tID0gR2FwQ3Vyc29yLmZpbmRHYXBDdXJzb3JGcm9tO1xuU2VsZWN0aW9uLmpzb25JRChcImdhcGN1cnNvclwiLCBHYXBDdXJzb3IpO1xuY2xhc3MgR2FwQm9va21hcmsge1xuICAgIGNvbnN0cnVjdG9yKHBvcykge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHYXBCb29rbWFyayhtYXBwaW5nLm1hcCh0aGlzLnBvcykpO1xuICAgIH1cbiAgICByZXNvbHZlKGRvYykge1xuICAgICAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHRoaXMucG9zKTtcbiAgICAgICAgcmV0dXJuIEdhcEN1cnNvci52YWxpZCgkcG9zKSA/IG5ldyBHYXBDdXJzb3IoJHBvcykgOiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zZWRCZWZvcmUoJHBvcykge1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4KGQpLCBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG4gICAgICAgIC8vIEF0IHRoZSBzdGFydCBvZiB0aGlzIHBhcmVudCwgbG9vayBhdCBuZXh0IG9uZVxuICAgICAgICBpZiAoaW5kZXggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIGlmIHRoZSBub2RlIGJlZm9yZSAob3IgaXRzIGZpcnN0IGFuY2VzdG9yKSBpcyBjbG9zZWRcbiAgICAgICAgZm9yIChsZXQgYmVmb3JlID0gcGFyZW50LmNoaWxkKGluZGV4IC0gMSk7OyBiZWZvcmUgPSBiZWZvcmUubGFzdENoaWxkKSB7XG4gICAgICAgICAgICBpZiAoKGJlZm9yZS5jaGlsZENvdW50ID09IDAgJiYgIWJlZm9yZS5pbmxpbmVDb250ZW50KSB8fCBiZWZvcmUuaXNBdG9tIHx8IGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGJlZm9yZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIaXQgc3RhcnQgb2YgZG9jdW1lbnRcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNsb3NlZEFmdGVyKCRwb3MpIHtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGQpLCBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG4gICAgICAgIGlmIChpbmRleCA9PSBwYXJlbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgYWZ0ZXIgPSBwYXJlbnQuY2hpbGQoaW5kZXgpOzsgYWZ0ZXIgPSBhZnRlci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBpZiAoKGFmdGVyLmNoaWxkQ291bnQgPT0gMCAmJiAhYWZ0ZXIuaW5saW5lQ29udGVudCkgfHwgYWZ0ZXIuaXNBdG9tIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuQ3JlYXRlIGEgZ2FwIGN1cnNvciBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgdGhpcyB3aWxsIGNhcHR1cmUgY2xpY2tzXG5uZWFyIGFuZCBhcnJvdy1rZXktbW90aW9uIHBhc3QgcGxhY2VzIHRoYXQgZG9uJ3QgaGF2ZSBhIG5vcm1hbGx5XG5zZWxlY3RhYmxlIHBvc2l0aW9uIG5lYXJieSwgYW5kIGNyZWF0ZSBhIGdhcCBjdXJzb3Igc2VsZWN0aW9uIGZvclxudGhlbS4gVGhlIGN1cnNvciBpcyBkcmF3biBhcyBhbiBlbGVtZW50IHdpdGggY2xhc3NcbmBQcm9zZU1pcnJvci1nYXBjdXJzb3JgLiBZb3UgY2FuIGVpdGhlciBpbmNsdWRlXG5gc3R5bGUvZ2FwY3Vyc29yLmNzc2AgZnJvbSB0aGUgcGFja2FnZSdzIGRpcmVjdG9yeSBvciBhZGQgeW91ciBvd25cbnN0eWxlcyB0byBtYWtlIGl0IHZpc2libGUuXG4qL1xuZnVuY3Rpb24gZ2FwQ3Vyc29yKCkge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiBkcmF3R2FwQ3Vyc29yLFxuICAgICAgICAgICAgY3JlYXRlU2VsZWN0aW9uQmV0d2VlbihfdmlldywgJGFuY2hvciwgJGhlYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGFuY2hvci5wb3MgPT0gJGhlYWQucG9zICYmIEdhcEN1cnNvci52YWxpZCgkaGVhZCkgPyBuZXcgR2FwQ3Vyc29yKCRoZWFkKSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlQ2xpY2ssXG4gICAgICAgICAgICBoYW5kbGVLZXlEb3duLFxuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7IGJlZm9yZWlucHV0OiBiZWZvcmVpbnB1dCB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGhhbmRsZUtleURvd24gPSBrZXlkb3duSGFuZGxlcih7XG4gICAgXCJBcnJvd0xlZnRcIjogYXJyb3coXCJob3JpelwiLCAtMSksXG4gICAgXCJBcnJvd1JpZ2h0XCI6IGFycm93KFwiaG9yaXpcIiwgMSksXG4gICAgXCJBcnJvd1VwXCI6IGFycm93KFwidmVydFwiLCAtMSksXG4gICAgXCJBcnJvd0Rvd25cIjogYXJyb3coXCJ2ZXJ0XCIsIDEpXG59KTtcbmZ1bmN0aW9uIGFycm93KGF4aXMsIGRpcikge1xuICAgIGNvbnN0IGRpclN0ciA9IGF4aXMgPT0gXCJ2ZXJ0XCIgPyAoZGlyID4gMCA/IFwiZG93blwiIDogXCJ1cFwiKSA6IChkaXIgPiAwID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gICAgICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCAkc3RhcnQgPSBkaXIgPiAwID8gc2VsLiR0byA6IHNlbC4kZnJvbSwgbXVzdE1vdmUgPSBzZWwuZW1wdHk7XG4gICAgICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyU3RyKSB8fCAkc3RhcnQuZGVwdGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgJHN0YXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUoZGlyID4gMCA/ICRzdGFydC5hZnRlcigpIDogJHN0YXJ0LmJlZm9yZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgJGZvdW5kID0gR2FwQ3Vyc29yLmZpbmRHYXBDdXJzb3JGcm9tKCRzdGFydCwgZGlyLCBtdXN0TW92ZSk7XG4gICAgICAgIGlmICghJGZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEdhcEN1cnNvcigkZm91bmQpKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBoYW5kbGVDbGljayh2aWV3LCBwb3MsIGV2ZW50KSB7XG4gICAgaWYgKCF2aWV3IHx8ICF2aWV3LmVkaXRhYmxlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCFHYXBDdXJzb3IudmFsaWQoJHBvcykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2xpY2tQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgbGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZIH0pO1xuICAgIGlmIChjbGlja1BvcyAmJiBjbGlja1Bvcy5pbnNpZGUgPiAtMSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSh2aWV3LnN0YXRlLmRvYy5ub2RlQXQoY2xpY2tQb3MuaW5zaWRlKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBHYXBDdXJzb3IoJHBvcykpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIFRoaXMgaXMgYSBoYWNrIHRoYXQsIHdoZW4gYSBjb21wb3NpdGlvbiBzdGFydHMgd2hpbGUgYSBnYXAgY3Vyc29yXG4vLyBpcyBhY3RpdmUsIHF1aWNrbHkgY3JlYXRlcyBhbiBpbmxpbmUgY29udGV4dCBmb3IgdGhlIGNvbXBvc2l0aW9uIHRvXG4vLyBoYXBwZW4gaW4sIHRvIGF2b2lkIGl0IGJlaW5nIGFib3J0ZWQgYnkgdGhlIERPTSBzZWxlY3Rpb24gYmVpbmdcbi8vIG1vdmVkIGludG8gYSB2YWxpZCBwb3NpdGlvbi5cbmZ1bmN0aW9uIGJlZm9yZWlucHV0KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmlucHV0VHlwZSAhPSBcImluc2VydENvbXBvc2l0aW9uVGV4dFwiIHx8ICEodmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBHYXBDdXJzb3IpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgJGZyb20gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBpbnNlcnQgPSAkZnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXgoKSkuZmluZFdyYXBwaW5nKHZpZXcuc3RhdGUuc2NoZW1hLm5vZGVzLnRleHQpO1xuICAgIGlmICghaW5zZXJ0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGZyYWcgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gaW5zZXJ0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBmcmFnID0gRnJhZ21lbnQuZnJvbShpbnNlcnRbaV0uY3JlYXRlQW5kRmlsbChudWxsLCBmcmFnKSk7XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5yZXBsYWNlKCRmcm9tLnBvcywgJGZyb20ucG9zLCBuZXcgU2xpY2UoZnJhZywgMCwgMCkpO1xuICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoJGZyb20ucG9zICsgMSkpKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkcmF3R2FwQ3Vyc29yKHN0YXRlKSB7XG4gICAgaWYgKCEoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgR2FwQ3Vyc29yKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIG5vZGUuY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1nYXBjdXJzb3JcIjtcbiAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoc3RhdGUuZG9jLCBbRGVjb3JhdGlvbi53aWRnZXQoc3RhdGUuc2VsZWN0aW9uLmhlYWQsIG5vZGUsIHsga2V5OiBcImdhcGN1cnNvclwiIH0pXSk7XG59XG5cbmV4cG9ydCB7IEdhcEN1cnNvciwgZ2FwQ3Vyc29yIH07XG4iLCAiaW1wb3J0IHtcbiAgY2FsbE9yUmV0dXJuLFxuICBFeHRlbnNpb24sXG4gIGdldEV4dGVuc2lvbkZpZWxkLFxuICBQYXJlbnRDb25maWcsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IGdhcEN1cnNvciB9IGZyb20gJ0B0aXB0YXAvcG0vZ2FwY3Vyc29yJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+IHtcbiAgICAvKipcbiAgICAgKiBBbGxvdyBnYXAgY3Vyc29yXG4gICAgICovXG4gICAgYWxsb3dHYXBDdXJzb3I/OlxuICAgICAgfCBib29sZWFuXG4gICAgICB8IG51bGxcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgIG5hbWU6IHN0cmluZyxcbiAgICAgICAgb3B0aW9uczogT3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogU3RvcmFnZSxcbiAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zPj5bJ2FsbG93R2FwQ3Vyc29yJ10sXG4gICAgICB9KSA9PiBib29sZWFuIHwgbnVsbCksXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEdhcGN1cnNvciA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnZ2FwQ3Vyc29yJyxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGdhcEN1cnNvcigpLFxuICAgIF1cbiAgfSxcblxuICBleHRlbmROb2RlU2NoZW1hKGV4dGVuc2lvbikge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFsbG93R2FwQ3Vyc29yOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWxsb3dHYXBDdXJzb3InLCBjb250ZXh0KSkgPz8gbnVsbCxcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBIYXJkQnJlYWtPcHRpb25zIHtcbiAga2VlcE1hcmtzOiBib29sZWFuLFxuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGhhcmRCcmVhazoge1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYSBoYXJkIGJyZWFrXG4gICAgICAgKi9cbiAgICAgIHNldEhhcmRCcmVhazogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEhhcmRCcmVhayA9IE5vZGUuY3JlYXRlPEhhcmRCcmVha09wdGlvbnM+KHtcbiAgbmFtZTogJ2hhcmRCcmVhaycsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2VlcE1hcmtzOiB0cnVlLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBpbmxpbmU6IHRydWUsXG5cbiAgZ3JvdXA6ICdpbmxpbmUnLFxuXG4gIHNlbGVjdGFibGU6IGZhbHNlLFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB0YWc6ICdicicgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydicicsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKV1cbiAgfSxcblxuICByZW5kZXJUZXh0KCkge1xuICAgIHJldHVybiAnXFxuJ1xuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRIYXJkQnJlYWs6ICgpID0+ICh7XG4gICAgICAgIGNvbW1hbmRzLFxuICAgICAgICBjaGFpbixcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGVkaXRvcixcbiAgICAgIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmZpcnN0KFtcbiAgICAgICAgICAoKSA9PiBjb21tYW5kcy5leGl0Q29kZSgpLFxuICAgICAgICAgICgpID0+IGNvbW1hbmRzLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZVxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLiRmcm9tLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB7IGtlZXBNYXJrcyB9ID0gdGhpcy5vcHRpb25zXG4gICAgICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXJcbiAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3NcbiAgICAgICAgICAgICAgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxuXG4gICAgICAgICAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgICAgICAgICAuaW5zZXJ0Q29udGVudCh7IHR5cGU6IHRoaXMubmFtZSB9KVxuICAgICAgICAgICAgICAuY29tbWFuZCgoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaCAmJiBtYXJrcyAmJiBrZWVwTWFya3MpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrc1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSlcblxuICAgICAgICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAucnVuKClcbiAgICAgICAgICB9KSxcbiAgICAgICAgXSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLUVudGVyJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0SGFyZEJyZWFrKCksXG4gICAgICAnU2hpZnQtRW50ZXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRIYXJkQnJlYWsoKSxcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSwgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IHR5cGUgTGV2ZWwgPSAxIHwgMiB8IDMgfCA0IHwgNSB8IDZcblxuZXhwb3J0IGludGVyZmFjZSBIZWFkaW5nT3B0aW9ucyB7XG4gIGxldmVsczogTGV2ZWxbXSxcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBoZWFkaW5nOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIGhlYWRpbmcgbm9kZVxuICAgICAgICovXG4gICAgICBzZXRIZWFkaW5nOiAoYXR0cmlidXRlczogeyBsZXZlbDogTGV2ZWwgfSkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgaGVhZGluZyBub2RlXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUhlYWRpbmc6IChhdHRyaWJ1dGVzOiB7IGxldmVsOiBMZXZlbCB9KSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgSGVhZGluZyA9IE5vZGUuY3JlYXRlPEhlYWRpbmdPcHRpb25zPih7XG4gIG5hbWU6ICdoZWFkaW5nJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbHM6IFsxLCAyLCAzLCA0LCA1LCA2XSxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgY29udGVudDogJ2lubGluZSonLFxuXG4gIGdyb3VwOiAnYmxvY2snLFxuXG4gIGRlZmluaW5nOiB0cnVlLFxuXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsOiB7XG4gICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgIHJlbmRlcmVkOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVsc1xuICAgICAgLm1hcCgobGV2ZWw6IExldmVsKSA9PiAoe1xuICAgICAgICB0YWc6IGBoJHtsZXZlbH1gLFxuICAgICAgICBhdHRyczogeyBsZXZlbCB9LFxuICAgICAgfSkpXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICBjb25zdCBoYXNMZXZlbCA9IHRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMobm9kZS5hdHRycy5sZXZlbClcbiAgICBjb25zdCBsZXZlbCA9IGhhc0xldmVsXG4gICAgICA/IG5vZGUuYXR0cnMubGV2ZWxcbiAgICAgIDogdGhpcy5vcHRpb25zLmxldmVsc1swXVxuXG4gICAgcmV0dXJuIFtgaCR7bGV2ZWx9YCwgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRIZWFkaW5nOiBhdHRyaWJ1dGVzID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubGV2ZWxzLmluY2x1ZGVzKGF0dHJpYnV0ZXMubGV2ZWwpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpXG4gICAgICB9LFxuICAgICAgdG9nZ2xlSGVhZGluZzogYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmxldmVscy5pbmNsdWRlcyhhdHRyaWJ1dGVzLmxldmVsKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU5vZGUodGhpcy5uYW1lLCAncGFyYWdyYXBoJywgYXR0cmlidXRlcylcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGV2ZWxzLnJlZHVjZSgoaXRlbXMsIGxldmVsKSA9PiAoe1xuICAgICAgLi4uaXRlbXMsXG4gICAgICAuLi57XG4gICAgICAgIFtgTW9kLUFsdC0ke2xldmVsfWBdOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVIZWFkaW5nKHsgbGV2ZWwgfSksXG4gICAgICB9LFxuICAgIH0pLCB7fSlcbiAgfSxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGV2ZWxzLm1hcChsZXZlbCA9PiB7XG4gICAgICByZXR1cm4gdGV4dGJsb2NrVHlwZUlucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IG5ldyBSZWdFeHAoYF4oI3sxLCR7bGV2ZWx9fSlcXFxccyRgKSxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgbGV2ZWwsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG59KVxuIiwgInZhciBHT09EX0xFQUZfU0laRSA9IDIwMDtcblxuLy8gOjogY2xhc3M8VD4gQSByb3BlIHNlcXVlbmNlIGlzIGEgcGVyc2lzdGVudCBzZXF1ZW5jZSBkYXRhIHN0cnVjdHVyZVxuLy8gdGhhdCBzdXBwb3J0cyBhcHBlbmRpbmcsIHByZXBlbmRpbmcsIGFuZCBzbGljaW5nIHdpdGhvdXQgZG9pbmcgYVxuLy8gZnVsbCBjb3B5LiBJdCBpcyByZXByZXNlbnRlZCBhcyBhIG1vc3RseS1iYWxhbmNlZCB0cmVlLlxudmFyIFJvcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uIFJvcGVTZXF1ZW5jZSAoKSB7fTtcblxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQgKG90aGVyKSB7XG4gIGlmICghb3RoZXIubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgb3RoZXIgPSBSb3BlU2VxdWVuY2UuZnJvbShvdGhlcik7XG5cbiAgcmV0dXJuICghdGhpcy5sZW5ndGggJiYgb3RoZXIpIHx8XG4gICAgKG90aGVyLmxlbmd0aCA8IEdPT0RfTEVBRl9TSVpFICYmIHRoaXMubGVhZkFwcGVuZChvdGhlcikpIHx8XG4gICAgKHRoaXMubGVuZ3RoIDwgR09PRF9MRUFGX1NJWkUgJiYgb3RoZXIubGVhZlByZXBlbmQodGhpcykpIHx8XG4gICAgdGhpcy5hcHBlbmRJbm5lcihvdGhlcilcbn07XG5cbi8vIDo6ICh1bmlvbjxbVF0sIFJvcGVTZXF1ZW5jZTxUPj4pIFx1MjE5MiBSb3BlU2VxdWVuY2U8VD5cbi8vIFByZXBlbmQgYW4gYXJyYXkgb3Igb3RoZXIgcm9wZSB0byB0aGlzIG9uZSwgcmV0dXJuaW5nIGEgbmV3IHJvcGUuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBwcmVwZW5kIChvdGhlcikge1xuICBpZiAoIW90aGVyLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gIHJldHVybiBSb3BlU2VxdWVuY2UuZnJvbShvdGhlcikuYXBwZW5kKHRoaXMpXG59O1xuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmFwcGVuZElubmVyID0gZnVuY3Rpb24gYXBwZW5kSW5uZXIgKG90aGVyKSB7XG4gIHJldHVybiBuZXcgQXBwZW5kKHRoaXMsIG90aGVyKVxufTtcblxuLy8gOjogKD9udW1iZXIsID9udW1iZXIpIFx1MjE5MiBSb3BlU2VxdWVuY2U8VD5cbi8vIENyZWF0ZSBhIHJvcGUgcmVwZXNlbnRpbmcgYSBzdWItc2VxdWVuY2Ugb2YgdGhpcyByb3BlLlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZnJvbSA+PSB0bykgeyByZXR1cm4gUm9wZVNlcXVlbmNlLmVtcHR5IH1cbiAgcmV0dXJuIHRoaXMuc2xpY2VJbm5lcihNYXRoLm1heCgwLCBmcm9tKSwgTWF0aC5taW4odGhpcy5sZW5ndGgsIHRvKSlcbn07XG5cbi8vIDo6IChudW1iZXIpIFx1MjE5MiBUXG4vLyBSZXRyaWV2ZSB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gZnJvbSB0aGlzIHJvcGUuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gdW5kZWZpbmVkIH1cbiAgcmV0dXJuIHRoaXMuZ2V0SW5uZXIoaSlcbn07XG5cbi8vIDo6ICgoZWxlbWVudDogVCwgaW5kZXg6IG51bWJlcikgXHUyMTkyID9ib29sLCA/bnVtYmVyLCA/bnVtYmVyKVxuLy8gQ2FsbCB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBiZXR3ZWVuIHRoZSBnaXZlblxuLy8gaW5kaWNlcy4gVGhpcyB0ZW5kcyB0byBiZSBtb3JlIGVmZmljaWVudCB0aGFuIGxvb3Bpbmcgb3ZlciB0aGVcbi8vIGluZGljZXMgYW5kIGNhbGxpbmcgYGdldGAsIGJlY2F1c2UgaXQgZG9lc24ndCBoYXZlIHRvIGRlc2NlbmQgdGhlXG4vLyB0cmVlIGZvciBldmVyeSBlbGVtZW50LlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaCAoZiwgZnJvbSwgdG8pIHtcbiAgICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuICAgIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGZyb20gPD0gdG8pXG4gICAgeyB0aGlzLmZvckVhY2hJbm5lcihmLCBmcm9tLCB0bywgMCk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5mb3JFYWNoSW52ZXJ0ZWRJbm5lcihmLCBmcm9tLCB0bywgMCk7IH1cbn07XG5cbi8vIDo6ICgoZWxlbWVudDogVCwgaW5kZXg6IG51bWJlcikgXHUyMTkyIFUsID9udW1iZXIsID9udW1iZXIpIFx1MjE5MiBbVV1cbi8vIE1hcCB0aGUgZ2l2ZW4gZnVuY3Rpb25zIG92ZXIgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3BlLCBwcm9kdWNpbmdcbi8vIGEgZmxhdCBhcnJheS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChmLCBmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLmxlbmd0aDtcblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWx0LCBpKSB7IHJldHVybiByZXN1bHQucHVzaChmKGVsdCwgaSkpOyB9LCBmcm9tLCB0byk7XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8vIDo6ICg/dW5pb248W1RdLCBSb3BlU2VxdWVuY2U8VD4+KSBcdTIxOTIgUm9wZVNlcXVlbmNlPFQ+XG4vLyBDcmVhdGUgYSByb3BlIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gYXJyYXksIG9yIHJldHVybiB0aGUgcm9wZVxuLy8gaXRzZWxmIGlmIGEgcm9wZSB3YXMgZ2l2ZW4uXG5Sb3BlU2VxdWVuY2UuZnJvbSA9IGZ1bmN0aW9uIGZyb20gKHZhbHVlcykge1xuICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUm9wZVNlcXVlbmNlKSB7IHJldHVybiB2YWx1ZXMgfVxuICByZXR1cm4gdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggPyBuZXcgTGVhZih2YWx1ZXMpIDogUm9wZVNlcXVlbmNlLmVtcHR5XG59O1xuXG52YXIgTGVhZiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFJvcGVTZXF1ZW5jZSkge1xuICBmdW5jdGlvbiBMZWFmKHZhbHVlcykge1xuICAgIFJvcGVTZXF1ZW5jZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICB9XG5cbiAgaWYgKCBSb3BlU2VxdWVuY2UgKSBMZWFmLl9fcHJvdG9fXyA9IFJvcGVTZXF1ZW5jZTtcbiAgTGVhZi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSb3BlU2VxdWVuY2UgJiYgUm9wZVNlcXVlbmNlLnByb3RvdHlwZSApO1xuICBMZWFmLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExlYWY7XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgbGVuZ3RoOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGRlcHRoOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uIGZsYXR0ZW4gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1xuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLnNsaWNlSW5uZXIgPSBmdW5jdGlvbiBzbGljZUlubmVyIChmcm9tLCB0bykge1xuICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHJldHVybiBuZXcgTGVhZih0aGlzLnZhbHVlcy5zbGljZShmcm9tLCB0bykpXG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZ2V0SW5uZXIgPSBmdW5jdGlvbiBnZXRJbm5lciAoaSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1tpXVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmZvckVhY2hJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgZm9yICh2YXIgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgeyBpZiAoZih0aGlzLnZhbHVlc1tpXSwgc3RhcnQgKyBpKSA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmZvckVhY2hJbnZlcnRlZElubmVyID0gZnVuY3Rpb24gZm9yRWFjaEludmVydGVkSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIGZvciAodmFyIGkgPSBmcm9tIC0gMTsgaSA+PSB0bzsgaS0tKVxuICAgICAgeyBpZiAoZih0aGlzLnZhbHVlc1tpXSwgc3RhcnQgKyBpKSA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmxlYWZBcHBlbmQgPSBmdW5jdGlvbiBsZWFmQXBwZW5kIChvdGhlcikge1xuICAgIGlmICh0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCA8PSBHT09EX0xFQUZfU0laRSlcbiAgICAgIHsgcmV0dXJuIG5ldyBMZWFmKHRoaXMudmFsdWVzLmNvbmNhdChvdGhlci5mbGF0dGVuKCkpKSB9XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUubGVhZlByZXBlbmQgPSBmdW5jdGlvbiBsZWFmUHJlcGVuZCAob3RoZXIpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggKyBvdGhlci5sZW5ndGggPD0gR09PRF9MRUFGX1NJWkUpXG4gICAgICB7IHJldHVybiBuZXcgTGVhZihvdGhlci5mbGF0dGVuKCkuY29uY2F0KHRoaXMudmFsdWVzKSkgfVxuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5sZW5ndGguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmRlcHRoLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTGVhZi5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4gIHJldHVybiBMZWFmO1xufShSb3BlU2VxdWVuY2UpKTtcblxuLy8gOjogUm9wZVNlcXVlbmNlXG4vLyBUaGUgZW1wdHkgcm9wZSBzZXF1ZW5jZS5cblJvcGVTZXF1ZW5jZS5lbXB0eSA9IG5ldyBMZWFmKFtdKTtcblxudmFyIEFwcGVuZCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFJvcGVTZXF1ZW5jZSkge1xuICBmdW5jdGlvbiBBcHBlbmQobGVmdCwgcmlnaHQpIHtcbiAgICBSb3BlU2VxdWVuY2UuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB0aGlzLmxlbmd0aCA9IGxlZnQubGVuZ3RoICsgcmlnaHQubGVuZ3RoO1xuICAgIHRoaXMuZGVwdGggPSBNYXRoLm1heChsZWZ0LmRlcHRoLCByaWdodC5kZXB0aCkgKyAxO1xuICB9XG5cbiAgaWYgKCBSb3BlU2VxdWVuY2UgKSBBcHBlbmQuX19wcm90b19fID0gUm9wZVNlcXVlbmNlO1xuICBBcHBlbmQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUm9wZVNlcXVlbmNlICYmIFJvcGVTZXF1ZW5jZS5wcm90b3R5cGUgKTtcbiAgQXBwZW5kLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFwcGVuZDtcblxuICBBcHBlbmQucHJvdG90eXBlLmZsYXR0ZW4gPSBmdW5jdGlvbiBmbGF0dGVuICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0LmZsYXR0ZW4oKS5jb25jYXQodGhpcy5yaWdodC5mbGF0dGVuKCkpXG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5nZXRJbm5lciA9IGZ1bmN0aW9uIGdldElubmVyIChpKSB7XG4gICAgcmV0dXJuIGkgPCB0aGlzLmxlZnQubGVuZ3RoID8gdGhpcy5sZWZ0LmdldChpKSA6IHRoaXMucmlnaHQuZ2V0KGkgLSB0aGlzLmxlZnQubGVuZ3RoKVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZm9yRWFjaElubmVyID0gZnVuY3Rpb24gZm9yRWFjaElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICB2YXIgbGVmdExlbiA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgaWYgKGZyb20gPCBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMubGVmdC5mb3JFYWNoSW5uZXIoZiwgZnJvbSwgTWF0aC5taW4odG8sIGxlZnRMZW4pLCBzdGFydCkgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0byA+IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoSW5uZXIoZiwgTWF0aC5tYXgoZnJvbSAtIGxlZnRMZW4sIDApLCBNYXRoLm1pbih0aGlzLmxlbmd0aCwgdG8pIC0gbGVmdExlbiwgc3RhcnQgKyBsZWZ0TGVuKSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5mb3JFYWNoSW52ZXJ0ZWRJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbnZlcnRlZElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICB2YXIgbGVmdExlbiA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgaWYgKGZyb20gPiBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaEludmVydGVkSW5uZXIoZiwgZnJvbSAtIGxlZnRMZW4sIE1hdGgubWF4KHRvLCBsZWZ0TGVuKSAtIGxlZnRMZW4sIHN0YXJ0ICsgbGVmdExlbikgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0byA8IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hJbnZlcnRlZElubmVyKGYsIE1hdGgubWluKGZyb20sIGxlZnRMZW4pLCB0bywgc3RhcnQpID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLnNsaWNlSW5uZXIgPSBmdW5jdGlvbiBzbGljZUlubmVyIChmcm9tLCB0bykge1xuICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHZhciBsZWZ0TGVuID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICBpZiAodG8gPD0gbGVmdExlbikgeyByZXR1cm4gdGhpcy5sZWZ0LnNsaWNlKGZyb20sIHRvKSB9XG4gICAgaWYgKGZyb20gPj0gbGVmdExlbikgeyByZXR1cm4gdGhpcy5yaWdodC5zbGljZShmcm9tIC0gbGVmdExlbiwgdG8gLSBsZWZ0TGVuKSB9XG4gICAgcmV0dXJuIHRoaXMubGVmdC5zbGljZShmcm9tLCBsZWZ0TGVuKS5hcHBlbmQodGhpcy5yaWdodC5zbGljZSgwLCB0byAtIGxlZnRMZW4pKVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUubGVhZkFwcGVuZCA9IGZ1bmN0aW9uIGxlYWZBcHBlbmQgKG90aGVyKSB7XG4gICAgdmFyIGlubmVyID0gdGhpcy5yaWdodC5sZWFmQXBwZW5kKG90aGVyKTtcbiAgICBpZiAoaW5uZXIpIHsgcmV0dXJuIG5ldyBBcHBlbmQodGhpcy5sZWZ0LCBpbm5lcikgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUubGVhZlByZXBlbmQgPSBmdW5jdGlvbiBsZWFmUHJlcGVuZCAob3RoZXIpIHtcbiAgICB2YXIgaW5uZXIgPSB0aGlzLmxlZnQubGVhZlByZXBlbmQob3RoZXIpO1xuICAgIGlmIChpbm5lcikgeyByZXR1cm4gbmV3IEFwcGVuZChpbm5lciwgdGhpcy5yaWdodCkgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuYXBwZW5kSW5uZXIgPSBmdW5jdGlvbiBhcHBlbmRJbm5lciAob3RoZXIpIHtcbiAgICBpZiAodGhpcy5sZWZ0LmRlcHRoID49IE1hdGgubWF4KHRoaXMucmlnaHQuZGVwdGgsIG90aGVyLmRlcHRoKSArIDEpXG4gICAgICB7IHJldHVybiBuZXcgQXBwZW5kKHRoaXMubGVmdCwgbmV3IEFwcGVuZCh0aGlzLnJpZ2h0LCBvdGhlcikpIH1cbiAgICByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLCBvdGhlcilcbiAgfTtcblxuICByZXR1cm4gQXBwZW5kO1xufShSb3BlU2VxdWVuY2UpKTtcblxuZXhwb3J0IGRlZmF1bHQgUm9wZVNlcXVlbmNlO1xuIiwgImltcG9ydCBSb3BlU2VxdWVuY2UgZnJvbSAncm9wZS1zZXF1ZW5jZSc7XG5pbXBvcnQgeyBNYXBwaW5nIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IFBsdWdpbktleSwgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG4vLyBQcm9zZU1pcnJvcidzIGhpc3RvcnkgaXNuJ3Qgc2ltcGx5IGEgd2F5IHRvIHJvbGwgYmFjayB0byBhIHByZXZpb3VzXG4vLyBzdGF0ZSwgYmVjYXVzZSBQcm9zZU1pcnJvciBzdXBwb3J0cyBhcHBseWluZyBjaGFuZ2VzIHdpdGhvdXQgYWRkaW5nXG4vLyB0aGVtIHRvIHRoZSBoaXN0b3J5IChmb3IgZXhhbXBsZSBkdXJpbmcgY29sbGFib3JhdGlvbikuXG4vL1xuLy8gVG8gdGhpcyBlbmQsIGVhY2ggJ0JyYW5jaCcgKG9uZSBmb3IgdGhlIHVuZG8gaGlzdG9yeSBhbmQgb25lIGZvclxuLy8gdGhlIHJlZG8gaGlzdG9yeSkga2VlcHMgYW4gYXJyYXkgb2YgJ0l0ZW1zJywgd2hpY2ggY2FuIG9wdGlvbmFsbHlcbi8vIGhvbGQgYSBzdGVwIChhbiBhY3R1YWwgdW5kb2FibGUgY2hhbmdlKSwgYW5kIGFsd2F5cyBob2xkIGEgcG9zaXRpb25cbi8vIG1hcCAod2hpY2ggaXMgbmVlZGVkIHRvIG1vdmUgY2hhbmdlcyBiZWxvdyB0aGVtIHRvIGFwcGx5IHRvIHRoZVxuLy8gY3VycmVudCBkb2N1bWVudCkuXG4vL1xuLy8gQW4gaXRlbSB0aGF0IGhhcyBib3RoIGEgc3RlcCBhbmQgYSBzZWxlY3Rpb24gYm9va21hcmsgaXMgdGhlIHN0YXJ0XG4vLyBvZiBhbiAnZXZlbnQnIFx1MjAxNCBhIGdyb3VwIG9mIGNoYW5nZXMgdGhhdCB3aWxsIGJlIHVuZG9uZSBvciByZWRvbmUgYXRcbi8vIG9uY2UuIChJdCBzdG9yZXMgb25seSB0aGUgYm9va21hcmssIHNpbmNlIHRoYXQgd2F5IHdlIGRvbid0IGhhdmUgdG9cbi8vIHByb3ZpZGUgYSBkb2N1bWVudCB1bnRpbCB0aGUgc2VsZWN0aW9uIGlzIGFjdHVhbGx5IGFwcGxpZWQsIHdoaWNoXG4vLyBpcyB1c2VmdWwgd2hlbiBjb21wcmVzc2luZy4pXG4vLyBVc2VkIHRvIHNjaGVkdWxlIGhpc3RvcnkgY29tcHJlc3Npb25cbmNvbnN0IG1heF9lbXB0eV9pdGVtcyA9IDUwMDtcbmNsYXNzIEJyYW5jaCB7XG4gICAgY29uc3RydWN0b3IoaXRlbXMsIGV2ZW50Q291bnQpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgICAgICB0aGlzLmV2ZW50Q291bnQgPSBldmVudENvdW50O1xuICAgIH1cbiAgICAvLyBQb3AgdGhlIGxhdGVzdCBldmVudCBvZmYgdGhlIGJyYW5jaCdzIGhpc3RvcnkgYW5kIGFwcGx5IGl0XG4gICAgLy8gdG8gYSBkb2N1bWVudCB0cmFuc2Zvcm0uXG4gICAgcG9wRXZlbnQoc3RhdGUsIHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgZm9yICg7OyBlbmQtLSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLml0ZW1zLmdldChlbmQgLSAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0LnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIC0tZW5kO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZW1hcCwgbWFwRnJvbTtcbiAgICAgICAgaWYgKHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgICAgIHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoZW5kLCB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHN0YXRlLnRyO1xuICAgICAgICBsZXQgc2VsZWN0aW9uLCByZW1haW5pbmc7XG4gICAgICAgIGxldCBhZGRBZnRlciA9IFtdLCBhZGRCZWZvcmUgPSBbXTtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAgPSB0aGlzLnJlbWFwcGluZyhlbmQsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgYWRkQmVmb3JlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbWFwKSB7XG4gICAgICAgICAgICAgICAgYWRkQmVmb3JlLnB1c2gobmV3IEl0ZW0oaXRlbS5tYXApKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IGl0ZW0uc3RlcC5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpLCBtYXA7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXAgJiYgdHJhbnNmb3JtLm1heWJlU3RlcChzdGVwKS5kb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwID0gdHJhbnNmb3JtLm1hcHBpbmcubWFwc1t0cmFuc2Zvcm0ubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBhZGRBZnRlci5wdXNoKG5ldyBJdGVtKG1hcCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFkZEFmdGVyLmxlbmd0aCArIGFkZEJlZm9yZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgICAgICAgIGlmIChtYXApXG4gICAgICAgICAgICAgICAgICAgIHJlbWFwLmFwcGVuZE1hcChtYXAsIG1hcEZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLm1heWJlU3RlcChpdGVtLnN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gcmVtYXAgPyBpdGVtLnNlbGVjdGlvbi5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpIDogaXRlbS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nID0gbmV3IEJyYW5jaCh0aGlzLml0ZW1zLnNsaWNlKDAsIGVuZCkuYXBwZW5kKGFkZEJlZm9yZS5yZXZlcnNlKCkuY29uY2F0KGFkZEFmdGVyKSksIHRoaXMuZXZlbnRDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5pdGVtcy5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4geyByZW1haW5pbmc6IHJlbWFpbmluZywgdHJhbnNmb3JtLCBzZWxlY3Rpb246IHNlbGVjdGlvbiB9O1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBuZXcgYnJhbmNoIHdpdGggdGhlIGdpdmVuIHRyYW5zZm9ybSBhZGRlZC5cbiAgICBhZGRUcmFuc2Zvcm0odHJhbnNmb3JtLCBzZWxlY3Rpb24sIGhpc3RPcHRpb25zLCBwcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgIGxldCBuZXdJdGVtcyA9IFtdLCBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICAgICAgICBsZXQgb2xkSXRlbXMgPSB0aGlzLml0ZW1zLCBsYXN0SXRlbSA9ICFwcmVzZXJ2ZUl0ZW1zICYmIG9sZEl0ZW1zLmxlbmd0aCA/IG9sZEl0ZW1zLmdldChvbGRJdGVtcy5sZW5ndGggLSAxKSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNmb3JtLnN0ZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RlcCA9IHRyYW5zZm9ybS5zdGVwc1tpXS5pbnZlcnQodHJhbnNmb3JtLmRvY3NbaV0pO1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBuZXcgSXRlbSh0cmFuc2Zvcm0ubWFwcGluZy5tYXBzW2ldLCBzdGVwLCBzZWxlY3Rpb24pLCBtZXJnZWQ7XG4gICAgICAgICAgICBpZiAobWVyZ2VkID0gbGFzdEl0ZW0gJiYgbGFzdEl0ZW0ubWVyZ2UoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gbWVyZ2VkO1xuICAgICAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgICAgICBuZXdJdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9sZEl0ZW1zID0gb2xkSXRlbXMuc2xpY2UoMCwgb2xkSXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGV2ZW50Q291bnQrKztcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZXNlcnZlSXRlbXMpXG4gICAgICAgICAgICAgICAgbGFzdEl0ZW0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdmVyZmxvdyA9IGV2ZW50Q291bnQgLSBoaXN0T3B0aW9ucy5kZXB0aDtcbiAgICAgICAgaWYgKG92ZXJmbG93ID4gREVQVEhfT1ZFUkZMT1cpIHtcbiAgICAgICAgICAgIG9sZEl0ZW1zID0gY3V0T2ZmRXZlbnRzKG9sZEl0ZW1zLCBvdmVyZmxvdyk7XG4gICAgICAgICAgICBldmVudENvdW50IC09IG92ZXJmbG93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKG9sZEl0ZW1zLmFwcGVuZChuZXdJdGVtcyksIGV2ZW50Q291bnQpO1xuICAgIH1cbiAgICByZW1hcHBpbmcoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IG1hcHMgPSBuZXcgTWFwcGluZztcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgbWlycm9yUG9zID0gaXRlbS5taXJyb3JPZmZzZXQgIT0gbnVsbCAmJiBpIC0gaXRlbS5taXJyb3JPZmZzZXQgPj0gZnJvbVxuICAgICAgICAgICAgICAgID8gbWFwcy5tYXBzLmxlbmd0aCAtIGl0ZW0ubWlycm9yT2Zmc2V0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbWFwcy5hcHBlbmRNYXAoaXRlbS5tYXAsIG1pcnJvclBvcyk7XG4gICAgICAgIH0sIGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIG1hcHM7XG4gICAgfVxuICAgIGFkZE1hcHMoYXJyYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKHRoaXMuaXRlbXMuYXBwZW5kKGFycmF5Lm1hcChtYXAgPT4gbmV3IEl0ZW0obWFwKSkpLCB0aGlzLmV2ZW50Q291bnQpO1xuICAgIH1cbiAgICAvLyBXaGVuIHRoZSBjb2xsYWIgbW9kdWxlIHJlY2VpdmVzIHJlbW90ZSBjaGFuZ2VzLCB0aGUgaGlzdG9yeSBoYXNcbiAgICAvLyB0byBrbm93IGFib3V0IHRob3NlLCBzbyB0aGF0IGl0IGNhbiBhZGp1c3QgdGhlIHN0ZXBzIHRoYXQgd2VyZVxuICAgIC8vIHJlYmFzZWQgb24gdG9wIG9mIHRoZSByZW1vdGUgY2hhbmdlcywgYW5kIGluY2x1ZGUgdGhlIHBvc2l0aW9uXG4gICAgLy8gbWFwcyBmb3IgdGhlIHJlbW90ZSBjaGFuZ2VzIGluIGl0cyBhcnJheSBvZiBpdGVtcy5cbiAgICByZWJhc2VkKHJlYmFzZWRUcmFuc2Zvcm0sIHJlYmFzZWRDb3VudCkge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnRDb3VudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcmViYXNlZEl0ZW1zID0gW10sIHN0YXJ0ID0gTWF0aC5tYXgoMCwgdGhpcy5pdGVtcy5sZW5ndGggLSByZWJhc2VkQ291bnQpO1xuICAgICAgICBsZXQgbWFwcGluZyA9IHJlYmFzZWRUcmFuc2Zvcm0ubWFwcGluZztcbiAgICAgICAgbGV0IG5ld1VudGlsID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwcy5sZW5ndGg7XG4gICAgICAgIGxldCBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7IGlmIChpdGVtLnNlbGVjdGlvbilcbiAgICAgICAgICAgIGV2ZW50Q291bnQtLTsgfSwgc3RhcnQpO1xuICAgICAgICBsZXQgaVJlYmFzZWQgPSByZWJhc2VkQ291bnQ7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLmdldE1pcnJvcigtLWlSZWJhc2VkKTtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBuZXdVbnRpbCA9IE1hdGgubWluKG5ld1VudGlsLCBwb3MpO1xuICAgICAgICAgICAgbGV0IG1hcCA9IG1hcHBpbmcubWFwc1twb3NdO1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwc1twb3NdLmludmVydChyZWJhc2VkVHJhbnNmb3JtLmRvY3NbcG9zXSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGl0ZW0uc2VsZWN0aW9uICYmIGl0ZW0uc2VsZWN0aW9uLm1hcChtYXBwaW5nLnNsaWNlKGlSZWJhc2VkICsgMSwgcG9zKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRDb3VudCsrO1xuICAgICAgICAgICAgICAgIHJlYmFzZWRJdGVtcy5wdXNoKG5ldyBJdGVtKG1hcCwgc3RlcCwgc2VsZWN0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWJhc2VkSXRlbXMucHVzaChuZXcgSXRlbShtYXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3RhcnQpO1xuICAgICAgICBsZXQgbmV3TWFwcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gcmViYXNlZENvdW50OyBpIDwgbmV3VW50aWw7IGkrKylcbiAgICAgICAgICAgIG5ld01hcHMucHVzaChuZXcgSXRlbShtYXBwaW5nLm1hcHNbaV0pKTtcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5pdGVtcy5zbGljZSgwLCBzdGFydCkuYXBwZW5kKG5ld01hcHMpLmFwcGVuZChyZWJhc2VkSXRlbXMpO1xuICAgICAgICBsZXQgYnJhbmNoID0gbmV3IEJyYW5jaChpdGVtcywgZXZlbnRDb3VudCk7XG4gICAgICAgIGlmIChicmFuY2guZW1wdHlJdGVtQ291bnQoKSA+IG1heF9lbXB0eV9pdGVtcylcbiAgICAgICAgICAgIGJyYW5jaCA9IGJyYW5jaC5jb21wcmVzcyh0aGlzLml0ZW1zLmxlbmd0aCAtIHJlYmFzZWRJdGVtcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgIH1cbiAgICBlbXB0eUl0ZW1Db3VudCgpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4geyBpZiAoIWl0ZW0uc3RlcClcbiAgICAgICAgICAgIGNvdW50Kys7IH0pO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIC8vIENvbXByZXNzaW5nIGEgYnJhbmNoIG1lYW5zIHJld3JpdGluZyBpdCB0byBwdXNoIHRoZSBhaXIgKG1hcC1vbmx5XG4gICAgLy8gaXRlbXMpIG91dC4gRHVyaW5nIGNvbGxhYm9yYXRpb24sIHRoZXNlIG5hdHVyYWxseSBhY2N1bXVsYXRlXG4gICAgLy8gYmVjYXVzZSBlYWNoIHJlbW90ZSBjaGFuZ2UgYWRkcyBvbmUuIFRoZSBgdXB0b2AgYXJndW1lbnQgaXMgdXNlZFxuICAgIC8vIHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGl0ZW1zIGJlbG93IGEgZ2l2ZW4gbGV2ZWwgYXJlIGNvbXByZXNzZWQsXG4gICAgLy8gYmVjYXVzZSBgcmViYXNlZGAgcmVsaWVzIG9uIGEgY2xlYW4sIHVudG91Y2hlZCBzZXQgb2YgaXRlbXMgaW5cbiAgICAvLyBvcmRlciB0byBhc3NvY2lhdGUgb2xkIGl0ZW1zIHdpdGggcmViYXNlZCBzdGVwcy5cbiAgICBjb21wcmVzcyh1cHRvID0gdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoMCwgdXB0byksIG1hcEZyb20gPSByZW1hcC5tYXBzLmxlbmd0aDtcbiAgICAgICAgbGV0IGl0ZW1zID0gW10sIGV2ZW50cyA9IDA7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPj0gdXB0bykge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBldmVudHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gaXRlbS5zdGVwLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSksIG1hcCA9IHN0ZXAgJiYgc3RlcC5nZXRNYXAoKTtcbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgaWYgKG1hcClcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAuYXBwZW5kTWFwKG1hcCwgbWFwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGl0ZW0uc2VsZWN0aW9uICYmIGl0ZW0uc2VsZWN0aW9uLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMrKztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0l0ZW0gPSBuZXcgSXRlbShtYXAuaW52ZXJ0KCksIHN0ZXAsIHNlbGVjdGlvbiksIG1lcmdlZCwgbGFzdCA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXJnZWQgPSBpdGVtcy5sZW5ndGggJiYgaXRlbXNbbGFzdF0ubWVyZ2UobmV3SXRlbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tsYXN0XSA9IG1lcmdlZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChuZXdJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLm1hcCkge1xuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5pdGVtcy5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4gbmV3IEJyYW5jaChSb3BlU2VxdWVuY2UuZnJvbShpdGVtcy5yZXZlcnNlKCkpLCBldmVudHMpO1xuICAgIH1cbn1cbkJyYW5jaC5lbXB0eSA9IG5ldyBCcmFuY2goUm9wZVNlcXVlbmNlLmVtcHR5LCAwKTtcbmZ1bmN0aW9uIGN1dE9mZkV2ZW50cyhpdGVtcywgbikge1xuICAgIGxldCBjdXRQb2ludDtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChpdGVtLnNlbGVjdGlvbiAmJiAobi0tID09IDApKSB7XG4gICAgICAgICAgICBjdXRQb2ludCA9IGk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXRlbXMuc2xpY2UoY3V0UG9pbnQpO1xufVxuY2xhc3MgSXRlbSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIChmb3J3YXJkKSBzdGVwIG1hcCBmb3IgdGhpcyBpdGVtLlxuICAgIG1hcCwgXG4gICAgLy8gVGhlIGludmVydGVkIHN0ZXBcbiAgICBzdGVwLCBcbiAgICAvLyBJZiB0aGlzIGlzIG5vbi1udWxsLCB0aGlzIGl0ZW0gaXMgdGhlIHN0YXJ0IG9mIGEgZ3JvdXAsIGFuZFxuICAgIC8vIHRoaXMgc2VsZWN0aW9uIGlzIHRoZSBzdGFydGluZyBzZWxlY3Rpb24gZm9yIHRoZSBncm91cCAodGhlIG9uZVxuICAgIC8vIHRoYXQgd2FzIGFjdGl2ZSBiZWZvcmUgdGhlIGZpcnN0IHN0ZXAgd2FzIGFwcGxpZWQpXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvLyBJZiB0aGlzIGl0ZW0gaXMgdGhlIGludmVyc2Ugb2YgYSBwcmV2aW91cyBtYXBwaW5nIG9uIHRoZSBzdGFjayxcbiAgICAvLyB0aGlzIHBvaW50cyBhdCB0aGUgaW52ZXJzZSdzIG9mZnNldFxuICAgIG1pcnJvck9mZnNldCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5zdGVwID0gc3RlcDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMubWlycm9yT2Zmc2V0ID0gbWlycm9yT2Zmc2V0O1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zdGVwICYmIG90aGVyLnN0ZXAgJiYgIW90aGVyLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IHN0ZXAgPSBvdGhlci5zdGVwLm1lcmdlKHRoaXMuc3RlcCk7XG4gICAgICAgICAgICBpZiAoc3RlcClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEl0ZW0oc3RlcC5nZXRNYXAoKS5pbnZlcnQoKSwgc3RlcCwgdGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gVGhlIHZhbHVlIG9mIHRoZSBzdGF0ZSBmaWVsZCB0aGF0IHRyYWNrcyB1bmRvL3JlZG8gaGlzdG9yeSBmb3IgdGhhdFxuLy8gc3RhdGUuIFdpbGwgYmUgc3RvcmVkIGluIHRoZSBwbHVnaW4gc3RhdGUgd2hlbiB0aGUgaGlzdG9yeSBwbHVnaW5cbi8vIGlzIGFjdGl2ZS5cbmNsYXNzIEhpc3RvcnlTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoZG9uZSwgdW5kb25lLCBwcmV2UmFuZ2VzLCBwcmV2VGltZSwgcHJldkNvbXBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IGRvbmU7XG4gICAgICAgIHRoaXMudW5kb25lID0gdW5kb25lO1xuICAgICAgICB0aGlzLnByZXZSYW5nZXMgPSBwcmV2UmFuZ2VzO1xuICAgICAgICB0aGlzLnByZXZUaW1lID0gcHJldlRpbWU7XG4gICAgICAgIHRoaXMucHJldkNvbXBvc2l0aW9uID0gcHJldkNvbXBvc2l0aW9uO1xuICAgIH1cbn1cbmNvbnN0IERFUFRIX09WRVJGTE9XID0gMjA7XG4vLyBSZWNvcmQgYSB0cmFuc2Zvcm1hdGlvbiBpbiB1bmRvIGhpc3RvcnkuXG5mdW5jdGlvbiBhcHBseVRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCB0ciwgb3B0aW9ucykge1xuICAgIGxldCBoaXN0b3J5VHIgPSB0ci5nZXRNZXRhKGhpc3RvcnlLZXkpLCByZWJhc2VkO1xuICAgIGlmIChoaXN0b3J5VHIpXG4gICAgICAgIHJldHVybiBoaXN0b3J5VHIuaGlzdG9yeVN0YXRlO1xuICAgIGlmICh0ci5nZXRNZXRhKGNsb3NlSGlzdG9yeUtleSkpXG4gICAgICAgIGhpc3RvcnkgPSBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUsIG51bGwsIDAsIC0xKTtcbiAgICBsZXQgYXBwZW5kZWQgPSB0ci5nZXRNZXRhKFwiYXBwZW5kZWRUcmFuc2FjdGlvblwiKTtcbiAgICBpZiAodHIuc3RlcHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIGhpc3Rvcnk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFwcGVuZGVkICYmIGFwcGVuZGVkLmdldE1ldGEoaGlzdG9yeUtleSkpIHtcbiAgICAgICAgaWYgKGFwcGVuZGVkLmdldE1ldGEoaGlzdG9yeUtleSkucmVkbylcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIHVuZGVmaW5lZCwgb3B0aW9ucywgbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpKSwgaGlzdG9yeS51bmRvbmUsIHJhbmdlc0Zvcih0ci5tYXBwaW5nLm1hcHNbdHIuc3RlcHMubGVuZ3RoIC0gMV0pLCBoaXN0b3J5LnByZXZUaW1lLCBoaXN0b3J5LnByZXZDb21wb3NpdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUuYWRkVHJhbnNmb3JtKHRyLCB1bmRlZmluZWQsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksIG51bGwsIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHIuZ2V0TWV0YShcImFkZFRvSGlzdG9yeVwiKSAhPT0gZmFsc2UgJiYgIShhcHBlbmRlZCAmJiBhcHBlbmRlZC5nZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIpID09PSBmYWxzZSkpIHtcbiAgICAgICAgLy8gR3JvdXAgdHJhbnNmb3JtcyB0aGF0IG9jY3VyIGluIHF1aWNrIHN1Y2Nlc3Npb24gaW50byBvbmUgZXZlbnQuXG4gICAgICAgIGxldCBjb21wb3NpdGlvbiA9IHRyLmdldE1ldGEoXCJjb21wb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IG5ld0dyb3VwID0gaGlzdG9yeS5wcmV2VGltZSA9PSAwIHx8XG4gICAgICAgICAgICAoIWFwcGVuZGVkICYmIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uICE9IGNvbXBvc2l0aW9uICYmXG4gICAgICAgICAgICAgICAgKGhpc3RvcnkucHJldlRpbWUgPCAodHIudGltZSB8fCAwKSAtIG9wdGlvbnMubmV3R3JvdXBEZWxheSB8fCAhaXNBZGphY2VudFRvKHRyLCBoaXN0b3J5LnByZXZSYW5nZXMpKSk7XG4gICAgICAgIGxldCBwcmV2UmFuZ2VzID0gYXBwZW5kZWQgPyBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSA6IHJhbmdlc0Zvcih0ci5tYXBwaW5nLm1hcHNbdHIuc3RlcHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUuYWRkVHJhbnNmb3JtKHRyLCBuZXdHcm91cCA/IHN0YXRlLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpIDogdW5kZWZpbmVkLCBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLCBCcmFuY2guZW1wdHksIHByZXZSYW5nZXMsIHRyLnRpbWUsIGNvbXBvc2l0aW9uID09IG51bGwgPyBoaXN0b3J5LnByZXZDb21wb3NpdGlvbiA6IGNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmViYXNlZCA9IHRyLmdldE1ldGEoXCJyZWJhc2VkXCIpKSB7XG4gICAgICAgIC8vIFVzZWQgYnkgdGhlIGNvbGxhYiBtb2R1bGUgdG8gdGVsbCB0aGUgaGlzdG9yeSB0aGF0IHNvbWUgb2YgaXRzXG4gICAgICAgIC8vIGNvbnRlbnQgaGFzIGJlZW4gcmViYXNlZC5cbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLnJlYmFzZWQodHIsIHJlYmFzZWQpLCBoaXN0b3J5LnVuZG9uZS5yZWJhc2VkKHRyLCByZWJhc2VkKSwgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRNYXBzKHRyLm1hcHBpbmcubWFwcyksIGhpc3RvcnkudW5kb25lLmFkZE1hcHModHIubWFwcGluZy5tYXBzKSwgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0FkamFjZW50VG8odHJhbnNmb3JtLCBwcmV2UmFuZ2VzKSB7XG4gICAgaWYgKCFwcmV2UmFuZ2VzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF0cmFuc2Zvcm0uZG9jQ2hhbmdlZClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGFkamFjZW50ID0gZmFsc2U7XG4gICAgdHJhbnNmb3JtLm1hcHBpbmcubWFwc1swXS5mb3JFYWNoKChzdGFydCwgZW5kKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldlJhbmdlcy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIGlmIChzdGFydCA8PSBwcmV2UmFuZ2VzW2kgKyAxXSAmJiBlbmQgPj0gcHJldlJhbmdlc1tpXSlcbiAgICAgICAgICAgICAgICBhZGphY2VudCA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFkamFjZW50O1xufVxuZnVuY3Rpb24gcmFuZ2VzRm9yKG1hcCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBtYXAuZm9yRWFjaCgoX2Zyb20sIF90bywgZnJvbSwgdG8pID0+IHJlc3VsdC5wdXNoKGZyb20sIHRvKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcFJhbmdlcyhyYW5nZXMsIG1hcHBpbmcpIHtcbiAgICBpZiAoIXJhbmdlcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAocmFuZ2VzW2ldLCAxKSwgdG8gPSBtYXBwaW5nLm1hcChyYW5nZXNbaSArIDFdLCAtMSk7XG4gICAgICAgIGlmIChmcm9tIDw9IHRvKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbSwgdG8pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQXBwbHkgdGhlIGxhdGVzdCBldmVudCBmcm9tIG9uZSBicmFuY2ggdG8gdGhlIGRvY3VtZW50IGFuZCBzaGlmdCB0aGUgZXZlbnRcbi8vIG9udG8gdGhlIG90aGVyIGJyYW5jaC5cbmZ1bmN0aW9uIGhpc3RUcmFuc2FjdGlvbihoaXN0b3J5LCBzdGF0ZSwgZGlzcGF0Y2gsIHJlZG8pIHtcbiAgICBsZXQgcHJlc2VydmVJdGVtcyA9IG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKTtcbiAgICBsZXQgaGlzdE9wdGlvbnMgPSBoaXN0b3J5S2V5LmdldChzdGF0ZSkuc3BlYy5jb25maWc7XG4gICAgbGV0IHBvcCA9IChyZWRvID8gaGlzdG9yeS51bmRvbmUgOiBoaXN0b3J5LmRvbmUpLnBvcEV2ZW50KHN0YXRlLCBwcmVzZXJ2ZUl0ZW1zKTtcbiAgICBpZiAoIXBvcClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBzZWxlY3Rpb24gPSBwb3Auc2VsZWN0aW9uLnJlc29sdmUocG9wLnRyYW5zZm9ybS5kb2MpO1xuICAgIGxldCBhZGRlZCA9IChyZWRvID8gaGlzdG9yeS5kb25lIDogaGlzdG9yeS51bmRvbmUpLmFkZFRyYW5zZm9ybShwb3AudHJhbnNmb3JtLCBzdGF0ZS5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKSwgaGlzdE9wdGlvbnMsIHByZXNlcnZlSXRlbXMpO1xuICAgIGxldCBuZXdIaXN0ID0gbmV3IEhpc3RvcnlTdGF0ZShyZWRvID8gYWRkZWQgOiBwb3AucmVtYWluaW5nLCByZWRvID8gcG9wLnJlbWFpbmluZyA6IGFkZGVkLCBudWxsLCAwLCAtMSk7XG4gICAgZGlzcGF0Y2gocG9wLnRyYW5zZm9ybS5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKS5zZXRNZXRhKGhpc3RvcnlLZXksIHsgcmVkbywgaGlzdG9yeVN0YXRlOiBuZXdIaXN0IH0pLnNjcm9sbEludG9WaWV3KCkpO1xufVxubGV0IGNhY2hlZFByZXNlcnZlSXRlbXMgPSBmYWxzZSwgY2FjaGVkUHJlc2VydmVJdGVtc1BsdWdpbnMgPSBudWxsO1xuLy8gQ2hlY2sgd2hldGhlciBhbnkgcGx1Z2luIGluIHRoZSBnaXZlbiBzdGF0ZSBoYXMgYVxuLy8gYGhpc3RvcnlQcmVzZXJ2ZUl0ZW1zYCBwcm9wZXJ0eSBpbiBpdHMgc3BlYywgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0XG4vLyBwcmVzZXJ2ZSBzdGVwcyBleGFjdGx5IGFzIHRoZXkgY2FtZSBpbiwgc28gdGhhdCB0aGV5IGNhbiBiZVxuLy8gcmViYXNlZC5cbmZ1bmN0aW9uIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSB7XG4gICAgbGV0IHBsdWdpbnMgPSBzdGF0ZS5wbHVnaW5zO1xuICAgIGlmIChjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyAhPSBwbHVnaW5zKSB7XG4gICAgICAgIGNhY2hlZFByZXNlcnZlSXRlbXMgPSBmYWxzZTtcbiAgICAgICAgY2FjaGVkUHJlc2VydmVJdGVtc1BsdWdpbnMgPSBwbHVnaW5zO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAocGx1Z2luc1tpXS5zcGVjLmhpc3RvcnlQcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkUHJlc2VydmVJdGVtcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRQcmVzZXJ2ZUl0ZW1zO1xufVxuLyoqXG5TZXQgYSBmbGFnIG9uIHRoZSBnaXZlbiB0cmFuc2FjdGlvbiB0aGF0IHdpbGwgcHJldmVudCBmdXJ0aGVyIHN0ZXBzXG5mcm9tIGJlaW5nIGFwcGVuZGVkIHRvIGFuIGV4aXN0aW5nIGhpc3RvcnkgZXZlbnQgKHNvIHRoYXQgdGhleVxucmVxdWlyZSBhIHNlcGFyYXRlIHVuZG8gY29tbWFuZCB0byB1bmRvKS5cbiovXG5mdW5jdGlvbiBjbG9zZUhpc3RvcnkodHIpIHtcbiAgICByZXR1cm4gdHIuc2V0TWV0YShjbG9zZUhpc3RvcnlLZXksIHRydWUpO1xufVxuY29uc3QgaGlzdG9yeUtleSA9IG5ldyBQbHVnaW5LZXkoXCJoaXN0b3J5XCIpO1xuY29uc3QgY2xvc2VIaXN0b3J5S2V5ID0gbmV3IFBsdWdpbktleShcImNsb3NlSGlzdG9yeVwiKTtcbi8qKlxuUmV0dXJucyBhIHBsdWdpbiB0aGF0IGVuYWJsZXMgdGhlIHVuZG8gaGlzdG9yeSBmb3IgYW4gZWRpdG9yLiBUaGVcbnBsdWdpbiB3aWxsIHRyYWNrIHVuZG8gYW5kIHJlZG8gc3RhY2tzLCB3aGljaCBjYW4gYmUgdXNlZCB3aXRoIHRoZVxuW2B1bmRvYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2hpc3RvcnkudW5kbykgYW5kIFtgcmVkb2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNoaXN0b3J5LnJlZG8pIGNvbW1hbmRzLlxuXG5Zb3UgY2FuIHNldCBhbiBgXCJhZGRUb0hpc3RvcnlcImAgW21ldGFkYXRhXG5wcm9wZXJ0eV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNldE1ldGEpIG9mIGBmYWxzZWAgb24gYSB0cmFuc2FjdGlvblxudG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJvbGxlZCBiYWNrIGJ5IHVuZG8uXG4qL1xuZnVuY3Rpb24gaGlzdG9yeShjb25maWcgPSB7fSkge1xuICAgIGNvbmZpZyA9IHsgZGVwdGg6IGNvbmZpZy5kZXB0aCB8fCAxMDAsXG4gICAgICAgIG5ld0dyb3VwRGVsYXk6IGNvbmZpZy5uZXdHcm91cERlbGF5IHx8IDUwMCB9O1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBoaXN0b3J5S2V5LFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShCcmFuY2guZW1wdHksIEJyYW5jaC5lbXB0eSwgbnVsbCwgMCwgLTEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcGx5KHRyLCBoaXN0LCBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseVRyYW5zYWN0aW9uKGhpc3QsIHN0YXRlLCB0ciwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgYmVmb3JlaW5wdXQodmlldywgZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5wdXRUeXBlID0gZS5pbnB1dFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21tYW5kID0gaW5wdXRUeXBlID09IFwiaGlzdG9yeVVuZG9cIiA/IHVuZG8gOiBpbnB1dFR5cGUgPT0gXCJoaXN0b3J5UmVkb1wiID8gcmVkbyA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tbWFuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZCh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuQSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgdW5kb2VzIHRoZSBsYXN0IGNoYW5nZSwgaWYgYW55LlxuKi9cbmNvbnN0IHVuZG8gPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICBpZiAoIWhpc3QgfHwgaGlzdC5kb25lLmV2ZW50Q291bnQgPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgaGlzdFRyYW5zYWN0aW9uKGhpc3QsIHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgcmVkb2VzIHRoZSBsYXN0IHVuZG9uZSBjaGFuZ2UsIGlmIGFueS5cbiovXG5jb25zdCByZWRvID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgaWYgKCFoaXN0IHx8IGhpc3QudW5kb25lLmV2ZW50Q291bnQgPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgaGlzdFRyYW5zYWN0aW9uKGhpc3QsIHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5UaGUgYW1vdW50IG9mIHVuZG9hYmxlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5mdW5jdGlvbiB1bmRvRGVwdGgoc3RhdGUpIHtcbiAgICBsZXQgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiBoaXN0ID8gaGlzdC5kb25lLmV2ZW50Q291bnQgOiAwO1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHJlZG9hYmxlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gcmVkb0RlcHRoKHN0YXRlKSB7XG4gICAgbGV0IGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gaGlzdCA/IGhpc3QudW5kb25lLmV2ZW50Q291bnQgOiAwO1xufVxuXG5leHBvcnQgeyBjbG9zZUhpc3RvcnksIGhpc3RvcnksIHJlZG8sIHJlZG9EZXB0aCwgdW5kbywgdW5kb0RlcHRoIH07XG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgaGlzdG9yeSwgcmVkbywgdW5kbyB9IGZyb20gJ0B0aXB0YXAvcG0vaGlzdG9yeSdcblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5T3B0aW9ucyB7XG4gIGRlcHRoOiBudW1iZXIsXG4gIG5ld0dyb3VwRGVsYXk6IG51bWJlcixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGhpc3Rvcnk6IHtcbiAgICAgIC8qKlxuICAgICAgICogVW5kbyByZWNlbnQgY2hhbmdlc1xuICAgICAgICovXG4gICAgICB1bmRvOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBSZWFwcGx5IHJldmVydGVkIGNoYW5nZXNcbiAgICAgICAqL1xuICAgICAgcmVkbzogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEhpc3RvcnkgPSBFeHRlbnNpb24uY3JlYXRlPEhpc3RvcnlPcHRpb25zPih7XG4gIG5hbWU6ICdoaXN0b3J5JyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZXB0aDogMTAwLFxuICAgICAgbmV3R3JvdXBEZWxheTogNTAwLFxuICAgIH1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdW5kbzogKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHVuZG8oc3RhdGUsIGRpc3BhdGNoKVxuICAgICAgfSxcbiAgICAgIHJlZG86ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIHJldHVybiByZWRvKHN0YXRlLCBkaXNwYXRjaClcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgaGlzdG9yeSh0aGlzLm9wdGlvbnMpLFxuICAgIF1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC16JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudW5kbygpLFxuICAgICAgJ01vZC1aJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudW5kbygpLFxuICAgICAgJ01vZC15JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxuICAgICAgJ01vZC1ZJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxuICAgICAgJ1NoaWZ0LU1vZC16JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxuICAgICAgJ1NoaWZ0LU1vZC1aJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxuXG4gICAgICAvLyBSdXNzaWFuIGtleWJvYXJkIGxheW91dHNcbiAgICAgICdNb2Qt0Y8nOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy51bmRvKCksXG4gICAgICAnU2hpZnQtTW9kLdGPJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCBub2RlSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgSG9yaXpvbnRhbFJ1bGVPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGhvcml6b250YWxSdWxlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhIGhvcml6b250YWwgcnVsZVxuICAgICAgICovXG4gICAgICBzZXRIb3Jpem9udGFsUnVsZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgSG9yaXpvbnRhbFJ1bGUgPSBOb2RlLmNyZWF0ZTxIb3Jpem9udGFsUnVsZU9wdGlvbnM+KHtcbiAgbmFtZTogJ2hvcml6b250YWxSdWxlJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIGdyb3VwOiAnYmxvY2snLFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiAnaHInIH1dXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydocicsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKV1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0SG9yaXpvbnRhbFJ1bGU6XG4gICAgICAgICgpID0+ICh7IGNoYWluLCBzdGF0ZSB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyAkdG86ICRvcmlnaW5UbyB9ID0gc3RhdGUuc2VsZWN0aW9uXG5cbiAgICAgICAgICBjb25zdCBjdXJyZW50Q2hhaW4gPSBjaGFpbigpXG5cbiAgICAgICAgICBpZiAoJG9yaWdpblRvLnBhcmVudE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgY3VycmVudENoYWluLmluc2VydENvbnRlbnRBdChNYXRoLm1heCgkb3JpZ2luVG8ucG9zIC0gMiwgMCksIHsgdHlwZTogdGhpcy5uYW1lIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRDaGFpbi5pbnNlcnRDb250ZW50KHsgdHlwZTogdGhpcy5uYW1lIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGN1cnJlbnRDaGFpblxuICAgICAgICAgICAgICAvLyBzZXQgY3Vyc29yIGFmdGVyIGhvcml6b250YWwgcnVsZVxuICAgICAgICAgICAgICAuY29tbWFuZCgoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgeyAkdG8gfSA9IHRyLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgY29uc3QgcG9zQWZ0ZXIgPSAkdG8uZW5kKClcblxuICAgICAgICAgICAgICAgICAgaWYgKCR0by5ub2RlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR0by5ub2RlQWZ0ZXIuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkdG8ucG9zICsgMSkpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHRvLm5vZGVBZnRlci5pc0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJHRvLnBvcykpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJHRvLnBvcykpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBub2RlIGFmdGVyIGhvcml6b250YWwgcnVsZSBpZiBpdOKAmXMgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9ICR0by5wYXJlbnQudHlwZS5jb250ZW50TWF0Y2guZGVmYXVsdFR5cGU/LmNyZWF0ZSgpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ci5pbnNlcnQocG9zQWZ0ZXIsIG5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9zQWZ0ZXIgKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnJ1bigpXG4gICAgICAgICAgKVxuICAgICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBub2RlSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogL14oPzotLS184oCULXxfX19cXHN8XFwqXFwqXFwqXFxzKSQvLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7XG4gIE1hcmssXG4gIG1hcmtJbnB1dFJ1bGUsXG4gIG1hcmtQYXN0ZVJ1bGUsXG4gIG1lcmdlQXR0cmlidXRlcyxcbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEl0YWxpY09wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGl0YWxpYzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYW4gaXRhbGljIG1hcmtcbiAgICAgICAqL1xuICAgICAgc2V0SXRhbGljOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYW4gaXRhbGljIG1hcmtcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlSXRhbGljOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBVbnNldCBhbiBpdGFsaWMgbWFya1xuICAgICAgICovXG4gICAgICB1bnNldEl0YWxpYzogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHN0YXJJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpcXCopKCg/OlteKl0rKSkoPzpcXCopKSQvXG5leHBvcnQgY29uc3Qgc3RhclBhc3RlUmVnZXggPSAvKD86XnxcXHMpKCg/OlxcKikoKD86W14qXSspKSg/OlxcKikpL2dcbmV4cG9ydCBjb25zdCB1bmRlcnNjb3JlSW5wdXRSZWdleCA9IC8oPzpefFxccykoKD86XykoKD86W15fXSspKSg/Ol8pKSQvXG5leHBvcnQgY29uc3QgdW5kZXJzY29yZVBhc3RlUmVnZXggPSAvKD86XnxcXHMpKCg/Ol8pKCg/OlteX10rKSkoPzpfKSkvZ1xuXG5leHBvcnQgY29uc3QgSXRhbGljID0gTWFyay5jcmVhdGU8SXRhbGljT3B0aW9ucz4oe1xuICBuYW1lOiAnaXRhbGljJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdlbScsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6ICdpJyxcbiAgICAgICAgZ2V0QXR0cnM6IG5vZGUgPT4gKG5vZGUgYXMgSFRNTEVsZW1lbnQpLnN0eWxlLmZvbnRTdHlsZSAhPT0gJ25vcm1hbCcgJiYgbnVsbCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiAnZm9udC1zdHlsZT1pdGFsaWMnLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydlbScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0SXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB0b2dnbGVJdGFsaWM6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHVuc2V0SXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtaSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUl0YWxpYygpLFxuICAgICAgJ01vZC1JJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlSXRhbGljKCksXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFySW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcblxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogc3RhclBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBMaXN0SXRlbU9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PixcbiAgYnVsbGV0TGlzdFR5cGVOYW1lOiBzdHJpbmdcbiAgb3JkZXJlZExpc3RUeXBlTmFtZTogc3RyaW5nXG59XG5cbmV4cG9ydCBjb25zdCBMaXN0SXRlbSA9IE5vZGUuY3JlYXRlPExpc3RJdGVtT3B0aW9ucz4oe1xuICBuYW1lOiAnbGlzdEl0ZW0nLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGJ1bGxldExpc3RUeXBlTmFtZTogJ2J1bGxldExpc3QnLFxuICAgICAgb3JkZXJlZExpc3RUeXBlTmFtZTogJ29yZGVyZWRMaXN0JyxcbiAgICB9XG4gIH0sXG5cbiAgY29udGVudDogJ3BhcmFncmFwaCBibG9jayonLFxuXG4gIGRlZmluaW5nOiB0cnVlLFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdsaScsXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ2xpJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBFbnRlcjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc3BsaXRMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgVGFiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zaW5rTGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgICdTaGlmdC1UYWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBMaXN0SXRlbU9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PixcbiAgYnVsbGV0TGlzdFR5cGVOYW1lOiBzdHJpbmdcbiAgb3JkZXJlZExpc3RUeXBlTmFtZTogc3RyaW5nXG59XG5cbmV4cG9ydCBjb25zdCBMaXN0SXRlbSA9IE5vZGUuY3JlYXRlPExpc3RJdGVtT3B0aW9ucz4oe1xuICBuYW1lOiAnbGlzdEl0ZW0nLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGJ1bGxldExpc3RUeXBlTmFtZTogJ2J1bGxldExpc3QnLFxuICAgICAgb3JkZXJlZExpc3RUeXBlTmFtZTogJ29yZGVyZWRMaXN0JyxcbiAgICB9XG4gIH0sXG5cbiAgY29udGVudDogJ3BhcmFncmFwaCBibG9jayonLFxuXG4gIGRlZmluaW5nOiB0cnVlLFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdsaScsXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ2xpJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBFbnRlcjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc3BsaXRMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgVGFiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zaW5rTGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgICdTaGlmdC1UYWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7XG4gIGdldE1hcmtBdHRyaWJ1dGVzLFxuICBNYXJrLFxuICBtZXJnZUF0dHJpYnV0ZXMsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBUZXh0U3R5bGVPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHNwYW5zIHdpdGhvdXQgaW5saW5lIHN0eWxlIGF0dHJpYnV0ZXMuXG4gICAgICAgKi9cbiAgICAgIHJlbW92ZUVtcHR5VGV4dFN0eWxlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgVGV4dFN0eWxlID0gTWFyay5jcmVhdGU8VGV4dFN0eWxlT3B0aW9ucz4oe1xuICBuYW1lOiAndGV4dFN0eWxlJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdzcGFuJyxcbiAgICAgICAgZ2V0QXR0cnM6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IGhhc1N0eWxlcyA9IChlbGVtZW50IGFzIEhUTUxFbGVtZW50KS5oYXNBdHRyaWJ1dGUoJ3N0eWxlJylcblxuICAgICAgICAgIGlmICghaGFzU3R5bGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge31cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnc3BhbicsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlRW1wdHlUZXh0U3R5bGU6ICgpID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdGhpcy50eXBlKVxuICAgICAgICBjb25zdCBoYXNTdHlsZXMgPSBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5zb21lKChbLCB2YWx1ZV0pID0+ICEhdmFsdWUpXG5cbiAgICAgICAgaWYgKGhhc1N0eWxlcykge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSwgd3JhcHBpbmdJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmltcG9ydCBMaXN0SXRlbSBmcm9tICcuLi8uLi9leHRlbnNpb24tbGlzdC1pdGVtL3NyYy9pbmRleC5qcydcbmltcG9ydCBUZXh0U3R5bGUgZnJvbSAnLi4vLi4vZXh0ZW5zaW9uLXRleHQtc3R5bGUvc3JjL2luZGV4LmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIE9yZGVyZWRMaXN0T3B0aW9ucyB7XG4gIGl0ZW1UeXBlTmFtZTogc3RyaW5nLFxuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PixcbiAga2VlcE1hcmtzOiBib29sZWFuLFxuICBrZWVwQXR0cmlidXRlczogYm9vbGVhbixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIG9yZGVyZWRMaXN0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhbiBvcmRlcmVkIGxpc3RcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlT3JkZXJlZExpc3Q6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbnB1dFJlZ2V4ID0gL14oXFxkKylcXC5cXHMkL1xuXG5leHBvcnQgY29uc3QgT3JkZXJlZExpc3QgPSBOb2RlLmNyZWF0ZTxPcmRlcmVkTGlzdE9wdGlvbnM+KHtcbiAgbmFtZTogJ29yZGVyZWRMaXN0JyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtVHlwZU5hbWU6ICdsaXN0SXRlbScsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICBrZWVwTWFya3M6IGZhbHNlLFxuICAgICAga2VlcEF0dHJpYnV0ZXM6IGZhbHNlLFxuICAgIH1cbiAgfSxcblxuICBncm91cDogJ2Jsb2NrIGxpc3QnLFxuXG4gIGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWV9K2BcbiAgfSxcblxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDoge1xuICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnc3RhcnQnKVxuICAgICAgICAgICAgPyBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3RhcnQnKSB8fCAnJywgMTApXG4gICAgICAgICAgICA6IDFcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdvbCcsXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIGNvbnN0IHsgc3RhcnQsIC4uLmF0dHJpYnV0ZXNXaXRob3V0U3RhcnQgfSA9IEhUTUxBdHRyaWJ1dGVzXG5cbiAgICByZXR1cm4gc3RhcnQgPT09IDFcbiAgICAgID8gWydvbCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXNXaXRob3V0U3RhcnQpLCAwXVxuICAgICAgOiBbJ29sJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2dnbGVPcmRlcmVkTGlzdDogKCkgPT4gKHsgY29tbWFuZHMsIGNoYWluIH0pID0+IHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAgIHJldHVybiBjaGFpbigpLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKS51cGRhdGVBdHRyaWJ1dGVzKExpc3RJdGVtLm5hbWUsIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlLm5hbWUpKS5ydW4oKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcylcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLVNoaWZ0LTcnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVPcmRlcmVkTGlzdCgpLFxuICAgIH1cbiAgfSxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIGxldCBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHsgc3RhcnQ6ICttYXRjaFsxXSB9KSxcbiAgICAgIGpvaW5QcmVkaWNhdGU6IChtYXRjaCwgbm9kZSkgPT4gbm9kZS5jaGlsZENvdW50ICsgbm9kZS5hdHRycy5zdGFydCA9PT0gK21hdGNoWzFdLFxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBNYXJrcyB8fCB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBrZWVwTWFya3M6IHRoaXMub3B0aW9ucy5rZWVwTWFya3MsXG4gICAgICAgIGtlZXBBdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7IHN0YXJ0OiArbWF0Y2hbMV0sIC4uLnRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlLm5hbWUpIH0pLFxuICAgICAgICBqb2luUHJlZGljYXRlOiAobWF0Y2gsIG5vZGUpID0+IG5vZGUuY2hpbGRDb3VudCArIG5vZGUuYXR0cnMuc3RhcnQgPT09ICttYXRjaFsxXSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICBpbnB1dFJ1bGUsXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyYWdyYXBoT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgcGFyYWdyYXBoOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIHBhcmFncmFwaFxuICAgICAgICovXG4gICAgICBzZXRQYXJhZ3JhcGg6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBQYXJhZ3JhcGggPSBOb2RlLmNyZWF0ZTxQYXJhZ3JhcGhPcHRpb25zPih7XG4gIG5hbWU6ICdwYXJhZ3JhcGgnLFxuXG4gIHByaW9yaXR5OiAxMDAwLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgZ3JvdXA6ICdibG9jaycsXG5cbiAgY29udGVudDogJ2lubGluZSonLFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB0YWc6ICdwJyB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ3AnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFBhcmFncmFwaDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1BbHQtMCc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFBhcmFncmFwaCgpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHtcbiAgaXNNYWNPUyxcbiAgTWFyayxcbiAgbWFya0lucHV0UnVsZSxcbiAgbWFya1Bhc3RlUnVsZSxcbiAgbWVyZ2VBdHRyaWJ1dGVzLFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RyaWtlT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc3RyaWtlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIHN0cmlrZSBtYXJrXG4gICAgICAgKi9cbiAgICAgIHNldFN0cmlrZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgc3RyaWtlIG1hcmtcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlU3RyaWtlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBVbnNldCBhIHN0cmlrZSBtYXJrXG4gICAgICAgKi9cbiAgICAgIHVuc2V0U3RyaWtlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaW5wdXRSZWdleCA9IC8oPzpefFxccykoKD86fn4pKCg/Oltefl0rKSkoPzp+fikpJC9cbmV4cG9ydCBjb25zdCBwYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKSgoPzp+fikoKD86W15+XSspKSg/On5+KSkvZ1xuXG5leHBvcnQgY29uc3QgU3RyaWtlID0gTWFyay5jcmVhdGU8U3RyaWtlT3B0aW9ucz4oe1xuICBuYW1lOiAnc3RyaWtlJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdzJyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogJ2RlbCcsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6ICdzdHJpa2UnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6ICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICAgICBjb25zdW1pbmc6IGZhbHNlLFxuICAgICAgICBnZXRBdHRyczogc3R5bGUgPT4gKChzdHlsZSBhcyBzdHJpbmcpLmluY2x1ZGVzKCdsaW5lLXRocm91Z2gnKSA/IHt9IDogZmFsc2UpLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydzJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZVN0cmlrZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdW5zZXRTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICBjb25zdCBzaG9ydGN1dHM6IFJlY29yZDxzdHJpbmcsICgpID0+IGJvb2xlYW4+ID0ge31cblxuICAgIGlmIChpc01hY09TKCkpIHtcbiAgICAgIHNob3J0Y3V0c1snTW9kLVNoaWZ0LXMnXSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVN0cmlrZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3J0Y3V0c1snQ3RybC1TaGlmdC1zJ10gPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVTdHJpa2UoKVxuICAgIH1cblxuICAgIHJldHVybiBzaG9ydGN1dHNcbiAgfSxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxuXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBwYXN0ZVJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IE5vZGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBjb25zdCBUZXh0ID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiAndGV4dCcsXG4gIGdyb3VwOiAnaW5saW5lJyxcbn0pXG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgQmxvY2txdW90ZSwgQmxvY2txdW90ZU9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1ibG9ja3F1b3RlJ1xuaW1wb3J0IHsgQm9sZCwgQm9sZE9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1ib2xkJ1xuaW1wb3J0IHsgQnVsbGV0TGlzdCwgQnVsbGV0TGlzdE9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1idWxsZXQtbGlzdCdcbmltcG9ydCB7IENvZGUsIENvZGVPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tY29kZSdcbmltcG9ydCB7IENvZGVCbG9jaywgQ29kZUJsb2NrT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUtYmxvY2snXG5pbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWRvY3VtZW50J1xuaW1wb3J0IHsgRHJvcGN1cnNvciwgRHJvcGN1cnNvck9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1kcm9wY3Vyc29yJ1xuaW1wb3J0IHsgR2FwY3Vyc29yIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tZ2FwY3Vyc29yJ1xuaW1wb3J0IHsgSGFyZEJyZWFrLCBIYXJkQnJlYWtPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhaydcbmltcG9ydCB7IEhlYWRpbmcsIEhlYWRpbmdPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taGVhZGluZydcbmltcG9ydCB7IEhpc3RvcnksIEhpc3RvcnlPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taGlzdG9yeSdcbmltcG9ydCB7IEhvcml6b250YWxSdWxlLCBIb3Jpem9udGFsUnVsZU9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1ob3Jpem9udGFsLXJ1bGUnXG5pbXBvcnQgeyBJdGFsaWMsIEl0YWxpY09wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1pdGFsaWMnXG5pbXBvcnQgeyBMaXN0SXRlbSwgTGlzdEl0ZW1PcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tbGlzdC1pdGVtJ1xuaW1wb3J0IHsgT3JkZXJlZExpc3QsIE9yZGVyZWRMaXN0T3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLW9yZGVyZWQtbGlzdCdcbmltcG9ydCB7IFBhcmFncmFwaCwgUGFyYWdyYXBoT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLXBhcmFncmFwaCdcbmltcG9ydCB7IFN0cmlrZSwgU3RyaWtlT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLXN0cmlrZSdcbmltcG9ydCB7IFRleHQgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi10ZXh0J1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXJ0ZXJLaXRPcHRpb25zIHtcbiAgYmxvY2txdW90ZTogUGFydGlhbDxCbG9ja3F1b3RlT3B0aW9ucz4gfCBmYWxzZSxcbiAgYm9sZDogUGFydGlhbDxCb2xkT3B0aW9ucz4gfCBmYWxzZSxcbiAgYnVsbGV0TGlzdDogUGFydGlhbDxCdWxsZXRMaXN0T3B0aW9ucz4gfCBmYWxzZSxcbiAgY29kZTogUGFydGlhbDxDb2RlT3B0aW9ucz4gfCBmYWxzZSxcbiAgY29kZUJsb2NrOiBQYXJ0aWFsPENvZGVCbG9ja09wdGlvbnM+IHwgZmFsc2UsXG4gIGRvY3VtZW50OiBmYWxzZSxcbiAgZHJvcGN1cnNvcjogUGFydGlhbDxEcm9wY3Vyc29yT3B0aW9ucz4gfCBmYWxzZSxcbiAgZ2FwY3Vyc29yOiBmYWxzZSxcbiAgaGFyZEJyZWFrOiBQYXJ0aWFsPEhhcmRCcmVha09wdGlvbnM+IHwgZmFsc2UsXG4gIGhlYWRpbmc6IFBhcnRpYWw8SGVhZGluZ09wdGlvbnM+IHwgZmFsc2UsXG4gIGhpc3Rvcnk6IFBhcnRpYWw8SGlzdG9yeU9wdGlvbnM+IHwgZmFsc2UsXG4gIGhvcml6b250YWxSdWxlOiBQYXJ0aWFsPEhvcml6b250YWxSdWxlT3B0aW9ucz4gfCBmYWxzZSxcbiAgaXRhbGljOiBQYXJ0aWFsPEl0YWxpY09wdGlvbnM+IHwgZmFsc2UsXG4gIGxpc3RJdGVtOiBQYXJ0aWFsPExpc3RJdGVtT3B0aW9ucz4gfCBmYWxzZSxcbiAgb3JkZXJlZExpc3Q6IFBhcnRpYWw8T3JkZXJlZExpc3RPcHRpb25zPiB8IGZhbHNlLFxuICBwYXJhZ3JhcGg6IFBhcnRpYWw8UGFyYWdyYXBoT3B0aW9ucz4gfCBmYWxzZSxcbiAgc3RyaWtlOiBQYXJ0aWFsPFN0cmlrZU9wdGlvbnM+IHwgZmFsc2UsXG4gIHRleHQ6IGZhbHNlLFxufVxuXG5leHBvcnQgY29uc3QgU3RhcnRlcktpdCA9IEV4dGVuc2lvbi5jcmVhdGU8U3RhcnRlcktpdE9wdGlvbnM+KHtcbiAgbmFtZTogJ3N0YXJ0ZXJLaXQnLFxuXG4gIGFkZEV4dGVuc2lvbnMoKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IFtdXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJsb2NrcXVvdGUgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goQmxvY2txdW90ZS5jb25maWd1cmUodGhpcy5vcHRpb25zPy5ibG9ja3F1b3RlKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJvbGQgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goQm9sZC5jb25maWd1cmUodGhpcy5vcHRpb25zPy5ib2xkKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldExpc3QgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goQnVsbGV0TGlzdC5jb25maWd1cmUodGhpcy5vcHRpb25zPy5idWxsZXRMaXN0KSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNvZGUgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goQ29kZS5jb25maWd1cmUodGhpcy5vcHRpb25zPy5jb2RlKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNvZGVCbG9jayAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChDb2RlQmxvY2suY29uZmlndXJlKHRoaXMub3B0aW9ucz8uY29kZUJsb2NrKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRvY3VtZW50ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKERvY3VtZW50LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmRvY3VtZW50KSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRyb3BjdXJzb3IgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goRHJvcGN1cnNvci5jb25maWd1cmUodGhpcy5vcHRpb25zPy5kcm9wY3Vyc29yKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmdhcGN1cnNvciAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChHYXBjdXJzb3IuY29uZmlndXJlKHRoaXMub3B0aW9ucz8uZ2FwY3Vyc29yKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmhhcmRCcmVhayAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChIYXJkQnJlYWsuY29uZmlndXJlKHRoaXMub3B0aW9ucz8uaGFyZEJyZWFrKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRpbmcgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goSGVhZGluZy5jb25maWd1cmUodGhpcy5vcHRpb25zPy5oZWFkaW5nKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmhpc3RvcnkgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goSGlzdG9yeS5jb25maWd1cmUodGhpcy5vcHRpb25zPy5oaXN0b3J5KSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmhvcml6b250YWxSdWxlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhvcml6b250YWxSdWxlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/Lmhvcml6b250YWxSdWxlKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLml0YWxpYyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChJdGFsaWMuY29uZmlndXJlKHRoaXMub3B0aW9ucz8uaXRhbGljKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpc3RJdGVtICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKExpc3RJdGVtLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/Lmxpc3RJdGVtKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9yZGVyZWRMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKE9yZGVyZWRMaXN0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/Lm9yZGVyZWRMaXN0KSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnBhcmFncmFwaCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChQYXJhZ3JhcGguY29uZmlndXJlKHRoaXMub3B0aW9ucz8ucGFyYWdyYXBoKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnN0cmlrZSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChTdHJpa2UuY29uZmlndXJlKHRoaXMub3B0aW9ucz8uc3RyaWtlKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRleHQgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVGV4dC5jb25maWd1cmUodGhpcy5vcHRpb25zPy50ZXh0KSlcbiAgICB9XG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uc1xuICB9LFxufSlcbiIsICI8c2NyaXB0PlxuICAgIGltcG9ydCB7IE5vZGVWaWV3V3JhcHBlciB9IGZyb20gJ3N2ZWx0ZS10aXB0YXAnXG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBwb3VuY2UgfSBmcm9tICcuLi91dGlscy9wb3VuY2UuanMnXG4gICAgaW1wb3J0IHsgZ2V0U3RhdGVQYXRoIH0gZnJvbSAnLi4vc3RvcmVzLmpzJ1xuXG4gICAgZXhwb3J0IGxldCBlZGl0b3I7XG4gICAgZXhwb3J0IGxldCBub2RlO1xuICAgIGV4cG9ydCBsZXQgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBleHBvcnQgbGV0IHVwZGF0ZUF0dHJpYnV0ZXM7XG5cbiAgICBsZXQgdmlldyA9IG51bGw7XG4gICAgbGV0IHdyYXBwZXI7XG5cbiAgICBjb25zdCBvcGVuID0gKCkgPT4ge1xuICAgICAgICBwb3VuY2Uobm9kZS5hdHRycy50eXBlLCB7IHVwZGF0ZTogdHJ1ZSwgc3RhdGVQYXRoOiAkZ2V0U3RhdGVQYXRoLCAuLi5ub2RlLmF0dHJzLnZhbHVlcyB9KVxuICAgIH1cblxuICAgIGNvbnN0IHJlbW92ZUJsb2NrID0gKCkgPT4ge1xuICAgICAgICBlZGl0b3IuY29tbWFuZHMuZGVsZXRlU2VsZWN0aW9uKClcbiAgICB9XG5cbiAgICBjb25zdCBnZXRWaWV3ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2NyaWJibGUtcmVuZGVyZXInKS5nZXRBdHRyaWJ1dGUoJ3dpcmU6aWQnKVxuXG4gICAgICAgIHdpbmRvdy5MaXZld2lyZVxuICAgICAgICAgICAgLmZpbmQoY29tcG9uZW50KVxuICAgICAgICAgICAgLmNhbGwoJ2dldFZpZXcnLCBub2RlLmF0dHJzLnR5cGUsIG5vZGUuYXR0cnMudmFsdWVzKVxuICAgICAgICAgICAgLnRoZW4oZSA9PiB2aWV3ID0gZSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0Jyk/LmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSgnaWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZS50YXJnZXQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUF0dHJpYnV0ZXMoeyB2YWx1ZXM6IHsuLi5ub2RlLmF0dHJzLnZhbHVlcywgW25hbWVdOiB2YWx1ZSB9IH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGdldFZpZXcoKVxuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVkQmxvY2snLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUuZGV0YWlsLnR5cGUgPT09IG5vZGUuYXR0cnMudHlwZSAmJiBlLmRldGFpbC5zdGF0ZVBhdGggPT09ICRnZXRTdGF0ZVBhdGgpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVBdHRyaWJ1dGVzKHsgdmFsdWVzOiBlLmRldGFpbC52YWx1ZXMgfSlcbiAgICAgICAgICAgICAgICBnZXRWaWV3KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KVxuPC9zY3JpcHQ+XG5cbjxOb2RlVmlld1dyYXBwZXI+XG4gICAgPGRpdiBjbGFzcz1cInJlbGF0aXZlIGdyb3VwIGJnLWdyYXktOTAwLzUgZGFyazpiZy13aGl0ZS81IHJvdW5kZWQtbWRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRyYW5zaXRpb24gY3Vyc29yLXBvaW50ZXIgcm91bmRlZC1tZCBvdmVyZmxvdy1oaWRkZW4gei0xMCByZWxhdGl2ZSB7c2VsZWN0ZWQgPyAnUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlJyA6ICcnfVwiIGJpbmQ6dGhpcz17d3JhcHBlcn0+XG4gICAgICAgICAgICB7QGh0bWwgdmlld31cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzY3JpYmJsZS1ibG9jay1hY3Rpb25zIHRyYW5zaXRpb24gb3BhY2l0eS0wIGFic29sdXRlIHotMjAgdG9wLTAgcmlnaHQtMCBwLTEgcm91bmRlZC10ci1tZCByb3VuZGVkLWJsLWxnIGZsZXggaXRlbXMtY2VudGVyIGJnLWdyYXktOTUwIGdyb3VwLWhvdmVyOm9wYWNpdHktMTAwXCI+XG4gICAgICAgICAgICA8ZGl2IGRhdGEtZHJhZy1oYW5kbGUgY2xhc3M9XCJjdXJzb3ItZ3JhYmJpbmcgdGV4dC13aGl0ZSBibG9jayByb3VuZGVkIHAtMSBob3Zlcjp0ZXh0LXByaW1hcnktNTAwIGhvdmVyOmJnLWdyYXktODAwXCI+XG4gICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInNpemUtNFwiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwibTIyLjY3IDEybC00LjQ5IDQuNWwtMi41MS0yLjVsMS45OC0ybC0xLjk4LTEuOTZsMi41MS0yLjUxek0xMiAxLjMzbDQuNDcgNC40OWwtMi41MSAyLjUxTDEyIDYuMzVsLTIgMS45OGwtMi41LTIuNTF6bTAgMjEuMzRsLTQuNDctNC40OWwyLjUxLTIuNTFMMTIgMTcuNjVsMi0xLjk4bDIuNSAyLjUxek0xLjMzIDEybDQuNDktNC41TDguMzMgMTBsLTEuOTggMmwxLjk4IDEuOTZsLTIuNTEgMi41MXpNMTIgMTBhMiAyIDAgMCAxIDIgMmEyIDIgMCAwIDEtMiAyYTIgMiAwIDAgMS0yLTJhMiAyIDAgMCAxIDItMlwiLz5cbiAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGJ1dHRvbiBvbjpjbGlja3xwcmV2ZW50RGVmYXVsdHxzdG9wUHJvcGFnYXRpb249e29wZW59IHR5cGU9XCJidXR0b25cIiBjbGFzcz1cInRleHQtd2hpdGUgYmxvY2sgcm91bmRlZCBwLTEgaG92ZXI6dGV4dC1wcmltYXJ5LTUwMCBob3ZlcjpiZy1ncmF5LTgwMFwiPlxuICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJzaXplLTRcIj5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNMTUgNC41QTMuNSAzLjUgMCAwIDEgMTEuNDM1IDhjLS45OS0uMDE5LTIuMDkzLjEzMi0yLjcuOTEzbC00LjEzIDUuMzFhMi4wMTUgMi4wMTUgMCAxIDEtMi44MjctMi44MjhsNS4zMDktNC4xM2MuNzgtLjYwNy45MzItMS43MS45MTQtMi43TDggNC41YTMuNSAzLjUgMCAwIDEgNC40NzctMy4zNjJjLjMyNS4wOTQuMzkuNDk3LjE1LjczNkwxMC42IDMuOTAyYS40OC40OCAwIDAgMC0uMDMzLjY1M2MuMjcxLjMxNC41NjUuNjA4Ljg3OS44NzlhLjQ4LjQ4IDAgMCAwIC42NTMtLjAzM2wyLjAyNy0yLjAyN2MuMjM5LS4yNC42NDItLjE3NS43MzYuMTUuMDkuMzEuMTM4LjYzNy4xMzguOTc2Wk0zLjc1IDEzYS43NS43NSAwIDEgMS0xLjUgMCAuNzUuNzUgMCAwIDEgMS41IDBaXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTEuNSA5LjVjLjMxMyAwIC42Mi0uMDI5LjkxNy0uMDg0bDEuOTYyIDEuOTYyYTIuMTIxIDIuMTIxIDAgMCAxLTMgM2wtMi44MS0yLjgxIDEuMzUtMS43MzRjLjA1LS4wNjQuMTU4LS4xNTguNDI2LS4yMzMuMjc4LS4wNzguNjM5LS4xMSAxLjA2Mi0uMTAybC4wOTMuMDAxWk01IDRsMS40NDYgMS40NDVhMi4yNTYgMi4yNTYgMCAwIDEtLjA0Ny4yMWMtLjA3NS4yNjgtLjE2OS4zNzctLjIzMy40MjdsLS42MS40NzRMNCA1SDIuNjU1YS4yNS4yNSAwIDAgMS0uMjI0LS4xMzlsLTEuMzUtMi43YS4yNS4yNSAwIDAgMSAuMDQ3LS4yODlsLjc0NS0uNzQ1YS4yNS4yNSAwIDAgMSAuMjg5LS4wNDdsMi43IDEuMzVBLjI1LjI1IDAgMCAxIDUgMi42NTRWNFpcIiAvPlxuICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIG9uOmNsaWNrfHByZXZlbnREZWZhdWx0fHN0b3BQcm9wYWdhdGlvbj17cmVtb3ZlQmxvY2t9IHR5cGU9XCJidXR0b25cIiBjbGFzcz1cInRleHQtd2hpdGUgYmxvY2sgcm91bmRlZCBwLTEgaG92ZXI6dGV4dC1wcmltYXJ5LTUwMCBob3ZlcjpiZy1ncmF5LTgwMFwiPlxuICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJzaXplLTRcIj5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNSAzLjI1VjRIMi43NWEuNzUuNzUgMCAwIDAgMCAxLjVoLjNsLjgxNSA4LjE1QTEuNSAxLjUgMCAwIDAgNS4zNTcgMTVoNS4yODVhMS41IDEuNSAwIDAgMCAxLjQ5My0xLjM1bC44MTUtOC4xNWguM2EuNzUuNzUgMCAwIDAgMC0xLjVIMTF2LS43NUEyLjI1IDIuMjUgMCAwIDAgOC43NSAxaC0xLjVBMi4yNSAyLjI1IDAgMCAwIDUgMy4yNVptMi4yNS0uNzVhLjc1Ljc1IDAgMCAwLS43NS43NVY0aDN2LS43NWEuNzUuNzUgMCAwIDAtLjc1LS43NWgtMS41Wk02LjA1IDZhLjc1Ljc1IDAgMCAxIC43ODcuNzEzbC4yNzUgNS41YS43NS43NSAwIDAgMS0xLjQ5OC4wNzVsLS4yNzUtNS41QS43NS43NSAwIDAgMSA2LjA1IDZabTMuOSAwYS43NS43NSAwIDAgMSAuNzEyLjc4N2wtLjI3NSA1LjVhLjc1Ljc1IDAgMCAxLTEuNDk4LS4wNzVsLjI3NS01LjVhLjc1Ljc1IDAgMCAxIC43ODYtLjcxMVpcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvTm9kZVZpZXdXcmFwcGVyPlxuIiwgImV4cG9ydCBjb25zdCB1dWlkID0gKCkgPT4ge1xuICAgIHJldHVybiAoWzFlN10rLTFlMystNGUzKy04ZTMrLTFlMTEpLnJlcGxhY2UoL1swMThdL2csIGMgPT5cbiAgICAgICAgKGMgXiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDEpKVswXSAmIDE1ID4+IGMgLyA0KS50b1N0cmluZygxNilcbiAgICApO1xufVxuIiwgImltcG9ydCB7IE5vZGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBTdmVsdGVOb2RlVmlld1JlbmRlcmVyIH0gZnJvbSAnc3ZlbHRlLXRpcHRhcCdcbmltcG9ydCBTY3JpYmJsZUJsb2NrVmlldyBmcm9tIFwiLi4vY29tcG9uZW50cy9TY3JpYmJsZUJsb2NrLnN2ZWx0ZVwiXG5pbXBvcnQgeyB1dWlkIH0gZnJvbSBcIi4uL3V0aWxzL3V1aWRcIlxuaW1wb3J0IHsgcG91bmNlIH0gZnJvbSAnLi4vdXRpbHMvcG91bmNlLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3NjcmliYmxlQmxvY2snLFxuICAgIGlzQmxvY2s6IHRydWUsXG4gICAgaW5saW5lOiBmYWxzZSxcbiAgICBncm91cDogJ2Jsb2NrJyxcbiAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgZGVmaW5pbmc6IHRydWUsXG4gICAgc2VsZWN0YWJsZTogdHJ1ZSxcblxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnc2NyaWJibGUtYmxvY2snLFxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiAoZG9tKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRvbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydzY3JpYmJsZS1ibG9jaycsIEpTT04uc3RyaW5naWZ5KEhUTUxBdHRyaWJ1dGVzKV07XG4gICAgfSxcblxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0U2NyaWJibGVCbG9jazogKG9wdGlvbnMpID0+ICh7IHRyLCBzdGF0ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHN0YXRlLnNjaGVtYS5ub2Rlc1sncGFyYWdyYXBoJ10uY3JlYXRlKClcblxuICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VSYW5nZVdpdGgoc2VsZWN0aW9uLmZyb20gLSBzZWxlY3Rpb24uJGFuY2hvci5wYXJlbnRPZmZzZXQsIHNlbGVjdGlvbi50bywgbm9kZSk7XG5cbiAgICAgICAgICAgICAgICBwb3VuY2Uob3B0aW9ucy50eXBlLCB7IHN0YXRlUGF0aDogb3B0aW9ucy5zdGF0ZVBhdGggfSlcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbnNlcnRTY3JpYmJsZUJsb2NrOiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoeyB0ciwgZGlzcGF0Y2gsIHN0YXRlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLntpZDogdXVpZCgpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VSYW5nZVdpdGgoc2VsZWN0aW9uLmZyb20gLSBzZWxlY3Rpb24uJGFuY2hvci5wYXJlbnRPZmZzZXQsIHNlbGVjdGlvbi50bywgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkTm9kZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBTdmVsdGVOb2RlVmlld1JlbmRlcmVyKFNjcmliYmxlQmxvY2tWaWV3KVxuICAgIH1cbn0pXG4iLCAiaW1wb3J0IHsgZXNjYXBlRm9yUmVnRXgsIFJhbmdlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgUmVzb2x2ZWRQb3MgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyaWdnZXIge1xuICBjaGFyOiBzdHJpbmdcbiAgYWxsb3dTcGFjZXM6IGJvb2xlYW5cbiAgYWxsb3dlZFByZWZpeGVzOiBzdHJpbmdbXSB8IG51bGxcbiAgc3RhcnRPZkxpbmU6IGJvb2xlYW5cbiAgJHBvc2l0aW9uOiBSZXNvbHZlZFBvc1xufVxuXG5leHBvcnQgdHlwZSBTdWdnZXN0aW9uTWF0Y2ggPSB7XG4gIHJhbmdlOiBSYW5nZVxuICBxdWVyeTogc3RyaW5nXG4gIHRleHQ6IHN0cmluZ1xufSB8IG51bGxcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRTdWdnZXN0aW9uTWF0Y2goY29uZmlnOiBUcmlnZ2VyKTogU3VnZ2VzdGlvbk1hdGNoIHtcbiAgY29uc3Qge1xuICAgIGNoYXIsIGFsbG93U3BhY2VzLCBhbGxvd2VkUHJlZml4ZXMsIHN0YXJ0T2ZMaW5lLCAkcG9zaXRpb24sXG4gIH0gPSBjb25maWdcblxuICBjb25zdCBlc2NhcGVkQ2hhciA9IGVzY2FwZUZvclJlZ0V4KGNoYXIpXG4gIGNvbnN0IHN1ZmZpeCA9IG5ldyBSZWdFeHAoYFxcXFxzJHtlc2NhcGVkQ2hhcn0kYClcbiAgY29uc3QgcHJlZml4ID0gc3RhcnRPZkxpbmUgPyAnXicgOiAnJ1xuICBjb25zdCByZWdleHAgPSBhbGxvd1NwYWNlc1xuICAgID8gbmV3IFJlZ0V4cChgJHtwcmVmaXh9JHtlc2NhcGVkQ2hhcn0uKj8oPz1cXFxccyR7ZXNjYXBlZENoYXJ9fCQpYCwgJ2dtJylcbiAgICA6IG5ldyBSZWdFeHAoYCR7cHJlZml4fSg/Ol4pPyR7ZXNjYXBlZENoYXJ9W15cXFxccyR7ZXNjYXBlZENoYXJ9XSpgLCAnZ20nKVxuXG4gIGNvbnN0IHRleHQgPSAkcG9zaXRpb24ubm9kZUJlZm9yZT8uaXNUZXh0ICYmICRwb3NpdGlvbi5ub2RlQmVmb3JlLnRleHRcblxuICBpZiAoIXRleHQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgdGV4dEZyb20gPSAkcG9zaXRpb24ucG9zIC0gdGV4dC5sZW5ndGhcbiAgY29uc3QgbWF0Y2ggPSBBcnJheS5mcm9tKHRleHQubWF0Y2hBbGwocmVnZXhwKSkucG9wKClcblxuICBpZiAoIW1hdGNoIHx8IG1hdGNoLmlucHV0ID09PSB1bmRlZmluZWQgfHwgbWF0Y2guaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBKYXZhU2NyaXB0IGRvZXNuJ3QgaGF2ZSBsb29rYmVoaW5kcy4gVGhpcyBoYWNrcyBhIGNoZWNrIHRoYXQgZmlyc3QgY2hhcmFjdGVyXG4gIC8vIGlzIGEgc3BhY2Ugb3IgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXG4gIGNvbnN0IG1hdGNoUHJlZml4ID0gbWF0Y2guaW5wdXQuc2xpY2UoTWF0aC5tYXgoMCwgbWF0Y2guaW5kZXggLSAxKSwgbWF0Y2guaW5kZXgpXG4gIGNvbnN0IG1hdGNoUHJlZml4SXNBbGxvd2VkID0gbmV3IFJlZ0V4cChgXlske2FsbG93ZWRQcmVmaXhlcz8uam9pbignJyl9XFwwXT8kYCkudGVzdChtYXRjaFByZWZpeClcblxuICBpZiAoYWxsb3dlZFByZWZpeGVzICE9PSBudWxsICYmICFtYXRjaFByZWZpeElzQWxsb3dlZCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIG1hdGNoIGluIHRoZSBkb2N1bWVudFxuICBjb25zdCBmcm9tID0gdGV4dEZyb20gKyBtYXRjaC5pbmRleFxuICBsZXQgdG8gPSBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoXG5cbiAgLy8gRWRnZSBjYXNlIGhhbmRsaW5nOyBpZiBzcGFjZXMgYXJlIGFsbG93ZWQgYW5kIHdlJ3JlIGRpcmVjdGx5IGluIGJldHdlZW5cbiAgLy8gdHdvIHRyaWdnZXJzXG4gIGlmIChhbGxvd1NwYWNlcyAmJiBzdWZmaXgudGVzdCh0ZXh0LnNsaWNlKHRvIC0gMSwgdG8gKyAxKSkpIHtcbiAgICBtYXRjaFswXSArPSAnICdcbiAgICB0byArPSAxXG4gIH1cblxuICAvLyBJZiB0aGUgJHBvc2l0aW9uIGlzIGxvY2F0ZWQgd2l0aGluIHRoZSBtYXRjaGVkIHN1YnN0cmluZywgcmV0dXJuIHRoYXQgcmFuZ2VcbiAgaWYgKGZyb20gPCAkcG9zaXRpb24ucG9zICYmIHRvID49ICRwb3NpdGlvbi5wb3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmFuZ2U6IHtcbiAgICAgICAgZnJvbSxcbiAgICAgICAgdG8sXG4gICAgICB9LFxuICAgICAgcXVlcnk6IG1hdGNoWzBdLnNsaWNlKGNoYXIubGVuZ3RoKSxcbiAgICAgIHRleHQ6IG1hdGNoWzBdLFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yLCBSYW5nZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IEVkaXRvclN0YXRlLCBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0LCBFZGl0b3JWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuXG5pbXBvcnQgeyBmaW5kU3VnZ2VzdGlvbk1hdGNoIH0gZnJvbSAnLi9maW5kU3VnZ2VzdGlvbk1hdGNoLmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFN1Z2dlc3Rpb25PcHRpb25zPEkgPSBhbnk+IHtcbiAgcGx1Z2luS2V5PzogUGx1Z2luS2V5XG4gIGVkaXRvcjogRWRpdG9yXG4gIGNoYXI/OiBzdHJpbmdcbiAgYWxsb3dTcGFjZXM/OiBib29sZWFuXG4gIGFsbG93ZWRQcmVmaXhlcz86IHN0cmluZ1tdIHwgbnVsbFxuICBzdGFydE9mTGluZT86IGJvb2xlYW5cbiAgZGVjb3JhdGlvblRhZz86IHN0cmluZ1xuICBkZWNvcmF0aW9uQ2xhc3M/OiBzdHJpbmdcbiAgY29tbWFuZD86IChwcm9wczogeyBlZGl0b3I6IEVkaXRvcjsgcmFuZ2U6IFJhbmdlOyBwcm9wczogSSB9KSA9PiB2b2lkXG4gIGl0ZW1zPzogKHByb3BzOiB7IHF1ZXJ5OiBzdHJpbmc7IGVkaXRvcjogRWRpdG9yIH0pID0+IElbXSB8IFByb21pc2U8SVtdPlxuICByZW5kZXI/OiAoKSA9PiB7XG4gICAgb25CZWZvcmVTdGFydD86IChwcm9wczogU3VnZ2VzdGlvblByb3BzPEk+KSA9PiB2b2lkXG4gICAgb25TdGFydD86IChwcm9wczogU3VnZ2VzdGlvblByb3BzPEk+KSA9PiB2b2lkXG4gICAgb25CZWZvcmVVcGRhdGU/OiAocHJvcHM6IFN1Z2dlc3Rpb25Qcm9wczxJPikgPT4gdm9pZFxuICAgIG9uVXBkYXRlPzogKHByb3BzOiBTdWdnZXN0aW9uUHJvcHM8ST4pID0+IHZvaWRcbiAgICBvbkV4aXQ/OiAocHJvcHM6IFN1Z2dlc3Rpb25Qcm9wczxJPikgPT4gdm9pZFxuICAgIG9uS2V5RG93bj86IChwcm9wczogU3VnZ2VzdGlvbktleURvd25Qcm9wcykgPT4gYm9vbGVhblxuICB9XG4gIGFsbG93PzogKHByb3BzOiB7IGVkaXRvcjogRWRpdG9yOyBzdGF0ZTogRWRpdG9yU3RhdGU7IHJhbmdlOiBSYW5nZSB9KSA9PiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3VnZ2VzdGlvblByb3BzPEkgPSBhbnk+IHtcbiAgZWRpdG9yOiBFZGl0b3JcbiAgcmFuZ2U6IFJhbmdlXG4gIHF1ZXJ5OiBzdHJpbmdcbiAgdGV4dDogc3RyaW5nXG4gIGl0ZW1zOiBJW11cbiAgY29tbWFuZDogKHByb3BzOiBJKSA9PiB2b2lkXG4gIGRlY29yYXRpb25Ob2RlOiBFbGVtZW50IHwgbnVsbFxuICBjbGllbnRSZWN0PzogKCgpID0+IERPTVJlY3QgfCBudWxsKSB8IG51bGxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdWdnZXN0aW9uS2V5RG93blByb3BzIHtcbiAgdmlldzogRWRpdG9yVmlld1xuICBldmVudDogS2V5Ym9hcmRFdmVudFxuICByYW5nZTogUmFuZ2Vcbn1cblxuZXhwb3J0IGNvbnN0IFN1Z2dlc3Rpb25QbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5KCdzdWdnZXN0aW9uJylcblxuZXhwb3J0IGZ1bmN0aW9uIFN1Z2dlc3Rpb248SSA9IGFueT4oe1xuICBwbHVnaW5LZXkgPSBTdWdnZXN0aW9uUGx1Z2luS2V5LFxuICBlZGl0b3IsXG4gIGNoYXIgPSAnQCcsXG4gIGFsbG93U3BhY2VzID0gZmFsc2UsXG4gIGFsbG93ZWRQcmVmaXhlcyA9IFsnICddLFxuICBzdGFydE9mTGluZSA9IGZhbHNlLFxuICBkZWNvcmF0aW9uVGFnID0gJ3NwYW4nLFxuICBkZWNvcmF0aW9uQ2xhc3MgPSAnc3VnZ2VzdGlvbicsXG4gIGNvbW1hbmQgPSAoKSA9PiBudWxsLFxuICBpdGVtcyA9ICgpID0+IFtdLFxuICByZW5kZXIgPSAoKSA9PiAoe30pLFxuICBhbGxvdyA9ICgpID0+IHRydWUsXG59OiBTdWdnZXN0aW9uT3B0aW9uczxJPikge1xuICBsZXQgcHJvcHM6IFN1Z2dlc3Rpb25Qcm9wczxJPiB8IHVuZGVmaW5lZFxuICBjb25zdCByZW5kZXJlciA9IHJlbmRlcj8uKClcblxuICBjb25zdCBwbHVnaW46IFBsdWdpbjxhbnk+ID0gbmV3IFBsdWdpbih7XG4gICAga2V5OiBwbHVnaW5LZXksXG5cbiAgICB2aWV3KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlOiBhc3luYyAodmlldywgcHJldlN0YXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJldiA9IHRoaXMua2V5Py5nZXRTdGF0ZShwcmV2U3RhdGUpXG4gICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMua2V5Py5nZXRTdGF0ZSh2aWV3LnN0YXRlKVxuXG4gICAgICAgICAgLy8gU2VlIGhvdyB0aGUgc3RhdGUgY2hhbmdlZFxuICAgICAgICAgIGNvbnN0IG1vdmVkID0gcHJldi5hY3RpdmUgJiYgbmV4dC5hY3RpdmUgJiYgcHJldi5yYW5nZS5mcm9tICE9PSBuZXh0LnJhbmdlLmZyb21cbiAgICAgICAgICBjb25zdCBzdGFydGVkID0gIXByZXYuYWN0aXZlICYmIG5leHQuYWN0aXZlXG4gICAgICAgICAgY29uc3Qgc3RvcHBlZCA9IHByZXYuYWN0aXZlICYmICFuZXh0LmFjdGl2ZVxuICAgICAgICAgIGNvbnN0IGNoYW5nZWQgPSAhc3RhcnRlZCAmJiAhc3RvcHBlZCAmJiBwcmV2LnF1ZXJ5ICE9PSBuZXh0LnF1ZXJ5XG4gICAgICAgICAgY29uc3QgaGFuZGxlU3RhcnQgPSBzdGFydGVkIHx8IG1vdmVkXG4gICAgICAgICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gY2hhbmdlZCAmJiAhbW92ZWRcbiAgICAgICAgICBjb25zdCBoYW5kbGVFeGl0ID0gc3RvcHBlZCB8fCBtb3ZlZFxuXG4gICAgICAgICAgLy8gQ2FuY2VsIHdoZW4gc3VnZ2VzdGlvbiBpc24ndCBhY3RpdmVcbiAgICAgICAgICBpZiAoIWhhbmRsZVN0YXJ0ICYmICFoYW5kbGVDaGFuZ2UgJiYgIWhhbmRsZUV4aXQpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHN0YXRlID0gaGFuZGxlRXhpdCAmJiAhaGFuZGxlU3RhcnQgPyBwcmV2IDogbmV4dFxuICAgICAgICAgIGNvbnN0IGRlY29yYXRpb25Ob2RlID0gdmlldy5kb20ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgIGBbZGF0YS1kZWNvcmF0aW9uLWlkPVwiJHtzdGF0ZS5kZWNvcmF0aW9uSWR9XCJdYCxcbiAgICAgICAgICApXG5cbiAgICAgICAgICBwcm9wcyA9IHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHJhbmdlOiBzdGF0ZS5yYW5nZSxcbiAgICAgICAgICAgIHF1ZXJ5OiBzdGF0ZS5xdWVyeSxcbiAgICAgICAgICAgIHRleHQ6IHN0YXRlLnRleHQsXG4gICAgICAgICAgICBpdGVtczogW10sXG4gICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kUHJvcHMgPT4ge1xuICAgICAgICAgICAgICBjb21tYW5kKHtcbiAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLnJhbmdlLFxuICAgICAgICAgICAgICAgIHByb3BzOiBjb21tYW5kUHJvcHMsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb3JhdGlvbk5vZGUsXG4gICAgICAgICAgICAvLyB2aXJ0dWFsIG5vZGUgZm9yIHBvcHBlci5qcyBvciB0aXBweS5qc1xuICAgICAgICAgICAgLy8gdGhpcyBjYW4gYmUgdXNlZCBmb3IgYnVpbGRpbmcgcG9wdXBzIHdpdGhvdXQgYSBET00gbm9kZVxuICAgICAgICAgICAgY2xpZW50UmVjdDogZGVjb3JhdGlvbk5vZGVcbiAgICAgICAgICAgICAgPyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBvZiBgaXRlbXNgIGNhbiBiZSBhc3luY2hyb3Vub3VzIHdl4oCZbGwgc2VhcmNoIGZvciB0aGUgY3VycmVudCBkZWNvcmF0aW9uIG5vZGVcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVjb3JhdGlvbklkIH0gPSB0aGlzLmtleT8uZ2V0U3RhdGUoZWRpdG9yLnN0YXRlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudERlY29yYXRpb25Ob2RlID0gdmlldy5kb20ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgICAgIGBbZGF0YS1kZWNvcmF0aW9uLWlkPVwiJHtkZWNvcmF0aW9uSWR9XCJdYCxcbiAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudERlY29yYXRpb25Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB8fCBudWxsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYW5kbGVTdGFydCkge1xuICAgICAgICAgICAgcmVuZGVyZXI/Lm9uQmVmb3JlU3RhcnQ/Lihwcm9wcylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFuZGxlQ2hhbmdlKSB7XG4gICAgICAgICAgICByZW5kZXJlcj8ub25CZWZvcmVVcGRhdGU/Lihwcm9wcylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFuZGxlQ2hhbmdlIHx8IGhhbmRsZVN0YXJ0KSB7XG4gICAgICAgICAgICBwcm9wcy5pdGVtcyA9IGF3YWl0IGl0ZW1zKHtcbiAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICBxdWVyeTogc3RhdGUucXVlcnksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYW5kbGVFeGl0KSB7XG4gICAgICAgICAgICByZW5kZXJlcj8ub25FeGl0Py4ocHJvcHMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhbmRsZUNoYW5nZSkge1xuICAgICAgICAgICAgcmVuZGVyZXI/Lm9uVXBkYXRlPy4ocHJvcHMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhbmRsZVN0YXJ0KSB7XG4gICAgICAgICAgICByZW5kZXJlcj8ub25TdGFydD8uKHByb3BzKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVuZGVyZXI/Lm9uRXhpdD8uKHByb3BzKVxuICAgICAgICB9LFxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGF0ZToge1xuICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcGx1Z2luJ3MgaW50ZXJuYWwgc3RhdGUuXG4gICAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBzdGF0ZToge1xuICAgICAgICAgIGFjdGl2ZTogYm9vbGVhblxuICAgICAgICAgIHJhbmdlOiBSYW5nZVxuICAgICAgICAgIHF1ZXJ5OiBudWxsIHwgc3RyaW5nXG4gICAgICAgICAgdGV4dDogbnVsbCB8IHN0cmluZ1xuICAgICAgICAgIGNvbXBvc2luZzogYm9vbGVhblxuICAgICAgICAgIGRlY29yYXRpb25JZD86IHN0cmluZyB8IG51bGxcbiAgICAgICAgfSA9IHtcbiAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgICAgdG86IDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBxdWVyeTogbnVsbCxcbiAgICAgICAgICB0ZXh0OiBudWxsLFxuICAgICAgICAgIGNvbXBvc2luZzogZmFsc2UsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgIH0sXG5cbiAgICAgIC8vIEFwcGx5IGNoYW5nZXMgdG8gdGhlIHBsdWdpbiBzdGF0ZSBmcm9tIGEgdmlldyB0cmFuc2FjdGlvbi5cbiAgICAgIGFwcGx5KHRyYW5zYWN0aW9uLCBwcmV2LCBvbGRTdGF0ZSwgc3RhdGUpIHtcbiAgICAgICAgY29uc3QgeyBpc0VkaXRhYmxlIH0gPSBlZGl0b3JcbiAgICAgICAgY29uc3QgeyBjb21wb3NpbmcgfSA9IGVkaXRvci52aWV3XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cmFuc2FjdGlvblxuICAgICAgICBjb25zdCB7IGVtcHR5LCBmcm9tIH0gPSBzZWxlY3Rpb25cbiAgICAgICAgY29uc3QgbmV4dCA9IHsgLi4ucHJldiB9XG5cbiAgICAgICAgbmV4dC5jb21wb3NpbmcgPSBjb21wb3NpbmdcblxuICAgICAgICAvLyBXZSBjYW4gb25seSBiZSBzdWdnZXN0aW5nIGlmIHRoZSB2aWV3IGlzIGVkaXRhYmxlLCBhbmQ6XG4gICAgICAgIC8vICAgKiB0aGVyZSBpcyBubyBzZWxlY3Rpb24sIG9yXG4gICAgICAgIC8vICAgKiBhIGNvbXBvc2l0aW9uIGlzIGFjdGl2ZSAoc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzE0NDkpXG4gICAgICAgIGlmIChpc0VkaXRhYmxlICYmIChlbXB0eSB8fCBlZGl0b3Iudmlldy5jb21wb3NpbmcpKSB7XG4gICAgICAgICAgLy8gUmVzZXQgYWN0aXZlIHN0YXRlIGlmIHdlIGp1c3QgbGVmdCB0aGUgcHJldmlvdXMgc3VnZ2VzdGlvbiByYW5nZVxuICAgICAgICAgIGlmICgoZnJvbSA8IHByZXYucmFuZ2UuZnJvbSB8fCBmcm9tID4gcHJldi5yYW5nZS50bykgJiYgIWNvbXBvc2luZyAmJiAhcHJldi5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgIG5leHQuYWN0aXZlID0gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggYWdhaW5zdCB3aGVyZSBvdXIgY3Vyc29yIGN1cnJlbnRseSBpc1xuICAgICAgICAgIGNvbnN0IG1hdGNoID0gZmluZFN1Z2dlc3Rpb25NYXRjaCh7XG4gICAgICAgICAgICBjaGFyLFxuICAgICAgICAgICAgYWxsb3dTcGFjZXMsXG4gICAgICAgICAgICBhbGxvd2VkUHJlZml4ZXMsXG4gICAgICAgICAgICBzdGFydE9mTGluZSxcbiAgICAgICAgICAgICRwb3NpdGlvbjogc2VsZWN0aW9uLiRmcm9tLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgY29uc3QgZGVjb3JhdGlvbklkID0gYGlkXyR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZil9YFxuXG4gICAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBtYXRjaCwgdXBkYXRlIHRoZSBjdXJyZW50IHN0YXRlIHRvIHNob3cgaXRcbiAgICAgICAgICBpZiAobWF0Y2ggJiYgYWxsb3coeyBlZGl0b3IsIHN0YXRlLCByYW5nZTogbWF0Y2gucmFuZ2UgfSkpIHtcbiAgICAgICAgICAgIG5leHQuYWN0aXZlID0gdHJ1ZVxuICAgICAgICAgICAgbmV4dC5kZWNvcmF0aW9uSWQgPSBwcmV2LmRlY29yYXRpb25JZCA/IHByZXYuZGVjb3JhdGlvbklkIDogZGVjb3JhdGlvbklkXG4gICAgICAgICAgICBuZXh0LnJhbmdlID0gbWF0Y2gucmFuZ2VcbiAgICAgICAgICAgIG5leHQucXVlcnkgPSBtYXRjaC5xdWVyeVxuICAgICAgICAgICAgbmV4dC50ZXh0ID0gbWF0Y2gudGV4dFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0LmFjdGl2ZSA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQuYWN0aXZlID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0byBlbXB0eSB0aGUgcmFuZ2UgaWYgc3VnZ2VzdGlvbiBpcyBpbmFjdGl2ZVxuICAgICAgICBpZiAoIW5leHQuYWN0aXZlKSB7XG4gICAgICAgICAgbmV4dC5kZWNvcmF0aW9uSWQgPSBudWxsXG4gICAgICAgICAgbmV4dC5yYW5nZSA9IHsgZnJvbTogMCwgdG86IDAgfVxuICAgICAgICAgIG5leHQucXVlcnkgPSBudWxsXG4gICAgICAgICAgbmV4dC50ZXh0ID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHRcbiAgICAgIH0sXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG4gICAgICAvLyBDYWxsIHRoZSBrZXlkb3duIGhvb2sgaWYgc3VnZ2VzdGlvbiBpcyBhY3RpdmUuXG4gICAgICBoYW5kbGVLZXlEb3duKHZpZXcsIGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgYWN0aXZlLCByYW5nZSB9ID0gcGx1Z2luLmdldFN0YXRlKHZpZXcuc3RhdGUpXG5cbiAgICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXJlcj8ub25LZXlEb3duPy4oeyB2aWV3LCBldmVudCwgcmFuZ2UgfSkgfHwgZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIC8vIFNldHVwIGRlY29yYXRvciBvbiB0aGUgY3VycmVudGx5IGFjdGl2ZSBzdWdnZXN0aW9uLlxuICAgICAgZGVjb3JhdGlvbnMoc3RhdGUpIHtcbiAgICAgICAgY29uc3QgeyBhY3RpdmUsIHJhbmdlLCBkZWNvcmF0aW9uSWQgfSA9IHBsdWdpbi5nZXRTdGF0ZShzdGF0ZSlcblxuICAgICAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoc3RhdGUuZG9jLCBbXG4gICAgICAgICAgRGVjb3JhdGlvbi5pbmxpbmUocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHtcbiAgICAgICAgICAgIG5vZGVOYW1lOiBkZWNvcmF0aW9uVGFnLFxuICAgICAgICAgICAgY2xhc3M6IGRlY29yYXRpb25DbGFzcyxcbiAgICAgICAgICAgICdkYXRhLWRlY29yYXRpb24taWQnOiBkZWNvcmF0aW9uSWQsXG4gICAgICAgICAgfSksXG4gICAgICAgIF0pXG4gICAgICB9LFxuICAgIH0sXG4gIH0pXG5cbiAgcmV0dXJuIHBsdWdpblxufVxuIiwgIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgcG91bmNlIH0gZnJvbSAnLi4vdXRpbHMvcG91bmNlLmpzJ1xuXG4gICAgZXhwb3J0IGxldCBpdGVtc1xuICAgIGV4cG9ydCBsZXQgZWRpdG9yXG4gICAgZXhwb3J0IGxldCByYW5nZVxuXG4gICAgbGV0IHNlbGVjdGVkSW5kZXggPSAwXG4gICAgbGV0IGRyb3Bkb3duXG4gICAgbGV0IGdyb3Vwc1xuXG4gICAgY29uc3QgZ2V0R3JvdXBzID0gYXJyYXkgPT4ge1xuICAgICAgICBsZXQgbWFwID0gYXJyYXkubWFwKChlLCBpKSA9PiB7XG4gICAgICAgICAgICBlLmluZGV4ID0gaVxuICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgfSlcblxuICAgICAgICBncm91cHMgPSBtYXAucmVkdWNlKGZ1bmN0aW9uKHIsIGEpIHtcbiAgICAgICAgICAgIHJbYS5ncm91cF0gPSByW2EuZ3JvdXBdIHx8IFtdXG4gICAgICAgICAgICByW2EuZ3JvdXBdLnB1c2goYSlcbiAgICAgICAgICAgIHJldHVybiByXG4gICAgICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpXG4gICAgfVxuXG4gICAgJDogZ2V0R3JvdXBzKGl0ZW1zKVxuXG4gICAgZXhwb3J0IGNvbnN0IHJlc2V0SW5kZXggPSAoKSA9PiBzZWxlY3RlZEluZGV4ID0gMFxuXG4gICAgZXhwb3J0IGNvbnN0IG9uS2V5RG93biA9ICh7IGV2ZW50IH0pID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0Fycm93VXAnKSB7XG4gICAgICAgICAgICB1cEhhbmRsZXIoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5rZXkgPT09ICdBcnJvd0Rvd24nKSB7XG4gICAgICAgICAgICBkb3duSGFuZGxlcigpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgZW50ZXJIYW5kbGVyKClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCB1cEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHNlbGVjdGVkSW5kZXggPSAoKHNlbGVjdGVkSW5kZXggKyBpdGVtcy5sZW5ndGgpIC0gMSkgJSBpdGVtcy5sZW5ndGhcbiAgICAgICAgc2Nyb2xsVG9TZWxlY3QoKVxuICAgIH1cblxuICAgIGNvbnN0IGRvd25IYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBzZWxlY3RlZEluZGV4ID0gKHNlbGVjdGVkSW5kZXggKyAxKSAlIGl0ZW1zLmxlbmd0aFxuICAgICAgICBzY3JvbGxUb1NlbGVjdCgpXG4gICAgfVxuXG4gICAgY29uc3QgZW50ZXJIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBzZWxlY3RJdGVtKHNlbGVjdGVkSW5kZXgpXG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0SXRlbSA9IGluZGV4ID0+IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2luZGV4XVxuXG4gICAgICAgIGlmIChpdGVtKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZW0pXG4gICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnYmxvY2snICYmIGl0ZW0ucHJlcmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmNoYWluKCkuaW5zZXJ0U2NyaWJibGVCbG9jayh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGl0ZW0uaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXRoOiBpdGVtLnN0YXRlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB7fVxuICAgICAgICAgICAgICAgIH0pLmZvY3VzKCkucnVuKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoaXRlbS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1hbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmNoYWluKCkuZm9jdXMoKS5kZWxldGVSYW5nZShyYW5nZSlbaXRlbS5jb21tYW5kXShpdGVtLmNvbW1hbmRBcmd1bWVudHMpLnJ1bigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbW9kYWwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmNvbW1hbmRzLmRlbGV0ZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvdW5jZShpdGVtLmlkZW50aWZpZXIsIHsgc3RhdGVQYXRoOiBpdGVtLnN0YXRlUGF0aCwgLi4uZWRpdG9yLmdldEF0dHJpYnV0ZXMoaXRlbS5leHRlbnNpb24pIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5jb21tYW5kcy5zZXRTY3JpYmJsZUJsb2NrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBpdGVtLmlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXRoOiBpdGVtLnN0YXRlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2Nyb2xsVG9TZWxlY3QgPSAoKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZHJvcGRvd24ucXVlcnlTZWxlY3RvcignLmFjdGl2ZS1vcHRpb24nKS5zY3JvbGxJbnRvVmlldyh7XG4gICAgICAgICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnLFxuICAgICAgICAgICAgICAgIGJsb2NrOiAnbmVhcmVzdCcsXG4gICAgICAgICAgICAgICAgaW5saW5lOiAnZW5kJyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIDApXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgICBjbGFzcz1cInctNTYgbWF4LWgtNTYgb3ZlcmZsb3cteS1hdXRvIHNjcm9sbGJhci1oaWRlIHRleHQteHMgcm91bmRlZC1sZyBzaGFkb3ctbGcgcmluZy0xIHJpbmctZ3JheS05NTAvNSB0cmFuc2l0aW9uIGRhcms6cmluZy13aGl0ZS8xMFwiXG4gICAgYmluZDp0aGlzPXtkcm9wZG93bn1cbj5cbiAgICA8ZGl2PlxuICAgICAgICB7I2lmIGl0ZW1zLmxlbmd0aH1cbiAgICAgICAgICAgIHsjZWFjaCBPYmplY3Qua2V5cyhncm91cHMpIGFzIGdyb3VwfVxuICAgICAgICAgICAgICAgIHsjaWYgZ3JvdXAgfVxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC14cyBteS0xIHB4LTIgZm9udC1ib2xkXCI+e2dyb3VwfTwvZGl2PlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgeyNlYWNoIGdyb3Vwc1tncm91cF0gYXMgaXRlbX1cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2s9eygpID0+IHNlbGVjdEl0ZW0oaXRlbS5pbmRleCl9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInAtMiB3LWZ1bGwgZmxleCBnYXAtMiBpdGVtcy1jZW50ZXIgY3Vyc29yLXBvaW50ZXIgc2VsZWN0LW5vbmUgeyBpdGVtLmluZGV4ID09PSBzZWxlY3RlZEluZGV4ID8gJ2JnLWdyYXktODAwIGFjdGl2ZS1vcHRpb24nIDogJ2hvdmVyOmJnLWdyYXktODAwJyB9XCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzaHJpbmstMCByb3VuZGVkLW1kIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHRleHQtZ3JheS0yMDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGh0bWwgaXRlbS5pY29ufVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmbGV4LTEgdGV4dC1sZWZ0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJibG9ja1wiPntpdGVtLmxhYmVsfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIGl0ZW0uZGVzY3JpcHRpb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJibG9jayB0ZXh0LXhzIHRleHQtZ3JheS0zMDBcIj57aXRlbS5kZXNjcmlwdGlvbn08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7L2lmfVxuXG4gICAgICAgIHsjaWYgIWl0ZW1zLmxlbmd0aH1cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwLTIgdGV4dC1ncmF5LTIwMFwiPk5vIGJsb2NrcyBmb3VuZDwvZGl2PlxuICAgICAgICB7L2lmfVxuICAgIDwvZGl2PlxuPC9kaXY+XG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IFN1Z2dlc3Rpb24gZnJvbSAnQHRpcHRhcC9zdWdnZXN0aW9uJ1xuaW1wb3J0IENvbW1hbmRzTGlzdCBmcm9tICcuLi9jb21wb25lbnRzL0NvbW1hbmRzTGlzdC5zdmVsdGUnXG5pbXBvcnQgdGlwcHkgZnJvbSAndGlwcHkuanMnXG5pbXBvcnQgeyBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgZGVmYXVsdCBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnc2xhc2hFeHRlbnNpb24nLFxuXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJsb2Nrczoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFtdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBTdWdnZXN0aW9uKHtcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgIGNoYXI6ICcvJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAoeyBlZGl0b3IsIHJhbmdlLCBwcm9wcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmNvbW1hbmQoeyBlZGl0b3IsIHJhbmdlIH0pXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdGFydE9mTGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwbHVnaW5LZXk6IG5ldyBQbHVnaW5LZXkoJ3NsYXNoRXh0ZW5zaW9uJyksXG4gICAgICAgICAgICAgICAgaXRlbXM6ICh7IHF1ZXJ5IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50b29scy5maWx0ZXIoaXRlbSA9PiBpdGVtLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZW5kZXI6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9wdXBcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25TdGFydDogcHJvcHMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvcHMuY2xpZW50UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IG5ldyBDb21tYW5kc0xpc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogcHJvcHMuaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IHByb3BzLmVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBwcm9wcy5yYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3B1cCA9IHRpcHB5KCdib2R5Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBwcm9wcy5jbGllbnRSZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRUbzogKCkgPT4gZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29tcG9uZW50LiQkLnJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dPbkNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20tc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZTogJ3NjcmliYmxlLXBhbmVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IDQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25VcGRhdGUocHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuJHNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBwcm9wcy5pdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBwcm9wcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBwcm9wcy5yYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnJlc2V0SW5kZXgoKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wcy5jbGllbnRSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVwWzBdLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogcHJvcHMuY2xpZW50UmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLmV2ZW50LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wdXBbMF0uaGlkZSgpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50Lm9uS2V5RG93bihwcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkV4aXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wdXBbMF0uZGVzdHJveSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LiRkZXN0cm95KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdXG4gICAgfVxufSlcbiIsICJpbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3Vic2NyaXB0RXh0ZW5zaW9uT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBPYmplY3QsXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzdWJzY3JpcHQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgc3Vic2NyaXB0IG1hcmtcbiAgICAgICAqL1xuICAgICAgc2V0U3Vic2NyaXB0OiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBzdWJzY3JpcHQgbWFya1xuICAgICAgICovXG4gICAgICB0b2dnbGVTdWJzY3JpcHQ6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGEgc3Vic2NyaXB0IG1hcmtcbiAgICAgICAqL1xuICAgICAgdW5zZXRTdWJzY3JpcHQ6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBTdWJzY3JpcHQgPSBNYXJrLmNyZWF0ZTxTdWJzY3JpcHRFeHRlbnNpb25PcHRpb25zPih7XG4gIG5hbWU6ICdzdWJzY3JpcHQnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ3N1YicsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogJ3ZlcnRpY2FsLWFsaWduJyxcbiAgICAgICAgZ2V0QXR0cnModmFsdWUpIHtcbiAgICAgICAgICAvLyBEb27igJl0IG1hdGNoIHRoaXMgcnVsZSBpZiB0aGUgdmVydGljYWwgYWxpZ24gaXNu4oCZdCBzdWIuXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSAnc3ViJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgaXQgZmFsbHMgdGhyb3VnaCB3ZeKAmWxsIG1hdGNoLCBhbmQgdGhpcyBtYXJrIHdpbGwgYmUgYXBwbGllZC5cbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydzdWInLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFN1YnNjcmlwdDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdG9nZ2xlU3Vic2NyaXB0OiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB1bnNldFN1YnNjcmlwdDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLSwnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVTdWJzY3JpcHQoKSxcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBTdXBlcnNjcmlwdEV4dGVuc2lvbk9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogT2JqZWN0LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc3VwZXJzY3JpcHQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgc3VwZXJzY3JpcHQgbWFya1xuICAgICAgICovXG4gICAgICBzZXRTdXBlcnNjcmlwdDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgc3VwZXJzY3JpcHQgbWFya1xuICAgICAgICovXG4gICAgICB0b2dnbGVTdXBlcnNjcmlwdDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zZXQgYSBzdXBlcnNjcmlwdCBtYXJrXG4gICAgICAgKi9cbiAgICAgIHVuc2V0U3VwZXJzY3JpcHQ6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBTdXBlcnNjcmlwdCA9IE1hcmsuY3JlYXRlPFN1cGVyc2NyaXB0RXh0ZW5zaW9uT3B0aW9ucz4oe1xuICBuYW1lOiAnc3VwZXJzY3JpcHQnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ3N1cCcsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogJ3ZlcnRpY2FsLWFsaWduJyxcbiAgICAgICAgZ2V0QXR0cnModmFsdWUpIHtcbiAgICAgICAgICAvLyBEb27igJl0IG1hdGNoIHRoaXMgcnVsZSBpZiB0aGUgdmVydGljYWwgYWxpZ24gaXNu4oCZdCBzdXBlci5cbiAgICAgICAgICBpZiAodmFsdWUgIT09ICdzdXBlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGl0IGZhbGxzIHRocm91Z2ggd2XigJlsbCBtYXRjaCwgYW5kIHRoaXMgbWFyayB3aWxsIGJlIGFwcGxpZWQuXG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnc3VwJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRTdXBlcnNjcmlwdDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdG9nZ2xlU3VwZXJzY3JpcHQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHVuc2V0U3VwZXJzY3JpcHQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC0uJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlU3VwZXJzY3JpcHQoKSxcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGNvbnN0IFRleHRBbGlnbiA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICd0ZXh0QWxpZ24nLFxuXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGVzOiBbXSxcbiAgICAgICAgICAgIGFsaWdubWVudHM6IFsnc3RhcnQnLCAnY2VudGVyJywgJ2VuZCcsICdqdXN0aWZ5J10sXG4gICAgICAgICAgICBkZWZhdWx0QWxpZ25tZW50OiAnc3RhcnQnLFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZEdsb2JhbEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZXM6IHRoaXMub3B0aW9ucy50eXBlcyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLmRlZmF1bHRBbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4gZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gfHwgdGhpcy5vcHRpb25zLmRlZmF1bHRBbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJIVE1MOiBhdHRyaWJ1dGVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy50ZXh0QWxpZ24gPT09IHRoaXMub3B0aW9ucy5kZWZhdWx0QWxpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0eWxlOiBgdGV4dC1hbGlnbjogJHthdHRyaWJ1dGVzLnRleHRBbGlnbn1gIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF1cbiAgICB9LFxuXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRUZXh0QWxpZ246IChhbGlnbm1lbnQpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGlnbm1lbnRzLmluY2x1ZGVzKGFsaWdubWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlcy5ldmVyeSh0eXBlID0+IGNvbW1hbmRzLnVwZGF0ZUF0dHJpYnV0ZXModHlwZSwgeyB0ZXh0QWxpZ246IGFsaWdubWVudCB9KSlcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHVuc2V0VGV4dEFsaWduOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlcy5ldmVyeSh0eXBlID0+IGNvbW1hbmRzLnJlc2V0QXR0cmlidXRlcyh0eXBlLCAndGV4dEFsaWduJykpXG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1TaGlmdC1sJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0VGV4dEFsaWduKCdzdGFydCcpLFxuICAgICAgICAgICAgJ01vZC1TaGlmdC1lJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0VGV4dEFsaWduKCdjZW50ZXInKSxcbiAgICAgICAgICAgICdNb2QtU2hpZnQtcic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFRleHRBbGlnbignZW5kJyksXG4gICAgICAgICAgICAnTW9kLVNoaWZ0LWonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRUZXh0QWxpZ24oJ2p1c3RpZnknKSxcbiAgICAgICAgfVxuICAgIH0sXG59KVxuIiwgImltcG9ydCB7XG4gIGdldE1hcmtBdHRyaWJ1dGVzLFxuICBNYXJrLFxuICBtZXJnZUF0dHJpYnV0ZXMsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBUZXh0U3R5bGVPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHNwYW5zIHdpdGhvdXQgaW5saW5lIHN0eWxlIGF0dHJpYnV0ZXMuXG4gICAgICAgKi9cbiAgICAgIHJlbW92ZUVtcHR5VGV4dFN0eWxlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgVGV4dFN0eWxlID0gTWFyay5jcmVhdGU8VGV4dFN0eWxlT3B0aW9ucz4oe1xuICBuYW1lOiAndGV4dFN0eWxlJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdzcGFuJyxcbiAgICAgICAgZ2V0QXR0cnM6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IGhhc1N0eWxlcyA9IChlbGVtZW50IGFzIEhUTUxFbGVtZW50KS5oYXNBdHRyaWJ1dGUoJ3N0eWxlJylcblxuICAgICAgICAgIGlmICghaGFzU3R5bGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge31cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnc3BhbicsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlRW1wdHlUZXh0U3R5bGU6ICgpID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdGhpcy50eXBlKVxuICAgICAgICBjb25zdCBoYXNTdHlsZXMgPSBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5zb21lKChbLCB2YWx1ZV0pID0+ICEhdmFsdWUpXG5cbiAgICAgICAgaWYgKGhhc1N0eWxlcykge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG59KVxuIiwgImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbz1lLmxlbmd0aDtmb3IodD0wO3Q8bzt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpfWVsc2UgZm9yKGYgaW4gZSllW2ZdJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCIsbz1hcmd1bWVudHMubGVuZ3RoO2Y8bztmKyspKGU9YXJndW1lbnRzW2ZdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7IiwgIjxzY3JpcHQ+XG4gICAgaW1wb3J0IGN4IGZyb20gJ2Nsc3gnXG5cbiAgICBleHBvcnQgbGV0IGVkaXRvclxuICAgIGV4cG9ydCBsZXQga2V5XG48L3NjcmlwdD5cblxueyNpZiBlZGl0b3J9XG48YnV0dG9uXG4gICAgdHlwZT1cImJ1dHRvblwiXG4gICAgY2xhc3M6YWN0aXZlPXtlZGl0b3IuaXNBY3RpdmUoa2V5KX1cbiAgICBvbjpjbGlja1xuICAgIGNsYXNzPXtjeChcbiAgICAgICAgYHJvdW5kZWQtc20gcC0xIGJnLXRyYW5zcGFyZW50IGhvdmVyOnRleHQtcHJpbWFyeS01MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMSBmb2N1czpyaW5nLXByaW1hcnktNTAwICR7a2V5fWAsXG4gICAgICAgIHtcbiAgICAgICAgICAgICd0ZXh0LWluaGVyaXQnOiAhZWRpdG9yLmlzQWN0aXZlKGtleSksXG4gICAgICAgICAgICAndGV4dC1wcmltYXJ5LTUwMCc6IGVkaXRvci5pc0FjdGl2ZShrZXkpXG4gICAgICAgIH1cbiAgICApfVxuPlxuICAgIDxzbG90IC8+XG48L2J1dHRvbj5cbnsvaWZ9XG4iLCAiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBOb2RlVmlld1dyYXBwZXIsIE5vZGVWaWV3Q29udGVudCB9IGZyb20gJ3N2ZWx0ZS10aXB0YXAnXG4gICAgaW1wb3J0IGN4IGZyb20gJ2Nsc3gnXG5cbiAgICBleHBvcnQgbGV0IGVkaXRvcjtcbiAgICBleHBvcnQgbGV0IHVwZGF0ZUF0dHJpYnV0ZXM7XG5cbiAgICBsZXQgc2VsZWN0ZWRDb2xvciA9ICdncmF5JztcbiAgICBsZXQgY29sb3JzID0gW1xuICAgICAgICB7a2V5OiAncHJpbWFyeScsIGxhYmVsOiAnUHJpbWFyeScgfSxcbiAgICAgICAge2tleTogJ3NlY29uZGFyeScsIGxhYmVsOiAnU2Vjb25kYXJ5JyB9LFxuICAgICAgICB7a2V5OiAndGVydGlhcnknLCBsYWJlbDogJ1RlcnRpYXJ5JyB9LFxuICAgICAgICB7a2V5OiAnYWNjZW50JywgbGFiZWw6ICdBY2NlbnQnIH0sXG4gICAgICAgIHtrZXk6ICdncmF5TGlnaHQnLCBsYWJlbDogJ0dyYXkgLSBMaWdodCcgfSxcbiAgICAgICAge2tleTogJ2dyYXknLCBsYWJlbDogJ0dyYXknIH0sXG4gICAgICAgIHtrZXk6ICdncmF5RGFyaycsIGxhYmVsOiAnR3JheSAtIERhcmsnIH0sXG4gICAgXVxuXG4gICAgY29uc3QgcmVtb3ZlQmxvY2sgPSAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5jb21tYW5kcy5kZWxldGVTZWxlY3Rpb24oKVxuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZUNvbG9yQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICB1cGRhdGVBdHRyaWJ1dGVzKHsgY29sb3I6IHNlbGVjdGVkQ29sb3IgfSlcbiAgICB9XG48L3NjcmlwdD5cblxuPE5vZGVWaWV3V3JhcHBlcj5cbiAgICA8ZGl2XG4gICAgICAgIGNsYXNzPXtjeChcbiAgICAgICAgICAgICdyZWxhdGl2ZSBncm91cCBwLTYnLFxuICAgICAgICAgICAgc2VsZWN0ZWRDb2xvclxuICAgICAgICApfVxuICAgID5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRyYW5zaXRpb24gcm91bmRlZC1tZCByZWxhdGl2ZVwiPlxuICAgICAgICAgICAgPE5vZGVWaWV3Q29udGVudCAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNjcmliYmxlLWJsb2NrLWFjdGlvbnMgdHJhbnNpdGlvbiBvcGFjaXR5LTAgYWJzb2x1dGUgei0yMCB0b3AtMCByaWdodC0wIHAtMSByb3VuZGVkLXRyLW1kIHJvdW5kZWQtYmwtbGcgZmxleCBpdGVtcy1jZW50ZXIgYmctZ3JheS05NTAgZ3JvdXAtaG92ZXI6b3BhY2l0eS0xMDBcIj5cbiAgICAgICAgICAgIDxkaXYgZGF0YS1kcmFnLWhhbmRsZSBjbGFzcz1cImN1cnNvci1ncmFiYmluZyB0ZXh0LXdoaXRlIGJsb2NrIHJvdW5kZWQgcC0xIGhvdmVyOnRleHQtcHJpbWFyeS01MDAgaG92ZXI6YmctZ3JheS04MDBcIj5cbiAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwic2l6ZS00XCI+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJtMjIuNjcgMTJsLTQuNDkgNC41bC0yLjUxLTIuNWwxLjk4LTJsLTEuOTgtMS45NmwyLjUxLTIuNTF6TTEyIDEuMzNsNC40NyA0LjQ5bC0yLjUxIDIuNTFMMTIgNi4zNWwtMiAxLjk4bC0yLjUtMi41MXptMCAyMS4zNGwtNC40Ny00LjQ5bDIuNTEtMi41MUwxMiAxNy42NWwyLTEuOThsMi41IDIuNTF6TTEuMzMgMTJsNC40OS00LjVMOC4zMyAxMGwtMS45OCAybDEuOTggMS45NmwtMi41MSAyLjUxek0xMiAxMGEyIDIgMCAwIDEgMiAyYTIgMiAwIDAgMS0yIDJhMiAyIDAgMCAxLTItMmEyIDIgMCAwIDEgMi0yXCIvPlxuICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8c2VsZWN0IG5hbWU9XCJiYWNrZ3JvdW5kQ29sb3JcIiBiaW5kOnZhbHVlPXtzZWxlY3RlZENvbG9yfSBvbjpjaGFuZ2U9e2hhbmRsZUNvbG9yQ2hhbmdlfSBjbGFzcz1cIlwiPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJudWxsXCI+Q29sb3I8L29wdGlvbj5cbiAgICAgICAgICAgICAgICB7I2VhY2ggY29sb3JzIGFzIGNvbG9yfVxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXtjb2xvci5rZXl9Pntjb2xvci5sYWJlbH08L29wdGlvbj5cbiAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDxidXR0b24gb246Y2xpY2t8cHJldmVudERlZmF1bHR8c3RvcFByb3BhZ2F0aW9uPXtyZW1vdmVCbG9ja30gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwidGV4dC13aGl0ZSBibG9jayByb3VuZGVkIHAtMSBob3Zlcjp0ZXh0LXByaW1hcnktNTAwIGhvdmVyOmJnLWdyYXktODAwXCI+XG4gICAgICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAxNiAxNlwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInNpemUtNFwiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk01IDMuMjVWNEgyLjc1YS43NS43NSAwIDAgMCAwIDEuNWguM2wuODE1IDguMTVBMS41IDEuNSAwIDAgMCA1LjM1NyAxNWg1LjI4NWExLjUgMS41IDAgMCAwIDEuNDkzLTEuMzVsLjgxNS04LjE1aC4zYS43NS43NSAwIDAgMCAwLTEuNUgxMXYtLjc1QTIuMjUgMi4yNSAwIDAgMCA4Ljc1IDFoLTEuNUEyLjI1IDIuMjUgMCAwIDAgNSAzLjI1Wm0yLjI1LS43NWEuNzUuNzUgMCAwIDAtLjc1Ljc1VjRoM3YtLjc1YS43NS43NSAwIDAgMC0uNzUtLjc1aC0xLjVaTTYuMDUgNmEuNzUuNzUgMCAwIDEgLjc4Ny43MTNsLjI3NSA1LjVhLjc1Ljc1IDAgMCAxLTEuNDk4LjA3NWwtLjI3NS01LjVBLjc1Ljc1IDAgMCAxIDYuMDUgNlptMy45IDBhLjc1Ljc1IDAgMCAxIC43MTIuNzg3bC0uMjc1IDUuNWEuNzUuNzUgMCAwIDEtMS40OTgtLjA3NWwuMjc1LTUuNWEuNzUuNzUgMCAwIDEgLjc4Ni0uNzExWlwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiAvPlxuICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9Ob2RlVmlld1dyYXBwZXI+XG4iLCAiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgU3ZlbHRlTm9kZVZpZXdSZW5kZXJlciB9IGZyb20gJ3N2ZWx0ZS10aXB0YXAnXG5pbXBvcnQgSGVyb1ZpZXcgZnJvbSAnLi4vY29tcG9uZW50cy9IZXJvVmlldy5zdmVsdGUnXG5cbmV4cG9ydCBjb25zdCBIZXJvRXh0ZW5zaW9uID0gTm9kZS5jcmVhdGUoe1xuICAgIG5hbWU6IFwiaGVyb1wiLFxuXG4gICAgZ3JvdXA6IFwiYmxvY2tcIixcblxuICAgIGNvbnRlbnQ6IFwiYmxvY2srXCIsXG5cbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sb3JzOiBbXG4gICAgICAgICAgICAgICAgJ2dyYXlMaWdodCcsXG4gICAgICAgICAgICAgICAgJ2dyYXknLFxuICAgICAgICAgICAgICAgICdncmF5RGFyaycsXG4gICAgICAgICAgICAgICAgJ3ByaW1hcnknLFxuICAgICAgICAgICAgICAgICdzZWNvbmRhcnknLFxuICAgICAgICAgICAgICAgICd0ZXJ0aWFyeScsXG4gICAgICAgICAgICAgICAgJ2FjY2VudCdcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBcImhlcm8tYmxvY2tcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICdwcmltYXJ5JyxcbiAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xvcicpLFxuICAgICAgICAgICAgICAgIHJlbmRlckhUTUw6IChhdHRyaWJ1dGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghIGF0dHJpYnV0ZXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtY29sb3InOiBhdHRyaWJ1dGVzLmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdkaXYnLFxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiAoZWxlbWVudCkgPT4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2hlcm8tYmxvY2snKVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcblxuICAgIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlc30pIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLFxuICAgICAgICAgICAgMFxuICAgICAgICBdXG4gICAgfSxcblxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9nZ2xlSGVybzogKGF0dHJpYnV0ZXMpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlV3JhcCh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkTm9kZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBTdmVsdGVOb2RlVmlld1JlbmRlcmVyKEhlcm9WaWV3KVxuICAgIH1cbn0pXG4iLCAiPHNjcmlwdD5cbiAgICBpbXBvcnQge29uTW91bnQsIG9uRGVzdHJveX0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSAnc3ZlbHRlL3N0b3JlJ1xuICAgIGltcG9ydCB7IEVkaXRvciB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbiAgICBpbXBvcnQgeyBCdWJibGVNZW51IH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tYnViYmxlLW1lbnUnXG4gICAgaW1wb3J0IHsgQ2xhc3NFeHRlbnNpb24gfSBmcm9tICcuL2V4dGVuc2lvbnMvQ2xhc3NFeHRlbnNpb24uanMnXG4gICAgaW1wb3J0IHsgSWRFeHRlbnNpb24gfSBmcm9tICcuL2V4dGVuc2lvbnMvSWRFeHRlbnNpb24uanMnXG4gICAgaW1wb3J0IHsgTGlua0V4dGVuc2lvbiB9IGZyb20gJy4vZXh0ZW5zaW9ucy9MaW5rRXh0ZW5zaW9uLmpzJ1xuICAgIGltcG9ydCB7IE1lZGlhRXh0ZW5zaW9uIH0gZnJvbSAnLi9leHRlbnNpb25zL01lZGlhRXh0ZW5zaW9uLmpzJ1xuICAgIGltcG9ydCB7IFBsYWNlaG9sZGVyIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tcGxhY2Vob2xkZXInXG4gICAgaW1wb3J0IFN0YXJ0ZXJLaXQgZnJvbSAnQHRpcHRhcC9zdGFydGVyLWtpdCc7XG4gICAgaW1wb3J0IFNjcmliYmxlQmxvY2sgZnJvbSAnLi9leHRlbnNpb25zL1NjcmliYmxlQmxvY2snO1xuICAgIGltcG9ydCBTbGFzaEV4dGVuc2lvbiBmcm9tICcuL2V4dGVuc2lvbnMvU2xhc2hFeHRlbnNpb24uanMnXG4gICAgaW1wb3J0IHsgU3Vic2NyaXB0IH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tc3Vic2NyaXB0J1xuICAgIGltcG9ydCB7IFN1cGVyc2NyaXB0IH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tc3VwZXJzY3JpcHQnXG4gICAgaW1wb3J0IHsgVGV4dEFsaWduIH0gZnJvbSAnLi9leHRlbnNpb25zL1RleHRBbGlnbkV4dGVuc2lvbi5qcydcbiAgICBpbXBvcnQgeyBUZXh0U3R5bGUgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tdGV4dC1zdHlsZVwiXG4gICAgaW1wb3J0IEJ1dHRvbiBmcm9tICcuL2NvbXBvbmVudHMvQnV0dG9uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgeyBwb3VuY2UgfSBmcm9tICcuL3V0aWxzL3BvdW5jZS5qcydcbiAgICBpbXBvcnQgeyBnZXRTdGF0ZVBhdGggfSBmcm9tICcuL3N0b3Jlcy5qcydcbiAgICBpbXBvcnQgeyBIZXJvRXh0ZW5zaW9uIH0gZnJvbSAnLi9leHRlbnNpb25zL0hlcm9FeHRlbnNpb24uanMnXG5cbiAgICBsZXQgZWRpdG9yO1xuICAgIGxldCBlbGVtZW50O1xuICAgIGxldCBidWJibGVNZW51RWxlbWVudDtcbiAgICBsZXQgYnViYmxlVG9vbHM7XG4gICAgbGV0IHN1Z2dlc3Rpb25Ub29scztcblxuICAgIGV4cG9ydCBsZXQgdG9vbHM7XG4gICAgZXhwb3J0IGxldCBjb250ZW50O1xuICAgIGV4cG9ydCBsZXQgc3RhdGVQYXRoO1xuICAgIGV4cG9ydCBsZXQgcGxhY2Vob2xkZXI7XG5cbiAgICAkZ2V0U3RhdGVQYXRoID0gc3RhdGVQYXRoXG5cbiAgICBjb25zdCBjb250ZW50U3RvcmUgPSB3cml0YWJsZShjb250ZW50KTtcblxuICAgIGJ1YmJsZVRvb2xzID0gdG9vbHMuZmlsdGVyKCh0b29sKSA9PiB0b29sLmJ1YmJsZSA9PT0gdHJ1ZSlcbiAgICBzdWdnZXN0aW9uVG9vbHMgPSB0b29scy5maWx0ZXIoKHRvb2wpID0+IHRvb2wuc3VnZ2VzdGlvbiA9PT0gdHJ1ZSlcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBlZGl0b3IgPSBuZXcgRWRpdG9yKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgZXh0ZW5zaW9uczogW1xuICAgICAgICAgICAgICAgIFN0YXJ0ZXJLaXQsXG4gICAgICAgICAgICAgICAgQ2xhc3NFeHRlbnNpb24sXG4gICAgICAgICAgICAgICAgTGlua0V4dGVuc2lvbixcbiAgICAgICAgICAgICAgICBJZEV4dGVuc2lvbixcbiAgICAgICAgICAgICAgICBTY3JpYmJsZUJsb2NrLFxuICAgICAgICAgICAgICAgIFN1YnNjcmlwdCxcbiAgICAgICAgICAgICAgICBTdXBlcnNjcmlwdCxcbiAgICAgICAgICAgICAgICBNZWRpYUV4dGVuc2lvbixcbiAgICAgICAgICAgICAgICBIZXJvRXh0ZW5zaW9uLFxuICAgICAgICAgICAgICAgIFRleHRBbGlnbi5jb25maWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlczogWydoZWFkaW5nJywgJ3BhcmFncmFwaCddXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgVGV4dFN0eWxlLFxuICAgICAgICAgICAgICAgIFNsYXNoRXh0ZW5zaW9uLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xzOiBzdWdnZXN0aW9uVG9vbHNcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBCdWJibGVNZW51LmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGJ1YmJsZU1lbnVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB0aXBweU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6ICd0b3Atc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWU6ICdzY3JpYmJsZS1idWJibGUnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzaG91bGRTaG93OiAoeyBlZGl0b3IsIGZyb20sIHRvIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID09PSB0byAmJiBlZGl0b3IuaXNBY3RpdmUoJ2xpbmsnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tICE9PSB0byAmJiAhIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuaXNBY3RpdmUoJ2ltYWdlJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuaXNBY3RpdmUoJ3NjcmliYmxlQmxvY2snKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5pc0FjdGl2ZSgnc2xhc2hFeHRlbnNpb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIFBsYWNlaG9sZGVyLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlFZGl0b3JDbGFzczogJ2lzLWVkaXRvci1lbXB0eScsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgb25UcmFuc2FjdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGVkaXRvciA9IGVkaXRvclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uVXBkYXRlKHtlZGl0b3J9KSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCd1cGRhdGVkRWRpdG9yJywge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlUGF0aDogc3RhdGVQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogZWRpdG9yLmdldEpTT04oKSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIGNvbnRlbnRTdG9yZS5zZXQoZWRpdG9yLmdldEhUTUwoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgIH0pXG5cbiAgICBvbkRlc3Ryb3koKCkgPT4ge1xuICAgICAgICBlZGl0b3IuZGVzdHJveSgpXG4gICAgfSlcblxuICAgIGNvbnN0IHRvZ2dsZUZ1bGxzY3JlZW4gPSAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgndG9nZ2xlLWZ1bGxzY3JlZW4nLCB7IGRldGFpbDogeyBzdGF0ZVBhdGg6IHN0YXRlUGF0aCB9IH0pKVxuICAgICAgICBlZGl0b3IuY29tbWFuZHMuZm9jdXMoKVxuICAgIH1cblxuICAgICQ6IGlzQWN0aXZlID0gKG5hbWUsIGF0dHJzID0ge30pID0+IGVkaXRvci5pc0FjdGl2ZShuYW1lLCBhdHRycyk7XG5cbiAgICB0b29scy5mb3JFYWNoKHRvb2wgPT4ge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihgaW5zZXJ0LSR7dG9vbC5leHRlbnNpb259YCwgZGF0YSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YS5kZXRhaWwuc3RhdGVQYXRoICE9PSBzdGF0ZVBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvb2wuZXh0ZW5zaW9uID09PSAnbGluaycpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuY2hhaW4oKS5mb2N1cygpLmV4dGVuZE1hcmtSYW5nZSgnbGluaycpLnNldExpbmsoZGF0YS5kZXRhaWwuZGF0YSkuc2VsZWN0VGV4dGJsb2NrRW5kKCkucnVuKClcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvb2wuZXh0ZW5zaW9uID09PSAnbWVkaWEnKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmNoYWluKCkuZm9jdXMoKS5zZXRJbWFnZShkYXRhLmRldGFpbC5kYXRhKS5ydW4oKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9vbC50eXBlID09PSAnYmxvY2snKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmNoYWluKCkuaW5zZXJ0U2NyaWJibGVCbG9jayh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRvb2wuaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXRoOiB0b29sLnN0YXRlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBkYXRhLmRldGFpbC5kYXRhXG4gICAgICAgICAgICAgICAgfSkuZm9jdXMoKS5ydW4oKTtcblxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlZGl0b3IuY2hhaW4oKS5mb2N1cygpW3Rvb2wuY29tbWFuZF0oZGF0YS5kZXRhaWwuZGF0YSkucnVuKClcbiAgICAgICAgfSlcblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihgdXBkYXRlLSR7dG9vbC5leHRlbnNpb259YCwgZGF0YSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YS5kZXRhaWwuc3RhdGVQYXRoICE9PSBzdGF0ZVBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvb2wuZXh0ZW5zaW9uID09PSAnbGluaycpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuY2hhaW4oKS5mb2N1cygpLmV4dGVuZE1hcmtSYW5nZSgnbGluaycpLnNldExpbmsoZGF0YS5kZXRhaWwuZGF0YSkuc2VsZWN0VGV4dGJsb2NrRW5kKCkucnVuKClcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvb2wuZXh0ZW5zaW9uID09PSAnbWVkaWEnKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmNoYWluKCkuZm9jdXMoKS5zZXRJbWFnZShkYXRhLmRldGFpbC5kYXRhKS5ydW4oKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9vbC50eXBlID09PSAnYmxvY2snKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCd1cGRhdGVkQmxvY2snLCB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9vbC5pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXRoOiB0b29sLnN0YXRlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogZGF0YS5kZXRhaWwuZGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVkaXRvci5jaGFpbigpLmZvY3VzKClbdG9vbC5jb21tYW5kXShkYXRhLmRldGFpbC5kYXRhKS5ydW4oKVxuICAgICAgICB9KVxuICAgIH0pXG5cbiAgICBjb25zdCBoYW5kbGVUb29sQ2xpY2sgPSAodG9vbCkgPT4ge1xuXG4gICAgICAgIGlmICh0b29sLnR5cGUgPT09ICdibG9jaycgJiYgdG9vbC5wcmVyZW5kZXIpIHtcbiAgICAgICAgICAgIGVkaXRvci5jaGFpbigpLmluc2VydFNjcmliYmxlQmxvY2soe1xuICAgICAgICAgICAgICAgIHR5cGU6IHRvb2wuaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBzdGF0ZVBhdGg6IHRvb2wuc3RhdGVQYXRoLFxuICAgICAgICAgICAgICAgIHZhbHVlczoge31cbiAgICAgICAgICAgIH0pLmZvY3VzKCkucnVuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRvb2wudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY29tbWFuZCc6IGVkaXRvci5jaGFpbigpLmZvY3VzKClbdG9vbC5jb21tYW5kXSh0b29sLmNvbW1hbmRBcmd1bWVudHMpLnJ1bigpOyByZXR1cm5cbiAgICAgICAgICAgIGNhc2UgJ21vZGFsJzogcG91bmNlKHRvb2wuaWRlbnRpZmllciwgeyBzdGF0ZVBhdGg6IHRvb2wuc3RhdGVQYXRoLCAuLi5lZGl0b3IuZ2V0QXR0cmlidXRlcyh0b29sLmV4dGVuc2lvbikgfSk7IHJldHVyblxuICAgICAgICAgICAgZGVmYXVsdDogZWRpdG9yLmNvbW1hbmRzLnNldFNjcmliYmxlQmxvY2soe1xuICAgICAgICAgICAgICAgIHR5cGU6IHRvb2wuaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBzdGF0ZVBhdGg6IHRvb2wuc3RhdGVQYXRoLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwic2NyaWJibGUtZWRpdG9yLXdyYXBwZXIgdy1mdWxsXCI+XG4gICAgeyNpZiBlZGl0b3J9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzY3JpYmJsZS1jb250cm9sc1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNjcmliYmxlLWNvbnRyb2xzLXBhbmVsIGlubGluZS1mbGV4IHB4LTIgaXRlbXMtY2VudGVyIHJvdW5kZWQtZnVsbCBib3JkZXIgYm9yZGVyLWdyYXktOTUwLzEwIGRhcms6Ym9yZGVyLXdoaXRlLzIwIHNoYWRvdy1tZFwiPlxuICAgICAgICAgICAgICAgIDxCdXR0b24ge2VkaXRvcn0ga2V5PVwidW5kb1wiIG9uOmNsaWNrPXsoKSA9PiBlZGl0b3IuY2hhaW4oKS5mb2N1cygpLnVuZG8oKS5ydW4oKX0+XG4gICAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3M9XCJzaXplLTVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCA1MTIgNTEyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMzJcIiBkPVwiTTI0MCA0MjR2LTk2YzExNi40IDAgMTU5LjM5IDMzLjc2IDIwOCA5NmMwLTExOS4yMy0zOS41Ny0yNDAtMjA4LTI0MFY4OEw2NCAyNTZaXCIvPlxuICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICA8QnV0dG9uIHtlZGl0b3J9IGtleT1cInJlZG9cIiBvbjpjbGljaz17KCkgPT4gZWRpdG9yLmNoYWluKCkuZm9jdXMoKS5yZWRvKCkucnVuKCl9PlxuICAgICAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzPVwic2l6ZS01XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjMyXCIgZD1cIk00NDggMjU2TDI3MiA4OHY5NkMxMDMuNTcgMTg0IDY0IDMwNC43NyA2NCA0MjRjNDguNjEtNjIuMjQgOTEuNi05NiAyMDgtOTZ2OTZaXCIvPlxuICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICA8QnV0dG9uIHtlZGl0b3J9IGtleT1cImNsZWFyXCIgb246Y2xpY2s9eygpID0+IGVkaXRvci5jaGFpbigpLmZvY3VzKCkuY2xlYXJDb250ZW50KHRydWUpLnJ1bigpfT5cbiAgICAgICAgICAgICAgICAgICAgPHN2ZyBjbGFzcz1cInNpemUtNVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cIk0xMy45OTk5IDE4Ljk5NjdIMjAuOTk5OVYyMC45OTY3SDExLjk5OTlMOC4wMDIyOSAyMC45OTkyTDEuNTE0NTcgMTQuNTExNUMxLjEyNDA1IDE0LjEyMDkgMS4xMjQwNSAxMy40ODc4IDEuNTE0NTcgMTMuMDk3MkwxMi4xMjEyIDIuNDkwNjVDMTIuNTExNyAyLjEwMDEyIDEzLjE0NDkgMi4xMDAxMiAxMy41MzU0IDIuNDkwNjVMMjEuMzEzNiAxMC4yNjg4QzIxLjcwNDEgMTAuNjU5MyAyMS43MDQxIDExLjI5MjUgMjEuMzEzNiAxMS42ODNMMTMuOTk5OSAxOC45OTY3Wk0xNS42NTY3IDE0LjUxMTVMMTkuMTkyMiAxMC45NzU5TDEyLjgyODMgNC42MTE5N0w5LjI5Mjc1IDguMTQ3NUwxNS42NTY3IDE0LjUxMTVaXCIvPlxuICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICA8QnV0dG9uIHtlZGl0b3J9IGtleT1cImVudGVyLWZ1bGxzY3JlZW5cIiBvbjpjbGljaz17dG9nZ2xlRnVsbHNjcmVlbn0+XG4gICAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3M9XCJzaXplLTVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGZpbGw9XCJub25lXCIgZD1cIk0wIDBoMjR2MjRIMHpcIi8+PHBhdGggZD1cIk0yMCAzaDJ2NmgtMlY1aC00VjNoNHpNNCAzaDR2Mkg0djRIMlYzaDJ6bTE2IDE2di00aDJ2NmgtNnYtMmg0ek00IDE5aDR2Mkgydi02aDJ2NHpcIi8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgIDxCdXR0b24ge2VkaXRvcn0ga2V5PVwiZXhpdC1mdWxsc2NyZWVuXCIgb246Y2xpY2s9e3RvZ2dsZUZ1bGxzY3JlZW59PlxuICAgICAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzPVwic2l6ZS01XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBmaWxsPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIvPjxwYXRoIGQ9XCJNMTggN2g0djJoLTZWM2gydjR6TTggOUgyVjdoNFYzaDJ2NnptMTAgOHY0aC0ydi02aDZ2MmgtNHpNOCAxNXY2SDZ2LTRIMnYtMmg2elwiLz5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgey9pZn1cbiAgICA8ZGl2IGNsYXNzPVwic2NyaWJibGUtZWRpdG9yXCIgYmluZDp0aGlzPXtlbGVtZW50fSAvPlxuICAgIDxkaXYgYmluZDp0aGlzPXtidWJibGVNZW51RWxlbWVudH0+XG4gICAgICAgIHsjaWYgZWRpdG9yfVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZsZXggaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICB7I2lmICFpc0FjdGl2ZSgnbGluaycpfVxuICAgICAgICAgICAgICAgIHsjZWFjaCBidWJibGVUb29scyBhcyB0b29sfVxuICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIHtlZGl0b3J9IGtleT17dG9vbC5leHRlbnNpb259IG9uOmNsaWNrPXsoKSA9PiBoYW5kbGVUb29sQ2xpY2sodG9vbCl9PlxuICAgICAgICAgICAgICAgICAgICAgICAge0BodG1sIHRvb2wuaWNvbn1cbiAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgezplbHNlIGlmIGlzQWN0aXZlKCdsaW5rJyl9XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJtYXgtdy14cyB0ZXh0LXNtIGxlYWRpbmctbm9uZSB0cnVuY2F0ZSBvdmVyZmxvdy1oaWRkZW4gd2hpdGVzcGFjZS1ub3dyYXBcIj57ZWRpdG9yLmdldEF0dHJpYnV0ZXMoJ2xpbmsnKS5ocmVmfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8QnV0dG9uIHtlZGl0b3J9IGtleT1cImVkaXRMaW5rXCIgb246Y2xpY2s9eygpID0+IGhhbmRsZVRvb2xDbGljayh0b29scy5maW5kKChpdGVtKSA9PiBpdGVtLmV4dGVuc2lvbiA9PT0gJ2xpbmsnKSl9PlxuICAgICAgICAgICAgICAgICAgICB7QGh0bWwgdG9vbHMuZmluZCgoaXRlbSkgPT4gaXRlbS5leHRlbnNpb24gPT09ICdsaW5rJyk/Lmljb259XG4gICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgPEJ1dHRvbiB7ZWRpdG9yfSBrZXk9XCJ1bnNldExpbmtcIiBvbjpjbGljaz17KCkgPT4gZWRpdG9yLmNoYWluKCkuZm9jdXMoKS5leHRlbmRNYXJrUmFuZ2UoJ2xpbmsnKS51bnNldExpbmsoKS5zZWxlY3RUZXh0YmxvY2tFbmQoKS5ydW4oKX0+XG4gICAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3M9XCJzaXplLTVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTcgMTdIMjJWMTlIMTlWMjJIMTdWMTdaTTcgN0gyVjVINVYySDdWN1pNMTguMzY0IDE1LjUzNTVMMTYuOTQ5NyAxNC4xMjEzTDE4LjM2NCAxMi43MDcxQzIwLjMxNjYgMTAuNzU0NSAyMC4zMTY2IDcuNTg4NjYgMTguMzY0IDUuNjM2MDRDMTYuNDExMyAzLjY4MzQyIDEzLjI0NTUgMy42ODM0MiAxMS4yOTI5IDUuNjM2MDRMOS44Nzg2OCA3LjA1MDI1TDguNDY0NDcgNS42MzYwNEw5Ljg3ODY4IDQuMjIxODNDMTIuNjEyMyAxLjQ4ODE2IDE3LjA0NDUgMS40ODgxNiAxOS43NzgyIDQuMjIxODNDMjIuNTExOCA2Ljk1NTUgMjIuNTExOCAxMS4zODc3IDE5Ljc3ODIgMTQuMTIxM0wxOC4zNjQgMTUuNTM1NVpNMTUuNTM1NSAxOC4zNjRMMTQuMTIxMyAxOS43NzgyQzExLjM4NzcgMjIuNTExOCA2Ljk1NTUgMjIuNTExOCA0LjIyMTgzIDE5Ljc3ODJDMS40ODgxNiAxNy4wNDQ1IDEuNDg4MTYgMTIuNjEyMyA0LjIyMTgzIDkuODc4NjhMNS42MzYwNCA4LjQ2NDQ3TDcuMDUwMjUgOS44Nzg2OEw1LjYzNjA0IDExLjI5MjlDMy42ODM0MiAxMy4yNDU1IDMuNjgzNDIgMTYuNDExMyA1LjYzNjA0IDE4LjM2NEM3LjU4ODY2IDIwLjMxNjYgMTAuNzU0NSAyMC4zMTY2IDEyLjcwNzEgMTguMzY0TDE0LjEyMTMgMTYuOTQ5N0wxNS41MzU1IDE4LjM2NFpNMTQuODI4NCA3Ljc1NzM2TDE2LjI0MjYgOS4xNzE1N0w5LjE3MTU3IDE2LjI0MjZMNy43NTczNiAxNC44Mjg0TDE0LjgyODQgNy43NTczNlpcIi8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICB7L2lmfVxuICAgIDwvZGl2PlxuPC9kaXY+XG4iLCAiaW1wb3J0IFNjcmliYmxlIGZyb20gJy4vU2NyaWJibGUuc3ZlbHRlJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzY3JpYmJsZSh0b29scywgc3RhdGUsIHN0YXRlUGF0aCwgcGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b29scyxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHN0YXRlUGF0aCxcbiAgICAgICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyID8/IFwicHJlc3MgJy8nIGZvciBibG9ja3NcIixcbiAgICAgICAgZnVsbHNjcmVlbjogZmFsc2UsXG5cbiAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpc1xuXG4gICAgICAgICAgICBuZXcgU2NyaWJibGUoe1xuICAgICAgICAgICAgICAgIHRhcmdldDogX3RoaXMuJHJvb3QsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHM6IF90aGlzLnRvb2xzLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBfdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXRoOiBfdGhpcy5zdGF0ZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBfdGhpcy5wbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZEVkaXRvcicsIGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLmRldGFpbC5zdGF0ZVBhdGggPT09IF90aGlzLnN0YXRlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9IGUuZGV0YWlsLmNvbnRlbnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuXG4gICAgICAgIHRvZ2dsZUZ1bGxzY3JlZW4oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5kZXRhaWwuc3RhdGVQYXRoICE9PSB0aGlzLnN0YXRlUGF0aCkgcmV0dXJuXG4gICAgICAgICAgICB0aGlzLmZ1bGxzY3JlZW4gPSAhdGhpcy5mdWxsc2NyZWVuXG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7OztBQUNPLFNBQVMsT0FBTztBQUFDO0FBV2pCLFNBQVMsT0FBTyxLQUFLLEtBQUs7QUFFaEMsYUFBVyxLQUFLO0FBQUssUUFBSSxDQUFDLElBQUksSUFBSSxDQUFDO0FBQ25DO0FBQUE7QUFBQSxJQUE2QjtBQUFBO0FBQzlCO0FBdUJPLFNBQVMsSUFBSUEsS0FBSTtBQUN2QixTQUFPQSxJQUFHO0FBQ1g7QUFFTyxTQUFTLGVBQWU7QUFDOUIsU0FBTyx1QkFBTyxPQUFPLElBQUk7QUFDMUI7QUFNTyxTQUFTLFFBQVEsS0FBSztBQUM1QixNQUFJLFFBQVEsR0FBRztBQUNoQjtBQU1PLFNBQVMsWUFBWSxPQUFPO0FBQ2xDLFNBQU8sT0FBTyxVQUFVO0FBQ3pCO0FBR08sU0FBUyxlQUFlLEdBQUcsR0FBRztBQUNw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SUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUNQO0FBRU8sSUFBSSxRQUFRO0FBQUEsRUFDakIsSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFB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Q0o7QUFDSjsiLAogICJuYW1lcyI6IFsiZm4iLCAiZm4iLCAia2V5cyIsICJlbGVtZW50IiwgImZuIiwgImVsZW1lbnQiLCAidGV4dCIsICJlbGVtZW50IiwgImVsZW1lbnQiLCAiZm4iLCAiZm4iLCAiZm4iLCAiZm4iLCAiZGV0YWNoIiwgInVwZGF0ZSIsICJpbnN0YW5jZSIsICJjcmVhdGVfZnJhZ21lbnQiLCAiY3JlYXRlX3Nsb3QiLCAiYXR0ciIsICJzdGFydCIsICJ1cGRhdGUiLCAiZm4iLCAic3Vic2NyaWJlIiwgInJ1biIsICJmb3VuZCIsICJtYXAiLCAiZnJvbSIsICJlbmQiLCAic3RhcnQiLCAidGV4dCIsICJmaXJzdCIsICJjb3B5IiwgImZvdW5kIiwgInJvdW5kIiwgIm9mZnNldCIsICJpbnNlcnQiLCAic2xpY2UiLCAibWFpbiIsICJkb2MiLCAiYmFzZSIsICJpIiwgIm1pbiIsICJtYXgiLCAidHlwZSIsICJuZmEiLCAiZWRnZSIsICJleHByIiwgImxvb3AiLCAibm9kZSIsICJzdGF0ZXMiLCAiZGVmYXVsdHMiLCAiYXR0ciIsICJtYXJrIiwgInIiLCAic3R5bGUiLCAid3JhcCIsICJ0b3AiLCAic3BhY2UiLCAib2Zmc2V0IiwgInN0YXJ0IiwgImVuZCIsICJkZWwiLCAiZnJvbSIsICJtYXAiLCAiZG9jIiwgInNsaWNlIiwgInBhcmVudCIsICJpbnNlcnQiLCAidHIiLCAiZm91bmQiLCAic3R5bGUiLCAiYmFzZSIsICJpbmRleCIsICJqb2luYWJsZSIsICJmaXJzdCIsICJ3cmFwIiwgIm1hdGNoZXMiLCAidG9wIiwgIm1hdGNoIiwgInR5cGUiLCAiY2xvc2UiLCAiYXR0ciIsICJUcmFuc2Zvcm1FcnJvciIsICJ0ciIsICJmcm9tIiwgImZvdW5kIiwgImRvYyIsICJ0ZXh0IiwgIm1hcCIsICJlbmQiLCAic2xpY2UiLCAiaW5zdGFuY2UiLCAiZnJvbSIsICJvZmZzZXQiLCAiZG9jIiwgInRvcCIsICJsZWZ0IiwgImVsZW1lbnQiLCAiZmlyc3QiLCAiY2hpbGRyZW4iLCAiZW5kIiwgImVudGVyIiwgImJhc2UiLCAid3JhcCIsICJ0ZXh0IiwgImNvcHkiLCAic3RhcnQiLCAiZm91bmQiLCAicHJlTWF0Y2giLCAibWF0Y2hlcyIsICJlbXB0eSIsICJ0ciIsICJzbGljZSIsICJkb20iLCAiZXZlbnQiLCAiaGFuZGxlcnMiLCAibm93IiwgImN1dCIsICJOb2RlVHlwZSIsICJyIiwgImkiLCAib2xkT2Zmc2V0IiwgInJlYWQiLCAiZmluZCIsICJhbmNob3IiLCAic2VsIiwgInVwZGF0ZSIsICJmcm9tIiwgImZvdW5kIiwgInByb3AiLCAib2Zmc2V0IiwgInRleHQiLCAidHIiLCAiYXR0ciIsICJtYWMiLCAiaWUiLCAibWFjIiwgInNoaWZ0IiwgIm1hcCIsICJjb3B5IiwgInRyIiwgImVtcHR5IiwgInRyIiwgImxpZnQiLCAiZmlyc3QiLCAiZW5kIiwgIndyYXAiLCAidHIiLCAic2V0QmxvY2tUeXBlIiwgImZyb20iLCAiY29tbWFuZHMiLCAibWFjIiwgIndyYXAiLCAidHIiLCAiZm91bmQiLCAiZmlyc3QiLCAidHIiLCAiZW5kIiwgInN0YXJ0IiwgInNsaWNlIiwgImRvYyIsICJ0ciIsICJjb21tYW5kIiwgInJ1biIsICJmbiIsICJleHRlbnNpb25zIiwgIl9hIiwgInRleHQiLCAiZmluZCIsICJmcm9tIiwgImNvbW1hbmRzIiwgIm1hdGNoZXMiLCAiaGFuZGxlcnMiLCAic3RhcnQiLCAiZW5kIiwgIm9uQ3JlYXRlIiwgIm9uRGVzdHJveSIsICJNYXJrIiwgInJhbmdlIiwgImNyZWF0ZVBhcmFncmFwaE5lYXIiLCAib3JpZ2luYWxDcmVhdGVQYXJhZ3JhcGhOZWFyIiwgImRlbGV0ZVJhbmdlIiwgImRlbGV0ZVNlbGVjdGlvbiIsICJvcmlnaW5hbERlbGV0ZVNlbGVjdGlvbiIsICJleGl0Q29kZSIsICJvcmlnaW5hbEV4aXRDb2RlIiwgImtleXMiLCAibWluIiwgIm1heCIsICJjaGlsZHJlbiIsICJzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCIsICJtYXAiLCAiam9pblVwIiwgIm9yaWdpbmFsSm9pblVwIiwgImpvaW5Eb3duIiwgIm9yaWdpbmFsSm9pbkRvd24iLCAiam9pbkJhY2t3YXJkIiwgIm9yaWdpbmFsSm9pbkJhY2t3YXJkIiwgImpvaW5Gb3J3YXJkIiwgIm9yaWdpbmFsSm9pbkZvcndhcmQiLCAibm9ybWFsaXplS2V5TmFtZSIsICJzaGlmdCIsICJlbXB0eSIsICJsaWZ0IiwgImlzQWN0aXZlIiwgIm9yaWdpbmFsTGlmdCIsICJsaWZ0RW1wdHlCbG9jayIsICJvcmlnaW5hbExpZnRFbXB0eUJsb2NrIiwgImxpZnRMaXN0SXRlbSIsICJvcmlnaW5hbExpZnRMaXN0SXRlbSIsICJuZXdsaW5lSW5Db2RlIiwgIm9yaWdpbmFsTmV3bGluZUluQ29kZSIsICJzZWxlY3RBbGwiLCAic2VsZWN0Tm9kZUJhY2t3YXJkIiwgIm9yaWdpbmFsU2VsZWN0Tm9kZUJhY2t3YXJkIiwgInNlbGVjdE5vZGVGb3J3YXJkIiwgIm9yaWdpbmFsU2VsZWN0Tm9kZUZvcndhcmQiLCAic2VsZWN0UGFyZW50Tm9kZSIsICJvcmlnaW5hbFNlbGVjdFBhcmVudE5vZGUiLCAic2VsZWN0VGV4dGJsb2NrRW5kIiwgIm9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrRW5kIiwgInNlbGVjdFRleHRibG9ja1N0YXJ0IiwgIm9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrU3RhcnQiLCAiZG9jdW1lbnQiLCAiZGVmYXVsdEJsb2NrQXQiLCAiZ2V0VGV4dCIsICJmcm9tIiwgIm5vZGUiLCAiZnJvbSIsICJkb2MiLCAiZW1wdHkiLCAiZnJvbSIsICJyYW5nZSIsICJleHRlbnNpb25zIiwgImZyb20iLCAic3RhcnQiLCAiZW5kIiwgInRvcCIsICJib3R0b20iLCAibGVmdCIsICJyaWdodCIsICJ0ciIsICJlbXB0eSIsICJjb21tYW5kcyIsICJzZXRCbG9ja1R5cGUiLCAiZG9jIiwgInNpbmtMaXN0SXRlbSIsICJvcmlnaW5hbFNpbmtMaXN0SXRlbSIsICJzcGxpdEJsb2NrIiwgImRlZmF1bHRCbG9ja0F0IiwgImZpcnN0IiwgIndyYXAiLCAibmV3TmV4dFR5cGVBdHRyaWJ1dGVzIiwgIm5leHRUeXBlIiwgImlzQWN0aXZlIiwgIndyYXBJbiIsICJvcmlnaW5hbFdyYXBJbiIsICJ3cmFwSW5MaXN0IiwgIm9yaWdpbmFsV3JhcEluTGlzdCIsICJzdHlsZSIsICJmbiIsICJmb2N1cyIsICJibHVyIiwgImdldFRleHQiLCAib2Zmc2V0IiwgInRyIiwgIk1hcmsiLCAicmVtb3ZlTWFyayIsICJOb2RlIiwgImZyb20iLCAiZWxlbWVudCIsICJzdHlsZSIsICJlbGVtZW50IiwgIm5hbWUiLCAiZWxlbWVudCIsICJjbGllbnRSZWN0IiwgImVsZW1lbnQiLCAiY2xpZW50UmVjdCIsICJnZXRDb21wdXRlZFN0eWxlIiwgImVsZW1lbnQiLCAiZWxlbWVudCIsICJlbGVtZW50IiwgImVsZW1lbnQiLCAiZWxlbWVudCIsICJnZXRDb21wdXRlZFN0eWxlIiwgIndpbmRvdyIsICJtaW4iLCAibWF4IiwgImtleXMiLCAidG9QYWRkaW5nT2JqZWN0IiwgInBvcHBlck9mZnNldHMiLCAibWluIiwgIm1heCIsICJvZmZzZXQiLCAiZWZmZWN0IiwgInBvcHBlciIsICJnZXRDb21wdXRlZFN0eWxlIiwgImVmZmVjdCIsICJpbnN0YW5jZSIsICJ3aW5kb3ciLCAiaGFzaCIsICJlbGVtZW50IiwgImVsZW1lbnQiLCAiZWxlbWVudCIsICJnZXRDb21wdXRlZFN0eWxlIiwgImVsZW1lbnQiLCAiZ2V0Q29tcHV0ZWRTdHlsZSIsICJlbGVtZW50IiwgImVsZW1lbnQiLCAiY2xpcHBpbmdQYXJlbnRzIiwgImdldENvbXB1dGVkU3R5bGUiLCAicmVmZXJlbmNlIiwgImVsZW1lbnQiLCAiZWxlbWVudCIsICJwb3BwZXJPZmZzZXRzIiwgIm9mZnNldCIsICJwbGFjZW1lbnRzIiwgInBsYWNlbWVudCIsICJwbGFjZW1lbnRzIiwgInBsYWNlbWVudCIsICJfbG9vcCIsICJfaSIsICJjaGVja3MiLCAib2Zmc2V0IiwgInBvcHBlck9mZnNldHMiLCAib2Zmc2V0IiwgIm1pbiIsICJtYXgiLCAiZWxlbWVudCIsICJlbGVtZW50IiwgIm1vZGlmaWVycyIsICJtYXAiLCAiZm4iLCAibW9kaWZpZXJzIiwgIm1lcmdlZCIsICJlbGVtZW50IiwgImRlZmF1bHRNb2RpZmllcnMiLCAiY3JlYXRlUG9wcGVyIiwgInJlZmVyZW5jZSIsICJwb3BwZXIiLCAiaW5zdGFuY2UiLCAib3B0aW9ucyIsICJmbiIsICJzdGF0ZSIsICJlZmZlY3QiLCAibm9vcEZuIiwgIkJPWF9DTEFTUyIsICJDT05URU5UX0NMQVNTIiwgIkJBQ0tEUk9QX0NMQVNTIiwgIkFSUk9XX0NMQVNTIiwgIlNWR19BUlJPV19DTEFTUyIsICJUT1VDSF9PUFRJT05TIiwgInBhc3NpdmUiLCAiY2FwdHVyZSIsICJUSVBQWV9ERUZBVUxUX0FQUEVORF9UTyIsICJkb2N1bWVudCIsICJib2R5IiwgImhhc093blByb3BlcnR5IiwgIm9iaiIsICJrZXkiLCAiY2FsbCIsICJnZXRWYWx1ZUF0SW5kZXhPclJldHVybiIsICJ2YWx1ZSIsICJpbmRleCIsICJkZWZhdWx0VmFsdWUiLCAiQXJyYXkiLCAiaXNBcnJheSIsICJ2IiwgImlzVHlwZSIsICJ0eXBlIiwgInN0ciIsICJ0b1N0cmluZyIsICJpbmRleE9mIiwgImludm9rZVdpdGhBcmdzT3JSZXR1cm4iLCAiYXJncyIsICJkZWJvdW5jZSIsICJmbiIsICJtcyIsICJ0aW1lb3V0IiwgImFyZyIsICJjbGVhclRpbWVvdXQiLCAic2V0VGltZW91dCIsICJyZW1vdmVQcm9wZXJ0aWVzIiwgImtleXMiLCAiY2xvbmUiLCAiZm9yRWFjaCIsICJzcGxpdEJ5U3BhY2VzIiwgInNwbGl0IiwgImZpbHRlciIsICJCb29sZWFuIiwgIm5vcm1hbGl6ZVRvQXJyYXkiLCAiY29uY2F0IiwgInB1c2hJZlVuaXF1ZSIsICJhcnIiLCAicHVzaCIsICJ1bmlxdWUiLCAiaXRlbSIsICJnZXRCYXNlUGxhY2VtZW50IiwgInBsYWNlbWVudCIsICJhcnJheUZyb20iLCAic2xpY2UiLCAicmVtb3ZlVW5kZWZpbmVkUHJvcHMiLCAiT2JqZWN0IiwgInJlZHVjZSIsICJhY2MiLCAidW5kZWZpbmVkIiwgImRpdiIsICJjcmVhdGVFbGVtZW50IiwgImlzRWxlbWVudCIsICJzb21lIiwgImlzTm9kZUxpc3QiLCAiaXNNb3VzZUV2ZW50IiwgImlzUmVmZXJlbmNlRWxlbWVudCIsICJfdGlwcHkiLCAicmVmZXJlbmNlIiwgImdldEFycmF5T2ZFbGVtZW50cyIsICJxdWVyeVNlbGVjdG9yQWxsIiwgInNldFRyYW5zaXRpb25EdXJhdGlvbiIsICJlbHMiLCAiZWwiLCAic3R5bGUiLCAidHJhbnNpdGlvbkR1cmF0aW9uIiwgInNldFZpc2liaWxpdHlTdGF0ZSIsICJzdGF0ZSIsICJzZXRBdHRyaWJ1dGUiLCAiZ2V0T3duZXJEb2N1bWVudCIsICJlbGVtZW50T3JFbGVtZW50cyIsICJlbGVtZW50IiwgIm93bmVyRG9jdW1lbnQiLCAiaXNDdXJzb3JPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIiLCAicG9wcGVyVHJlZURhdGEiLCAiZXZlbnQiLCAiY2xpZW50WCIsICJjbGllbnRZIiwgImV2ZXJ5IiwgInBvcHBlclJlY3QiLCAicG9wcGVyU3RhdGUiLCAicHJvcHMiLCAiaW50ZXJhY3RpdmVCb3JkZXIiLCAiYmFzZVBsYWNlbWVudCIsICJvZmZzZXREYXRhIiwgIm1vZGlmaWVyc0RhdGEiLCAib2Zmc2V0IiwgInRvcERpc3RhbmNlIiwgInRvcCIsICJ5IiwgImJvdHRvbURpc3RhbmNlIiwgImJvdHRvbSIsICJsZWZ0RGlzdGFuY2UiLCAibGVmdCIsICJ4IiwgInJpZ2h0RGlzdGFuY2UiLCAicmlnaHQiLCAiZXhjZWVkc1RvcCIsICJleGNlZWRzQm90dG9tIiwgImV4Y2VlZHNMZWZ0IiwgImV4Y2VlZHNSaWdodCIsICJ1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIiLCAiYm94IiwgImFjdGlvbiIsICJsaXN0ZW5lciIsICJtZXRob2QiLCAiYWN0dWFsQ29udGFpbnMiLCAicGFyZW50IiwgImNoaWxkIiwgInRhcmdldCIsICJjb250YWlucyIsICJnZXRSb290Tm9kZSIsICJob3N0IiwgImN1cnJlbnRJbnB1dCIsICJpc1RvdWNoIiwgImxhc3RNb3VzZU1vdmVUaW1lIiwgIm9uRG9jdW1lbnRUb3VjaFN0YXJ0IiwgIndpbmRvdyIsICJwZXJmb3JtYW5jZSIsICJhZGRFdmVudExpc3RlbmVyIiwgIm9uRG9jdW1lbnRNb3VzZU1vdmUiLCAibm93IiwgInJlbW92ZUV2ZW50TGlzdGVuZXIiLCAib25XaW5kb3dCbHVyIiwgImFjdGl2ZUVsZW1lbnQiLCAiaW5zdGFuY2UiLCAiYmx1ciIsICJpc1Zpc2libGUiLCAiYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzIiwgImlzQnJvd3NlciIsICJpc0lFMTEiLCAibXNDcnlwdG8iLCAiY3JlYXRlTWVtb3J5TGVha1dhcm5pbmciLCAidHh0IiwgImpvaW4iLCAiY2xlYW4iLCAic3BhY2VzQW5kVGFicyIsICJsaW5lU3RhcnRXaXRoU3BhY2VzIiwgInJlcGxhY2UiLCAidHJpbSIsICJnZXREZXZNZXNzYWdlIiwgIm1lc3NhZ2UiLCAiZ2V0Rm9ybWF0dGVkTWVzc2FnZSIsICJ2aXNpdGVkTWVzc2FnZXMiLCAicmVzZXRWaXNpdGVkTWVzc2FnZXMiLCAiU2V0IiwgIndhcm5XaGVuIiwgImNvbmRpdGlvbiIsICJoYXMiLCAiYWRkIiwgImNvbnNvbGUiLCAid2FybiIsICJlcnJvcldoZW4iLCAiZXJyb3IiLCAidmFsaWRhdGVUYXJnZXRzIiwgInRhcmdldHMiLCAiZGlkUGFzc0ZhbHN5VmFsdWUiLCAiZGlkUGFzc1BsYWluT2JqZWN0IiwgInByb3RvdHlwZSIsICJTdHJpbmciLCAicGx1Z2luUHJvcHMiLCAiYW5pbWF0ZUZpbGwiLCAiZm9sbG93Q3Vyc29yIiwgImlubGluZVBvc2l0aW9uaW5nIiwgInN0aWNreSIsICJyZW5kZXJQcm9wcyIsICJhbGxvd0hUTUwiLCAiYW5pbWF0aW9uIiwgImFycm93IiwgImNvbnRlbnQiLCAiaW5lcnRpYSIsICJtYXhXaWR0aCIsICJyb2xlIiwgInRoZW1lIiwgInpJbmRleCIsICJkZWZhdWx0UHJvcHMiLCAiYXBwZW5kVG8iLCAiYXJpYSIsICJleHBhbmRlZCIsICJkZWxheSIsICJkdXJhdGlvbiIsICJnZXRSZWZlcmVuY2VDbGllbnRSZWN0IiwgImhpZGVPbkNsaWNrIiwgImlnbm9yZUF0dHJpYnV0ZXMiLCAiaW50ZXJhY3RpdmUiLCAiaW50ZXJhY3RpdmVEZWJvdW5jZSIsICJtb3ZlVHJhbnNpdGlvbiIsICJvbkFmdGVyVXBkYXRlIiwgIm9uQmVmb3JlVXBkYXRlIiwgIm9uQ3JlYXRlIiwgIm9uRGVzdHJveSIsICJvbkhpZGRlbiIsICJvbkhpZGUiLCAib25Nb3VudCIsICJvblNob3ciLCAib25TaG93biIsICJvblRyaWdnZXIiLCAib25VbnRyaWdnZXIiLCAib25DbGlja091dHNpZGUiLCAicGx1Z2lucyIsICJwb3BwZXJPcHRpb25zIiwgInJlbmRlciIsICJzaG93T25DcmVhdGUiLCAidG91Y2giLCAidHJpZ2dlciIsICJ0cmlnZ2VyVGFyZ2V0IiwgImRlZmF1bHRLZXlzIiwgInNldERlZmF1bHRQcm9wcyIsICJwYXJ0aWFsUHJvcHMiLCAidmFsaWRhdGVQcm9wcyIsICJnZXRFeHRlbmRlZFBhc3NlZFByb3BzIiwgInBhc3NlZFByb3BzIiwgInBsdWdpbiIsICJuYW1lIiwgImdldERhdGFBdHRyaWJ1dGVQcm9wcyIsICJwcm9wS2V5cyIsICJ2YWx1ZUFzU3RyaW5nIiwgImdldEF0dHJpYnV0ZSIsICJKU09OIiwgInBhcnNlIiwgImUiLCAiZXZhbHVhdGVQcm9wcyIsICJvdXQiLCAicHJvcCIsICJub25QbHVnaW5Qcm9wcyIsICJkaWRQYXNzVW5rbm93blByb3AiLCAibGVuZ3RoIiwgImlubmVySFRNTCIsICJkYW5nZXJvdXNseVNldElubmVySFRNTCIsICJodG1sIiwgImNyZWF0ZUFycm93RWxlbWVudCIsICJjbGFzc05hbWUiLCAiYXBwZW5kQ2hpbGQiLCAic2V0Q29udGVudCIsICJ0ZXh0Q29udGVudCIsICJnZXRDaGlsZHJlbiIsICJwb3BwZXIiLCAiZmlyc3RFbGVtZW50Q2hpbGQiLCAiYm94Q2hpbGRyZW4iLCAiY2hpbGRyZW4iLCAiZmluZCIsICJub2RlIiwgImNsYXNzTGlzdCIsICJiYWNrZHJvcCIsICJvblVwZGF0ZSIsICJwcmV2UHJvcHMiLCAibmV4dFByb3BzIiwgInJlbW92ZUF0dHJpYnV0ZSIsICJyZW1vdmVDaGlsZCIsICIkJHRpcHB5IiwgImlkQ291bnRlciIsICJtb3VzZU1vdmVMaXN0ZW5lcnMiLCAibW91bnRlZEluc3RhbmNlcyIsICJjcmVhdGVUaXBweSIsICJzaG93VGltZW91dCIsICJoaWRlVGltZW91dCIsICJzY2hlZHVsZUhpZGVBbmltYXRpb25GcmFtZSIsICJpc1Zpc2libGVGcm9tQ2xpY2siLCAiZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24iLCAiZGlkVG91Y2hNb3ZlIiwgImlnbm9yZU9uRmlyc3RVcGRhdGUiLCAibGFzdFRyaWdnZXJFdmVudCIsICJjdXJyZW50VHJhbnNpdGlvbkVuZExpc3RlbmVyIiwgIm9uRmlyc3RVcGRhdGUiLCAibGlzdGVuZXJzIiwgImRlYm91bmNlZE9uTW91c2VNb3ZlIiwgIm9uTW91c2VNb3ZlIiwgImN1cnJlbnRUYXJnZXQiLCAiaWQiLCAicG9wcGVySW5zdGFuY2UiLCAiaXNFbmFibGVkIiwgImlzRGVzdHJveWVkIiwgImlzTW91bnRlZCIsICJpc1Nob3duIiwgImNsZWFyRGVsYXlUaW1lb3V0cyIsICJzZXRQcm9wcyIsICJzaG93IiwgImhpZGUiLCAiaGlkZVdpdGhJbnRlcmFjdGl2aXR5IiwgImVuYWJsZSIsICJkaXNhYmxlIiwgInVubW91bnQiLCAiZGVzdHJveSIsICJwbHVnaW5zSG9va3MiLCAibWFwIiwgImhhc0FyaWFFeHBhbmRlZCIsICJoYXNBdHRyaWJ1dGUiLCAiYWRkTGlzdGVuZXJzIiwgImhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSIsICJoYW5kbGVTdHlsZXMiLCAiaW52b2tlSG9vayIsICJzY2hlZHVsZVNob3ciLCAiZ2V0RG9jdW1lbnQiLCAiZ2V0Tm9ybWFsaXplZFRvdWNoU2V0dGluZ3MiLCAiZ2V0SXNDdXN0b21Ub3VjaEJlaGF2aW9yIiwgImdldElzRGVmYXVsdFJlbmRlckZuIiwgImdldEN1cnJlbnRUYXJnZXQiLCAicGFyZW50Tm9kZSIsICJnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbiIsICJnZXREZWxheSIsICJpc1Nob3ciLCAiZnJvbUhpZGUiLCAicG9pbnRlckV2ZW50cyIsICJob29rIiwgInNob3VsZEludm9rZVByb3BzSG9vayIsICJwbHVnaW5Ib29rcyIsICJoYW5kbGVBcmlhQ29udGVudEF0dHJpYnV0ZSIsICJhdHRyIiwgIm5vZGVzIiwgImN1cnJlbnRWYWx1ZSIsICJuZXh0VmFsdWUiLCAiY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMiLCAib25Eb2N1bWVudFByZXNzIiwgImFjdHVhbFRhcmdldCIsICJjb21wb3NlZFBhdGgiLCAicmVtb3ZlRG9jdW1lbnRQcmVzcyIsICJvblRvdWNoTW92ZSIsICJvblRvdWNoU3RhcnQiLCAiYWRkRG9jdW1lbnRQcmVzcyIsICJkb2MiLCAib25UcmFuc2l0aW9uZWRPdXQiLCAiY2FsbGJhY2siLCAib25UcmFuc2l0aW9uRW5kIiwgIm9uVHJhbnNpdGlvbmVkSW4iLCAib24iLCAiZXZlbnRUeXBlIiwgImhhbmRsZXIiLCAib3B0aW9ucyIsICJvbk1vdXNlTGVhdmUiLCAib25CbHVyT3JGb2N1c091dCIsICJyZW1vdmVMaXN0ZW5lcnMiLCAic2hvdWxkU2NoZWR1bGVDbGlja0hpZGUiLCAiaXNFdmVudExpc3RlbmVyU3RvcHBlZCIsICJ3YXNGb2N1c2VkIiwgInNjaGVkdWxlSGlkZSIsICJpc0N1cnNvck92ZXJSZWZlcmVuY2VPclBvcHBlciIsICJnZXROZXN0ZWRQb3BwZXJUcmVlIiwgImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsICJzaG91bGRCYWlsIiwgInJlbGF0ZWRUYXJnZXQiLCAiY3JlYXRlUG9wcGVySW5zdGFuY2UiLCAiZGVzdHJveVBvcHBlckluc3RhbmNlIiwgImNvbXB1dGVkUmVmZXJlbmNlIiwgImNvbnRleHRFbGVtZW50IiwgInRpcHB5TW9kaWZpZXIiLCAiZW5hYmxlZCIsICJwaGFzZSIsICJyZXF1aXJlcyIsICJhdHRyaWJ1dGVzIiwgIm1vZGlmaWVycyIsICJwYWRkaW5nIiwgImFkYXB0aXZlIiwgImNyZWF0ZVBvcHBlciIsICJtb3VudCIsICJuZXh0RWxlbWVudFNpYmxpbmciLCAidG91Y2hWYWx1ZSIsICJ0b3VjaERlbGF5IiwgInJlcXVlc3RBbmltYXRpb25GcmFtZSIsICJjYW5jZWxBbmltYXRpb25GcmFtZSIsICJuZXN0ZWRQb3BwZXIiLCAiZm9yY2VVcGRhdGUiLCAiaXNBbHJlYWR5VmlzaWJsZSIsICJpc0Rpc2FibGVkIiwgImlzVG91Y2hBbmRUb3VjaERpc2FibGVkIiwgInZpc2liaWxpdHkiLCAidHJhbnNpdGlvbiIsICJvZmZzZXRIZWlnaHQiLCAiaXNBbHJlYWR5SGlkZGVuIiwgImkiLCAidGlwcHkiLCAib3B0aW9uYWxQcm9wcyIsICJlbGVtZW50cyIsICJpc1NpbmdsZUNvbnRlbnRFbGVtZW50IiwgImlzTW9yZVRoYW5PbmVSZWZlcmVuY2VFbGVtZW50IiwgImluc3RhbmNlcyIsICJhcHBseVN0eWxlc01vZGlmaWVyIiwgImFwcGx5U3R5bGVzIiwgImVmZmVjdCIsICJzdGF0ZSIsICJpbml0aWFsU3R5bGVzIiwgInBvcHBlciIsICJwb3NpdGlvbiIsICJvcHRpb25zIiwgInN0cmF0ZWd5IiwgImxlZnQiLCAidG9wIiwgIm1hcmdpbiIsICJhcnJvdyIsICJyZWZlcmVuY2UiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJlbGVtZW50cyIsICJzdHlsZSIsICJzdHlsZXMiLCAidGlwcHkiLCAic2V0RGVmYXVsdFByb3BzIiwgInJlbmRlciIsICJlbGVtZW50IiwgInZpZXciLCAiZnJvbSIsICJkb2MiLCAiZW1wdHkiLCAic2hvdWxkU2hvdyIsICJlbGVtZW50IiwgImVsZW1lbnQiLCAiYXNzaWduIiwgIm5leHRTdGF0ZSIsICJhc3NpZ24iLCAicnVuJDEiLCAic3RhcnQiLCAiZmlyc3QiLCAibm9vcCIsICJzY2hlbWUiLCAiYXNzaWduIiwgInJ1biIsICJzdGFydCIsICJzY2hlbWUiLCAiaW5pdCIsICJydW4iLCAicnVuJDEiLCAidHIiLCAic2xpY2UiLCAiZW1wdHkiLCAiTWFyayIsICJ0ZXh0IiwgImVsZW1lbnQiLCAiTm9kZSIsICJjb21tYW5kcyIsICJlbGVtZW50IiwgImZyb20iLCAiY3R4IiwgImVsZW1lbnQiLCAiY3R4IiwgImNyZWF0ZV9keW5hbWljX2VsZW1lbnQiLCAiZWxlbWVudCIsICJjdHgiLCAidXBkYXRlQXR0cmlidXRlcyIsICJkb2MiLCAiaW5wdXRSZWdleCIsICJOb2RlIiwgImNvbW1hbmRzIiwgIk1hcmsiLCAiY29tbWFuZHMiLCAiTm9kZSIsICJNYXJrIiwgImVsZW1lbnQiLCAiY29tbWFuZHMiLCAiaW5wdXRSZWdleCIsICJpbnB1dFJlZ2V4IiwgIk1hcmsiLCAiY29tbWFuZHMiLCAiTm9kZSIsICJlbGVtZW50IiwgImNvbW1hbmRzIiwgImVtcHR5IiwgInRyIiwgImRvYyIsICJ0ZXh0IiwgIk5vZGUiLCAidG9wIiwgInJlY3QiLCAiZG9jIiwgImFycm93IiwgImluc2VydCIsICJ0ciIsICJOb2RlIiwgImNvbW1hbmRzIiwgInRyIiwgIk5vZGUiLCAiY29tbWFuZHMiLCAiUm9wZVNlcXVlbmNlIiwgImFwcGVuZCIsICJmcm9tIiwgImZvckVhY2giLCAiTGVhZiIsICJzdGFydCIsICJBcHBlbmQiLCAibGVmdCIsICJyaWdodCIsICJhcHBlbmRJbm5lciIsICJkaXN0X2RlZmF1bHQiLCAiZW5kIiwgIm1hcCIsICJmcm9tIiwgInN0YXJ0IiwgImRpc3RfZGVmYXVsdCIsICJoaXN0b3J5IiwgInRyIiwgInJlZG8iLCAidHIiLCAiY29tbWFuZCIsICJOb2RlIiwgInRyIiwgInN0YXJJbnB1dFJlZ2V4IiwgInN0YXJQYXN0ZVJlZ2V4IiwgInVuZGVyc2NvcmVJbnB1dFJlZ2V4IiwgInVuZGVyc2NvcmVQYXN0ZVJlZ2V4IiwgIk1hcmsiLCAiY29tbWFuZHMiLCAiTGlzdEl0ZW0iLCAiTm9kZSIsICJMaXN0SXRlbSIsICJOb2RlIiwgIlRleHRTdHlsZSIsICJNYXJrIiwgImVsZW1lbnQiLCAiY29tbWFuZHMiLCAiaW5wdXRSZWdleCIsICJzdGFydCIsICJOb2RlIiwgImNvbW1hbmRzIiwgImlucHV0UmVnZXgiLCAicGFzdGVSZWdleCIsICJNYXJrIiwgInN0eWxlIiwgImNvbW1hbmRzIiwgIlRleHQiLCAiTm9kZSIsICJleHRlbnNpb25zIiwgIkxpc3RJdGVtIiwgIlRleHQiLCAiY3R4IiwgInVwZGF0ZUF0dHJpYnV0ZXMiLCAiU2NyaWJibGVCbG9ja19kZWZhdWx0IiwgIk5vZGUiLCAidHIiLCAidGV4dCIsICJmcm9tIiwgImNvbW1hbmQiLCAicmVuZGVyIiwgIl9hIiwgImVtcHR5IiwgImN0eCIsICJkaXYiLCAibWFwIiwgInIiLCAiZWxlbWVudCIsICJNYXJrIiwgImNvbW1hbmRzIiwgIk1hcmsiLCAiY29tbWFuZHMiLCAiZWxlbWVudCIsICJjb21tYW5kcyIsICJUZXh0U3R5bGUiLCAiTWFyayIsICJlbGVtZW50IiwgImNvbW1hbmRzIiwgImN0eCIsICJjcmVhdGVfaWZfYmxvY2siLCAiY3R4IiwgInVwZGF0ZUF0dHJpYnV0ZXMiLCAiTm9kZSIsICJlbGVtZW50IiwgImNvbW1hbmRzIiwgImN0eCIsICJkaXYiLCAiY3JlYXRlX2lmX2Jsb2NrXzMiLCAiY3JlYXRlX2lmX2Jsb2NrIiwgImVsZW1lbnQiLCAiU2NyaWJibGVCbG9ja19kZWZhdWx0IiwgIlRleHRTdHlsZSIsICJlZGl0b3IiLCAiZnJvbSIsICJpc0FjdGl2ZSJdCn0K
